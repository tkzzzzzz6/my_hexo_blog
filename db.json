{"meta":{"version":1,"warehouse":"5.0.1"},"models":{"Asset":[{"_id":"themes/hingle/source/static/kico.css","path":"static/kico.css","modified":0,"renderable":1},{"_id":"themes/hingle/source/static/hingle.css","path":"static/hingle.css","modified":0,"renderable":1},{"_id":"themes/hingle/source/static/hingle.js","path":"static/hingle.js","modified":0,"renderable":1},{"_id":"themes/hingle/source/static/kico.js","path":"static/kico.js","modified":0,"renderable":1},{"_id":"themes/hingle/source/static/img/icon.png","path":"static/img/icon.png","modified":0,"renderable":1},{"_id":"source/CNAME","path":"CNAME","modified":1,"renderable":0}],"Cache":[{"_id":"source/_posts/2025-02-09-wsl启动报错Cannot execute daemonize to start systemd的解决方法.md","hash":"19bb135c2c3839e7e3380fe8d15e989beaab7613","modified":1758888895495},{"_id":"source/_posts/2025-02-10-文言文背诵检测程序开发.md","hash":"7bcc2c8d4e1ba12dd00c77386f01cd4dbe2d8773","modified":1758888901414},{"_id":"source/_posts/2025-02-08-提示词.md","hash":"59e34f8866b8c7dafb2280a457ec8b8e7b9c8965","modified":1758887096720},{"_id":"source/_posts/2025-02-11-数模笔记_微分方程与差分方程.md","hash":"dca4aa60a7baf8d72377b06d30335b06067b7565","modified":1758888904954},{"_id":"source/_posts/2025-02-16-全景分割.md","hash":"e06416699b0e44204080cb00a8d1a0a13e04e460","modified":1758888916487},{"_id":"source/_posts/2025-02-16-实例分割.md","hash":"3426c5724d981466f76971607bbc71c125b73561","modified":1758888921847},{"_id":"source/_posts/2025-02-17-语义分割、实例分割与全景分割三种分割技术的对比.md","hash":"0bd9e1bdc9c0dcbcaa850ae7b066737f1937adf7","modified":1758888925024},{"_id":"source/_posts/2025-03-01-牛客周赛83.md","hash":"f13b163fa4d49b2720b558096cd4f59809c0abbd","modified":1758888935385},{"_id":"source/_posts/2025-02-23-abc394.md","hash":"5db6d0746019a1f39c14c7afe7a223d6f426b235","modified":1758888928974},{"_id":"source/_posts/2025-03-03-java作业(week2).md","hash":"73b9c3907d5b3b09de8e8b20e01ca374ec4fdaff","modified":1758888938944},{"_id":"source/_posts/2025-02-15-语义分割.md","hash":"48e1347cb26ce5ff83dee25b06a0c6844fa41b7c","modified":1758888908448},{"_id":"source/_posts/2025-03-04-判断素数.md","hash":"c4ea12f0223e57dbdc0cbd45943527526f115986","modified":1758888944193},{"_id":"source/_posts/2025-03-05-判断回文数.md","hash":"bc9fab3224125daf132dba3e1aef24d72da9e69f","modified":1758888969674},{"_id":"source/_posts/2025-03-14-Google检索技巧.md","hash":"a787431a87351667cb346d17b5f7d5d448cae6b1","modified":1758888963766},{"_id":"source/_posts/2025-03-15-位运算.md","hash":"9644183b0dbb06611dcaa417624f30b92d2deeaf","modified":1758888976014},{"_id":"source/_posts/2025-03-12-Bunny轻量级多模态语言模型家族.md","hash":"0666bb0b568a637b52cae3d3ed8e3be61770965b","modified":1758888966623},{"_id":"source/_posts/2025-03-16-水“镜”安澜——基于YOLO11的智能溺水检测系统软件 V1.0 设计说明文档.md","hash":"cc7206be2551012bf9a932047677521e107887bd","modified":1758888978855},{"_id":"source/_posts/2025-03-18-VitPose基于vit的姿态评估模型.md","hash":"fddbb44e2571a1bbb0f686672b306060d752de6f","modified":1758888985850},{"_id":"source/_posts/2025-03-17-构造函数与析构函数.md","hash":"338f9d5a2bbdba352ecf9a73b61ab6e325a921ca","modified":1758888982047},{"_id":"source/_posts/2025-03-20-使用word文档导出功能压缩图片的技巧.md","hash":"fa0dc8bc93678973becfb6fd9058c3910c63abae","modified":1758888989077},{"_id":"source/_posts/2025-03-28-Tmux(multi-shell manager)command summary.md","hash":"1c6df766315c7ed91cda3ec6744bd51339003ed4","modified":1758888992127},{"_id":"source/_posts/2025-04-02-JAVA作业_图书管理系统_week4.md","hash":"173389bde9eff7ec4a0727fa44c159592dadf8fd","modified":1758888996515},{"_id":"source/_posts/2025-04-10-汇编语言实验1_debug命令.md","hash":"b8ee317bedb44a4a60bd509c058b7e830e595929","modified":1758889000701},{"_id":"source/_posts/2025-04-15-二进制思想在计算机科学中的应用.md","hash":"24a3cc2a6ef31dd002865d2fb5c7baa85ad05bf6","modified":1758889009430},{"_id":"source/_posts/2025-04-28-堆、栈及其应用分析.md","hash":"576bbaa6e77f599efbf63c1d72652fe12224cd7e","modified":1758889029607},{"_id":"source/_posts/2025-04-23-基于上下位机结构的系统实例分析.md","hash":"eb4ca310f4192b2f34d6f5371644537f62b33ee3","modified":1758889024622},{"_id":"source/_posts/2025-05-05-80x86汇编语言环境配置.md","hash":"97382483dd71157c2a13741625178b094a5b4682","modified":1758889037696},{"_id":"source/_posts/2025-04-22-X86 架构与 Arm 架构异同及应用.md","hash":"25b89dec65b133bdfbe98607a1d55d1b9db2499a","modified":1758889021068},{"_id":"source/_posts/2025-05-01-决策树算法及应用.md","hash":"6ae1dbca8033f466f89eafd9ec6a97e48189824d","modified":1758889033227},{"_id":"source/_posts/2025-04-20-CPU-GPU-NPU 的区别及应用前景.md","hash":"dc53e817605e7be1de031af1f02ecb4b317247aa","modified":1758889015238},{"_id":"source/_posts/2025-05-06-Windows系统将安装过系统镜像的固态硬盘恢复.md","hash":"adde44daed26b632300a2849b78dc461c059a261","modified":1758889041349},{"_id":"source/_posts/2025-05-07-二分查找.md","hash":"a32e81ced6cea4c91ee1bf935c0d8fec63192abb","modified":1758889046646},{"_id":"source/_posts/2025-05-09-进程调度算法分析.md","hash":"07bf2d26ff45a48221ba3f8e391c169ffab7b5fa","modified":1758889055470},{"_id":"source/_posts/2025-05-12-虚函数.md","hash":"842289fd02e2d03c1e278c05e649e7f37ca6a76a","modified":1758889067396},{"_id":"source/_posts/2025-05-08-deepseek本地化部署.md","hash":"37b4164f8f4ff4adcdacb8633fb83223274f46e9","modified":1758889051223},{"_id":"source/_posts/2025-05-11-域适应(Domain Adaptation).md","hash":"4da3bd5e896bf05978c041c324466ef180f6eb6e","modified":1758889063892},{"_id":"source/_posts/2025-05-17-scBridge embraces cell heterogeneity in single-cell RNA-seq and ATAC-seq data integration.md","hash":"0d0591d43e84c780efc868f60a05c4f80b79436d","modified":1758889072217},{"_id":"source/_posts/2025-05-11-银行家算法分析.md","hash":"8e29e769a209b5b189690baddd59ed52267985ea","modified":1758889059591},{"_id":"source/_posts/2025-05-21-汇编语言键盘输入输出.md","hash":"1494e7e7e27f06b91d10105819eb1fed794fc66b","modified":1758889077147},{"_id":"source/_posts/2025-06-04-低代码平台及相关技术介绍.md","hash":"615d02cd4e5829efc756349b989df4b684d29172","modified":1758889095241},{"_id":"source/_posts/2025-06-01-Hive 技术及应用介绍.md","hash":"fcbdd959235572798b2a58fc0bc9816d011b5a41","modified":1758889080834},{"_id":"source/_posts/2025-06-02-IP 地址规划及案例分析.md","hash":"4c1df6016034368d6ec9dc4ed9847cec49e597e3","modified":1758889088131},{"_id":"source/_posts/2025-06-03-微信小程序开发框架详解.md","hash":"92dbf7387214d143e184b381c2f5389e8412ec60","modified":1758889091650},{"_id":"source/_posts/2025-06-02-数据库的分类和应用.md","hash":"5e2b76297b0a7d3d91af0ae975a87b76a5376fc6","modified":1758889084926},{"_id":"source/_posts/2025-06-05-智能体平台及关键技术分析.md","hash":"72bfdb55a07953bd6ebf2da04ffd5a253ed819e7","modified":1758889099129},{"_id":"source/_posts/2025-06-08-大模型底层技术分析.md","hash":"15a503c14ce2fe8b4e367a6fca92432ed6c0d721","modified":1758889103194},{"_id":"source/_posts/2025-07-29-九格通用基础大模型环境配置.md","hash":"f964196032223745f63df0b025b0f0671cf4e462","modified":1758889109302},{"_id":"source/_posts/2025-07-03-拯救我的“高烧”战友——Y7000P 2024版清灰换硅脂记录.md","hash":"ed4774a3b8c6c4f91bfa2aa2fabb6a0d41f56aca","modified":1758889106084},{"_id":"themes/hingle/layout/index.ejs","hash":"9bcb0ddbe47e19149c6b50b0dc669955d7804caa","modified":1758857066902},{"_id":"themes/hingle/.gitignore","hash":"1e51bee1ec3527ff3e2d6818a5367b5d81c69038","modified":1758857066768},{"_id":"themes/hingle/LICENSE","hash":"4de1840f7346984f481500155ab438f0fdd12634","modified":1758857066773},{"_id":"themes/hingle/README.md","hash":"71d1762328de3b6eb7c0536c2d414e8221be0742","modified":1758857066780},{"_id":"themes/hingle/layout/post.ejs","hash":"69cae3890cb41aef16b4bb80ac1b135afa6ca9e8","modified":1758857066913},{"_id":"themes/hingle/layout/archive.ejs","hash":"90eff02318b17c6eff80021d9a32c2a680415d29","modified":1758857066897},{"_id":"themes/hingle/layout/layout.ejs","hash":"8bdd50a2138545c6b27b00d70973a58ddbf2784c","modified":1758857066904},{"_id":"themes/hingle/_config.yml","hash":"75bfc8d8ad9fe5db69f35ac6f34a4ffb93945382","modified":1758870960585},{"_id":"themes/hingle/layout/page.ejs","hash":"c0cb64ef3215a041c077d91adc911b2f8380c6c1","modified":1758857066909},{"_id":"themes/hingle/source/static/hingle.js","hash":"c58cbe224adaa51143cd2b9d79bb11c459bf9b4d","modified":1758857066932},{"_id":"themes/hingle/source/static/hingle.css","hash":"b8f3dfcee2770288a489ea5a916d38145426a620","modified":1758857066924},{"_id":"themes/hingle/source/static/kico.js","hash":"353d3ece9b5020bdac573c35fece1455e72b40ee","modified":1758857067382},{"_id":"themes/hingle/layout/_partial/social.ejs","hash":"482bf0adfb597d2a3f54a28adde9c9f7c4a93300","modified":1758857066892},{"_id":"themes/hingle/layout/_partial/footer.ejs","hash":"dc2758ef7ac3c53587042d671e4a9e5f3c36d7c8","modified":1758857066855},{"_id":"themes/hingle/layout/_partial/head.ejs","hash":"0e82d9eaa440bee53350357143d511486ab3296c","modified":1758857066874},{"_id":"themes/hingle/layout/_partial/header.ejs","hash":"cf2828de5a125d425c24e0940c578979309d25bd","modified":1758857066884},{"_id":"themes/hingle/source/static/img/icon.png","hash":"2f02d8ad49d7efee4b49fa6287297dd53a112440","modified":1758857067356},{"_id":"themes/hingle/layout/_partial/archive-list.ejs","hash":"d0ff1db7c10c68230f4ee8f7052bf68aa1301f13","modified":1758857066831},{"_id":"themes/hingle/source/static/kico.css","hash":"5cfb69fc5cb76f93d39a95ee571160262388659f","modified":1758857067368},{"_id":"public/2025/02/08/2025-02-08-提示词/index.html","hash":"c5ce864149eaa1c6371d0add9b3c55b625435d64","modified":1758890918767},{"_id":"public/1970/01/01/2025-02-10-文言文背诵检测程序开发/index.html","hash":"661df0d2f7e9a5b6cef179aa3b8f8b6b60fbd562","modified":1758888608235},{"_id":"public/1970/01/01/2025-02-15-语义分割/index.html","hash":"10230deaab29bda8c2581e7d2b87418b7233818e","modified":1758888608235},{"_id":"public/1970/01/01/2025-02-09-wsl启动报错Cannot execute daemonize to start systemd的解决方法/index.html","hash":"245cfa17dace26032ec1a2382ecbfe020e9f83ec","modified":1758888608235},{"_id":"public/1970/01/01/2025-02-16-实例分割/index.html","hash":"a639596d89b40c3e4e9630a9422c044b0e78c040","modified":1758888608235},{"_id":"public/1970/01/01/2025-02-23-abc394/index.html","hash":"04a4a55a168031a246a5c00fd5edad17dda66875","modified":1758888608235},{"_id":"public/1970/01/01/2025-03-01-牛客周赛83/index.html","hash":"44af33c81d330da79accc4e13ab5147b0857913e","modified":1758888608235},{"_id":"public/1970/01/01/2025-02-16-全景分割/index.html","hash":"d07d24b44a6a261416f11726cf467cf6936ef8f5","modified":1758888608235},{"_id":"public/1970/01/01/2025-03-04-判断素数/index.html","hash":"21dfe3997c9959cea09c5ed2148cf7cd29e4eda7","modified":1758888608235},{"_id":"public/1970/01/01/2025-03-03-java作业(week2)/index.html","hash":"45ce059675ef70b2a38c9dc388c74fe6fca07fe9","modified":1758888608235},{"_id":"public/1970/01/01/2025-03-14-Google检索技巧/index.html","hash":"8b7c5a944f99f9ac7ee8a7856793ab726b38e181","modified":1758888608235},{"_id":"public/1970/01/01/2025-03-05-判断回文数/index.html","hash":"bf121216dd25ff0125dd4f00a21c51800381fe09","modified":1758888608235},{"_id":"public/1970/01/01/2025-03-15-位运算/index.html","hash":"98fc689d78bc2863894535258fb2b83446a987b6","modified":1758888608235},{"_id":"public/1970/01/01/2025-03-18-VitPose基于vit的姿态评估模型/index.html","hash":"8619db4b832baae6ce4aca6a39d3165ed7fd31c7","modified":1758888608235},{"_id":"public/1970/01/01/2025-03-20-使用word文档导出功能压缩图片的技巧/index.html","hash":"7144dcee26f94f0bcdde109990cc86b48c466358","modified":1758888608235},{"_id":"public/1970/01/01/2025-03-16-水“镜”安澜——基于YOLO11的智能溺水检测系统软件 V1.0 设计说明文档/index.html","hash":"d834b1376ebd097abf4b600089033f4bd173609e","modified":1758888608235},{"_id":"public/1970/01/01/2025-03-28-Tmux(multi-shell manager)command summary/index.html","hash":"69046fa24a55f286ef4def8a7bf5aad0584f75c2","modified":1758888608235},{"_id":"public/1970/01/01/2025-04-15-二进制思想在计算机科学中的应用/index.html","hash":"b89ee56238bdfb0be5a1734411fbfdb0cbbca0e1","modified":1758888608235},{"_id":"public/1970/01/01/2025-03-17-构造函数与析构函数/index.html","hash":"0d572a699f7717c7f82c77629121453b52d1ae24","modified":1758888608235},{"_id":"public/1970/01/01/2025-04-22-X86 架构与 Arm 架构异同及应用/index.html","hash":"d822fa3373957bb1478f152c1facea100570e3eb","modified":1758888608235},{"_id":"public/1970/01/01/2025-03-12-Bunny轻量级多模态语言模型家族/index.html","hash":"0d470c012c99af67d261b2aa6376c242c71a6be2","modified":1758888608235},{"_id":"public/1970/01/01/2025-04-23-基于上下位机结构的系统实例分析/index.html","hash":"69854dbc40245e97357f1f44600932aa7d39b0d8","modified":1758888608235},{"_id":"public/1970/01/01/2025-04-02-JAVA作业_图书管理系统_week4/index.html","hash":"117157212403d939aa24c5a97bea95451d0dfb12","modified":1758888608235},{"_id":"public/1970/01/01/2025-04-10-汇编语言实验1_debug命令/index.html","hash":"d91725c7b9c0a5cba0f0c8f2ef8dc0d55e4b4fcd","modified":1758888608235},{"_id":"public/1970/01/01/2025-04-28-堆、栈及其应用分析/index.html","hash":"5bda2a38fcb7243a3c1168bac5182b5f81752efd","modified":1758888608235},{"_id":"public/1970/01/01/2025-05-06-Windows系统将安装过系统镜像的固态硬盘恢复/index.html","hash":"4baa3a009e78fedab8b63b7bf1ef41e82c59bd09","modified":1758888608235},{"_id":"public/1970/01/01/2025-05-01-决策树算法及应用/index.html","hash":"d0685022f17db42d56a72dd8c69d89d76bf147c4","modified":1758888608235},{"_id":"public/1970/01/01/2025-05-05-80x86汇编语言环境配置/index.html","hash":"b63a740ae6dbf5b50ef7e7917421eb8b004e36bb","modified":1758888608235},{"_id":"public/1970/01/01/2025-05-09-进程调度算法分析/index.html","hash":"168389175f33fee8591488a80547a8609c3941dd","modified":1758888608235},{"_id":"public/1970/01/01/2025-05-07-二分查找/index.html","hash":"679b44c283cb991487f04c83d1eb6f5cdfaa0904","modified":1758888608235},{"_id":"public/1970/01/01/2025-05-12-虚函数/index.html","hash":"7abdf4ba2c38578177d26a3938a6b9dce9020622","modified":1758888608235},{"_id":"public/1970/01/01/2025-04-20-CPU-GPU-NPU 的区别及应用前景/index.html","hash":"852755fe7227865bbe64112b76c45d0f6ccad7f6","modified":1758888608235},{"_id":"public/1970/01/01/2025-05-08-deepseek本地化部署/index.html","hash":"85a4873703f8282396eed279a9e10a71a9e6e373","modified":1758888608235},{"_id":"public/1970/01/01/2025-05-11-域适应(Domain Adaptation)/index.html","hash":"499875451adf241561098fe341b8c572c79a6fe8","modified":1758888608235},{"_id":"public/1970/01/01/2025-05-11-银行家算法分析/index.html","hash":"16e99bf7134d6f832a376b067b392dc000cac375","modified":1758888608235},{"_id":"public/1970/01/01/2025-05-17-scBridge embraces cell heterogeneity in single-cell RNA-seq and ATAC-seq data integration/index.html","hash":"228e5f3bdfaac7ddc61d6c651313e4343f372b99","modified":1758888608235},{"_id":"public/1970/01/01/2025-06-01-Hive 技术及应用介绍/index.html","hash":"d104945a8b50581f4e2765c1d181c4783754fa02","modified":1758888608235},{"_id":"public/1970/01/01/2025-05-21-汇编语言键盘输入输出/index.html","hash":"160bd67886ccbaea0297a06940714a5b1c4116c7","modified":1758888608235},{"_id":"public/1970/01/01/2025-06-03-微信小程序开发框架详解/index.html","hash":"3398485c5078d74839bcfc64dcbc5aaadc9a5d5b","modified":1758888608235},{"_id":"public/1970/01/01/2025-06-02-数据库的分类和应用/index.html","hash":"6d90c17653ee5faab3bccf90d9944616cdaef9de","modified":1758888608235},{"_id":"public/1970/01/01/2025-06-02-IP 地址规划及案例分析/index.html","hash":"07685b9be1db0d3965ee763a0363c13acc5c3695","modified":1758888608235},{"_id":"public/1970/01/01/2025-07-29-九格通用基础大模型环境配置/index.html","hash":"e8e6bc87a0b0140ae7ed0de8c68969aa6b25b2ef","modified":1758888608235},{"_id":"public/1970/01/01/2025-06-08-大模型底层技术分析/index.html","hash":"464c64ba9fe46957e9a862c5adc166bf7b9d4234","modified":1758888608235},{"_id":"public/1970/01/01/2025-06-04-低代码平台及相关技术介绍/index.html","hash":"ccf0d94ed36b92fbfc78d6cf8269bce0dfccc288","modified":1758888608235},{"_id":"public/1970/01/01/2025-06-05-智能体平台及关键技术分析/index.html","hash":"d99db26524fcf6cd602ce0e3f702b393ae0b41ee","modified":1758888608235},{"_id":"public/1970/01/01/2025-07-03-拯救我的“高烧”战友——Y7000P 2024版清灰换硅脂记录/index.html","hash":"a8146ca22ab5e0fa0c1d3e44aa99a8f890ca7c7c","modified":1758888608235},{"_id":"public/1970/01/01/2025-02-11-数模笔记_微分方程与差分方程/index.html","hash":"47f3d306dba0ca25107b84e8294be39dec5bead1","modified":1758888608235},{"_id":"public/archives/index.html","hash":"ce7bea55789f98721f70b89755e0e1e604b7c0d8","modified":1758890918767},{"_id":"public/archives/page/4/index.html","hash":"2ef1764fda34451127c07b02920b6d13d771d6c0","modified":1758890918767},{"_id":"public/archives/page/5/index.html","hash":"719aed327799d9ed1c71ead31b09f818a1a94aad","modified":1758890918767},{"_id":"public/archives/1970/index.html","hash":"9a88f68552d16878bf9f954ceb5c2386f901dea7","modified":1758888608235},{"_id":"public/archives/1970/page/2/index.html","hash":"e38676a561ead7b61e1557fce5a5ff0638b22d11","modified":1758888608235},{"_id":"public/archives/1970/page/3/index.html","hash":"488989218387a502c7da6f6930fa5b293134cfe0","modified":1758888608235},{"_id":"public/archives/1970/page/4/index.html","hash":"57c9c304d85ff9990b4067b1a8863cbc83cb68da","modified":1758888608235},{"_id":"public/archives/1970/page/5/index.html","hash":"df5df649254a65bae1e0c6e3c5c31e3b53d8cf22","modified":1758888608235},{"_id":"public/archives/1970/01/index.html","hash":"f69b2e6d30632af7ad63ad057e6a9b9a91e60dc2","modified":1758888608235},{"_id":"public/archives/1970/01/page/2/index.html","hash":"ff66ee3b765775ed8927060d917803240bc6ab89","modified":1758888608235},{"_id":"public/archives/1970/01/page/3/index.html","hash":"457f7d11e4e2e557fc30ee9b6e62149ec1424bb0","modified":1758888608235},{"_id":"public/archives/1970/01/page/4/index.html","hash":"fa32a18e04a5226a7260005cf2a8b88384bfd489","modified":1758888608235},{"_id":"public/archives/1970/01/page/5/index.html","hash":"841374867a7ec47a859e6703feea0c3d2fb2bf2e","modified":1758888608235},{"_id":"public/archives/2025/index.html","hash":"7f5fd6f0a18938e6e33b030f7f4e4132d271935a","modified":1758890918767},{"_id":"public/archives/2025/02/index.html","hash":"e2c3c1ebbc25558c53263ca82a88394725d1e4d3","modified":1758890918767},{"_id":"public/archives/page/3/index.html","hash":"34019483e241d15681f38dd55eb9a99ac8772699","modified":1758890918767},{"_id":"public/archives/page/2/index.html","hash":"f3f36d1670f922ef8ad98fcd76c5be123420de4a","modified":1758890918767},{"_id":"public/1970/01/01/2025-02-17-语义分割、实例分割与全景分割三种分割技术的对比/index.html","hash":"6ebcff0227d871e8e529e46e531743986fc88961","modified":1758888608235},{"_id":"public/index.html","hash":"3c530714b01180440b547ce35c7ae0dba473bc6a","modified":1758890918767},{"_id":"public/page/2/index.html","hash":"5ec745d2c149658695a5943133b4e20ff32be153","modified":1758890918767},{"_id":"public/page/5/index.html","hash":"f73619df927974309b965417323b65ca18472743","modified":1758890918767},{"_id":"public/page/4/index.html","hash":"7909473e2ef6b253ce11d6e816d820eb7a924c3c","modified":1758890918767},{"_id":"public/page/3/index.html","hash":"6ebdcc22ee8d9c066b41bbbe1282700d2dbcc5cc","modified":1758890918767},{"_id":"public/tags/问题解决/index.html","hash":"006b6d79509a03baa29ba88ac1f3f9e9bffbeded","modified":1758890918767},{"_id":"public/tags/算法练习/index.html","hash":"3fc10451a63f08cd84819f8bcab240508d540c64","modified":1758890918767},{"_id":"public/tags/深度学习-论文阅读/index.html","hash":"c13dd291f05eacbe5df14b9651358f67c4737a9d","modified":1758890918767},{"_id":"public/tags/课程学习/index.html","hash":"9d431c77b3fdc3fcc92c8b6b1ed18b7e537e2f01","modified":1758890918767},{"_id":"public/tags/课程学习/page/2/index.html","hash":"36a36c3d22fce630f6954ee4e121e02d6629b837","modified":1758890918767},{"_id":"public/tags/算法学习/index.html","hash":"cee00094bb31a6e7aa586453dfeaa42daa5b42fa","modified":1758890918767},{"_id":"public/tags/深度学习-程序开发/index.html","hash":"fdec06bdce77f6c903f2c93dbdddfab694bdb763","modified":1758890918767},{"_id":"public/tags/深度学习/index.html","hash":"95d37ad93a7768647ec21b3a45195d8fb884563e","modified":1758890918767},{"_id":"public/tags/数学建模/index.html","hash":"ce5064ddcbbbbe4cddbf31a2fac23b162d20b799","modified":1758890918767},{"_id":"public/tags/程序开发/index.html","hash":"45e7f5e518896ba4d3248fd51e25fdf3c31c3cd7","modified":1758890918767},{"_id":"public/static/img/icon.png","hash":"2f02d8ad49d7efee4b49fa6287297dd53a112440","modified":1758887547056},{"_id":"public/static/hingle.js","hash":"c58cbe224adaa51143cd2b9d79bb11c459bf9b4d","modified":1758887547056},{"_id":"public/static/kico.css","hash":"5cfb69fc5cb76f93d39a95ee571160262388659f","modified":1758887547056},{"_id":"public/static/kico.js","hash":"353d3ece9b5020bdac573c35fece1455e72b40ee","modified":1758887547056},{"_id":"public/static/hingle.css","hash":"b8f3dfcee2770288a489ea5a916d38145426a620","modified":1758887547056},{"_id":"source/about/index.md","hash":"51d1b77550dde12e87e7fdfb711d5d2af774c697","modified":1758888402192},{"_id":"source/friends/index.md","hash":"0ea0e266b381b446e04f1d1b39d441970e54e017","modified":1758888402199},{"_id":"public/friends/index.html","hash":"2fa6b50685cdbc35bdc673bd2a66c81a0368a870","modified":1758890918767},{"_id":"public/about/index.html","hash":"2fae5388682bfc422cbda50d1b58de5477183b72","modified":1758890918767},{"_id":"public/2025/07/29/2025-07-29-九格通用基础大模型环境配置/index.html","hash":"acd0220ee63ade3229b3c966eb074c423f05a424","modified":1758890918767},{"_id":"public/2025/07/03/2025-07-03-拯救我的“高烧”战友——Y7000P 2024版清灰换硅脂记录/index.html","hash":"b3a4ca89c0c40785b570c19578637789a3144dbf","modified":1758890918767},{"_id":"public/2025/06/08/2025-06-08-大模型底层技术分析/index.html","hash":"1b6f745fa5c2902f304451f3413bcd2103258169","modified":1758890918767},{"_id":"public/2025/06/03/2025-06-03-微信小程序开发框架详解/index.html","hash":"12cfc5ae8a7492a7687aaec6ad2362766e976dee","modified":1758890918767},{"_id":"public/2025/06/02/2025-06-02-数据库的分类和应用/index.html","hash":"e87ef33572b5d206f84687415abd2e6b98b51675","modified":1758890918767},{"_id":"public/2025/06/04/2025-06-04-低代码平台及相关技术介绍/index.html","hash":"31f3402d233cf687ab665e1f2ed760a6398945d3","modified":1758890918767},{"_id":"public/2025/06/01/2025-06-01-Hive 技术及应用介绍/index.html","hash":"01f921d9c60ca618d3ef0a6f48f2c32bcab06694","modified":1758890918767},{"_id":"public/2025/06/02/2025-06-02-IP 地址规划及案例分析/index.html","hash":"bc13314bfe04a0f671d93d0e2884d0b1ffee0683","modified":1758890918767},{"_id":"public/2025/06/05/2025-06-05-智能体平台及关键技术分析/index.html","hash":"edf7852cfd83f400076247f7c6a15daf46fddfb4","modified":1758890918767},{"_id":"public/2025/05/17/2025-05-17-scBridge embraces cell heterogeneity in single-cell RNA-seq and ATAC-seq data integration/index.html","hash":"8b8381cf3e77e35f9e5ca10426f4a4d713f375f8","modified":1758890918767},{"_id":"public/2025/05/11/2025-05-11-域适应(Domain Adaptation)/index.html","hash":"a7f3252a08b834a4f07afb1dd69df1fb06779476","modified":1758890918767},{"_id":"public/2025/05/12/2025-05-12-虚函数/index.html","hash":"08ff1fa279d8762225f74299faa0b30264b62137","modified":1758890918767},{"_id":"public/2025/05/11/2025-05-11-银行家算法分析/index.html","hash":"54acef869439114b3fdb08eadd4002b3b67e4dfd","modified":1758890918767},{"_id":"public/2025/05/09/2025-05-09-进程调度算法分析/index.html","hash":"338cb81d0ffccc4b04148330d1e90593e2a01712","modified":1758890918767},{"_id":"public/2025/05/08/2025-05-08-deepseek本地化部署/index.html","hash":"430865039c3326357aa5773f5c9e6dfeb8df16a0","modified":1758890918767},{"_id":"public/2025/05/07/2025-05-07-二分查找/index.html","hash":"836c6c7fe4c4628416ccc6b8ef007466ec00067b","modified":1758890918767},{"_id":"public/2025/05/06/2025-05-06-Windows系统将安装过系统镜像的固态硬盘恢复/index.html","hash":"22c2bd64cb5210b486b5eddb6c53b7ee582f9144","modified":1758890918767},{"_id":"public/2025/05/05/2025-05-05-80x86汇编语言环境配置/index.html","hash":"ad7312bff2d9bebf2a03ffdd3d342aec09ca77af","modified":1758890918767},{"_id":"public/2025/05/01/2025-05-01-决策树算法及应用/index.html","hash":"6261b22153ace83a3d5b9abff7fad5f72b68a3fc","modified":1758890918767},{"_id":"public/2025/05/21/2025-05-21-汇编语言键盘输入输出/index.html","hash":"ad9de991766d4c310e7e5d8f51e23af516973e81","modified":1758890918767},{"_id":"public/2025/04/20/2025-04-20-CPU-GPU-NPU 的区别及应用前景/index.html","hash":"104796dabb100fe20d21e6fb738b804a84c7d150","modified":1758890918767},{"_id":"public/2025/04/23/2025-04-23-基于上下位机结构的系统实例分析/index.html","hash":"cebf3766ba6043d47cf12ca2c6bb591097e12dcf","modified":1758890918767},{"_id":"public/2025/04/28/2025-04-28-堆、栈及其应用分析/index.html","hash":"094ee85d1581ecc38df918735e7021b559be5990","modified":1758890918767},{"_id":"public/2025/04/15/2025-04-15-二进制思想在计算机科学中的应用/index.html","hash":"0c8379988ba2a535207cac6e01dcf969ece00b7d","modified":1758890918767},{"_id":"public/2025/04/10/2025-04-10-汇编语言实验1_debug命令/index.html","hash":"65e80397748b289e05999f1920e52bacce7c8577","modified":1758890918767},{"_id":"public/2025/04/02/2025-04-02-JAVA作业_图书管理系统_week4/index.html","hash":"15bd5105f41631494e37717e985c9293304cdc81","modified":1758890918767},{"_id":"public/2025/04/22/2025-04-22-X86 架构与 Arm 架构异同及应用/index.html","hash":"5d477253edd804ac9c2dbb7ac026697fd1076120","modified":1758890918767},{"_id":"public/2025/03/20/2025-03-20-使用word文档导出功能压缩图片的技巧/index.html","hash":"f00f0d8c2a2d4a534b6ce0d565d64712974c5250","modified":1758890918767},{"_id":"public/2025/03/17/2025-03-17-构造函数与析构函数/index.html","hash":"47e50c16d0af678fd3b3bed616d00762c5f640c6","modified":1758890918767},{"_id":"public/2025/03/28/2025-03-28-Tmux(multi-shell manager)command summary/index.html","hash":"c63bb6cac841fa02b6d0a57a1a5d4a833033a983","modified":1758890918767},{"_id":"public/2025/03/16/2025-03-16-水“镜”安澜——基于YOLO11的智能溺水检测系统软件 V1.0 设计说明文档/index.html","hash":"5a6dd3a352004dd98ddb56427a612dd73b428d12","modified":1758890918767},{"_id":"public/2025/03/12/2025-03-12-Bunny轻量级多模态语言模型家族/index.html","hash":"5d18154f6f9820697e4d981fc314705bfd3d1c53","modified":1758890918767},{"_id":"public/2025/03/15/2025-03-15-位运算/index.html","hash":"40e1493d792905aff1930698137f48bb11a4b098","modified":1758890918767},{"_id":"public/2025/03/05/2025-03-05-判断回文数/index.html","hash":"0c03b4a7be7bcfe4276d1f395b514f7017d50349","modified":1758890918767},{"_id":"public/2025/03/04/2025-03-04-判断素数/index.html","hash":"d89aeda399d6153892c40bd32b1690bed32bd0ff","modified":1758890918767},{"_id":"public/2025/03/03/2025-03-03-java作业(week2)/index.html","hash":"64d07bea65f901083e29c1aaa0f7fa5ebbdac1af","modified":1758890918767},{"_id":"public/2025/03/01/2025-03-01-牛客周赛83/index.html","hash":"0d44513c144fa28dc109533ba0a16b43a8ad1d3f","modified":1758890918767},{"_id":"public/2025/03/14/2025-03-14-Google检索技巧/index.html","hash":"abc3167e91e15a6570bee968013070bbda9be934","modified":1758890918767},{"_id":"public/2025/03/18/2025-03-18-VitPose基于vit的姿态评估模型/index.html","hash":"5157483b79d6df0492efb840d4b0d27dfdbd3fd0","modified":1758890918767},{"_id":"public/2025/02/23/2025-02-23-abc394/index.html","hash":"24fdcf9009b6d0f6f193ca350ef81fedcb1d46cb","modified":1758890918767},{"_id":"public/2025/02/17/2025-02-17-语义分割、实例分割与全景分割三种分割技术的对比/index.html","hash":"67f4216ca23062a79c3fb4213bce9e731c2ea3f0","modified":1758890918767},{"_id":"public/2025/02/16/2025-02-16-实例分割/index.html","hash":"2b4104b0a5feb592976ae562be34dea8c66c0eea","modified":1758890918767},{"_id":"public/2025/02/16/2025-02-16-全景分割/index.html","hash":"c9e4e305a336a7812de97f94b27313a9cf5197b2","modified":1758890918767},{"_id":"public/2025/02/15/2025-02-15-语义分割/index.html","hash":"c72a10ce30f43209f54c01fb1010658213c49ca1","modified":1758890918767},{"_id":"public/2025/02/11/2025-02-11-数模笔记_微分方程与差分方程/index.html","hash":"cb19f8f97c6d8c223f568a3b4a0993084ec2f2a4","modified":1758890918767},{"_id":"public/2025/02/09/2025-02-09-wsl启动报错Cannot execute daemonize to start systemd的解决方法/index.html","hash":"e49b62a2c0bdb94baed59f39eadcf45fa0ec5bca","modified":1758890918767},{"_id":"public/2025/02/10/2025-02-10-文言文背诵检测程序开发/index.html","hash":"0e0c72e6ce5b99eb4b32f61caf2205c1f982e46d","modified":1758890918767},{"_id":"public/archives/2025/page/2/index.html","hash":"7ec54ea412080b569e0c459ad4f3d601ceef1fb5","modified":1758890918767},{"_id":"public/archives/2025/page/3/index.html","hash":"b9fc6b5e0e7578fc5d7213216bcb18b4d418be4f","modified":1758890918767},{"_id":"public/archives/2025/page/4/index.html","hash":"2268955ad1723542c0efa4386cb8b1ec08510d05","modified":1758890918767},{"_id":"public/archives/2025/page/5/index.html","hash":"611b357f2ef790ff96f1dab2277dd492fc1659fb","modified":1758890918767},{"_id":"public/archives/2025/03/index.html","hash":"0d512f77e9eaced2cd41658e35d11ae3f317f6c7","modified":1758890918767},{"_id":"public/archives/2025/03/page/2/index.html","hash":"dd184a8e665f4e8ada766cce82b06d6b5a454134","modified":1758890918767},{"_id":"public/archives/2025/04/index.html","hash":"0988084d4d9968f15df8146c100b001b26c40446","modified":1758890918767},{"_id":"public/archives/2025/05/index.html","hash":"e112319ae1a728f3fcda1d50f11e5f1e875cdf04","modified":1758890918767},{"_id":"public/archives/2025/05/page/2/index.html","hash":"a8c2fe5ff64b4ceb25d2ba9360a2f10688e12f13","modified":1758890918767},{"_id":"public/archives/2025/06/index.html","hash":"635c02b13dee4ff373735fe4a64dd1eb7a406db1","modified":1758890918767},{"_id":"public/archives/2025/07/index.html","hash":"b3bcb7beee1d9f5db833fe25c89a9ad0b34cc60f","modified":1758890918767},{"_id":"source/CNAME","hash":"a54d1310d4e3dbf33b408aca9accf405aa9c39ab","modified":1739258027661},{"_id":"public/atom.xml","hash":"b5afeca4477930e7a56a86cad7630a58f80d87ee","modified":1758890918767},{"_id":"public/style.css","hash":"d8fd4b6e4ec9b6ad483069796dae3c50e6738da0","modified":1758890918767},{"_id":"public/bundle.js","hash":"03743f95973c413743046136a4ca35ab277d8b9c","modified":1758890918767},{"_id":"public/CNAME","hash":"a54d1310d4e3dbf33b408aca9accf405aa9c39ab","modified":1758890918767},{"_id":"public/live2dw/lib/L2Dwidget.min.js","hash":"5f1a807437cc723bcadc3791d37add5ceed566a2","modified":1758890918767},{"_id":"public/live2dw/lib/L2Dwidget.min.js.map","hash":"3290fe2df45f065b51a1cd7b24ec325cbf9bb5ce","modified":1758890918767},{"_id":"public/live2dw/lib/L2Dwidget.0.min.js","hash":"35bb5b588b6de25c9be2dd51d3fd331feafac02d","modified":1758890918767},{"_id":"public/live2dw/lib/L2Dwidget.0.min.js.map","hash":"35e71cc2a130199efb167b9a06939576602f0d75","modified":1758890918767}],"Category":[],"Data":[],"Page":[{"title":"朋友们","date":"2024-12-31T16:00:00.000Z","layout":"page","_content":"\n# 朋友们\n\n这里是我的朋友们和推荐的一些优秀博客！\n\n## 技术博客\n\n### 深度学习相关\n- [深度学习相关博客1](https://example.com) - 深度学习技术分享\n- [计算机视觉博客](https://example.com) - CV技术研究\n\n### 编程技术\n- [算法竞赛博客](https://example.com) - 算法学习与竞赛\n- [Web开发博客](https://example.com) - 前端后端技术\n\n### 数学建模\n- [数学建模博客](https://example.com) - 数模经验分享\n- [数据分析博客](https://example.com) - 数据处理与分析\n\n## 学习资源\n\n### 在线课程\n- [Coursera深度学习课程](https://www.coursera.org)\n- [edX计算机科学课程](https://www.edx.org)\n\n### 技术文档\n- [PyTorch官方文档](https://pytorch.org/docs/)\n- [TensorFlow官方文档](https://tensorflow.org/docs/)\n\n## 推荐网站\n\n### 编程学习\n- [LeetCode](https://leetcode.cn) - 算法刷题\n- [GitHub](https://github.com) - 代码托管\n- [Stack Overflow](https://stackoverflow.com) - 技术问答\n\n### 学术资源\n- [arXiv](https://arxiv.org) - 学术论文\n- [Google Scholar](https://scholar.google.com) - 学术搜索\n\n---\n\n## 友链申请\n\n如果你也想交换友链，欢迎联系我！\n\n**申请要求**：\n- 技术类博客或个人网站\n- 内容原创，更新频率适中\n- 无违法违规内容\n\n**联系方式**：\n- 邮箱：[你的邮箱]\n- GitHub：[tkzzzzzz6](https://github.com/tkzzzzzz6)\n\n---\n\n*最后更新时间：2025-01-01*\n","source":"friends/index.md","raw":"---\ntitle: 朋友们\ndate: 2025-01-01\nlayout: page\n---\n\n# 朋友们\n\n这里是我的朋友们和推荐的一些优秀博客！\n\n## 技术博客\n\n### 深度学习相关\n- [深度学习相关博客1](https://example.com) - 深度学习技术分享\n- [计算机视觉博客](https://example.com) - CV技术研究\n\n### 编程技术\n- [算法竞赛博客](https://example.com) - 算法学习与竞赛\n- [Web开发博客](https://example.com) - 前端后端技术\n\n### 数学建模\n- [数学建模博客](https://example.com) - 数模经验分享\n- [数据分析博客](https://example.com) - 数据处理与分析\n\n## 学习资源\n\n### 在线课程\n- [Coursera深度学习课程](https://www.coursera.org)\n- [edX计算机科学课程](https://www.edx.org)\n\n### 技术文档\n- [PyTorch官方文档](https://pytorch.org/docs/)\n- [TensorFlow官方文档](https://tensorflow.org/docs/)\n\n## 推荐网站\n\n### 编程学习\n- [LeetCode](https://leetcode.cn) - 算法刷题\n- [GitHub](https://github.com) - 代码托管\n- [Stack Overflow](https://stackoverflow.com) - 技术问答\n\n### 学术资源\n- [arXiv](https://arxiv.org) - 学术论文\n- [Google Scholar](https://scholar.google.com) - 学术搜索\n\n---\n\n## 友链申请\n\n如果你也想交换友链，欢迎联系我！\n\n**申请要求**：\n- 技术类博客或个人网站\n- 内容原创，更新频率适中\n- 无违法违规内容\n\n**联系方式**：\n- 邮箱：[你的邮箱]\n- GitHub：[tkzzzzzz6](https://github.com/tkzzzzzz6)\n\n---\n\n*最后更新时间：2025-01-01*\n","updated":"2025-09-26T12:06:42.199Z","path":"friends/index.html","comments":1,"_id":"cmg0swld90000zg8na7gh3tcd","content":"<h1 id=\"朋友们\"><a href=\"#朋友们\" class=\"headerlink\" title=\"朋友们\"></a>朋友们</h1><p>这里是我的朋友们和推荐的一些优秀博客！</p>\n<h2 id=\"技术博客\"><a href=\"#技术博客\" class=\"headerlink\" title=\"技术博客\"></a>技术博客</h2><h3 id=\"深度学习相关\"><a href=\"#深度学习相关\" class=\"headerlink\" title=\"深度学习相关\"></a>深度学习相关</h3><ul>\n<li><a href=\"https://example.com/\">深度学习相关博客1</a> - 深度学习技术分享</li>\n<li><a href=\"https://example.com/\">计算机视觉博客</a> - CV技术研究</li>\n</ul>\n<h3 id=\"编程技术\"><a href=\"#编程技术\" class=\"headerlink\" title=\"编程技术\"></a>编程技术</h3><ul>\n<li><a href=\"https://example.com/\">算法竞赛博客</a> - 算法学习与竞赛</li>\n<li><a href=\"https://example.com/\">Web开发博客</a> - 前端后端技术</li>\n</ul>\n<h3 id=\"数学建模\"><a href=\"#数学建模\" class=\"headerlink\" title=\"数学建模\"></a>数学建模</h3><ul>\n<li><a href=\"https://example.com/\">数学建模博客</a> - 数模经验分享</li>\n<li><a href=\"https://example.com/\">数据分析博客</a> - 数据处理与分析</li>\n</ul>\n<h2 id=\"学习资源\"><a href=\"#学习资源\" class=\"headerlink\" title=\"学习资源\"></a>学习资源</h2><h3 id=\"在线课程\"><a href=\"#在线课程\" class=\"headerlink\" title=\"在线课程\"></a>在线课程</h3><ul>\n<li><a href=\"https://www.coursera.org/\">Coursera深度学习课程</a></li>\n<li><a href=\"https://www.edx.org/\">edX计算机科学课程</a></li>\n</ul>\n<h3 id=\"技术文档\"><a href=\"#技术文档\" class=\"headerlink\" title=\"技术文档\"></a>技术文档</h3><ul>\n<li><a href=\"https://pytorch.org/docs/\">PyTorch官方文档</a></li>\n<li><a href=\"https://tensorflow.org/docs/\">TensorFlow官方文档</a></li>\n</ul>\n<h2 id=\"推荐网站\"><a href=\"#推荐网站\" class=\"headerlink\" title=\"推荐网站\"></a>推荐网站</h2><h3 id=\"编程学习\"><a href=\"#编程学习\" class=\"headerlink\" title=\"编程学习\"></a>编程学习</h3><ul>\n<li><a href=\"https://leetcode.cn/\">LeetCode</a> - 算法刷题</li>\n<li><a href=\"https://github.com/\">GitHub</a> - 代码托管</li>\n<li><a href=\"https://stackoverflow.com/\">Stack Overflow</a> - 技术问答</li>\n</ul>\n<h3 id=\"学术资源\"><a href=\"#学术资源\" class=\"headerlink\" title=\"学术资源\"></a>学术资源</h3><ul>\n<li><a href=\"https://arxiv.org/\">arXiv</a> - 学术论文</li>\n<li><a href=\"https://scholar.google.com/\">Google Scholar</a> - 学术搜索</li>\n</ul>\n<hr>\n<h2 id=\"友链申请\"><a href=\"#友链申请\" class=\"headerlink\" title=\"友链申请\"></a>友链申请</h2><p>如果你也想交换友链，欢迎联系我！</p>\n<p><strong>申请要求</strong>：</p>\n<ul>\n<li>技术类博客或个人网站</li>\n<li>内容原创，更新频率适中</li>\n<li>无违法违规内容</li>\n</ul>\n<p><strong>联系方式</strong>：</p>\n<ul>\n<li>邮箱：[你的邮箱]</li>\n<li>GitHub：<a href=\"https://github.com/tkzzzzzz6\">tkzzzzzz6</a></li>\n</ul>\n<hr>\n<p><em>最后更新时间：2025-01-01</em></p>\n","excerpt":"","more":"<h1 id=\"朋友们\"><a href=\"#朋友们\" class=\"headerlink\" title=\"朋友们\"></a>朋友们</h1><p>这里是我的朋友们和推荐的一些优秀博客！</p>\n<h2 id=\"技术博客\"><a href=\"#技术博客\" class=\"headerlink\" title=\"技术博客\"></a>技术博客</h2><h3 id=\"深度学习相关\"><a href=\"#深度学习相关\" class=\"headerlink\" title=\"深度学习相关\"></a>深度学习相关</h3><ul>\n<li><a href=\"https://example.com/\">深度学习相关博客1</a> - 深度学习技术分享</li>\n<li><a href=\"https://example.com/\">计算机视觉博客</a> - CV技术研究</li>\n</ul>\n<h3 id=\"编程技术\"><a href=\"#编程技术\" class=\"headerlink\" title=\"编程技术\"></a>编程技术</h3><ul>\n<li><a href=\"https://example.com/\">算法竞赛博客</a> - 算法学习与竞赛</li>\n<li><a href=\"https://example.com/\">Web开发博客</a> - 前端后端技术</li>\n</ul>\n<h3 id=\"数学建模\"><a href=\"#数学建模\" class=\"headerlink\" title=\"数学建模\"></a>数学建模</h3><ul>\n<li><a href=\"https://example.com/\">数学建模博客</a> - 数模经验分享</li>\n<li><a href=\"https://example.com/\">数据分析博客</a> - 数据处理与分析</li>\n</ul>\n<h2 id=\"学习资源\"><a href=\"#学习资源\" class=\"headerlink\" title=\"学习资源\"></a>学习资源</h2><h3 id=\"在线课程\"><a href=\"#在线课程\" class=\"headerlink\" title=\"在线课程\"></a>在线课程</h3><ul>\n<li><a href=\"https://www.coursera.org/\">Coursera深度学习课程</a></li>\n<li><a href=\"https://www.edx.org/\">edX计算机科学课程</a></li>\n</ul>\n<h3 id=\"技术文档\"><a href=\"#技术文档\" class=\"headerlink\" title=\"技术文档\"></a>技术文档</h3><ul>\n<li><a href=\"https://pytorch.org/docs/\">PyTorch官方文档</a></li>\n<li><a href=\"https://tensorflow.org/docs/\">TensorFlow官方文档</a></li>\n</ul>\n<h2 id=\"推荐网站\"><a href=\"#推荐网站\" class=\"headerlink\" title=\"推荐网站\"></a>推荐网站</h2><h3 id=\"编程学习\"><a href=\"#编程学习\" class=\"headerlink\" title=\"编程学习\"></a>编程学习</h3><ul>\n<li><a href=\"https://leetcode.cn/\">LeetCode</a> - 算法刷题</li>\n<li><a href=\"https://github.com/\">GitHub</a> - 代码托管</li>\n<li><a href=\"https://stackoverflow.com/\">Stack Overflow</a> - 技术问答</li>\n</ul>\n<h3 id=\"学术资源\"><a href=\"#学术资源\" class=\"headerlink\" title=\"学术资源\"></a>学术资源</h3><ul>\n<li><a href=\"https://arxiv.org/\">arXiv</a> - 学术论文</li>\n<li><a href=\"https://scholar.google.com/\">Google Scholar</a> - 学术搜索</li>\n</ul>\n<hr>\n<h2 id=\"友链申请\"><a href=\"#友链申请\" class=\"headerlink\" title=\"友链申请\"></a>友链申请</h2><p>如果你也想交换友链，欢迎联系我！</p>\n<p><strong>申请要求</strong>：</p>\n<ul>\n<li>技术类博客或个人网站</li>\n<li>内容原创，更新频率适中</li>\n<li>无违法违规内容</li>\n</ul>\n<p><strong>联系方式</strong>：</p>\n<ul>\n<li>邮箱：[你的邮箱]</li>\n<li>GitHub：<a href=\"https://github.com/tkzzzzzz6\">tkzzzzzz6</a></li>\n</ul>\n<hr>\n<p><em>最后更新时间：2025-01-01</em></p>\n"},{"title":"关于我","date":"2024-12-31T16:00:00.000Z","layout":"page","_content":"\n# 关于我\n\n你好，我是 TK！\n\n## 个人简介\n\n计算机大三学生，喜欢研究一些乱七八糟的东西，目前研究方向是深度学习。\n\n## 技能栈\n\n- **编程语言**: Python, Java, C++, JavaScript\n- **深度学习**: PyTorch, TensorFlow, 计算机视觉\n- **Web开发**: HTML, CSS, JavaScript, Node.js\n- **数据库**: MySQL, MongoDB\n- **其他**: Git, Linux, Docker\n\n## 兴趣爱好\n\n- 深度学习算法研究\n- 计算机视觉\n- 数学建模\n- 编程竞赛\n- 技术写作\n\n## 联系方式\n\n欢迎通过以下方式与我交流：\n\n- **GitHub**: [tkzzzzzz6](https://github.com/tkzzzzzz6)\n- **邮箱**: [你的邮箱地址]\n\n## 本站说明\n\n本站未注明转载的文章均为原创，并采用 [CC BY-NC-SA 4.0](https://creativecommons.org/licenses/by-nc-sa/4.0/deed.zh) 授权协议，转载请注明来源，谢谢！\n\n如本站内容对你有所帮助的话，不妨支持一下？同时欢迎订阅关注，分享每日的学习经历。\n","source":"about/index.md","raw":"---\ntitle: 关于我\ndate: 2025-01-01\nlayout: page\n---\n\n# 关于我\n\n你好，我是 TK！\n\n## 个人简介\n\n计算机大三学生，喜欢研究一些乱七八糟的东西，目前研究方向是深度学习。\n\n## 技能栈\n\n- **编程语言**: Python, Java, C++, JavaScript\n- **深度学习**: PyTorch, TensorFlow, 计算机视觉\n- **Web开发**: HTML, CSS, JavaScript, Node.js\n- **数据库**: MySQL, MongoDB\n- **其他**: Git, Linux, Docker\n\n## 兴趣爱好\n\n- 深度学习算法研究\n- 计算机视觉\n- 数学建模\n- 编程竞赛\n- 技术写作\n\n## 联系方式\n\n欢迎通过以下方式与我交流：\n\n- **GitHub**: [tkzzzzzz6](https://github.com/tkzzzzzz6)\n- **邮箱**: [你的邮箱地址]\n\n## 本站说明\n\n本站未注明转载的文章均为原创，并采用 [CC BY-NC-SA 4.0](https://creativecommons.org/licenses/by-nc-sa/4.0/deed.zh) 授权协议，转载请注明来源，谢谢！\n\n如本站内容对你有所帮助的话，不妨支持一下？同时欢迎订阅关注，分享每日的学习经历。\n","updated":"2025-09-26T12:06:42.192Z","path":"about/index.html","comments":1,"_id":"cmg0swlda0001zg8ngb4w0k7o","content":"<h1 id=\"关于我\"><a href=\"#关于我\" class=\"headerlink\" title=\"关于我\"></a>关于我</h1><p>你好，我是 TK！</p>\n<h2 id=\"个人简介\"><a href=\"#个人简介\" class=\"headerlink\" title=\"个人简介\"></a>个人简介</h2><p>计算机大三学生，喜欢研究一些乱七八糟的东西，目前研究方向是深度学习。</p>\n<h2 id=\"技能栈\"><a href=\"#技能栈\" class=\"headerlink\" title=\"技能栈\"></a>技能栈</h2><ul>\n<li><strong>编程语言</strong>: Python, Java, C++, JavaScript</li>\n<li><strong>深度学习</strong>: PyTorch, TensorFlow, 计算机视觉</li>\n<li><strong>Web开发</strong>: HTML, CSS, JavaScript, Node.js</li>\n<li><strong>数据库</strong>: MySQL, MongoDB</li>\n<li><strong>其他</strong>: Git, Linux, Docker</li>\n</ul>\n<h2 id=\"兴趣爱好\"><a href=\"#兴趣爱好\" class=\"headerlink\" title=\"兴趣爱好\"></a>兴趣爱好</h2><ul>\n<li>深度学习算法研究</li>\n<li>计算机视觉</li>\n<li>数学建模</li>\n<li>编程竞赛</li>\n<li>技术写作</li>\n</ul>\n<h2 id=\"联系方式\"><a href=\"#联系方式\" class=\"headerlink\" title=\"联系方式\"></a>联系方式</h2><p>欢迎通过以下方式与我交流：</p>\n<ul>\n<li><strong>GitHub</strong>: <a href=\"https://github.com/tkzzzzzz6\">tkzzzzzz6</a></li>\n<li><strong>邮箱</strong>: [你的邮箱地址]</li>\n</ul>\n<h2 id=\"本站说明\"><a href=\"#本站说明\" class=\"headerlink\" title=\"本站说明\"></a>本站说明</h2><p>本站未注明转载的文章均为原创，并采用 <a href=\"https://creativecommons.org/licenses/by-nc-sa/4.0/deed.zh\">CC BY-NC-SA 4.0</a> 授权协议，转载请注明来源，谢谢！</p>\n<p>如本站内容对你有所帮助的话，不妨支持一下？同时欢迎订阅关注，分享每日的学习经历。</p>\n","excerpt":"","more":"<h1 id=\"关于我\"><a href=\"#关于我\" class=\"headerlink\" title=\"关于我\"></a>关于我</h1><p>你好，我是 TK！</p>\n<h2 id=\"个人简介\"><a href=\"#个人简介\" class=\"headerlink\" title=\"个人简介\"></a>个人简介</h2><p>计算机大三学生，喜欢研究一些乱七八糟的东西，目前研究方向是深度学习。</p>\n<h2 id=\"技能栈\"><a href=\"#技能栈\" class=\"headerlink\" title=\"技能栈\"></a>技能栈</h2><ul>\n<li><strong>编程语言</strong>: Python, Java, C++, JavaScript</li>\n<li><strong>深度学习</strong>: PyTorch, TensorFlow, 计算机视觉</li>\n<li><strong>Web开发</strong>: HTML, CSS, JavaScript, Node.js</li>\n<li><strong>数据库</strong>: MySQL, MongoDB</li>\n<li><strong>其他</strong>: Git, Linux, Docker</li>\n</ul>\n<h2 id=\"兴趣爱好\"><a href=\"#兴趣爱好\" class=\"headerlink\" title=\"兴趣爱好\"></a>兴趣爱好</h2><ul>\n<li>深度学习算法研究</li>\n<li>计算机视觉</li>\n<li>数学建模</li>\n<li>编程竞赛</li>\n<li>技术写作</li>\n</ul>\n<h2 id=\"联系方式\"><a href=\"#联系方式\" class=\"headerlink\" title=\"联系方式\"></a>联系方式</h2><p>欢迎通过以下方式与我交流：</p>\n<ul>\n<li><strong>GitHub</strong>: <a href=\"https://github.com/tkzzzzzz6\">tkzzzzzz6</a></li>\n<li><strong>邮箱</strong>: [你的邮箱地址]</li>\n</ul>\n<h2 id=\"本站说明\"><a href=\"#本站说明\" class=\"headerlink\" title=\"本站说明\"></a>本站说明</h2><p>本站未注明转载的文章均为原创，并采用 <a href=\"https://creativecommons.org/licenses/by-nc-sa/4.0/deed.zh\">CC BY-NC-SA 4.0</a> 授权协议，转载请注明来源，谢谢！</p>\n<p>如本站内容对你有所帮助的话，不妨支持一下？同时欢迎订阅关注，分享每日的学习经历。</p>\n"}],"Post":[{"title":"WSL 启动报错 \"Cannot execute daemonize to start systemd\" 的解决方法","date":"2025-02-08T16:00:00.000Z","_content":"## 问题背景\n\n在启动 WSL2 时遇到以下错误：\n`Cannot execute daemonize to start systemd`\n\n![报错截图](https://tk-pichost-1325224430.cos.ap-chengdu.myqcloud.com/blog/17390777698341739077769078.png)\n\n> 解决思路来源:https://github.com/DamionGans/ubuntu-wsl2-systemd-script/issues/37\n\n此错误通常是因为 **`daemonize`** 工具未正确安装或配置导致。\n`daemonize` 是一个 Linux 工具，用于将普通程序转换为守护进程（后台服务），而 `systemd` 作为系统和服务管理器需要依赖此工具。\n\n---\n\n## 解决方法\n\n### 1. 检查 daemonize 是否安装\n\n1. **以 root 身份登录 WSL**：在 Windows 的 CMD 或 PowerShell 中执行：\n\n   ```bash\n   wsl -u root\n   ```\n2. **验证 daemonize 是否存在**：\n\n   ```bash\n   which daemonize\n   ```\n\n   - 如果无输出，则表示未安装。\n\n---\n\n### 2. 安装 daemonize\n\n#### 步骤一：更新软件源\n\n```bash\nsudo apt update\n```\n\n#### 步骤二：尝试安装 daemonize\n\n```bash\nsudo apt install daemonize\n```\n\n---\n\n### 3. 处理安装报错 `E: Unable to locate package daemonize`\n\n若出现此错误，可能是软件源未正确配置。需手动更新软件源：\n\n#### 方案一：使用 Ubuntu 官方源（推荐国际用户）\n\n```bash\nsudo sh -c 'echo \"deb http://archive.ubuntu.com/ubuntu/ jammy main restricted universe multiverse\" > /etc/apt/sources.list'\nsudo sh -c 'echo \"deb http://archive.ubuntu.com/ubuntu/ jammy-updates main restricted universe multiverse\" >> /etc/apt/sources.list'\nsudo sh -c 'echo \"deb http://archive.ubuntu.com/ubuntu/ jammy-backports main restricted universe multiverse\" >> /etc/apt/sources.list'\nsudo sh -c 'echo \"deb http://security.ubuntu.com/ubuntu/ jammy-security main restricted universe multiverse\" >> /etc/apt/sources.list'\n```\n\n#### 方案二：使用国内镜像源（推荐中国用户）\n\n例如替换为清华源：\n\n```bash\nsudo sed -i \"s@http://.*archive.ubuntu.com@https://mirrors.tuna.tsinghua.edu.cn@g\" /etc/apt/sources.list\nsudo sed -i \"s@http://.*security.ubuntu.com@https://mirrors.tuna.tsinghua.edu.cn@g\" /etc/apt/sources.list\n```\n\n#### 更新并安装\n\n```bash\nsudo apt update && sudo apt upgrade -y\nsudo apt install daemonize\n```\n\n---\n\n### 4. 验证安装并重启 WSL\n\n1. **确认 daemonize 路径**：\n\n   ```bash\n   which daemonize  # 应输出 /usr/bin/daemonize\n   ```\n2. **重启 WSL**：\n   关闭 WSL 并重新启动：\n\n   ```bash\n   wsl --shutdown\n   wsl\n   ```\n\n---\n\n## 补充说明\n\n### 为什么需要 systemd？\n\n- `systemd` 是 Linux 系统的初始化系统，管理后台服务（如 SSH、Docker 等）。\n- WSL2 默认不启用 systemd，但部分工具（如 Docker Desktop、snap）依赖它。\n\n### 可选：永久启用 systemd\n\n若需在 WSL 中默认启用 systemd，可修改 `/etc/wsl.conf`：\n\n```bash\nsudo tee /etc/wsl.conf <<EOF\n[boot]\nsystemd=true\nEOF\n```\n\n重启 WSL 生效：\n\n```bash\nwsl --shutdown\nwsl\n```\n\n---\n\n## 常见问题\n\n#### Q1: 安装后仍报错怎么办？\n\n- 确认 `daemonize` 路径在 `/usr/bin` 中。\n- 检查 WSL 版本是否为 WSL2：`wsl -l -v`。\n\n#### Q2: 修改软件源后无法更新？\n\n- 备份原始源文件：`sudo cp /etc/apt/sources.list /etc/apt/sources.list.bak`。\n- 检查网络连接：`ping archive.ubuntu.com`。\n\n---\n\n## 总结\n\n通过安装 `daemonize` 并正确配置软件源，可解决 `Cannot execute daemonize to start systemd` 错误。若需进一步使用 systemd 相关服务，建议通过 `/etc/wsl.conf` 启用 systemd 支持。\n","source":"_posts/2025-02-09-wsl启动报错Cannot execute daemonize to start systemd的解决方法.md","raw":"---\ntitle: WSL 启动报错 \"Cannot execute daemonize to start systemd\" 的解决方法\ndate: 2025-02-09\ntags: 问题解决\n---\n## 问题背景\n\n在启动 WSL2 时遇到以下错误：\n`Cannot execute daemonize to start systemd`\n\n![报错截图](https://tk-pichost-1325224430.cos.ap-chengdu.myqcloud.com/blog/17390777698341739077769078.png)\n\n> 解决思路来源:https://github.com/DamionGans/ubuntu-wsl2-systemd-script/issues/37\n\n此错误通常是因为 **`daemonize`** 工具未正确安装或配置导致。\n`daemonize` 是一个 Linux 工具，用于将普通程序转换为守护进程（后台服务），而 `systemd` 作为系统和服务管理器需要依赖此工具。\n\n---\n\n## 解决方法\n\n### 1. 检查 daemonize 是否安装\n\n1. **以 root 身份登录 WSL**：在 Windows 的 CMD 或 PowerShell 中执行：\n\n   ```bash\n   wsl -u root\n   ```\n2. **验证 daemonize 是否存在**：\n\n   ```bash\n   which daemonize\n   ```\n\n   - 如果无输出，则表示未安装。\n\n---\n\n### 2. 安装 daemonize\n\n#### 步骤一：更新软件源\n\n```bash\nsudo apt update\n```\n\n#### 步骤二：尝试安装 daemonize\n\n```bash\nsudo apt install daemonize\n```\n\n---\n\n### 3. 处理安装报错 `E: Unable to locate package daemonize`\n\n若出现此错误，可能是软件源未正确配置。需手动更新软件源：\n\n#### 方案一：使用 Ubuntu 官方源（推荐国际用户）\n\n```bash\nsudo sh -c 'echo \"deb http://archive.ubuntu.com/ubuntu/ jammy main restricted universe multiverse\" > /etc/apt/sources.list'\nsudo sh -c 'echo \"deb http://archive.ubuntu.com/ubuntu/ jammy-updates main restricted universe multiverse\" >> /etc/apt/sources.list'\nsudo sh -c 'echo \"deb http://archive.ubuntu.com/ubuntu/ jammy-backports main restricted universe multiverse\" >> /etc/apt/sources.list'\nsudo sh -c 'echo \"deb http://security.ubuntu.com/ubuntu/ jammy-security main restricted universe multiverse\" >> /etc/apt/sources.list'\n```\n\n#### 方案二：使用国内镜像源（推荐中国用户）\n\n例如替换为清华源：\n\n```bash\nsudo sed -i \"s@http://.*archive.ubuntu.com@https://mirrors.tuna.tsinghua.edu.cn@g\" /etc/apt/sources.list\nsudo sed -i \"s@http://.*security.ubuntu.com@https://mirrors.tuna.tsinghua.edu.cn@g\" /etc/apt/sources.list\n```\n\n#### 更新并安装\n\n```bash\nsudo apt update && sudo apt upgrade -y\nsudo apt install daemonize\n```\n\n---\n\n### 4. 验证安装并重启 WSL\n\n1. **确认 daemonize 路径**：\n\n   ```bash\n   which daemonize  # 应输出 /usr/bin/daemonize\n   ```\n2. **重启 WSL**：\n   关闭 WSL 并重新启动：\n\n   ```bash\n   wsl --shutdown\n   wsl\n   ```\n\n---\n\n## 补充说明\n\n### 为什么需要 systemd？\n\n- `systemd` 是 Linux 系统的初始化系统，管理后台服务（如 SSH、Docker 等）。\n- WSL2 默认不启用 systemd，但部分工具（如 Docker Desktop、snap）依赖它。\n\n### 可选：永久启用 systemd\n\n若需在 WSL 中默认启用 systemd，可修改 `/etc/wsl.conf`：\n\n```bash\nsudo tee /etc/wsl.conf <<EOF\n[boot]\nsystemd=true\nEOF\n```\n\n重启 WSL 生效：\n\n```bash\nwsl --shutdown\nwsl\n```\n\n---\n\n## 常见问题\n\n#### Q1: 安装后仍报错怎么办？\n\n- 确认 `daemonize` 路径在 `/usr/bin` 中。\n- 检查 WSL 版本是否为 WSL2：`wsl -l -v`。\n\n#### Q2: 修改软件源后无法更新？\n\n- 备份原始源文件：`sudo cp /etc/apt/sources.list /etc/apt/sources.list.bak`。\n- 检查网络连接：`ping archive.ubuntu.com`。\n\n---\n\n## 总结\n\n通过安装 `daemonize` 并正确配置软件源，可解决 `Cannot execute daemonize to start systemd` 错误。若需进一步使用 systemd 相关服务，建议通过 `/etc/wsl.conf` 启用 systemd 支持。\n","slug":"2025-02-09-wsl启动报错Cannot execute daemonize to start systemd的解决方法","published":1,"updated":"2025-09-26T12:14:55.495Z","_id":"cmg0saj3h0000jm8nbfxug700","comments":1,"layout":"post","photos":[],"content":"<h2 id=\"问题背景\"><a href=\"#问题背景\" class=\"headerlink\" title=\"问题背景\"></a>问题背景</h2><p>在启动 WSL2 时遇到以下错误：<br><code>Cannot execute daemonize to start systemd</code></p>\n<p><img src=\"https://tk-pichost-1325224430.cos.ap-chengdu.myqcloud.com/blog/17390777698341739077769078.png\" alt=\"报错截图\"></p>\n<blockquote>\n<p>解决思路来源:<a href=\"https://github.com/DamionGans/ubuntu-wsl2-systemd-script/issues/37\">https://github.com/DamionGans/ubuntu-wsl2-systemd-script/issues/37</a></p>\n</blockquote>\n<p>此错误通常是因为 <strong><code>daemonize</code></strong> 工具未正确安装或配置导致。<br><code>daemonize</code> 是一个 Linux 工具，用于将普通程序转换为守护进程（后台服务），而 <code>systemd</code> 作为系统和服务管理器需要依赖此工具。</p>\n<hr>\n<h2 id=\"解决方法\"><a href=\"#解决方法\" class=\"headerlink\" title=\"解决方法\"></a>解决方法</h2><h3 id=\"1-检查-daemonize-是否安装\"><a href=\"#1-检查-daemonize-是否安装\" class=\"headerlink\" title=\"1. 检查 daemonize 是否安装\"></a>1. 检查 daemonize 是否安装</h3><ol>\n<li><p><strong>以 root 身份登录 WSL</strong>：在 Windows 的 CMD 或 PowerShell 中执行：</p>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">wsl -u root</span><br></pre></td></tr></table></figure></li>\n<li><p><strong>验证 daemonize 是否存在</strong>：</p>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"built_in\">which</span> daemonize</span><br></pre></td></tr></table></figure>\n\n<ul>\n<li>如果无输出，则表示未安装。</li>\n</ul>\n</li>\n</ol>\n<hr>\n<h3 id=\"2-安装-daemonize\"><a href=\"#2-安装-daemonize\" class=\"headerlink\" title=\"2. 安装 daemonize\"></a>2. 安装 daemonize</h3><h4 id=\"步骤一：更新软件源\"><a href=\"#步骤一：更新软件源\" class=\"headerlink\" title=\"步骤一：更新软件源\"></a>步骤一：更新软件源</h4><figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"built_in\">sudo</span> apt update</span><br></pre></td></tr></table></figure>\n\n<h4 id=\"步骤二：尝试安装-daemonize\"><a href=\"#步骤二：尝试安装-daemonize\" class=\"headerlink\" title=\"步骤二：尝试安装 daemonize\"></a>步骤二：尝试安装 daemonize</h4><figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"built_in\">sudo</span> apt install daemonize</span><br></pre></td></tr></table></figure>\n\n<hr>\n<h3 id=\"3-处理安装报错-E-Unable-to-locate-package-daemonize\"><a href=\"#3-处理安装报错-E-Unable-to-locate-package-daemonize\" class=\"headerlink\" title=\"3. 处理安装报错 E: Unable to locate package daemonize\"></a>3. 处理安装报错 <code>E: Unable to locate package daemonize</code></h3><p>若出现此错误，可能是软件源未正确配置。需手动更新软件源：</p>\n<h4 id=\"方案一：使用-Ubuntu-官方源（推荐国际用户）\"><a href=\"#方案一：使用-Ubuntu-官方源（推荐国际用户）\" class=\"headerlink\" title=\"方案一：使用 Ubuntu 官方源（推荐国际用户）\"></a>方案一：使用 Ubuntu 官方源（推荐国际用户）</h4><figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"built_in\">sudo</span> sh -c <span class=\"string\">&#x27;echo &quot;deb http://archive.ubuntu.com/ubuntu/ jammy main restricted universe multiverse&quot; &gt; /etc/apt/sources.list&#x27;</span></span><br><span class=\"line\"><span class=\"built_in\">sudo</span> sh -c <span class=\"string\">&#x27;echo &quot;deb http://archive.ubuntu.com/ubuntu/ jammy-updates main restricted universe multiverse&quot; &gt;&gt; /etc/apt/sources.list&#x27;</span></span><br><span class=\"line\"><span class=\"built_in\">sudo</span> sh -c <span class=\"string\">&#x27;echo &quot;deb http://archive.ubuntu.com/ubuntu/ jammy-backports main restricted universe multiverse&quot; &gt;&gt; /etc/apt/sources.list&#x27;</span></span><br><span class=\"line\"><span class=\"built_in\">sudo</span> sh -c <span class=\"string\">&#x27;echo &quot;deb http://security.ubuntu.com/ubuntu/ jammy-security main restricted universe multiverse&quot; &gt;&gt; /etc/apt/sources.list&#x27;</span></span><br></pre></td></tr></table></figure>\n\n<h4 id=\"方案二：使用国内镜像源（推荐中国用户）\"><a href=\"#方案二：使用国内镜像源（推荐中国用户）\" class=\"headerlink\" title=\"方案二：使用国内镜像源（推荐中国用户）\"></a>方案二：使用国内镜像源（推荐中国用户）</h4><p>例如替换为清华源：</p>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"built_in\">sudo</span> sed -i <span class=\"string\">&quot;s@http://.*archive.ubuntu.com@https://mirrors.tuna.tsinghua.edu.cn@g&quot;</span> /etc/apt/sources.list</span><br><span class=\"line\"><span class=\"built_in\">sudo</span> sed -i <span class=\"string\">&quot;s@http://.*security.ubuntu.com@https://mirrors.tuna.tsinghua.edu.cn@g&quot;</span> /etc/apt/sources.list</span><br></pre></td></tr></table></figure>\n\n<h4 id=\"更新并安装\"><a href=\"#更新并安装\" class=\"headerlink\" title=\"更新并安装\"></a>更新并安装</h4><figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"built_in\">sudo</span> apt update &amp;&amp; <span class=\"built_in\">sudo</span> apt upgrade -y</span><br><span class=\"line\"><span class=\"built_in\">sudo</span> apt install daemonize</span><br></pre></td></tr></table></figure>\n\n<hr>\n<h3 id=\"4-验证安装并重启-WSL\"><a href=\"#4-验证安装并重启-WSL\" class=\"headerlink\" title=\"4. 验证安装并重启 WSL\"></a>4. 验证安装并重启 WSL</h3><ol>\n<li><p><strong>确认 daemonize 路径</strong>：</p>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"built_in\">which</span> daemonize  <span class=\"comment\"># 应输出 /usr/bin/daemonize</span></span><br></pre></td></tr></table></figure></li>\n<li><p><strong>重启 WSL</strong>：<br>关闭 WSL 并重新启动：</p>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">wsl --shutdown</span><br><span class=\"line\">wsl</span><br></pre></td></tr></table></figure></li>\n</ol>\n<hr>\n<h2 id=\"补充说明\"><a href=\"#补充说明\" class=\"headerlink\" title=\"补充说明\"></a>补充说明</h2><h3 id=\"为什么需要-systemd？\"><a href=\"#为什么需要-systemd？\" class=\"headerlink\" title=\"为什么需要 systemd？\"></a>为什么需要 systemd？</h3><ul>\n<li><code>systemd</code> 是 Linux 系统的初始化系统，管理后台服务（如 SSH、Docker 等）。</li>\n<li>WSL2 默认不启用 systemd，但部分工具（如 Docker Desktop、snap）依赖它。</li>\n</ul>\n<h3 id=\"可选：永久启用-systemd\"><a href=\"#可选：永久启用-systemd\" class=\"headerlink\" title=\"可选：永久启用 systemd\"></a>可选：永久启用 systemd</h3><p>若需在 WSL 中默认启用 systemd，可修改 <code>/etc/wsl.conf</code>：</p>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"built_in\">sudo</span> <span class=\"built_in\">tee</span> /etc/wsl.conf &lt;&lt;<span class=\"string\">EOF</span></span><br><span class=\"line\"><span class=\"string\">[boot]</span></span><br><span class=\"line\"><span class=\"string\">systemd=true</span></span><br><span class=\"line\"><span class=\"string\">EOF</span></span><br></pre></td></tr></table></figure>\n\n<p>重启 WSL 生效：</p>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">wsl --shutdown</span><br><span class=\"line\">wsl</span><br></pre></td></tr></table></figure>\n\n<hr>\n<h2 id=\"常见问题\"><a href=\"#常见问题\" class=\"headerlink\" title=\"常见问题\"></a>常见问题</h2><h4 id=\"Q1-安装后仍报错怎么办？\"><a href=\"#Q1-安装后仍报错怎么办？\" class=\"headerlink\" title=\"Q1: 安装后仍报错怎么办？\"></a>Q1: 安装后仍报错怎么办？</h4><ul>\n<li>确认 <code>daemonize</code> 路径在 <code>/usr/bin</code> 中。</li>\n<li>检查 WSL 版本是否为 WSL2：<code>wsl -l -v</code>。</li>\n</ul>\n<h4 id=\"Q2-修改软件源后无法更新？\"><a href=\"#Q2-修改软件源后无法更新？\" class=\"headerlink\" title=\"Q2: 修改软件源后无法更新？\"></a>Q2: 修改软件源后无法更新？</h4><ul>\n<li>备份原始源文件：<code>sudo cp /etc/apt/sources.list /etc/apt/sources.list.bak</code>。</li>\n<li>检查网络连接：<code>ping archive.ubuntu.com</code>。</li>\n</ul>\n<hr>\n<h2 id=\"总结\"><a href=\"#总结\" class=\"headerlink\" title=\"总结\"></a>总结</h2><p>通过安装 <code>daemonize</code> 并正确配置软件源，可解决 <code>Cannot execute daemonize to start systemd</code> 错误。若需进一步使用 systemd 相关服务，建议通过 <code>/etc/wsl.conf</code> 启用 systemd 支持。</p>\n","excerpt":"","more":"<h2 id=\"问题背景\"><a href=\"#问题背景\" class=\"headerlink\" title=\"问题背景\"></a>问题背景</h2><p>在启动 WSL2 时遇到以下错误：<br><code>Cannot execute daemonize to start systemd</code></p>\n<p><img src=\"https://tk-pichost-1325224430.cos.ap-chengdu.myqcloud.com/blog/17390777698341739077769078.png\" alt=\"报错截图\"></p>\n<blockquote>\n<p>解决思路来源:<a href=\"https://github.com/DamionGans/ubuntu-wsl2-systemd-script/issues/37\">https://github.com/DamionGans/ubuntu-wsl2-systemd-script/issues/37</a></p>\n</blockquote>\n<p>此错误通常是因为 <strong><code>daemonize</code></strong> 工具未正确安装或配置导致。<br><code>daemonize</code> 是一个 Linux 工具，用于将普通程序转换为守护进程（后台服务），而 <code>systemd</code> 作为系统和服务管理器需要依赖此工具。</p>\n<hr>\n<h2 id=\"解决方法\"><a href=\"#解决方法\" class=\"headerlink\" title=\"解决方法\"></a>解决方法</h2><h3 id=\"1-检查-daemonize-是否安装\"><a href=\"#1-检查-daemonize-是否安装\" class=\"headerlink\" title=\"1. 检查 daemonize 是否安装\"></a>1. 检查 daemonize 是否安装</h3><ol>\n<li><p><strong>以 root 身份登录 WSL</strong>：在 Windows 的 CMD 或 PowerShell 中执行：</p>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">wsl -u root</span><br></pre></td></tr></table></figure></li>\n<li><p><strong>验证 daemonize 是否存在</strong>：</p>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"built_in\">which</span> daemonize</span><br></pre></td></tr></table></figure>\n\n<ul>\n<li>如果无输出，则表示未安装。</li>\n</ul>\n</li>\n</ol>\n<hr>\n<h3 id=\"2-安装-daemonize\"><a href=\"#2-安装-daemonize\" class=\"headerlink\" title=\"2. 安装 daemonize\"></a>2. 安装 daemonize</h3><h4 id=\"步骤一：更新软件源\"><a href=\"#步骤一：更新软件源\" class=\"headerlink\" title=\"步骤一：更新软件源\"></a>步骤一：更新软件源</h4><figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"built_in\">sudo</span> apt update</span><br></pre></td></tr></table></figure>\n\n<h4 id=\"步骤二：尝试安装-daemonize\"><a href=\"#步骤二：尝试安装-daemonize\" class=\"headerlink\" title=\"步骤二：尝试安装 daemonize\"></a>步骤二：尝试安装 daemonize</h4><figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"built_in\">sudo</span> apt install daemonize</span><br></pre></td></tr></table></figure>\n\n<hr>\n<h3 id=\"3-处理安装报错-E-Unable-to-locate-package-daemonize\"><a href=\"#3-处理安装报错-E-Unable-to-locate-package-daemonize\" class=\"headerlink\" title=\"3. 处理安装报错 E: Unable to locate package daemonize\"></a>3. 处理安装报错 <code>E: Unable to locate package daemonize</code></h3><p>若出现此错误，可能是软件源未正确配置。需手动更新软件源：</p>\n<h4 id=\"方案一：使用-Ubuntu-官方源（推荐国际用户）\"><a href=\"#方案一：使用-Ubuntu-官方源（推荐国际用户）\" class=\"headerlink\" title=\"方案一：使用 Ubuntu 官方源（推荐国际用户）\"></a>方案一：使用 Ubuntu 官方源（推荐国际用户）</h4><figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"built_in\">sudo</span> sh -c <span class=\"string\">&#x27;echo &quot;deb http://archive.ubuntu.com/ubuntu/ jammy main restricted universe multiverse&quot; &gt; /etc/apt/sources.list&#x27;</span></span><br><span class=\"line\"><span class=\"built_in\">sudo</span> sh -c <span class=\"string\">&#x27;echo &quot;deb http://archive.ubuntu.com/ubuntu/ jammy-updates main restricted universe multiverse&quot; &gt;&gt; /etc/apt/sources.list&#x27;</span></span><br><span class=\"line\"><span class=\"built_in\">sudo</span> sh -c <span class=\"string\">&#x27;echo &quot;deb http://archive.ubuntu.com/ubuntu/ jammy-backports main restricted universe multiverse&quot; &gt;&gt; /etc/apt/sources.list&#x27;</span></span><br><span class=\"line\"><span class=\"built_in\">sudo</span> sh -c <span class=\"string\">&#x27;echo &quot;deb http://security.ubuntu.com/ubuntu/ jammy-security main restricted universe multiverse&quot; &gt;&gt; /etc/apt/sources.list&#x27;</span></span><br></pre></td></tr></table></figure>\n\n<h4 id=\"方案二：使用国内镜像源（推荐中国用户）\"><a href=\"#方案二：使用国内镜像源（推荐中国用户）\" class=\"headerlink\" title=\"方案二：使用国内镜像源（推荐中国用户）\"></a>方案二：使用国内镜像源（推荐中国用户）</h4><p>例如替换为清华源：</p>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"built_in\">sudo</span> sed -i <span class=\"string\">&quot;s@http://.*archive.ubuntu.com@https://mirrors.tuna.tsinghua.edu.cn@g&quot;</span> /etc/apt/sources.list</span><br><span class=\"line\"><span class=\"built_in\">sudo</span> sed -i <span class=\"string\">&quot;s@http://.*security.ubuntu.com@https://mirrors.tuna.tsinghua.edu.cn@g&quot;</span> /etc/apt/sources.list</span><br></pre></td></tr></table></figure>\n\n<h4 id=\"更新并安装\"><a href=\"#更新并安装\" class=\"headerlink\" title=\"更新并安装\"></a>更新并安装</h4><figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"built_in\">sudo</span> apt update &amp;&amp; <span class=\"built_in\">sudo</span> apt upgrade -y</span><br><span class=\"line\"><span class=\"built_in\">sudo</span> apt install daemonize</span><br></pre></td></tr></table></figure>\n\n<hr>\n<h3 id=\"4-验证安装并重启-WSL\"><a href=\"#4-验证安装并重启-WSL\" class=\"headerlink\" title=\"4. 验证安装并重启 WSL\"></a>4. 验证安装并重启 WSL</h3><ol>\n<li><p><strong>确认 daemonize 路径</strong>：</p>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"built_in\">which</span> daemonize  <span class=\"comment\"># 应输出 /usr/bin/daemonize</span></span><br></pre></td></tr></table></figure></li>\n<li><p><strong>重启 WSL</strong>：<br>关闭 WSL 并重新启动：</p>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">wsl --shutdown</span><br><span class=\"line\">wsl</span><br></pre></td></tr></table></figure></li>\n</ol>\n<hr>\n<h2 id=\"补充说明\"><a href=\"#补充说明\" class=\"headerlink\" title=\"补充说明\"></a>补充说明</h2><h3 id=\"为什么需要-systemd？\"><a href=\"#为什么需要-systemd？\" class=\"headerlink\" title=\"为什么需要 systemd？\"></a>为什么需要 systemd？</h3><ul>\n<li><code>systemd</code> 是 Linux 系统的初始化系统，管理后台服务（如 SSH、Docker 等）。</li>\n<li>WSL2 默认不启用 systemd，但部分工具（如 Docker Desktop、snap）依赖它。</li>\n</ul>\n<h3 id=\"可选：永久启用-systemd\"><a href=\"#可选：永久启用-systemd\" class=\"headerlink\" title=\"可选：永久启用 systemd\"></a>可选：永久启用 systemd</h3><p>若需在 WSL 中默认启用 systemd，可修改 <code>/etc/wsl.conf</code>：</p>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"built_in\">sudo</span> <span class=\"built_in\">tee</span> /etc/wsl.conf &lt;&lt;<span class=\"string\">EOF</span></span><br><span class=\"line\"><span class=\"string\">[boot]</span></span><br><span class=\"line\"><span class=\"string\">systemd=true</span></span><br><span class=\"line\"><span class=\"string\">EOF</span></span><br></pre></td></tr></table></figure>\n\n<p>重启 WSL 生效：</p>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">wsl --shutdown</span><br><span class=\"line\">wsl</span><br></pre></td></tr></table></figure>\n\n<hr>\n<h2 id=\"常见问题\"><a href=\"#常见问题\" class=\"headerlink\" title=\"常见问题\"></a>常见问题</h2><h4 id=\"Q1-安装后仍报错怎么办？\"><a href=\"#Q1-安装后仍报错怎么办？\" class=\"headerlink\" title=\"Q1: 安装后仍报错怎么办？\"></a>Q1: 安装后仍报错怎么办？</h4><ul>\n<li>确认 <code>daemonize</code> 路径在 <code>/usr/bin</code> 中。</li>\n<li>检查 WSL 版本是否为 WSL2：<code>wsl -l -v</code>。</li>\n</ul>\n<h4 id=\"Q2-修改软件源后无法更新？\"><a href=\"#Q2-修改软件源后无法更新？\" class=\"headerlink\" title=\"Q2: 修改软件源后无法更新？\"></a>Q2: 修改软件源后无法更新？</h4><ul>\n<li>备份原始源文件：<code>sudo cp /etc/apt/sources.list /etc/apt/sources.list.bak</code>。</li>\n<li>检查网络连接：<code>ping archive.ubuntu.com</code>。</li>\n</ul>\n<hr>\n<h2 id=\"总结\"><a href=\"#总结\" class=\"headerlink\" title=\"总结\"></a>总结</h2><p>通过安装 <code>daemonize</code> 并正确配置软件源，可解决 <code>Cannot execute daemonize to start systemd</code> 错误。若需进一步使用 systemd 相关服务，建议通过 <code>/etc/wsl.conf</code> 启用 systemd 支持。</p>\n"},{"title":"2025-02-11-数模笔记_微分方程与差分方程","date":"2025-02-10T16:00:00.000Z","_content":"# 微分方程与差分方程\n\n# 一、概述\n\n![17393373960371739337395061.png](https://tk-pichost-1325224430.cos.ap-chengdu.myqcloud.com/blog/17393373960371739337395061.png)\n\n| 年份    | 题目                                | 相关方法或理论                               |\n| ------- | ----------------------------------- | -------------------------------------------- |\n| 1996 年 | A: 最优捕鱼策略问题                 | 微分方程的问题                               |\n|         | B: 节水洗衣机的程序设计问题         | 偏微分方程，也可以用优化                     |\n| 2003 年 | A: SARS 的传播问题                  | 预测类问题，可用差分方程、微分方程           |\n|         | D: 抢渡长江问题                     | 微分方程、优化问题                           |\n| 2004 年 | C: 酒后开车问题                     | 微分方程                                     |\n| 2008 年 | A: 数码相机定位（机理分析）         | 模糊数学、微分方程                           |\n|         | B: 高等教育学费标准探讨问题         | 模糊数学、微分方程                           |\n| 2009 年 | A: 制动器试验台的控制方法问题       | 微分方程、优化（求解物理应用题）             |\n| 2014 年 | A: 缆坡三号软着陆轨道设计与控制策略 | 常微分方程目标规划、优化模型                 |\n|         | B: 创意平板折叠桌                   | 力学方程、物理模型、多目标规划               |\n| 2015 年 | 太阳影子定位（机理分析）            | 偏微分方程                                   |\n| 2018 年 | A: 高温作业专用服装设计             | 偏微分方程、单目标规划、双目标规划           |\n| 2019 年 | A: 高压油管的压力控制               | 数据预处理、常微分方程、单目标规划           |\n|         | B: “同心协力”策略研究             | 二维碰撞、二维碰撞（常微分方程）、多目标规划 |\n| 2020 年 | A: 沪温曲线                         | 热传导、有限差分法、遍历法                   |\n| 2022 年 | A: 波浪能最大输出功率设计           | 微分方程、模拟仿真、最优解                   |\n| 2023 年 | A: 优化设计启目镜场以及发电问题     | 微分方程、优化问题                           |\n\n## 微分方程模型介绍\n\n### 模型介绍\n\n微分方程建模是数学建模的重要方法，因为许多实际问题的数学描述将导致求解微分方程的定解问题。解决相应问题可以按以下几步：\n\n1. 根据实际要求确定要研究的量（自变量、未知函数、必要的参数等）并确定坐标系。\n2. 找出这些量所满足的基本规律（物理的、几何的、化学的或生物学的等）。\n3. 运用这些规律列出方程和定解条件。\n4. 求解、分析结果。\n\n### 列方程常见的方法\n\n1. **微元分析法与任意区域上取积分的方法**\n\n   通过微元分析法，利用已知的规律建立一些变量（自变量与未知函数）的微元之间的关系式，然后再通过取极限的方法得到微分方程，或等价地通过任意区域上取积分的方法来建立微分方程。\n2. **按规律直接列方程**\n\n   在数学、力学、物理、化学等学科中许多自然现象所满足的规律已为人们所熟悉，并直接由微分方程所描述。我们常利用这些规律对某些实际问题列出微分方程。\n3. **模拟近似法**\n\n   在生物、经济等学科中，许多现象所满足的规律并不很清楚且相当复杂，因此需要根据实际资料或大量的实验数据，提出各种假设。在一定的假设下，给出实际现象所满足的规律，然后利用适当的数学方法列出微分方程。\n\n### 例题\n\n一个较热的物体置于室温为 18°C 的房间内，该物体最初的温度是 60°C，3 分钟以后降到 50°C。想知道它的温度降到 30°C 需要多少时间？10 分钟以后它的温度是多少？\n\n**牛顿冷却（加热）定律**：将温度为 $T$ 的物体放入处于常温 $m$ 的介质中时，$T$ 的变化速率正比于 $T$ 与周围介质的温度差。\n\n牛顿冷却定律描述了物体温度随时间变化的过程。根据牛顿冷却定律，温度 $T(t)$ 随时间 $t$ 的变化满足以下微分方程：\n\n$$\n\\frac{dT}{dt} = -k(T - m)\n$$\n\n其中：\n\n- $T(t)$ 是物体在时间 $t$ 时的温度。\n- $m$ 是环境温度。\n- $k$ 是冷却常数，取决于物体和环境的性质。\n\n我们可以通过积分这个方程得到 $ T(t) $ 的表达式：\n\n$$\nT(t) = m + (T_0 - m) e^{-kt}\n$$\n\n其中：\n\n- $T_0$ 是物体的初始温度。\n\n我们根据给定条件来求解这个问题。具体步骤如下：\n\n1. 根据初始条件求解冷却常数 $k$。\n2. 使用 $k$ 求解物体温度降到 30°C 所需的时间。\n3. 计算 10 分钟后物体的温度。\n\n![uk2rco.png](https://files.catbox.moe/uk2rco.png)\n\n```python\nimport numpy as np\n\n# 已知条件\nT0 = 60  # 初始温度\nT1 = 50  # 3分钟后的温度\nT_room = 18  # 环境温度\ntime1 = 3  # 时间为3分钟\n\n# 求解冷却常数k\nk = -np.log((T1 - T_room) / (T0 - T_room)) / time1\n\n# 求解降到30度所需的时间\nT_target = 30\ntime_to_target = -np.log((T_target - T_room) / (T0 - T_room)) / k\n\n# 计算10分钟后的温度\ntime2 = 10\nT_after_10_minutes = T_room + (T0 - T_room) * np.exp(-k * time2)\n\n# 输出结果\nprint(f\"物体温度降到30°C所需的时间为: {time_to_target:.2f} 分钟\")\nprint(f\"10分钟后物体的温度为: {T_after_10_minutes:.2f} °C\")\n```\n\n# 二、传染病模型\n\n## 背景与问题\n\n- 描述传染病的传播过程。\n- 分析受感染人数的变化规律。\n- 预报传染病高潮到来的时刻。\n- 预防传染病蔓延的手段。\n\n> 基本方法:按照传播过程的一般规律建立数学模型\n\n![vopq8o.png](https://files.catbox.moe/vopq8o.png)\n\n### 模型 1：I 模型\n\n已感染人数（病人）记为$i(t)$\n\n假设：每个病人每天有效接触（足以使人致病）人数为 $\\lambda$。\n\n建模：\n\n> 求解采用的是分离变量法\n\n$$\ni(t + \\Delta t) - i(t) = i(t) \\lambda \\Delta t\n$$\n\n$$\n\\frac{di}{dt} = \\lambda i\n$$\n\n$$\ni(0) = i_0\n$$\n\n求解、分析、检验：\n\n$$\n\\frac{di}{dt} = \\lambda i\n$$\n\n$$\ni(0) = i_0\n$$\n\n$$\ni(t) = i_0 e^{\\lambda t}\n$$\n\n$$\nt \\rightarrow \\infty \\Rightarrow i(t) \\rightarrow \\infty\n$$\n\n![43qanr.png](https://files.catbox.moe/43qanr.png)\n\n> 显然这个模型的结果是不合理的,感染人数不可能超过总人数。\n> 若有效接触的是病人，则不能使病人数增加。\n> 必须区分已感染者和未感染者以及总人数。\n\n#### 代码\n\n```matlab\n%创建一个.m文件并命名为i_model.m\n% I Model\nfunction [t, i] = i_model(i0, lambda, tmax)\n    [t, i] = ode45(@(t, i) lambda * i, [0 tmax], i0);\nend\n```\n\n> 注意:要创建两个文件,上面的代码创建的是 matlab 的函数文件\n\n```matlab\n% 设置参数\ni0 = 1;  % 初始感染人数\nlambda = 0.5;  % 每天有效接触人数\ntmax = 20;  % 模拟时间\n\n% 求解模型\n[t, i] = i_model(i0, lambda, tmax);\n\n% 绘图\nfigure;\nplot(t, i);\ntitle('I Model');\nxlabel('Time');\nylabel('Infected Population');\n```\n\n### 模型 2：SI 模型\n\n区分已感染者和未感染者\n\n假设：\n\n1. 总人数 $N$ 不变，病人和健康人的**比例**分别为 $i(t), s(t)$。\n\n> 注意这里$i(t)$表示的是比例和上一个模型表示人数是不一样的\n\n1. 每个病人每天有效接触人数为 $\\lambda$，且使接触的健康人致病。\n\n建模：\n\n$$\nN[i(t + \\Delta t) - i(t)] = N i(t) \\lambda \\Delta t s(t)\n$$\n\n$$\n\\frac{di}{dt} = \\lambda s i\n$$\n\n$$\ns(t) + i(t) = 1\n$$\n\n求解、分析、检验：\n\n$$\n\\begin{cases}\n\\frac{di}{dt} = \\lambda i (1 - i) \\\\\ni(0) = i_0\n\\end{cases}\n$$\n\n$$\n\\int \\frac{di}{i(1 - i)} = \\int \\lambda dt\n$$\n\n$$\ni(t) = \\frac{1}{1 + \\left(\\frac{1}{i_0} - 1\\right)e^{-\\lambda t}}\n$$\n\n![4ufuyo.png](https://files.catbox.moe/4ufuyo.png)\n\n![jkyrhf.png](https://files.catbox.moe/jkyrhf.png)\n\n$t = t_m$ 时, $\\frac{di}{dt}$ 最大\n\n$t_m \\sim$ 传染病高峰到来的时刻\n\n$$\nt_m = \\lambda^{-1} \\ln \\left(\\frac{1}{i_0} - 1\\right)\n$$\n\n$$\n\\lambda\\downarrow \\rightarrow t_m \\uparrow\n$$\n\n$$\nt \\rightarrow \\infty \\Rightarrow i \\rightarrow 1\n$$\n\n#### 代码\n\n```matlab\n%创建一个.m文件并命名为si_model.m\n% SI Model\nfunction [t, y] = si_model(i0, lambda, tmax)\n    [t, y] = ode45(@(t, y) [lambda * y(1) * (1 - y(1))], [0 tmax], i0);\nend\n```\n\n> 注意:要创建两个文件,上面的代码创建的是 matlab 的函数文件\n\n```matlab\n% 设置参数\ni0 = 0.1; % 初始感染比例\nlambda = 0.5; % 每天有效接触人数\ntmax = 50; % 模拟时间\n\n% 求解模型\n[t, i] = si_model(i0, lambda, tmax);\n\n% 找到 infected 和 susceptible 比例为 0.5 的时间点\ninfected_half = interp1(i, t, 0.5);\nsusceptible_half = interp1(1-i, t, 0.5);\n\n% 绘图\nfigure;\nplot(t, i, 'b', 'LineWidth', 2);\nhold on;\nplot(t, 1-i, 'r', 'LineWidth', 2);\n\n% 标记 infected 和 susceptible 比例为 0.5 的点\nplot(infected_half, 0.5, 'bo', 'MarkerSize', 10, 'MarkerFaceColor', 'b');\nplot(susceptible_half, 0.5, 'ro', 'MarkerSize', 10, 'MarkerFaceColor', 'r');\n\n% 添加标记点的文本说明\ntext(infected_half, 0.55, ['t_mi = ', num2str(infected_half, '%.2f')], 'Color', 'b', 'HorizontalAlignment', 'right');\ntext(susceptible_half, 0.55, ['t_ms = ', num2str(susceptible_half, '%.2f')], 'Color', 'r', 'HorizontalAlignment', 'left');\n\ntitle('SI Model');\nxlabel('Time');\nylabel('Population Ratio');\nlegend('Infected', 'Susceptible', 'Location', 'north');\n\n% 添加水平线以突出 0.5 比例\nyline(0.5, '--k', 'LineWidth', 1);\n\n% 计算传染病高峰时刻\ntm = 1/lambda * log((1/i0) - 1);\ndisp(['Peak time: ', num2str(tm)]);\n\n% 设置坐标轴范围，确保标记点可见\nylim([0 1.1]);\n```\n\n### 模型 3：SIS 模型\n\n考虑病人自愈且可再次被感染\n\n传染病无免疫性——病人治愈成为健康人，健康人可再次被感染。\n\n增加假设：\n\n病人每天治愈的比例为 $\\mu$\n\n$\\lambda \\sim$ 日接触率\n\n$\\mu \\sim$ 日治愈率\n\n$$\n\\sigma = \\lambda / \\mu\n$$\n\n建模：\n\n$$\nN[i(t + \\Delta t) - i(t)] = Ni(t)\\lambda \\Delta t s(t) - Ni(t) \\mu \\Delta t\n$$\n\n$$\n\\begin{cases}\n\\frac{di}{dt} = \\lambda i (1 - i) - \\mu i = -\\lambda i \\left[i - \\left(1 - \\frac{1}{\\sigma}\\right)\\right] \\\\\ni(0) = i_0\n\\end{cases}\n$$\n\n求解分析检验:\n\n$$\n\\frac{di}{dt} = -\\lambda i \\left[i - \\left(1 - \\frac{1}{\\sigma}\\right)\\right]\n$$\n\n![potjqt.png](https://files.catbox.moe/potjqt.png)\n\n![upnnn3.png](https://files.catbox.moe/upnnn3.png)\n\n#### 代码\n\n```matlab\n%创建一个.m文件并命名为sis_model.m\n% SIS Model\nfunction [t, y] = sis_model(i0, lambda, mu, tmax)\n    [t, y] = ode45(@(t, y) [lambda * y(1) * (1 - y(1)) - mu * y(1)], [0 tmax], i0);\nend\n```\n\n> 注意:要创建两个文件,上面的代码创建的是 matlab 的函数文件\n\n```matlab\n% 设置参数\ni0 = 0.01;  % 初始感染比例\nlambda = 0.5;  % 每天有效接触人数\nmu = 0.1;  % 每天治愈比例\ntmax = 100;  % 模拟时间\n\n% 求解模型\n[t, i] = sis_model(i0, lambda, mu, tmax);\n\n% 绘图\nfigure;\nplot(t, i);\nhold on;\nplot(t, 1-i);\ntitle('SIS Model');\nxlabel('Time');\nylabel('Population Ratio');\nlegend('Infected', 'Susceptible');\n\n% 计算平衡点\nequilibrium = 1 - mu/lambda;\ndisp(['Equilibrium point: ', num2str(equilibrium)]);\n\n% 情况1: σ > 1\nlambda1 = 0.5;\nmu1 = 0.2;\n[t1, i1] = sis_model(i0, lambda1, mu1, tmax);\n\n% 情况2: σ ≤ 1\nlambda2 = 0.2;\nmu2 = 0.5;\n[t2, i2] = sis_model(i0, lambda2, mu2, tmax);\n\n% 绘图\nfigure;\nsubplot(1,2,1);\nplot(t1, i1);\ntitle('SIS Model: σ > 1');\nxlabel('Time');\nylabel('Infected Ratio');\nyline(1 - mu1/lambda1, '--r', 'Equilibrium');\n\nsubplot(1,2,2);\nplot(t2, i2);\ntitle('SIS Model: σ ≤ 1');\nxlabel('Time');\nylabel('Infected Ratio');\n\n% 显示R₀值\ndisp(['R₀ (Case 1): ', num2str(lambda1/mu1)]);\ndisp(['R₀ (Case 2): ', num2str(lambda2/mu2)]);\n```\n\n### 模型 4：SIR 模型\n\n传染病有免疫性——病人治愈后即移出感染系统，称为**移出者**。\n\n假设：\n\n1. 总人数 $N$ 不变，病人、健康人和移出者的比例分别为 $i(t), s(t), r(t)$。\n2. 病人的日接触率 $\\lambda$, 日治愈率 $\\mu$, 接触数 $\\sigma = \\lambda / \\mu$\n\n建模：\n\n$$\ns(t) + i(t) + r(t) = 1\n$$\n\n需要建立 $i(t), s(t), r(t)$ 的两个方程。\n\n$$\nN[r(t + \\Delta t) - r(t)] = Ni(t) \\mu \\Delta t\n$$\n\n$$\nN[i(t + \\Delta t) - i(t)] = Ni(t)\\lambda \\Delta t s(t) - Ni(t) \\mu \\Delta t\n$$\n\n$$\nN[s(t + \\Delta t) - s(t)] = -\\lambda Ns(t)i(t) \\Delta t\n$$\n\n$$\ni_0 + s_0 \\approx 1 \\quad (通常r(0) = r_0 很小)\n$$\n\n求解分析检验:\n\n$$\n\\begin{cases}\n\\frac{di}{dt} = \\lambda si - \\mu i \\\\\n\\frac{ds}{dt} = -\\lambda si \\\\\ni(0) = i_0, \\quad s(0) = s_0\\\\\ni_0 + s_0 \\approx 1 \\quad (通常r(0) = r_0 很小)\n\\end{cases}\n$$\n\n> 由于无法求出 $i(t), s(t)$ 的解析解。\n> 我们考虑其他办法:\n>\n> 1. 数值计算\n> 2. 定性分析\n>    相平面上研究解析性质。\n\n#### SIR 模型的数值解\n\n设 $\\lambda = 1$, $\\mu = 0.3$, $i_0 = 0.02$, $s_0 = 0.98$, 用 MATLAB 计算作图 $i(t)$,$s(t)$及 $i(s)$\n\n$$\n\\frac{di}{ds} = \\frac{\\lambda si - \\mu i}{-\\lambda si}\n$$\n\n![17393389691728c9d5531aed64ccb881b7886773b424b.png](https://tk-pichost-1325224430.cos.ap-chengdu.myqcloud.com/blog/17393389691728c9d5531aed64ccb881b7886773b424b.png)\n\n![1739338986650311b4ff45f134c2c84cb248ba699a0a1.png](https://tk-pichost-1325224430.cos.ap-chengdu.myqcloud.com/blog/1739338986650311b4ff45f134c2c84cb248ba699a0a1.png)\n\n#### 模型的相轨线分析\n\n对于前面求解分析检验的方程组\n\n消去 $dt$, $\\sigma = \\lambda / \\mu$\n\n$$\n\\begin{cases}\n\\frac{di}{ds} = \\frac{1}{\\sigma s} - 1 \\\\\ni \\big|_{s = s_0} = i_0\n\\end{cases}\n$$\n\n相轨线:\n\n$$\ni(s) = (s_0 + i_0) - s + \\frac{1}{\\sigma} \\ln \\frac{s}{s_0}\n$$\n\n相轨线 $i(s)$ 的定义域：\n\n$$\nD = \\{(s, i) | s \\geq 0, i \\geq 0, s + i \\leq 1\\}\n$$\n\n$s(t)$ 单调递减 $\\rightarrow$ 相轨线的方向\n\n![1739339031385fbb865dcb636407682dda5b02724f9bf.png](https://tk-pichost-1325224430.cos.ap-chengdu.myqcloud.com/blog/1739339031385fbb865dcb636407682dda5b02724f9bf.png)\n\n#### 预防传染病蔓延的手段\n\n传染病不蔓延的条件—— $s_0 < 1/\\sigma$\n\n- 提高阈值 $1/\\sigma$\n\n  - 降低 $\\sigma$\n  - $\\lambda$ (日接触率) $\\downarrow \\rightarrow$ 卫生水平 $\\uparrow$\n  - $\\mu$ (日治愈率) $\\uparrow \\rightarrow$ 医疗水平 $\\uparrow$\n- 降低 $s_0$\n\n  - 提高 $r_0$$\\rightarrow$群体免疫\n\n$$\ns_0 + i_0 + r_0 = 1\n$$\n\n#### 代码\n\n```matlab\n%创建一个.m文件并命名为i_model.m\n% SIR Model\nfunction [t, y] = sir_model(i0, s0, lambda, mu, tmax)\n    [t, y] = ode45(@(t, y) [\n        lambda * y(1) * y(2) - mu * y(1)  % di/dt\n        -lambda * y(1) * y(2)  % ds/dt\n        mu * y(1)  % dr/dt\n    ], [0 tmax], [i0; s0; 1-i0-s0]);\nend\n```\n\n> 注意:要创建两个文件,上面的代码创建的是 matlab 的函数文件\n\n```matlab\n% 设置参数\ni0 = 0.01;  % 初始感染比例\ns0 = 0.99;  % 初始易感比例\nlambda = 0.5;  % 每天有效接触人数\nmu = 0.1;  % 每天治愈比例\ntmax = 100;  % 模拟时间\n\n% 求解模型\n[t, y] = sir_model(i0, s0, lambda, mu, tmax);\n\n% 绘图\nfigure;\nplot(t, y);\ntitle('SIR Model');\nxlabel('Time');\nylabel('Population Ratio');\nlegend('Infected', 'Susceptible', 'Removed');\n\n% 相平面图\nfigure;\nplot(y(:,2), y(:,1));\ntitle('SIR Model Phase Plane');\nxlabel('Susceptible');\nylabel('Infected');\n\n% 计算R0\nR0 = lambda / mu;\ndisp(['R0: ', num2str(R0)]);\n```\n\n# 三、香烟过滤嘴的作用模型\n\n## 问题\n\n- 过滤嘴的作用与它的材料和长度有什么关系？\n- 人体吸入的毒物量与哪些因素有关，其中什么因素影响大，什么因素影响小？\n\n## 模型分析\n\n- 分析吸烟时毒物进入人体的过程，建立吸烟过程的数学模型。\n\n## 模型假设\n\n1. $l_1 \\sim$ 烟草长, $l_2 \\sim$ 过滤嘴长, $l = l_1 + l_2$, 毒物总量 $M$ 均匀分布，密度 $w_0 = M/l$。\n2. 点燃处毒物进入空气和沿香烟穿行的数量比是 $a : a'$, $a' + a = 1$。\n3. 未点燃的烟草和过滤嘴对穿行的毒物的单位时间吸收速率分别是 $b$ 和 $\\beta$。\n4. 烟雾沿香烟穿行速度是常数 $v$, 香烟燃烧速度是常数 $u$, $v \\gg u$。\n\n![1739339098264762c0aa149f14ae599a418c4309aa91a.png](https://tk-pichost-1325224430.cos.ap-chengdu.myqcloud.com/blog/1739339098264762c0aa149f14ae599a418c4309aa91a.png)\n\n## 模型建立\n\n$t = 0, x = 0$, 点燃香烟\n\n$q(x,t) \\sim$ 毒物在 $x$ 处的流速（单位时间的流量）\n\n$w(x,t) \\sim$ 毒物密度\n\n$$\nw(x,0) = w_0\n$$\n\n$$\nQ = \\int_0^T q(l, t) dt, \\quad T = l_1 / u\n$$\n\n1. 求 $q(x,t)$\n\n流量守恒：\n\n$$\n\\begin{cases}\nq(x,t) - q(x+\\Delta x,t) = \\frac{q(x,t)b\\Delta x}{v}, & ut \\leq x \\leq l_1 \\\\\nq(x,t) - q(x+\\Delta x,t) = \\frac{q(x,t)\\beta\\Delta x}{v}, & l_1 \\leq x \\leq l\n\\end{cases}\n$$\n\n$$\n\\frac{dq(x,t)}{dx} = \n\\begin{cases}\n-\\frac{b}{v}q(x,t), & ut \\leq x \\leq l_1 \\\\\n-\\frac{\\beta}{v}q(x,t), & l_1 \\leq x \\leq l\n\\end{cases}\n$$\n\n定解条件：$q(ut,t) = auw(ut,t)$\n\n1. 求 $w(ut,t)$ 考察 $\\Delta t$ 内毒物密度的增量\n\n$$\nw(x, t + \\Delta t) - w(x, t) = \\frac{q(x,t)\\Delta t b\\Delta t}{v\\Delta t}\n$$\n\n其中：$q(x,t) = auw(ut,t)e^{-\\frac{b(x-ut)}{v}}$\n\n$$\n\\begin{cases}\\frac{\\partial w(ut,t)}{\\partial t} = \\frac{b}{v}auw(ut,t)e^{-\\frac{b(x-ut)}{v}}\\\\\nw(x,0)=w_0\n\\end{cases}\n$$\n\n$$\nw(ut,t) = \\frac{w_0}{a'}\\left(1 - ae^{-\\frac{a'but}{v}}\\right), \\quad a' = 1-a\n$$\n\n1. 计算 $Q$~吸一支烟毒物进入人体总量\n\n$$\nw(ut,t) = \\frac{w_0}{a'}\\left(1 - ae^{-\\frac{a'but}{v}}\\right)\n$$\n\n$$\nq(l,t) = auw(ut,t)e^{-\\frac{b l_1-wt}{v}}e^{-\\frac{\\beta l_2}{v}}\\\\\n$$\n\n$$\nQ = \\int_0^{l_1/u} q(l,t) dt = \\frac{auw_0}{a'b} e^{-\\frac{\\beta l_2}{v}}\\left(1 - e^{-\\frac{a'bl_1}{v}}\\right)\n$$\n\n$$\nQ = aMe^{-\\frac{\\beta l_2}{v}} \\varphi(r), \\quad r = \\frac{a'bl_1}{v}, \\quad \\varphi(r) = \\frac{1 - e^{-r}}{r}\n$$\n\n## 结果分析\n\n1. $Q$ 与 $a, M$ 成正比。($aM$ 是毒物集中在 $x = l_1$ 处的吸入量)\n2. $e^{-\\frac{\\beta l_2}{v}} \\sim$ 过滤嘴因素, $\\beta, l_2 \\sim$ 负指数作用\n3. $\\varphi(r) \\sim$ 烟草的吸收作用 （烟草为什么有作用？）\n\n$$\nr = \\frac{a'bl_1}{v} \\ll 1\n$$\n\n$$\n\\varphi(r) = 1 - \\frac{r}{2}\n$$\n\n$$\nQ = aMe^{-\\frac{\\beta l_2}{v}}\\left(1 - \\frac{a'bl_1}{2v}\\right), \\quad b,l_1 \\sim \\text{线性作用}\n$$\n\n1. 与另一支不带过滤嘴的香烟比较，$w_0, b, a, v, l$ 均相同，吸至 $x = l_1$ 抛掉。\n\n**带过滤嘴**:\n\n$$\nQ_1 = \\frac{a w_0 v}{a' b} e^{-\\frac{\\beta l_2}{v}} \\left(1 - e^{-\\frac{a' b l_1}{v}}\\right)\n$$\n\n**不带过滤嘴**:\n\n$$\nQ_2 = \\frac{a w_0 v}{a' b} \\left(1 - e^{-\\frac{a' b l_1}{v}}\\right)\n$$\n\n$$\n\\frac{Q_1}{Q_2} = e^{-\\frac{(\\beta - b) l_2}{v}}\n$$\n\n$$\n\\beta > b \\Rightarrow Q_1 < Q_2\n$$\n\n提高 $\\beta b$ 与加长 $l_2$，效果相同。\n\n## 总结\n\n- 引入两个基本函数：流量 $q(x,t)$ 和密度 $w(x,t)$，运用物理学的守恒定律通过微元方法建立微分方程，构造动态模型。\n- 对求解结果进行定性和定量分析，得到合理的实际结论。\n\n![17393391272532c0a5ec759324803b6b1d6f399985c6d.png](https://tk-pichost-1325224430.cos.ap-chengdu.myqcloud.com/blog/17393391272532c0a5ec759324803b6b1d6f399985c6d.png)\n\n## 代码\n\n```python\nimport numpy as np\nimport matplotlib.pyplot as plt\n\n#参数设置\nM = 1.0  #毒物总量 (任意单位)\na = 0.5  #毒物进入空气和穿行的比例 (a = 0.5, a' = 0.5)\nb = 0.1  #烟草的吸收系数\nbeta = 0.8  #过滤嘴的吸收系数, 增大以突出非线性效果\nv = 1.0  #烟雾穿行速度\nl1 = 1.0  #烟草长度\nl2_values = np.linspace(0, 10, 100)  #过滤嘴长度的变化范围, 增大以观察非线性效果\n\n#计算 Q1 和 Q2\ndef calculate_Q(l1, l2, a, M, b, beta, v):\n    a_prime = 1 - a\n    r = a_prime * b * l1 / v\n    Q1 = (a * M * v / (a_prime * b)) * np.exp(-beta * l2 / v) * (1 - np.exp(-r))\n    Q2 = (a * M * v / (a_prime * b)) * (1 - np.exp(-r))\n    return Q1, Q2\n\nQ1_values = []\nQ2_values = []\nfor l2 in l2_values:\n    Q1, Q2 = calculate_Q(l1, l2, a, M, b, beta, v)\n    Q1_values.append(Q1)\n    Q2_values.append(Q2)\n\n#比较有过滤嘴和无过滤嘴的毒物量\nQ1_values = np.array(Q1_values)\nQ2_values = np.array(Q2_values)\nQ_ratio = Q1_values / Q2_values\n\n#绘图\nplt.figure(figsize=(10, 6))\nplt.plot(l2_values, Q1_values, label='Q1 (With Filter)')\nplt.plot(l2_values, Q2_values, label='Q2 (Without Filter)')\nplt.plot(l2_values, Q_ratio, label='Q1/Q2 Ratio', linestyle='--')\nplt.xlabel('Filter Length l2')\nplt.ylabel('Toxin Amount Q')\nplt.title('Effect of Filter Length and Material on Toxin Inhalation')\nplt.legend()\nplt.grid(True)\nplt.show()\n```\n\n# 四、烟雾的扩散与消失模型\n\n## 现象和问题\n\n- 炮弹在空中爆炸，烟雾向四周扩散，形成圆形不透光区域。\n- 不透光区域不断扩大，然后区域边界逐渐明亮，区域缩小，最后烟雾消失。\n- 建立模型描述烟雾扩散和消失过程，分析消失时间与各因素的关系。\n\n## 问题分析\n\n- 无穷空间由瞬时点源导致的扩散过程，用二阶偏微分方程描述烟雾浓度的变化。\n- 观察到的烟雾消失与烟雾对光线的吸收，以及仪器对明暗的灵敏度有关。\n\n## 模型假设\n\n1. 扩散服从扩散定律。\n2. 光线穿过烟雾时光强的相对减少与与烟雾浓度成正比；无烟雾的大小不影响光强。\n3. 穿过烟雾进入仪器的光线只有明暗之分，明暗界限由仪器灵敏度决定。\n\n## 模型建立\n\n**扩散定律**：单位时间通过单位法向面积的流量 $q$ 与浓度 $C$ 的梯度成正比。\n\n$$\nq = -k \\cdot \\nabla C\n$$\n\n烟雾浓度 $C(x,y,z,t)$ 的变化规律\n\n$[t,t+\\Delta t]$ 通过$\\Omega$流出量$Q_1 = \\int_{t}^{t+\\Delta t} \\iint_S q \\cdot n d \\sigma dt$\n\n$\\Omega$ 内烟雾改变量 $Q_2 = \\iiint_{v} [C(x,y,z,t+\\Delta t) - C(x,y,z,t)] dV$\n\n高斯公式:\n\n$$\n\\iint_S q \\cdot n d\\sigma = \\iiint_V \\text{div } q dV = -k \\iiint_V \\text{div } (\\nabla C) dV\n$$\n\n$$\nQ_2 = -Q_1\n$$\n\n$$\n\\frac{\\partial C}{\\partial t} = k [\\text{div}(\\nabla C)] = k \\left(\\frac{\\partial^2 C}{\\partial x^2} + \\frac{\\partial^2 C}{\\partial y^2} + \\frac{\\partial^2 C}{\\partial z^2}\\right),-\\infty<x,y,z<\\infty,t>0\n$$\n\n## 初始条件\n\n$$\nC(x, y, z, 0) = Q \\delta(x, y, z)\n$$\n\n- $Q \\sim$ 炮弹释放的烟雾总量\n- $\\delta \\sim$ 单位强度的点源函数\n\n求解方程:\n\n$$\nC(x, y, z, t) = \\frac{Q}{(4 \\pi kt)^{3/2}} e^{-\\frac{x^2 + y^2 + z^2}{4 kt}}\n$$\n\n## 光强穿过烟雾时的变化规律\n\n- $I(l) \\sim$ 沿 $l$ 方向的光强\n- $C(l) \\sim$ 沿 $l$ 方向的烟雾浓度\n\n假设光强的相对减少与烟雾浓度成正比。\n\n$$\n\\frac{dI(l)}{dl} = -\\alpha C(l) I(l)\n$$\n\n记未进入烟雾($l \\leq l_0$)时光强为 $I(l_0) = I_0$:\n\n$$\nI(l) = I_0 e^{-\\alpha \\int_{l_0}^{l} C(s) ds}\n$$\n\n## 仪器灵敏度与烟雾明暗界限\n\n- 烟雾浓度连续变化\n- 烟雾中光强连续变化。\n- 穿过烟雾进入仪器的光线只有明暗之分，明暗界限由仪器灵敏度决定。\n\n$\\mu \\sim$ 仪器灵敏度，当 $I/I_0 < 1 - \\mu$，观测结果为暗。\n\n设光源在 $z = -\\infty$，仪器在 $z = \\infty$，则观测到的明暗界限为:\n\n$e^{-\\alpha \\int_{-\\infty}^{\\infty} C(x,y,z,t) dz} = 1 - \\mu$$\\sim$ 不透光区域边界\n\n### 求解方程\n\n$$\nC(x, y, z, t) = \\frac{Q}{(4 \\pi kt)^{3/2}} e^{-\\frac{x^2 + y^2 + z^2}{4 kt}}\n$$\n\n$$\n\\Rightarrow \\int_{-\\infty}^{\\infty} C(x,y,z,t) dz = \\frac{1}{\\alpha} \\ln \\frac{1}{1-\\mu} \\approx \\frac{\\mu}{\\alpha} \\quad (\\mu \\text{ 很小})\n$$\n\n而$\\quad \\int_{-\\infty}^{\\infty} C(x,y,z,t) dz = \\frac{Q}{4 \\pi kt} e^{-\\frac{x^2 + y^2}{4kt}}$\n\n$$\n\\frac{Q}{4 \\pi kt} e^{-\\frac{x^2 + y^2}{4 kt}} = \\frac{\\mu}{\\alpha}\n$$\n\n不透光区域边界半径:\n\n$$\nr(t) = \\sqrt{4 kt \\ln \\frac{\\alpha Q}{4 \\pi k \\mu t}}\n$$\n\n### 结果分析\n\n$$\nr(t) = \\sqrt{4 kt \\ln \\frac{\\alpha Q}{4 \\pi k \\mu t}}\n$$\n\n$$\nt = t_1 = \\frac{\\alpha Q}{4 \\pi k \\mu e}, \\quad r = r_m = \\sqrt{\\frac{Q}{\\pi \\mu e}} \\quad (\\text{最大值})\n$$\n\n$$\nt = t_2 = \\frac{\\alpha Q}{4 \\pi k \\mu}, \\quad r = 0\n$$\n\n$$\n\\alpha \\uparrow, Q \\uparrow, \\mu \\downarrow \\Rightarrow t_1 \\uparrow, r_m \\uparrow\n$$\n\n$$\nk \\downarrow \\Rightarrow t_1 \\uparrow\n$$\n\n![173933914986904ee6ddfd517468d93120f3cfe746ffd.png](https://tk-pichost-1325224430.cos.ap-chengdu.myqcloud.com/blog/173933914986904ee6ddfd517468d93120f3cfe746ffd.png)\n\n| 参数                              | 数值   |\n| --------------------------------- | ------ |\n| 最大不透光区域边界半径$r_{max}$ | 3.4220 |\n| 边界达到最大值的时间$t_1$       | 2.9275 |\n| 烟雾完全消失的时间$t_2$         | 7.9577 |\n\n观测到不透光区域边界达到最大的时刻 $t_1$, 可以预报烟雾消失的时刻 $t_2$\n\n> 1. **蓝色曲线**$r(t) = \\sqrt{4kt \\ln \\left(\\frac{\\alpha Q}{4\\pi k \\mu t}\\right)}$:\n>    - 该曲线表示不透光区域的边界半径 $r(t)$随时间 $ t$ 的变化。\n>    - 在爆炸初始时刻，烟雾边界迅速扩散，边界半径增大。\n>    - 随着时间的推移，边界半径达到一个最大值，然后开始减小，直到最后烟雾完全消失。\n> 2. **红色虚线**(垂直线)$t_1 = \\frac{\\alpha Q}{4 \\pi k \\mu e}$:\n>    - 这条红色虚线表示边界半径达到最大值的时间$t_1$。\n>    - 从图中可以看到，边界半径在此时刻 $t_1$达到了峰值。\n> 3. **绿色虚线**(水平线)$r_m = \\sqrt{\\frac{Q}{\\pi \\mu e}}$:\n>    - 这条绿色虚线表示不透光区域边界的最大半径 $ r_m$。\n>    - 该半径在 $t_1$ 时刻达到，这是烟雾扩散过程中的最大范围。\n> 4. **蓝色虚线**(垂直线)$t_2 = \\frac{\\alpha Q}{4 \\pi k \\mu}$:\n>    - 这条蓝色虚线表示烟雾完全消失的时间 $t_2 $。\n>    - 此时，边界半径 $r(t)$已经缩小至零，意味着烟雾已经完全消散。\n\n## 代码\n\n```python\nimport numpy as np\nimport matplotlib.pyplot as plt\n\n# 定义常数(这些常数可以根据特定情况进行设置)\nk = 1.0  # 扩散系数\nalpha = 1.0  # 参数alpha\nQ = 1.0  # 炮弹释放的烟雾总量\nmu = 0.01  # 仪器灵敏度\npi = np.pi\n\n# 定义不透光区域边界半径 r(t)\ndef r(t):\n    return np.sqrt(4 * k * t * np.log(alpha * Q / (4 * pi * k * mu * t)))\n\n# 计算最大边界半径和相关时间点\nt1 = alpha * Q / (4 * pi * k * mu * np.e)\nr_max = np.sqrt(Q / (pi * mu * np.e))\nt2 = alpha * Q / (4 * pi * k * mu)\n\n# 时间范围\nt = np.linspace(0.1, t2 * 1.5, 500)  # 从小于 t2 的时间开始\n\n# 绘制不透光区域边界随时间的变化\nplt.figure(figsize=(10, 6))\nplt.plot(t, r(t), label=r'$r(t) = \\sqrt{4 kt **\\l**n **\\f**rac{**\\a**lpha Q}{4 **\\p**i k **\\m**u t}}$')\nplt.axvline(t1, color='r', linestyle='--', label=r'$t_1 = **\\f**rac{**\\a**lpha Q}{4 **\\p**i k **\\m**u e}$')\nplt.axhline(r_max, color='g', linestyle='--', label=r'$r_m = \\sqrt{**\\f**rac{Q}{**\\p**i **\\m**u e}}$')\nplt.axvline(t2, color='b', linestyle='--', label=r'$t_2 = **\\f**rac{**\\a**lpha Q}{4 **\\p**i k **\\m**u}$')\nplt.xlabel('Time t')\nplt.ylabel('Boundary Radius r(t)')\nplt.title('Smoke Diffusion and Dissipation Model')\nplt.legend()\nplt.grid(True)\nplt.show()\n\n# 输出最大边界半径和相关时间点\nprint(f\"最大不透光区域边界半径 r_max = {r_max:.4f}\")\nprint(f\"边界达到最大值的时间 t1 = {t1:.4f}\")\nprint(f\"烟雾完全消失的时间 t2 = {t2:.4f}\")\n```\n","source":"_posts/2025-02-11-数模笔记_微分方程与差分方程.md","raw":"---\ntitle: 2025-02-11-数模笔记_微分方程与差分方程\ndate: 2025-02-11\ntags: 数学建模\n---\n# 微分方程与差分方程\n\n# 一、概述\n\n![17393373960371739337395061.png](https://tk-pichost-1325224430.cos.ap-chengdu.myqcloud.com/blog/17393373960371739337395061.png)\n\n| 年份    | 题目                                | 相关方法或理论                               |\n| ------- | ----------------------------------- | -------------------------------------------- |\n| 1996 年 | A: 最优捕鱼策略问题                 | 微分方程的问题                               |\n|         | B: 节水洗衣机的程序设计问题         | 偏微分方程，也可以用优化                     |\n| 2003 年 | A: SARS 的传播问题                  | 预测类问题，可用差分方程、微分方程           |\n|         | D: 抢渡长江问题                     | 微分方程、优化问题                           |\n| 2004 年 | C: 酒后开车问题                     | 微分方程                                     |\n| 2008 年 | A: 数码相机定位（机理分析）         | 模糊数学、微分方程                           |\n|         | B: 高等教育学费标准探讨问题         | 模糊数学、微分方程                           |\n| 2009 年 | A: 制动器试验台的控制方法问题       | 微分方程、优化（求解物理应用题）             |\n| 2014 年 | A: 缆坡三号软着陆轨道设计与控制策略 | 常微分方程目标规划、优化模型                 |\n|         | B: 创意平板折叠桌                   | 力学方程、物理模型、多目标规划               |\n| 2015 年 | 太阳影子定位（机理分析）            | 偏微分方程                                   |\n| 2018 年 | A: 高温作业专用服装设计             | 偏微分方程、单目标规划、双目标规划           |\n| 2019 年 | A: 高压油管的压力控制               | 数据预处理、常微分方程、单目标规划           |\n|         | B: “同心协力”策略研究             | 二维碰撞、二维碰撞（常微分方程）、多目标规划 |\n| 2020 年 | A: 沪温曲线                         | 热传导、有限差分法、遍历法                   |\n| 2022 年 | A: 波浪能最大输出功率设计           | 微分方程、模拟仿真、最优解                   |\n| 2023 年 | A: 优化设计启目镜场以及发电问题     | 微分方程、优化问题                           |\n\n## 微分方程模型介绍\n\n### 模型介绍\n\n微分方程建模是数学建模的重要方法，因为许多实际问题的数学描述将导致求解微分方程的定解问题。解决相应问题可以按以下几步：\n\n1. 根据实际要求确定要研究的量（自变量、未知函数、必要的参数等）并确定坐标系。\n2. 找出这些量所满足的基本规律（物理的、几何的、化学的或生物学的等）。\n3. 运用这些规律列出方程和定解条件。\n4. 求解、分析结果。\n\n### 列方程常见的方法\n\n1. **微元分析法与任意区域上取积分的方法**\n\n   通过微元分析法，利用已知的规律建立一些变量（自变量与未知函数）的微元之间的关系式，然后再通过取极限的方法得到微分方程，或等价地通过任意区域上取积分的方法来建立微分方程。\n2. **按规律直接列方程**\n\n   在数学、力学、物理、化学等学科中许多自然现象所满足的规律已为人们所熟悉，并直接由微分方程所描述。我们常利用这些规律对某些实际问题列出微分方程。\n3. **模拟近似法**\n\n   在生物、经济等学科中，许多现象所满足的规律并不很清楚且相当复杂，因此需要根据实际资料或大量的实验数据，提出各种假设。在一定的假设下，给出实际现象所满足的规律，然后利用适当的数学方法列出微分方程。\n\n### 例题\n\n一个较热的物体置于室温为 18°C 的房间内，该物体最初的温度是 60°C，3 分钟以后降到 50°C。想知道它的温度降到 30°C 需要多少时间？10 分钟以后它的温度是多少？\n\n**牛顿冷却（加热）定律**：将温度为 $T$ 的物体放入处于常温 $m$ 的介质中时，$T$ 的变化速率正比于 $T$ 与周围介质的温度差。\n\n牛顿冷却定律描述了物体温度随时间变化的过程。根据牛顿冷却定律，温度 $T(t)$ 随时间 $t$ 的变化满足以下微分方程：\n\n$$\n\\frac{dT}{dt} = -k(T - m)\n$$\n\n其中：\n\n- $T(t)$ 是物体在时间 $t$ 时的温度。\n- $m$ 是环境温度。\n- $k$ 是冷却常数，取决于物体和环境的性质。\n\n我们可以通过积分这个方程得到 $ T(t) $ 的表达式：\n\n$$\nT(t) = m + (T_0 - m) e^{-kt}\n$$\n\n其中：\n\n- $T_0$ 是物体的初始温度。\n\n我们根据给定条件来求解这个问题。具体步骤如下：\n\n1. 根据初始条件求解冷却常数 $k$。\n2. 使用 $k$ 求解物体温度降到 30°C 所需的时间。\n3. 计算 10 分钟后物体的温度。\n\n![uk2rco.png](https://files.catbox.moe/uk2rco.png)\n\n```python\nimport numpy as np\n\n# 已知条件\nT0 = 60  # 初始温度\nT1 = 50  # 3分钟后的温度\nT_room = 18  # 环境温度\ntime1 = 3  # 时间为3分钟\n\n# 求解冷却常数k\nk = -np.log((T1 - T_room) / (T0 - T_room)) / time1\n\n# 求解降到30度所需的时间\nT_target = 30\ntime_to_target = -np.log((T_target - T_room) / (T0 - T_room)) / k\n\n# 计算10分钟后的温度\ntime2 = 10\nT_after_10_minutes = T_room + (T0 - T_room) * np.exp(-k * time2)\n\n# 输出结果\nprint(f\"物体温度降到30°C所需的时间为: {time_to_target:.2f} 分钟\")\nprint(f\"10分钟后物体的温度为: {T_after_10_minutes:.2f} °C\")\n```\n\n# 二、传染病模型\n\n## 背景与问题\n\n- 描述传染病的传播过程。\n- 分析受感染人数的变化规律。\n- 预报传染病高潮到来的时刻。\n- 预防传染病蔓延的手段。\n\n> 基本方法:按照传播过程的一般规律建立数学模型\n\n![vopq8o.png](https://files.catbox.moe/vopq8o.png)\n\n### 模型 1：I 模型\n\n已感染人数（病人）记为$i(t)$\n\n假设：每个病人每天有效接触（足以使人致病）人数为 $\\lambda$。\n\n建模：\n\n> 求解采用的是分离变量法\n\n$$\ni(t + \\Delta t) - i(t) = i(t) \\lambda \\Delta t\n$$\n\n$$\n\\frac{di}{dt} = \\lambda i\n$$\n\n$$\ni(0) = i_0\n$$\n\n求解、分析、检验：\n\n$$\n\\frac{di}{dt} = \\lambda i\n$$\n\n$$\ni(0) = i_0\n$$\n\n$$\ni(t) = i_0 e^{\\lambda t}\n$$\n\n$$\nt \\rightarrow \\infty \\Rightarrow i(t) \\rightarrow \\infty\n$$\n\n![43qanr.png](https://files.catbox.moe/43qanr.png)\n\n> 显然这个模型的结果是不合理的,感染人数不可能超过总人数。\n> 若有效接触的是病人，则不能使病人数增加。\n> 必须区分已感染者和未感染者以及总人数。\n\n#### 代码\n\n```matlab\n%创建一个.m文件并命名为i_model.m\n% I Model\nfunction [t, i] = i_model(i0, lambda, tmax)\n    [t, i] = ode45(@(t, i) lambda * i, [0 tmax], i0);\nend\n```\n\n> 注意:要创建两个文件,上面的代码创建的是 matlab 的函数文件\n\n```matlab\n% 设置参数\ni0 = 1;  % 初始感染人数\nlambda = 0.5;  % 每天有效接触人数\ntmax = 20;  % 模拟时间\n\n% 求解模型\n[t, i] = i_model(i0, lambda, tmax);\n\n% 绘图\nfigure;\nplot(t, i);\ntitle('I Model');\nxlabel('Time');\nylabel('Infected Population');\n```\n\n### 模型 2：SI 模型\n\n区分已感染者和未感染者\n\n假设：\n\n1. 总人数 $N$ 不变，病人和健康人的**比例**分别为 $i(t), s(t)$。\n\n> 注意这里$i(t)$表示的是比例和上一个模型表示人数是不一样的\n\n1. 每个病人每天有效接触人数为 $\\lambda$，且使接触的健康人致病。\n\n建模：\n\n$$\nN[i(t + \\Delta t) - i(t)] = N i(t) \\lambda \\Delta t s(t)\n$$\n\n$$\n\\frac{di}{dt} = \\lambda s i\n$$\n\n$$\ns(t) + i(t) = 1\n$$\n\n求解、分析、检验：\n\n$$\n\\begin{cases}\n\\frac{di}{dt} = \\lambda i (1 - i) \\\\\ni(0) = i_0\n\\end{cases}\n$$\n\n$$\n\\int \\frac{di}{i(1 - i)} = \\int \\lambda dt\n$$\n\n$$\ni(t) = \\frac{1}{1 + \\left(\\frac{1}{i_0} - 1\\right)e^{-\\lambda t}}\n$$\n\n![4ufuyo.png](https://files.catbox.moe/4ufuyo.png)\n\n![jkyrhf.png](https://files.catbox.moe/jkyrhf.png)\n\n$t = t_m$ 时, $\\frac{di}{dt}$ 最大\n\n$t_m \\sim$ 传染病高峰到来的时刻\n\n$$\nt_m = \\lambda^{-1} \\ln \\left(\\frac{1}{i_0} - 1\\right)\n$$\n\n$$\n\\lambda\\downarrow \\rightarrow t_m \\uparrow\n$$\n\n$$\nt \\rightarrow \\infty \\Rightarrow i \\rightarrow 1\n$$\n\n#### 代码\n\n```matlab\n%创建一个.m文件并命名为si_model.m\n% SI Model\nfunction [t, y] = si_model(i0, lambda, tmax)\n    [t, y] = ode45(@(t, y) [lambda * y(1) * (1 - y(1))], [0 tmax], i0);\nend\n```\n\n> 注意:要创建两个文件,上面的代码创建的是 matlab 的函数文件\n\n```matlab\n% 设置参数\ni0 = 0.1; % 初始感染比例\nlambda = 0.5; % 每天有效接触人数\ntmax = 50; % 模拟时间\n\n% 求解模型\n[t, i] = si_model(i0, lambda, tmax);\n\n% 找到 infected 和 susceptible 比例为 0.5 的时间点\ninfected_half = interp1(i, t, 0.5);\nsusceptible_half = interp1(1-i, t, 0.5);\n\n% 绘图\nfigure;\nplot(t, i, 'b', 'LineWidth', 2);\nhold on;\nplot(t, 1-i, 'r', 'LineWidth', 2);\n\n% 标记 infected 和 susceptible 比例为 0.5 的点\nplot(infected_half, 0.5, 'bo', 'MarkerSize', 10, 'MarkerFaceColor', 'b');\nplot(susceptible_half, 0.5, 'ro', 'MarkerSize', 10, 'MarkerFaceColor', 'r');\n\n% 添加标记点的文本说明\ntext(infected_half, 0.55, ['t_mi = ', num2str(infected_half, '%.2f')], 'Color', 'b', 'HorizontalAlignment', 'right');\ntext(susceptible_half, 0.55, ['t_ms = ', num2str(susceptible_half, '%.2f')], 'Color', 'r', 'HorizontalAlignment', 'left');\n\ntitle('SI Model');\nxlabel('Time');\nylabel('Population Ratio');\nlegend('Infected', 'Susceptible', 'Location', 'north');\n\n% 添加水平线以突出 0.5 比例\nyline(0.5, '--k', 'LineWidth', 1);\n\n% 计算传染病高峰时刻\ntm = 1/lambda * log((1/i0) - 1);\ndisp(['Peak time: ', num2str(tm)]);\n\n% 设置坐标轴范围，确保标记点可见\nylim([0 1.1]);\n```\n\n### 模型 3：SIS 模型\n\n考虑病人自愈且可再次被感染\n\n传染病无免疫性——病人治愈成为健康人，健康人可再次被感染。\n\n增加假设：\n\n病人每天治愈的比例为 $\\mu$\n\n$\\lambda \\sim$ 日接触率\n\n$\\mu \\sim$ 日治愈率\n\n$$\n\\sigma = \\lambda / \\mu\n$$\n\n建模：\n\n$$\nN[i(t + \\Delta t) - i(t)] = Ni(t)\\lambda \\Delta t s(t) - Ni(t) \\mu \\Delta t\n$$\n\n$$\n\\begin{cases}\n\\frac{di}{dt} = \\lambda i (1 - i) - \\mu i = -\\lambda i \\left[i - \\left(1 - \\frac{1}{\\sigma}\\right)\\right] \\\\\ni(0) = i_0\n\\end{cases}\n$$\n\n求解分析检验:\n\n$$\n\\frac{di}{dt} = -\\lambda i \\left[i - \\left(1 - \\frac{1}{\\sigma}\\right)\\right]\n$$\n\n![potjqt.png](https://files.catbox.moe/potjqt.png)\n\n![upnnn3.png](https://files.catbox.moe/upnnn3.png)\n\n#### 代码\n\n```matlab\n%创建一个.m文件并命名为sis_model.m\n% SIS Model\nfunction [t, y] = sis_model(i0, lambda, mu, tmax)\n    [t, y] = ode45(@(t, y) [lambda * y(1) * (1 - y(1)) - mu * y(1)], [0 tmax], i0);\nend\n```\n\n> 注意:要创建两个文件,上面的代码创建的是 matlab 的函数文件\n\n```matlab\n% 设置参数\ni0 = 0.01;  % 初始感染比例\nlambda = 0.5;  % 每天有效接触人数\nmu = 0.1;  % 每天治愈比例\ntmax = 100;  % 模拟时间\n\n% 求解模型\n[t, i] = sis_model(i0, lambda, mu, tmax);\n\n% 绘图\nfigure;\nplot(t, i);\nhold on;\nplot(t, 1-i);\ntitle('SIS Model');\nxlabel('Time');\nylabel('Population Ratio');\nlegend('Infected', 'Susceptible');\n\n% 计算平衡点\nequilibrium = 1 - mu/lambda;\ndisp(['Equilibrium point: ', num2str(equilibrium)]);\n\n% 情况1: σ > 1\nlambda1 = 0.5;\nmu1 = 0.2;\n[t1, i1] = sis_model(i0, lambda1, mu1, tmax);\n\n% 情况2: σ ≤ 1\nlambda2 = 0.2;\nmu2 = 0.5;\n[t2, i2] = sis_model(i0, lambda2, mu2, tmax);\n\n% 绘图\nfigure;\nsubplot(1,2,1);\nplot(t1, i1);\ntitle('SIS Model: σ > 1');\nxlabel('Time');\nylabel('Infected Ratio');\nyline(1 - mu1/lambda1, '--r', 'Equilibrium');\n\nsubplot(1,2,2);\nplot(t2, i2);\ntitle('SIS Model: σ ≤ 1');\nxlabel('Time');\nylabel('Infected Ratio');\n\n% 显示R₀值\ndisp(['R₀ (Case 1): ', num2str(lambda1/mu1)]);\ndisp(['R₀ (Case 2): ', num2str(lambda2/mu2)]);\n```\n\n### 模型 4：SIR 模型\n\n传染病有免疫性——病人治愈后即移出感染系统，称为**移出者**。\n\n假设：\n\n1. 总人数 $N$ 不变，病人、健康人和移出者的比例分别为 $i(t), s(t), r(t)$。\n2. 病人的日接触率 $\\lambda$, 日治愈率 $\\mu$, 接触数 $\\sigma = \\lambda / \\mu$\n\n建模：\n\n$$\ns(t) + i(t) + r(t) = 1\n$$\n\n需要建立 $i(t), s(t), r(t)$ 的两个方程。\n\n$$\nN[r(t + \\Delta t) - r(t)] = Ni(t) \\mu \\Delta t\n$$\n\n$$\nN[i(t + \\Delta t) - i(t)] = Ni(t)\\lambda \\Delta t s(t) - Ni(t) \\mu \\Delta t\n$$\n\n$$\nN[s(t + \\Delta t) - s(t)] = -\\lambda Ns(t)i(t) \\Delta t\n$$\n\n$$\ni_0 + s_0 \\approx 1 \\quad (通常r(0) = r_0 很小)\n$$\n\n求解分析检验:\n\n$$\n\\begin{cases}\n\\frac{di}{dt} = \\lambda si - \\mu i \\\\\n\\frac{ds}{dt} = -\\lambda si \\\\\ni(0) = i_0, \\quad s(0) = s_0\\\\\ni_0 + s_0 \\approx 1 \\quad (通常r(0) = r_0 很小)\n\\end{cases}\n$$\n\n> 由于无法求出 $i(t), s(t)$ 的解析解。\n> 我们考虑其他办法:\n>\n> 1. 数值计算\n> 2. 定性分析\n>    相平面上研究解析性质。\n\n#### SIR 模型的数值解\n\n设 $\\lambda = 1$, $\\mu = 0.3$, $i_0 = 0.02$, $s_0 = 0.98$, 用 MATLAB 计算作图 $i(t)$,$s(t)$及 $i(s)$\n\n$$\n\\frac{di}{ds} = \\frac{\\lambda si - \\mu i}{-\\lambda si}\n$$\n\n![17393389691728c9d5531aed64ccb881b7886773b424b.png](https://tk-pichost-1325224430.cos.ap-chengdu.myqcloud.com/blog/17393389691728c9d5531aed64ccb881b7886773b424b.png)\n\n![1739338986650311b4ff45f134c2c84cb248ba699a0a1.png](https://tk-pichost-1325224430.cos.ap-chengdu.myqcloud.com/blog/1739338986650311b4ff45f134c2c84cb248ba699a0a1.png)\n\n#### 模型的相轨线分析\n\n对于前面求解分析检验的方程组\n\n消去 $dt$, $\\sigma = \\lambda / \\mu$\n\n$$\n\\begin{cases}\n\\frac{di}{ds} = \\frac{1}{\\sigma s} - 1 \\\\\ni \\big|_{s = s_0} = i_0\n\\end{cases}\n$$\n\n相轨线:\n\n$$\ni(s) = (s_0 + i_0) - s + \\frac{1}{\\sigma} \\ln \\frac{s}{s_0}\n$$\n\n相轨线 $i(s)$ 的定义域：\n\n$$\nD = \\{(s, i) | s \\geq 0, i \\geq 0, s + i \\leq 1\\}\n$$\n\n$s(t)$ 单调递减 $\\rightarrow$ 相轨线的方向\n\n![1739339031385fbb865dcb636407682dda5b02724f9bf.png](https://tk-pichost-1325224430.cos.ap-chengdu.myqcloud.com/blog/1739339031385fbb865dcb636407682dda5b02724f9bf.png)\n\n#### 预防传染病蔓延的手段\n\n传染病不蔓延的条件—— $s_0 < 1/\\sigma$\n\n- 提高阈值 $1/\\sigma$\n\n  - 降低 $\\sigma$\n  - $\\lambda$ (日接触率) $\\downarrow \\rightarrow$ 卫生水平 $\\uparrow$\n  - $\\mu$ (日治愈率) $\\uparrow \\rightarrow$ 医疗水平 $\\uparrow$\n- 降低 $s_0$\n\n  - 提高 $r_0$$\\rightarrow$群体免疫\n\n$$\ns_0 + i_0 + r_0 = 1\n$$\n\n#### 代码\n\n```matlab\n%创建一个.m文件并命名为i_model.m\n% SIR Model\nfunction [t, y] = sir_model(i0, s0, lambda, mu, tmax)\n    [t, y] = ode45(@(t, y) [\n        lambda * y(1) * y(2) - mu * y(1)  % di/dt\n        -lambda * y(1) * y(2)  % ds/dt\n        mu * y(1)  % dr/dt\n    ], [0 tmax], [i0; s0; 1-i0-s0]);\nend\n```\n\n> 注意:要创建两个文件,上面的代码创建的是 matlab 的函数文件\n\n```matlab\n% 设置参数\ni0 = 0.01;  % 初始感染比例\ns0 = 0.99;  % 初始易感比例\nlambda = 0.5;  % 每天有效接触人数\nmu = 0.1;  % 每天治愈比例\ntmax = 100;  % 模拟时间\n\n% 求解模型\n[t, y] = sir_model(i0, s0, lambda, mu, tmax);\n\n% 绘图\nfigure;\nplot(t, y);\ntitle('SIR Model');\nxlabel('Time');\nylabel('Population Ratio');\nlegend('Infected', 'Susceptible', 'Removed');\n\n% 相平面图\nfigure;\nplot(y(:,2), y(:,1));\ntitle('SIR Model Phase Plane');\nxlabel('Susceptible');\nylabel('Infected');\n\n% 计算R0\nR0 = lambda / mu;\ndisp(['R0: ', num2str(R0)]);\n```\n\n# 三、香烟过滤嘴的作用模型\n\n## 问题\n\n- 过滤嘴的作用与它的材料和长度有什么关系？\n- 人体吸入的毒物量与哪些因素有关，其中什么因素影响大，什么因素影响小？\n\n## 模型分析\n\n- 分析吸烟时毒物进入人体的过程，建立吸烟过程的数学模型。\n\n## 模型假设\n\n1. $l_1 \\sim$ 烟草长, $l_2 \\sim$ 过滤嘴长, $l = l_1 + l_2$, 毒物总量 $M$ 均匀分布，密度 $w_0 = M/l$。\n2. 点燃处毒物进入空气和沿香烟穿行的数量比是 $a : a'$, $a' + a = 1$。\n3. 未点燃的烟草和过滤嘴对穿行的毒物的单位时间吸收速率分别是 $b$ 和 $\\beta$。\n4. 烟雾沿香烟穿行速度是常数 $v$, 香烟燃烧速度是常数 $u$, $v \\gg u$。\n\n![1739339098264762c0aa149f14ae599a418c4309aa91a.png](https://tk-pichost-1325224430.cos.ap-chengdu.myqcloud.com/blog/1739339098264762c0aa149f14ae599a418c4309aa91a.png)\n\n## 模型建立\n\n$t = 0, x = 0$, 点燃香烟\n\n$q(x,t) \\sim$ 毒物在 $x$ 处的流速（单位时间的流量）\n\n$w(x,t) \\sim$ 毒物密度\n\n$$\nw(x,0) = w_0\n$$\n\n$$\nQ = \\int_0^T q(l, t) dt, \\quad T = l_1 / u\n$$\n\n1. 求 $q(x,t)$\n\n流量守恒：\n\n$$\n\\begin{cases}\nq(x,t) - q(x+\\Delta x,t) = \\frac{q(x,t)b\\Delta x}{v}, & ut \\leq x \\leq l_1 \\\\\nq(x,t) - q(x+\\Delta x,t) = \\frac{q(x,t)\\beta\\Delta x}{v}, & l_1 \\leq x \\leq l\n\\end{cases}\n$$\n\n$$\n\\frac{dq(x,t)}{dx} = \n\\begin{cases}\n-\\frac{b}{v}q(x,t), & ut \\leq x \\leq l_1 \\\\\n-\\frac{\\beta}{v}q(x,t), & l_1 \\leq x \\leq l\n\\end{cases}\n$$\n\n定解条件：$q(ut,t) = auw(ut,t)$\n\n1. 求 $w(ut,t)$ 考察 $\\Delta t$ 内毒物密度的增量\n\n$$\nw(x, t + \\Delta t) - w(x, t) = \\frac{q(x,t)\\Delta t b\\Delta t}{v\\Delta t}\n$$\n\n其中：$q(x,t) = auw(ut,t)e^{-\\frac{b(x-ut)}{v}}$\n\n$$\n\\begin{cases}\\frac{\\partial w(ut,t)}{\\partial t} = \\frac{b}{v}auw(ut,t)e^{-\\frac{b(x-ut)}{v}}\\\\\nw(x,0)=w_0\n\\end{cases}\n$$\n\n$$\nw(ut,t) = \\frac{w_0}{a'}\\left(1 - ae^{-\\frac{a'but}{v}}\\right), \\quad a' = 1-a\n$$\n\n1. 计算 $Q$~吸一支烟毒物进入人体总量\n\n$$\nw(ut,t) = \\frac{w_0}{a'}\\left(1 - ae^{-\\frac{a'but}{v}}\\right)\n$$\n\n$$\nq(l,t) = auw(ut,t)e^{-\\frac{b l_1-wt}{v}}e^{-\\frac{\\beta l_2}{v}}\\\\\n$$\n\n$$\nQ = \\int_0^{l_1/u} q(l,t) dt = \\frac{auw_0}{a'b} e^{-\\frac{\\beta l_2}{v}}\\left(1 - e^{-\\frac{a'bl_1}{v}}\\right)\n$$\n\n$$\nQ = aMe^{-\\frac{\\beta l_2}{v}} \\varphi(r), \\quad r = \\frac{a'bl_1}{v}, \\quad \\varphi(r) = \\frac{1 - e^{-r}}{r}\n$$\n\n## 结果分析\n\n1. $Q$ 与 $a, M$ 成正比。($aM$ 是毒物集中在 $x = l_1$ 处的吸入量)\n2. $e^{-\\frac{\\beta l_2}{v}} \\sim$ 过滤嘴因素, $\\beta, l_2 \\sim$ 负指数作用\n3. $\\varphi(r) \\sim$ 烟草的吸收作用 （烟草为什么有作用？）\n\n$$\nr = \\frac{a'bl_1}{v} \\ll 1\n$$\n\n$$\n\\varphi(r) = 1 - \\frac{r}{2}\n$$\n\n$$\nQ = aMe^{-\\frac{\\beta l_2}{v}}\\left(1 - \\frac{a'bl_1}{2v}\\right), \\quad b,l_1 \\sim \\text{线性作用}\n$$\n\n1. 与另一支不带过滤嘴的香烟比较，$w_0, b, a, v, l$ 均相同，吸至 $x = l_1$ 抛掉。\n\n**带过滤嘴**:\n\n$$\nQ_1 = \\frac{a w_0 v}{a' b} e^{-\\frac{\\beta l_2}{v}} \\left(1 - e^{-\\frac{a' b l_1}{v}}\\right)\n$$\n\n**不带过滤嘴**:\n\n$$\nQ_2 = \\frac{a w_0 v}{a' b} \\left(1 - e^{-\\frac{a' b l_1}{v}}\\right)\n$$\n\n$$\n\\frac{Q_1}{Q_2} = e^{-\\frac{(\\beta - b) l_2}{v}}\n$$\n\n$$\n\\beta > b \\Rightarrow Q_1 < Q_2\n$$\n\n提高 $\\beta b$ 与加长 $l_2$，效果相同。\n\n## 总结\n\n- 引入两个基本函数：流量 $q(x,t)$ 和密度 $w(x,t)$，运用物理学的守恒定律通过微元方法建立微分方程，构造动态模型。\n- 对求解结果进行定性和定量分析，得到合理的实际结论。\n\n![17393391272532c0a5ec759324803b6b1d6f399985c6d.png](https://tk-pichost-1325224430.cos.ap-chengdu.myqcloud.com/blog/17393391272532c0a5ec759324803b6b1d6f399985c6d.png)\n\n## 代码\n\n```python\nimport numpy as np\nimport matplotlib.pyplot as plt\n\n#参数设置\nM = 1.0  #毒物总量 (任意单位)\na = 0.5  #毒物进入空气和穿行的比例 (a = 0.5, a' = 0.5)\nb = 0.1  #烟草的吸收系数\nbeta = 0.8  #过滤嘴的吸收系数, 增大以突出非线性效果\nv = 1.0  #烟雾穿行速度\nl1 = 1.0  #烟草长度\nl2_values = np.linspace(0, 10, 100)  #过滤嘴长度的变化范围, 增大以观察非线性效果\n\n#计算 Q1 和 Q2\ndef calculate_Q(l1, l2, a, M, b, beta, v):\n    a_prime = 1 - a\n    r = a_prime * b * l1 / v\n    Q1 = (a * M * v / (a_prime * b)) * np.exp(-beta * l2 / v) * (1 - np.exp(-r))\n    Q2 = (a * M * v / (a_prime * b)) * (1 - np.exp(-r))\n    return Q1, Q2\n\nQ1_values = []\nQ2_values = []\nfor l2 in l2_values:\n    Q1, Q2 = calculate_Q(l1, l2, a, M, b, beta, v)\n    Q1_values.append(Q1)\n    Q2_values.append(Q2)\n\n#比较有过滤嘴和无过滤嘴的毒物量\nQ1_values = np.array(Q1_values)\nQ2_values = np.array(Q2_values)\nQ_ratio = Q1_values / Q2_values\n\n#绘图\nplt.figure(figsize=(10, 6))\nplt.plot(l2_values, Q1_values, label='Q1 (With Filter)')\nplt.plot(l2_values, Q2_values, label='Q2 (Without Filter)')\nplt.plot(l2_values, Q_ratio, label='Q1/Q2 Ratio', linestyle='--')\nplt.xlabel('Filter Length l2')\nplt.ylabel('Toxin Amount Q')\nplt.title('Effect of Filter Length and Material on Toxin Inhalation')\nplt.legend()\nplt.grid(True)\nplt.show()\n```\n\n# 四、烟雾的扩散与消失模型\n\n## 现象和问题\n\n- 炮弹在空中爆炸，烟雾向四周扩散，形成圆形不透光区域。\n- 不透光区域不断扩大，然后区域边界逐渐明亮，区域缩小，最后烟雾消失。\n- 建立模型描述烟雾扩散和消失过程，分析消失时间与各因素的关系。\n\n## 问题分析\n\n- 无穷空间由瞬时点源导致的扩散过程，用二阶偏微分方程描述烟雾浓度的变化。\n- 观察到的烟雾消失与烟雾对光线的吸收，以及仪器对明暗的灵敏度有关。\n\n## 模型假设\n\n1. 扩散服从扩散定律。\n2. 光线穿过烟雾时光强的相对减少与与烟雾浓度成正比；无烟雾的大小不影响光强。\n3. 穿过烟雾进入仪器的光线只有明暗之分，明暗界限由仪器灵敏度决定。\n\n## 模型建立\n\n**扩散定律**：单位时间通过单位法向面积的流量 $q$ 与浓度 $C$ 的梯度成正比。\n\n$$\nq = -k \\cdot \\nabla C\n$$\n\n烟雾浓度 $C(x,y,z,t)$ 的变化规律\n\n$[t,t+\\Delta t]$ 通过$\\Omega$流出量$Q_1 = \\int_{t}^{t+\\Delta t} \\iint_S q \\cdot n d \\sigma dt$\n\n$\\Omega$ 内烟雾改变量 $Q_2 = \\iiint_{v} [C(x,y,z,t+\\Delta t) - C(x,y,z,t)] dV$\n\n高斯公式:\n\n$$\n\\iint_S q \\cdot n d\\sigma = \\iiint_V \\text{div } q dV = -k \\iiint_V \\text{div } (\\nabla C) dV\n$$\n\n$$\nQ_2 = -Q_1\n$$\n\n$$\n\\frac{\\partial C}{\\partial t} = k [\\text{div}(\\nabla C)] = k \\left(\\frac{\\partial^2 C}{\\partial x^2} + \\frac{\\partial^2 C}{\\partial y^2} + \\frac{\\partial^2 C}{\\partial z^2}\\right),-\\infty<x,y,z<\\infty,t>0\n$$\n\n## 初始条件\n\n$$\nC(x, y, z, 0) = Q \\delta(x, y, z)\n$$\n\n- $Q \\sim$ 炮弹释放的烟雾总量\n- $\\delta \\sim$ 单位强度的点源函数\n\n求解方程:\n\n$$\nC(x, y, z, t) = \\frac{Q}{(4 \\pi kt)^{3/2}} e^{-\\frac{x^2 + y^2 + z^2}{4 kt}}\n$$\n\n## 光强穿过烟雾时的变化规律\n\n- $I(l) \\sim$ 沿 $l$ 方向的光强\n- $C(l) \\sim$ 沿 $l$ 方向的烟雾浓度\n\n假设光强的相对减少与烟雾浓度成正比。\n\n$$\n\\frac{dI(l)}{dl} = -\\alpha C(l) I(l)\n$$\n\n记未进入烟雾($l \\leq l_0$)时光强为 $I(l_0) = I_0$:\n\n$$\nI(l) = I_0 e^{-\\alpha \\int_{l_0}^{l} C(s) ds}\n$$\n\n## 仪器灵敏度与烟雾明暗界限\n\n- 烟雾浓度连续变化\n- 烟雾中光强连续变化。\n- 穿过烟雾进入仪器的光线只有明暗之分，明暗界限由仪器灵敏度决定。\n\n$\\mu \\sim$ 仪器灵敏度，当 $I/I_0 < 1 - \\mu$，观测结果为暗。\n\n设光源在 $z = -\\infty$，仪器在 $z = \\infty$，则观测到的明暗界限为:\n\n$e^{-\\alpha \\int_{-\\infty}^{\\infty} C(x,y,z,t) dz} = 1 - \\mu$$\\sim$ 不透光区域边界\n\n### 求解方程\n\n$$\nC(x, y, z, t) = \\frac{Q}{(4 \\pi kt)^{3/2}} e^{-\\frac{x^2 + y^2 + z^2}{4 kt}}\n$$\n\n$$\n\\Rightarrow \\int_{-\\infty}^{\\infty} C(x,y,z,t) dz = \\frac{1}{\\alpha} \\ln \\frac{1}{1-\\mu} \\approx \\frac{\\mu}{\\alpha} \\quad (\\mu \\text{ 很小})\n$$\n\n而$\\quad \\int_{-\\infty}^{\\infty} C(x,y,z,t) dz = \\frac{Q}{4 \\pi kt} e^{-\\frac{x^2 + y^2}{4kt}}$\n\n$$\n\\frac{Q}{4 \\pi kt} e^{-\\frac{x^2 + y^2}{4 kt}} = \\frac{\\mu}{\\alpha}\n$$\n\n不透光区域边界半径:\n\n$$\nr(t) = \\sqrt{4 kt \\ln \\frac{\\alpha Q}{4 \\pi k \\mu t}}\n$$\n\n### 结果分析\n\n$$\nr(t) = \\sqrt{4 kt \\ln \\frac{\\alpha Q}{4 \\pi k \\mu t}}\n$$\n\n$$\nt = t_1 = \\frac{\\alpha Q}{4 \\pi k \\mu e}, \\quad r = r_m = \\sqrt{\\frac{Q}{\\pi \\mu e}} \\quad (\\text{最大值})\n$$\n\n$$\nt = t_2 = \\frac{\\alpha Q}{4 \\pi k \\mu}, \\quad r = 0\n$$\n\n$$\n\\alpha \\uparrow, Q \\uparrow, \\mu \\downarrow \\Rightarrow t_1 \\uparrow, r_m \\uparrow\n$$\n\n$$\nk \\downarrow \\Rightarrow t_1 \\uparrow\n$$\n\n![173933914986904ee6ddfd517468d93120f3cfe746ffd.png](https://tk-pichost-1325224430.cos.ap-chengdu.myqcloud.com/blog/173933914986904ee6ddfd517468d93120f3cfe746ffd.png)\n\n| 参数                              | 数值   |\n| --------------------------------- | ------ |\n| 最大不透光区域边界半径$r_{max}$ | 3.4220 |\n| 边界达到最大值的时间$t_1$       | 2.9275 |\n| 烟雾完全消失的时间$t_2$         | 7.9577 |\n\n观测到不透光区域边界达到最大的时刻 $t_1$, 可以预报烟雾消失的时刻 $t_2$\n\n> 1. **蓝色曲线**$r(t) = \\sqrt{4kt \\ln \\left(\\frac{\\alpha Q}{4\\pi k \\mu t}\\right)}$:\n>    - 该曲线表示不透光区域的边界半径 $r(t)$随时间 $ t$ 的变化。\n>    - 在爆炸初始时刻，烟雾边界迅速扩散，边界半径增大。\n>    - 随着时间的推移，边界半径达到一个最大值，然后开始减小，直到最后烟雾完全消失。\n> 2. **红色虚线**(垂直线)$t_1 = \\frac{\\alpha Q}{4 \\pi k \\mu e}$:\n>    - 这条红色虚线表示边界半径达到最大值的时间$t_1$。\n>    - 从图中可以看到，边界半径在此时刻 $t_1$达到了峰值。\n> 3. **绿色虚线**(水平线)$r_m = \\sqrt{\\frac{Q}{\\pi \\mu e}}$:\n>    - 这条绿色虚线表示不透光区域边界的最大半径 $ r_m$。\n>    - 该半径在 $t_1$ 时刻达到，这是烟雾扩散过程中的最大范围。\n> 4. **蓝色虚线**(垂直线)$t_2 = \\frac{\\alpha Q}{4 \\pi k \\mu}$:\n>    - 这条蓝色虚线表示烟雾完全消失的时间 $t_2 $。\n>    - 此时，边界半径 $r(t)$已经缩小至零，意味着烟雾已经完全消散。\n\n## 代码\n\n```python\nimport numpy as np\nimport matplotlib.pyplot as plt\n\n# 定义常数(这些常数可以根据特定情况进行设置)\nk = 1.0  # 扩散系数\nalpha = 1.0  # 参数alpha\nQ = 1.0  # 炮弹释放的烟雾总量\nmu = 0.01  # 仪器灵敏度\npi = np.pi\n\n# 定义不透光区域边界半径 r(t)\ndef r(t):\n    return np.sqrt(4 * k * t * np.log(alpha * Q / (4 * pi * k * mu * t)))\n\n# 计算最大边界半径和相关时间点\nt1 = alpha * Q / (4 * pi * k * mu * np.e)\nr_max = np.sqrt(Q / (pi * mu * np.e))\nt2 = alpha * Q / (4 * pi * k * mu)\n\n# 时间范围\nt = np.linspace(0.1, t2 * 1.5, 500)  # 从小于 t2 的时间开始\n\n# 绘制不透光区域边界随时间的变化\nplt.figure(figsize=(10, 6))\nplt.plot(t, r(t), label=r'$r(t) = \\sqrt{4 kt **\\l**n **\\f**rac{**\\a**lpha Q}{4 **\\p**i k **\\m**u t}}$')\nplt.axvline(t1, color='r', linestyle='--', label=r'$t_1 = **\\f**rac{**\\a**lpha Q}{4 **\\p**i k **\\m**u e}$')\nplt.axhline(r_max, color='g', linestyle='--', label=r'$r_m = \\sqrt{**\\f**rac{Q}{**\\p**i **\\m**u e}}$')\nplt.axvline(t2, color='b', linestyle='--', label=r'$t_2 = **\\f**rac{**\\a**lpha Q}{4 **\\p**i k **\\m**u}$')\nplt.xlabel('Time t')\nplt.ylabel('Boundary Radius r(t)')\nplt.title('Smoke Diffusion and Dissipation Model')\nplt.legend()\nplt.grid(True)\nplt.show()\n\n# 输出最大边界半径和相关时间点\nprint(f\"最大不透光区域边界半径 r_max = {r_max:.4f}\")\nprint(f\"边界达到最大值的时间 t1 = {t1:.4f}\")\nprint(f\"烟雾完全消失的时间 t2 = {t2:.4f}\")\n```\n","slug":"2025-02-11-数模笔记_微分方程与差分方程","published":1,"updated":"2025-09-26T12:15:04.954Z","_id":"cmg0saj3j0001jm8n9h6fdbws","comments":1,"layout":"post","photos":[],"content":"<h1 id=\"微分方程与差分方程\"><a href=\"#微分方程与差分方程\" class=\"headerlink\" title=\"微分方程与差分方程\"></a>微分方程与差分方程</h1><h1 id=\"一、概述\"><a href=\"#一、概述\" class=\"headerlink\" title=\"一、概述\"></a>一、概述</h1><p><img src=\"https://tk-pichost-1325224430.cos.ap-chengdu.myqcloud.com/blog/17393373960371739337395061.png\" alt=\"17393373960371739337395061.png\"></p>\n<table>\n<thead>\n<tr>\n<th>年份</th>\n<th>题目</th>\n<th>相关方法或理论</th>\n</tr>\n</thead>\n<tbody><tr>\n<td>1996 年</td>\n<td>A: 最优捕鱼策略问题</td>\n<td>微分方程的问题</td>\n</tr>\n<tr>\n<td></td>\n<td>B: 节水洗衣机的程序设计问题</td>\n<td>偏微分方程，也可以用优化</td>\n</tr>\n<tr>\n<td>2003 年</td>\n<td>A: SARS 的传播问题</td>\n<td>预测类问题，可用差分方程、微分方程</td>\n</tr>\n<tr>\n<td></td>\n<td>D: 抢渡长江问题</td>\n<td>微分方程、优化问题</td>\n</tr>\n<tr>\n<td>2004 年</td>\n<td>C: 酒后开车问题</td>\n<td>微分方程</td>\n</tr>\n<tr>\n<td>2008 年</td>\n<td>A: 数码相机定位（机理分析）</td>\n<td>模糊数学、微分方程</td>\n</tr>\n<tr>\n<td></td>\n<td>B: 高等教育学费标准探讨问题</td>\n<td>模糊数学、微分方程</td>\n</tr>\n<tr>\n<td>2009 年</td>\n<td>A: 制动器试验台的控制方法问题</td>\n<td>微分方程、优化（求解物理应用题）</td>\n</tr>\n<tr>\n<td>2014 年</td>\n<td>A: 缆坡三号软着陆轨道设计与控制策略</td>\n<td>常微分方程目标规划、优化模型</td>\n</tr>\n<tr>\n<td></td>\n<td>B: 创意平板折叠桌</td>\n<td>力学方程、物理模型、多目标规划</td>\n</tr>\n<tr>\n<td>2015 年</td>\n<td>太阳影子定位（机理分析）</td>\n<td>偏微分方程</td>\n</tr>\n<tr>\n<td>2018 年</td>\n<td>A: 高温作业专用服装设计</td>\n<td>偏微分方程、单目标规划、双目标规划</td>\n</tr>\n<tr>\n<td>2019 年</td>\n<td>A: 高压油管的压力控制</td>\n<td>数据预处理、常微分方程、单目标规划</td>\n</tr>\n<tr>\n<td></td>\n<td>B: “同心协力”策略研究</td>\n<td>二维碰撞、二维碰撞（常微分方程）、多目标规划</td>\n</tr>\n<tr>\n<td>2020 年</td>\n<td>A: 沪温曲线</td>\n<td>热传导、有限差分法、遍历法</td>\n</tr>\n<tr>\n<td>2022 年</td>\n<td>A: 波浪能最大输出功率设计</td>\n<td>微分方程、模拟仿真、最优解</td>\n</tr>\n<tr>\n<td>2023 年</td>\n<td>A: 优化设计启目镜场以及发电问题</td>\n<td>微分方程、优化问题</td>\n</tr>\n</tbody></table>\n<h2 id=\"微分方程模型介绍\"><a href=\"#微分方程模型介绍\" class=\"headerlink\" title=\"微分方程模型介绍\"></a>微分方程模型介绍</h2><h3 id=\"模型介绍\"><a href=\"#模型介绍\" class=\"headerlink\" title=\"模型介绍\"></a>模型介绍</h3><p>微分方程建模是数学建模的重要方法，因为许多实际问题的数学描述将导致求解微分方程的定解问题。解决相应问题可以按以下几步：</p>\n<ol>\n<li>根据实际要求确定要研究的量（自变量、未知函数、必要的参数等）并确定坐标系。</li>\n<li>找出这些量所满足的基本规律（物理的、几何的、化学的或生物学的等）。</li>\n<li>运用这些规律列出方程和定解条件。</li>\n<li>求解、分析结果。</li>\n</ol>\n<h3 id=\"列方程常见的方法\"><a href=\"#列方程常见的方法\" class=\"headerlink\" title=\"列方程常见的方法\"></a>列方程常见的方法</h3><ol>\n<li><p><strong>微元分析法与任意区域上取积分的方法</strong></p>\n<p>通过微元分析法，利用已知的规律建立一些变量（自变量与未知函数）的微元之间的关系式，然后再通过取极限的方法得到微分方程，或等价地通过任意区域上取积分的方法来建立微分方程。</p>\n</li>\n<li><p><strong>按规律直接列方程</strong></p>\n<p>在数学、力学、物理、化学等学科中许多自然现象所满足的规律已为人们所熟悉，并直接由微分方程所描述。我们常利用这些规律对某些实际问题列出微分方程。</p>\n</li>\n<li><p><strong>模拟近似法</strong></p>\n<p>在生物、经济等学科中，许多现象所满足的规律并不很清楚且相当复杂，因此需要根据实际资料或大量的实验数据，提出各种假设。在一定的假设下，给出实际现象所满足的规律，然后利用适当的数学方法列出微分方程。</p>\n</li>\n</ol>\n<h3 id=\"例题\"><a href=\"#例题\" class=\"headerlink\" title=\"例题\"></a>例题</h3><p>一个较热的物体置于室温为 18°C 的房间内，该物体最初的温度是 60°C，3 分钟以后降到 50°C。想知道它的温度降到 30°C 需要多少时间？10 分钟以后它的温度是多少？</p>\n<p><strong>牛顿冷却（加热）定律</strong>：将温度为 $T$ 的物体放入处于常温 $m$ 的介质中时，$T$ 的变化速率正比于 $T$ 与周围介质的温度差。</p>\n<p>牛顿冷却定律描述了物体温度随时间变化的过程。根据牛顿冷却定律，温度 $T(t)$ 随时间 $t$ 的变化满足以下微分方程：</p>\n<p>$$<br>\\frac{dT}{dt} &#x3D; -k(T - m)<br>$$</p>\n<p>其中：</p>\n<ul>\n<li>$T(t)$ 是物体在时间 $t$ 时的温度。</li>\n<li>$m$ 是环境温度。</li>\n<li>$k$ 是冷却常数，取决于物体和环境的性质。</li>\n</ul>\n<p>我们可以通过积分这个方程得到 $ T(t) $ 的表达式：</p>\n<p>$$<br>T(t) &#x3D; m + (T_0 - m) e^{-kt}<br>$$</p>\n<p>其中：</p>\n<ul>\n<li>$T_0$ 是物体的初始温度。</li>\n</ul>\n<p>我们根据给定条件来求解这个问题。具体步骤如下：</p>\n<ol>\n<li>根据初始条件求解冷却常数 $k$。</li>\n<li>使用 $k$ 求解物体温度降到 30°C 所需的时间。</li>\n<li>计算 10 分钟后物体的温度。</li>\n</ol>\n<p><img src=\"https://files.catbox.moe/uk2rco.png\" alt=\"uk2rco.png\"></p>\n<figure class=\"highlight python\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">import</span> numpy <span class=\"keyword\">as</span> np</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\"># 已知条件</span></span><br><span class=\"line\">T0 = <span class=\"number\">60</span>  <span class=\"comment\"># 初始温度</span></span><br><span class=\"line\">T1 = <span class=\"number\">50</span>  <span class=\"comment\"># 3分钟后的温度</span></span><br><span class=\"line\">T_room = <span class=\"number\">18</span>  <span class=\"comment\"># 环境温度</span></span><br><span class=\"line\">time1 = <span class=\"number\">3</span>  <span class=\"comment\"># 时间为3分钟</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\"># 求解冷却常数k</span></span><br><span class=\"line\">k = -np.log((T1 - T_room) / (T0 - T_room)) / time1</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\"># 求解降到30度所需的时间</span></span><br><span class=\"line\">T_target = <span class=\"number\">30</span></span><br><span class=\"line\">time_to_target = -np.log((T_target - T_room) / (T0 - T_room)) / k</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\"># 计算10分钟后的温度</span></span><br><span class=\"line\">time2 = <span class=\"number\">10</span></span><br><span class=\"line\">T_after_10_minutes = T_room + (T0 - T_room) * np.exp(-k * time2)</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\"># 输出结果</span></span><br><span class=\"line\"><span class=\"built_in\">print</span>(<span class=\"string\">f&quot;物体温度降到30°C所需的时间为: <span class=\"subst\">&#123;time_to_target:<span class=\"number\">.2</span>f&#125;</span> 分钟&quot;</span>)</span><br><span class=\"line\"><span class=\"built_in\">print</span>(<span class=\"string\">f&quot;10分钟后物体的温度为: <span class=\"subst\">&#123;T_after_10_minutes:<span class=\"number\">.2</span>f&#125;</span> °C&quot;</span>)</span><br></pre></td></tr></table></figure>\n\n<h1 id=\"二、传染病模型\"><a href=\"#二、传染病模型\" class=\"headerlink\" title=\"二、传染病模型\"></a>二、传染病模型</h1><h2 id=\"背景与问题\"><a href=\"#背景与问题\" class=\"headerlink\" title=\"背景与问题\"></a>背景与问题</h2><ul>\n<li>描述传染病的传播过程。</li>\n<li>分析受感染人数的变化规律。</li>\n<li>预报传染病高潮到来的时刻。</li>\n<li>预防传染病蔓延的手段。</li>\n</ul>\n<blockquote>\n<p>基本方法:按照传播过程的一般规律建立数学模型</p>\n</blockquote>\n<p><img src=\"https://files.catbox.moe/vopq8o.png\" alt=\"vopq8o.png\"></p>\n<h3 id=\"模型-1：I-模型\"><a href=\"#模型-1：I-模型\" class=\"headerlink\" title=\"模型 1：I 模型\"></a>模型 1：I 模型</h3><p>已感染人数（病人）记为$i(t)$</p>\n<p>假设：每个病人每天有效接触（足以使人致病）人数为 $\\lambda$。</p>\n<p>建模：</p>\n<blockquote>\n<p>求解采用的是分离变量法</p>\n</blockquote>\n<p>$$<br>i(t + \\Delta t) - i(t) &#x3D; i(t) \\lambda \\Delta t<br>$$</p>\n<p>$$<br>\\frac{di}{dt} &#x3D; \\lambda i<br>$$</p>\n<p>$$<br>i(0) &#x3D; i_0<br>$$</p>\n<p>求解、分析、检验：</p>\n<p>$$<br>\\frac{di}{dt} &#x3D; \\lambda i<br>$$</p>\n<p>$$<br>i(0) &#x3D; i_0<br>$$</p>\n<p>$$<br>i(t) &#x3D; i_0 e^{\\lambda t}<br>$$</p>\n<p>$$<br>t \\rightarrow \\infty \\Rightarrow i(t) \\rightarrow \\infty<br>$$</p>\n<p><img src=\"https://files.catbox.moe/43qanr.png\" alt=\"43qanr.png\"></p>\n<blockquote>\n<p>显然这个模型的结果是不合理的,感染人数不可能超过总人数。<br>若有效接触的是病人，则不能使病人数增加。<br>必须区分已感染者和未感染者以及总人数。</p>\n</blockquote>\n<h4 id=\"代码\"><a href=\"#代码\" class=\"headerlink\" title=\"代码\"></a>代码</h4><figure class=\"highlight matlab\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">%创建一个.m文件并命名为i_model.m</span></span><br><span class=\"line\"><span class=\"comment\">% I Model</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"params\">[t, i]</span> = <span class=\"title\">i_model</span><span class=\"params\">(i0, lambda, tmax)</span></span></span><br><span class=\"line\">    [t, <span class=\"built_in\">i</span>] = ode45(@(t, <span class=\"built_in\">i</span>) lambda * <span class=\"built_in\">i</span>, [<span class=\"number\">0</span> tmax], i0);</span><br><span class=\"line\"><span class=\"keyword\">end</span></span><br></pre></td></tr></table></figure>\n\n<blockquote>\n<p>注意:要创建两个文件,上面的代码创建的是 matlab 的函数文件</p>\n</blockquote>\n<figure class=\"highlight matlab\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">% 设置参数</span></span><br><span class=\"line\">i0 = <span class=\"number\">1</span>;  <span class=\"comment\">% 初始感染人数</span></span><br><span class=\"line\">lambda = <span class=\"number\">0.5</span>;  <span class=\"comment\">% 每天有效接触人数</span></span><br><span class=\"line\">tmax = <span class=\"number\">20</span>;  <span class=\"comment\">% 模拟时间</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">% 求解模型</span></span><br><span class=\"line\">[t, <span class=\"built_in\">i</span>] = i_model(i0, lambda, tmax);</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">% 绘图</span></span><br><span class=\"line\"><span class=\"built_in\">figure</span>;</span><br><span class=\"line\"><span class=\"built_in\">plot</span>(t, <span class=\"built_in\">i</span>);</span><br><span class=\"line\">title(<span class=\"string\">&#x27;I Model&#x27;</span>);</span><br><span class=\"line\">xlabel(<span class=\"string\">&#x27;Time&#x27;</span>);</span><br><span class=\"line\">ylabel(<span class=\"string\">&#x27;Infected Population&#x27;</span>);</span><br></pre></td></tr></table></figure>\n\n<h3 id=\"模型-2：SI-模型\"><a href=\"#模型-2：SI-模型\" class=\"headerlink\" title=\"模型 2：SI 模型\"></a>模型 2：SI 模型</h3><p>区分已感染者和未感染者</p>\n<p>假设：</p>\n<ol>\n<li>总人数 $N$ 不变，病人和健康人的<strong>比例</strong>分别为 $i(t), s(t)$。</li>\n</ol>\n<blockquote>\n<p>注意这里$i(t)$表示的是比例和上一个模型表示人数是不一样的</p>\n</blockquote>\n<ol>\n<li>每个病人每天有效接触人数为 $\\lambda$，且使接触的健康人致病。</li>\n</ol>\n<p>建模：</p>\n<p>$$<br>N[i(t + \\Delta t) - i(t)] &#x3D; N i(t) \\lambda \\Delta t s(t)<br>$$</p>\n<p>$$<br>\\frac{di}{dt} &#x3D; \\lambda s i<br>$$</p>\n<p>$$<br>s(t) + i(t) &#x3D; 1<br>$$</p>\n<p>求解、分析、检验：</p>\n<p>$$<br>\\begin{cases}<br>\\frac{di}{dt} &#x3D; \\lambda i (1 - i) \\<br>i(0) &#x3D; i_0<br>\\end{cases}<br>$$</p>\n<p>$$<br>\\int \\frac{di}{i(1 - i)} &#x3D; \\int \\lambda dt<br>$$</p>\n<p>$$<br>i(t) &#x3D; \\frac{1}{1 + \\left(\\frac{1}{i_0} - 1\\right)e^{-\\lambda t}}<br>$$</p>\n<p><img src=\"https://files.catbox.moe/4ufuyo.png\" alt=\"4ufuyo.png\"></p>\n<p><img src=\"https://files.catbox.moe/jkyrhf.png\" alt=\"jkyrhf.png\"></p>\n<p>$t &#x3D; t_m$ 时, $\\frac{di}{dt}$ 最大</p>\n<p>$t_m \\sim$ 传染病高峰到来的时刻</p>\n<p>$$<br>t_m &#x3D; \\lambda^{-1} \\ln \\left(\\frac{1}{i_0} - 1\\right)<br>$$</p>\n<p>$$<br>\\lambda\\downarrow \\rightarrow t_m \\uparrow<br>$$</p>\n<p>$$<br>t \\rightarrow \\infty \\Rightarrow i \\rightarrow 1<br>$$</p>\n<h4 id=\"代码-1\"><a href=\"#代码-1\" class=\"headerlink\" title=\"代码\"></a>代码</h4><figure class=\"highlight matlab\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">%创建一个.m文件并命名为si_model.m</span></span><br><span class=\"line\"><span class=\"comment\">% SI Model</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"params\">[t, y]</span> = <span class=\"title\">si_model</span><span class=\"params\">(i0, lambda, tmax)</span></span></span><br><span class=\"line\">    [t, y] = ode45(@(t, y) [lambda * y(<span class=\"number\">1</span>) * (<span class=\"number\">1</span> - y(<span class=\"number\">1</span>))], [<span class=\"number\">0</span> tmax], i0);</span><br><span class=\"line\"><span class=\"keyword\">end</span></span><br></pre></td></tr></table></figure>\n\n<blockquote>\n<p>注意:要创建两个文件,上面的代码创建的是 matlab 的函数文件</p>\n</blockquote>\n<figure class=\"highlight matlab\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">% 设置参数</span></span><br><span class=\"line\">i0 = <span class=\"number\">0.1</span>; <span class=\"comment\">% 初始感染比例</span></span><br><span class=\"line\">lambda = <span class=\"number\">0.5</span>; <span class=\"comment\">% 每天有效接触人数</span></span><br><span class=\"line\">tmax = <span class=\"number\">50</span>; <span class=\"comment\">% 模拟时间</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">% 求解模型</span></span><br><span class=\"line\">[t, <span class=\"built_in\">i</span>] = si_model(i0, lambda, tmax);</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">% 找到 infected 和 susceptible 比例为 0.5 的时间点</span></span><br><span class=\"line\">infected_half = interp1(<span class=\"built_in\">i</span>, t, <span class=\"number\">0.5</span>);</span><br><span class=\"line\">susceptible_half = interp1(<span class=\"number\">1</span>-<span class=\"built_in\">i</span>, t, <span class=\"number\">0.5</span>);</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">% 绘图</span></span><br><span class=\"line\"><span class=\"built_in\">figure</span>;</span><br><span class=\"line\"><span class=\"built_in\">plot</span>(t, <span class=\"built_in\">i</span>, <span class=\"string\">&#x27;b&#x27;</span>, <span class=\"string\">&#x27;LineWidth&#x27;</span>, <span class=\"number\">2</span>);</span><br><span class=\"line\"><span class=\"built_in\">hold</span> on;</span><br><span class=\"line\"><span class=\"built_in\">plot</span>(t, <span class=\"number\">1</span>-<span class=\"built_in\">i</span>, <span class=\"string\">&#x27;r&#x27;</span>, <span class=\"string\">&#x27;LineWidth&#x27;</span>, <span class=\"number\">2</span>);</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">% 标记 infected 和 susceptible 比例为 0.5 的点</span></span><br><span class=\"line\"><span class=\"built_in\">plot</span>(infected_half, <span class=\"number\">0.5</span>, <span class=\"string\">&#x27;bo&#x27;</span>, <span class=\"string\">&#x27;MarkerSize&#x27;</span>, <span class=\"number\">10</span>, <span class=\"string\">&#x27;MarkerFaceColor&#x27;</span>, <span class=\"string\">&#x27;b&#x27;</span>);</span><br><span class=\"line\"><span class=\"built_in\">plot</span>(susceptible_half, <span class=\"number\">0.5</span>, <span class=\"string\">&#x27;ro&#x27;</span>, <span class=\"string\">&#x27;MarkerSize&#x27;</span>, <span class=\"number\">10</span>, <span class=\"string\">&#x27;MarkerFaceColor&#x27;</span>, <span class=\"string\">&#x27;r&#x27;</span>);</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">% 添加标记点的文本说明</span></span><br><span class=\"line\">text(infected_half, <span class=\"number\">0.55</span>, [<span class=\"string\">&#x27;t_mi = &#x27;</span>, num2str(infected_half, <span class=\"string\">&#x27;%.2f&#x27;</span>)], <span class=\"string\">&#x27;Color&#x27;</span>, <span class=\"string\">&#x27;b&#x27;</span>, <span class=\"string\">&#x27;HorizontalAlignment&#x27;</span>, <span class=\"string\">&#x27;right&#x27;</span>);</span><br><span class=\"line\">text(susceptible_half, <span class=\"number\">0.55</span>, [<span class=\"string\">&#x27;t_ms = &#x27;</span>, num2str(susceptible_half, <span class=\"string\">&#x27;%.2f&#x27;</span>)], <span class=\"string\">&#x27;Color&#x27;</span>, <span class=\"string\">&#x27;r&#x27;</span>, <span class=\"string\">&#x27;HorizontalAlignment&#x27;</span>, <span class=\"string\">&#x27;left&#x27;</span>);</span><br><span class=\"line\"></span><br><span class=\"line\">title(<span class=\"string\">&#x27;SI Model&#x27;</span>);</span><br><span class=\"line\">xlabel(<span class=\"string\">&#x27;Time&#x27;</span>);</span><br><span class=\"line\">ylabel(<span class=\"string\">&#x27;Population Ratio&#x27;</span>);</span><br><span class=\"line\"><span class=\"built_in\">legend</span>(<span class=\"string\">&#x27;Infected&#x27;</span>, <span class=\"string\">&#x27;Susceptible&#x27;</span>, <span class=\"string\">&#x27;Location&#x27;</span>, <span class=\"string\">&#x27;north&#x27;</span>);</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">% 添加水平线以突出 0.5 比例</span></span><br><span class=\"line\">yline(<span class=\"number\">0.5</span>, <span class=\"string\">&#x27;--k&#x27;</span>, <span class=\"string\">&#x27;LineWidth&#x27;</span>, <span class=\"number\">1</span>);</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">% 计算传染病高峰时刻</span></span><br><span class=\"line\">tm = <span class=\"number\">1</span>/lambda * <span class=\"built_in\">log</span>((<span class=\"number\">1</span>/i0) - <span class=\"number\">1</span>);</span><br><span class=\"line\"><span class=\"built_in\">disp</span>([<span class=\"string\">&#x27;Peak time: &#x27;</span>, num2str(tm)]);</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">% 设置坐标轴范围，确保标记点可见</span></span><br><span class=\"line\">ylim([<span class=\"number\">0</span> <span class=\"number\">1.1</span>]);</span><br></pre></td></tr></table></figure>\n\n<h3 id=\"模型-3：SIS-模型\"><a href=\"#模型-3：SIS-模型\" class=\"headerlink\" title=\"模型 3：SIS 模型\"></a>模型 3：SIS 模型</h3><p>考虑病人自愈且可再次被感染</p>\n<p>传染病无免疫性——病人治愈成为健康人，健康人可再次被感染。</p>\n<p>增加假设：</p>\n<p>病人每天治愈的比例为 $\\mu$</p>\n<p>$\\lambda \\sim$ 日接触率</p>\n<p>$\\mu \\sim$ 日治愈率</p>\n<p>$$<br>\\sigma &#x3D; \\lambda &#x2F; \\mu<br>$$</p>\n<p>建模：</p>\n<p>$$<br>N[i(t + \\Delta t) - i(t)] &#x3D; Ni(t)\\lambda \\Delta t s(t) - Ni(t) \\mu \\Delta t<br>$$</p>\n<p>$$<br>\\begin{cases}<br>\\frac{di}{dt} &#x3D; \\lambda i (1 - i) - \\mu i &#x3D; -\\lambda i \\left[i - \\left(1 - \\frac{1}{\\sigma}\\right)\\right] \\<br>i(0) &#x3D; i_0<br>\\end{cases}<br>$$</p>\n<p>求解分析检验:</p>\n<p>$$<br>\\frac{di}{dt} &#x3D; -\\lambda i \\left[i - \\left(1 - \\frac{1}{\\sigma}\\right)\\right]<br>$$</p>\n<p><img src=\"https://files.catbox.moe/potjqt.png\" alt=\"potjqt.png\"></p>\n<p><img src=\"https://files.catbox.moe/upnnn3.png\" alt=\"upnnn3.png\"></p>\n<h4 id=\"代码-2\"><a href=\"#代码-2\" class=\"headerlink\" title=\"代码\"></a>代码</h4><figure class=\"highlight matlab\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">%创建一个.m文件并命名为sis_model.m</span></span><br><span class=\"line\"><span class=\"comment\">% SIS Model</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"params\">[t, y]</span> = <span class=\"title\">sis_model</span><span class=\"params\">(i0, lambda, mu, tmax)</span></span></span><br><span class=\"line\">    [t, y] = ode45(@(t, y) [lambda * y(<span class=\"number\">1</span>) * (<span class=\"number\">1</span> - y(<span class=\"number\">1</span>)) - mu * y(<span class=\"number\">1</span>)], [<span class=\"number\">0</span> tmax], i0);</span><br><span class=\"line\"><span class=\"keyword\">end</span></span><br></pre></td></tr></table></figure>\n\n<blockquote>\n<p>注意:要创建两个文件,上面的代码创建的是 matlab 的函数文件</p>\n</blockquote>\n<figure class=\"highlight matlab\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br><span class=\"line\">47</span><br><span class=\"line\">48</span><br><span class=\"line\">49</span><br><span class=\"line\">50</span><br><span class=\"line\">51</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">% 设置参数</span></span><br><span class=\"line\">i0 = <span class=\"number\">0.01</span>;  <span class=\"comment\">% 初始感染比例</span></span><br><span class=\"line\">lambda = <span class=\"number\">0.5</span>;  <span class=\"comment\">% 每天有效接触人数</span></span><br><span class=\"line\">mu = <span class=\"number\">0.1</span>;  <span class=\"comment\">% 每天治愈比例</span></span><br><span class=\"line\">tmax = <span class=\"number\">100</span>;  <span class=\"comment\">% 模拟时间</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">% 求解模型</span></span><br><span class=\"line\">[t, <span class=\"built_in\">i</span>] = sis_model(i0, lambda, mu, tmax);</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">% 绘图</span></span><br><span class=\"line\"><span class=\"built_in\">figure</span>;</span><br><span class=\"line\"><span class=\"built_in\">plot</span>(t, <span class=\"built_in\">i</span>);</span><br><span class=\"line\"><span class=\"built_in\">hold</span> on;</span><br><span class=\"line\"><span class=\"built_in\">plot</span>(t, <span class=\"number\">1</span>-<span class=\"built_in\">i</span>);</span><br><span class=\"line\">title(<span class=\"string\">&#x27;SIS Model&#x27;</span>);</span><br><span class=\"line\">xlabel(<span class=\"string\">&#x27;Time&#x27;</span>);</span><br><span class=\"line\">ylabel(<span class=\"string\">&#x27;Population Ratio&#x27;</span>);</span><br><span class=\"line\"><span class=\"built_in\">legend</span>(<span class=\"string\">&#x27;Infected&#x27;</span>, <span class=\"string\">&#x27;Susceptible&#x27;</span>);</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">% 计算平衡点</span></span><br><span class=\"line\">equilibrium = <span class=\"number\">1</span> - mu/lambda;</span><br><span class=\"line\"><span class=\"built_in\">disp</span>([<span class=\"string\">&#x27;Equilibrium point: &#x27;</span>, num2str(equilibrium)]);</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">% 情况1: σ &gt; 1</span></span><br><span class=\"line\">lambda1 = <span class=\"number\">0.5</span>;</span><br><span class=\"line\">mu1 = <span class=\"number\">0.2</span>;</span><br><span class=\"line\">[t1, i1] = sis_model(i0, lambda1, mu1, tmax);</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">% 情况2: σ ≤ 1</span></span><br><span class=\"line\">lambda2 = <span class=\"number\">0.2</span>;</span><br><span class=\"line\">mu2 = <span class=\"number\">0.5</span>;</span><br><span class=\"line\">[t2, i2] = sis_model(i0, lambda2, mu2, tmax);</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">% 绘图</span></span><br><span class=\"line\"><span class=\"built_in\">figure</span>;</span><br><span class=\"line\">subplot(<span class=\"number\">1</span>,<span class=\"number\">2</span>,<span class=\"number\">1</span>);</span><br><span class=\"line\"><span class=\"built_in\">plot</span>(t1, i1);</span><br><span class=\"line\">title(<span class=\"string\">&#x27;SIS Model: σ &gt; 1&#x27;</span>);</span><br><span class=\"line\">xlabel(<span class=\"string\">&#x27;Time&#x27;</span>);</span><br><span class=\"line\">ylabel(<span class=\"string\">&#x27;Infected Ratio&#x27;</span>);</span><br><span class=\"line\">yline(<span class=\"number\">1</span> - mu1/lambda1, <span class=\"string\">&#x27;--r&#x27;</span>, <span class=\"string\">&#x27;Equilibrium&#x27;</span>);</span><br><span class=\"line\"></span><br><span class=\"line\">subplot(<span class=\"number\">1</span>,<span class=\"number\">2</span>,<span class=\"number\">2</span>);</span><br><span class=\"line\"><span class=\"built_in\">plot</span>(t2, i2);</span><br><span class=\"line\">title(<span class=\"string\">&#x27;SIS Model: σ ≤ 1&#x27;</span>);</span><br><span class=\"line\">xlabel(<span class=\"string\">&#x27;Time&#x27;</span>);</span><br><span class=\"line\">ylabel(<span class=\"string\">&#x27;Infected Ratio&#x27;</span>);</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">% 显示R₀值</span></span><br><span class=\"line\"><span class=\"built_in\">disp</span>([<span class=\"string\">&#x27;R₀ (Case 1): &#x27;</span>, num2str(lambda1/mu1)]);</span><br><span class=\"line\"><span class=\"built_in\">disp</span>([<span class=\"string\">&#x27;R₀ (Case 2): &#x27;</span>, num2str(lambda2/mu2)]);</span><br></pre></td></tr></table></figure>\n\n<h3 id=\"模型-4：SIR-模型\"><a href=\"#模型-4：SIR-模型\" class=\"headerlink\" title=\"模型 4：SIR 模型\"></a>模型 4：SIR 模型</h3><p>传染病有免疫性——病人治愈后即移出感染系统，称为<strong>移出者</strong>。</p>\n<p>假设：</p>\n<ol>\n<li>总人数 $N$ 不变，病人、健康人和移出者的比例分别为 $i(t), s(t), r(t)$。</li>\n<li>病人的日接触率 $\\lambda$, 日治愈率 $\\mu$, 接触数 $\\sigma &#x3D; \\lambda &#x2F; \\mu$</li>\n</ol>\n<p>建模：</p>\n<p>$$<br>s(t) + i(t) + r(t) &#x3D; 1<br>$$</p>\n<p>需要建立 $i(t), s(t), r(t)$ 的两个方程。</p>\n<p>$$<br>N[r(t + \\Delta t) - r(t)] &#x3D; Ni(t) \\mu \\Delta t<br>$$</p>\n<p>$$<br>N[i(t + \\Delta t) - i(t)] &#x3D; Ni(t)\\lambda \\Delta t s(t) - Ni(t) \\mu \\Delta t<br>$$</p>\n<p>$$<br>N[s(t + \\Delta t) - s(t)] &#x3D; -\\lambda Ns(t)i(t) \\Delta t<br>$$</p>\n<p>$$<br>i_0 + s_0 \\approx 1 \\quad (通常r(0) &#x3D; r_0 很小)<br>$$</p>\n<p>求解分析检验:</p>\n<p>$$<br>\\begin{cases}<br>\\frac{di}{dt} &#x3D; \\lambda si - \\mu i \\<br>\\frac{ds}{dt} &#x3D; -\\lambda si \\<br>i(0) &#x3D; i_0, \\quad s(0) &#x3D; s_0\\<br>i_0 + s_0 \\approx 1 \\quad (通常r(0) &#x3D; r_0 很小)<br>\\end{cases}<br>$$</p>\n<blockquote>\n<p>由于无法求出 $i(t), s(t)$ 的解析解。<br>我们考虑其他办法:</p>\n<ol>\n<li>数值计算</li>\n<li>定性分析<br>相平面上研究解析性质。</li>\n</ol>\n</blockquote>\n<h4 id=\"SIR-模型的数值解\"><a href=\"#SIR-模型的数值解\" class=\"headerlink\" title=\"SIR 模型的数值解\"></a>SIR 模型的数值解</h4><p>设 $\\lambda &#x3D; 1$, $\\mu &#x3D; 0.3$, $i_0 &#x3D; 0.02$, $s_0 &#x3D; 0.98$, 用 MATLAB 计算作图 $i(t)$,$s(t)$及 $i(s)$</p>\n<p>$$<br>\\frac{di}{ds} &#x3D; \\frac{\\lambda si - \\mu i}{-\\lambda si}<br>$$</p>\n<p><img src=\"https://tk-pichost-1325224430.cos.ap-chengdu.myqcloud.com/blog/17393389691728c9d5531aed64ccb881b7886773b424b.png\" alt=\"17393389691728c9d5531aed64ccb881b7886773b424b.png\"></p>\n<p><img src=\"https://tk-pichost-1325224430.cos.ap-chengdu.myqcloud.com/blog/1739338986650311b4ff45f134c2c84cb248ba699a0a1.png\" alt=\"1739338986650311b4ff45f134c2c84cb248ba699a0a1.png\"></p>\n<h4 id=\"模型的相轨线分析\"><a href=\"#模型的相轨线分析\" class=\"headerlink\" title=\"模型的相轨线分析\"></a>模型的相轨线分析</h4><p>对于前面求解分析检验的方程组</p>\n<p>消去 $dt$, $\\sigma &#x3D; \\lambda &#x2F; \\mu$</p>\n<p>$$<br>\\begin{cases}<br>\\frac{di}{ds} &#x3D; \\frac{1}{\\sigma s} - 1 \\<br>i \\big|_{s &#x3D; s_0} &#x3D; i_0<br>\\end{cases}<br>$$</p>\n<p>相轨线:</p>\n<p>$$<br>i(s) &#x3D; (s_0 + i_0) - s + \\frac{1}{\\sigma} \\ln \\frac{s}{s_0}<br>$$</p>\n<p>相轨线 $i(s)$ 的定义域：</p>\n<p>$$<br>D &#x3D; {(s, i) | s \\geq 0, i \\geq 0, s + i \\leq 1}<br>$$</p>\n<p>$s(t)$ 单调递减 $\\rightarrow$ 相轨线的方向</p>\n<p><img src=\"https://tk-pichost-1325224430.cos.ap-chengdu.myqcloud.com/blog/1739339031385fbb865dcb636407682dda5b02724f9bf.png\" alt=\"1739339031385fbb865dcb636407682dda5b02724f9bf.png\"></p>\n<h4 id=\"预防传染病蔓延的手段\"><a href=\"#预防传染病蔓延的手段\" class=\"headerlink\" title=\"预防传染病蔓延的手段\"></a>预防传染病蔓延的手段</h4><p>传染病不蔓延的条件—— $s_0 &lt; 1&#x2F;\\sigma$</p>\n<ul>\n<li><p>提高阈值 $1&#x2F;\\sigma$</p>\n<ul>\n<li>降低 $\\sigma$</li>\n<li>$\\lambda$ (日接触率) $\\downarrow \\rightarrow$ 卫生水平 $\\uparrow$</li>\n<li>$\\mu$ (日治愈率) $\\uparrow \\rightarrow$ 医疗水平 $\\uparrow$</li>\n</ul>\n</li>\n<li><p>降低 $s_0$</p>\n<ul>\n<li>提高 $r_0$$\\rightarrow$群体免疫</li>\n</ul>\n</li>\n</ul>\n<p>$$<br>s_0 + i_0 + r_0 &#x3D; 1<br>$$</p>\n<h4 id=\"代码-3\"><a href=\"#代码-3\" class=\"headerlink\" title=\"代码\"></a>代码</h4><figure class=\"highlight matlab\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">%创建一个.m文件并命名为i_model.m</span></span><br><span class=\"line\"><span class=\"comment\">% SIR Model</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"params\">[t, y]</span> = <span class=\"title\">sir_model</span><span class=\"params\">(i0, s0, lambda, mu, tmax)</span></span></span><br><span class=\"line\">    [t, y] = ode45(@(t, y) [</span><br><span class=\"line\">        lambda * y(<span class=\"number\">1</span>) * y(<span class=\"number\">2</span>) - mu * y(<span class=\"number\">1</span>)  <span class=\"comment\">% di/dt</span></span><br><span class=\"line\">        -lambda * y(<span class=\"number\">1</span>) * y(<span class=\"number\">2</span>)  <span class=\"comment\">% ds/dt</span></span><br><span class=\"line\">        mu * y(<span class=\"number\">1</span>)  <span class=\"comment\">% dr/dt</span></span><br><span class=\"line\">    ], [<span class=\"number\">0</span> tmax], [i0; s0; <span class=\"number\">1</span>-i0-s0]);</span><br><span class=\"line\"><span class=\"keyword\">end</span></span><br></pre></td></tr></table></figure>\n\n<blockquote>\n<p>注意:要创建两个文件,上面的代码创建的是 matlab 的函数文件</p>\n</blockquote>\n<figure class=\"highlight matlab\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">% 设置参数</span></span><br><span class=\"line\">i0 = <span class=\"number\">0.01</span>;  <span class=\"comment\">% 初始感染比例</span></span><br><span class=\"line\">s0 = <span class=\"number\">0.99</span>;  <span class=\"comment\">% 初始易感比例</span></span><br><span class=\"line\">lambda = <span class=\"number\">0.5</span>;  <span class=\"comment\">% 每天有效接触人数</span></span><br><span class=\"line\">mu = <span class=\"number\">0.1</span>;  <span class=\"comment\">% 每天治愈比例</span></span><br><span class=\"line\">tmax = <span class=\"number\">100</span>;  <span class=\"comment\">% 模拟时间</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">% 求解模型</span></span><br><span class=\"line\">[t, y] = sir_model(i0, s0, lambda, mu, tmax);</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">% 绘图</span></span><br><span class=\"line\"><span class=\"built_in\">figure</span>;</span><br><span class=\"line\"><span class=\"built_in\">plot</span>(t, y);</span><br><span class=\"line\">title(<span class=\"string\">&#x27;SIR Model&#x27;</span>);</span><br><span class=\"line\">xlabel(<span class=\"string\">&#x27;Time&#x27;</span>);</span><br><span class=\"line\">ylabel(<span class=\"string\">&#x27;Population Ratio&#x27;</span>);</span><br><span class=\"line\"><span class=\"built_in\">legend</span>(<span class=\"string\">&#x27;Infected&#x27;</span>, <span class=\"string\">&#x27;Susceptible&#x27;</span>, <span class=\"string\">&#x27;Removed&#x27;</span>);</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">% 相平面图</span></span><br><span class=\"line\"><span class=\"built_in\">figure</span>;</span><br><span class=\"line\"><span class=\"built_in\">plot</span>(y(:,<span class=\"number\">2</span>), y(:,<span class=\"number\">1</span>));</span><br><span class=\"line\">title(<span class=\"string\">&#x27;SIR Model Phase Plane&#x27;</span>);</span><br><span class=\"line\">xlabel(<span class=\"string\">&#x27;Susceptible&#x27;</span>);</span><br><span class=\"line\">ylabel(<span class=\"string\">&#x27;Infected&#x27;</span>);</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">% 计算R0</span></span><br><span class=\"line\">R0 = lambda / mu;</span><br><span class=\"line\"><span class=\"built_in\">disp</span>([<span class=\"string\">&#x27;R0: &#x27;</span>, num2str(R0)]);</span><br></pre></td></tr></table></figure>\n\n<h1 id=\"三、香烟过滤嘴的作用模型\"><a href=\"#三、香烟过滤嘴的作用模型\" class=\"headerlink\" title=\"三、香烟过滤嘴的作用模型\"></a>三、香烟过滤嘴的作用模型</h1><h2 id=\"问题\"><a href=\"#问题\" class=\"headerlink\" title=\"问题\"></a>问题</h2><ul>\n<li>过滤嘴的作用与它的材料和长度有什么关系？</li>\n<li>人体吸入的毒物量与哪些因素有关，其中什么因素影响大，什么因素影响小？</li>\n</ul>\n<h2 id=\"模型分析\"><a href=\"#模型分析\" class=\"headerlink\" title=\"模型分析\"></a>模型分析</h2><ul>\n<li>分析吸烟时毒物进入人体的过程，建立吸烟过程的数学模型。</li>\n</ul>\n<h2 id=\"模型假设\"><a href=\"#模型假设\" class=\"headerlink\" title=\"模型假设\"></a>模型假设</h2><ol>\n<li>$l_1 \\sim$ 烟草长, $l_2 \\sim$ 过滤嘴长, $l &#x3D; l_1 + l_2$, 毒物总量 $M$ 均匀分布，密度 $w_0 &#x3D; M&#x2F;l$。</li>\n<li>点燃处毒物进入空气和沿香烟穿行的数量比是 $a : a’$, $a’ + a &#x3D; 1$。</li>\n<li>未点燃的烟草和过滤嘴对穿行的毒物的单位时间吸收速率分别是 $b$ 和 $\\beta$。</li>\n<li>烟雾沿香烟穿行速度是常数 $v$, 香烟燃烧速度是常数 $u$, $v \\gg u$。</li>\n</ol>\n<p><img src=\"https://tk-pichost-1325224430.cos.ap-chengdu.myqcloud.com/blog/1739339098264762c0aa149f14ae599a418c4309aa91a.png\" alt=\"1739339098264762c0aa149f14ae599a418c4309aa91a.png\"></p>\n<h2 id=\"模型建立\"><a href=\"#模型建立\" class=\"headerlink\" title=\"模型建立\"></a>模型建立</h2><p>$t &#x3D; 0, x &#x3D; 0$, 点燃香烟</p>\n<p>$q(x,t) \\sim$ 毒物在 $x$ 处的流速（单位时间的流量）</p>\n<p>$w(x,t) \\sim$ 毒物密度</p>\n<p>$$<br>w(x,0) &#x3D; w_0<br>$$</p>\n<p>$$<br>Q &#x3D; \\int_0^T q(l, t) dt, \\quad T &#x3D; l_1 &#x2F; u<br>$$</p>\n<ol>\n<li>求 $q(x,t)$</li>\n</ol>\n<p>流量守恒：</p>\n<p>$$<br>\\begin{cases}<br>q(x,t) - q(x+\\Delta x,t) &#x3D; \\frac{q(x,t)b\\Delta x}{v}, &amp; ut \\leq x \\leq l_1 \\<br>q(x,t) - q(x+\\Delta x,t) &#x3D; \\frac{q(x,t)\\beta\\Delta x}{v}, &amp; l_1 \\leq x \\leq l<br>\\end{cases}<br>$$</p>\n<p>$$<br>\\frac{dq(x,t)}{dx} &#x3D;<br>\\begin{cases}<br>-\\frac{b}{v}q(x,t), &amp; ut \\leq x \\leq l_1 \\<br>-\\frac{\\beta}{v}q(x,t), &amp; l_1 \\leq x \\leq l<br>\\end{cases}<br>$$</p>\n<p>定解条件：$q(ut,t) &#x3D; auw(ut,t)$</p>\n<ol>\n<li>求 $w(ut,t)$ 考察 $\\Delta t$ 内毒物密度的增量</li>\n</ol>\n<p>$$<br>w(x, t + \\Delta t) - w(x, t) &#x3D; \\frac{q(x,t)\\Delta t b\\Delta t}{v\\Delta t}<br>$$</p>\n<p>其中：$q(x,t) &#x3D; auw(ut,t)e^{-\\frac{b(x-ut)}{v}}$</p>\n<p>$$<br>\\begin{cases}\\frac{\\partial w(ut,t)}{\\partial t} &#x3D; \\frac{b}{v}auw(ut,t)e^{-\\frac{b(x-ut)}{v}}\\<br>w(x,0)&#x3D;w_0<br>\\end{cases}<br>$$</p>\n<p>$$<br>w(ut,t) &#x3D; \\frac{w_0}{a’}\\left(1 - ae^{-\\frac{a’but}{v}}\\right), \\quad a’ &#x3D; 1-a<br>$$</p>\n<ol>\n<li>计算 $Q$~吸一支烟毒物进入人体总量</li>\n</ol>\n<p>$$<br>w(ut,t) &#x3D; \\frac{w_0}{a’}\\left(1 - ae^{-\\frac{a’but}{v}}\\right)<br>$$</p>\n<p>$$<br>q(l,t) &#x3D; auw(ut,t)e^{-\\frac{b l_1-wt}{v}}e^{-\\frac{\\beta l_2}{v}}\\<br>$$</p>\n<p>$$<br>Q &#x3D; \\int_0^{l_1&#x2F;u} q(l,t) dt &#x3D; \\frac{auw_0}{a’b} e^{-\\frac{\\beta l_2}{v}}\\left(1 - e^{-\\frac{a’bl_1}{v}}\\right)<br>$$</p>\n<p>$$<br>Q &#x3D; aMe^{-\\frac{\\beta l_2}{v}} \\varphi(r), \\quad r &#x3D; \\frac{a’bl_1}{v}, \\quad \\varphi(r) &#x3D; \\frac{1 - e^{-r}}{r}<br>$$</p>\n<h2 id=\"结果分析\"><a href=\"#结果分析\" class=\"headerlink\" title=\"结果分析\"></a>结果分析</h2><ol>\n<li>$Q$ 与 $a, M$ 成正比。($aM$ 是毒物集中在 $x &#x3D; l_1$ 处的吸入量)</li>\n<li>$e^{-\\frac{\\beta l_2}{v}} \\sim$ 过滤嘴因素, $\\beta, l_2 \\sim$ 负指数作用</li>\n<li>$\\varphi(r) \\sim$ 烟草的吸收作用 （烟草为什么有作用？）</li>\n</ol>\n<p>$$<br>r &#x3D; \\frac{a’bl_1}{v} \\ll 1<br>$$</p>\n<p>$$<br>\\varphi(r) &#x3D; 1 - \\frac{r}{2}<br>$$</p>\n<p>$$<br>Q &#x3D; aMe^{-\\frac{\\beta l_2}{v}}\\left(1 - \\frac{a’bl_1}{2v}\\right), \\quad b,l_1 \\sim \\text{线性作用}<br>$$</p>\n<ol>\n<li>与另一支不带过滤嘴的香烟比较，$w_0, b, a, v, l$ 均相同，吸至 $x &#x3D; l_1$ 抛掉。</li>\n</ol>\n<p><strong>带过滤嘴</strong>:</p>\n<p>$$<br>Q_1 &#x3D; \\frac{a w_0 v}{a’ b} e^{-\\frac{\\beta l_2}{v}} \\left(1 - e^{-\\frac{a’ b l_1}{v}}\\right)<br>$$</p>\n<p><strong>不带过滤嘴</strong>:</p>\n<p>$$<br>Q_2 &#x3D; \\frac{a w_0 v}{a’ b} \\left(1 - e^{-\\frac{a’ b l_1}{v}}\\right)<br>$$</p>\n<p>$$<br>\\frac{Q_1}{Q_2} &#x3D; e^{-\\frac{(\\beta - b) l_2}{v}}<br>$$</p>\n<p>$$<br>\\beta &gt; b \\Rightarrow Q_1 &lt; Q_2<br>$$</p>\n<p>提高 $\\beta b$ 与加长 $l_2$，效果相同。</p>\n<h2 id=\"总结\"><a href=\"#总结\" class=\"headerlink\" title=\"总结\"></a>总结</h2><ul>\n<li>引入两个基本函数：流量 $q(x,t)$ 和密度 $w(x,t)$，运用物理学的守恒定律通过微元方法建立微分方程，构造动态模型。</li>\n<li>对求解结果进行定性和定量分析，得到合理的实际结论。</li>\n</ul>\n<p><img src=\"https://tk-pichost-1325224430.cos.ap-chengdu.myqcloud.com/blog/17393391272532c0a5ec759324803b6b1d6f399985c6d.png\" alt=\"17393391272532c0a5ec759324803b6b1d6f399985c6d.png\"></p>\n<h2 id=\"代码-4\"><a href=\"#代码-4\" class=\"headerlink\" title=\"代码\"></a>代码</h2><figure class=\"highlight python\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">import</span> numpy <span class=\"keyword\">as</span> np</span><br><span class=\"line\"><span class=\"keyword\">import</span> matplotlib.pyplot <span class=\"keyword\">as</span> plt</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">#参数设置</span></span><br><span class=\"line\">M = <span class=\"number\">1.0</span>  <span class=\"comment\">#毒物总量 (任意单位)</span></span><br><span class=\"line\">a = <span class=\"number\">0.5</span>  <span class=\"comment\">#毒物进入空气和穿行的比例 (a = 0.5, a&#x27; = 0.5)</span></span><br><span class=\"line\">b = <span class=\"number\">0.1</span>  <span class=\"comment\">#烟草的吸收系数</span></span><br><span class=\"line\">beta = <span class=\"number\">0.8</span>  <span class=\"comment\">#过滤嘴的吸收系数, 增大以突出非线性效果</span></span><br><span class=\"line\">v = <span class=\"number\">1.0</span>  <span class=\"comment\">#烟雾穿行速度</span></span><br><span class=\"line\">l1 = <span class=\"number\">1.0</span>  <span class=\"comment\">#烟草长度</span></span><br><span class=\"line\">l2_values = np.linspace(<span class=\"number\">0</span>, <span class=\"number\">10</span>, <span class=\"number\">100</span>)  <span class=\"comment\">#过滤嘴长度的变化范围, 增大以观察非线性效果</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">#计算 Q1 和 Q2</span></span><br><span class=\"line\"><span class=\"keyword\">def</span> <span class=\"title function_\">calculate_Q</span>(<span class=\"params\">l1, l2, a, M, b, beta, v</span>):</span><br><span class=\"line\">    a_prime = <span class=\"number\">1</span> - a</span><br><span class=\"line\">    r = a_prime * b * l1 / v</span><br><span class=\"line\">    Q1 = (a * M * v / (a_prime * b)) * np.exp(-beta * l2 / v) * (<span class=\"number\">1</span> - np.exp(-r))</span><br><span class=\"line\">    Q2 = (a * M * v / (a_prime * b)) * (<span class=\"number\">1</span> - np.exp(-r))</span><br><span class=\"line\">    <span class=\"keyword\">return</span> Q1, Q2</span><br><span class=\"line\"></span><br><span class=\"line\">Q1_values = []</span><br><span class=\"line\">Q2_values = []</span><br><span class=\"line\"><span class=\"keyword\">for</span> l2 <span class=\"keyword\">in</span> l2_values:</span><br><span class=\"line\">    Q1, Q2 = calculate_Q(l1, l2, a, M, b, beta, v)</span><br><span class=\"line\">    Q1_values.append(Q1)</span><br><span class=\"line\">    Q2_values.append(Q2)</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">#比较有过滤嘴和无过滤嘴的毒物量</span></span><br><span class=\"line\">Q1_values = np.array(Q1_values)</span><br><span class=\"line\">Q2_values = np.array(Q2_values)</span><br><span class=\"line\">Q_ratio = Q1_values / Q2_values</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">#绘图</span></span><br><span class=\"line\">plt.figure(figsize=(<span class=\"number\">10</span>, <span class=\"number\">6</span>))</span><br><span class=\"line\">plt.plot(l2_values, Q1_values, label=<span class=\"string\">&#x27;Q1 (With Filter)&#x27;</span>)</span><br><span class=\"line\">plt.plot(l2_values, Q2_values, label=<span class=\"string\">&#x27;Q2 (Without Filter)&#x27;</span>)</span><br><span class=\"line\">plt.plot(l2_values, Q_ratio, label=<span class=\"string\">&#x27;Q1/Q2 Ratio&#x27;</span>, linestyle=<span class=\"string\">&#x27;--&#x27;</span>)</span><br><span class=\"line\">plt.xlabel(<span class=\"string\">&#x27;Filter Length l2&#x27;</span>)</span><br><span class=\"line\">plt.ylabel(<span class=\"string\">&#x27;Toxin Amount Q&#x27;</span>)</span><br><span class=\"line\">plt.title(<span class=\"string\">&#x27;Effect of Filter Length and Material on Toxin Inhalation&#x27;</span>)</span><br><span class=\"line\">plt.legend()</span><br><span class=\"line\">plt.grid(<span class=\"literal\">True</span>)</span><br><span class=\"line\">plt.show()</span><br></pre></td></tr></table></figure>\n\n<h1 id=\"四、烟雾的扩散与消失模型\"><a href=\"#四、烟雾的扩散与消失模型\" class=\"headerlink\" title=\"四、烟雾的扩散与消失模型\"></a>四、烟雾的扩散与消失模型</h1><h2 id=\"现象和问题\"><a href=\"#现象和问题\" class=\"headerlink\" title=\"现象和问题\"></a>现象和问题</h2><ul>\n<li>炮弹在空中爆炸，烟雾向四周扩散，形成圆形不透光区域。</li>\n<li>不透光区域不断扩大，然后区域边界逐渐明亮，区域缩小，最后烟雾消失。</li>\n<li>建立模型描述烟雾扩散和消失过程，分析消失时间与各因素的关系。</li>\n</ul>\n<h2 id=\"问题分析\"><a href=\"#问题分析\" class=\"headerlink\" title=\"问题分析\"></a>问题分析</h2><ul>\n<li>无穷空间由瞬时点源导致的扩散过程，用二阶偏微分方程描述烟雾浓度的变化。</li>\n<li>观察到的烟雾消失与烟雾对光线的吸收，以及仪器对明暗的灵敏度有关。</li>\n</ul>\n<h2 id=\"模型假设-1\"><a href=\"#模型假设-1\" class=\"headerlink\" title=\"模型假设\"></a>模型假设</h2><ol>\n<li>扩散服从扩散定律。</li>\n<li>光线穿过烟雾时光强的相对减少与与烟雾浓度成正比；无烟雾的大小不影响光强。</li>\n<li>穿过烟雾进入仪器的光线只有明暗之分，明暗界限由仪器灵敏度决定。</li>\n</ol>\n<h2 id=\"模型建立-1\"><a href=\"#模型建立-1\" class=\"headerlink\" title=\"模型建立\"></a>模型建立</h2><p><strong>扩散定律</strong>：单位时间通过单位法向面积的流量 $q$ 与浓度 $C$ 的梯度成正比。</p>\n<p>$$<br>q &#x3D; -k \\cdot \\nabla C<br>$$</p>\n<p>烟雾浓度 $C(x,y,z,t)$ 的变化规律</p>\n<p>$[t,t+\\Delta t]$ 通过$\\Omega$流出量$Q_1 &#x3D; \\int_{t}^{t+\\Delta t} \\iint_S q \\cdot n d \\sigma dt$</p>\n<p>$\\Omega$ 内烟雾改变量 $Q_2 &#x3D; \\iiint_{v} [C(x,y,z,t+\\Delta t) - C(x,y,z,t)] dV$</p>\n<p>高斯公式:</p>\n<p>$$<br>\\iint_S q \\cdot n d\\sigma &#x3D; \\iiint_V \\text{div } q dV &#x3D; -k \\iiint_V \\text{div } (\\nabla C) dV<br>$$</p>\n<p>$$<br>Q_2 &#x3D; -Q_1<br>$$</p>\n<p>$$<br>\\frac{\\partial C}{\\partial t} &#x3D; k [\\text{div}(\\nabla C)] &#x3D; k \\left(\\frac{\\partial^2 C}{\\partial x^2} + \\frac{\\partial^2 C}{\\partial y^2} + \\frac{\\partial^2 C}{\\partial z^2}\\right),-\\infty&lt;x,y,z&lt;\\infty,t&gt;0<br>$$</p>\n<h2 id=\"初始条件\"><a href=\"#初始条件\" class=\"headerlink\" title=\"初始条件\"></a>初始条件</h2><p>$$<br>C(x, y, z, 0) &#x3D; Q \\delta(x, y, z)<br>$$</p>\n<ul>\n<li>$Q \\sim$ 炮弹释放的烟雾总量</li>\n<li>$\\delta \\sim$ 单位强度的点源函数</li>\n</ul>\n<p>求解方程:</p>\n<p>$$<br>C(x, y, z, t) &#x3D; \\frac{Q}{(4 \\pi kt)^{3&#x2F;2}} e^{-\\frac{x^2 + y^2 + z^2}{4 kt}}<br>$$</p>\n<h2 id=\"光强穿过烟雾时的变化规律\"><a href=\"#光强穿过烟雾时的变化规律\" class=\"headerlink\" title=\"光强穿过烟雾时的变化规律\"></a>光强穿过烟雾时的变化规律</h2><ul>\n<li>$I(l) \\sim$ 沿 $l$ 方向的光强</li>\n<li>$C(l) \\sim$ 沿 $l$ 方向的烟雾浓度</li>\n</ul>\n<p>假设光强的相对减少与烟雾浓度成正比。</p>\n<p>$$<br>\\frac{dI(l)}{dl} &#x3D; -\\alpha C(l) I(l)<br>$$</p>\n<p>记未进入烟雾($l \\leq l_0$)时光强为 $I(l_0) &#x3D; I_0$:</p>\n<p>$$<br>I(l) &#x3D; I_0 e^{-\\alpha \\int_{l_0}^{l} C(s) ds}<br>$$</p>\n<h2 id=\"仪器灵敏度与烟雾明暗界限\"><a href=\"#仪器灵敏度与烟雾明暗界限\" class=\"headerlink\" title=\"仪器灵敏度与烟雾明暗界限\"></a>仪器灵敏度与烟雾明暗界限</h2><ul>\n<li>烟雾浓度连续变化</li>\n<li>烟雾中光强连续变化。</li>\n<li>穿过烟雾进入仪器的光线只有明暗之分，明暗界限由仪器灵敏度决定。</li>\n</ul>\n<p>$\\mu \\sim$ 仪器灵敏度，当 $I&#x2F;I_0 &lt; 1 - \\mu$，观测结果为暗。</p>\n<p>设光源在 $z &#x3D; -\\infty$，仪器在 $z &#x3D; \\infty$，则观测到的明暗界限为:</p>\n<p>$e^{-\\alpha \\int_{-\\infty}^{\\infty} C(x,y,z,t) dz} &#x3D; 1 - \\mu$$\\sim$ 不透光区域边界</p>\n<h3 id=\"求解方程\"><a href=\"#求解方程\" class=\"headerlink\" title=\"求解方程\"></a>求解方程</h3><p>$$<br>C(x, y, z, t) &#x3D; \\frac{Q}{(4 \\pi kt)^{3&#x2F;2}} e^{-\\frac{x^2 + y^2 + z^2}{4 kt}}<br>$$</p>\n<p>$$<br>\\Rightarrow \\int_{-\\infty}^{\\infty} C(x,y,z,t) dz &#x3D; \\frac{1}{\\alpha} \\ln \\frac{1}{1-\\mu} \\approx \\frac{\\mu}{\\alpha} \\quad (\\mu \\text{ 很小})<br>$$</p>\n<p>而$\\quad \\int_{-\\infty}^{\\infty} C(x,y,z,t) dz &#x3D; \\frac{Q}{4 \\pi kt} e^{-\\frac{x^2 + y^2}{4kt}}$</p>\n<p>$$<br>\\frac{Q}{4 \\pi kt} e^{-\\frac{x^2 + y^2}{4 kt}} &#x3D; \\frac{\\mu}{\\alpha}<br>$$</p>\n<p>不透光区域边界半径:</p>\n<p>$$<br>r(t) &#x3D; \\sqrt{4 kt \\ln \\frac{\\alpha Q}{4 \\pi k \\mu t}}<br>$$</p>\n<h3 id=\"结果分析-1\"><a href=\"#结果分析-1\" class=\"headerlink\" title=\"结果分析\"></a>结果分析</h3><p>$$<br>r(t) &#x3D; \\sqrt{4 kt \\ln \\frac{\\alpha Q}{4 \\pi k \\mu t}}<br>$$</p>\n<p>$$<br>t &#x3D; t_1 &#x3D; \\frac{\\alpha Q}{4 \\pi k \\mu e}, \\quad r &#x3D; r_m &#x3D; \\sqrt{\\frac{Q}{\\pi \\mu e}} \\quad (\\text{最大值})<br>$$</p>\n<p>$$<br>t &#x3D; t_2 &#x3D; \\frac{\\alpha Q}{4 \\pi k \\mu}, \\quad r &#x3D; 0<br>$$</p>\n<p>$$<br>\\alpha \\uparrow, Q \\uparrow, \\mu \\downarrow \\Rightarrow t_1 \\uparrow, r_m \\uparrow<br>$$</p>\n<p>$$<br>k \\downarrow \\Rightarrow t_1 \\uparrow<br>$$</p>\n<p><img src=\"https://tk-pichost-1325224430.cos.ap-chengdu.myqcloud.com/blog/173933914986904ee6ddfd517468d93120f3cfe746ffd.png\" alt=\"173933914986904ee6ddfd517468d93120f3cfe746ffd.png\"></p>\n<table>\n<thead>\n<tr>\n<th>参数</th>\n<th>数值</th>\n</tr>\n</thead>\n<tbody><tr>\n<td>最大不透光区域边界半径$r_{max}$</td>\n<td>3.4220</td>\n</tr>\n<tr>\n<td>边界达到最大值的时间$t_1$</td>\n<td>2.9275</td>\n</tr>\n<tr>\n<td>烟雾完全消失的时间$t_2$</td>\n<td>7.9577</td>\n</tr>\n</tbody></table>\n<p>观测到不透光区域边界达到最大的时刻 $t_1$, 可以预报烟雾消失的时刻 $t_2$</p>\n<blockquote>\n<ol>\n<li><strong>蓝色曲线</strong>$r(t) &#x3D; \\sqrt{4kt \\ln \\left(\\frac{\\alpha Q}{4\\pi k \\mu t}\\right)}$:<ul>\n<li>该曲线表示不透光区域的边界半径 $r(t)$随时间 $ t$ 的变化。</li>\n<li>在爆炸初始时刻，烟雾边界迅速扩散，边界半径增大。</li>\n<li>随着时间的推移，边界半径达到一个最大值，然后开始减小，直到最后烟雾完全消失。</li>\n</ul>\n</li>\n<li><strong>红色虚线</strong>(垂直线)$t_1 &#x3D; \\frac{\\alpha Q}{4 \\pi k \\mu e}$:<ul>\n<li>这条红色虚线表示边界半径达到最大值的时间$t_1$。</li>\n<li>从图中可以看到，边界半径在此时刻 $t_1$达到了峰值。</li>\n</ul>\n</li>\n<li><strong>绿色虚线</strong>(水平线)$r_m &#x3D; \\sqrt{\\frac{Q}{\\pi \\mu e}}$:<ul>\n<li>这条绿色虚线表示不透光区域边界的最大半径 $ r_m$。</li>\n<li>该半径在 $t_1$ 时刻达到，这是烟雾扩散过程中的最大范围。</li>\n</ul>\n</li>\n<li><strong>蓝色虚线</strong>(垂直线)$t_2 &#x3D; \\frac{\\alpha Q}{4 \\pi k \\mu}$:<ul>\n<li>这条蓝色虚线表示烟雾完全消失的时间 $t_2 $。</li>\n<li>此时，边界半径 $r(t)$已经缩小至零，意味着烟雾已经完全消散。</li>\n</ul>\n</li>\n</ol>\n</blockquote>\n<h2 id=\"代码-5\"><a href=\"#代码-5\" class=\"headerlink\" title=\"代码\"></a>代码</h2><figure class=\"highlight python\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">import</span> numpy <span class=\"keyword\">as</span> np</span><br><span class=\"line\"><span class=\"keyword\">import</span> matplotlib.pyplot <span class=\"keyword\">as</span> plt</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\"># 定义常数(这些常数可以根据特定情况进行设置)</span></span><br><span class=\"line\">k = <span class=\"number\">1.0</span>  <span class=\"comment\"># 扩散系数</span></span><br><span class=\"line\">alpha = <span class=\"number\">1.0</span>  <span class=\"comment\"># 参数alpha</span></span><br><span class=\"line\">Q = <span class=\"number\">1.0</span>  <span class=\"comment\"># 炮弹释放的烟雾总量</span></span><br><span class=\"line\">mu = <span class=\"number\">0.01</span>  <span class=\"comment\"># 仪器灵敏度</span></span><br><span class=\"line\">pi = np.pi</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\"># 定义不透光区域边界半径 r(t)</span></span><br><span class=\"line\"><span class=\"keyword\">def</span> <span class=\"title function_\">r</span>(<span class=\"params\">t</span>):</span><br><span class=\"line\">    <span class=\"keyword\">return</span> np.sqrt(<span class=\"number\">4</span> * k * t * np.log(alpha * Q / (<span class=\"number\">4</span> * pi * k * mu * t)))</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\"># 计算最大边界半径和相关时间点</span></span><br><span class=\"line\">t1 = alpha * Q / (<span class=\"number\">4</span> * pi * k * mu * np.e)</span><br><span class=\"line\">r_max = np.sqrt(Q / (pi * mu * np.e))</span><br><span class=\"line\">t2 = alpha * Q / (<span class=\"number\">4</span> * pi * k * mu)</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\"># 时间范围</span></span><br><span class=\"line\">t = np.linspace(<span class=\"number\">0.1</span>, t2 * <span class=\"number\">1.5</span>, <span class=\"number\">500</span>)  <span class=\"comment\"># 从小于 t2 的时间开始</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\"># 绘制不透光区域边界随时间的变化</span></span><br><span class=\"line\">plt.figure(figsize=(<span class=\"number\">10</span>, <span class=\"number\">6</span>))</span><br><span class=\"line\">plt.plot(t, r(t), label=<span class=\"string\">r&#x27;$r(t) = \\sqrt&#123;4 kt **\\l**n **\\f**rac&#123;**\\a**lpha Q&#125;&#123;4 **\\p**i k **\\m**u t&#125;&#125;$&#x27;</span>)</span><br><span class=\"line\">plt.axvline(t1, color=<span class=\"string\">&#x27;r&#x27;</span>, linestyle=<span class=\"string\">&#x27;--&#x27;</span>, label=<span class=\"string\">r&#x27;$t_1 = **\\f**rac&#123;**\\a**lpha Q&#125;&#123;4 **\\p**i k **\\m**u e&#125;$&#x27;</span>)</span><br><span class=\"line\">plt.axhline(r_max, color=<span class=\"string\">&#x27;g&#x27;</span>, linestyle=<span class=\"string\">&#x27;--&#x27;</span>, label=<span class=\"string\">r&#x27;$r_m = \\sqrt&#123;**\\f**rac&#123;Q&#125;&#123;**\\p**i **\\m**u e&#125;&#125;$&#x27;</span>)</span><br><span class=\"line\">plt.axvline(t2, color=<span class=\"string\">&#x27;b&#x27;</span>, linestyle=<span class=\"string\">&#x27;--&#x27;</span>, label=<span class=\"string\">r&#x27;$t_2 = **\\f**rac&#123;**\\a**lpha Q&#125;&#123;4 **\\p**i k **\\m**u&#125;$&#x27;</span>)</span><br><span class=\"line\">plt.xlabel(<span class=\"string\">&#x27;Time t&#x27;</span>)</span><br><span class=\"line\">plt.ylabel(<span class=\"string\">&#x27;Boundary Radius r(t)&#x27;</span>)</span><br><span class=\"line\">plt.title(<span class=\"string\">&#x27;Smoke Diffusion and Dissipation Model&#x27;</span>)</span><br><span class=\"line\">plt.legend()</span><br><span class=\"line\">plt.grid(<span class=\"literal\">True</span>)</span><br><span class=\"line\">plt.show()</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\"># 输出最大边界半径和相关时间点</span></span><br><span class=\"line\"><span class=\"built_in\">print</span>(<span class=\"string\">f&quot;最大不透光区域边界半径 r_max = <span class=\"subst\">&#123;r_max:<span class=\"number\">.4</span>f&#125;</span>&quot;</span>)</span><br><span class=\"line\"><span class=\"built_in\">print</span>(<span class=\"string\">f&quot;边界达到最大值的时间 t1 = <span class=\"subst\">&#123;t1:<span class=\"number\">.4</span>f&#125;</span>&quot;</span>)</span><br><span class=\"line\"><span class=\"built_in\">print</span>(<span class=\"string\">f&quot;烟雾完全消失的时间 t2 = <span class=\"subst\">&#123;t2:<span class=\"number\">.4</span>f&#125;</span>&quot;</span>)</span><br></pre></td></tr></table></figure>\n","excerpt":"","more":"<h1 id=\"微分方程与差分方程\"><a href=\"#微分方程与差分方程\" class=\"headerlink\" title=\"微分方程与差分方程\"></a>微分方程与差分方程</h1><h1 id=\"一、概述\"><a href=\"#一、概述\" class=\"headerlink\" title=\"一、概述\"></a>一、概述</h1><p><img src=\"https://tk-pichost-1325224430.cos.ap-chengdu.myqcloud.com/blog/17393373960371739337395061.png\" alt=\"17393373960371739337395061.png\"></p>\n<table>\n<thead>\n<tr>\n<th>年份</th>\n<th>题目</th>\n<th>相关方法或理论</th>\n</tr>\n</thead>\n<tbody><tr>\n<td>1996 年</td>\n<td>A: 最优捕鱼策略问题</td>\n<td>微分方程的问题</td>\n</tr>\n<tr>\n<td></td>\n<td>B: 节水洗衣机的程序设计问题</td>\n<td>偏微分方程，也可以用优化</td>\n</tr>\n<tr>\n<td>2003 年</td>\n<td>A: SARS 的传播问题</td>\n<td>预测类问题，可用差分方程、微分方程</td>\n</tr>\n<tr>\n<td></td>\n<td>D: 抢渡长江问题</td>\n<td>微分方程、优化问题</td>\n</tr>\n<tr>\n<td>2004 年</td>\n<td>C: 酒后开车问题</td>\n<td>微分方程</td>\n</tr>\n<tr>\n<td>2008 年</td>\n<td>A: 数码相机定位（机理分析）</td>\n<td>模糊数学、微分方程</td>\n</tr>\n<tr>\n<td></td>\n<td>B: 高等教育学费标准探讨问题</td>\n<td>模糊数学、微分方程</td>\n</tr>\n<tr>\n<td>2009 年</td>\n<td>A: 制动器试验台的控制方法问题</td>\n<td>微分方程、优化（求解物理应用题）</td>\n</tr>\n<tr>\n<td>2014 年</td>\n<td>A: 缆坡三号软着陆轨道设计与控制策略</td>\n<td>常微分方程目标规划、优化模型</td>\n</tr>\n<tr>\n<td></td>\n<td>B: 创意平板折叠桌</td>\n<td>力学方程、物理模型、多目标规划</td>\n</tr>\n<tr>\n<td>2015 年</td>\n<td>太阳影子定位（机理分析）</td>\n<td>偏微分方程</td>\n</tr>\n<tr>\n<td>2018 年</td>\n<td>A: 高温作业专用服装设计</td>\n<td>偏微分方程、单目标规划、双目标规划</td>\n</tr>\n<tr>\n<td>2019 年</td>\n<td>A: 高压油管的压力控制</td>\n<td>数据预处理、常微分方程、单目标规划</td>\n</tr>\n<tr>\n<td></td>\n<td>B: “同心协力”策略研究</td>\n<td>二维碰撞、二维碰撞（常微分方程）、多目标规划</td>\n</tr>\n<tr>\n<td>2020 年</td>\n<td>A: 沪温曲线</td>\n<td>热传导、有限差分法、遍历法</td>\n</tr>\n<tr>\n<td>2022 年</td>\n<td>A: 波浪能最大输出功率设计</td>\n<td>微分方程、模拟仿真、最优解</td>\n</tr>\n<tr>\n<td>2023 年</td>\n<td>A: 优化设计启目镜场以及发电问题</td>\n<td>微分方程、优化问题</td>\n</tr>\n</tbody></table>\n<h2 id=\"微分方程模型介绍\"><a href=\"#微分方程模型介绍\" class=\"headerlink\" title=\"微分方程模型介绍\"></a>微分方程模型介绍</h2><h3 id=\"模型介绍\"><a href=\"#模型介绍\" class=\"headerlink\" title=\"模型介绍\"></a>模型介绍</h3><p>微分方程建模是数学建模的重要方法，因为许多实际问题的数学描述将导致求解微分方程的定解问题。解决相应问题可以按以下几步：</p>\n<ol>\n<li>根据实际要求确定要研究的量（自变量、未知函数、必要的参数等）并确定坐标系。</li>\n<li>找出这些量所满足的基本规律（物理的、几何的、化学的或生物学的等）。</li>\n<li>运用这些规律列出方程和定解条件。</li>\n<li>求解、分析结果。</li>\n</ol>\n<h3 id=\"列方程常见的方法\"><a href=\"#列方程常见的方法\" class=\"headerlink\" title=\"列方程常见的方法\"></a>列方程常见的方法</h3><ol>\n<li><p><strong>微元分析法与任意区域上取积分的方法</strong></p>\n<p>通过微元分析法，利用已知的规律建立一些变量（自变量与未知函数）的微元之间的关系式，然后再通过取极限的方法得到微分方程，或等价地通过任意区域上取积分的方法来建立微分方程。</p>\n</li>\n<li><p><strong>按规律直接列方程</strong></p>\n<p>在数学、力学、物理、化学等学科中许多自然现象所满足的规律已为人们所熟悉，并直接由微分方程所描述。我们常利用这些规律对某些实际问题列出微分方程。</p>\n</li>\n<li><p><strong>模拟近似法</strong></p>\n<p>在生物、经济等学科中，许多现象所满足的规律并不很清楚且相当复杂，因此需要根据实际资料或大量的实验数据，提出各种假设。在一定的假设下，给出实际现象所满足的规律，然后利用适当的数学方法列出微分方程。</p>\n</li>\n</ol>\n<h3 id=\"例题\"><a href=\"#例题\" class=\"headerlink\" title=\"例题\"></a>例题</h3><p>一个较热的物体置于室温为 18°C 的房间内，该物体最初的温度是 60°C，3 分钟以后降到 50°C。想知道它的温度降到 30°C 需要多少时间？10 分钟以后它的温度是多少？</p>\n<p><strong>牛顿冷却（加热）定律</strong>：将温度为 $T$ 的物体放入处于常温 $m$ 的介质中时，$T$ 的变化速率正比于 $T$ 与周围介质的温度差。</p>\n<p>牛顿冷却定律描述了物体温度随时间变化的过程。根据牛顿冷却定律，温度 $T(t)$ 随时间 $t$ 的变化满足以下微分方程：</p>\n<p>$$<br>\\frac{dT}{dt} &#x3D; -k(T - m)<br>$$</p>\n<p>其中：</p>\n<ul>\n<li>$T(t)$ 是物体在时间 $t$ 时的温度。</li>\n<li>$m$ 是环境温度。</li>\n<li>$k$ 是冷却常数，取决于物体和环境的性质。</li>\n</ul>\n<p>我们可以通过积分这个方程得到 $ T(t) $ 的表达式：</p>\n<p>$$<br>T(t) &#x3D; m + (T_0 - m) e^{-kt}<br>$$</p>\n<p>其中：</p>\n<ul>\n<li>$T_0$ 是物体的初始温度。</li>\n</ul>\n<p>我们根据给定条件来求解这个问题。具体步骤如下：</p>\n<ol>\n<li>根据初始条件求解冷却常数 $k$。</li>\n<li>使用 $k$ 求解物体温度降到 30°C 所需的时间。</li>\n<li>计算 10 分钟后物体的温度。</li>\n</ol>\n<p><img src=\"https://files.catbox.moe/uk2rco.png\" alt=\"uk2rco.png\"></p>\n<figure class=\"highlight python\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">import</span> numpy <span class=\"keyword\">as</span> np</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\"># 已知条件</span></span><br><span class=\"line\">T0 = <span class=\"number\">60</span>  <span class=\"comment\"># 初始温度</span></span><br><span class=\"line\">T1 = <span class=\"number\">50</span>  <span class=\"comment\"># 3分钟后的温度</span></span><br><span class=\"line\">T_room = <span class=\"number\">18</span>  <span class=\"comment\"># 环境温度</span></span><br><span class=\"line\">time1 = <span class=\"number\">3</span>  <span class=\"comment\"># 时间为3分钟</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\"># 求解冷却常数k</span></span><br><span class=\"line\">k = -np.log((T1 - T_room) / (T0 - T_room)) / time1</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\"># 求解降到30度所需的时间</span></span><br><span class=\"line\">T_target = <span class=\"number\">30</span></span><br><span class=\"line\">time_to_target = -np.log((T_target - T_room) / (T0 - T_room)) / k</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\"># 计算10分钟后的温度</span></span><br><span class=\"line\">time2 = <span class=\"number\">10</span></span><br><span class=\"line\">T_after_10_minutes = T_room + (T0 - T_room) * np.exp(-k * time2)</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\"># 输出结果</span></span><br><span class=\"line\"><span class=\"built_in\">print</span>(<span class=\"string\">f&quot;物体温度降到30°C所需的时间为: <span class=\"subst\">&#123;time_to_target:<span class=\"number\">.2</span>f&#125;</span> 分钟&quot;</span>)</span><br><span class=\"line\"><span class=\"built_in\">print</span>(<span class=\"string\">f&quot;10分钟后物体的温度为: <span class=\"subst\">&#123;T_after_10_minutes:<span class=\"number\">.2</span>f&#125;</span> °C&quot;</span>)</span><br></pre></td></tr></table></figure>\n\n<h1 id=\"二、传染病模型\"><a href=\"#二、传染病模型\" class=\"headerlink\" title=\"二、传染病模型\"></a>二、传染病模型</h1><h2 id=\"背景与问题\"><a href=\"#背景与问题\" class=\"headerlink\" title=\"背景与问题\"></a>背景与问题</h2><ul>\n<li>描述传染病的传播过程。</li>\n<li>分析受感染人数的变化规律。</li>\n<li>预报传染病高潮到来的时刻。</li>\n<li>预防传染病蔓延的手段。</li>\n</ul>\n<blockquote>\n<p>基本方法:按照传播过程的一般规律建立数学模型</p>\n</blockquote>\n<p><img src=\"https://files.catbox.moe/vopq8o.png\" alt=\"vopq8o.png\"></p>\n<h3 id=\"模型-1：I-模型\"><a href=\"#模型-1：I-模型\" class=\"headerlink\" title=\"模型 1：I 模型\"></a>模型 1：I 模型</h3><p>已感染人数（病人）记为$i(t)$</p>\n<p>假设：每个病人每天有效接触（足以使人致病）人数为 $\\lambda$。</p>\n<p>建模：</p>\n<blockquote>\n<p>求解采用的是分离变量法</p>\n</blockquote>\n<p>$$<br>i(t + \\Delta t) - i(t) &#x3D; i(t) \\lambda \\Delta t<br>$$</p>\n<p>$$<br>\\frac{di}{dt} &#x3D; \\lambda i<br>$$</p>\n<p>$$<br>i(0) &#x3D; i_0<br>$$</p>\n<p>求解、分析、检验：</p>\n<p>$$<br>\\frac{di}{dt} &#x3D; \\lambda i<br>$$</p>\n<p>$$<br>i(0) &#x3D; i_0<br>$$</p>\n<p>$$<br>i(t) &#x3D; i_0 e^{\\lambda t}<br>$$</p>\n<p>$$<br>t \\rightarrow \\infty \\Rightarrow i(t) \\rightarrow \\infty<br>$$</p>\n<p><img src=\"https://files.catbox.moe/43qanr.png\" alt=\"43qanr.png\"></p>\n<blockquote>\n<p>显然这个模型的结果是不合理的,感染人数不可能超过总人数。<br>若有效接触的是病人，则不能使病人数增加。<br>必须区分已感染者和未感染者以及总人数。</p>\n</blockquote>\n<h4 id=\"代码\"><a href=\"#代码\" class=\"headerlink\" title=\"代码\"></a>代码</h4><figure class=\"highlight matlab\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">%创建一个.m文件并命名为i_model.m</span></span><br><span class=\"line\"><span class=\"comment\">% I Model</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"params\">[t, i]</span> = <span class=\"title\">i_model</span><span class=\"params\">(i0, lambda, tmax)</span></span></span><br><span class=\"line\">    [t, <span class=\"built_in\">i</span>] = ode45(@(t, <span class=\"built_in\">i</span>) lambda * <span class=\"built_in\">i</span>, [<span class=\"number\">0</span> tmax], i0);</span><br><span class=\"line\"><span class=\"keyword\">end</span></span><br></pre></td></tr></table></figure>\n\n<blockquote>\n<p>注意:要创建两个文件,上面的代码创建的是 matlab 的函数文件</p>\n</blockquote>\n<figure class=\"highlight matlab\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">% 设置参数</span></span><br><span class=\"line\">i0 = <span class=\"number\">1</span>;  <span class=\"comment\">% 初始感染人数</span></span><br><span class=\"line\">lambda = <span class=\"number\">0.5</span>;  <span class=\"comment\">% 每天有效接触人数</span></span><br><span class=\"line\">tmax = <span class=\"number\">20</span>;  <span class=\"comment\">% 模拟时间</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">% 求解模型</span></span><br><span class=\"line\">[t, <span class=\"built_in\">i</span>] = i_model(i0, lambda, tmax);</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">% 绘图</span></span><br><span class=\"line\"><span class=\"built_in\">figure</span>;</span><br><span class=\"line\"><span class=\"built_in\">plot</span>(t, <span class=\"built_in\">i</span>);</span><br><span class=\"line\">title(<span class=\"string\">&#x27;I Model&#x27;</span>);</span><br><span class=\"line\">xlabel(<span class=\"string\">&#x27;Time&#x27;</span>);</span><br><span class=\"line\">ylabel(<span class=\"string\">&#x27;Infected Population&#x27;</span>);</span><br></pre></td></tr></table></figure>\n\n<h3 id=\"模型-2：SI-模型\"><a href=\"#模型-2：SI-模型\" class=\"headerlink\" title=\"模型 2：SI 模型\"></a>模型 2：SI 模型</h3><p>区分已感染者和未感染者</p>\n<p>假设：</p>\n<ol>\n<li>总人数 $N$ 不变，病人和健康人的<strong>比例</strong>分别为 $i(t), s(t)$。</li>\n</ol>\n<blockquote>\n<p>注意这里$i(t)$表示的是比例和上一个模型表示人数是不一样的</p>\n</blockquote>\n<ol>\n<li>每个病人每天有效接触人数为 $\\lambda$，且使接触的健康人致病。</li>\n</ol>\n<p>建模：</p>\n<p>$$<br>N[i(t + \\Delta t) - i(t)] &#x3D; N i(t) \\lambda \\Delta t s(t)<br>$$</p>\n<p>$$<br>\\frac{di}{dt} &#x3D; \\lambda s i<br>$$</p>\n<p>$$<br>s(t) + i(t) &#x3D; 1<br>$$</p>\n<p>求解、分析、检验：</p>\n<p>$$<br>\\begin{cases}<br>\\frac{di}{dt} &#x3D; \\lambda i (1 - i) \\<br>i(0) &#x3D; i_0<br>\\end{cases}<br>$$</p>\n<p>$$<br>\\int \\frac{di}{i(1 - i)} &#x3D; \\int \\lambda dt<br>$$</p>\n<p>$$<br>i(t) &#x3D; \\frac{1}{1 + \\left(\\frac{1}{i_0} - 1\\right)e^{-\\lambda t}}<br>$$</p>\n<p><img src=\"https://files.catbox.moe/4ufuyo.png\" alt=\"4ufuyo.png\"></p>\n<p><img src=\"https://files.catbox.moe/jkyrhf.png\" alt=\"jkyrhf.png\"></p>\n<p>$t &#x3D; t_m$ 时, $\\frac{di}{dt}$ 最大</p>\n<p>$t_m \\sim$ 传染病高峰到来的时刻</p>\n<p>$$<br>t_m &#x3D; \\lambda^{-1} \\ln \\left(\\frac{1}{i_0} - 1\\right)<br>$$</p>\n<p>$$<br>\\lambda\\downarrow \\rightarrow t_m \\uparrow<br>$$</p>\n<p>$$<br>t \\rightarrow \\infty \\Rightarrow i \\rightarrow 1<br>$$</p>\n<h4 id=\"代码-1\"><a href=\"#代码-1\" class=\"headerlink\" title=\"代码\"></a>代码</h4><figure class=\"highlight matlab\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">%创建一个.m文件并命名为si_model.m</span></span><br><span class=\"line\"><span class=\"comment\">% SI Model</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"params\">[t, y]</span> = <span class=\"title\">si_model</span><span class=\"params\">(i0, lambda, tmax)</span></span></span><br><span class=\"line\">    [t, y] = ode45(@(t, y) [lambda * y(<span class=\"number\">1</span>) * (<span class=\"number\">1</span> - y(<span class=\"number\">1</span>))], [<span class=\"number\">0</span> tmax], i0);</span><br><span class=\"line\"><span class=\"keyword\">end</span></span><br></pre></td></tr></table></figure>\n\n<blockquote>\n<p>注意:要创建两个文件,上面的代码创建的是 matlab 的函数文件</p>\n</blockquote>\n<figure class=\"highlight matlab\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">% 设置参数</span></span><br><span class=\"line\">i0 = <span class=\"number\">0.1</span>; <span class=\"comment\">% 初始感染比例</span></span><br><span class=\"line\">lambda = <span class=\"number\">0.5</span>; <span class=\"comment\">% 每天有效接触人数</span></span><br><span class=\"line\">tmax = <span class=\"number\">50</span>; <span class=\"comment\">% 模拟时间</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">% 求解模型</span></span><br><span class=\"line\">[t, <span class=\"built_in\">i</span>] = si_model(i0, lambda, tmax);</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">% 找到 infected 和 susceptible 比例为 0.5 的时间点</span></span><br><span class=\"line\">infected_half = interp1(<span class=\"built_in\">i</span>, t, <span class=\"number\">0.5</span>);</span><br><span class=\"line\">susceptible_half = interp1(<span class=\"number\">1</span>-<span class=\"built_in\">i</span>, t, <span class=\"number\">0.5</span>);</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">% 绘图</span></span><br><span class=\"line\"><span class=\"built_in\">figure</span>;</span><br><span class=\"line\"><span class=\"built_in\">plot</span>(t, <span class=\"built_in\">i</span>, <span class=\"string\">&#x27;b&#x27;</span>, <span class=\"string\">&#x27;LineWidth&#x27;</span>, <span class=\"number\">2</span>);</span><br><span class=\"line\"><span class=\"built_in\">hold</span> on;</span><br><span class=\"line\"><span class=\"built_in\">plot</span>(t, <span class=\"number\">1</span>-<span class=\"built_in\">i</span>, <span class=\"string\">&#x27;r&#x27;</span>, <span class=\"string\">&#x27;LineWidth&#x27;</span>, <span class=\"number\">2</span>);</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">% 标记 infected 和 susceptible 比例为 0.5 的点</span></span><br><span class=\"line\"><span class=\"built_in\">plot</span>(infected_half, <span class=\"number\">0.5</span>, <span class=\"string\">&#x27;bo&#x27;</span>, <span class=\"string\">&#x27;MarkerSize&#x27;</span>, <span class=\"number\">10</span>, <span class=\"string\">&#x27;MarkerFaceColor&#x27;</span>, <span class=\"string\">&#x27;b&#x27;</span>);</span><br><span class=\"line\"><span class=\"built_in\">plot</span>(susceptible_half, <span class=\"number\">0.5</span>, <span class=\"string\">&#x27;ro&#x27;</span>, <span class=\"string\">&#x27;MarkerSize&#x27;</span>, <span class=\"number\">10</span>, <span class=\"string\">&#x27;MarkerFaceColor&#x27;</span>, <span class=\"string\">&#x27;r&#x27;</span>);</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">% 添加标记点的文本说明</span></span><br><span class=\"line\">text(infected_half, <span class=\"number\">0.55</span>, [<span class=\"string\">&#x27;t_mi = &#x27;</span>, num2str(infected_half, <span class=\"string\">&#x27;%.2f&#x27;</span>)], <span class=\"string\">&#x27;Color&#x27;</span>, <span class=\"string\">&#x27;b&#x27;</span>, <span class=\"string\">&#x27;HorizontalAlignment&#x27;</span>, <span class=\"string\">&#x27;right&#x27;</span>);</span><br><span class=\"line\">text(susceptible_half, <span class=\"number\">0.55</span>, [<span class=\"string\">&#x27;t_ms = &#x27;</span>, num2str(susceptible_half, <span class=\"string\">&#x27;%.2f&#x27;</span>)], <span class=\"string\">&#x27;Color&#x27;</span>, <span class=\"string\">&#x27;r&#x27;</span>, <span class=\"string\">&#x27;HorizontalAlignment&#x27;</span>, <span class=\"string\">&#x27;left&#x27;</span>);</span><br><span class=\"line\"></span><br><span class=\"line\">title(<span class=\"string\">&#x27;SI Model&#x27;</span>);</span><br><span class=\"line\">xlabel(<span class=\"string\">&#x27;Time&#x27;</span>);</span><br><span class=\"line\">ylabel(<span class=\"string\">&#x27;Population Ratio&#x27;</span>);</span><br><span class=\"line\"><span class=\"built_in\">legend</span>(<span class=\"string\">&#x27;Infected&#x27;</span>, <span class=\"string\">&#x27;Susceptible&#x27;</span>, <span class=\"string\">&#x27;Location&#x27;</span>, <span class=\"string\">&#x27;north&#x27;</span>);</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">% 添加水平线以突出 0.5 比例</span></span><br><span class=\"line\">yline(<span class=\"number\">0.5</span>, <span class=\"string\">&#x27;--k&#x27;</span>, <span class=\"string\">&#x27;LineWidth&#x27;</span>, <span class=\"number\">1</span>);</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">% 计算传染病高峰时刻</span></span><br><span class=\"line\">tm = <span class=\"number\">1</span>/lambda * <span class=\"built_in\">log</span>((<span class=\"number\">1</span>/i0) - <span class=\"number\">1</span>);</span><br><span class=\"line\"><span class=\"built_in\">disp</span>([<span class=\"string\">&#x27;Peak time: &#x27;</span>, num2str(tm)]);</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">% 设置坐标轴范围，确保标记点可见</span></span><br><span class=\"line\">ylim([<span class=\"number\">0</span> <span class=\"number\">1.1</span>]);</span><br></pre></td></tr></table></figure>\n\n<h3 id=\"模型-3：SIS-模型\"><a href=\"#模型-3：SIS-模型\" class=\"headerlink\" title=\"模型 3：SIS 模型\"></a>模型 3：SIS 模型</h3><p>考虑病人自愈且可再次被感染</p>\n<p>传染病无免疫性——病人治愈成为健康人，健康人可再次被感染。</p>\n<p>增加假设：</p>\n<p>病人每天治愈的比例为 $\\mu$</p>\n<p>$\\lambda \\sim$ 日接触率</p>\n<p>$\\mu \\sim$ 日治愈率</p>\n<p>$$<br>\\sigma &#x3D; \\lambda &#x2F; \\mu<br>$$</p>\n<p>建模：</p>\n<p>$$<br>N[i(t + \\Delta t) - i(t)] &#x3D; Ni(t)\\lambda \\Delta t s(t) - Ni(t) \\mu \\Delta t<br>$$</p>\n<p>$$<br>\\begin{cases}<br>\\frac{di}{dt} &#x3D; \\lambda i (1 - i) - \\mu i &#x3D; -\\lambda i \\left[i - \\left(1 - \\frac{1}{\\sigma}\\right)\\right] \\<br>i(0) &#x3D; i_0<br>\\end{cases}<br>$$</p>\n<p>求解分析检验:</p>\n<p>$$<br>\\frac{di}{dt} &#x3D; -\\lambda i \\left[i - \\left(1 - \\frac{1}{\\sigma}\\right)\\right]<br>$$</p>\n<p><img src=\"https://files.catbox.moe/potjqt.png\" alt=\"potjqt.png\"></p>\n<p><img src=\"https://files.catbox.moe/upnnn3.png\" alt=\"upnnn3.png\"></p>\n<h4 id=\"代码-2\"><a href=\"#代码-2\" class=\"headerlink\" title=\"代码\"></a>代码</h4><figure class=\"highlight matlab\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">%创建一个.m文件并命名为sis_model.m</span></span><br><span class=\"line\"><span class=\"comment\">% SIS Model</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"params\">[t, y]</span> = <span class=\"title\">sis_model</span><span class=\"params\">(i0, lambda, mu, tmax)</span></span></span><br><span class=\"line\">    [t, y] = ode45(@(t, y) [lambda * y(<span class=\"number\">1</span>) * (<span class=\"number\">1</span> - y(<span class=\"number\">1</span>)) - mu * y(<span class=\"number\">1</span>)], [<span class=\"number\">0</span> tmax], i0);</span><br><span class=\"line\"><span class=\"keyword\">end</span></span><br></pre></td></tr></table></figure>\n\n<blockquote>\n<p>注意:要创建两个文件,上面的代码创建的是 matlab 的函数文件</p>\n</blockquote>\n<figure class=\"highlight matlab\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br><span class=\"line\">47</span><br><span class=\"line\">48</span><br><span class=\"line\">49</span><br><span class=\"line\">50</span><br><span class=\"line\">51</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">% 设置参数</span></span><br><span class=\"line\">i0 = <span class=\"number\">0.01</span>;  <span class=\"comment\">% 初始感染比例</span></span><br><span class=\"line\">lambda = <span class=\"number\">0.5</span>;  <span class=\"comment\">% 每天有效接触人数</span></span><br><span class=\"line\">mu = <span class=\"number\">0.1</span>;  <span class=\"comment\">% 每天治愈比例</span></span><br><span class=\"line\">tmax = <span class=\"number\">100</span>;  <span class=\"comment\">% 模拟时间</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">% 求解模型</span></span><br><span class=\"line\">[t, <span class=\"built_in\">i</span>] = sis_model(i0, lambda, mu, tmax);</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">% 绘图</span></span><br><span class=\"line\"><span class=\"built_in\">figure</span>;</span><br><span class=\"line\"><span class=\"built_in\">plot</span>(t, <span class=\"built_in\">i</span>);</span><br><span class=\"line\"><span class=\"built_in\">hold</span> on;</span><br><span class=\"line\"><span class=\"built_in\">plot</span>(t, <span class=\"number\">1</span>-<span class=\"built_in\">i</span>);</span><br><span class=\"line\">title(<span class=\"string\">&#x27;SIS Model&#x27;</span>);</span><br><span class=\"line\">xlabel(<span class=\"string\">&#x27;Time&#x27;</span>);</span><br><span class=\"line\">ylabel(<span class=\"string\">&#x27;Population Ratio&#x27;</span>);</span><br><span class=\"line\"><span class=\"built_in\">legend</span>(<span class=\"string\">&#x27;Infected&#x27;</span>, <span class=\"string\">&#x27;Susceptible&#x27;</span>);</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">% 计算平衡点</span></span><br><span class=\"line\">equilibrium = <span class=\"number\">1</span> - mu/lambda;</span><br><span class=\"line\"><span class=\"built_in\">disp</span>([<span class=\"string\">&#x27;Equilibrium point: &#x27;</span>, num2str(equilibrium)]);</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">% 情况1: σ &gt; 1</span></span><br><span class=\"line\">lambda1 = <span class=\"number\">0.5</span>;</span><br><span class=\"line\">mu1 = <span class=\"number\">0.2</span>;</span><br><span class=\"line\">[t1, i1] = sis_model(i0, lambda1, mu1, tmax);</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">% 情况2: σ ≤ 1</span></span><br><span class=\"line\">lambda2 = <span class=\"number\">0.2</span>;</span><br><span class=\"line\">mu2 = <span class=\"number\">0.5</span>;</span><br><span class=\"line\">[t2, i2] = sis_model(i0, lambda2, mu2, tmax);</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">% 绘图</span></span><br><span class=\"line\"><span class=\"built_in\">figure</span>;</span><br><span class=\"line\">subplot(<span class=\"number\">1</span>,<span class=\"number\">2</span>,<span class=\"number\">1</span>);</span><br><span class=\"line\"><span class=\"built_in\">plot</span>(t1, i1);</span><br><span class=\"line\">title(<span class=\"string\">&#x27;SIS Model: σ &gt; 1&#x27;</span>);</span><br><span class=\"line\">xlabel(<span class=\"string\">&#x27;Time&#x27;</span>);</span><br><span class=\"line\">ylabel(<span class=\"string\">&#x27;Infected Ratio&#x27;</span>);</span><br><span class=\"line\">yline(<span class=\"number\">1</span> - mu1/lambda1, <span class=\"string\">&#x27;--r&#x27;</span>, <span class=\"string\">&#x27;Equilibrium&#x27;</span>);</span><br><span class=\"line\"></span><br><span class=\"line\">subplot(<span class=\"number\">1</span>,<span class=\"number\">2</span>,<span class=\"number\">2</span>);</span><br><span class=\"line\"><span class=\"built_in\">plot</span>(t2, i2);</span><br><span class=\"line\">title(<span class=\"string\">&#x27;SIS Model: σ ≤ 1&#x27;</span>);</span><br><span class=\"line\">xlabel(<span class=\"string\">&#x27;Time&#x27;</span>);</span><br><span class=\"line\">ylabel(<span class=\"string\">&#x27;Infected Ratio&#x27;</span>);</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">% 显示R₀值</span></span><br><span class=\"line\"><span class=\"built_in\">disp</span>([<span class=\"string\">&#x27;R₀ (Case 1): &#x27;</span>, num2str(lambda1/mu1)]);</span><br><span class=\"line\"><span class=\"built_in\">disp</span>([<span class=\"string\">&#x27;R₀ (Case 2): &#x27;</span>, num2str(lambda2/mu2)]);</span><br></pre></td></tr></table></figure>\n\n<h3 id=\"模型-4：SIR-模型\"><a href=\"#模型-4：SIR-模型\" class=\"headerlink\" title=\"模型 4：SIR 模型\"></a>模型 4：SIR 模型</h3><p>传染病有免疫性——病人治愈后即移出感染系统，称为<strong>移出者</strong>。</p>\n<p>假设：</p>\n<ol>\n<li>总人数 $N$ 不变，病人、健康人和移出者的比例分别为 $i(t), s(t), r(t)$。</li>\n<li>病人的日接触率 $\\lambda$, 日治愈率 $\\mu$, 接触数 $\\sigma &#x3D; \\lambda &#x2F; \\mu$</li>\n</ol>\n<p>建模：</p>\n<p>$$<br>s(t) + i(t) + r(t) &#x3D; 1<br>$$</p>\n<p>需要建立 $i(t), s(t), r(t)$ 的两个方程。</p>\n<p>$$<br>N[r(t + \\Delta t) - r(t)] &#x3D; Ni(t) \\mu \\Delta t<br>$$</p>\n<p>$$<br>N[i(t + \\Delta t) - i(t)] &#x3D; Ni(t)\\lambda \\Delta t s(t) - Ni(t) \\mu \\Delta t<br>$$</p>\n<p>$$<br>N[s(t + \\Delta t) - s(t)] &#x3D; -\\lambda Ns(t)i(t) \\Delta t<br>$$</p>\n<p>$$<br>i_0 + s_0 \\approx 1 \\quad (通常r(0) &#x3D; r_0 很小)<br>$$</p>\n<p>求解分析检验:</p>\n<p>$$<br>\\begin{cases}<br>\\frac{di}{dt} &#x3D; \\lambda si - \\mu i \\<br>\\frac{ds}{dt} &#x3D; -\\lambda si \\<br>i(0) &#x3D; i_0, \\quad s(0) &#x3D; s_0\\<br>i_0 + s_0 \\approx 1 \\quad (通常r(0) &#x3D; r_0 很小)<br>\\end{cases}<br>$$</p>\n<blockquote>\n<p>由于无法求出 $i(t), s(t)$ 的解析解。<br>我们考虑其他办法:</p>\n<ol>\n<li>数值计算</li>\n<li>定性分析<br>相平面上研究解析性质。</li>\n</ol>\n</blockquote>\n<h4 id=\"SIR-模型的数值解\"><a href=\"#SIR-模型的数值解\" class=\"headerlink\" title=\"SIR 模型的数值解\"></a>SIR 模型的数值解</h4><p>设 $\\lambda &#x3D; 1$, $\\mu &#x3D; 0.3$, $i_0 &#x3D; 0.02$, $s_0 &#x3D; 0.98$, 用 MATLAB 计算作图 $i(t)$,$s(t)$及 $i(s)$</p>\n<p>$$<br>\\frac{di}{ds} &#x3D; \\frac{\\lambda si - \\mu i}{-\\lambda si}<br>$$</p>\n<p><img src=\"https://tk-pichost-1325224430.cos.ap-chengdu.myqcloud.com/blog/17393389691728c9d5531aed64ccb881b7886773b424b.png\" alt=\"17393389691728c9d5531aed64ccb881b7886773b424b.png\"></p>\n<p><img src=\"https://tk-pichost-1325224430.cos.ap-chengdu.myqcloud.com/blog/1739338986650311b4ff45f134c2c84cb248ba699a0a1.png\" alt=\"1739338986650311b4ff45f134c2c84cb248ba699a0a1.png\"></p>\n<h4 id=\"模型的相轨线分析\"><a href=\"#模型的相轨线分析\" class=\"headerlink\" title=\"模型的相轨线分析\"></a>模型的相轨线分析</h4><p>对于前面求解分析检验的方程组</p>\n<p>消去 $dt$, $\\sigma &#x3D; \\lambda &#x2F; \\mu$</p>\n<p>$$<br>\\begin{cases}<br>\\frac{di}{ds} &#x3D; \\frac{1}{\\sigma s} - 1 \\<br>i \\big|_{s &#x3D; s_0} &#x3D; i_0<br>\\end{cases}<br>$$</p>\n<p>相轨线:</p>\n<p>$$<br>i(s) &#x3D; (s_0 + i_0) - s + \\frac{1}{\\sigma} \\ln \\frac{s}{s_0}<br>$$</p>\n<p>相轨线 $i(s)$ 的定义域：</p>\n<p>$$<br>D &#x3D; {(s, i) | s \\geq 0, i \\geq 0, s + i \\leq 1}<br>$$</p>\n<p>$s(t)$ 单调递减 $\\rightarrow$ 相轨线的方向</p>\n<p><img src=\"https://tk-pichost-1325224430.cos.ap-chengdu.myqcloud.com/blog/1739339031385fbb865dcb636407682dda5b02724f9bf.png\" alt=\"1739339031385fbb865dcb636407682dda5b02724f9bf.png\"></p>\n<h4 id=\"预防传染病蔓延的手段\"><a href=\"#预防传染病蔓延的手段\" class=\"headerlink\" title=\"预防传染病蔓延的手段\"></a>预防传染病蔓延的手段</h4><p>传染病不蔓延的条件—— $s_0 &lt; 1&#x2F;\\sigma$</p>\n<ul>\n<li><p>提高阈值 $1&#x2F;\\sigma$</p>\n<ul>\n<li>降低 $\\sigma$</li>\n<li>$\\lambda$ (日接触率) $\\downarrow \\rightarrow$ 卫生水平 $\\uparrow$</li>\n<li>$\\mu$ (日治愈率) $\\uparrow \\rightarrow$ 医疗水平 $\\uparrow$</li>\n</ul>\n</li>\n<li><p>降低 $s_0$</p>\n<ul>\n<li>提高 $r_0$$\\rightarrow$群体免疫</li>\n</ul>\n</li>\n</ul>\n<p>$$<br>s_0 + i_0 + r_0 &#x3D; 1<br>$$</p>\n<h4 id=\"代码-3\"><a href=\"#代码-3\" class=\"headerlink\" title=\"代码\"></a>代码</h4><figure class=\"highlight matlab\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">%创建一个.m文件并命名为i_model.m</span></span><br><span class=\"line\"><span class=\"comment\">% SIR Model</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"params\">[t, y]</span> = <span class=\"title\">sir_model</span><span class=\"params\">(i0, s0, lambda, mu, tmax)</span></span></span><br><span class=\"line\">    [t, y] = ode45(@(t, y) [</span><br><span class=\"line\">        lambda * y(<span class=\"number\">1</span>) * y(<span class=\"number\">2</span>) - mu * y(<span class=\"number\">1</span>)  <span class=\"comment\">% di/dt</span></span><br><span class=\"line\">        -lambda * y(<span class=\"number\">1</span>) * y(<span class=\"number\">2</span>)  <span class=\"comment\">% ds/dt</span></span><br><span class=\"line\">        mu * y(<span class=\"number\">1</span>)  <span class=\"comment\">% dr/dt</span></span><br><span class=\"line\">    ], [<span class=\"number\">0</span> tmax], [i0; s0; <span class=\"number\">1</span>-i0-s0]);</span><br><span class=\"line\"><span class=\"keyword\">end</span></span><br></pre></td></tr></table></figure>\n\n<blockquote>\n<p>注意:要创建两个文件,上面的代码创建的是 matlab 的函数文件</p>\n</blockquote>\n<figure class=\"highlight matlab\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">% 设置参数</span></span><br><span class=\"line\">i0 = <span class=\"number\">0.01</span>;  <span class=\"comment\">% 初始感染比例</span></span><br><span class=\"line\">s0 = <span class=\"number\">0.99</span>;  <span class=\"comment\">% 初始易感比例</span></span><br><span class=\"line\">lambda = <span class=\"number\">0.5</span>;  <span class=\"comment\">% 每天有效接触人数</span></span><br><span class=\"line\">mu = <span class=\"number\">0.1</span>;  <span class=\"comment\">% 每天治愈比例</span></span><br><span class=\"line\">tmax = <span class=\"number\">100</span>;  <span class=\"comment\">% 模拟时间</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">% 求解模型</span></span><br><span class=\"line\">[t, y] = sir_model(i0, s0, lambda, mu, tmax);</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">% 绘图</span></span><br><span class=\"line\"><span class=\"built_in\">figure</span>;</span><br><span class=\"line\"><span class=\"built_in\">plot</span>(t, y);</span><br><span class=\"line\">title(<span class=\"string\">&#x27;SIR Model&#x27;</span>);</span><br><span class=\"line\">xlabel(<span class=\"string\">&#x27;Time&#x27;</span>);</span><br><span class=\"line\">ylabel(<span class=\"string\">&#x27;Population Ratio&#x27;</span>);</span><br><span class=\"line\"><span class=\"built_in\">legend</span>(<span class=\"string\">&#x27;Infected&#x27;</span>, <span class=\"string\">&#x27;Susceptible&#x27;</span>, <span class=\"string\">&#x27;Removed&#x27;</span>);</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">% 相平面图</span></span><br><span class=\"line\"><span class=\"built_in\">figure</span>;</span><br><span class=\"line\"><span class=\"built_in\">plot</span>(y(:,<span class=\"number\">2</span>), y(:,<span class=\"number\">1</span>));</span><br><span class=\"line\">title(<span class=\"string\">&#x27;SIR Model Phase Plane&#x27;</span>);</span><br><span class=\"line\">xlabel(<span class=\"string\">&#x27;Susceptible&#x27;</span>);</span><br><span class=\"line\">ylabel(<span class=\"string\">&#x27;Infected&#x27;</span>);</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">% 计算R0</span></span><br><span class=\"line\">R0 = lambda / mu;</span><br><span class=\"line\"><span class=\"built_in\">disp</span>([<span class=\"string\">&#x27;R0: &#x27;</span>, num2str(R0)]);</span><br></pre></td></tr></table></figure>\n\n<h1 id=\"三、香烟过滤嘴的作用模型\"><a href=\"#三、香烟过滤嘴的作用模型\" class=\"headerlink\" title=\"三、香烟过滤嘴的作用模型\"></a>三、香烟过滤嘴的作用模型</h1><h2 id=\"问题\"><a href=\"#问题\" class=\"headerlink\" title=\"问题\"></a>问题</h2><ul>\n<li>过滤嘴的作用与它的材料和长度有什么关系？</li>\n<li>人体吸入的毒物量与哪些因素有关，其中什么因素影响大，什么因素影响小？</li>\n</ul>\n<h2 id=\"模型分析\"><a href=\"#模型分析\" class=\"headerlink\" title=\"模型分析\"></a>模型分析</h2><ul>\n<li>分析吸烟时毒物进入人体的过程，建立吸烟过程的数学模型。</li>\n</ul>\n<h2 id=\"模型假设\"><a href=\"#模型假设\" class=\"headerlink\" title=\"模型假设\"></a>模型假设</h2><ol>\n<li>$l_1 \\sim$ 烟草长, $l_2 \\sim$ 过滤嘴长, $l &#x3D; l_1 + l_2$, 毒物总量 $M$ 均匀分布，密度 $w_0 &#x3D; M&#x2F;l$。</li>\n<li>点燃处毒物进入空气和沿香烟穿行的数量比是 $a : a’$, $a’ + a &#x3D; 1$。</li>\n<li>未点燃的烟草和过滤嘴对穿行的毒物的单位时间吸收速率分别是 $b$ 和 $\\beta$。</li>\n<li>烟雾沿香烟穿行速度是常数 $v$, 香烟燃烧速度是常数 $u$, $v \\gg u$。</li>\n</ol>\n<p><img src=\"https://tk-pichost-1325224430.cos.ap-chengdu.myqcloud.com/blog/1739339098264762c0aa149f14ae599a418c4309aa91a.png\" alt=\"1739339098264762c0aa149f14ae599a418c4309aa91a.png\"></p>\n<h2 id=\"模型建立\"><a href=\"#模型建立\" class=\"headerlink\" title=\"模型建立\"></a>模型建立</h2><p>$t &#x3D; 0, x &#x3D; 0$, 点燃香烟</p>\n<p>$q(x,t) \\sim$ 毒物在 $x$ 处的流速（单位时间的流量）</p>\n<p>$w(x,t) \\sim$ 毒物密度</p>\n<p>$$<br>w(x,0) &#x3D; w_0<br>$$</p>\n<p>$$<br>Q &#x3D; \\int_0^T q(l, t) dt, \\quad T &#x3D; l_1 &#x2F; u<br>$$</p>\n<ol>\n<li>求 $q(x,t)$</li>\n</ol>\n<p>流量守恒：</p>\n<p>$$<br>\\begin{cases}<br>q(x,t) - q(x+\\Delta x,t) &#x3D; \\frac{q(x,t)b\\Delta x}{v}, &amp; ut \\leq x \\leq l_1 \\<br>q(x,t) - q(x+\\Delta x,t) &#x3D; \\frac{q(x,t)\\beta\\Delta x}{v}, &amp; l_1 \\leq x \\leq l<br>\\end{cases}<br>$$</p>\n<p>$$<br>\\frac{dq(x,t)}{dx} &#x3D;<br>\\begin{cases}<br>-\\frac{b}{v}q(x,t), &amp; ut \\leq x \\leq l_1 \\<br>-\\frac{\\beta}{v}q(x,t), &amp; l_1 \\leq x \\leq l<br>\\end{cases}<br>$$</p>\n<p>定解条件：$q(ut,t) &#x3D; auw(ut,t)$</p>\n<ol>\n<li>求 $w(ut,t)$ 考察 $\\Delta t$ 内毒物密度的增量</li>\n</ol>\n<p>$$<br>w(x, t + \\Delta t) - w(x, t) &#x3D; \\frac{q(x,t)\\Delta t b\\Delta t}{v\\Delta t}<br>$$</p>\n<p>其中：$q(x,t) &#x3D; auw(ut,t)e^{-\\frac{b(x-ut)}{v}}$</p>\n<p>$$<br>\\begin{cases}\\frac{\\partial w(ut,t)}{\\partial t} &#x3D; \\frac{b}{v}auw(ut,t)e^{-\\frac{b(x-ut)}{v}}\\<br>w(x,0)&#x3D;w_0<br>\\end{cases}<br>$$</p>\n<p>$$<br>w(ut,t) &#x3D; \\frac{w_0}{a’}\\left(1 - ae^{-\\frac{a’but}{v}}\\right), \\quad a’ &#x3D; 1-a<br>$$</p>\n<ol>\n<li>计算 $Q$~吸一支烟毒物进入人体总量</li>\n</ol>\n<p>$$<br>w(ut,t) &#x3D; \\frac{w_0}{a’}\\left(1 - ae^{-\\frac{a’but}{v}}\\right)<br>$$</p>\n<p>$$<br>q(l,t) &#x3D; auw(ut,t)e^{-\\frac{b l_1-wt}{v}}e^{-\\frac{\\beta l_2}{v}}\\<br>$$</p>\n<p>$$<br>Q &#x3D; \\int_0^{l_1&#x2F;u} q(l,t) dt &#x3D; \\frac{auw_0}{a’b} e^{-\\frac{\\beta l_2}{v}}\\left(1 - e^{-\\frac{a’bl_1}{v}}\\right)<br>$$</p>\n<p>$$<br>Q &#x3D; aMe^{-\\frac{\\beta l_2}{v}} \\varphi(r), \\quad r &#x3D; \\frac{a’bl_1}{v}, \\quad \\varphi(r) &#x3D; \\frac{1 - e^{-r}}{r}<br>$$</p>\n<h2 id=\"结果分析\"><a href=\"#结果分析\" class=\"headerlink\" title=\"结果分析\"></a>结果分析</h2><ol>\n<li>$Q$ 与 $a, M$ 成正比。($aM$ 是毒物集中在 $x &#x3D; l_1$ 处的吸入量)</li>\n<li>$e^{-\\frac{\\beta l_2}{v}} \\sim$ 过滤嘴因素, $\\beta, l_2 \\sim$ 负指数作用</li>\n<li>$\\varphi(r) \\sim$ 烟草的吸收作用 （烟草为什么有作用？）</li>\n</ol>\n<p>$$<br>r &#x3D; \\frac{a’bl_1}{v} \\ll 1<br>$$</p>\n<p>$$<br>\\varphi(r) &#x3D; 1 - \\frac{r}{2}<br>$$</p>\n<p>$$<br>Q &#x3D; aMe^{-\\frac{\\beta l_2}{v}}\\left(1 - \\frac{a’bl_1}{2v}\\right), \\quad b,l_1 \\sim \\text{线性作用}<br>$$</p>\n<ol>\n<li>与另一支不带过滤嘴的香烟比较，$w_0, b, a, v, l$ 均相同，吸至 $x &#x3D; l_1$ 抛掉。</li>\n</ol>\n<p><strong>带过滤嘴</strong>:</p>\n<p>$$<br>Q_1 &#x3D; \\frac{a w_0 v}{a’ b} e^{-\\frac{\\beta l_2}{v}} \\left(1 - e^{-\\frac{a’ b l_1}{v}}\\right)<br>$$</p>\n<p><strong>不带过滤嘴</strong>:</p>\n<p>$$<br>Q_2 &#x3D; \\frac{a w_0 v}{a’ b} \\left(1 - e^{-\\frac{a’ b l_1}{v}}\\right)<br>$$</p>\n<p>$$<br>\\frac{Q_1}{Q_2} &#x3D; e^{-\\frac{(\\beta - b) l_2}{v}}<br>$$</p>\n<p>$$<br>\\beta &gt; b \\Rightarrow Q_1 &lt; Q_2<br>$$</p>\n<p>提高 $\\beta b$ 与加长 $l_2$，效果相同。</p>\n<h2 id=\"总结\"><a href=\"#总结\" class=\"headerlink\" title=\"总结\"></a>总结</h2><ul>\n<li>引入两个基本函数：流量 $q(x,t)$ 和密度 $w(x,t)$，运用物理学的守恒定律通过微元方法建立微分方程，构造动态模型。</li>\n<li>对求解结果进行定性和定量分析，得到合理的实际结论。</li>\n</ul>\n<p><img src=\"https://tk-pichost-1325224430.cos.ap-chengdu.myqcloud.com/blog/17393391272532c0a5ec759324803b6b1d6f399985c6d.png\" alt=\"17393391272532c0a5ec759324803b6b1d6f399985c6d.png\"></p>\n<h2 id=\"代码-4\"><a href=\"#代码-4\" class=\"headerlink\" title=\"代码\"></a>代码</h2><figure class=\"highlight python\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">import</span> numpy <span class=\"keyword\">as</span> np</span><br><span class=\"line\"><span class=\"keyword\">import</span> matplotlib.pyplot <span class=\"keyword\">as</span> plt</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">#参数设置</span></span><br><span class=\"line\">M = <span class=\"number\">1.0</span>  <span class=\"comment\">#毒物总量 (任意单位)</span></span><br><span class=\"line\">a = <span class=\"number\">0.5</span>  <span class=\"comment\">#毒物进入空气和穿行的比例 (a = 0.5, a&#x27; = 0.5)</span></span><br><span class=\"line\">b = <span class=\"number\">0.1</span>  <span class=\"comment\">#烟草的吸收系数</span></span><br><span class=\"line\">beta = <span class=\"number\">0.8</span>  <span class=\"comment\">#过滤嘴的吸收系数, 增大以突出非线性效果</span></span><br><span class=\"line\">v = <span class=\"number\">1.0</span>  <span class=\"comment\">#烟雾穿行速度</span></span><br><span class=\"line\">l1 = <span class=\"number\">1.0</span>  <span class=\"comment\">#烟草长度</span></span><br><span class=\"line\">l2_values = np.linspace(<span class=\"number\">0</span>, <span class=\"number\">10</span>, <span class=\"number\">100</span>)  <span class=\"comment\">#过滤嘴长度的变化范围, 增大以观察非线性效果</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">#计算 Q1 和 Q2</span></span><br><span class=\"line\"><span class=\"keyword\">def</span> <span class=\"title function_\">calculate_Q</span>(<span class=\"params\">l1, l2, a, M, b, beta, v</span>):</span><br><span class=\"line\">    a_prime = <span class=\"number\">1</span> - a</span><br><span class=\"line\">    r = a_prime * b * l1 / v</span><br><span class=\"line\">    Q1 = (a * M * v / (a_prime * b)) * np.exp(-beta * l2 / v) * (<span class=\"number\">1</span> - np.exp(-r))</span><br><span class=\"line\">    Q2 = (a * M * v / (a_prime * b)) * (<span class=\"number\">1</span> - np.exp(-r))</span><br><span class=\"line\">    <span class=\"keyword\">return</span> Q1, Q2</span><br><span class=\"line\"></span><br><span class=\"line\">Q1_values = []</span><br><span class=\"line\">Q2_values = []</span><br><span class=\"line\"><span class=\"keyword\">for</span> l2 <span class=\"keyword\">in</span> l2_values:</span><br><span class=\"line\">    Q1, Q2 = calculate_Q(l1, l2, a, M, b, beta, v)</span><br><span class=\"line\">    Q1_values.append(Q1)</span><br><span class=\"line\">    Q2_values.append(Q2)</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">#比较有过滤嘴和无过滤嘴的毒物量</span></span><br><span class=\"line\">Q1_values = np.array(Q1_values)</span><br><span class=\"line\">Q2_values = np.array(Q2_values)</span><br><span class=\"line\">Q_ratio = Q1_values / Q2_values</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">#绘图</span></span><br><span class=\"line\">plt.figure(figsize=(<span class=\"number\">10</span>, <span class=\"number\">6</span>))</span><br><span class=\"line\">plt.plot(l2_values, Q1_values, label=<span class=\"string\">&#x27;Q1 (With Filter)&#x27;</span>)</span><br><span class=\"line\">plt.plot(l2_values, Q2_values, label=<span class=\"string\">&#x27;Q2 (Without Filter)&#x27;</span>)</span><br><span class=\"line\">plt.plot(l2_values, Q_ratio, label=<span class=\"string\">&#x27;Q1/Q2 Ratio&#x27;</span>, linestyle=<span class=\"string\">&#x27;--&#x27;</span>)</span><br><span class=\"line\">plt.xlabel(<span class=\"string\">&#x27;Filter Length l2&#x27;</span>)</span><br><span class=\"line\">plt.ylabel(<span class=\"string\">&#x27;Toxin Amount Q&#x27;</span>)</span><br><span class=\"line\">plt.title(<span class=\"string\">&#x27;Effect of Filter Length and Material on Toxin Inhalation&#x27;</span>)</span><br><span class=\"line\">plt.legend()</span><br><span class=\"line\">plt.grid(<span class=\"literal\">True</span>)</span><br><span class=\"line\">plt.show()</span><br></pre></td></tr></table></figure>\n\n<h1 id=\"四、烟雾的扩散与消失模型\"><a href=\"#四、烟雾的扩散与消失模型\" class=\"headerlink\" title=\"四、烟雾的扩散与消失模型\"></a>四、烟雾的扩散与消失模型</h1><h2 id=\"现象和问题\"><a href=\"#现象和问题\" class=\"headerlink\" title=\"现象和问题\"></a>现象和问题</h2><ul>\n<li>炮弹在空中爆炸，烟雾向四周扩散，形成圆形不透光区域。</li>\n<li>不透光区域不断扩大，然后区域边界逐渐明亮，区域缩小，最后烟雾消失。</li>\n<li>建立模型描述烟雾扩散和消失过程，分析消失时间与各因素的关系。</li>\n</ul>\n<h2 id=\"问题分析\"><a href=\"#问题分析\" class=\"headerlink\" title=\"问题分析\"></a>问题分析</h2><ul>\n<li>无穷空间由瞬时点源导致的扩散过程，用二阶偏微分方程描述烟雾浓度的变化。</li>\n<li>观察到的烟雾消失与烟雾对光线的吸收，以及仪器对明暗的灵敏度有关。</li>\n</ul>\n<h2 id=\"模型假设-1\"><a href=\"#模型假设-1\" class=\"headerlink\" title=\"模型假设\"></a>模型假设</h2><ol>\n<li>扩散服从扩散定律。</li>\n<li>光线穿过烟雾时光强的相对减少与与烟雾浓度成正比；无烟雾的大小不影响光强。</li>\n<li>穿过烟雾进入仪器的光线只有明暗之分，明暗界限由仪器灵敏度决定。</li>\n</ol>\n<h2 id=\"模型建立-1\"><a href=\"#模型建立-1\" class=\"headerlink\" title=\"模型建立\"></a>模型建立</h2><p><strong>扩散定律</strong>：单位时间通过单位法向面积的流量 $q$ 与浓度 $C$ 的梯度成正比。</p>\n<p>$$<br>q &#x3D; -k \\cdot \\nabla C<br>$$</p>\n<p>烟雾浓度 $C(x,y,z,t)$ 的变化规律</p>\n<p>$[t,t+\\Delta t]$ 通过$\\Omega$流出量$Q_1 &#x3D; \\int_{t}^{t+\\Delta t} \\iint_S q \\cdot n d \\sigma dt$</p>\n<p>$\\Omega$ 内烟雾改变量 $Q_2 &#x3D; \\iiint_{v} [C(x,y,z,t+\\Delta t) - C(x,y,z,t)] dV$</p>\n<p>高斯公式:</p>\n<p>$$<br>\\iint_S q \\cdot n d\\sigma &#x3D; \\iiint_V \\text{div } q dV &#x3D; -k \\iiint_V \\text{div } (\\nabla C) dV<br>$$</p>\n<p>$$<br>Q_2 &#x3D; -Q_1<br>$$</p>\n<p>$$<br>\\frac{\\partial C}{\\partial t} &#x3D; k [\\text{div}(\\nabla C)] &#x3D; k \\left(\\frac{\\partial^2 C}{\\partial x^2} + \\frac{\\partial^2 C}{\\partial y^2} + \\frac{\\partial^2 C}{\\partial z^2}\\right),-\\infty&lt;x,y,z&lt;\\infty,t&gt;0<br>$$</p>\n<h2 id=\"初始条件\"><a href=\"#初始条件\" class=\"headerlink\" title=\"初始条件\"></a>初始条件</h2><p>$$<br>C(x, y, z, 0) &#x3D; Q \\delta(x, y, z)<br>$$</p>\n<ul>\n<li>$Q \\sim$ 炮弹释放的烟雾总量</li>\n<li>$\\delta \\sim$ 单位强度的点源函数</li>\n</ul>\n<p>求解方程:</p>\n<p>$$<br>C(x, y, z, t) &#x3D; \\frac{Q}{(4 \\pi kt)^{3&#x2F;2}} e^{-\\frac{x^2 + y^2 + z^2}{4 kt}}<br>$$</p>\n<h2 id=\"光强穿过烟雾时的变化规律\"><a href=\"#光强穿过烟雾时的变化规律\" class=\"headerlink\" title=\"光强穿过烟雾时的变化规律\"></a>光强穿过烟雾时的变化规律</h2><ul>\n<li>$I(l) \\sim$ 沿 $l$ 方向的光强</li>\n<li>$C(l) \\sim$ 沿 $l$ 方向的烟雾浓度</li>\n</ul>\n<p>假设光强的相对减少与烟雾浓度成正比。</p>\n<p>$$<br>\\frac{dI(l)}{dl} &#x3D; -\\alpha C(l) I(l)<br>$$</p>\n<p>记未进入烟雾($l \\leq l_0$)时光强为 $I(l_0) &#x3D; I_0$:</p>\n<p>$$<br>I(l) &#x3D; I_0 e^{-\\alpha \\int_{l_0}^{l} C(s) ds}<br>$$</p>\n<h2 id=\"仪器灵敏度与烟雾明暗界限\"><a href=\"#仪器灵敏度与烟雾明暗界限\" class=\"headerlink\" title=\"仪器灵敏度与烟雾明暗界限\"></a>仪器灵敏度与烟雾明暗界限</h2><ul>\n<li>烟雾浓度连续变化</li>\n<li>烟雾中光强连续变化。</li>\n<li>穿过烟雾进入仪器的光线只有明暗之分，明暗界限由仪器灵敏度决定。</li>\n</ul>\n<p>$\\mu \\sim$ 仪器灵敏度，当 $I&#x2F;I_0 &lt; 1 - \\mu$，观测结果为暗。</p>\n<p>设光源在 $z &#x3D; -\\infty$，仪器在 $z &#x3D; \\infty$，则观测到的明暗界限为:</p>\n<p>$e^{-\\alpha \\int_{-\\infty}^{\\infty} C(x,y,z,t) dz} &#x3D; 1 - \\mu$$\\sim$ 不透光区域边界</p>\n<h3 id=\"求解方程\"><a href=\"#求解方程\" class=\"headerlink\" title=\"求解方程\"></a>求解方程</h3><p>$$<br>C(x, y, z, t) &#x3D; \\frac{Q}{(4 \\pi kt)^{3&#x2F;2}} e^{-\\frac{x^2 + y^2 + z^2}{4 kt}}<br>$$</p>\n<p>$$<br>\\Rightarrow \\int_{-\\infty}^{\\infty} C(x,y,z,t) dz &#x3D; \\frac{1}{\\alpha} \\ln \\frac{1}{1-\\mu} \\approx \\frac{\\mu}{\\alpha} \\quad (\\mu \\text{ 很小})<br>$$</p>\n<p>而$\\quad \\int_{-\\infty}^{\\infty} C(x,y,z,t) dz &#x3D; \\frac{Q}{4 \\pi kt} e^{-\\frac{x^2 + y^2}{4kt}}$</p>\n<p>$$<br>\\frac{Q}{4 \\pi kt} e^{-\\frac{x^2 + y^2}{4 kt}} &#x3D; \\frac{\\mu}{\\alpha}<br>$$</p>\n<p>不透光区域边界半径:</p>\n<p>$$<br>r(t) &#x3D; \\sqrt{4 kt \\ln \\frac{\\alpha Q}{4 \\pi k \\mu t}}<br>$$</p>\n<h3 id=\"结果分析-1\"><a href=\"#结果分析-1\" class=\"headerlink\" title=\"结果分析\"></a>结果分析</h3><p>$$<br>r(t) &#x3D; \\sqrt{4 kt \\ln \\frac{\\alpha Q}{4 \\pi k \\mu t}}<br>$$</p>\n<p>$$<br>t &#x3D; t_1 &#x3D; \\frac{\\alpha Q}{4 \\pi k \\mu e}, \\quad r &#x3D; r_m &#x3D; \\sqrt{\\frac{Q}{\\pi \\mu e}} \\quad (\\text{最大值})<br>$$</p>\n<p>$$<br>t &#x3D; t_2 &#x3D; \\frac{\\alpha Q}{4 \\pi k \\mu}, \\quad r &#x3D; 0<br>$$</p>\n<p>$$<br>\\alpha \\uparrow, Q \\uparrow, \\mu \\downarrow \\Rightarrow t_1 \\uparrow, r_m \\uparrow<br>$$</p>\n<p>$$<br>k \\downarrow \\Rightarrow t_1 \\uparrow<br>$$</p>\n<p><img src=\"https://tk-pichost-1325224430.cos.ap-chengdu.myqcloud.com/blog/173933914986904ee6ddfd517468d93120f3cfe746ffd.png\" alt=\"173933914986904ee6ddfd517468d93120f3cfe746ffd.png\"></p>\n<table>\n<thead>\n<tr>\n<th>参数</th>\n<th>数值</th>\n</tr>\n</thead>\n<tbody><tr>\n<td>最大不透光区域边界半径$r_{max}$</td>\n<td>3.4220</td>\n</tr>\n<tr>\n<td>边界达到最大值的时间$t_1$</td>\n<td>2.9275</td>\n</tr>\n<tr>\n<td>烟雾完全消失的时间$t_2$</td>\n<td>7.9577</td>\n</tr>\n</tbody></table>\n<p>观测到不透光区域边界达到最大的时刻 $t_1$, 可以预报烟雾消失的时刻 $t_2$</p>\n<blockquote>\n<ol>\n<li><strong>蓝色曲线</strong>$r(t) &#x3D; \\sqrt{4kt \\ln \\left(\\frac{\\alpha Q}{4\\pi k \\mu t}\\right)}$:<ul>\n<li>该曲线表示不透光区域的边界半径 $r(t)$随时间 $ t$ 的变化。</li>\n<li>在爆炸初始时刻，烟雾边界迅速扩散，边界半径增大。</li>\n<li>随着时间的推移，边界半径达到一个最大值，然后开始减小，直到最后烟雾完全消失。</li>\n</ul>\n</li>\n<li><strong>红色虚线</strong>(垂直线)$t_1 &#x3D; \\frac{\\alpha Q}{4 \\pi k \\mu e}$:<ul>\n<li>这条红色虚线表示边界半径达到最大值的时间$t_1$。</li>\n<li>从图中可以看到，边界半径在此时刻 $t_1$达到了峰值。</li>\n</ul>\n</li>\n<li><strong>绿色虚线</strong>(水平线)$r_m &#x3D; \\sqrt{\\frac{Q}{\\pi \\mu e}}$:<ul>\n<li>这条绿色虚线表示不透光区域边界的最大半径 $ r_m$。</li>\n<li>该半径在 $t_1$ 时刻达到，这是烟雾扩散过程中的最大范围。</li>\n</ul>\n</li>\n<li><strong>蓝色虚线</strong>(垂直线)$t_2 &#x3D; \\frac{\\alpha Q}{4 \\pi k \\mu}$:<ul>\n<li>这条蓝色虚线表示烟雾完全消失的时间 $t_2 $。</li>\n<li>此时，边界半径 $r(t)$已经缩小至零，意味着烟雾已经完全消散。</li>\n</ul>\n</li>\n</ol>\n</blockquote>\n<h2 id=\"代码-5\"><a href=\"#代码-5\" class=\"headerlink\" title=\"代码\"></a>代码</h2><figure class=\"highlight python\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">import</span> numpy <span class=\"keyword\">as</span> np</span><br><span class=\"line\"><span class=\"keyword\">import</span> matplotlib.pyplot <span class=\"keyword\">as</span> plt</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\"># 定义常数(这些常数可以根据特定情况进行设置)</span></span><br><span class=\"line\">k = <span class=\"number\">1.0</span>  <span class=\"comment\"># 扩散系数</span></span><br><span class=\"line\">alpha = <span class=\"number\">1.0</span>  <span class=\"comment\"># 参数alpha</span></span><br><span class=\"line\">Q = <span class=\"number\">1.0</span>  <span class=\"comment\"># 炮弹释放的烟雾总量</span></span><br><span class=\"line\">mu = <span class=\"number\">0.01</span>  <span class=\"comment\"># 仪器灵敏度</span></span><br><span class=\"line\">pi = np.pi</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\"># 定义不透光区域边界半径 r(t)</span></span><br><span class=\"line\"><span class=\"keyword\">def</span> <span class=\"title function_\">r</span>(<span class=\"params\">t</span>):</span><br><span class=\"line\">    <span class=\"keyword\">return</span> np.sqrt(<span class=\"number\">4</span> * k * t * np.log(alpha * Q / (<span class=\"number\">4</span> * pi * k * mu * t)))</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\"># 计算最大边界半径和相关时间点</span></span><br><span class=\"line\">t1 = alpha * Q / (<span class=\"number\">4</span> * pi * k * mu * np.e)</span><br><span class=\"line\">r_max = np.sqrt(Q / (pi * mu * np.e))</span><br><span class=\"line\">t2 = alpha * Q / (<span class=\"number\">4</span> * pi * k * mu)</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\"># 时间范围</span></span><br><span class=\"line\">t = np.linspace(<span class=\"number\">0.1</span>, t2 * <span class=\"number\">1.5</span>, <span class=\"number\">500</span>)  <span class=\"comment\"># 从小于 t2 的时间开始</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\"># 绘制不透光区域边界随时间的变化</span></span><br><span class=\"line\">plt.figure(figsize=(<span class=\"number\">10</span>, <span class=\"number\">6</span>))</span><br><span class=\"line\">plt.plot(t, r(t), label=<span class=\"string\">r&#x27;$r(t) = \\sqrt&#123;4 kt **\\l**n **\\f**rac&#123;**\\a**lpha Q&#125;&#123;4 **\\p**i k **\\m**u t&#125;&#125;$&#x27;</span>)</span><br><span class=\"line\">plt.axvline(t1, color=<span class=\"string\">&#x27;r&#x27;</span>, linestyle=<span class=\"string\">&#x27;--&#x27;</span>, label=<span class=\"string\">r&#x27;$t_1 = **\\f**rac&#123;**\\a**lpha Q&#125;&#123;4 **\\p**i k **\\m**u e&#125;$&#x27;</span>)</span><br><span class=\"line\">plt.axhline(r_max, color=<span class=\"string\">&#x27;g&#x27;</span>, linestyle=<span class=\"string\">&#x27;--&#x27;</span>, label=<span class=\"string\">r&#x27;$r_m = \\sqrt&#123;**\\f**rac&#123;Q&#125;&#123;**\\p**i **\\m**u e&#125;&#125;$&#x27;</span>)</span><br><span class=\"line\">plt.axvline(t2, color=<span class=\"string\">&#x27;b&#x27;</span>, linestyle=<span class=\"string\">&#x27;--&#x27;</span>, label=<span class=\"string\">r&#x27;$t_2 = **\\f**rac&#123;**\\a**lpha Q&#125;&#123;4 **\\p**i k **\\m**u&#125;$&#x27;</span>)</span><br><span class=\"line\">plt.xlabel(<span class=\"string\">&#x27;Time t&#x27;</span>)</span><br><span class=\"line\">plt.ylabel(<span class=\"string\">&#x27;Boundary Radius r(t)&#x27;</span>)</span><br><span class=\"line\">plt.title(<span class=\"string\">&#x27;Smoke Diffusion and Dissipation Model&#x27;</span>)</span><br><span class=\"line\">plt.legend()</span><br><span class=\"line\">plt.grid(<span class=\"literal\">True</span>)</span><br><span class=\"line\">plt.show()</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\"># 输出最大边界半径和相关时间点</span></span><br><span class=\"line\"><span class=\"built_in\">print</span>(<span class=\"string\">f&quot;最大不透光区域边界半径 r_max = <span class=\"subst\">&#123;r_max:<span class=\"number\">.4</span>f&#125;</span>&quot;</span>)</span><br><span class=\"line\"><span class=\"built_in\">print</span>(<span class=\"string\">f&quot;边界达到最大值的时间 t1 = <span class=\"subst\">&#123;t1:<span class=\"number\">.4</span>f&#125;</span>&quot;</span>)</span><br><span class=\"line\"><span class=\"built_in\">print</span>(<span class=\"string\">f&quot;烟雾完全消失的时间 t2 = <span class=\"subst\">&#123;t2:<span class=\"number\">.4</span>f&#125;</span>&quot;</span>)</span><br></pre></td></tr></table></figure>\n"},{"title":"文言文背诵检测程序开发","date":"2025-02-09T16:00:00.000Z","_content":"## 目录\n\n- [概述](#-概述)\n- [项目结构](#-项目结构)\n  - [项目索引](#-项目索引)\n- [开始使用](#-开始使用)\n  - [前提条件](#-前提条件)\n  - [安装](#-安装)\n\n## 概述\n\n今天在侄儿子要求在我这里背书的时候,有点嫌麻烦,想用程序识别和检测他的背诵,在网上查找相关软件和网站发现只有一个滑板车背诵的软件效果还不错,但是还是感觉这个产业不太成熟,于是自己用ai基于百度AI接口开发了此背诵检测程序，实现以下功能：\n\n- 语音转文本：实时录制背诵音频并转换为文字\n- 相似度对比：通过自然语言处理（NLP）比对背诵内容与原文\n- 准确率评分：输出整体匹配度和逐句差异分析\n  支持导入自定义文言文文本文件\n\n> 注意:`<br>`\n> 需提前申请百度语音API 和百度NPL API `<br>`\n> 目前识别效果和响应时间并不理想,需要一次性一句话一句话背诵\n\n### 项目原理\n\n本程序基于Python开发，主要利用百度AI开放平台的语音识别和自然语言处理（NLP）技术，实现文言文背诵的自动检测。以下是程序的核心技术原理：\n\n1. 语音转文本（语音识别）\n\n- 技术原理：\n  - 使用百度AI的语音识别API，将用户背诵的语音实时转换为文本。\n  - 语音识别通过声学模型和语言模型，将音频信号转换为文字。声学模型负责将语音信号转换为音素，语言模型则根据上下文和语法生成最可能的文本结果。\n  - 本程序采用百度AI的asr接口，支持实时语音识别，能够处理流式音频数据。\n- 实现步骤：\n  1. 音频采集：通过麦克风采集用户的语音，并将其转换为音频数据流。\n  2. 音频预处理：对音频数据进行降噪、归一化等预处理操作，提高识别准确率。\n  3. 语音识别：将预处理后的音频数据发送到百度AI语音识别API，获取识别结果。\n  4. 结果处理：对识别结果进行后处理，如去除多余空格、标点符号等。\n\n2. 文本相似度分析（自然语言处理）\n\n- 技术原理：\n  - 使用百度AI的自然语言处理（NLP）技术，对背诵文本和原文进行相似度分析。\n  - 相似度分析通过计算两个文本的语义相似度，判断背诵内容是否与原文一致。\n  - 本程序采用百度AI的simnet接口，基于深度学习模型，能够准确计算文本之间的语义相似度。\n- 实现步骤：\n  1. 文本分句：将背诵文本和原文按句子分割，提取每个句子的文本内容。\n  2. 相似度计算：对每个句子的背诵文本和原文进行相似度计算，获取相似度分数。\n  3. 结果评估：根据相似度分数，判断背诵内容的准确性和完整性。\n\n3. 准确率评分\n\n- 技术原理：\n  - 通过对比背诵文本和原文的相似度，计算整体匹配度和逐句差异分析。\n  - 使用difflib库的SequenceMatcher类，计算两个文本的相似度分数。\n  - 结合百度AI的语义相似度分析结果，生成最终的准确率评分。\n- 实现步骤：\n  1. 逐句对比：对每个句子的背诵文本和原文进行逐句对比，计算相似度分数。\n  2. 整体评分：根据逐句相似度分数，计算整体匹配度。\n  3. 差异分析：生成逐句差异分析报告，显示每句话的相似度分数和差异部分。\n\n4. 实时反馈与进度显示\n\n- 技术原理：\n  - 使用Tkinter库创建图形用户界面（GUI），实时显示背诵进度和识别结果。\n  - 通过多线程技术，实现语音识别、文本处理和UI更新的并行处理，确保程序的实时性和流畅性。\n  - 使用进度条和计时器，显示背诵进度和剩余时间，帮助用户更好地掌握背诵节奏。\n- 实现步骤：\n  1. UI设计：设计背诵界面，包括原文显示、识别结果显示、进度条和计时器等。\n  2. 多线程处理：创建多个线程，分别处理音频采集、语音识别、文本处理和UI更新。\n  3. 实时更新：根据识别结果和相似度分析，实时更新识别结果显示和进度条。\n\n## 项目结构\n\n```sh\n└── ReciteHelper/\n    ├── Dockerfile\n    ├── README.md\n    ├── config.py\n    ├── main.py\n    ├── requirements.txt\n    └── texts\n        ├── 买油翁.txt\n        ├── 孙权劝学.txt\n        └── 木兰诗.txt\n```\n\n## 开始使用\n\n### 安装\n\n使用以下方法安装 ReciteHelper：\n\n1. 克隆 ReciteHelper 仓库：\n\n```sh\ngit clone https://github.com/tkzzzzzz6/ReciteHelper\n```\n\n2. 进入项目目录：\n\n```sh\ncd ReciteHelper\n```\n\n3. 配置环境\n\n推荐使用 conda 虚拟环境：\n\n```sh\nconda create -n beisong python=3.10 -y\nconda activate beisong\npip install -r requirements.txt\n```\n\n4. 配置API密钥\n\n- 前往百度AI控制台 创建应用\n- 获取 API Key 和 Secret Key\n- 修改 config.py 文件：\n\n```sh\n#语音识别配置\nAPP_ID = '你的APP ID'      # 应用ID\nAPI_KEY = '你的API Key'    # API Key\nSECRET_KEY = '你的API Key'    # API Key\n\n#百度NLP配置\nNLP_APP_ID = '你的APP ID' \nNLP_API_KEY = '你的API Key'    # API Key\nNLP_SECRET_KEY = '你的API Key'    # API Key\n```\n\n5. 添加背诵文本\n\n将文言文文本保存为 txt 文件，放置于 /texts 目录下（程序已内置《孙权劝学》《卖油翁》《木兰诗》示例文本）\n\n6. 运行程序\n\n```sh\npython main.py\n```\n","source":"_posts/2025-02-10-文言文背诵检测程序开发.md","raw":"---\ntitle: 文言文背诵检测程序开发\ndate: 2025-02-10\ntags: 程序开发\n---\n## 目录\n\n- [概述](#-概述)\n- [项目结构](#-项目结构)\n  - [项目索引](#-项目索引)\n- [开始使用](#-开始使用)\n  - [前提条件](#-前提条件)\n  - [安装](#-安装)\n\n## 概述\n\n今天在侄儿子要求在我这里背书的时候,有点嫌麻烦,想用程序识别和检测他的背诵,在网上查找相关软件和网站发现只有一个滑板车背诵的软件效果还不错,但是还是感觉这个产业不太成熟,于是自己用ai基于百度AI接口开发了此背诵检测程序，实现以下功能：\n\n- 语音转文本：实时录制背诵音频并转换为文字\n- 相似度对比：通过自然语言处理（NLP）比对背诵内容与原文\n- 准确率评分：输出整体匹配度和逐句差异分析\n  支持导入自定义文言文文本文件\n\n> 注意:`<br>`\n> 需提前申请百度语音API 和百度NPL API `<br>`\n> 目前识别效果和响应时间并不理想,需要一次性一句话一句话背诵\n\n### 项目原理\n\n本程序基于Python开发，主要利用百度AI开放平台的语音识别和自然语言处理（NLP）技术，实现文言文背诵的自动检测。以下是程序的核心技术原理：\n\n1. 语音转文本（语音识别）\n\n- 技术原理：\n  - 使用百度AI的语音识别API，将用户背诵的语音实时转换为文本。\n  - 语音识别通过声学模型和语言模型，将音频信号转换为文字。声学模型负责将语音信号转换为音素，语言模型则根据上下文和语法生成最可能的文本结果。\n  - 本程序采用百度AI的asr接口，支持实时语音识别，能够处理流式音频数据。\n- 实现步骤：\n  1. 音频采集：通过麦克风采集用户的语音，并将其转换为音频数据流。\n  2. 音频预处理：对音频数据进行降噪、归一化等预处理操作，提高识别准确率。\n  3. 语音识别：将预处理后的音频数据发送到百度AI语音识别API，获取识别结果。\n  4. 结果处理：对识别结果进行后处理，如去除多余空格、标点符号等。\n\n2. 文本相似度分析（自然语言处理）\n\n- 技术原理：\n  - 使用百度AI的自然语言处理（NLP）技术，对背诵文本和原文进行相似度分析。\n  - 相似度分析通过计算两个文本的语义相似度，判断背诵内容是否与原文一致。\n  - 本程序采用百度AI的simnet接口，基于深度学习模型，能够准确计算文本之间的语义相似度。\n- 实现步骤：\n  1. 文本分句：将背诵文本和原文按句子分割，提取每个句子的文本内容。\n  2. 相似度计算：对每个句子的背诵文本和原文进行相似度计算，获取相似度分数。\n  3. 结果评估：根据相似度分数，判断背诵内容的准确性和完整性。\n\n3. 准确率评分\n\n- 技术原理：\n  - 通过对比背诵文本和原文的相似度，计算整体匹配度和逐句差异分析。\n  - 使用difflib库的SequenceMatcher类，计算两个文本的相似度分数。\n  - 结合百度AI的语义相似度分析结果，生成最终的准确率评分。\n- 实现步骤：\n  1. 逐句对比：对每个句子的背诵文本和原文进行逐句对比，计算相似度分数。\n  2. 整体评分：根据逐句相似度分数，计算整体匹配度。\n  3. 差异分析：生成逐句差异分析报告，显示每句话的相似度分数和差异部分。\n\n4. 实时反馈与进度显示\n\n- 技术原理：\n  - 使用Tkinter库创建图形用户界面（GUI），实时显示背诵进度和识别结果。\n  - 通过多线程技术，实现语音识别、文本处理和UI更新的并行处理，确保程序的实时性和流畅性。\n  - 使用进度条和计时器，显示背诵进度和剩余时间，帮助用户更好地掌握背诵节奏。\n- 实现步骤：\n  1. UI设计：设计背诵界面，包括原文显示、识别结果显示、进度条和计时器等。\n  2. 多线程处理：创建多个线程，分别处理音频采集、语音识别、文本处理和UI更新。\n  3. 实时更新：根据识别结果和相似度分析，实时更新识别结果显示和进度条。\n\n## 项目结构\n\n```sh\n└── ReciteHelper/\n    ├── Dockerfile\n    ├── README.md\n    ├── config.py\n    ├── main.py\n    ├── requirements.txt\n    └── texts\n        ├── 买油翁.txt\n        ├── 孙权劝学.txt\n        └── 木兰诗.txt\n```\n\n## 开始使用\n\n### 安装\n\n使用以下方法安装 ReciteHelper：\n\n1. 克隆 ReciteHelper 仓库：\n\n```sh\ngit clone https://github.com/tkzzzzzz6/ReciteHelper\n```\n\n2. 进入项目目录：\n\n```sh\ncd ReciteHelper\n```\n\n3. 配置环境\n\n推荐使用 conda 虚拟环境：\n\n```sh\nconda create -n beisong python=3.10 -y\nconda activate beisong\npip install -r requirements.txt\n```\n\n4. 配置API密钥\n\n- 前往百度AI控制台 创建应用\n- 获取 API Key 和 Secret Key\n- 修改 config.py 文件：\n\n```sh\n#语音识别配置\nAPP_ID = '你的APP ID'      # 应用ID\nAPI_KEY = '你的API Key'    # API Key\nSECRET_KEY = '你的API Key'    # API Key\n\n#百度NLP配置\nNLP_APP_ID = '你的APP ID' \nNLP_API_KEY = '你的API Key'    # API Key\nNLP_SECRET_KEY = '你的API Key'    # API Key\n```\n\n5. 添加背诵文本\n\n将文言文文本保存为 txt 文件，放置于 /texts 目录下（程序已内置《孙权劝学》《卖油翁》《木兰诗》示例文本）\n\n6. 运行程序\n\n```sh\npython main.py\n```\n","slug":"2025-02-10-文言文背诵检测程序开发","published":1,"updated":"2025-09-26T12:15:01.414Z","_id":"cmg0saj3s0006jm8n8yfb4swh","comments":1,"layout":"post","photos":[],"content":"<h2 id=\"目录\"><a href=\"#目录\" class=\"headerlink\" title=\"目录\"></a>目录</h2><ul>\n<li><a href=\"#-%E6%A6%82%E8%BF%B0\">概述</a></li>\n<li><a href=\"#-%E9%A1%B9%E7%9B%AE%E7%BB%93%E6%9E%84\">项目结构</a><ul>\n<li><a href=\"#-%E9%A1%B9%E7%9B%AE%E7%B4%A2%E5%BC%95\">项目索引</a></li>\n</ul>\n</li>\n<li><a href=\"#-%E5%BC%80%E5%A7%8B%E4%BD%BF%E7%94%A8\">开始使用</a><ul>\n<li><a href=\"#-%E5%89%8D%E6%8F%90%E6%9D%A1%E4%BB%B6\">前提条件</a></li>\n<li><a href=\"#-%E5%AE%89%E8%A3%85\">安装</a></li>\n</ul>\n</li>\n</ul>\n<h2 id=\"概述\"><a href=\"#概述\" class=\"headerlink\" title=\"概述\"></a>概述</h2><p>今天在侄儿子要求在我这里背书的时候,有点嫌麻烦,想用程序识别和检测他的背诵,在网上查找相关软件和网站发现只有一个滑板车背诵的软件效果还不错,但是还是感觉这个产业不太成熟,于是自己用ai基于百度AI接口开发了此背诵检测程序，实现以下功能：</p>\n<ul>\n<li>语音转文本：实时录制背诵音频并转换为文字</li>\n<li>相似度对比：通过自然语言处理（NLP）比对背诵内容与原文</li>\n<li>准确率评分：输出整体匹配度和逐句差异分析<br>支持导入自定义文言文文本文件</li>\n</ul>\n<blockquote>\n<p>注意:<code>&lt;br&gt;</code><br>需提前申请百度语音API 和百度NPL API <code>&lt;br&gt;</code><br>目前识别效果和响应时间并不理想,需要一次性一句话一句话背诵</p>\n</blockquote>\n<h3 id=\"项目原理\"><a href=\"#项目原理\" class=\"headerlink\" title=\"项目原理\"></a>项目原理</h3><p>本程序基于Python开发，主要利用百度AI开放平台的语音识别和自然语言处理（NLP）技术，实现文言文背诵的自动检测。以下是程序的核心技术原理：</p>\n<ol>\n<li>语音转文本（语音识别）</li>\n</ol>\n<ul>\n<li>技术原理：<ul>\n<li>使用百度AI的语音识别API，将用户背诵的语音实时转换为文本。</li>\n<li>语音识别通过声学模型和语言模型，将音频信号转换为文字。声学模型负责将语音信号转换为音素，语言模型则根据上下文和语法生成最可能的文本结果。</li>\n<li>本程序采用百度AI的asr接口，支持实时语音识别，能够处理流式音频数据。</li>\n</ul>\n</li>\n<li>实现步骤：<ol>\n<li>音频采集：通过麦克风采集用户的语音，并将其转换为音频数据流。</li>\n<li>音频预处理：对音频数据进行降噪、归一化等预处理操作，提高识别准确率。</li>\n<li>语音识别：将预处理后的音频数据发送到百度AI语音识别API，获取识别结果。</li>\n<li>结果处理：对识别结果进行后处理，如去除多余空格、标点符号等。</li>\n</ol>\n</li>\n</ul>\n<ol start=\"2\">\n<li>文本相似度分析（自然语言处理）</li>\n</ol>\n<ul>\n<li>技术原理：<ul>\n<li>使用百度AI的自然语言处理（NLP）技术，对背诵文本和原文进行相似度分析。</li>\n<li>相似度分析通过计算两个文本的语义相似度，判断背诵内容是否与原文一致。</li>\n<li>本程序采用百度AI的simnet接口，基于深度学习模型，能够准确计算文本之间的语义相似度。</li>\n</ul>\n</li>\n<li>实现步骤：<ol>\n<li>文本分句：将背诵文本和原文按句子分割，提取每个句子的文本内容。</li>\n<li>相似度计算：对每个句子的背诵文本和原文进行相似度计算，获取相似度分数。</li>\n<li>结果评估：根据相似度分数，判断背诵内容的准确性和完整性。</li>\n</ol>\n</li>\n</ul>\n<ol start=\"3\">\n<li>准确率评分</li>\n</ol>\n<ul>\n<li>技术原理：<ul>\n<li>通过对比背诵文本和原文的相似度，计算整体匹配度和逐句差异分析。</li>\n<li>使用difflib库的SequenceMatcher类，计算两个文本的相似度分数。</li>\n<li>结合百度AI的语义相似度分析结果，生成最终的准确率评分。</li>\n</ul>\n</li>\n<li>实现步骤：<ol>\n<li>逐句对比：对每个句子的背诵文本和原文进行逐句对比，计算相似度分数。</li>\n<li>整体评分：根据逐句相似度分数，计算整体匹配度。</li>\n<li>差异分析：生成逐句差异分析报告，显示每句话的相似度分数和差异部分。</li>\n</ol>\n</li>\n</ul>\n<ol start=\"4\">\n<li>实时反馈与进度显示</li>\n</ol>\n<ul>\n<li>技术原理：<ul>\n<li>使用Tkinter库创建图形用户界面（GUI），实时显示背诵进度和识别结果。</li>\n<li>通过多线程技术，实现语音识别、文本处理和UI更新的并行处理，确保程序的实时性和流畅性。</li>\n<li>使用进度条和计时器，显示背诵进度和剩余时间，帮助用户更好地掌握背诵节奏。</li>\n</ul>\n</li>\n<li>实现步骤：<ol>\n<li>UI设计：设计背诵界面，包括原文显示、识别结果显示、进度条和计时器等。</li>\n<li>多线程处理：创建多个线程，分别处理音频采集、语音识别、文本处理和UI更新。</li>\n<li>实时更新：根据识别结果和相似度分析，实时更新识别结果显示和进度条。</li>\n</ol>\n</li>\n</ul>\n<h2 id=\"项目结构\"><a href=\"#项目结构\" class=\"headerlink\" title=\"项目结构\"></a>项目结构</h2><figure class=\"highlight sh\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">└── ReciteHelper/</span><br><span class=\"line\">    ├── Dockerfile</span><br><span class=\"line\">    ├── README.md</span><br><span class=\"line\">    ├── config.py</span><br><span class=\"line\">    ├── main.py</span><br><span class=\"line\">    ├── requirements.txt</span><br><span class=\"line\">    └── texts</span><br><span class=\"line\">        ├── 买油翁.txt</span><br><span class=\"line\">        ├── 孙权劝学.txt</span><br><span class=\"line\">        └── 木兰诗.txt</span><br></pre></td></tr></table></figure>\n\n<h2 id=\"开始使用\"><a href=\"#开始使用\" class=\"headerlink\" title=\"开始使用\"></a>开始使用</h2><h3 id=\"安装\"><a href=\"#安装\" class=\"headerlink\" title=\"安装\"></a>安装</h3><p>使用以下方法安装 ReciteHelper：</p>\n<ol>\n<li>克隆 ReciteHelper 仓库：</li>\n</ol>\n<figure class=\"highlight sh\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">git <span class=\"built_in\">clone</span> https://github.com/tkzzzzzz6/ReciteHelper</span><br></pre></td></tr></table></figure>\n\n<ol start=\"2\">\n<li>进入项目目录：</li>\n</ol>\n<figure class=\"highlight sh\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"built_in\">cd</span> ReciteHelper</span><br></pre></td></tr></table></figure>\n\n<ol start=\"3\">\n<li>配置环境</li>\n</ol>\n<p>推荐使用 conda 虚拟环境：</p>\n<figure class=\"highlight sh\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">conda create -n beisong python=3.10 -y</span><br><span class=\"line\">conda activate beisong</span><br><span class=\"line\">pip install -r requirements.txt</span><br></pre></td></tr></table></figure>\n\n<ol start=\"4\">\n<li>配置API密钥</li>\n</ol>\n<ul>\n<li>前往百度AI控制台 创建应用</li>\n<li>获取 API Key 和 Secret Key</li>\n<li>修改 config.py 文件：</li>\n</ul>\n<figure class=\"highlight sh\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">#语音识别配置</span></span><br><span class=\"line\">APP_ID = <span class=\"string\">&#x27;你的APP ID&#x27;</span>      <span class=\"comment\"># 应用ID</span></span><br><span class=\"line\">API_KEY = <span class=\"string\">&#x27;你的API Key&#x27;</span>    <span class=\"comment\"># API Key</span></span><br><span class=\"line\">SECRET_KEY = <span class=\"string\">&#x27;你的API Key&#x27;</span>    <span class=\"comment\"># API Key</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">#百度NLP配置</span></span><br><span class=\"line\">NLP_APP_ID = <span class=\"string\">&#x27;你的APP ID&#x27;</span> </span><br><span class=\"line\">NLP_API_KEY = <span class=\"string\">&#x27;你的API Key&#x27;</span>    <span class=\"comment\"># API Key</span></span><br><span class=\"line\">NLP_SECRET_KEY = <span class=\"string\">&#x27;你的API Key&#x27;</span>    <span class=\"comment\"># API Key</span></span><br></pre></td></tr></table></figure>\n\n<ol start=\"5\">\n<li>添加背诵文本</li>\n</ol>\n<p>将文言文文本保存为 txt 文件，放置于 &#x2F;texts 目录下（程序已内置《孙权劝学》《卖油翁》《木兰诗》示例文本）</p>\n<ol start=\"6\">\n<li>运行程序</li>\n</ol>\n<figure class=\"highlight sh\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">python main.py</span><br></pre></td></tr></table></figure>\n","excerpt":"","more":"<h2 id=\"目录\"><a href=\"#目录\" class=\"headerlink\" title=\"目录\"></a>目录</h2><ul>\n<li><a href=\"#-%E6%A6%82%E8%BF%B0\">概述</a></li>\n<li><a href=\"#-%E9%A1%B9%E7%9B%AE%E7%BB%93%E6%9E%84\">项目结构</a><ul>\n<li><a href=\"#-%E9%A1%B9%E7%9B%AE%E7%B4%A2%E5%BC%95\">项目索引</a></li>\n</ul>\n</li>\n<li><a href=\"#-%E5%BC%80%E5%A7%8B%E4%BD%BF%E7%94%A8\">开始使用</a><ul>\n<li><a href=\"#-%E5%89%8D%E6%8F%90%E6%9D%A1%E4%BB%B6\">前提条件</a></li>\n<li><a href=\"#-%E5%AE%89%E8%A3%85\">安装</a></li>\n</ul>\n</li>\n</ul>\n<h2 id=\"概述\"><a href=\"#概述\" class=\"headerlink\" title=\"概述\"></a>概述</h2><p>今天在侄儿子要求在我这里背书的时候,有点嫌麻烦,想用程序识别和检测他的背诵,在网上查找相关软件和网站发现只有一个滑板车背诵的软件效果还不错,但是还是感觉这个产业不太成熟,于是自己用ai基于百度AI接口开发了此背诵检测程序，实现以下功能：</p>\n<ul>\n<li>语音转文本：实时录制背诵音频并转换为文字</li>\n<li>相似度对比：通过自然语言处理（NLP）比对背诵内容与原文</li>\n<li>准确率评分：输出整体匹配度和逐句差异分析<br>支持导入自定义文言文文本文件</li>\n</ul>\n<blockquote>\n<p>注意:<code>&lt;br&gt;</code><br>需提前申请百度语音API 和百度NPL API <code>&lt;br&gt;</code><br>目前识别效果和响应时间并不理想,需要一次性一句话一句话背诵</p>\n</blockquote>\n<h3 id=\"项目原理\"><a href=\"#项目原理\" class=\"headerlink\" title=\"项目原理\"></a>项目原理</h3><p>本程序基于Python开发，主要利用百度AI开放平台的语音识别和自然语言处理（NLP）技术，实现文言文背诵的自动检测。以下是程序的核心技术原理：</p>\n<ol>\n<li>语音转文本（语音识别）</li>\n</ol>\n<ul>\n<li>技术原理：<ul>\n<li>使用百度AI的语音识别API，将用户背诵的语音实时转换为文本。</li>\n<li>语音识别通过声学模型和语言模型，将音频信号转换为文字。声学模型负责将语音信号转换为音素，语言模型则根据上下文和语法生成最可能的文本结果。</li>\n<li>本程序采用百度AI的asr接口，支持实时语音识别，能够处理流式音频数据。</li>\n</ul>\n</li>\n<li>实现步骤：<ol>\n<li>音频采集：通过麦克风采集用户的语音，并将其转换为音频数据流。</li>\n<li>音频预处理：对音频数据进行降噪、归一化等预处理操作，提高识别准确率。</li>\n<li>语音识别：将预处理后的音频数据发送到百度AI语音识别API，获取识别结果。</li>\n<li>结果处理：对识别结果进行后处理，如去除多余空格、标点符号等。</li>\n</ol>\n</li>\n</ul>\n<ol start=\"2\">\n<li>文本相似度分析（自然语言处理）</li>\n</ol>\n<ul>\n<li>技术原理：<ul>\n<li>使用百度AI的自然语言处理（NLP）技术，对背诵文本和原文进行相似度分析。</li>\n<li>相似度分析通过计算两个文本的语义相似度，判断背诵内容是否与原文一致。</li>\n<li>本程序采用百度AI的simnet接口，基于深度学习模型，能够准确计算文本之间的语义相似度。</li>\n</ul>\n</li>\n<li>实现步骤：<ol>\n<li>文本分句：将背诵文本和原文按句子分割，提取每个句子的文本内容。</li>\n<li>相似度计算：对每个句子的背诵文本和原文进行相似度计算，获取相似度分数。</li>\n<li>结果评估：根据相似度分数，判断背诵内容的准确性和完整性。</li>\n</ol>\n</li>\n</ul>\n<ol start=\"3\">\n<li>准确率评分</li>\n</ol>\n<ul>\n<li>技术原理：<ul>\n<li>通过对比背诵文本和原文的相似度，计算整体匹配度和逐句差异分析。</li>\n<li>使用difflib库的SequenceMatcher类，计算两个文本的相似度分数。</li>\n<li>结合百度AI的语义相似度分析结果，生成最终的准确率评分。</li>\n</ul>\n</li>\n<li>实现步骤：<ol>\n<li>逐句对比：对每个句子的背诵文本和原文进行逐句对比，计算相似度分数。</li>\n<li>整体评分：根据逐句相似度分数，计算整体匹配度。</li>\n<li>差异分析：生成逐句差异分析报告，显示每句话的相似度分数和差异部分。</li>\n</ol>\n</li>\n</ul>\n<ol start=\"4\">\n<li>实时反馈与进度显示</li>\n</ol>\n<ul>\n<li>技术原理：<ul>\n<li>使用Tkinter库创建图形用户界面（GUI），实时显示背诵进度和识别结果。</li>\n<li>通过多线程技术，实现语音识别、文本处理和UI更新的并行处理，确保程序的实时性和流畅性。</li>\n<li>使用进度条和计时器，显示背诵进度和剩余时间，帮助用户更好地掌握背诵节奏。</li>\n</ul>\n</li>\n<li>实现步骤：<ol>\n<li>UI设计：设计背诵界面，包括原文显示、识别结果显示、进度条和计时器等。</li>\n<li>多线程处理：创建多个线程，分别处理音频采集、语音识别、文本处理和UI更新。</li>\n<li>实时更新：根据识别结果和相似度分析，实时更新识别结果显示和进度条。</li>\n</ol>\n</li>\n</ul>\n<h2 id=\"项目结构\"><a href=\"#项目结构\" class=\"headerlink\" title=\"项目结构\"></a>项目结构</h2><figure class=\"highlight sh\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">└── ReciteHelper/</span><br><span class=\"line\">    ├── Dockerfile</span><br><span class=\"line\">    ├── README.md</span><br><span class=\"line\">    ├── config.py</span><br><span class=\"line\">    ├── main.py</span><br><span class=\"line\">    ├── requirements.txt</span><br><span class=\"line\">    └── texts</span><br><span class=\"line\">        ├── 买油翁.txt</span><br><span class=\"line\">        ├── 孙权劝学.txt</span><br><span class=\"line\">        └── 木兰诗.txt</span><br></pre></td></tr></table></figure>\n\n<h2 id=\"开始使用\"><a href=\"#开始使用\" class=\"headerlink\" title=\"开始使用\"></a>开始使用</h2><h3 id=\"安装\"><a href=\"#安装\" class=\"headerlink\" title=\"安装\"></a>安装</h3><p>使用以下方法安装 ReciteHelper：</p>\n<ol>\n<li>克隆 ReciteHelper 仓库：</li>\n</ol>\n<figure class=\"highlight sh\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">git <span class=\"built_in\">clone</span> https://github.com/tkzzzzzz6/ReciteHelper</span><br></pre></td></tr></table></figure>\n\n<ol start=\"2\">\n<li>进入项目目录：</li>\n</ol>\n<figure class=\"highlight sh\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"built_in\">cd</span> ReciteHelper</span><br></pre></td></tr></table></figure>\n\n<ol start=\"3\">\n<li>配置环境</li>\n</ol>\n<p>推荐使用 conda 虚拟环境：</p>\n<figure class=\"highlight sh\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">conda create -n beisong python=3.10 -y</span><br><span class=\"line\">conda activate beisong</span><br><span class=\"line\">pip install -r requirements.txt</span><br></pre></td></tr></table></figure>\n\n<ol start=\"4\">\n<li>配置API密钥</li>\n</ol>\n<ul>\n<li>前往百度AI控制台 创建应用</li>\n<li>获取 API Key 和 Secret Key</li>\n<li>修改 config.py 文件：</li>\n</ul>\n<figure class=\"highlight sh\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">#语音识别配置</span></span><br><span class=\"line\">APP_ID = <span class=\"string\">&#x27;你的APP ID&#x27;</span>      <span class=\"comment\"># 应用ID</span></span><br><span class=\"line\">API_KEY = <span class=\"string\">&#x27;你的API Key&#x27;</span>    <span class=\"comment\"># API Key</span></span><br><span class=\"line\">SECRET_KEY = <span class=\"string\">&#x27;你的API Key&#x27;</span>    <span class=\"comment\"># API Key</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">#百度NLP配置</span></span><br><span class=\"line\">NLP_APP_ID = <span class=\"string\">&#x27;你的APP ID&#x27;</span> </span><br><span class=\"line\">NLP_API_KEY = <span class=\"string\">&#x27;你的API Key&#x27;</span>    <span class=\"comment\"># API Key</span></span><br><span class=\"line\">NLP_SECRET_KEY = <span class=\"string\">&#x27;你的API Key&#x27;</span>    <span class=\"comment\"># API Key</span></span><br></pre></td></tr></table></figure>\n\n<ol start=\"5\">\n<li>添加背诵文本</li>\n</ol>\n<p>将文言文文本保存为 txt 文件，放置于 &#x2F;texts 目录下（程序已内置《孙权劝学》《卖油翁》《木兰诗》示例文本）</p>\n<ol start=\"6\">\n<li>运行程序</li>\n</ol>\n<figure class=\"highlight sh\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">python main.py</span><br></pre></td></tr></table></figure>\n"},{"title":"语义分割、实例分割与全景分割三种分割技术的对比","date":"2025-02-16T16:00:00.000Z","_content":"\n# **三种分割技术的对比**\n\n语义分割、实例分割和全景分割是计算机视觉中三种重要的图像分割技术，各自有不同的任务目标、技术难点和应用场景。语义分割的目标是为图像中的每个像素分配一个类别标签，但不区分同一类别中的不同实例。它的技术难点在于需要精确的像素级分类，而对同一类别中的不同实例不进行区分。语义分割的主流方法包括 FCN、DeepLab 系列和 PSPNet，性能通常通过平均交并比（mIoU）来衡量。语义分割模型结构相对简单，适合大规模像素级分类任务，广泛应用于自动驾驶、医学影像分析和卫星图像处理等领域。\n\n实例分割则进一步要求为图像中的每个目标实例生成独立的分割掩码，并区分同一类别中的不同实例。它的技术难点在于需要同时处理目标检测和像素级分割，尤其是在处理小目标和密集目标时，对分割精度的要求更高。实例分割的主流方法包括 Mask R-CNN、SOLO 系列和 BlendMask，性能指标通常包括掩码平均精度（mask AP）和实例分割精度。实例分割能够精确区分同一类别中的不同实例，适用于复杂场景，如自动驾驶和医学影像分析。\n\n全景分割结合了语义分割和实例分割的优点，旨在同时处理“Things”（可数目标）和“Stuff”（不可数目标），为每个像素分配类别和实例 ID。全景分割的技术难点在于需要统一处理前景目标和背景区域，避免分割结果的重叠和遗漏。其主流方法包括 Mask2Former 和 Panoptic-DeepLab，性能通过全景质量（PQ）、分割质量（SQ）和识别质量（RQ）来衡量。全景分割提供了一种更全面的场景理解方式，适用于自动驾驶、机器人视觉和视频监控等需要完整场景理解的应用场景。\n\n随着技术的发展，Transformer 架构逐渐被引入到这些分割任务中，显著提升了模型的多尺度特征学习能力和整体性能。语义分割、实例分割和全景分割各有其独特的优势和应用场景，但在实际应用中，全景分割因其能够提供更完整的场景理解，逐渐成为研究和应用的热点方向。\n\n![17402355054491740235504618.png](https://tk-pichost-1325224430.cos.ap-chengdu.myqcloud.com/blog/17402355054491740235504618.png)\n\n<table>\n<tr>\n<td>技术<br/></td><td>方法简介<br/></td><td>关注点<br/></td></tr>\n<tr>\n<td>语义分割<br/></td><td>为图像中的每个像素分配特定类别标签。<br/></td><td>关注“stuff”部分<br/></td></tr>\n<tr>\n<td>实例分割<br/></td><td>在图像中检测并区分不同的物体实例。<br/></td><td>关注“things”部分<br/></td></tr>\n<tr>\n<td>全景分割<br/></td><td>结合语义分割和实例分割，为每个像素分配语义标签和实例标识符。<br/></td><td>同时关注“things”和“stuff”部分<br/></td></tr>\n</table>\n\n# **评价指标**\n\n<table>\n<tr>\n<td>分割类型<br/></td><td>评估指标<br/></td><td>描述<br/></td></tr>\n<tr>\n<td rowspan=\"4\">语义分割<br/></td><td>像素准确率（Pixel Accuracy）<br/></td><td>计算所有像素中被正确分类的比例<br/></td></tr>\n<tr>\n<td>平均交并比（MIoU）<br/></td><td>衡量预测分割与真实标注之间的重叠程度，是语义分割的核心指标<br/></td></tr>\n<tr>\n<td>Dice 系数（Dice Coefficient）<br/></td><td>衡量预测和真实分割的相似度，类似于 IoU<br/></td></tr>\n<tr>\n<td>召回率（Recall）和精确率（Precision）<br/></td><td>分别衡量模型对正样本的召回能力和预测正样本的准确性<br/></td></tr>\n<tr>\n<td rowspan=\"3\">实例分割<br/></td><td>平均精度均值（mAP）<br/></td><td>通过不同交并比（IoU）阈值下的平均精度来评估模型性能，是实例分割的核心指标<br/></td></tr>\n<tr>\n<td>平均交并比（MIoU）<br/></td><td>衡量预测实例与真实实例之间的重叠程度<br/></td></tr>\n<tr>\n<td>目标级别的精确率和召回率<br/></td><td>基于实例的 IoU 判断预测实例是否正确匹配真实实例<br/></td></tr>\n<tr>\n<td rowspan=\"3\">全景分割<br/></td><td>平均交并比（mIoU）<br/></td><td>用于评估语义分割部分的性能<br/></td></tr>\n<tr>\n<td>平均精度均值（mAP）<br/></td><td>用于评估实例分割部分的性能<br/></td></tr>\n<tr>\n<td>全景质量（Panoptic Quality, PQ）<br/></td><td>综合考虑语义分割的准确性和实例分割的完整性，是全景分割特有的评估指标<br/></td></tr>\n</table>\n\n这些指标各有侧重点，具体选择取决于任务需求和数据集特性。\n\n1. **MIoU（Mean Intersection over Union）**\n\nMIoU 是一种常用的语义分割模型评价指标，它通过计算预测结果和真实标签的交集与并集之间的比值来衡量模型性能。MIoU 的计算公式为：\n\n$$\n\\mathrm{MIoU}=\\frac1N\\sum_{i=1}^N\\frac{\\mathrm{TP}_i}{\\mathrm{TP}_i+\\mathrm{FP}_i+\\mathrm{FN}_i}\n$$\n\n其中 TP 表示真正例（True Positives），FP 表示假正例（False Positives），FN 表示假反例（False Negatives）。MIoU 能够综合考虑模型的像素级别预测准确度，对模型在处理不同类别、不同大小的目标时进行公平的评价。\n\n1. **IoU（Intersection over Union）**\n\nIoU 指标即交并比，是语义分割中常用的标准度量。它衡量的是预测结果与真实标签之间的交集与并集之比。IoU 的计算公式为：\n\n$$\n\\mathrm{IoU}=\\frac{\\mathrm{TP}}{\\mathrm{TP}+\\mathrm{FP}+\\mathrm{FN}}\n$$\n\n1. **Accuracy（准确率）**\n\n$$\n\\mathrm{Accuracy}=\\frac{\\mathrm{TP+TN}}{\\mathrm{TP+FP+FN+TN}}\n$$\n\n准确率是指预测正确的样本数量占全部样本的百分比。然而，当数据类别分布不平衡时，准确率可能无法准确评价模型的好坏。因此，在语义分割任务中，准确率通常与其他指标结合使用。\n\n1. **Precision（查准率,精确率）**\n\n$$\n\\text{Precision}=\\frac{\\mathrm{TP}}{\\mathrm{TP}+\\mathrm{FP}}\n$$\n\n查准率表示模型预测为正例的所有样本中，预测正确（真实标签为正）样本的占比。在语义分割中，查准率反映了模型对正样本的识别能力。\n\n1. **Recall（查全率,召回率）**\n\n$$\n\\mathrm{Recall}=\\frac{\\mathrm{TP}}{\\mathrm{TP}+\\mathrm{FN}}\n$$\n\n查全率表示所有真实标签为正的样本中，有多大百分比被模型预测出来。在语义分割任务中，查全率衡量了模型对正样本的覆盖程度。\n\n1. **F1-Score**\n\nF1-Score 是查准率和查全率的调和平均数，用于综合评估模型的性能。它的计算公式为：\n\n$$\n\\text{F1-Score}=2\\cdot\\frac{\\text{Precision}\\cdot\\text{Recall}}{\\text{Precision}+\\text{Recall}}\n$$\n\nF1-Score 的优点在于它综合考虑了精确度和召回率，使得模型在不平衡分类问题中的性能评估更为准确。在语义分割任务中，F1-Score 能够帮助我们了解模型在各类别上的综合表现。\n\n1. **像素准确率（Pixel Accuracy）**\n\n$$\n\\text{Pixel Accuracy}=\\frac{\\mathrm{TP+TN}}{\\text{Total Pixels}}\n$$\n\n像素准确率是指模型预测正确的像素数量占总像素数量的比例。它是一个简单的指标，用于衡量模型在像素级别上的整体分类准确性。然而，像素准确率对类别不平衡的数据集不够敏感，因此通常与其他指标结合使用。\n\n1. **平均精度均值（mAP）**\n\n$$\n\\mathrm{mAP}=\\frac1N\\sum_{i=1}^N\\mathrm{AP}_i\n$$\n\nmAP（Mean Average Precision）是一种广泛用于目标检测和实例分割任务的评价指标，也适用于全景分割。它通过计算不同类别上的平均精度（AP），并取这些值的平均值得到。mAP 综合考虑了模型的精确度（Precision）和召回率（Recall），能够更全面地评估模型在不同类别上的性能。\n\n1. **全景质量（Panoptic Quality, PQ）**\n\n全景质量（PQ）是专门为全景分割任务设计的评价指标，用于综合评估模型在处理“Things”（可数目标）和“Stuff”（不可数背景）时的性能。PQ 指标结合了分割质量（Segmentation Quality, SQ）和识别质量（Recognition Quality, RQ），并通过以下公式计算：\n\n其中，SQ 衡量分割掩码的准确性，RQ 衡量实例识别的准确性。\n\nPQ 指标还分为单类别 PQ 和多类别 PQ（mPQ）。在某些竞赛中，还会使用 mPQ+，即对所有图像和类别进行加权平均的 PQ，以避免因某些类别在某些图像中缺失而导致的统计偏差。\n\n> - **分割质量（Segmentation Quality, SQ）**\n>   SQ 衡量的是预测分割掩码与真实分割掩码之间的平均交并比（IoU）。具体来说，它反映了匹配成功的预测实例与真实实例之间的重叠程度。SQ 的计算公式为:\n>\n> $$\n> \\mathrm{SQ}=\\frac{\\sum_{(g_k,p_l)\\in\\mathrm{TP}}\\mathrm{IoU}(g_k,p_l)}{|\\mathrm{TP}|}\n> $$\n>\n> 其中，$gk$表示真实实例, $p_l$ 表示预测实例，TP 表示真正例（True Positives），即预测与真实实例匹配成功的对。\n>\n> - **识别质量（Recognition Quality, RQ）**\n>   RQ 衡量的是模型对目标实例的识别能力，类似于目标检测中的 F1 分数。它通过平衡精确率（Precision）和召回率（Recall）来评估模型对实例的识别效果。RQ 的计算公式为：\n>\n> $$\n> \\mathrm{RQ}=\\frac{|\\mathrm{TP}|}{|\\mathrm{TP}|+\\frac12|\\mathrm{FP}|+\\frac12|\\mathrm{FP}|+\\frac12|\\mathrm{FN}|}\n> $$\n>\n> 其中，FP 表示假正例（False Positives），FN 表示假反例（False Negatives）。\n\n- **SQ**：关注分割掩码的准确性，即预测掩码与真实掩码的重叠程度。\n- **RQ**：关注实例识别的准确性，类似于目标检测中的 F1 分数。\n- **PQ**：通过结合 SQ 和 RQ，提供了一个综合评估全景分割模型性能的指标。\n\n# **总结**\n\n语义分割、实例分割和全景分割是深度学习在图像分割领域的三大重要技术。语义分割专注于像素级分类，能够识别图像中不同类别的物体，但无法区分同一类别中的不同实例，因此在某些场景中需要结合实例分割来进一步划分同类别的不同实例。实例分割则专注于目标实例的区分，能够将同一类别中的不同物体单独识别出来。全景分割则结合了语义分割和实例分割的优点，能够同时提供像素级分类和实例区分，从而实现更全面的场景理解。\n\n# 其他资源\n\n| 分类   | 链接                                                                 |\n|--------|----------------------------------------------------------------------|\n| 项目   | [bubbliiing/unet-pytorch](https://github.com/bubbliiing/unet-pytorch) |\n| 项目   | [bubbliiing/pspnet-pytorch](https://github.com/bubbliiing/pspnet-pytorch) |\n| 项目   | [https://github.com/ultralytics/ultralytics](https://github.com/ultralytics/ultralytics) |\n| 项目   | [bonlime/keras-deeplab-v3-plus](https://github.com/bonlime/keras-deeplab-v3-plus) |\n| 项目   | [https://www.codewithgpu.com/i/bubbliiing/unet-pytorch/UNet-PyTorch](https://www.codewithgpu.com/i/bubbliiing/unet-pytorch/UNet-PyTorch) |\n| 博客   | [https://zhuanlan.zhihu.com/p/303355997](https://zhuanlan.zhihu.com/p/303355997) |\n| 数据集 | [bubble - v1 2025-01-23 12:27pm](https://app.roboflow.com/project-p0vpn/bubble-mclkq/1) |\n| 工具   | [https://huggingface.co/spaces](https://huggingface.co/spaces)       |\n| 工具   | [GitHub Proxy 代理加速](https://ghfast.top/)                                              |\n| 工具   | [https://hf-mirror.com/](https://hf-mirror.com/)                     |\n| 工具   | [AutoDL算力云](https://www.autodl.com/) | \n\n希望这对你有帮助！","source":"_posts/2025-02-17-语义分割、实例分割与全景分割三种分割技术的对比.md","raw":"---\ntitle: 语义分割、实例分割与全景分割三种分割技术的对比\ndate: 2025-02-17\ntags: 深度学习\n---\n\n# **三种分割技术的对比**\n\n语义分割、实例分割和全景分割是计算机视觉中三种重要的图像分割技术，各自有不同的任务目标、技术难点和应用场景。语义分割的目标是为图像中的每个像素分配一个类别标签，但不区分同一类别中的不同实例。它的技术难点在于需要精确的像素级分类，而对同一类别中的不同实例不进行区分。语义分割的主流方法包括 FCN、DeepLab 系列和 PSPNet，性能通常通过平均交并比（mIoU）来衡量。语义分割模型结构相对简单，适合大规模像素级分类任务，广泛应用于自动驾驶、医学影像分析和卫星图像处理等领域。\n\n实例分割则进一步要求为图像中的每个目标实例生成独立的分割掩码，并区分同一类别中的不同实例。它的技术难点在于需要同时处理目标检测和像素级分割，尤其是在处理小目标和密集目标时，对分割精度的要求更高。实例分割的主流方法包括 Mask R-CNN、SOLO 系列和 BlendMask，性能指标通常包括掩码平均精度（mask AP）和实例分割精度。实例分割能够精确区分同一类别中的不同实例，适用于复杂场景，如自动驾驶和医学影像分析。\n\n全景分割结合了语义分割和实例分割的优点，旨在同时处理“Things”（可数目标）和“Stuff”（不可数目标），为每个像素分配类别和实例 ID。全景分割的技术难点在于需要统一处理前景目标和背景区域，避免分割结果的重叠和遗漏。其主流方法包括 Mask2Former 和 Panoptic-DeepLab，性能通过全景质量（PQ）、分割质量（SQ）和识别质量（RQ）来衡量。全景分割提供了一种更全面的场景理解方式，适用于自动驾驶、机器人视觉和视频监控等需要完整场景理解的应用场景。\n\n随着技术的发展，Transformer 架构逐渐被引入到这些分割任务中，显著提升了模型的多尺度特征学习能力和整体性能。语义分割、实例分割和全景分割各有其独特的优势和应用场景，但在实际应用中，全景分割因其能够提供更完整的场景理解，逐渐成为研究和应用的热点方向。\n\n![17402355054491740235504618.png](https://tk-pichost-1325224430.cos.ap-chengdu.myqcloud.com/blog/17402355054491740235504618.png)\n\n<table>\n<tr>\n<td>技术<br/></td><td>方法简介<br/></td><td>关注点<br/></td></tr>\n<tr>\n<td>语义分割<br/></td><td>为图像中的每个像素分配特定类别标签。<br/></td><td>关注“stuff”部分<br/></td></tr>\n<tr>\n<td>实例分割<br/></td><td>在图像中检测并区分不同的物体实例。<br/></td><td>关注“things”部分<br/></td></tr>\n<tr>\n<td>全景分割<br/></td><td>结合语义分割和实例分割，为每个像素分配语义标签和实例标识符。<br/></td><td>同时关注“things”和“stuff”部分<br/></td></tr>\n</table>\n\n# **评价指标**\n\n<table>\n<tr>\n<td>分割类型<br/></td><td>评估指标<br/></td><td>描述<br/></td></tr>\n<tr>\n<td rowspan=\"4\">语义分割<br/></td><td>像素准确率（Pixel Accuracy）<br/></td><td>计算所有像素中被正确分类的比例<br/></td></tr>\n<tr>\n<td>平均交并比（MIoU）<br/></td><td>衡量预测分割与真实标注之间的重叠程度，是语义分割的核心指标<br/></td></tr>\n<tr>\n<td>Dice 系数（Dice Coefficient）<br/></td><td>衡量预测和真实分割的相似度，类似于 IoU<br/></td></tr>\n<tr>\n<td>召回率（Recall）和精确率（Precision）<br/></td><td>分别衡量模型对正样本的召回能力和预测正样本的准确性<br/></td></tr>\n<tr>\n<td rowspan=\"3\">实例分割<br/></td><td>平均精度均值（mAP）<br/></td><td>通过不同交并比（IoU）阈值下的平均精度来评估模型性能，是实例分割的核心指标<br/></td></tr>\n<tr>\n<td>平均交并比（MIoU）<br/></td><td>衡量预测实例与真实实例之间的重叠程度<br/></td></tr>\n<tr>\n<td>目标级别的精确率和召回率<br/></td><td>基于实例的 IoU 判断预测实例是否正确匹配真实实例<br/></td></tr>\n<tr>\n<td rowspan=\"3\">全景分割<br/></td><td>平均交并比（mIoU）<br/></td><td>用于评估语义分割部分的性能<br/></td></tr>\n<tr>\n<td>平均精度均值（mAP）<br/></td><td>用于评估实例分割部分的性能<br/></td></tr>\n<tr>\n<td>全景质量（Panoptic Quality, PQ）<br/></td><td>综合考虑语义分割的准确性和实例分割的完整性，是全景分割特有的评估指标<br/></td></tr>\n</table>\n\n这些指标各有侧重点，具体选择取决于任务需求和数据集特性。\n\n1. **MIoU（Mean Intersection over Union）**\n\nMIoU 是一种常用的语义分割模型评价指标，它通过计算预测结果和真实标签的交集与并集之间的比值来衡量模型性能。MIoU 的计算公式为：\n\n$$\n\\mathrm{MIoU}=\\frac1N\\sum_{i=1}^N\\frac{\\mathrm{TP}_i}{\\mathrm{TP}_i+\\mathrm{FP}_i+\\mathrm{FN}_i}\n$$\n\n其中 TP 表示真正例（True Positives），FP 表示假正例（False Positives），FN 表示假反例（False Negatives）。MIoU 能够综合考虑模型的像素级别预测准确度，对模型在处理不同类别、不同大小的目标时进行公平的评价。\n\n1. **IoU（Intersection over Union）**\n\nIoU 指标即交并比，是语义分割中常用的标准度量。它衡量的是预测结果与真实标签之间的交集与并集之比。IoU 的计算公式为：\n\n$$\n\\mathrm{IoU}=\\frac{\\mathrm{TP}}{\\mathrm{TP}+\\mathrm{FP}+\\mathrm{FN}}\n$$\n\n1. **Accuracy（准确率）**\n\n$$\n\\mathrm{Accuracy}=\\frac{\\mathrm{TP+TN}}{\\mathrm{TP+FP+FN+TN}}\n$$\n\n准确率是指预测正确的样本数量占全部样本的百分比。然而，当数据类别分布不平衡时，准确率可能无法准确评价模型的好坏。因此，在语义分割任务中，准确率通常与其他指标结合使用。\n\n1. **Precision（查准率,精确率）**\n\n$$\n\\text{Precision}=\\frac{\\mathrm{TP}}{\\mathrm{TP}+\\mathrm{FP}}\n$$\n\n查准率表示模型预测为正例的所有样本中，预测正确（真实标签为正）样本的占比。在语义分割中，查准率反映了模型对正样本的识别能力。\n\n1. **Recall（查全率,召回率）**\n\n$$\n\\mathrm{Recall}=\\frac{\\mathrm{TP}}{\\mathrm{TP}+\\mathrm{FN}}\n$$\n\n查全率表示所有真实标签为正的样本中，有多大百分比被模型预测出来。在语义分割任务中，查全率衡量了模型对正样本的覆盖程度。\n\n1. **F1-Score**\n\nF1-Score 是查准率和查全率的调和平均数，用于综合评估模型的性能。它的计算公式为：\n\n$$\n\\text{F1-Score}=2\\cdot\\frac{\\text{Precision}\\cdot\\text{Recall}}{\\text{Precision}+\\text{Recall}}\n$$\n\nF1-Score 的优点在于它综合考虑了精确度和召回率，使得模型在不平衡分类问题中的性能评估更为准确。在语义分割任务中，F1-Score 能够帮助我们了解模型在各类别上的综合表现。\n\n1. **像素准确率（Pixel Accuracy）**\n\n$$\n\\text{Pixel Accuracy}=\\frac{\\mathrm{TP+TN}}{\\text{Total Pixels}}\n$$\n\n像素准确率是指模型预测正确的像素数量占总像素数量的比例。它是一个简单的指标，用于衡量模型在像素级别上的整体分类准确性。然而，像素准确率对类别不平衡的数据集不够敏感，因此通常与其他指标结合使用。\n\n1. **平均精度均值（mAP）**\n\n$$\n\\mathrm{mAP}=\\frac1N\\sum_{i=1}^N\\mathrm{AP}_i\n$$\n\nmAP（Mean Average Precision）是一种广泛用于目标检测和实例分割任务的评价指标，也适用于全景分割。它通过计算不同类别上的平均精度（AP），并取这些值的平均值得到。mAP 综合考虑了模型的精确度（Precision）和召回率（Recall），能够更全面地评估模型在不同类别上的性能。\n\n1. **全景质量（Panoptic Quality, PQ）**\n\n全景质量（PQ）是专门为全景分割任务设计的评价指标，用于综合评估模型在处理“Things”（可数目标）和“Stuff”（不可数背景）时的性能。PQ 指标结合了分割质量（Segmentation Quality, SQ）和识别质量（Recognition Quality, RQ），并通过以下公式计算：\n\n其中，SQ 衡量分割掩码的准确性，RQ 衡量实例识别的准确性。\n\nPQ 指标还分为单类别 PQ 和多类别 PQ（mPQ）。在某些竞赛中，还会使用 mPQ+，即对所有图像和类别进行加权平均的 PQ，以避免因某些类别在某些图像中缺失而导致的统计偏差。\n\n> - **分割质量（Segmentation Quality, SQ）**\n>   SQ 衡量的是预测分割掩码与真实分割掩码之间的平均交并比（IoU）。具体来说，它反映了匹配成功的预测实例与真实实例之间的重叠程度。SQ 的计算公式为:\n>\n> $$\n> \\mathrm{SQ}=\\frac{\\sum_{(g_k,p_l)\\in\\mathrm{TP}}\\mathrm{IoU}(g_k,p_l)}{|\\mathrm{TP}|}\n> $$\n>\n> 其中，$gk$表示真实实例, $p_l$ 表示预测实例，TP 表示真正例（True Positives），即预测与真实实例匹配成功的对。\n>\n> - **识别质量（Recognition Quality, RQ）**\n>   RQ 衡量的是模型对目标实例的识别能力，类似于目标检测中的 F1 分数。它通过平衡精确率（Precision）和召回率（Recall）来评估模型对实例的识别效果。RQ 的计算公式为：\n>\n> $$\n> \\mathrm{RQ}=\\frac{|\\mathrm{TP}|}{|\\mathrm{TP}|+\\frac12|\\mathrm{FP}|+\\frac12|\\mathrm{FP}|+\\frac12|\\mathrm{FN}|}\n> $$\n>\n> 其中，FP 表示假正例（False Positives），FN 表示假反例（False Negatives）。\n\n- **SQ**：关注分割掩码的准确性，即预测掩码与真实掩码的重叠程度。\n- **RQ**：关注实例识别的准确性，类似于目标检测中的 F1 分数。\n- **PQ**：通过结合 SQ 和 RQ，提供了一个综合评估全景分割模型性能的指标。\n\n# **总结**\n\n语义分割、实例分割和全景分割是深度学习在图像分割领域的三大重要技术。语义分割专注于像素级分类，能够识别图像中不同类别的物体，但无法区分同一类别中的不同实例，因此在某些场景中需要结合实例分割来进一步划分同类别的不同实例。实例分割则专注于目标实例的区分，能够将同一类别中的不同物体单独识别出来。全景分割则结合了语义分割和实例分割的优点，能够同时提供像素级分类和实例区分，从而实现更全面的场景理解。\n\n# 其他资源\n\n| 分类   | 链接                                                                 |\n|--------|----------------------------------------------------------------------|\n| 项目   | [bubbliiing/unet-pytorch](https://github.com/bubbliiing/unet-pytorch) |\n| 项目   | [bubbliiing/pspnet-pytorch](https://github.com/bubbliiing/pspnet-pytorch) |\n| 项目   | [https://github.com/ultralytics/ultralytics](https://github.com/ultralytics/ultralytics) |\n| 项目   | [bonlime/keras-deeplab-v3-plus](https://github.com/bonlime/keras-deeplab-v3-plus) |\n| 项目   | [https://www.codewithgpu.com/i/bubbliiing/unet-pytorch/UNet-PyTorch](https://www.codewithgpu.com/i/bubbliiing/unet-pytorch/UNet-PyTorch) |\n| 博客   | [https://zhuanlan.zhihu.com/p/303355997](https://zhuanlan.zhihu.com/p/303355997) |\n| 数据集 | [bubble - v1 2025-01-23 12:27pm](https://app.roboflow.com/project-p0vpn/bubble-mclkq/1) |\n| 工具   | [https://huggingface.co/spaces](https://huggingface.co/spaces)       |\n| 工具   | [GitHub Proxy 代理加速](https://ghfast.top/)                                              |\n| 工具   | [https://hf-mirror.com/](https://hf-mirror.com/)                     |\n| 工具   | [AutoDL算力云](https://www.autodl.com/) | \n\n希望这对你有帮助！","slug":"2025-02-17-语义分割、实例分割与全景分割三种分割技术的对比","published":1,"updated":"2025-09-26T12:15:25.024Z","_id":"cmg0saj3s0007jm8n2trg9ka4","comments":1,"layout":"post","photos":[],"content":"<h1 id=\"三种分割技术的对比\"><a href=\"#三种分割技术的对比\" class=\"headerlink\" title=\"三种分割技术的对比\"></a><strong>三种分割技术的对比</strong></h1><p>语义分割、实例分割和全景分割是计算机视觉中三种重要的图像分割技术，各自有不同的任务目标、技术难点和应用场景。语义分割的目标是为图像中的每个像素分配一个类别标签，但不区分同一类别中的不同实例。它的技术难点在于需要精确的像素级分类，而对同一类别中的不同实例不进行区分。语义分割的主流方法包括 FCN、DeepLab 系列和 PSPNet，性能通常通过平均交并比（mIoU）来衡量。语义分割模型结构相对简单，适合大规模像素级分类任务，广泛应用于自动驾驶、医学影像分析和卫星图像处理等领域。</p>\n<p>实例分割则进一步要求为图像中的每个目标实例生成独立的分割掩码，并区分同一类别中的不同实例。它的技术难点在于需要同时处理目标检测和像素级分割，尤其是在处理小目标和密集目标时，对分割精度的要求更高。实例分割的主流方法包括 Mask R-CNN、SOLO 系列和 BlendMask，性能指标通常包括掩码平均精度（mask AP）和实例分割精度。实例分割能够精确区分同一类别中的不同实例，适用于复杂场景，如自动驾驶和医学影像分析。</p>\n<p>全景分割结合了语义分割和实例分割的优点，旨在同时处理“Things”（可数目标）和“Stuff”（不可数目标），为每个像素分配类别和实例 ID。全景分割的技术难点在于需要统一处理前景目标和背景区域，避免分割结果的重叠和遗漏。其主流方法包括 Mask2Former 和 Panoptic-DeepLab，性能通过全景质量（PQ）、分割质量（SQ）和识别质量（RQ）来衡量。全景分割提供了一种更全面的场景理解方式，适用于自动驾驶、机器人视觉和视频监控等需要完整场景理解的应用场景。</p>\n<p>随着技术的发展，Transformer 架构逐渐被引入到这些分割任务中，显著提升了模型的多尺度特征学习能力和整体性能。语义分割、实例分割和全景分割各有其独特的优势和应用场景，但在实际应用中，全景分割因其能够提供更完整的场景理解，逐渐成为研究和应用的热点方向。</p>\n<p><img src=\"https://tk-pichost-1325224430.cos.ap-chengdu.myqcloud.com/blog/17402355054491740235504618.png\" alt=\"17402355054491740235504618.png\"></p>\n<table>\n<tr>\n<td>技术<br/></td><td>方法简介<br/></td><td>关注点<br/></td></tr>\n<tr>\n<td>语义分割<br/></td><td>为图像中的每个像素分配特定类别标签。<br/></td><td>关注“stuff”部分<br/></td></tr>\n<tr>\n<td>实例分割<br/></td><td>在图像中检测并区分不同的物体实例。<br/></td><td>关注“things”部分<br/></td></tr>\n<tr>\n<td>全景分割<br/></td><td>结合语义分割和实例分割，为每个像素分配语义标签和实例标识符。<br/></td><td>同时关注“things”和“stuff”部分<br/></td></tr>\n</table>\n\n<h1 id=\"评价指标\"><a href=\"#评价指标\" class=\"headerlink\" title=\"评价指标\"></a><strong>评价指标</strong></h1><table>\n<tr>\n<td>分割类型<br/></td><td>评估指标<br/></td><td>描述<br/></td></tr>\n<tr>\n<td rowspan=\"4\">语义分割<br/></td><td>像素准确率（Pixel Accuracy）<br/></td><td>计算所有像素中被正确分类的比例<br/></td></tr>\n<tr>\n<td>平均交并比（MIoU）<br/></td><td>衡量预测分割与真实标注之间的重叠程度，是语义分割的核心指标<br/></td></tr>\n<tr>\n<td>Dice 系数（Dice Coefficient）<br/></td><td>衡量预测和真实分割的相似度，类似于 IoU<br/></td></tr>\n<tr>\n<td>召回率（Recall）和精确率（Precision）<br/></td><td>分别衡量模型对正样本的召回能力和预测正样本的准确性<br/></td></tr>\n<tr>\n<td rowspan=\"3\">实例分割<br/></td><td>平均精度均值（mAP）<br/></td><td>通过不同交并比（IoU）阈值下的平均精度来评估模型性能，是实例分割的核心指标<br/></td></tr>\n<tr>\n<td>平均交并比（MIoU）<br/></td><td>衡量预测实例与真实实例之间的重叠程度<br/></td></tr>\n<tr>\n<td>目标级别的精确率和召回率<br/></td><td>基于实例的 IoU 判断预测实例是否正确匹配真实实例<br/></td></tr>\n<tr>\n<td rowspan=\"3\">全景分割<br/></td><td>平均交并比（mIoU）<br/></td><td>用于评估语义分割部分的性能<br/></td></tr>\n<tr>\n<td>平均精度均值（mAP）<br/></td><td>用于评估实例分割部分的性能<br/></td></tr>\n<tr>\n<td>全景质量（Panoptic Quality, PQ）<br/></td><td>综合考虑语义分割的准确性和实例分割的完整性，是全景分割特有的评估指标<br/></td></tr>\n</table>\n\n<p>这些指标各有侧重点，具体选择取决于任务需求和数据集特性。</p>\n<ol>\n<li><strong>MIoU（Mean Intersection over Union）</strong></li>\n</ol>\n<p>MIoU 是一种常用的语义分割模型评价指标，它通过计算预测结果和真实标签的交集与并集之间的比值来衡量模型性能。MIoU 的计算公式为：</p>\n<p>$$<br>\\mathrm{MIoU}&#x3D;\\frac1N\\sum_{i&#x3D;1}^N\\frac{\\mathrm{TP}_i}{\\mathrm{TP}_i+\\mathrm{FP}_i+\\mathrm{FN}_i}<br>$$</p>\n<p>其中 TP 表示真正例（True Positives），FP 表示假正例（False Positives），FN 表示假反例（False Negatives）。MIoU 能够综合考虑模型的像素级别预测准确度，对模型在处理不同类别、不同大小的目标时进行公平的评价。</p>\n<ol>\n<li><strong>IoU（Intersection over Union）</strong></li>\n</ol>\n<p>IoU 指标即交并比，是语义分割中常用的标准度量。它衡量的是预测结果与真实标签之间的交集与并集之比。IoU 的计算公式为：</p>\n<p>$$<br>\\mathrm{IoU}&#x3D;\\frac{\\mathrm{TP}}{\\mathrm{TP}+\\mathrm{FP}+\\mathrm{FN}}<br>$$</p>\n<ol>\n<li><strong>Accuracy（准确率）</strong></li>\n</ol>\n<p>$$<br>\\mathrm{Accuracy}&#x3D;\\frac{\\mathrm{TP+TN}}{\\mathrm{TP+FP+FN+TN}}<br>$$</p>\n<p>准确率是指预测正确的样本数量占全部样本的百分比。然而，当数据类别分布不平衡时，准确率可能无法准确评价模型的好坏。因此，在语义分割任务中，准确率通常与其他指标结合使用。</p>\n<ol>\n<li><strong>Precision（查准率,精确率）</strong></li>\n</ol>\n<p>$$<br>\\text{Precision}&#x3D;\\frac{\\mathrm{TP}}{\\mathrm{TP}+\\mathrm{FP}}<br>$$</p>\n<p>查准率表示模型预测为正例的所有样本中，预测正确（真实标签为正）样本的占比。在语义分割中，查准率反映了模型对正样本的识别能力。</p>\n<ol>\n<li><strong>Recall（查全率,召回率）</strong></li>\n</ol>\n<p>$$<br>\\mathrm{Recall}&#x3D;\\frac{\\mathrm{TP}}{\\mathrm{TP}+\\mathrm{FN}}<br>$$</p>\n<p>查全率表示所有真实标签为正的样本中，有多大百分比被模型预测出来。在语义分割任务中，查全率衡量了模型对正样本的覆盖程度。</p>\n<ol>\n<li><strong>F1-Score</strong></li>\n</ol>\n<p>F1-Score 是查准率和查全率的调和平均数，用于综合评估模型的性能。它的计算公式为：</p>\n<p>$$<br>\\text{F1-Score}&#x3D;2\\cdot\\frac{\\text{Precision}\\cdot\\text{Recall}}{\\text{Precision}+\\text{Recall}}<br>$$</p>\n<p>F1-Score 的优点在于它综合考虑了精确度和召回率，使得模型在不平衡分类问题中的性能评估更为准确。在语义分割任务中，F1-Score 能够帮助我们了解模型在各类别上的综合表现。</p>\n<ol>\n<li><strong>像素准确率（Pixel Accuracy）</strong></li>\n</ol>\n<p>$$<br>\\text{Pixel Accuracy}&#x3D;\\frac{\\mathrm{TP+TN}}{\\text{Total Pixels}}<br>$$</p>\n<p>像素准确率是指模型预测正确的像素数量占总像素数量的比例。它是一个简单的指标，用于衡量模型在像素级别上的整体分类准确性。然而，像素准确率对类别不平衡的数据集不够敏感，因此通常与其他指标结合使用。</p>\n<ol>\n<li><strong>平均精度均值（mAP）</strong></li>\n</ol>\n<p>$$<br>\\mathrm{mAP}&#x3D;\\frac1N\\sum_{i&#x3D;1}^N\\mathrm{AP}_i<br>$$</p>\n<p>mAP（Mean Average Precision）是一种广泛用于目标检测和实例分割任务的评价指标，也适用于全景分割。它通过计算不同类别上的平均精度（AP），并取这些值的平均值得到。mAP 综合考虑了模型的精确度（Precision）和召回率（Recall），能够更全面地评估模型在不同类别上的性能。</p>\n<ol>\n<li><strong>全景质量（Panoptic Quality, PQ）</strong></li>\n</ol>\n<p>全景质量（PQ）是专门为全景分割任务设计的评价指标，用于综合评估模型在处理“Things”（可数目标）和“Stuff”（不可数背景）时的性能。PQ 指标结合了分割质量（Segmentation Quality, SQ）和识别质量（Recognition Quality, RQ），并通过以下公式计算：</p>\n<p>其中，SQ 衡量分割掩码的准确性，RQ 衡量实例识别的准确性。</p>\n<p>PQ 指标还分为单类别 PQ 和多类别 PQ（mPQ）。在某些竞赛中，还会使用 mPQ+，即对所有图像和类别进行加权平均的 PQ，以避免因某些类别在某些图像中缺失而导致的统计偏差。</p>\n<blockquote>\n<ul>\n<li><strong>分割质量（Segmentation Quality, SQ）</strong><br>SQ 衡量的是预测分割掩码与真实分割掩码之间的平均交并比（IoU）。具体来说，它反映了匹配成功的预测实例与真实实例之间的重叠程度。SQ 的计算公式为:</li>\n</ul>\n<p>$$<br>\\mathrm{SQ}&#x3D;\\frac{\\sum_{(g_k,p_l)\\in\\mathrm{TP}}\\mathrm{IoU}(g_k,p_l)}{|\\mathrm{TP}|}<br>$$</p>\n<p>其中，$gk$表示真实实例, $p_l$ 表示预测实例，TP 表示真正例（True Positives），即预测与真实实例匹配成功的对。</p>\n<ul>\n<li><strong>识别质量（Recognition Quality, RQ）</strong><br>RQ 衡量的是模型对目标实例的识别能力，类似于目标检测中的 F1 分数。它通过平衡精确率（Precision）和召回率（Recall）来评估模型对实例的识别效果。RQ 的计算公式为：</li>\n</ul>\n<p>$$<br>\\mathrm{RQ}&#x3D;\\frac{|\\mathrm{TP}|}{|\\mathrm{TP}|+\\frac12|\\mathrm{FP}|+\\frac12|\\mathrm{FP}|+\\frac12|\\mathrm{FN}|}<br>$$</p>\n<p>其中，FP 表示假正例（False Positives），FN 表示假反例（False Negatives）。</p>\n</blockquote>\n<ul>\n<li><strong>SQ</strong>：关注分割掩码的准确性，即预测掩码与真实掩码的重叠程度。</li>\n<li><strong>RQ</strong>：关注实例识别的准确性，类似于目标检测中的 F1 分数。</li>\n<li><strong>PQ</strong>：通过结合 SQ 和 RQ，提供了一个综合评估全景分割模型性能的指标。</li>\n</ul>\n<h1 id=\"总结\"><a href=\"#总结\" class=\"headerlink\" title=\"总结\"></a><strong>总结</strong></h1><p>语义分割、实例分割和全景分割是深度学习在图像分割领域的三大重要技术。语义分割专注于像素级分类，能够识别图像中不同类别的物体，但无法区分同一类别中的不同实例，因此在某些场景中需要结合实例分割来进一步划分同类别的不同实例。实例分割则专注于目标实例的区分，能够将同一类别中的不同物体单独识别出来。全景分割则结合了语义分割和实例分割的优点，能够同时提供像素级分类和实例区分，从而实现更全面的场景理解。</p>\n<h1 id=\"其他资源\"><a href=\"#其他资源\" class=\"headerlink\" title=\"其他资源\"></a>其他资源</h1><table>\n<thead>\n<tr>\n<th>分类</th>\n<th>链接</th>\n</tr>\n</thead>\n<tbody><tr>\n<td>项目</td>\n<td><a href=\"https://github.com/bubbliiing/unet-pytorch\">bubbliiing&#x2F;unet-pytorch</a></td>\n</tr>\n<tr>\n<td>项目</td>\n<td><a href=\"https://github.com/bubbliiing/pspnet-pytorch\">bubbliiing&#x2F;pspnet-pytorch</a></td>\n</tr>\n<tr>\n<td>项目</td>\n<td><a href=\"https://github.com/ultralytics/ultralytics\">https://github.com/ultralytics/ultralytics</a></td>\n</tr>\n<tr>\n<td>项目</td>\n<td><a href=\"https://github.com/bonlime/keras-deeplab-v3-plus\">bonlime&#x2F;keras-deeplab-v3-plus</a></td>\n</tr>\n<tr>\n<td>项目</td>\n<td><a href=\"https://www.codewithgpu.com/i/bubbliiing/unet-pytorch/UNet-PyTorch\">https://www.codewithgpu.com/i/bubbliiing/unet-pytorch/UNet-PyTorch</a></td>\n</tr>\n<tr>\n<td>博客</td>\n<td><a href=\"https://zhuanlan.zhihu.com/p/303355997\">https://zhuanlan.zhihu.com/p/303355997</a></td>\n</tr>\n<tr>\n<td>数据集</td>\n<td><a href=\"https://app.roboflow.com/project-p0vpn/bubble-mclkq/1\">bubble - v1 2025-01-23 12:27pm</a></td>\n</tr>\n<tr>\n<td>工具</td>\n<td><a href=\"https://huggingface.co/spaces\">https://huggingface.co/spaces</a></td>\n</tr>\n<tr>\n<td>工具</td>\n<td><a href=\"https://ghfast.top/\">GitHub Proxy 代理加速</a></td>\n</tr>\n<tr>\n<td>工具</td>\n<td><a href=\"https://hf-mirror.com/\">https://hf-mirror.com/</a></td>\n</tr>\n<tr>\n<td>工具</td>\n<td><a href=\"https://www.autodl.com/\">AutoDL算力云</a></td>\n</tr>\n</tbody></table>\n<p>希望这对你有帮助！</p>\n","excerpt":"","more":"<h1 id=\"三种分割技术的对比\"><a href=\"#三种分割技术的对比\" class=\"headerlink\" title=\"三种分割技术的对比\"></a><strong>三种分割技术的对比</strong></h1><p>语义分割、实例分割和全景分割是计算机视觉中三种重要的图像分割技术，各自有不同的任务目标、技术难点和应用场景。语义分割的目标是为图像中的每个像素分配一个类别标签，但不区分同一类别中的不同实例。它的技术难点在于需要精确的像素级分类，而对同一类别中的不同实例不进行区分。语义分割的主流方法包括 FCN、DeepLab 系列和 PSPNet，性能通常通过平均交并比（mIoU）来衡量。语义分割模型结构相对简单，适合大规模像素级分类任务，广泛应用于自动驾驶、医学影像分析和卫星图像处理等领域。</p>\n<p>实例分割则进一步要求为图像中的每个目标实例生成独立的分割掩码，并区分同一类别中的不同实例。它的技术难点在于需要同时处理目标检测和像素级分割，尤其是在处理小目标和密集目标时，对分割精度的要求更高。实例分割的主流方法包括 Mask R-CNN、SOLO 系列和 BlendMask，性能指标通常包括掩码平均精度（mask AP）和实例分割精度。实例分割能够精确区分同一类别中的不同实例，适用于复杂场景，如自动驾驶和医学影像分析。</p>\n<p>全景分割结合了语义分割和实例分割的优点，旨在同时处理“Things”（可数目标）和“Stuff”（不可数目标），为每个像素分配类别和实例 ID。全景分割的技术难点在于需要统一处理前景目标和背景区域，避免分割结果的重叠和遗漏。其主流方法包括 Mask2Former 和 Panoptic-DeepLab，性能通过全景质量（PQ）、分割质量（SQ）和识别质量（RQ）来衡量。全景分割提供了一种更全面的场景理解方式，适用于自动驾驶、机器人视觉和视频监控等需要完整场景理解的应用场景。</p>\n<p>随着技术的发展，Transformer 架构逐渐被引入到这些分割任务中，显著提升了模型的多尺度特征学习能力和整体性能。语义分割、实例分割和全景分割各有其独特的优势和应用场景，但在实际应用中，全景分割因其能够提供更完整的场景理解，逐渐成为研究和应用的热点方向。</p>\n<p><img src=\"https://tk-pichost-1325224430.cos.ap-chengdu.myqcloud.com/blog/17402355054491740235504618.png\" alt=\"17402355054491740235504618.png\"></p>\n<table>\n<tr>\n<td>技术<br/></td><td>方法简介<br/></td><td>关注点<br/></td></tr>\n<tr>\n<td>语义分割<br/></td><td>为图像中的每个像素分配特定类别标签。<br/></td><td>关注“stuff”部分<br/></td></tr>\n<tr>\n<td>实例分割<br/></td><td>在图像中检测并区分不同的物体实例。<br/></td><td>关注“things”部分<br/></td></tr>\n<tr>\n<td>全景分割<br/></td><td>结合语义分割和实例分割，为每个像素分配语义标签和实例标识符。<br/></td><td>同时关注“things”和“stuff”部分<br/></td></tr>\n</table>\n\n<h1 id=\"评价指标\"><a href=\"#评价指标\" class=\"headerlink\" title=\"评价指标\"></a><strong>评价指标</strong></h1><table>\n<tr>\n<td>分割类型<br/></td><td>评估指标<br/></td><td>描述<br/></td></tr>\n<tr>\n<td rowspan=\"4\">语义分割<br/></td><td>像素准确率（Pixel Accuracy）<br/></td><td>计算所有像素中被正确分类的比例<br/></td></tr>\n<tr>\n<td>平均交并比（MIoU）<br/></td><td>衡量预测分割与真实标注之间的重叠程度，是语义分割的核心指标<br/></td></tr>\n<tr>\n<td>Dice 系数（Dice Coefficient）<br/></td><td>衡量预测和真实分割的相似度，类似于 IoU<br/></td></tr>\n<tr>\n<td>召回率（Recall）和精确率（Precision）<br/></td><td>分别衡量模型对正样本的召回能力和预测正样本的准确性<br/></td></tr>\n<tr>\n<td rowspan=\"3\">实例分割<br/></td><td>平均精度均值（mAP）<br/></td><td>通过不同交并比（IoU）阈值下的平均精度来评估模型性能，是实例分割的核心指标<br/></td></tr>\n<tr>\n<td>平均交并比（MIoU）<br/></td><td>衡量预测实例与真实实例之间的重叠程度<br/></td></tr>\n<tr>\n<td>目标级别的精确率和召回率<br/></td><td>基于实例的 IoU 判断预测实例是否正确匹配真实实例<br/></td></tr>\n<tr>\n<td rowspan=\"3\">全景分割<br/></td><td>平均交并比（mIoU）<br/></td><td>用于评估语义分割部分的性能<br/></td></tr>\n<tr>\n<td>平均精度均值（mAP）<br/></td><td>用于评估实例分割部分的性能<br/></td></tr>\n<tr>\n<td>全景质量（Panoptic Quality, PQ）<br/></td><td>综合考虑语义分割的准确性和实例分割的完整性，是全景分割特有的评估指标<br/></td></tr>\n</table>\n\n<p>这些指标各有侧重点，具体选择取决于任务需求和数据集特性。</p>\n<ol>\n<li><strong>MIoU（Mean Intersection over Union）</strong></li>\n</ol>\n<p>MIoU 是一种常用的语义分割模型评价指标，它通过计算预测结果和真实标签的交集与并集之间的比值来衡量模型性能。MIoU 的计算公式为：</p>\n<p>$$<br>\\mathrm{MIoU}&#x3D;\\frac1N\\sum_{i&#x3D;1}^N\\frac{\\mathrm{TP}_i}{\\mathrm{TP}_i+\\mathrm{FP}_i+\\mathrm{FN}_i}<br>$$</p>\n<p>其中 TP 表示真正例（True Positives），FP 表示假正例（False Positives），FN 表示假反例（False Negatives）。MIoU 能够综合考虑模型的像素级别预测准确度，对模型在处理不同类别、不同大小的目标时进行公平的评价。</p>\n<ol>\n<li><strong>IoU（Intersection over Union）</strong></li>\n</ol>\n<p>IoU 指标即交并比，是语义分割中常用的标准度量。它衡量的是预测结果与真实标签之间的交集与并集之比。IoU 的计算公式为：</p>\n<p>$$<br>\\mathrm{IoU}&#x3D;\\frac{\\mathrm{TP}}{\\mathrm{TP}+\\mathrm{FP}+\\mathrm{FN}}<br>$$</p>\n<ol>\n<li><strong>Accuracy（准确率）</strong></li>\n</ol>\n<p>$$<br>\\mathrm{Accuracy}&#x3D;\\frac{\\mathrm{TP+TN}}{\\mathrm{TP+FP+FN+TN}}<br>$$</p>\n<p>准确率是指预测正确的样本数量占全部样本的百分比。然而，当数据类别分布不平衡时，准确率可能无法准确评价模型的好坏。因此，在语义分割任务中，准确率通常与其他指标结合使用。</p>\n<ol>\n<li><strong>Precision（查准率,精确率）</strong></li>\n</ol>\n<p>$$<br>\\text{Precision}&#x3D;\\frac{\\mathrm{TP}}{\\mathrm{TP}+\\mathrm{FP}}<br>$$</p>\n<p>查准率表示模型预测为正例的所有样本中，预测正确（真实标签为正）样本的占比。在语义分割中，查准率反映了模型对正样本的识别能力。</p>\n<ol>\n<li><strong>Recall（查全率,召回率）</strong></li>\n</ol>\n<p>$$<br>\\mathrm{Recall}&#x3D;\\frac{\\mathrm{TP}}{\\mathrm{TP}+\\mathrm{FN}}<br>$$</p>\n<p>查全率表示所有真实标签为正的样本中，有多大百分比被模型预测出来。在语义分割任务中，查全率衡量了模型对正样本的覆盖程度。</p>\n<ol>\n<li><strong>F1-Score</strong></li>\n</ol>\n<p>F1-Score 是查准率和查全率的调和平均数，用于综合评估模型的性能。它的计算公式为：</p>\n<p>$$<br>\\text{F1-Score}&#x3D;2\\cdot\\frac{\\text{Precision}\\cdot\\text{Recall}}{\\text{Precision}+\\text{Recall}}<br>$$</p>\n<p>F1-Score 的优点在于它综合考虑了精确度和召回率，使得模型在不平衡分类问题中的性能评估更为准确。在语义分割任务中，F1-Score 能够帮助我们了解模型在各类别上的综合表现。</p>\n<ol>\n<li><strong>像素准确率（Pixel Accuracy）</strong></li>\n</ol>\n<p>$$<br>\\text{Pixel Accuracy}&#x3D;\\frac{\\mathrm{TP+TN}}{\\text{Total Pixels}}<br>$$</p>\n<p>像素准确率是指模型预测正确的像素数量占总像素数量的比例。它是一个简单的指标，用于衡量模型在像素级别上的整体分类准确性。然而，像素准确率对类别不平衡的数据集不够敏感，因此通常与其他指标结合使用。</p>\n<ol>\n<li><strong>平均精度均值（mAP）</strong></li>\n</ol>\n<p>$$<br>\\mathrm{mAP}&#x3D;\\frac1N\\sum_{i&#x3D;1}^N\\mathrm{AP}_i<br>$$</p>\n<p>mAP（Mean Average Precision）是一种广泛用于目标检测和实例分割任务的评价指标，也适用于全景分割。它通过计算不同类别上的平均精度（AP），并取这些值的平均值得到。mAP 综合考虑了模型的精确度（Precision）和召回率（Recall），能够更全面地评估模型在不同类别上的性能。</p>\n<ol>\n<li><strong>全景质量（Panoptic Quality, PQ）</strong></li>\n</ol>\n<p>全景质量（PQ）是专门为全景分割任务设计的评价指标，用于综合评估模型在处理“Things”（可数目标）和“Stuff”（不可数背景）时的性能。PQ 指标结合了分割质量（Segmentation Quality, SQ）和识别质量（Recognition Quality, RQ），并通过以下公式计算：</p>\n<p>其中，SQ 衡量分割掩码的准确性，RQ 衡量实例识别的准确性。</p>\n<p>PQ 指标还分为单类别 PQ 和多类别 PQ（mPQ）。在某些竞赛中，还会使用 mPQ+，即对所有图像和类别进行加权平均的 PQ，以避免因某些类别在某些图像中缺失而导致的统计偏差。</p>\n<blockquote>\n<ul>\n<li><strong>分割质量（Segmentation Quality, SQ）</strong><br>SQ 衡量的是预测分割掩码与真实分割掩码之间的平均交并比（IoU）。具体来说，它反映了匹配成功的预测实例与真实实例之间的重叠程度。SQ 的计算公式为:</li>\n</ul>\n<p>$$<br>\\mathrm{SQ}&#x3D;\\frac{\\sum_{(g_k,p_l)\\in\\mathrm{TP}}\\mathrm{IoU}(g_k,p_l)}{|\\mathrm{TP}|}<br>$$</p>\n<p>其中，$gk$表示真实实例, $p_l$ 表示预测实例，TP 表示真正例（True Positives），即预测与真实实例匹配成功的对。</p>\n<ul>\n<li><strong>识别质量（Recognition Quality, RQ）</strong><br>RQ 衡量的是模型对目标实例的识别能力，类似于目标检测中的 F1 分数。它通过平衡精确率（Precision）和召回率（Recall）来评估模型对实例的识别效果。RQ 的计算公式为：</li>\n</ul>\n<p>$$<br>\\mathrm{RQ}&#x3D;\\frac{|\\mathrm{TP}|}{|\\mathrm{TP}|+\\frac12|\\mathrm{FP}|+\\frac12|\\mathrm{FP}|+\\frac12|\\mathrm{FN}|}<br>$$</p>\n<p>其中，FP 表示假正例（False Positives），FN 表示假反例（False Negatives）。</p>\n</blockquote>\n<ul>\n<li><strong>SQ</strong>：关注分割掩码的准确性，即预测掩码与真实掩码的重叠程度。</li>\n<li><strong>RQ</strong>：关注实例识别的准确性，类似于目标检测中的 F1 分数。</li>\n<li><strong>PQ</strong>：通过结合 SQ 和 RQ，提供了一个综合评估全景分割模型性能的指标。</li>\n</ul>\n<h1 id=\"总结\"><a href=\"#总结\" class=\"headerlink\" title=\"总结\"></a><strong>总结</strong></h1><p>语义分割、实例分割和全景分割是深度学习在图像分割领域的三大重要技术。语义分割专注于像素级分类，能够识别图像中不同类别的物体，但无法区分同一类别中的不同实例，因此在某些场景中需要结合实例分割来进一步划分同类别的不同实例。实例分割则专注于目标实例的区分，能够将同一类别中的不同物体单独识别出来。全景分割则结合了语义分割和实例分割的优点，能够同时提供像素级分类和实例区分，从而实现更全面的场景理解。</p>\n<h1 id=\"其他资源\"><a href=\"#其他资源\" class=\"headerlink\" title=\"其他资源\"></a>其他资源</h1><table>\n<thead>\n<tr>\n<th>分类</th>\n<th>链接</th>\n</tr>\n</thead>\n<tbody><tr>\n<td>项目</td>\n<td><a href=\"https://github.com/bubbliiing/unet-pytorch\">bubbliiing&#x2F;unet-pytorch</a></td>\n</tr>\n<tr>\n<td>项目</td>\n<td><a href=\"https://github.com/bubbliiing/pspnet-pytorch\">bubbliiing&#x2F;pspnet-pytorch</a></td>\n</tr>\n<tr>\n<td>项目</td>\n<td><a href=\"https://github.com/ultralytics/ultralytics\">https://github.com/ultralytics/ultralytics</a></td>\n</tr>\n<tr>\n<td>项目</td>\n<td><a href=\"https://github.com/bonlime/keras-deeplab-v3-plus\">bonlime&#x2F;keras-deeplab-v3-plus</a></td>\n</tr>\n<tr>\n<td>项目</td>\n<td><a href=\"https://www.codewithgpu.com/i/bubbliiing/unet-pytorch/UNet-PyTorch\">https://www.codewithgpu.com/i/bubbliiing/unet-pytorch/UNet-PyTorch</a></td>\n</tr>\n<tr>\n<td>博客</td>\n<td><a href=\"https://zhuanlan.zhihu.com/p/303355997\">https://zhuanlan.zhihu.com/p/303355997</a></td>\n</tr>\n<tr>\n<td>数据集</td>\n<td><a href=\"https://app.roboflow.com/project-p0vpn/bubble-mclkq/1\">bubble - v1 2025-01-23 12:27pm</a></td>\n</tr>\n<tr>\n<td>工具</td>\n<td><a href=\"https://huggingface.co/spaces\">https://huggingface.co/spaces</a></td>\n</tr>\n<tr>\n<td>工具</td>\n<td><a href=\"https://ghfast.top/\">GitHub Proxy 代理加速</a></td>\n</tr>\n<tr>\n<td>工具</td>\n<td><a href=\"https://hf-mirror.com/\">https://hf-mirror.com/</a></td>\n</tr>\n<tr>\n<td>工具</td>\n<td><a href=\"https://www.autodl.com/\">AutoDL算力云</a></td>\n</tr>\n</tbody></table>\n<p>希望这对你有帮助！</p>\n"},{"title":"文言文背诵检测程序开发","date":"2025-02-07T16:00:00.000Z","_content":"### 可参考的提示词（Prompts）\n\n您可以将这些提示词组合或分步提供给AI，以生成文章的各个部分。\n\n#### **角色设定与总体任务 (Master Prompt)**\n\n> 你是一位资深的软件工程师和技术博主，擅长撰写清晰、易于理解的“手把手”教程。\n>\n> 我需要你帮我写一篇关于“**本地化部署DeepSeek模型**”的博客文章。\n>\n> **核心技术栈包括**：Ollama、DeepSeek-1.5B模型、Open WebUI。\n> **目标平台**：主要是在Windows 11本地部署，其次是在Linux服务器上部署。\n> **文章风格**：面向有一定基础的开发者，步骤清晰，配有命令代码和截图占位符 `![截图描述]`。\n>\n> **文章需要包含以下几个部分**：\n>\n> 1. 引言和准备工作（参考资料、实验目的）。\n> 2. Windows下的详细部署流程：安装Ollama -> 拉取DeepSeek模型 -> 通过命令行和Open WebUI（pip和Docker两种方式）进行交互。\n> 3. Linux服务器上的简化部署流程，指出与Windows的不同之处。\n> 4. 一个总结，评价1.5B小模型的优缺点和适用场景。\n>\n> 现在，请先为我生成文章的**大纲**和**引言部分**。\n\n#### **分步生成提示词 (Step-by-Step Prompts)**\n\n**第1步：生成引言和准备工作**\n\n> 根据我们之前定下的主题“本地化部署DeepSeek模型”，请为我撰写文章的**引言**、**参考资料**和**实验目的**部分。参考资料可以先用占位符链接。实验目的要清晰地列出我们计划完成的任务。\n\n**第2步：生成Windows部署 - Ollama和模型部分**\n\n> 接下来，请撰写“**在Windows本地部署**”的第一部分内容。\n>\n> 1. **下载并安装Ollama**：描述如何从 `ollama.com` 下载并安装Ollama，并为下载页面和安装过程各插入一个截图占位符。\n> 2. **通过Ollama拉取DeepSeek模型**：说明我们将使用 `deepseek-r1:1.5b` 模型，提供 `ollama run` 命令，并附上一个查看更多版本的Ollama官网链接。最后插入一个命令成功执行的截图占位符。\n\n**第3步：生成Windows部署 - 交互方式部分**\n\n> 现在，请详细描述与本地模型交互的几种方式。\n>\n> 1. **终端回答**：简单描述这是最直接的方式，并插入一张终端对话的截图占位符。\n> 2. **使用open-webui**：重点介绍这个方法。\n>    - 先写一个“注意”块，提醒用户需要Python 3.11和Conda环境。\n>    - 写一个子标题“**使用pip安装**”，提供创建conda环境、pip安装和启动服务的完整命令，并说明如何访问（`localhost:8080`）。插入UI截图占位符。\n>    - 再写一个子标题“**使用docker安装**”，提供 `docker run` 命令，解释端口映射。说明如何访问（`localhost:3000`）。插入Docker运行状态和UI界面的截图占位符。\n\n**第44步：生成Linux服务器部署部分**\n\n> 请为我撰写“**linux服务器部署**”章节。\n>\n> - 开头说明这个过程和Windows类似。\n> - 提供在Linux下安装Ollama的 `curl` 命令和 `sudo snap install ollama` 备用命令。\n> - 简要列出后续的 `ollama run` 和 `docker run` 命令。\n> - 特别提醒用户访问时需要使用服务器的公网IP。\n> - 最后插入一张在Linux上部署成功并访问的截图占位符。\n\n**第5步：生成总结部分**\n\n> 最后，请为整篇文章撰写一个**总结**。评价一下像DeepSeek-1.5B这样的小参数模型的**优势**（资源占用、延迟）和**局限性**（生成能力）。根据这些特点，给出你的**最终建议**：这类模型适合什么场景（如边缘计算、基础任务），而对于高质量的生产需求，应该选择什么样的模型。\n","source":"_posts/2025-02-08-提示词.md","raw":"---\ntitle: 文言文背诵检测程序开发\ndate: 2025-02-08\ntags: 程序开发\n---\n### 可参考的提示词（Prompts）\n\n您可以将这些提示词组合或分步提供给AI，以生成文章的各个部分。\n\n#### **角色设定与总体任务 (Master Prompt)**\n\n> 你是一位资深的软件工程师和技术博主，擅长撰写清晰、易于理解的“手把手”教程。\n>\n> 我需要你帮我写一篇关于“**本地化部署DeepSeek模型**”的博客文章。\n>\n> **核心技术栈包括**：Ollama、DeepSeek-1.5B模型、Open WebUI。\n> **目标平台**：主要是在Windows 11本地部署，其次是在Linux服务器上部署。\n> **文章风格**：面向有一定基础的开发者，步骤清晰，配有命令代码和截图占位符 `![截图描述]`。\n>\n> **文章需要包含以下几个部分**：\n>\n> 1. 引言和准备工作（参考资料、实验目的）。\n> 2. Windows下的详细部署流程：安装Ollama -> 拉取DeepSeek模型 -> 通过命令行和Open WebUI（pip和Docker两种方式）进行交互。\n> 3. Linux服务器上的简化部署流程，指出与Windows的不同之处。\n> 4. 一个总结，评价1.5B小模型的优缺点和适用场景。\n>\n> 现在，请先为我生成文章的**大纲**和**引言部分**。\n\n#### **分步生成提示词 (Step-by-Step Prompts)**\n\n**第1步：生成引言和准备工作**\n\n> 根据我们之前定下的主题“本地化部署DeepSeek模型”，请为我撰写文章的**引言**、**参考资料**和**实验目的**部分。参考资料可以先用占位符链接。实验目的要清晰地列出我们计划完成的任务。\n\n**第2步：生成Windows部署 - Ollama和模型部分**\n\n> 接下来，请撰写“**在Windows本地部署**”的第一部分内容。\n>\n> 1. **下载并安装Ollama**：描述如何从 `ollama.com` 下载并安装Ollama，并为下载页面和安装过程各插入一个截图占位符。\n> 2. **通过Ollama拉取DeepSeek模型**：说明我们将使用 `deepseek-r1:1.5b` 模型，提供 `ollama run` 命令，并附上一个查看更多版本的Ollama官网链接。最后插入一个命令成功执行的截图占位符。\n\n**第3步：生成Windows部署 - 交互方式部分**\n\n> 现在，请详细描述与本地模型交互的几种方式。\n>\n> 1. **终端回答**：简单描述这是最直接的方式，并插入一张终端对话的截图占位符。\n> 2. **使用open-webui**：重点介绍这个方法。\n>    - 先写一个“注意”块，提醒用户需要Python 3.11和Conda环境。\n>    - 写一个子标题“**使用pip安装**”，提供创建conda环境、pip安装和启动服务的完整命令，并说明如何访问（`localhost:8080`）。插入UI截图占位符。\n>    - 再写一个子标题“**使用docker安装**”，提供 `docker run` 命令，解释端口映射。说明如何访问（`localhost:3000`）。插入Docker运行状态和UI界面的截图占位符。\n\n**第44步：生成Linux服务器部署部分**\n\n> 请为我撰写“**linux服务器部署**”章节。\n>\n> - 开头说明这个过程和Windows类似。\n> - 提供在Linux下安装Ollama的 `curl` 命令和 `sudo snap install ollama` 备用命令。\n> - 简要列出后续的 `ollama run` 和 `docker run` 命令。\n> - 特别提醒用户访问时需要使用服务器的公网IP。\n> - 最后插入一张在Linux上部署成功并访问的截图占位符。\n\n**第5步：生成总结部分**\n\n> 最后，请为整篇文章撰写一个**总结**。评价一下像DeepSeek-1.5B这样的小参数模型的**优势**（资源占用、延迟）和**局限性**（生成能力）。根据这些特点，给出你的**最终建议**：这类模型适合什么场景（如边缘计算、基础任务），而对于高质量的生产需求，应该选择什么样的模型。\n","slug":"2025-02-08-提示词","published":1,"updated":"2025-09-26T11:44:56.720Z","comments":1,"layout":"post","photos":[],"_id":"cmg0saj3u0009jm8ndroo672p","content":"<h3 id=\"可参考的提示词（Prompts）\"><a href=\"#可参考的提示词（Prompts）\" class=\"headerlink\" title=\"可参考的提示词（Prompts）\"></a>可参考的提示词（Prompts）</h3><p>您可以将这些提示词组合或分步提供给AI，以生成文章的各个部分。</p>\n<h4 id=\"角色设定与总体任务-Master-Prompt\"><a href=\"#角色设定与总体任务-Master-Prompt\" class=\"headerlink\" title=\"角色设定与总体任务 (Master Prompt)\"></a><strong>角色设定与总体任务 (Master Prompt)</strong></h4><blockquote>\n<p>你是一位资深的软件工程师和技术博主，擅长撰写清晰、易于理解的“手把手”教程。</p>\n<p>我需要你帮我写一篇关于“<strong>本地化部署DeepSeek模型</strong>”的博客文章。</p>\n<p><strong>核心技术栈包括</strong>：Ollama、DeepSeek-1.5B模型、Open WebUI。<br><strong>目标平台</strong>：主要是在Windows 11本地部署，其次是在Linux服务器上部署。<br><strong>文章风格</strong>：面向有一定基础的开发者，步骤清晰，配有命令代码和截图占位符 <code>![截图描述]</code>。</p>\n<p><strong>文章需要包含以下几个部分</strong>：</p>\n<ol>\n<li>引言和准备工作（参考资料、实验目的）。</li>\n<li>Windows下的详细部署流程：安装Ollama -&gt; 拉取DeepSeek模型 -&gt; 通过命令行和Open WebUI（pip和Docker两种方式）进行交互。</li>\n<li>Linux服务器上的简化部署流程，指出与Windows的不同之处。</li>\n<li>一个总结，评价1.5B小模型的优缺点和适用场景。</li>\n</ol>\n<p>现在，请先为我生成文章的<strong>大纲</strong>和<strong>引言部分</strong>。</p>\n</blockquote>\n<h4 id=\"分步生成提示词-Step-by-Step-Prompts\"><a href=\"#分步生成提示词-Step-by-Step-Prompts\" class=\"headerlink\" title=\"分步生成提示词 (Step-by-Step Prompts)\"></a><strong>分步生成提示词 (Step-by-Step Prompts)</strong></h4><p><strong>第1步：生成引言和准备工作</strong></p>\n<blockquote>\n<p>根据我们之前定下的主题“本地化部署DeepSeek模型”，请为我撰写文章的<strong>引言</strong>、<strong>参考资料</strong>和<strong>实验目的</strong>部分。参考资料可以先用占位符链接。实验目的要清晰地列出我们计划完成的任务。</p>\n</blockquote>\n<p><strong>第2步：生成Windows部署 - Ollama和模型部分</strong></p>\n<blockquote>\n<p>接下来，请撰写“<strong>在Windows本地部署</strong>”的第一部分内容。</p>\n<ol>\n<li><strong>下载并安装Ollama</strong>：描述如何从 <code>ollama.com</code> 下载并安装Ollama，并为下载页面和安装过程各插入一个截图占位符。</li>\n<li><strong>通过Ollama拉取DeepSeek模型</strong>：说明我们将使用 <code>deepseek-r1:1.5b</code> 模型，提供 <code>ollama run</code> 命令，并附上一个查看更多版本的Ollama官网链接。最后插入一个命令成功执行的截图占位符。</li>\n</ol>\n</blockquote>\n<p><strong>第3步：生成Windows部署 - 交互方式部分</strong></p>\n<blockquote>\n<p>现在，请详细描述与本地模型交互的几种方式。</p>\n<ol>\n<li><strong>终端回答</strong>：简单描述这是最直接的方式，并插入一张终端对话的截图占位符。</li>\n<li><strong>使用open-webui</strong>：重点介绍这个方法。<ul>\n<li>先写一个“注意”块，提醒用户需要Python 3.11和Conda环境。</li>\n<li>写一个子标题“<strong>使用pip安装</strong>”，提供创建conda环境、pip安装和启动服务的完整命令，并说明如何访问（<code>localhost:8080</code>）。插入UI截图占位符。</li>\n<li>再写一个子标题“<strong>使用docker安装</strong>”，提供 <code>docker run</code> 命令，解释端口映射。说明如何访问（<code>localhost:3000</code>）。插入Docker运行状态和UI界面的截图占位符。</li>\n</ul>\n</li>\n</ol>\n</blockquote>\n<p><strong>第44步：生成Linux服务器部署部分</strong></p>\n<blockquote>\n<p>请为我撰写“<strong>linux服务器部署</strong>”章节。</p>\n<ul>\n<li>开头说明这个过程和Windows类似。</li>\n<li>提供在Linux下安装Ollama的 <code>curl</code> 命令和 <code>sudo snap install ollama</code> 备用命令。</li>\n<li>简要列出后续的 <code>ollama run</code> 和 <code>docker run</code> 命令。</li>\n<li>特别提醒用户访问时需要使用服务器的公网IP。</li>\n<li>最后插入一张在Linux上部署成功并访问的截图占位符。</li>\n</ul>\n</blockquote>\n<p><strong>第5步：生成总结部分</strong></p>\n<blockquote>\n<p>最后，请为整篇文章撰写一个<strong>总结</strong>。评价一下像DeepSeek-1.5B这样的小参数模型的<strong>优势</strong>（资源占用、延迟）和<strong>局限性</strong>（生成能力）。根据这些特点，给出你的<strong>最终建议</strong>：这类模型适合什么场景（如边缘计算、基础任务），而对于高质量的生产需求，应该选择什么样的模型。</p>\n</blockquote>\n","excerpt":"","more":"<h3 id=\"可参考的提示词（Prompts）\"><a href=\"#可参考的提示词（Prompts）\" class=\"headerlink\" title=\"可参考的提示词（Prompts）\"></a>可参考的提示词（Prompts）</h3><p>您可以将这些提示词组合或分步提供给AI，以生成文章的各个部分。</p>\n<h4 id=\"角色设定与总体任务-Master-Prompt\"><a href=\"#角色设定与总体任务-Master-Prompt\" class=\"headerlink\" title=\"角色设定与总体任务 (Master Prompt)\"></a><strong>角色设定与总体任务 (Master Prompt)</strong></h4><blockquote>\n<p>你是一位资深的软件工程师和技术博主，擅长撰写清晰、易于理解的“手把手”教程。</p>\n<p>我需要你帮我写一篇关于“<strong>本地化部署DeepSeek模型</strong>”的博客文章。</p>\n<p><strong>核心技术栈包括</strong>：Ollama、DeepSeek-1.5B模型、Open WebUI。<br><strong>目标平台</strong>：主要是在Windows 11本地部署，其次是在Linux服务器上部署。<br><strong>文章风格</strong>：面向有一定基础的开发者，步骤清晰，配有命令代码和截图占位符 <code>![截图描述]</code>。</p>\n<p><strong>文章需要包含以下几个部分</strong>：</p>\n<ol>\n<li>引言和准备工作（参考资料、实验目的）。</li>\n<li>Windows下的详细部署流程：安装Ollama -&gt; 拉取DeepSeek模型 -&gt; 通过命令行和Open WebUI（pip和Docker两种方式）进行交互。</li>\n<li>Linux服务器上的简化部署流程，指出与Windows的不同之处。</li>\n<li>一个总结，评价1.5B小模型的优缺点和适用场景。</li>\n</ol>\n<p>现在，请先为我生成文章的<strong>大纲</strong>和<strong>引言部分</strong>。</p>\n</blockquote>\n<h4 id=\"分步生成提示词-Step-by-Step-Prompts\"><a href=\"#分步生成提示词-Step-by-Step-Prompts\" class=\"headerlink\" title=\"分步生成提示词 (Step-by-Step Prompts)\"></a><strong>分步生成提示词 (Step-by-Step Prompts)</strong></h4><p><strong>第1步：生成引言和准备工作</strong></p>\n<blockquote>\n<p>根据我们之前定下的主题“本地化部署DeepSeek模型”，请为我撰写文章的<strong>引言</strong>、<strong>参考资料</strong>和<strong>实验目的</strong>部分。参考资料可以先用占位符链接。实验目的要清晰地列出我们计划完成的任务。</p>\n</blockquote>\n<p><strong>第2步：生成Windows部署 - Ollama和模型部分</strong></p>\n<blockquote>\n<p>接下来，请撰写“<strong>在Windows本地部署</strong>”的第一部分内容。</p>\n<ol>\n<li><strong>下载并安装Ollama</strong>：描述如何从 <code>ollama.com</code> 下载并安装Ollama，并为下载页面和安装过程各插入一个截图占位符。</li>\n<li><strong>通过Ollama拉取DeepSeek模型</strong>：说明我们将使用 <code>deepseek-r1:1.5b</code> 模型，提供 <code>ollama run</code> 命令，并附上一个查看更多版本的Ollama官网链接。最后插入一个命令成功执行的截图占位符。</li>\n</ol>\n</blockquote>\n<p><strong>第3步：生成Windows部署 - 交互方式部分</strong></p>\n<blockquote>\n<p>现在，请详细描述与本地模型交互的几种方式。</p>\n<ol>\n<li><strong>终端回答</strong>：简单描述这是最直接的方式，并插入一张终端对话的截图占位符。</li>\n<li><strong>使用open-webui</strong>：重点介绍这个方法。<ul>\n<li>先写一个“注意”块，提醒用户需要Python 3.11和Conda环境。</li>\n<li>写一个子标题“<strong>使用pip安装</strong>”，提供创建conda环境、pip安装和启动服务的完整命令，并说明如何访问（<code>localhost:8080</code>）。插入UI截图占位符。</li>\n<li>再写一个子标题“<strong>使用docker安装</strong>”，提供 <code>docker run</code> 命令，解释端口映射。说明如何访问（<code>localhost:3000</code>）。插入Docker运行状态和UI界面的截图占位符。</li>\n</ul>\n</li>\n</ol>\n</blockquote>\n<p><strong>第44步：生成Linux服务器部署部分</strong></p>\n<blockquote>\n<p>请为我撰写“<strong>linux服务器部署</strong>”章节。</p>\n<ul>\n<li>开头说明这个过程和Windows类似。</li>\n<li>提供在Linux下安装Ollama的 <code>curl</code> 命令和 <code>sudo snap install ollama</code> 备用命令。</li>\n<li>简要列出后续的 <code>ollama run</code> 和 <code>docker run</code> 命令。</li>\n<li>特别提醒用户访问时需要使用服务器的公网IP。</li>\n<li>最后插入一张在Linux上部署成功并访问的截图占位符。</li>\n</ul>\n</blockquote>\n<p><strong>第5步：生成总结部分</strong></p>\n<blockquote>\n<p>最后，请为整篇文章撰写一个<strong>总结</strong>。评价一下像DeepSeek-1.5B这样的小参数模型的<strong>优势</strong>（资源占用、延迟）和<strong>局限性</strong>（生成能力）。根据这些特点，给出你的<strong>最终建议</strong>：这类模型适合什么场景（如边缘计算、基础任务），而对于高质量的生产需求，应该选择什么样的模型。</p>\n</blockquote>\n"},{"title":"2025-02-15-语义分割","date":"2025-02-14T16:00:00.000Z","_content":"# 前言\n\n在开始这篇文章之前，我们得首先弄明白，什么是图像分割？\n\n我们知道一个图像只不过是许多像素的集合。图像分割分类是对图像中属于特定类别的像素进行分类的过程，即像素级别的下游任务。因此图像分割简单来说就是按像素进行分类的问题。\n\n传统的图像分割算法均是基于灰度值的不连续和相似的性质。而基于深度学习的图像分割技术则是利用卷积神经网络，来理解图像中的每个像素所代表的真实世界物体，这在以前是难以想象的。\n\n![1740235822031FRBrbtq8Zogp1oxNSIhcx7Z6nVb.png](https://tk-pichost-1325224430.cos.ap-chengdu.myqcloud.com/blog/1740235822031FRBrbtq8Zogp1oxNSIhcx7Z6nVb.png)\n\n# **语义分割（Semantic Segmentation）**\n\n## ** 定义**\n\n“语义”是个很抽象的概念，在 2D 图像领域，每个像素点作为最小单位，它的像素值代表的就是一个特征，即“语义”信息。语义分割会为图像中的每个像素分配一个类别，但是同一类别之间的对象不会区分。而实例分割，只对特定的物体进行分类。这看起来与目标检测相似，不同的是目标检测输出目标的边界框和类别，实例分割输出的是目标的 Mask 和类别。具体而言，语义分割的目的是为了从像素级别理解图像的内容，并为图像中的每个像素分配一个对象类。\n\n语义分割是一种将图像中的每个像素分配给特定类别的技术。其目标是识别图像中存在的各种对象和背景，并为每个像素分配相应的类别标签。例如，将图像中的像素划分为人、树、草地和天空等不同区域。是图像处理和机器视觉一个重要分支。与分类任务不同，语义分割需要判断图像每个像素点的类别，进行精确分割。语义分割目前在自动驾驶、自动抠图、医疗影像等领域有着比较广泛的应用。\n\n## ** 特点**\n\n- 提供精确的像素级分类，有助于深入理解图像内容。\n- 无法区分同一类别中的不同实例。\n\n## ** 语义分割的应用**\n\n语义分割在多个领域有广泛应用：\n\n- **自动驾驶**：用于道路、车辆和行人的识别。\n- **医学成像**：用于组织和器官的分割。\n- **卫星遥感**：用于土地覆盖分类。\n\n## ** 常见模型**\n\n### **FCN（Fully Convolutional Network）**\n\n- **优点**：简单易用，但是现在已经很少使用了,但它的历史贡献不可忽视。\n- **缺点**：分割精度较低，可能无法很好地处理细节。\n\n#### 提出初衷\n\n![1740236704772Z5SNbToLOosLf9xBvllcevjVnEe.png](https://tk-pichost-1325224430.cos.ap-chengdu.myqcloud.com/blog/1740236704772Z5SNbToLOosLf9xBvllcevjVnEe.png)\nFCN（全卷积网络）模型的初衷是为了解决传统卷积神经网络（CNN）在语义分割任务中的局限性。具体而言，传统 CNN 使用全连接层进行分类，这会丢失图像的空间位置信息，导致其不适合像素级的预测任务。FCN 的核心动机包括：\n\n1. **实现端到端的像素级预测**：FCN 通过将全连接层替换为卷积层，使得网络能够接受任意尺寸的输入图像，并输出与输入尺寸相同的像素级预测结果。\n2. **保留空间信息**：取消全连接层后，FCN 能够保留图像的空间位置信息，从而更好地适应语义分割任务。\n3. **提高分割效率和精度**：通过引入反卷积层（上采样层）和跳跃连接（Skip Connections），FCN 能够融合不同深度的特征，兼顾全局语义信息和局部细节，从而提升分割精度。\n4. **利用预训练模型加速训练**：FCN 可以基于预训练的分类模型（如 AlexNet、VGG 等）进行微调，从而显著加速训练过程并提高模型性能。\n\n#### 网络结构\n\n![1740236686503VcqtbHWWQoRtJIxgy6bconZQnHc.png](https://tk-pichost-1325224430.cos.ap-chengdu.myqcloud.com/blog/1740236686503VcqtbHWWQoRtJIxgy6bconZQnHc.png)\n通常 CNN 网络在卷积层之后会接上若干个全连接层, 将卷积层产生的特征图(feature map)映射成一个固定长度的特征向量。以 AlexNet 为代表的经典 CNN 结构适合于图像级的分类和回归任务，因为它们最后都期望得到整个输入图像的一个数值描述（概率）。\nFCN 对图像进行像素级的分类，从而解决了语义级别的图像分割（semantic segmentation）问题。与经典的 CNN 在卷积层之后使用全连接层得到固定长度的特征向量进行分类（全连接层 ＋softmax 输出）不同，FCN 可以接受任意尺寸的输入图像，采用反卷积层对最后一个卷积层的 feature map 进行上采样, 使它恢复到输入图像相同的尺寸，从而可以对每个像素都产生了一个预测, 同时保留了原始输入图像中的空间信息, 最后在上采样的特征图上进行逐像素分类。\n![1740236781446CxZ6b4zcXo9A12xuNJtcEgA7nfc.png](https://tk-pichost-1325224430.cos.ap-chengdu.myqcloud.com/blog/1740236781446CxZ6b4zcXo9A12xuNJtcEgA7nfc.png)\nFCN（全卷积网络）为了解决语义分割（semantic segmentation）问题而提出，它对图像进行像素级的分类，能够保留原始输入图像中的空间信息。与传统 CNN 不同，FCN 可以接受任意尺寸的输入图像，并通过以下方式实现像素级分类：\n\n1. **去除全连接层**：FCN 将传统 CNN 中的全连接层替换为卷积层，从而保留空间信息。\n2. **上采样操作**：使用反卷积层（上采样层）对最后一个卷积层的特征图进行上采样，恢复到与输入图像相同的尺寸。\n3. **逐像素分类**：在上采样后的特征图上进行逐像素分类，为每个像素生成类别预测。\n\n> Q:**FCN 是如何通过上采样操作恢复特征图的空间分辨率的？**\n\n#### 模型代码\n\n##### 论文源码\n\n```python\nimport caffe\nfrom caffe import layers as L, params as P\nfrom caffe.coord_map import crop\n\ndef conv_relu(bottom, nout, ks=3, stride=1, pad=1):\n    conv = L.Convolution(bottom, kernel_size=ks, stride=stride,\n        num_output=nout, pad=pad,\n        param=[dict(lr_mult=1, decay_mult=1), dict(lr_mult=2, decay_mult=0)])\n    return conv, L.ReLU(conv, in_place=True)\n\ndef max_pool(bottom, ks=2, stride=2):\n    return L.Pooling(bottom, pool=P.Pooling.MAX, kernel_size=ks, stride=stride)\n\ndef fcn(split):\n    n = caffe.NetSpec()\n    pydata_params = dict(split=split, mean=(104.00699, 116.66877, 122.67892),\n            seed=1337)\n    if split == 'train':\n        pydata_params['sbdd_dir'] = '../data/sbdd/dataset'\n        pylayer = 'SBDDSegDataLayer'\n    else:\n        pydata_params['voc_dir'] = '../data/pascal/VOC2011'\n        pylayer = 'VOCSegDataLayer'\n    n.data, n.label = L.Python(module='voc_layers', layer=pylayer,\n            ntop=2, param_str=str(pydata_params))\n\n    # the base net\n    n.conv1_1, n.relu1_1 = conv_relu(n.data, 64, pad=100)\n    n.conv1_2, n.relu1_2 = conv_relu(n.relu1_1, 64)\n    n.pool1 = max_pool(n.relu1_2)\n\n    n.conv2_1, n.relu2_1 = conv_relu(n.pool1, 128)\n    n.conv2_2, n.relu2_2 = conv_relu(n.relu2_1, 128)\n    n.pool2 = max_pool(n.relu2_2)\n\n    n.conv3_1, n.relu3_1 = conv_relu(n.pool2, 256)\n    n.conv3_2, n.relu3_2 = conv_relu(n.relu3_1, 256)\n    n.conv3_3, n.relu3_3 = conv_relu(n.relu3_2, 256)\n    n.pool3 = max_pool(n.relu3_3)\n\n    n.conv4_1, n.relu4_1 = conv_relu(n.pool3, 512)\n    n.conv4_2, n.relu4_2 = conv_relu(n.relu4_1, 512)\n    n.conv4_3, n.relu4_3 = conv_relu(n.relu4_2, 512)\n    n.pool4 = max_pool(n.relu4_3)\n\n    n.conv5_1, n.relu5_1 = conv_relu(n.pool4, 512)\n    n.conv5_2, n.relu5_2 = conv_relu(n.relu5_1, 512)\n    n.conv5_3, n.relu5_3 = conv_relu(n.relu5_2, 512)\n    n.pool5 = max_pool(n.relu5_3)\n\n    # fully conv\n    n.fc6, n.relu6 = conv_relu(n.pool5, 4096, ks=7, pad=0)\n    n.drop6 = L.Dropout(n.relu6, dropout_ratio=0.5, in_place=True)\n    n.fc7, n.relu7 = conv_relu(n.drop6, 4096, ks=1, pad=0)\n    n.drop7 = L.Dropout(n.relu7, dropout_ratio=0.5, in_place=True)\n    n.score_fr = L.Convolution(n.drop7, num_output=21, kernel_size=1, pad=0,\n        param=[dict(lr_mult=1, decay_mult=1), dict(lr_mult=2, decay_mult=0)])\n    n.upscore2 = L.Deconvolution(n.score_fr,\n        convolution_param=dict(num_output=21, kernel_size=4, stride=2,\n            bias_term=False),\n        param=[dict(lr_mult=0)])\n\n    n.score_pool4 = L.Convolution(n.pool4, num_output=21, kernel_size=1, pad=0,\n        param=[dict(lr_mult=1, decay_mult=1), dict(lr_mult=2, decay_mult=0)])\n    n.score_pool4c = crop(n.score_pool4, n.upscore2)\n    n.fuse_pool4 = L.Eltwise(n.upscore2, n.score_pool4c,\n            operation=P.Eltwise.SUM)\n    n.upscore_pool4 = L.Deconvolution(n.fuse_pool4,\n        convolution_param=dict(num_output=21, kernel_size=4, stride=2,\n            bias_term=False),\n        param=[dict(lr_mult=0)])\n\n    n.score_pool3 = L.Convolution(n.pool3, num_output=21, kernel_size=1, pad=0,\n        param=[dict(lr_mult=1, decay_mult=1), dict(lr_mult=2, decay_mult=0)])\n    n.score_pool3c = crop(n.score_pool3, n.upscore_pool4)\n    n.fuse_pool3 = L.Eltwise(n.upscore_pool4, n.score_pool3c,\n            operation=P.Eltwise.SUM)\n    n.upscore8 = L.Deconvolution(n.fuse_pool3,\n        convolution_param=dict(num_output=21, kernel_size=16, stride=8,\n            bias_term=False),\n        param=[dict(lr_mult=0)])\n\n    n.score = crop(n.upscore8, n.data)\n    n.loss = L.SoftmaxWithLoss(n.score, n.label,\n            loss_param=dict(normalize=False, ignore_label=255))\n\n    return n.to_proto()\n\ndef make_net():\n    with open('train.prototxt', 'w') as f:\n        f.write(str(fcn('train')))\n\n    with open('val.prototxt', 'w') as f:\n        f.write(str(fcn('seg11valid')))\n\nif __name__ == '__main__':\n    make_net()\n```\n\n##### fcn8_vgg\n\n```python\nfrom __future__ import absolute_import\nfrom __future__ import division\nfrom __future__ import print_function\n\nimport os\nimport logging\nfrom math import ceil\nimport sys\n\nimport numpy as np\nimport tensorflow as tf\n\nVGG_MEAN = [103.939, 116.779, 123.68]\n\n\nclass FCN8VGG:\n\n    def __init__(self, vgg16_npy_path=None):\n        if vgg16_npy_path is None:\n            path = sys.modules[self.__class__.__module__].__file__\n            # print path\n            path = os.path.abspath(os.path.join(path, os.pardir))\n            # print path\n            path = os.path.join(path, \"vgg16.npy\")\n            vgg16_npy_path = path\n            logging.info(\"Load npy file from '%s'.\", vgg16_npy_path)\n        if not os.path.isfile(vgg16_npy_path):\n            logging.error((\"File '%s' not found. Download it from \"\n                           \"ftp://mi.eng.cam.ac.uk/pub/mttt2/\"\n                           \"models/vgg16.npy\"), vgg16_npy_path)\n            sys.exit(1)\n\n        self.data_dict = np.load(vgg16_npy_path, encoding='latin1').item()\n        self.wd = 5e-4\n        print(\"npy file loaded\")\n\n    def build(self, rgb, train=False, num_classes=20, random_init_fc8=False,\n              debug=False, use_dilated=False):\n        \"\"\"\n        Build the VGG model using loaded weights\n        Parameters\n        ----------\n        rgb: image batch tensor\n            Image in rgb shap. Scaled to Intervall [0, 255]\n        train: bool\n            Whether to build train or inference graph\n        num_classes: int\n            How many classes should be predicted (by fc8)\n        random_init_fc8 : bool\n            Whether to initialize fc8 layer randomly.\n            Finetuning is required in this case.\n        debug: bool\n            Whether to print additional Debug Information.\n        \"\"\"\n        # Convert RGB to BGR\n\n        with tf.name_scope('Processing'):\n\n            red, green, blue = tf.split(rgb, 3, 3)\n            # assert red.get_shape().as_list()[1:] == [224, 224, 1]\n            # assert green.get_shape().as_list()[1:] == [224, 224, 1]\n            # assert blue.get_shape().as_list()[1:] == [224, 224, 1]\n            bgr = tf.concat([\n                blue - VGG_MEAN[0],\n                green - VGG_MEAN[1],\n                red - VGG_MEAN[2],\n            ], 3)\n\n            if debug:\n                bgr = tf.Print(bgr, [tf.shape(bgr)],\n                               message='Shape of input image: ',\n                               summarize=4, first_n=1)\n\n        self.conv1_1 = self._conv_layer(bgr, \"conv1_1\")\n        self.conv1_2 = self._conv_layer(self.conv1_1, \"conv1_2\")\n        self.pool1 = self._max_pool(self.conv1_2, 'pool1', debug)\n\n        self.conv2_1 = self._conv_layer(self.pool1, \"conv2_1\")\n        self.conv2_2 = self._conv_layer(self.conv2_1, \"conv2_2\")\n        self.pool2 = self._max_pool(self.conv2_2, 'pool2', debug)\n\n        self.conv3_1 = self._conv_layer(self.pool2, \"conv3_1\")\n        self.conv3_2 = self._conv_layer(self.conv3_1, \"conv3_2\")\n        self.conv3_3 = self._conv_layer(self.conv3_2, \"conv3_3\")\n        self.pool3 = self._max_pool(self.conv3_3, 'pool3', debug)\n\n        self.conv4_1 = self._conv_layer(self.pool3, \"conv4_1\")\n        self.conv4_2 = self._conv_layer(self.conv4_1, \"conv4_2\")\n        self.conv4_3 = self._conv_layer(self.conv4_2, \"conv4_3\")\n\n        if use_dilated:\n            pad = [[0, 0], [0, 0]]\n            self.pool4 = tf.nn.max_pool(self.conv4_3, ksize=[1, 2, 2, 1],\n                                        strides=[1, 1, 1, 1],\n                                        padding='SAME', name='pool4')\n            self.pool4 = tf.space_to_batch(self.pool4,\n                                           paddings=pad, block_size=2)\n        else:\n            self.pool4 = self._max_pool(self.conv4_3, 'pool4', debug)\n\n        self.conv5_1 = self._conv_layer(self.pool4, \"conv5_1\")\n        self.conv5_2 = self._conv_layer(self.conv5_1, \"conv5_2\")\n        self.conv5_3 = self._conv_layer(self.conv5_2, \"conv5_3\")\n        if use_dilated:\n            pad = [[0, 0], [0, 0]]\n            self.pool5 = tf.nn.max_pool(self.conv5_3, ksize=[1, 2, 2, 1],\n                                        strides=[1, 1, 1, 1],\n                                        padding='SAME', name='pool5')\n            self.pool5 = tf.space_to_batch(self.pool5,\n                                           paddings=pad, block_size=2)\n        else:\n            self.pool5 = self._max_pool(self.conv5_3, 'pool5', debug)\n\n        self.fc6 = self._fc_layer(self.pool5, \"fc6\")\n\n        if train:\n            self.fc6 = tf.nn.dropout(self.fc6, 0.5)\n\n        self.fc7 = self._fc_layer(self.fc6, \"fc7\")\n        if train:\n            self.fc7 = tf.nn.dropout(self.fc7, 0.5)\n\n        if use_dilated:\n            self.pool5 = tf.batch_to_space(self.pool5, crops=pad, block_size=2)\n            self.pool5 = tf.batch_to_space(self.pool5, crops=pad, block_size=2)\n            self.fc7 = tf.batch_to_space(self.fc7, crops=pad, block_size=2)\n            self.fc7 = tf.batch_to_space(self.fc7, crops=pad, block_size=2)\n            return\n\n        if random_init_fc8:\n            self.score_fr = self._score_layer(self.fc7, \"score_fr\",\n                                              num_classes)\n        else:\n            self.score_fr = self._fc_layer(self.fc7, \"score_fr\",\n                                           num_classes=num_classes,\n                                           relu=False)\n\n        self.pred = tf.argmax(self.score_fr, dimension=3)\n\n        self.upscore2 = self._upscore_layer(self.score_fr,\n                                            shape=tf.shape(self.pool4),\n                                            num_classes=num_classes,\n                                            debug=debug, name='upscore2',\n                                            ksize=4, stride=2)\n        self.score_pool4 = self._score_layer(self.pool4, \"score_pool4\",\n                                             num_classes=num_classes)\n        self.fuse_pool4 = tf.add(self.upscore2, self.score_pool4)\n\n        self.upscore4 = self._upscore_layer(self.fuse_pool4,\n                                            shape=tf.shape(self.pool3),\n                                            num_classes=num_classes,\n                                            debug=debug, name='upscore4',\n                                            ksize=4, stride=2)\n        self.score_pool3 = self._score_layer(self.pool3, \"score_pool3\",\n                                             num_classes=num_classes)\n        self.fuse_pool3 = tf.add(self.upscore4, self.score_pool3)\n\n        self.upscore32 = self._upscore_layer(self.fuse_pool3,\n                                             shape=tf.shape(bgr),\n                                             num_classes=num_classes,\n                                             debug=debug, name='upscore32',\n                                             ksize=16, stride=8)\n\n        self.pred_up = tf.argmax(self.upscore32, dimension=3)\n\n    def _max_pool(self, bottom, name, debug):\n        pool = tf.nn.max_pool(bottom, ksize=[1, 2, 2, 1], strides=[1, 2, 2, 1],\n                              padding='SAME', name=name)\n\n        if debug:\n            pool = tf.Print(pool, [tf.shape(pool)],\n                            message='Shape of %s' % name,\n                            summarize=4, first_n=1)\n        return pool\n\n    def _conv_layer(self, bottom, name):\n        with tf.variable_scope(name) as scope:\n            filt = self.get_conv_filter(name)\n            conv = tf.nn.conv2d(bottom, filt, [1, 1, 1, 1], padding='SAME')\n\n            conv_biases = self.get_bias(name)\n            bias = tf.nn.bias_add(conv, conv_biases)\n\n            relu = tf.nn.relu(bias)\n            # Add summary to Tensorboard\n            _activation_summary(relu)\n            return relu\n\n    def _fc_layer(self, bottom, name, num_classes=None,\n                  relu=True, debug=False):\n        with tf.variable_scope(name) as scope:\n            shape = bottom.get_shape().as_list()\n\n            if name == 'fc6':\n                filt = self.get_fc_weight_reshape(name, [7, 7, 512, 4096])\n            elif name == 'score_fr':\n                name = 'fc8'  # Name of score_fr layer in VGG Model\n                filt = self.get_fc_weight_reshape(name, [1, 1, 4096, 1000],\n                                                  num_classes=num_classes)\n            else:\n                filt = self.get_fc_weight_reshape(name, [1, 1, 4096, 4096])\n\n            self._add_wd_and_summary(filt, self.wd, \"fc_wlosses\")\n\n            conv = tf.nn.conv2d(bottom, filt, [1, 1, 1, 1], padding='SAME')\n            conv_biases = self.get_bias(name, num_classes=num_classes)\n            bias = tf.nn.bias_add(conv, conv_biases)\n\n            if relu:\n                bias = tf.nn.relu(bias)\n            _activation_summary(bias)\n\n            if debug:\n                bias = tf.Print(bias, [tf.shape(bias)],\n                                message='Shape of %s' % name,\n                                summarize=4, first_n=1)\n            return bias\n\n    def _score_layer(self, bottom, name, num_classes):\n        with tf.variable_scope(name) as scope:\n            # get number of input channels\n            in_features = bottom.get_shape()[3].value\n            shape = [1, 1, in_features, num_classes]\n            # He initialization Sheme\n            if name == \"score_fr\":\n                num_input = in_features\n                stddev = (2 / num_input)**0.5\n            elif name == \"score_pool4\":\n                stddev = 0.001\n            elif name == \"score_pool3\":\n                stddev = 0.0001\n            # Apply convolution\n            w_decay = self.wd\n\n            weights = self._variable_with_weight_decay(shape, stddev, w_decay,\n                                                       decoder=True)\n            conv = tf.nn.conv2d(bottom, weights, [1, 1, 1, 1], padding='SAME')\n            # Apply bias\n            conv_biases = self._bias_variable([num_classes], constant=0.0)\n            bias = tf.nn.bias_add(conv, conv_biases)\n\n            _activation_summary(bias)\n\n            return bias\n\n    def _upscore_layer(self, bottom, shape,\n                       num_classes, name, debug,\n                       ksize=4, stride=2):\n        strides = [1, stride, stride, 1]\n        with tf.variable_scope(name):\n            in_features = bottom.get_shape()[3].value\n\n            if shape is None:\n                # Compute shape out of Bottom\n                in_shape = tf.shape(bottom)\n\n                h = ((in_shape[1] - 1) * stride) + 1\n                w = ((in_shape[2] - 1) * stride) + 1\n                new_shape = [in_shape[0], h, w, num_classes]\n            else:\n                new_shape = [shape[0], shape[1], shape[2], num_classes]\n            output_shape = tf.stack(new_shape)\n\n            logging.debug(\"Layer: %s, Fan-in: %d\" % (name, in_features))\n            f_shape = [ksize, ksize, num_classes, in_features]\n\n            # create\n            num_input = ksize * ksize * in_features / stride\n            stddev = (2 / num_input)**0.5\n\n            weights = self.get_deconv_filter(f_shape)\n            self._add_wd_and_summary(weights, self.wd, \"fc_wlosses\")\n            deconv = tf.nn.conv2d_transpose(bottom, weights, output_shape,\n                                            strides=strides, padding='SAME')\n\n            if debug:\n                deconv = tf.Print(deconv, [tf.shape(deconv)],\n                                  message='Shape of %s' % name,\n                                  summarize=4, first_n=1)\n\n        _activation_summary(deconv)\n        return deconv\n\n    def get_deconv_filter(self, f_shape):\n        width = f_shape[0]\n        height = f_shape[1]\n        f = ceil(width/2.0)\n        c = (2 * f - 1 - f % 2) / (2.0 * f)\n        bilinear = np.zeros([f_shape[0], f_shape[1]])\n        for x in range(width):\n            for y in range(height):\n                value = (1 - abs(x / f - c)) * (1 - abs(y / f - c))\n                bilinear[x, y] = value\n        weights = np.zeros(f_shape)\n        for i in range(f_shape[2]):\n            weights[:, :, i, i] = bilinear\n\n        init = tf.constant_initializer(value=weights,\n                                       dtype=tf.float32)\n        var = tf.get_variable(name=\"up_filter\", initializer=init,\n                              shape=weights.shape)\n        return var\n\n    def get_conv_filter(self, name):\n        init = tf.constant_initializer(value=self.data_dict[name][0],\n                                       dtype=tf.float32)\n        shape = self.data_dict[name][0].shape\n        print('Layer name: %s' % name)\n        print('Layer shape: %s' % str(shape))\n        var = tf.get_variable(name=\"filter\", initializer=init, shape=shape)\n        if not tf.get_variable_scope().reuse:\n            weight_decay = tf.multiply(tf.nn.l2_loss(var), self.wd,\n                                       name='weight_loss')\n            tf.add_to_collection(tf.GraphKeys.REGULARIZATION_LOSSES,\n                                 weight_decay)\n        _variable_summaries(var)\n        return var\n\n    def get_bias(self, name, num_classes=None):\n        bias_wights = self.data_dict[name][1]\n        shape = self.data_dict[name][1].shape\n        if name == 'fc8':\n            bias_wights = self._bias_reshape(bias_wights, shape[0],\n                                             num_classes)\n            shape = [num_classes]\n        init = tf.constant_initializer(value=bias_wights,\n                                       dtype=tf.float32)\n        var = tf.get_variable(name=\"biases\", initializer=init, shape=shape)\n        _variable_summaries(var)\n        return var\n\n    def get_fc_weight(self, name):\n        init = tf.constant_initializer(value=self.data_dict[name][0],\n                                       dtype=tf.float32)\n        shape = self.data_dict[name][0].shape\n        var = tf.get_variable(name=\"weights\", initializer=init, shape=shape)\n        if not tf.get_variable_scope().reuse:\n            weight_decay = tf.multiply(tf.nn.l2_loss(var), self.wd,\n                                       name='weight_loss')\n            tf.add_to_collection(tf.GraphKeys.REGULARIZATION_LOSSES,\n                                 weight_decay)\n        _variable_summaries(var)\n        return var\n\n    def _bias_reshape(self, bweight, num_orig, num_new):\n        \"\"\" Build bias weights for filter produces with `_summary_reshape`\n\n        \"\"\"\n        n_averaged_elements = num_orig//num_new\n        avg_bweight = np.zeros(num_new)\n        for i in range(0, num_orig, n_averaged_elements):\n            start_idx = i\n            end_idx = start_idx + n_averaged_elements\n            avg_idx = start_idx//n_averaged_elements\n            if avg_idx == num_new:\n                break\n            avg_bweight[avg_idx] = np.mean(bweight[start_idx:end_idx])\n        return avg_bweight\n\n    def _summary_reshape(self, fweight, shape, num_new):\n        \"\"\" Produce weights for a reduced fully-connected layer.\n\n        FC8 of VGG produces 1000 classes. Most semantic segmentation\n        task require much less classes. This reshapes the original weights\n        to be used in a fully-convolutional layer which produces num_new\n        classes. To archive this the average (mean) of n adjanced classes is\n        taken.\n\n        Consider reordering fweight, to perserve semantic meaning of the\n        weights.\n\n        Args:\n          fweight: original weights\n          shape: shape of the desired fully-convolutional layer\n          num_new: number of new classes\n\n\n        Returns:\n          Filter weights for `num_new` classes.\n        \"\"\"\n        num_orig = shape[3]\n        shape[3] = num_new\n        assert(num_new < num_orig)\n        n_averaged_elements = num_orig//num_new\n        avg_fweight = np.zeros(shape)\n        for i in range(0, num_orig, n_averaged_elements):\n            start_idx = i\n            end_idx = start_idx + n_averaged_elements\n            avg_idx = start_idx//n_averaged_elements\n            if avg_idx == num_new:\n                break\n            avg_fweight[:, :, :, avg_idx] = np.mean(\n                fweight[:, :, :, start_idx:end_idx], axis=3)\n        return avg_fweight\n\n    def _variable_with_weight_decay(self, shape, stddev, wd, decoder=False):\n        \"\"\"Helper to create an initialized Variable with weight decay.\n\n        Note that the Variable is initialized with a truncated normal\n        distribution.\n        A weight decay is added only if one is specified.\n\n        Args:\n          name: name of the variable\n          shape: list of ints\n          stddev: standard deviation of a truncated Gaussian\n          wd: add L2Loss weight decay multiplied by this float. If None, weight\n              decay is not added for this Variable.\n\n        Returns:\n          Variable Tensor\n        \"\"\"\n\n        initializer = tf.truncated_normal_initializer(stddev=stddev)\n        var = tf.get_variable('weights', shape=shape,\n                              initializer=initializer)\n\n        collection_name = tf.GraphKeys.REGULARIZATION_LOSSES\n        if wd and (not tf.get_variable_scope().reuse):\n            weight_decay = tf.multiply(\n                tf.nn.l2_loss(var), wd, name='weight_loss')\n            tf.add_to_collection(collection_name, weight_decay)\n        _variable_summaries(var)\n        return var\n\n    def _add_wd_and_summary(self, var, wd, collection_name=None):\n        if collection_name is None:\n            collection_name = tf.GraphKeys.REGULARIZATION_LOSSES\n        if wd and (not tf.get_variable_scope().reuse):\n            weight_decay = tf.multiply(\n                tf.nn.l2_loss(var), wd, name='weight_loss')\n            tf.add_to_collection(collection_name, weight_decay)\n        _variable_summaries(var)\n        return var\n\n    def _bias_variable(self, shape, constant=0.0):\n        initializer = tf.constant_initializer(constant)\n        var = tf.get_variable(name='biases', shape=shape,\n                              initializer=initializer)\n        _variable_summaries(var)\n        return var\n\n    def get_fc_weight_reshape(self, name, shape, num_classes=None):\n        print('Layer name: %s' % name)\n        print('Layer shape: %s' % shape)\n        weights = self.data_dict[name][0]\n        weights = weights.reshape(shape)\n        if num_classes is not None:\n            weights = self._summary_reshape(weights, shape,\n                                            num_new=num_classes)\n        init = tf.constant_initializer(value=weights,\n                                       dtype=tf.float32)\n        var = tf.get_variable(name=\"weights\", initializer=init, shape=shape)\n        return var\n\n\ndef _activation_summary(x):\n    \"\"\"Helper to create summaries for activations.\n\n    Creates a summary that provides a histogram of activations.\n    Creates a summary that measure the sparsity of activations.\n\n    Args:\n      x: Tensor\n    Returns:\n      nothing\n    \"\"\"\n    # Remove 'tower_[0-9]/' from the name in case this is a multi-GPU training\n    # session. This helps the clarity of presentation on tensorboard.\n    tensor_name = x.op.name\n    # tensor_name = re.sub('%s_[0-9]*/' % TOWER_NAME, '', x.op.name)\n    tf.summary.histogram(tensor_name + '/activations', x)\n    tf.summary.scalar(tensor_name + '/sparsity', tf.nn.zero_fraction(x))\n\n\ndef _variable_summaries(var):\n    \"\"\"Attach a lot of summaries to a Tensor.\"\"\"\n    if not tf.get_variable_scope().reuse:\n        name = var.op.name\n        logging.info(\"Creating Summary for: %s\" % name)\n        with tf.name_scope('summaries'):\n            mean = tf.reduce_mean(var)\n            tf.summary.scalar(name + '/mean', mean)\n            with tf.name_scope('stddev'):\n                stddev = tf.sqrt(tf.reduce_sum(tf.square(var - mean)))\n            tf.summary.scalar(name + '/sttdev', stddev)\n            tf.summary.scalar(name + '/max', tf.reduce_max(var))\n            tf.summary.scalar(name + '/min', tf.reduce_min(var))\n            tf.summary.histogram(name, var)\n```\n\n##### fcn 调包\n\n```python\nimport torch.nn as nn\nimport torch.nn.functional as F\nfrom abc import ABCMeta\nimport torchvision.models as models\n\n\ndef _maybe_pad(x, size):\n    hpad = size[0] - x.shape[2]\n    wpad = size[1] - x.shape[3]\n    if hpad + wpad > 0:\n        x = F.pad(x, (0, wpad, 0, hpad, 0, 0, 0, 0 ))\n    return x\n\n\nclass VGGFCN(nn.Module, metaclass=ABCMeta):\n    def __init__(self, in_channels, n_classes):\n        super().__init__()\n        assert in_channels == 3\n        self.n_classes = n_classes\n        self.vgg16 = models.vgg16(pretrained=True)\n        self.classifier = nn.Sequential(\n            nn.Conv2d(512, 4096, kernel_size=7, padding=3),\n            nn.ReLU(True),\n            nn.Dropout(),\n            nn.Conv2d(4096, 4096, kernel_size=1),\n            nn.ReLU(True),\n            nn.Dropout(),\n            nn.Conv2d(4096, n_classes, kernel_size=1),\n        )\n\n        self._initialize_weights()\n\n    def _initialize_weights(self):\n        self.classifier[0].weight.data = (\n            self.vgg16.classifier[0].weight.data.view(\n                self.classifier[0].weight.size())\n        )\n        self.classifier[3].weight.data = (\n            self.vgg16.classifier[3].weight.data.view(\n                self.classifier[3].weight.size())\n        )\n\n\nclass VGGFCN32(VGGFCN):\n    def forward(self, x):\n        input_height, input_width = x.shape[2], x.shape[3]\n        x = self.vgg16.features(x)\n        x = self.classifier(x)\n        x = F.interpolate(x, size=(input_height, input_width),\n                          mode='bilinear', align_corners=True)\n        return x\n\n\nclass VGGFCN16(VGGFCN):\n    def __init__(self, in_channels, n_classes):\n        super().__init__(in_channels, n_classes)\n        self.score4 = nn.Conv2d(512, n_classes, kernel_size=1)\n        self.upscale5 = nn.ConvTranspose2d(\n            n_classes, n_classes, kernel_size=2, stride=2)\n\n    def forward(self, x):\n        input_height, input_width = x.shape[2], x.shape[3]\n        pool4 = self.vgg16.features[:-7](x)\n        pool5 = self.vgg16.features[-7:](pool4)\n        pool5_upscaled = self.upscale5(self.classifier(pool5))\n        pool4 = self.score4(pool4)\n        x = pool4 + pool5_upscaled\n        x = F.interpolate(x, size=(input_height, input_width),\n                          mode='bilinear', align_corners=True)\n        return x\n\n\nclass VGGFCN8(VGGFCN):\n    def __init__(self, in_channels, n_classes):\n        super().__init__(in_channels, n_classes)\n        self.upscale4 = nn.ConvTranspose2d(\n            n_classes, n_classes, kernel_size=2, stride=2)\n        self.score4 = nn.Conv2d(\n            512, n_classes, kernel_size=1, stride=1)\n        self.score3 = nn.Conv2d(\n            256, n_classes, kernel_size=1, stride=1)\n        self.upscale5 = nn.ConvTranspose2d(\n            n_classes, n_classes, kernel_size=2, stride=2)\n\n    def forward(self, x):\n        input_height, input_width = x.shape[2], x.shape[3]\n        pool3 = self.vgg16.features[:-14](x)\n        pool4 = self.vgg16.features[-14:-7](pool3)\n        pool5 = self.vgg16.features[-7:](pool4)\n        pool5_upscaled = self.upscale5(self.classifier(pool5))\n        pool5_upscaled = _maybe_pad(pool5_upscaled, pool4.shape[2:])\n        pool4_scores = self.score4(pool4)\n        pool4_fused = pool4_scores + pool5_upscaled\n        pool4_upscaled = self.upscale4(pool4_fused)\n        pool4_upscaled = _maybe_pad(pool4_upscaled, pool3.shape[2:])\n        x = self.score3(pool3) + pool4_upscaled\n        x = F.interpolate(x, size=(input_height, input_width),\n                          mode='bilinear', align_corners=True)\n        return x\n```\n\n#### 相关资源\n\n### **U-Net**\n\n- **优点**：简单易用，适用于小数据集，尤其在医学图像分割中表现良好。\n- **缺点**：容易过拟合，不太适合大规模数据集。\n\n![1740236677445SwkUbDFUtolVEKxc4dmcbrOknJf.png](https://tk-pichost-1325224430.cos.ap-chengdu.myqcloud.com/blog/1740236677445SwkUbDFUtolVEKxc4dmcbrOknJf.png)\n\n#### 提出初衷\n\nU-Net 是一种经典且广泛使用的分割模型，以其简单、高效、易于理解和构建的特点而受到青睐，尤其适合从小数据集中进行训练。该模型最早于 2015 年在论文《U-Net: Convolutional Networks for Biomedical Image Segmentation》中被提出，至今仍然是医学图像分割领域的重要基础模型。\n\n![1740236700448YM2HbihrkonVkixR0KdcPLcBnLc.png](https://tk-pichost-1325224430.cos.ap-chengdu.myqcloud.com/blog/1740236700448YM2HbihrkonVkixR0KdcPLcBnLc.png)\n\n![1740236696443Voorb6LuJopG3exmtulcaySynjc.png](https://tk-pichost-1325224430.cos.ap-chengdu.myqcloud.com/blog/1740236696443Voorb6LuJopG3exmtulcaySynjc.png)\n\n![1740236682500NfPrbS5SNoEjsFxFFptcl471nhb.png](https://tk-pichost-1325224430.cos.ap-chengdu.myqcloud.com/blog/1740236682500NfPrbS5SNoEjsFxFFptcl471nhb.png)\n\n1. Unet 提出的初衷是为了解决医学图像分割的问题；\n2. 一种 U 型的网络结构来获取上下文的信息和位置信息；\n3. 在 2015 年的 ISBI cell tracking 比赛中获得了多个第一，一开始这是为了解决细胞层面的分割的任务的\n\n#### 网络结构\n\n![1740236655458N3Vab29uNorFHwxpINwc5s6unkh.png](https://tk-pichost-1325224430.cos.ap-chengdu.myqcloud.com/blog/1740236655458N3Vab29uNorFHwxpINwc5s6unkh.png)\n\nU-Net 网络是一种经典的编码器-解码器结构，因其整体结构形似大写的英文字母“U”而得名。它广泛应用于医学图像分割等领域。U-Net 的设计非常简洁：前半部分用于特征提取（编码器），后半部分用于上采样（解码器）。\n\n##### 编码器（Encoder）\n\n编码器位于网络的左半部分，主要由多个下采样模块组成。每个模块包含两个 3×3 的卷积层（激活函数为 ReLU），后接一个 2×2 的最大池化（Max Pooling）层，用于特征提取和空间尺寸的减半。通过这种结构，编码器能够逐步提取图像的深层特征，同时扩大感受野。\n\n##### 解码器（Decoder）\n\n解码器位于网络的右半部分，主要由上采样模块组成。每个模块包含一个 2×2 的反卷积层（上采样卷积层），用于将特征图的空间尺寸恢复到与编码器对应层相同的大小。随后，解码器通过特征拼接（concatenation）将上采样后的特征图与编码器中对应层的特征图进行通道级拼接，最后通过两个 3×3 的卷积层（激活函数为 ReLU）进一步融合特征。这种结构能够有效地结合深层特征和浅层特征，兼顾全局语义信息和局部细节。\n\n##### 特征融合方式\n\n与 FCN 网络通过特征图对应像素值的相加来融合特征不同，U-Net 采用通道级拼接的方式。这种方式可以形成更厚的特征图，从而保留更多的细节信息，但也增加了显存的消耗。\n\n### U-Net 的优点\n\n1. **多尺度特征融合**：U-Net 通过拼接深层和浅层特征图，能够充分利用不同层次的特征。浅层卷积关注纹理和细节特征，而深层网络关注更高级的语义特征。这种融合方式使得模型能够更好地处理复杂的分割任务。\n2. **边缘特征的保留**：在下采样过程中，虽然会损失一些边缘特征，但通过特征拼接，解码器能够从编码器的浅层特征中找回这些丢失的边缘信息，从而提高分割的精度。\n\nUnet 的好处我感觉是：网络层越深得到的特征图，有着更大的视野域，浅层卷积关注纹理特征，深层网络关注本质的那种特征，所以深层浅层特征都是有格子的意义的；另外一点是通过反卷积得到的更大的尺寸的特征图的边缘，是缺少信息的，毕竟每一次下采样提炼特征的同时，也必然会损失一些边缘特征，而失去的特征并不能从上采样中找回，因此通过特征的拼接，来实现边缘特征的一个找回。\n\n下面是一些与医学相关的数据集以及对应的提取码,有兴趣的同学可以下载下来跑一下。\n\n<table>\n<tr>\n<td>**数据集名称**<br/></td><td>**下载链接**<td>**提取码**<br/></td></tr>\n<tr>\n<td>Cell dataset (dsb2018)<br/></td><td>https://pan.baidu.com/share/init?surl=BaVrzYdrSP78CwYaRzZr1w<td>5l54<br/></td></tr>\n<tr>\n<td>Liver dataset<br/></td><td>https://pan.baidu.com/share/init?surl=FljGCVzu7HPYpwAKvSVN4Q<td>5l88<br/></td></tr>\n<tr>\n<td>Cell dataset (isbi)<br/></td><td>https://pan.baidu.com/share/init?surl=FkfnhU-RnYFZti62-f8AVA<td>14rz<br/></td></tr>\n<tr>\n<td>Lung dataset<br/></td><td>https://pan.baidu.com/share/init?surl=sLFRmtG2TOTEgUKniJf7AA<td>qdwo<br/></td></tr>\n<tr>\n<td>Corneal Nerve dataset<br/></td><td>https://pan.baidu.com/share/init?surl=T3-kS_FgYI6DeXv3n1I7bA<td>ih02<br/></td></tr>\n<tr>\n<td>Eye Vessels (DRIVE dataset)<br/></td><td>https://pan.baidu.com/share/init?surl=UkMLmdbM61N8ecgnKlAsPg<td>f1ek<br/></td></tr>\n<tr>\n<td>Esophagus and Esophagus Cancer dataset (First Affiliated Hospital of Sun Yat-sen University)<br/></td><td>https://pan.baidu.com/share/init?surl=0b5arIQjNpiggwdkgYNHXQ<td>hivm<br/></td></tr>\n</table>\n\n#### 为什么 Unet 在医疗图像分割中表现好?\n\n大多数医疗影像语义分割任务都会首先用 Unet 作为 baseline，当然上一章节讲解的 Unet 的优点肯定是可以当作这个问题的答案，这里谈一谈医疗影像的特点\n\n根据网友的讨论，得到的结果：\n\n1. 医疗影像语义较为简单、结构固定。因此语义信息相比自动驾驶等较为单一，因此并不需要去筛选过滤无用的信息。医疗影像的所有特征都很重要，因此低级特征和高级语义特征都很重要，所以 U 型结构的 skip connection 结构（特征拼接）更好派上用场\n2. 医学影像的数据较少，获取难度大，数据量可能只有几百甚至不到 100，因此如果使用大型的网络例如 DeepLabv3+ 等模型，很容易过拟合。大型网络的优点是更强的图像表述能力，而较为简单、数量少的医学影像并没有那么多的内容需要表述，因此也有人发现在小数量级中，分割的 SOTA 模型与轻量的 Unet 并没有神恶魔优势\n3. 医学影像往往是多模态的。比方说 ISLES 脑梗竞赛中，官方提供了 CBF，MTT，CBV 等多中模态的数据（这一点听不懂也无妨）。因此医学影像任务中，往往需要自己设计网络去提取不同的模态特征，因此轻量结构简单的 Unet 可以有更大的操作空间。\n\n> Q:过拟合与模型复杂程度有关还和什么有关呢?\n\n#### 模型代码\n\n##### 源码\n\n```python\nimport torch.nn as nn\nimport torch\nfrom torch import autograd\nfrom functools import partial\nimport torch.nn.functional as F\nfrom torchvision import models\n\nclass DoubleConv(nn.Module):\n    def __init__(self, in_ch, out_ch):\n        super(DoubleConv, self).__init__()\n        self.**conv** = nn.Sequential(\n            nn.Conv2d(in_ch, out_ch, 3, _padding_=1),\n            nn.BatchNorm2d(out_ch),\n            nn.ReLU(_inplace_=True),\n            nn.Conv2d(out_ch, out_ch, 3, _padding_=1),\n            nn.BatchNorm2d(out_ch),\n            nn.ReLU(_inplace_=True)\n        )\n\n    def forward(self, input):\n        return self.**conv**(input)\n\nclass Unet(nn.Module):\n    def __init__(self, in_ch, out_ch):\n        super(Unet, self).__init__()\n\n        self.**conv1** = DoubleConv(in_ch, 32)\n        self.**pool1** = nn.MaxPool2d(2)\n        self.**conv2** = DoubleConv(32, 64)\n        self.**pool2** = nn.MaxPool2d(2)\n        self.**conv3** = DoubleConv(64, 128)\n        self.**pool3** = nn.MaxPool2d(2)\n        self.**conv4** = DoubleConv(128, 256)\n        self.**pool4** = nn.MaxPool2d(2)\n        self.**conv5** = DoubleConv(256, 512)\n        self.**up6** = nn.ConvTranspose2d(512, 256, 2, _stride_=2)\n        self.**conv6** = DoubleConv(512, 256)\n        self.**up7** = nn.ConvTranspose2d(256, 128, 2, _stride_=2)\n        self.**conv7** = DoubleConv(256, 128)\n        self.**up8** = nn.ConvTranspose2d(128, 64, 2, _stride_=2)\n        self.**conv8** = DoubleConv(128, 64)\n        self.**up9** = nn.ConvTranspose2d(64, 32, 2, _stride_=2)\n        self.**conv9** = DoubleConv(64, 32)\n        self.**conv10** = nn.Conv2d(32, out_ch, 1)\n\n    def forward(self, x):\n        _#print(x.shape)_\n        c1 = self.**conv1**(x)\n        p1 = self.**pool1**(c1)\n        _#print(p1.shape)_\n        c2 = self.**conv2**(p1)\n        p2 = self.**pool2**(c2)\n        _#print(p2.shape)_\n        c3 = self.**conv3**(p2)\n        p3 = self.**pool3**(c3)\n        _#print(p3.shape)_\n        c4 = self.**conv4**(p3)\n        p4 = self.**pool4**(c4)\n        _#print(p4.shape)_\n        c5 = self.**conv5**(p4)\n        up_6 = self.**up6**(c5)\n        merge6 = torch.cat([up_6, c4], _dim_=1)\n        c6 = self.**conv6**(merge6)\n        up_7 = self.**up7**(c6)\n        merge7 = torch.cat([up_7, c3], _dim_=1)\n        c7 = self.**conv7**(merge7)\n        up_8 = self.**up8**(c7)\n        merge8 = torch.cat([up_8, c2], _dim_=1)\n        c8 = self.**conv8**(merge8)\n        up_9 = self.**up9**(c8)\n        merge9 = torch.cat([up_9, c1], _dim_=1)\n        c9 = self.**conv9**(merge9)\n        c10 = self.**conv10**(c9)\n        out = nn.Sigmoid()(c10)\n        return out\n\nnonlinearity = partial(F.relu, _inplace_=True)\nclass DecoderBlock(nn.Module):\n    def __init__(self, in_channels, n_filters):\n        super(DecoderBlock, self).__init__()\n\n        self.**conv1** = nn.Conv2d(in_channels, in_channels // 4, 1)\n        self.**norm1** = nn.BatchNorm2d(in_channels // 4)\n        self.**relu1** = nonlinearity\n\n        self.**deconv2** = nn.ConvTranspose2d(in_channels // 4, in_channels // 4, 3, _stride_=2, _padding_=1, _output_padding_=1)\n        self.**norm2** = nn.BatchNorm2d(in_channels // 4)\n        self.**relu2** = nonlinearity\n\n        self.**conv3** = nn.Conv2d(in_channels // 4, n_filters, 1)\n        self.**norm3** = nn.BatchNorm2d(n_filters)\n        self.**relu3** = nonlinearity\n\n    def forward(self, x):\n        x = self.**conv1**(x)\n        x = self.**norm1**(x)\n        x = self.**relu1**(x)\n        x = self.**deconv2**(x)\n        x = self.**norm2**(x)\n        x = self.**relu2**(x)\n        x = self.**conv3**(x)\n        x = self.**norm3**(x)\n        x = self.**relu3**(x)\n        return x\n\nclass resnet34_unet(nn.Module):\n    def __init__(self, num_classes=1, num_channels=3,pretrained=True):\n        super(resnet34_unet, self).__init__()\n\n        filters = [64, 128, 256, 512]\n        resnet = models.resnet34(_pretrained_=pretrained)\n        self.**firstconv** = resnet.**conv1**\n        self.**firstbn** = resnet.**bn1**\n        self.**firstrelu** = resnet.**relu**\n        self.**firstmaxpool** = resnet.**maxpool**\n        self.**encoder1** = resnet.**layer1**\n        self.**encoder2** = resnet.**layer2**\n        self.**encoder3** = resnet.**layer3**\n        self.**encoder4** = resnet.**layer4**\n\n        self.**decoder4** = DecoderBlock(512, filters[2])\n        self.**decoder3** = DecoderBlock(filters[2], filters[1])\n        self.**decoder2** = DecoderBlock(filters[1], filters[0])\n        self.**decoder1** = DecoderBlock(filters[0], filters[0])\n\n        self.**decoder4** = DecoderBlock(512, filters[2])\n        self.**decoder3** = DecoderBlock(filters[2], filters[1])\n        self.**decoder2** = DecoderBlock(filters[1], filters[0])\n        self.**decoder1** = DecoderBlock(filters[0], filters[0])\n\n        self.**finaldeconv1** = nn.ConvTranspose2d(filters[0], 32, 4, 2, 1)\n        self.**finalrelu1** = nonlinearity\n        self.**finalconv2** = nn.Conv2d(32, 32, 3, _padding_=1)\n        self.**finalrelu2** = nonlinearity\n        self.**finalconv3** = nn.Conv2d(32, num_classes, 3, _padding_=1)\n\n    def forward(self, x):\n        _# Encoder_\n        x = self.**firstconv**(x)\n        x = self.**firstbn**(x)\n        x = self.**firstrelu**(x)\n        x = self.**firstmaxpool**(x)\n        e1 = self.**encoder1**(x)\n        e2 = self.**encoder2**(e1)\n        e3 = self.**encoder3**(e2)\n        e4 = self.**encoder4**(e3)\n\n        _# Center_\n\n        _# Decoder_\n        d4 = self.**decoder4**(e4) + e3\n        d3 = self.**decoder3**(d4) + e2\n        d2 = self.**decoder2**(d3) + e1\n        d1 = self.**decoder1**(d2)\n\n        out = self.**finaldeconv1**(d1)\n        out = self.**finalrelu1**(out)\n        out = self.**finalconv2**(out)\n        out = self.**finalrelu2**(out)\n        out = self.**finalconv3**(out)\n\n        return nn.Sigmoid()(out)\n```\n\n##### 模型实现\n\n```python\nimport torch\nimport torch.nn as nn\nimport torch.nn.functional as F\n\nclass double_conv2d_bn(nn.Module):\n    def __init__(self,in_channels,out_channels,kernel_size=3,strides=1,padding=1):\n        super(double_conv2d_bn,self).__init__()\n        self.conv1 = nn.Conv2d(in_channels,out_channels,\n                               kernel_size=kernel_size,\n                              stride = strides,padding=padding,bias=True)\n        self.conv2 = nn.Conv2d(out_channels,out_channels,\n                              kernel_size = kernel_size,\n                              stride = strides,padding=padding,bias=True)\n        self.bn1 = nn.BatchNorm2d(out_channels)\n        self.bn2 = nn.BatchNorm2d(out_channels)\n  \n    def forward(self,x):\n        out = F.relu(self.bn1(self.conv1(x)))\n        out = F.relu(self.bn2(self.conv2(out)))\n        return out\n  \nclass deconv2d_bn(nn.Module):\n    def __init__(self,in_channels,out_channels,kernel_size=2,strides=2):\n        super(deconv2d_bn,self).__init__()\n        self.conv1 = nn.ConvTranspose2d(in_channels,out_channels,\n                                        kernel_size = kernel_size,\n                                       stride = strides,bias=True)\n        self.bn1 = nn.BatchNorm2d(out_channels)\n      \n    def forward(self,x):\n        out = F.relu(self.bn1(self.conv1(x)))\n        return out\n  \nclass Unet(nn.Module):\n    def __init__(self):\n        super(Unet,self).__init__()\n        self.layer1_conv = double_conv2d_bn(1,8)\n        self.layer2_conv = double_conv2d_bn(8,16)\n        self.layer3_conv = double_conv2d_bn(16,32)\n        self.layer4_conv = double_conv2d_bn(32,64)\n        self.layer5_conv = double_conv2d_bn(64,128)\n        self.layer6_conv = double_conv2d_bn(128,64)\n        self.layer7_conv = double_conv2d_bn(64,32)\n        self.layer8_conv = double_conv2d_bn(32,16)\n        self.layer9_conv = double_conv2d_bn(16,8)\n        self.layer10_conv = nn.Conv2d(8,1,kernel_size=3,\n                                     stride=1,padding=1,bias=True)\n      \n        self.deconv1 = deconv2d_bn(128,64)\n        self.deconv2 = deconv2d_bn(64,32)\n        self.deconv3 = deconv2d_bn(32,16)\n        self.deconv4 = deconv2d_bn(16,8)\n      \n        self.sigmoid = nn.Sigmoid()\n      \n    def forward(self,x):\n        conv1 = self.layer1_conv(x)\n        pool1 = F.max_pool2d(conv1,2)\n      \n        conv2 = self.layer2_conv(pool1)\n        pool2 = F.max_pool2d(conv2,2)\n      \n        conv3 = self.layer3_conv(pool2)\n        pool3 = F.max_pool2d(conv3,2)\n      \n        conv4 = self.layer4_conv(pool3)\n        pool4 = F.max_pool2d(conv4,2)\n      \n        conv5 = self.layer5_conv(pool4)\n      \n        convt1 = self.deconv1(conv5)\n        concat1 = torch.cat([convt1,conv4],dim=1)\n        conv6 = self.layer6_conv(concat1)\n      \n        convt2 = self.deconv2(conv6)\n        concat2 = torch.cat([convt2,conv3],dim=1)\n        conv7 = self.layer7_conv(concat2)\n      \n        convt3 = self.deconv3(conv7)\n        concat3 = torch.cat([convt3,conv2],dim=1)\n        conv8 = self.layer8_conv(concat3)\n      \n        convt4 = self.deconv4(conv8)\n        concat4 = torch.cat([convt4,conv1],dim=1)\n        conv9 = self.layer9_conv(concat4)\n        outp = self.layer10_conv(conv9)\n        outp = self.sigmoid(outp)\n        return outp\n  \n\nmodel = Unet()\ninp = torch.rand(10,1,224,224)\noutp = model(inp)\nprint(outp.shape)\n==> torch.Size([10, 1, 224, 224])\n```\n\n#### 相关资源\n\n##### 项目\n\n> https://github.com/Andy-zhujunwen/UNET-ZOO?tab=readme-ov-file`<br>`\n> https://github.com/bigmb/Unet-Segmentation-Pytorch-Nest-of-Unets`<br>`\n> https://www.codewithgpu.com/i/bubbliiiing/unet-pytorch/UNet-PyTorch`<br>`\n> https://huggingface.co/spaces/h2chen/demo_unet\n\n##### 博客\n\n> [UNet详解（附图文和代码实现）-CSDN博客](https://blog.csdn.net/weixin_45074568/article/details/114901600)`<br>`\n> [图像分割必备知识点 | Unet详解 理论+ 代码 - 忽逢桃林 - 博客园](https://www.cnblogs.com/PythonLearner/p/14041874.html)\n\n---\n","source":"_posts/2025-02-15-语义分割.md","raw":"---\ntitle: 2025-02-15-语义分割\ndate: 2025-02-15\ntags: 深度学习\n---\n# 前言\n\n在开始这篇文章之前，我们得首先弄明白，什么是图像分割？\n\n我们知道一个图像只不过是许多像素的集合。图像分割分类是对图像中属于特定类别的像素进行分类的过程，即像素级别的下游任务。因此图像分割简单来说就是按像素进行分类的问题。\n\n传统的图像分割算法均是基于灰度值的不连续和相似的性质。而基于深度学习的图像分割技术则是利用卷积神经网络，来理解图像中的每个像素所代表的真实世界物体，这在以前是难以想象的。\n\n![1740235822031FRBrbtq8Zogp1oxNSIhcx7Z6nVb.png](https://tk-pichost-1325224430.cos.ap-chengdu.myqcloud.com/blog/1740235822031FRBrbtq8Zogp1oxNSIhcx7Z6nVb.png)\n\n# **语义分割（Semantic Segmentation）**\n\n## ** 定义**\n\n“语义”是个很抽象的概念，在 2D 图像领域，每个像素点作为最小单位，它的像素值代表的就是一个特征，即“语义”信息。语义分割会为图像中的每个像素分配一个类别，但是同一类别之间的对象不会区分。而实例分割，只对特定的物体进行分类。这看起来与目标检测相似，不同的是目标检测输出目标的边界框和类别，实例分割输出的是目标的 Mask 和类别。具体而言，语义分割的目的是为了从像素级别理解图像的内容，并为图像中的每个像素分配一个对象类。\n\n语义分割是一种将图像中的每个像素分配给特定类别的技术。其目标是识别图像中存在的各种对象和背景，并为每个像素分配相应的类别标签。例如，将图像中的像素划分为人、树、草地和天空等不同区域。是图像处理和机器视觉一个重要分支。与分类任务不同，语义分割需要判断图像每个像素点的类别，进行精确分割。语义分割目前在自动驾驶、自动抠图、医疗影像等领域有着比较广泛的应用。\n\n## ** 特点**\n\n- 提供精确的像素级分类，有助于深入理解图像内容。\n- 无法区分同一类别中的不同实例。\n\n## ** 语义分割的应用**\n\n语义分割在多个领域有广泛应用：\n\n- **自动驾驶**：用于道路、车辆和行人的识别。\n- **医学成像**：用于组织和器官的分割。\n- **卫星遥感**：用于土地覆盖分类。\n\n## ** 常见模型**\n\n### **FCN（Fully Convolutional Network）**\n\n- **优点**：简单易用，但是现在已经很少使用了,但它的历史贡献不可忽视。\n- **缺点**：分割精度较低，可能无法很好地处理细节。\n\n#### 提出初衷\n\n![1740236704772Z5SNbToLOosLf9xBvllcevjVnEe.png](https://tk-pichost-1325224430.cos.ap-chengdu.myqcloud.com/blog/1740236704772Z5SNbToLOosLf9xBvllcevjVnEe.png)\nFCN（全卷积网络）模型的初衷是为了解决传统卷积神经网络（CNN）在语义分割任务中的局限性。具体而言，传统 CNN 使用全连接层进行分类，这会丢失图像的空间位置信息，导致其不适合像素级的预测任务。FCN 的核心动机包括：\n\n1. **实现端到端的像素级预测**：FCN 通过将全连接层替换为卷积层，使得网络能够接受任意尺寸的输入图像，并输出与输入尺寸相同的像素级预测结果。\n2. **保留空间信息**：取消全连接层后，FCN 能够保留图像的空间位置信息，从而更好地适应语义分割任务。\n3. **提高分割效率和精度**：通过引入反卷积层（上采样层）和跳跃连接（Skip Connections），FCN 能够融合不同深度的特征，兼顾全局语义信息和局部细节，从而提升分割精度。\n4. **利用预训练模型加速训练**：FCN 可以基于预训练的分类模型（如 AlexNet、VGG 等）进行微调，从而显著加速训练过程并提高模型性能。\n\n#### 网络结构\n\n![1740236686503VcqtbHWWQoRtJIxgy6bconZQnHc.png](https://tk-pichost-1325224430.cos.ap-chengdu.myqcloud.com/blog/1740236686503VcqtbHWWQoRtJIxgy6bconZQnHc.png)\n通常 CNN 网络在卷积层之后会接上若干个全连接层, 将卷积层产生的特征图(feature map)映射成一个固定长度的特征向量。以 AlexNet 为代表的经典 CNN 结构适合于图像级的分类和回归任务，因为它们最后都期望得到整个输入图像的一个数值描述（概率）。\nFCN 对图像进行像素级的分类，从而解决了语义级别的图像分割（semantic segmentation）问题。与经典的 CNN 在卷积层之后使用全连接层得到固定长度的特征向量进行分类（全连接层 ＋softmax 输出）不同，FCN 可以接受任意尺寸的输入图像，采用反卷积层对最后一个卷积层的 feature map 进行上采样, 使它恢复到输入图像相同的尺寸，从而可以对每个像素都产生了一个预测, 同时保留了原始输入图像中的空间信息, 最后在上采样的特征图上进行逐像素分类。\n![1740236781446CxZ6b4zcXo9A12xuNJtcEgA7nfc.png](https://tk-pichost-1325224430.cos.ap-chengdu.myqcloud.com/blog/1740236781446CxZ6b4zcXo9A12xuNJtcEgA7nfc.png)\nFCN（全卷积网络）为了解决语义分割（semantic segmentation）问题而提出，它对图像进行像素级的分类，能够保留原始输入图像中的空间信息。与传统 CNN 不同，FCN 可以接受任意尺寸的输入图像，并通过以下方式实现像素级分类：\n\n1. **去除全连接层**：FCN 将传统 CNN 中的全连接层替换为卷积层，从而保留空间信息。\n2. **上采样操作**：使用反卷积层（上采样层）对最后一个卷积层的特征图进行上采样，恢复到与输入图像相同的尺寸。\n3. **逐像素分类**：在上采样后的特征图上进行逐像素分类，为每个像素生成类别预测。\n\n> Q:**FCN 是如何通过上采样操作恢复特征图的空间分辨率的？**\n\n#### 模型代码\n\n##### 论文源码\n\n```python\nimport caffe\nfrom caffe import layers as L, params as P\nfrom caffe.coord_map import crop\n\ndef conv_relu(bottom, nout, ks=3, stride=1, pad=1):\n    conv = L.Convolution(bottom, kernel_size=ks, stride=stride,\n        num_output=nout, pad=pad,\n        param=[dict(lr_mult=1, decay_mult=1), dict(lr_mult=2, decay_mult=0)])\n    return conv, L.ReLU(conv, in_place=True)\n\ndef max_pool(bottom, ks=2, stride=2):\n    return L.Pooling(bottom, pool=P.Pooling.MAX, kernel_size=ks, stride=stride)\n\ndef fcn(split):\n    n = caffe.NetSpec()\n    pydata_params = dict(split=split, mean=(104.00699, 116.66877, 122.67892),\n            seed=1337)\n    if split == 'train':\n        pydata_params['sbdd_dir'] = '../data/sbdd/dataset'\n        pylayer = 'SBDDSegDataLayer'\n    else:\n        pydata_params['voc_dir'] = '../data/pascal/VOC2011'\n        pylayer = 'VOCSegDataLayer'\n    n.data, n.label = L.Python(module='voc_layers', layer=pylayer,\n            ntop=2, param_str=str(pydata_params))\n\n    # the base net\n    n.conv1_1, n.relu1_1 = conv_relu(n.data, 64, pad=100)\n    n.conv1_2, n.relu1_2 = conv_relu(n.relu1_1, 64)\n    n.pool1 = max_pool(n.relu1_2)\n\n    n.conv2_1, n.relu2_1 = conv_relu(n.pool1, 128)\n    n.conv2_2, n.relu2_2 = conv_relu(n.relu2_1, 128)\n    n.pool2 = max_pool(n.relu2_2)\n\n    n.conv3_1, n.relu3_1 = conv_relu(n.pool2, 256)\n    n.conv3_2, n.relu3_2 = conv_relu(n.relu3_1, 256)\n    n.conv3_3, n.relu3_3 = conv_relu(n.relu3_2, 256)\n    n.pool3 = max_pool(n.relu3_3)\n\n    n.conv4_1, n.relu4_1 = conv_relu(n.pool3, 512)\n    n.conv4_2, n.relu4_2 = conv_relu(n.relu4_1, 512)\n    n.conv4_3, n.relu4_3 = conv_relu(n.relu4_2, 512)\n    n.pool4 = max_pool(n.relu4_3)\n\n    n.conv5_1, n.relu5_1 = conv_relu(n.pool4, 512)\n    n.conv5_2, n.relu5_2 = conv_relu(n.relu5_1, 512)\n    n.conv5_3, n.relu5_3 = conv_relu(n.relu5_2, 512)\n    n.pool5 = max_pool(n.relu5_3)\n\n    # fully conv\n    n.fc6, n.relu6 = conv_relu(n.pool5, 4096, ks=7, pad=0)\n    n.drop6 = L.Dropout(n.relu6, dropout_ratio=0.5, in_place=True)\n    n.fc7, n.relu7 = conv_relu(n.drop6, 4096, ks=1, pad=0)\n    n.drop7 = L.Dropout(n.relu7, dropout_ratio=0.5, in_place=True)\n    n.score_fr = L.Convolution(n.drop7, num_output=21, kernel_size=1, pad=0,\n        param=[dict(lr_mult=1, decay_mult=1), dict(lr_mult=2, decay_mult=0)])\n    n.upscore2 = L.Deconvolution(n.score_fr,\n        convolution_param=dict(num_output=21, kernel_size=4, stride=2,\n            bias_term=False),\n        param=[dict(lr_mult=0)])\n\n    n.score_pool4 = L.Convolution(n.pool4, num_output=21, kernel_size=1, pad=0,\n        param=[dict(lr_mult=1, decay_mult=1), dict(lr_mult=2, decay_mult=0)])\n    n.score_pool4c = crop(n.score_pool4, n.upscore2)\n    n.fuse_pool4 = L.Eltwise(n.upscore2, n.score_pool4c,\n            operation=P.Eltwise.SUM)\n    n.upscore_pool4 = L.Deconvolution(n.fuse_pool4,\n        convolution_param=dict(num_output=21, kernel_size=4, stride=2,\n            bias_term=False),\n        param=[dict(lr_mult=0)])\n\n    n.score_pool3 = L.Convolution(n.pool3, num_output=21, kernel_size=1, pad=0,\n        param=[dict(lr_mult=1, decay_mult=1), dict(lr_mult=2, decay_mult=0)])\n    n.score_pool3c = crop(n.score_pool3, n.upscore_pool4)\n    n.fuse_pool3 = L.Eltwise(n.upscore_pool4, n.score_pool3c,\n            operation=P.Eltwise.SUM)\n    n.upscore8 = L.Deconvolution(n.fuse_pool3,\n        convolution_param=dict(num_output=21, kernel_size=16, stride=8,\n            bias_term=False),\n        param=[dict(lr_mult=0)])\n\n    n.score = crop(n.upscore8, n.data)\n    n.loss = L.SoftmaxWithLoss(n.score, n.label,\n            loss_param=dict(normalize=False, ignore_label=255))\n\n    return n.to_proto()\n\ndef make_net():\n    with open('train.prototxt', 'w') as f:\n        f.write(str(fcn('train')))\n\n    with open('val.prototxt', 'w') as f:\n        f.write(str(fcn('seg11valid')))\n\nif __name__ == '__main__':\n    make_net()\n```\n\n##### fcn8_vgg\n\n```python\nfrom __future__ import absolute_import\nfrom __future__ import division\nfrom __future__ import print_function\n\nimport os\nimport logging\nfrom math import ceil\nimport sys\n\nimport numpy as np\nimport tensorflow as tf\n\nVGG_MEAN = [103.939, 116.779, 123.68]\n\n\nclass FCN8VGG:\n\n    def __init__(self, vgg16_npy_path=None):\n        if vgg16_npy_path is None:\n            path = sys.modules[self.__class__.__module__].__file__\n            # print path\n            path = os.path.abspath(os.path.join(path, os.pardir))\n            # print path\n            path = os.path.join(path, \"vgg16.npy\")\n            vgg16_npy_path = path\n            logging.info(\"Load npy file from '%s'.\", vgg16_npy_path)\n        if not os.path.isfile(vgg16_npy_path):\n            logging.error((\"File '%s' not found. Download it from \"\n                           \"ftp://mi.eng.cam.ac.uk/pub/mttt2/\"\n                           \"models/vgg16.npy\"), vgg16_npy_path)\n            sys.exit(1)\n\n        self.data_dict = np.load(vgg16_npy_path, encoding='latin1').item()\n        self.wd = 5e-4\n        print(\"npy file loaded\")\n\n    def build(self, rgb, train=False, num_classes=20, random_init_fc8=False,\n              debug=False, use_dilated=False):\n        \"\"\"\n        Build the VGG model using loaded weights\n        Parameters\n        ----------\n        rgb: image batch tensor\n            Image in rgb shap. Scaled to Intervall [0, 255]\n        train: bool\n            Whether to build train or inference graph\n        num_classes: int\n            How many classes should be predicted (by fc8)\n        random_init_fc8 : bool\n            Whether to initialize fc8 layer randomly.\n            Finetuning is required in this case.\n        debug: bool\n            Whether to print additional Debug Information.\n        \"\"\"\n        # Convert RGB to BGR\n\n        with tf.name_scope('Processing'):\n\n            red, green, blue = tf.split(rgb, 3, 3)\n            # assert red.get_shape().as_list()[1:] == [224, 224, 1]\n            # assert green.get_shape().as_list()[1:] == [224, 224, 1]\n            # assert blue.get_shape().as_list()[1:] == [224, 224, 1]\n            bgr = tf.concat([\n                blue - VGG_MEAN[0],\n                green - VGG_MEAN[1],\n                red - VGG_MEAN[2],\n            ], 3)\n\n            if debug:\n                bgr = tf.Print(bgr, [tf.shape(bgr)],\n                               message='Shape of input image: ',\n                               summarize=4, first_n=1)\n\n        self.conv1_1 = self._conv_layer(bgr, \"conv1_1\")\n        self.conv1_2 = self._conv_layer(self.conv1_1, \"conv1_2\")\n        self.pool1 = self._max_pool(self.conv1_2, 'pool1', debug)\n\n        self.conv2_1 = self._conv_layer(self.pool1, \"conv2_1\")\n        self.conv2_2 = self._conv_layer(self.conv2_1, \"conv2_2\")\n        self.pool2 = self._max_pool(self.conv2_2, 'pool2', debug)\n\n        self.conv3_1 = self._conv_layer(self.pool2, \"conv3_1\")\n        self.conv3_2 = self._conv_layer(self.conv3_1, \"conv3_2\")\n        self.conv3_3 = self._conv_layer(self.conv3_2, \"conv3_3\")\n        self.pool3 = self._max_pool(self.conv3_3, 'pool3', debug)\n\n        self.conv4_1 = self._conv_layer(self.pool3, \"conv4_1\")\n        self.conv4_2 = self._conv_layer(self.conv4_1, \"conv4_2\")\n        self.conv4_3 = self._conv_layer(self.conv4_2, \"conv4_3\")\n\n        if use_dilated:\n            pad = [[0, 0], [0, 0]]\n            self.pool4 = tf.nn.max_pool(self.conv4_3, ksize=[1, 2, 2, 1],\n                                        strides=[1, 1, 1, 1],\n                                        padding='SAME', name='pool4')\n            self.pool4 = tf.space_to_batch(self.pool4,\n                                           paddings=pad, block_size=2)\n        else:\n            self.pool4 = self._max_pool(self.conv4_3, 'pool4', debug)\n\n        self.conv5_1 = self._conv_layer(self.pool4, \"conv5_1\")\n        self.conv5_2 = self._conv_layer(self.conv5_1, \"conv5_2\")\n        self.conv5_3 = self._conv_layer(self.conv5_2, \"conv5_3\")\n        if use_dilated:\n            pad = [[0, 0], [0, 0]]\n            self.pool5 = tf.nn.max_pool(self.conv5_3, ksize=[1, 2, 2, 1],\n                                        strides=[1, 1, 1, 1],\n                                        padding='SAME', name='pool5')\n            self.pool5 = tf.space_to_batch(self.pool5,\n                                           paddings=pad, block_size=2)\n        else:\n            self.pool5 = self._max_pool(self.conv5_3, 'pool5', debug)\n\n        self.fc6 = self._fc_layer(self.pool5, \"fc6\")\n\n        if train:\n            self.fc6 = tf.nn.dropout(self.fc6, 0.5)\n\n        self.fc7 = self._fc_layer(self.fc6, \"fc7\")\n        if train:\n            self.fc7 = tf.nn.dropout(self.fc7, 0.5)\n\n        if use_dilated:\n            self.pool5 = tf.batch_to_space(self.pool5, crops=pad, block_size=2)\n            self.pool5 = tf.batch_to_space(self.pool5, crops=pad, block_size=2)\n            self.fc7 = tf.batch_to_space(self.fc7, crops=pad, block_size=2)\n            self.fc7 = tf.batch_to_space(self.fc7, crops=pad, block_size=2)\n            return\n\n        if random_init_fc8:\n            self.score_fr = self._score_layer(self.fc7, \"score_fr\",\n                                              num_classes)\n        else:\n            self.score_fr = self._fc_layer(self.fc7, \"score_fr\",\n                                           num_classes=num_classes,\n                                           relu=False)\n\n        self.pred = tf.argmax(self.score_fr, dimension=3)\n\n        self.upscore2 = self._upscore_layer(self.score_fr,\n                                            shape=tf.shape(self.pool4),\n                                            num_classes=num_classes,\n                                            debug=debug, name='upscore2',\n                                            ksize=4, stride=2)\n        self.score_pool4 = self._score_layer(self.pool4, \"score_pool4\",\n                                             num_classes=num_classes)\n        self.fuse_pool4 = tf.add(self.upscore2, self.score_pool4)\n\n        self.upscore4 = self._upscore_layer(self.fuse_pool4,\n                                            shape=tf.shape(self.pool3),\n                                            num_classes=num_classes,\n                                            debug=debug, name='upscore4',\n                                            ksize=4, stride=2)\n        self.score_pool3 = self._score_layer(self.pool3, \"score_pool3\",\n                                             num_classes=num_classes)\n        self.fuse_pool3 = tf.add(self.upscore4, self.score_pool3)\n\n        self.upscore32 = self._upscore_layer(self.fuse_pool3,\n                                             shape=tf.shape(bgr),\n                                             num_classes=num_classes,\n                                             debug=debug, name='upscore32',\n                                             ksize=16, stride=8)\n\n        self.pred_up = tf.argmax(self.upscore32, dimension=3)\n\n    def _max_pool(self, bottom, name, debug):\n        pool = tf.nn.max_pool(bottom, ksize=[1, 2, 2, 1], strides=[1, 2, 2, 1],\n                              padding='SAME', name=name)\n\n        if debug:\n            pool = tf.Print(pool, [tf.shape(pool)],\n                            message='Shape of %s' % name,\n                            summarize=4, first_n=1)\n        return pool\n\n    def _conv_layer(self, bottom, name):\n        with tf.variable_scope(name) as scope:\n            filt = self.get_conv_filter(name)\n            conv = tf.nn.conv2d(bottom, filt, [1, 1, 1, 1], padding='SAME')\n\n            conv_biases = self.get_bias(name)\n            bias = tf.nn.bias_add(conv, conv_biases)\n\n            relu = tf.nn.relu(bias)\n            # Add summary to Tensorboard\n            _activation_summary(relu)\n            return relu\n\n    def _fc_layer(self, bottom, name, num_classes=None,\n                  relu=True, debug=False):\n        with tf.variable_scope(name) as scope:\n            shape = bottom.get_shape().as_list()\n\n            if name == 'fc6':\n                filt = self.get_fc_weight_reshape(name, [7, 7, 512, 4096])\n            elif name == 'score_fr':\n                name = 'fc8'  # Name of score_fr layer in VGG Model\n                filt = self.get_fc_weight_reshape(name, [1, 1, 4096, 1000],\n                                                  num_classes=num_classes)\n            else:\n                filt = self.get_fc_weight_reshape(name, [1, 1, 4096, 4096])\n\n            self._add_wd_and_summary(filt, self.wd, \"fc_wlosses\")\n\n            conv = tf.nn.conv2d(bottom, filt, [1, 1, 1, 1], padding='SAME')\n            conv_biases = self.get_bias(name, num_classes=num_classes)\n            bias = tf.nn.bias_add(conv, conv_biases)\n\n            if relu:\n                bias = tf.nn.relu(bias)\n            _activation_summary(bias)\n\n            if debug:\n                bias = tf.Print(bias, [tf.shape(bias)],\n                                message='Shape of %s' % name,\n                                summarize=4, first_n=1)\n            return bias\n\n    def _score_layer(self, bottom, name, num_classes):\n        with tf.variable_scope(name) as scope:\n            # get number of input channels\n            in_features = bottom.get_shape()[3].value\n            shape = [1, 1, in_features, num_classes]\n            # He initialization Sheme\n            if name == \"score_fr\":\n                num_input = in_features\n                stddev = (2 / num_input)**0.5\n            elif name == \"score_pool4\":\n                stddev = 0.001\n            elif name == \"score_pool3\":\n                stddev = 0.0001\n            # Apply convolution\n            w_decay = self.wd\n\n            weights = self._variable_with_weight_decay(shape, stddev, w_decay,\n                                                       decoder=True)\n            conv = tf.nn.conv2d(bottom, weights, [1, 1, 1, 1], padding='SAME')\n            # Apply bias\n            conv_biases = self._bias_variable([num_classes], constant=0.0)\n            bias = tf.nn.bias_add(conv, conv_biases)\n\n            _activation_summary(bias)\n\n            return bias\n\n    def _upscore_layer(self, bottom, shape,\n                       num_classes, name, debug,\n                       ksize=4, stride=2):\n        strides = [1, stride, stride, 1]\n        with tf.variable_scope(name):\n            in_features = bottom.get_shape()[3].value\n\n            if shape is None:\n                # Compute shape out of Bottom\n                in_shape = tf.shape(bottom)\n\n                h = ((in_shape[1] - 1) * stride) + 1\n                w = ((in_shape[2] - 1) * stride) + 1\n                new_shape = [in_shape[0], h, w, num_classes]\n            else:\n                new_shape = [shape[0], shape[1], shape[2], num_classes]\n            output_shape = tf.stack(new_shape)\n\n            logging.debug(\"Layer: %s, Fan-in: %d\" % (name, in_features))\n            f_shape = [ksize, ksize, num_classes, in_features]\n\n            # create\n            num_input = ksize * ksize * in_features / stride\n            stddev = (2 / num_input)**0.5\n\n            weights = self.get_deconv_filter(f_shape)\n            self._add_wd_and_summary(weights, self.wd, \"fc_wlosses\")\n            deconv = tf.nn.conv2d_transpose(bottom, weights, output_shape,\n                                            strides=strides, padding='SAME')\n\n            if debug:\n                deconv = tf.Print(deconv, [tf.shape(deconv)],\n                                  message='Shape of %s' % name,\n                                  summarize=4, first_n=1)\n\n        _activation_summary(deconv)\n        return deconv\n\n    def get_deconv_filter(self, f_shape):\n        width = f_shape[0]\n        height = f_shape[1]\n        f = ceil(width/2.0)\n        c = (2 * f - 1 - f % 2) / (2.0 * f)\n        bilinear = np.zeros([f_shape[0], f_shape[1]])\n        for x in range(width):\n            for y in range(height):\n                value = (1 - abs(x / f - c)) * (1 - abs(y / f - c))\n                bilinear[x, y] = value\n        weights = np.zeros(f_shape)\n        for i in range(f_shape[2]):\n            weights[:, :, i, i] = bilinear\n\n        init = tf.constant_initializer(value=weights,\n                                       dtype=tf.float32)\n        var = tf.get_variable(name=\"up_filter\", initializer=init,\n                              shape=weights.shape)\n        return var\n\n    def get_conv_filter(self, name):\n        init = tf.constant_initializer(value=self.data_dict[name][0],\n                                       dtype=tf.float32)\n        shape = self.data_dict[name][0].shape\n        print('Layer name: %s' % name)\n        print('Layer shape: %s' % str(shape))\n        var = tf.get_variable(name=\"filter\", initializer=init, shape=shape)\n        if not tf.get_variable_scope().reuse:\n            weight_decay = tf.multiply(tf.nn.l2_loss(var), self.wd,\n                                       name='weight_loss')\n            tf.add_to_collection(tf.GraphKeys.REGULARIZATION_LOSSES,\n                                 weight_decay)\n        _variable_summaries(var)\n        return var\n\n    def get_bias(self, name, num_classes=None):\n        bias_wights = self.data_dict[name][1]\n        shape = self.data_dict[name][1].shape\n        if name == 'fc8':\n            bias_wights = self._bias_reshape(bias_wights, shape[0],\n                                             num_classes)\n            shape = [num_classes]\n        init = tf.constant_initializer(value=bias_wights,\n                                       dtype=tf.float32)\n        var = tf.get_variable(name=\"biases\", initializer=init, shape=shape)\n        _variable_summaries(var)\n        return var\n\n    def get_fc_weight(self, name):\n        init = tf.constant_initializer(value=self.data_dict[name][0],\n                                       dtype=tf.float32)\n        shape = self.data_dict[name][0].shape\n        var = tf.get_variable(name=\"weights\", initializer=init, shape=shape)\n        if not tf.get_variable_scope().reuse:\n            weight_decay = tf.multiply(tf.nn.l2_loss(var), self.wd,\n                                       name='weight_loss')\n            tf.add_to_collection(tf.GraphKeys.REGULARIZATION_LOSSES,\n                                 weight_decay)\n        _variable_summaries(var)\n        return var\n\n    def _bias_reshape(self, bweight, num_orig, num_new):\n        \"\"\" Build bias weights for filter produces with `_summary_reshape`\n\n        \"\"\"\n        n_averaged_elements = num_orig//num_new\n        avg_bweight = np.zeros(num_new)\n        for i in range(0, num_orig, n_averaged_elements):\n            start_idx = i\n            end_idx = start_idx + n_averaged_elements\n            avg_idx = start_idx//n_averaged_elements\n            if avg_idx == num_new:\n                break\n            avg_bweight[avg_idx] = np.mean(bweight[start_idx:end_idx])\n        return avg_bweight\n\n    def _summary_reshape(self, fweight, shape, num_new):\n        \"\"\" Produce weights for a reduced fully-connected layer.\n\n        FC8 of VGG produces 1000 classes. Most semantic segmentation\n        task require much less classes. This reshapes the original weights\n        to be used in a fully-convolutional layer which produces num_new\n        classes. To archive this the average (mean) of n adjanced classes is\n        taken.\n\n        Consider reordering fweight, to perserve semantic meaning of the\n        weights.\n\n        Args:\n          fweight: original weights\n          shape: shape of the desired fully-convolutional layer\n          num_new: number of new classes\n\n\n        Returns:\n          Filter weights for `num_new` classes.\n        \"\"\"\n        num_orig = shape[3]\n        shape[3] = num_new\n        assert(num_new < num_orig)\n        n_averaged_elements = num_orig//num_new\n        avg_fweight = np.zeros(shape)\n        for i in range(0, num_orig, n_averaged_elements):\n            start_idx = i\n            end_idx = start_idx + n_averaged_elements\n            avg_idx = start_idx//n_averaged_elements\n            if avg_idx == num_new:\n                break\n            avg_fweight[:, :, :, avg_idx] = np.mean(\n                fweight[:, :, :, start_idx:end_idx], axis=3)\n        return avg_fweight\n\n    def _variable_with_weight_decay(self, shape, stddev, wd, decoder=False):\n        \"\"\"Helper to create an initialized Variable with weight decay.\n\n        Note that the Variable is initialized with a truncated normal\n        distribution.\n        A weight decay is added only if one is specified.\n\n        Args:\n          name: name of the variable\n          shape: list of ints\n          stddev: standard deviation of a truncated Gaussian\n          wd: add L2Loss weight decay multiplied by this float. If None, weight\n              decay is not added for this Variable.\n\n        Returns:\n          Variable Tensor\n        \"\"\"\n\n        initializer = tf.truncated_normal_initializer(stddev=stddev)\n        var = tf.get_variable('weights', shape=shape,\n                              initializer=initializer)\n\n        collection_name = tf.GraphKeys.REGULARIZATION_LOSSES\n        if wd and (not tf.get_variable_scope().reuse):\n            weight_decay = tf.multiply(\n                tf.nn.l2_loss(var), wd, name='weight_loss')\n            tf.add_to_collection(collection_name, weight_decay)\n        _variable_summaries(var)\n        return var\n\n    def _add_wd_and_summary(self, var, wd, collection_name=None):\n        if collection_name is None:\n            collection_name = tf.GraphKeys.REGULARIZATION_LOSSES\n        if wd and (not tf.get_variable_scope().reuse):\n            weight_decay = tf.multiply(\n                tf.nn.l2_loss(var), wd, name='weight_loss')\n            tf.add_to_collection(collection_name, weight_decay)\n        _variable_summaries(var)\n        return var\n\n    def _bias_variable(self, shape, constant=0.0):\n        initializer = tf.constant_initializer(constant)\n        var = tf.get_variable(name='biases', shape=shape,\n                              initializer=initializer)\n        _variable_summaries(var)\n        return var\n\n    def get_fc_weight_reshape(self, name, shape, num_classes=None):\n        print('Layer name: %s' % name)\n        print('Layer shape: %s' % shape)\n        weights = self.data_dict[name][0]\n        weights = weights.reshape(shape)\n        if num_classes is not None:\n            weights = self._summary_reshape(weights, shape,\n                                            num_new=num_classes)\n        init = tf.constant_initializer(value=weights,\n                                       dtype=tf.float32)\n        var = tf.get_variable(name=\"weights\", initializer=init, shape=shape)\n        return var\n\n\ndef _activation_summary(x):\n    \"\"\"Helper to create summaries for activations.\n\n    Creates a summary that provides a histogram of activations.\n    Creates a summary that measure the sparsity of activations.\n\n    Args:\n      x: Tensor\n    Returns:\n      nothing\n    \"\"\"\n    # Remove 'tower_[0-9]/' from the name in case this is a multi-GPU training\n    # session. This helps the clarity of presentation on tensorboard.\n    tensor_name = x.op.name\n    # tensor_name = re.sub('%s_[0-9]*/' % TOWER_NAME, '', x.op.name)\n    tf.summary.histogram(tensor_name + '/activations', x)\n    tf.summary.scalar(tensor_name + '/sparsity', tf.nn.zero_fraction(x))\n\n\ndef _variable_summaries(var):\n    \"\"\"Attach a lot of summaries to a Tensor.\"\"\"\n    if not tf.get_variable_scope().reuse:\n        name = var.op.name\n        logging.info(\"Creating Summary for: %s\" % name)\n        with tf.name_scope('summaries'):\n            mean = tf.reduce_mean(var)\n            tf.summary.scalar(name + '/mean', mean)\n            with tf.name_scope('stddev'):\n                stddev = tf.sqrt(tf.reduce_sum(tf.square(var - mean)))\n            tf.summary.scalar(name + '/sttdev', stddev)\n            tf.summary.scalar(name + '/max', tf.reduce_max(var))\n            tf.summary.scalar(name + '/min', tf.reduce_min(var))\n            tf.summary.histogram(name, var)\n```\n\n##### fcn 调包\n\n```python\nimport torch.nn as nn\nimport torch.nn.functional as F\nfrom abc import ABCMeta\nimport torchvision.models as models\n\n\ndef _maybe_pad(x, size):\n    hpad = size[0] - x.shape[2]\n    wpad = size[1] - x.shape[3]\n    if hpad + wpad > 0:\n        x = F.pad(x, (0, wpad, 0, hpad, 0, 0, 0, 0 ))\n    return x\n\n\nclass VGGFCN(nn.Module, metaclass=ABCMeta):\n    def __init__(self, in_channels, n_classes):\n        super().__init__()\n        assert in_channels == 3\n        self.n_classes = n_classes\n        self.vgg16 = models.vgg16(pretrained=True)\n        self.classifier = nn.Sequential(\n            nn.Conv2d(512, 4096, kernel_size=7, padding=3),\n            nn.ReLU(True),\n            nn.Dropout(),\n            nn.Conv2d(4096, 4096, kernel_size=1),\n            nn.ReLU(True),\n            nn.Dropout(),\n            nn.Conv2d(4096, n_classes, kernel_size=1),\n        )\n\n        self._initialize_weights()\n\n    def _initialize_weights(self):\n        self.classifier[0].weight.data = (\n            self.vgg16.classifier[0].weight.data.view(\n                self.classifier[0].weight.size())\n        )\n        self.classifier[3].weight.data = (\n            self.vgg16.classifier[3].weight.data.view(\n                self.classifier[3].weight.size())\n        )\n\n\nclass VGGFCN32(VGGFCN):\n    def forward(self, x):\n        input_height, input_width = x.shape[2], x.shape[3]\n        x = self.vgg16.features(x)\n        x = self.classifier(x)\n        x = F.interpolate(x, size=(input_height, input_width),\n                          mode='bilinear', align_corners=True)\n        return x\n\n\nclass VGGFCN16(VGGFCN):\n    def __init__(self, in_channels, n_classes):\n        super().__init__(in_channels, n_classes)\n        self.score4 = nn.Conv2d(512, n_classes, kernel_size=1)\n        self.upscale5 = nn.ConvTranspose2d(\n            n_classes, n_classes, kernel_size=2, stride=2)\n\n    def forward(self, x):\n        input_height, input_width = x.shape[2], x.shape[3]\n        pool4 = self.vgg16.features[:-7](x)\n        pool5 = self.vgg16.features[-7:](pool4)\n        pool5_upscaled = self.upscale5(self.classifier(pool5))\n        pool4 = self.score4(pool4)\n        x = pool4 + pool5_upscaled\n        x = F.interpolate(x, size=(input_height, input_width),\n                          mode='bilinear', align_corners=True)\n        return x\n\n\nclass VGGFCN8(VGGFCN):\n    def __init__(self, in_channels, n_classes):\n        super().__init__(in_channels, n_classes)\n        self.upscale4 = nn.ConvTranspose2d(\n            n_classes, n_classes, kernel_size=2, stride=2)\n        self.score4 = nn.Conv2d(\n            512, n_classes, kernel_size=1, stride=1)\n        self.score3 = nn.Conv2d(\n            256, n_classes, kernel_size=1, stride=1)\n        self.upscale5 = nn.ConvTranspose2d(\n            n_classes, n_classes, kernel_size=2, stride=2)\n\n    def forward(self, x):\n        input_height, input_width = x.shape[2], x.shape[3]\n        pool3 = self.vgg16.features[:-14](x)\n        pool4 = self.vgg16.features[-14:-7](pool3)\n        pool5 = self.vgg16.features[-7:](pool4)\n        pool5_upscaled = self.upscale5(self.classifier(pool5))\n        pool5_upscaled = _maybe_pad(pool5_upscaled, pool4.shape[2:])\n        pool4_scores = self.score4(pool4)\n        pool4_fused = pool4_scores + pool5_upscaled\n        pool4_upscaled = self.upscale4(pool4_fused)\n        pool4_upscaled = _maybe_pad(pool4_upscaled, pool3.shape[2:])\n        x = self.score3(pool3) + pool4_upscaled\n        x = F.interpolate(x, size=(input_height, input_width),\n                          mode='bilinear', align_corners=True)\n        return x\n```\n\n#### 相关资源\n\n### **U-Net**\n\n- **优点**：简单易用，适用于小数据集，尤其在医学图像分割中表现良好。\n- **缺点**：容易过拟合，不太适合大规模数据集。\n\n![1740236677445SwkUbDFUtolVEKxc4dmcbrOknJf.png](https://tk-pichost-1325224430.cos.ap-chengdu.myqcloud.com/blog/1740236677445SwkUbDFUtolVEKxc4dmcbrOknJf.png)\n\n#### 提出初衷\n\nU-Net 是一种经典且广泛使用的分割模型，以其简单、高效、易于理解和构建的特点而受到青睐，尤其适合从小数据集中进行训练。该模型最早于 2015 年在论文《U-Net: Convolutional Networks for Biomedical Image Segmentation》中被提出，至今仍然是医学图像分割领域的重要基础模型。\n\n![1740236700448YM2HbihrkonVkixR0KdcPLcBnLc.png](https://tk-pichost-1325224430.cos.ap-chengdu.myqcloud.com/blog/1740236700448YM2HbihrkonVkixR0KdcPLcBnLc.png)\n\n![1740236696443Voorb6LuJopG3exmtulcaySynjc.png](https://tk-pichost-1325224430.cos.ap-chengdu.myqcloud.com/blog/1740236696443Voorb6LuJopG3exmtulcaySynjc.png)\n\n![1740236682500NfPrbS5SNoEjsFxFFptcl471nhb.png](https://tk-pichost-1325224430.cos.ap-chengdu.myqcloud.com/blog/1740236682500NfPrbS5SNoEjsFxFFptcl471nhb.png)\n\n1. Unet 提出的初衷是为了解决医学图像分割的问题；\n2. 一种 U 型的网络结构来获取上下文的信息和位置信息；\n3. 在 2015 年的 ISBI cell tracking 比赛中获得了多个第一，一开始这是为了解决细胞层面的分割的任务的\n\n#### 网络结构\n\n![1740236655458N3Vab29uNorFHwxpINwc5s6unkh.png](https://tk-pichost-1325224430.cos.ap-chengdu.myqcloud.com/blog/1740236655458N3Vab29uNorFHwxpINwc5s6unkh.png)\n\nU-Net 网络是一种经典的编码器-解码器结构，因其整体结构形似大写的英文字母“U”而得名。它广泛应用于医学图像分割等领域。U-Net 的设计非常简洁：前半部分用于特征提取（编码器），后半部分用于上采样（解码器）。\n\n##### 编码器（Encoder）\n\n编码器位于网络的左半部分，主要由多个下采样模块组成。每个模块包含两个 3×3 的卷积层（激活函数为 ReLU），后接一个 2×2 的最大池化（Max Pooling）层，用于特征提取和空间尺寸的减半。通过这种结构，编码器能够逐步提取图像的深层特征，同时扩大感受野。\n\n##### 解码器（Decoder）\n\n解码器位于网络的右半部分，主要由上采样模块组成。每个模块包含一个 2×2 的反卷积层（上采样卷积层），用于将特征图的空间尺寸恢复到与编码器对应层相同的大小。随后，解码器通过特征拼接（concatenation）将上采样后的特征图与编码器中对应层的特征图进行通道级拼接，最后通过两个 3×3 的卷积层（激活函数为 ReLU）进一步融合特征。这种结构能够有效地结合深层特征和浅层特征，兼顾全局语义信息和局部细节。\n\n##### 特征融合方式\n\n与 FCN 网络通过特征图对应像素值的相加来融合特征不同，U-Net 采用通道级拼接的方式。这种方式可以形成更厚的特征图，从而保留更多的细节信息，但也增加了显存的消耗。\n\n### U-Net 的优点\n\n1. **多尺度特征融合**：U-Net 通过拼接深层和浅层特征图，能够充分利用不同层次的特征。浅层卷积关注纹理和细节特征，而深层网络关注更高级的语义特征。这种融合方式使得模型能够更好地处理复杂的分割任务。\n2. **边缘特征的保留**：在下采样过程中，虽然会损失一些边缘特征，但通过特征拼接，解码器能够从编码器的浅层特征中找回这些丢失的边缘信息，从而提高分割的精度。\n\nUnet 的好处我感觉是：网络层越深得到的特征图，有着更大的视野域，浅层卷积关注纹理特征，深层网络关注本质的那种特征，所以深层浅层特征都是有格子的意义的；另外一点是通过反卷积得到的更大的尺寸的特征图的边缘，是缺少信息的，毕竟每一次下采样提炼特征的同时，也必然会损失一些边缘特征，而失去的特征并不能从上采样中找回，因此通过特征的拼接，来实现边缘特征的一个找回。\n\n下面是一些与医学相关的数据集以及对应的提取码,有兴趣的同学可以下载下来跑一下。\n\n<table>\n<tr>\n<td>**数据集名称**<br/></td><td>**下载链接**<td>**提取码**<br/></td></tr>\n<tr>\n<td>Cell dataset (dsb2018)<br/></td><td>https://pan.baidu.com/share/init?surl=BaVrzYdrSP78CwYaRzZr1w<td>5l54<br/></td></tr>\n<tr>\n<td>Liver dataset<br/></td><td>https://pan.baidu.com/share/init?surl=FljGCVzu7HPYpwAKvSVN4Q<td>5l88<br/></td></tr>\n<tr>\n<td>Cell dataset (isbi)<br/></td><td>https://pan.baidu.com/share/init?surl=FkfnhU-RnYFZti62-f8AVA<td>14rz<br/></td></tr>\n<tr>\n<td>Lung dataset<br/></td><td>https://pan.baidu.com/share/init?surl=sLFRmtG2TOTEgUKniJf7AA<td>qdwo<br/></td></tr>\n<tr>\n<td>Corneal Nerve dataset<br/></td><td>https://pan.baidu.com/share/init?surl=T3-kS_FgYI6DeXv3n1I7bA<td>ih02<br/></td></tr>\n<tr>\n<td>Eye Vessels (DRIVE dataset)<br/></td><td>https://pan.baidu.com/share/init?surl=UkMLmdbM61N8ecgnKlAsPg<td>f1ek<br/></td></tr>\n<tr>\n<td>Esophagus and Esophagus Cancer dataset (First Affiliated Hospital of Sun Yat-sen University)<br/></td><td>https://pan.baidu.com/share/init?surl=0b5arIQjNpiggwdkgYNHXQ<td>hivm<br/></td></tr>\n</table>\n\n#### 为什么 Unet 在医疗图像分割中表现好?\n\n大多数医疗影像语义分割任务都会首先用 Unet 作为 baseline，当然上一章节讲解的 Unet 的优点肯定是可以当作这个问题的答案，这里谈一谈医疗影像的特点\n\n根据网友的讨论，得到的结果：\n\n1. 医疗影像语义较为简单、结构固定。因此语义信息相比自动驾驶等较为单一，因此并不需要去筛选过滤无用的信息。医疗影像的所有特征都很重要，因此低级特征和高级语义特征都很重要，所以 U 型结构的 skip connection 结构（特征拼接）更好派上用场\n2. 医学影像的数据较少，获取难度大，数据量可能只有几百甚至不到 100，因此如果使用大型的网络例如 DeepLabv3+ 等模型，很容易过拟合。大型网络的优点是更强的图像表述能力，而较为简单、数量少的医学影像并没有那么多的内容需要表述，因此也有人发现在小数量级中，分割的 SOTA 模型与轻量的 Unet 并没有神恶魔优势\n3. 医学影像往往是多模态的。比方说 ISLES 脑梗竞赛中，官方提供了 CBF，MTT，CBV 等多中模态的数据（这一点听不懂也无妨）。因此医学影像任务中，往往需要自己设计网络去提取不同的模态特征，因此轻量结构简单的 Unet 可以有更大的操作空间。\n\n> Q:过拟合与模型复杂程度有关还和什么有关呢?\n\n#### 模型代码\n\n##### 源码\n\n```python\nimport torch.nn as nn\nimport torch\nfrom torch import autograd\nfrom functools import partial\nimport torch.nn.functional as F\nfrom torchvision import models\n\nclass DoubleConv(nn.Module):\n    def __init__(self, in_ch, out_ch):\n        super(DoubleConv, self).__init__()\n        self.**conv** = nn.Sequential(\n            nn.Conv2d(in_ch, out_ch, 3, _padding_=1),\n            nn.BatchNorm2d(out_ch),\n            nn.ReLU(_inplace_=True),\n            nn.Conv2d(out_ch, out_ch, 3, _padding_=1),\n            nn.BatchNorm2d(out_ch),\n            nn.ReLU(_inplace_=True)\n        )\n\n    def forward(self, input):\n        return self.**conv**(input)\n\nclass Unet(nn.Module):\n    def __init__(self, in_ch, out_ch):\n        super(Unet, self).__init__()\n\n        self.**conv1** = DoubleConv(in_ch, 32)\n        self.**pool1** = nn.MaxPool2d(2)\n        self.**conv2** = DoubleConv(32, 64)\n        self.**pool2** = nn.MaxPool2d(2)\n        self.**conv3** = DoubleConv(64, 128)\n        self.**pool3** = nn.MaxPool2d(2)\n        self.**conv4** = DoubleConv(128, 256)\n        self.**pool4** = nn.MaxPool2d(2)\n        self.**conv5** = DoubleConv(256, 512)\n        self.**up6** = nn.ConvTranspose2d(512, 256, 2, _stride_=2)\n        self.**conv6** = DoubleConv(512, 256)\n        self.**up7** = nn.ConvTranspose2d(256, 128, 2, _stride_=2)\n        self.**conv7** = DoubleConv(256, 128)\n        self.**up8** = nn.ConvTranspose2d(128, 64, 2, _stride_=2)\n        self.**conv8** = DoubleConv(128, 64)\n        self.**up9** = nn.ConvTranspose2d(64, 32, 2, _stride_=2)\n        self.**conv9** = DoubleConv(64, 32)\n        self.**conv10** = nn.Conv2d(32, out_ch, 1)\n\n    def forward(self, x):\n        _#print(x.shape)_\n        c1 = self.**conv1**(x)\n        p1 = self.**pool1**(c1)\n        _#print(p1.shape)_\n        c2 = self.**conv2**(p1)\n        p2 = self.**pool2**(c2)\n        _#print(p2.shape)_\n        c3 = self.**conv3**(p2)\n        p3 = self.**pool3**(c3)\n        _#print(p3.shape)_\n        c4 = self.**conv4**(p3)\n        p4 = self.**pool4**(c4)\n        _#print(p4.shape)_\n        c5 = self.**conv5**(p4)\n        up_6 = self.**up6**(c5)\n        merge6 = torch.cat([up_6, c4], _dim_=1)\n        c6 = self.**conv6**(merge6)\n        up_7 = self.**up7**(c6)\n        merge7 = torch.cat([up_7, c3], _dim_=1)\n        c7 = self.**conv7**(merge7)\n        up_8 = self.**up8**(c7)\n        merge8 = torch.cat([up_8, c2], _dim_=1)\n        c8 = self.**conv8**(merge8)\n        up_9 = self.**up9**(c8)\n        merge9 = torch.cat([up_9, c1], _dim_=1)\n        c9 = self.**conv9**(merge9)\n        c10 = self.**conv10**(c9)\n        out = nn.Sigmoid()(c10)\n        return out\n\nnonlinearity = partial(F.relu, _inplace_=True)\nclass DecoderBlock(nn.Module):\n    def __init__(self, in_channels, n_filters):\n        super(DecoderBlock, self).__init__()\n\n        self.**conv1** = nn.Conv2d(in_channels, in_channels // 4, 1)\n        self.**norm1** = nn.BatchNorm2d(in_channels // 4)\n        self.**relu1** = nonlinearity\n\n        self.**deconv2** = nn.ConvTranspose2d(in_channels // 4, in_channels // 4, 3, _stride_=2, _padding_=1, _output_padding_=1)\n        self.**norm2** = nn.BatchNorm2d(in_channels // 4)\n        self.**relu2** = nonlinearity\n\n        self.**conv3** = nn.Conv2d(in_channels // 4, n_filters, 1)\n        self.**norm3** = nn.BatchNorm2d(n_filters)\n        self.**relu3** = nonlinearity\n\n    def forward(self, x):\n        x = self.**conv1**(x)\n        x = self.**norm1**(x)\n        x = self.**relu1**(x)\n        x = self.**deconv2**(x)\n        x = self.**norm2**(x)\n        x = self.**relu2**(x)\n        x = self.**conv3**(x)\n        x = self.**norm3**(x)\n        x = self.**relu3**(x)\n        return x\n\nclass resnet34_unet(nn.Module):\n    def __init__(self, num_classes=1, num_channels=3,pretrained=True):\n        super(resnet34_unet, self).__init__()\n\n        filters = [64, 128, 256, 512]\n        resnet = models.resnet34(_pretrained_=pretrained)\n        self.**firstconv** = resnet.**conv1**\n        self.**firstbn** = resnet.**bn1**\n        self.**firstrelu** = resnet.**relu**\n        self.**firstmaxpool** = resnet.**maxpool**\n        self.**encoder1** = resnet.**layer1**\n        self.**encoder2** = resnet.**layer2**\n        self.**encoder3** = resnet.**layer3**\n        self.**encoder4** = resnet.**layer4**\n\n        self.**decoder4** = DecoderBlock(512, filters[2])\n        self.**decoder3** = DecoderBlock(filters[2], filters[1])\n        self.**decoder2** = DecoderBlock(filters[1], filters[0])\n        self.**decoder1** = DecoderBlock(filters[0], filters[0])\n\n        self.**decoder4** = DecoderBlock(512, filters[2])\n        self.**decoder3** = DecoderBlock(filters[2], filters[1])\n        self.**decoder2** = DecoderBlock(filters[1], filters[0])\n        self.**decoder1** = DecoderBlock(filters[0], filters[0])\n\n        self.**finaldeconv1** = nn.ConvTranspose2d(filters[0], 32, 4, 2, 1)\n        self.**finalrelu1** = nonlinearity\n        self.**finalconv2** = nn.Conv2d(32, 32, 3, _padding_=1)\n        self.**finalrelu2** = nonlinearity\n        self.**finalconv3** = nn.Conv2d(32, num_classes, 3, _padding_=1)\n\n    def forward(self, x):\n        _# Encoder_\n        x = self.**firstconv**(x)\n        x = self.**firstbn**(x)\n        x = self.**firstrelu**(x)\n        x = self.**firstmaxpool**(x)\n        e1 = self.**encoder1**(x)\n        e2 = self.**encoder2**(e1)\n        e3 = self.**encoder3**(e2)\n        e4 = self.**encoder4**(e3)\n\n        _# Center_\n\n        _# Decoder_\n        d4 = self.**decoder4**(e4) + e3\n        d3 = self.**decoder3**(d4) + e2\n        d2 = self.**decoder2**(d3) + e1\n        d1 = self.**decoder1**(d2)\n\n        out = self.**finaldeconv1**(d1)\n        out = self.**finalrelu1**(out)\n        out = self.**finalconv2**(out)\n        out = self.**finalrelu2**(out)\n        out = self.**finalconv3**(out)\n\n        return nn.Sigmoid()(out)\n```\n\n##### 模型实现\n\n```python\nimport torch\nimport torch.nn as nn\nimport torch.nn.functional as F\n\nclass double_conv2d_bn(nn.Module):\n    def __init__(self,in_channels,out_channels,kernel_size=3,strides=1,padding=1):\n        super(double_conv2d_bn,self).__init__()\n        self.conv1 = nn.Conv2d(in_channels,out_channels,\n                               kernel_size=kernel_size,\n                              stride = strides,padding=padding,bias=True)\n        self.conv2 = nn.Conv2d(out_channels,out_channels,\n                              kernel_size = kernel_size,\n                              stride = strides,padding=padding,bias=True)\n        self.bn1 = nn.BatchNorm2d(out_channels)\n        self.bn2 = nn.BatchNorm2d(out_channels)\n  \n    def forward(self,x):\n        out = F.relu(self.bn1(self.conv1(x)))\n        out = F.relu(self.bn2(self.conv2(out)))\n        return out\n  \nclass deconv2d_bn(nn.Module):\n    def __init__(self,in_channels,out_channels,kernel_size=2,strides=2):\n        super(deconv2d_bn,self).__init__()\n        self.conv1 = nn.ConvTranspose2d(in_channels,out_channels,\n                                        kernel_size = kernel_size,\n                                       stride = strides,bias=True)\n        self.bn1 = nn.BatchNorm2d(out_channels)\n      \n    def forward(self,x):\n        out = F.relu(self.bn1(self.conv1(x)))\n        return out\n  \nclass Unet(nn.Module):\n    def __init__(self):\n        super(Unet,self).__init__()\n        self.layer1_conv = double_conv2d_bn(1,8)\n        self.layer2_conv = double_conv2d_bn(8,16)\n        self.layer3_conv = double_conv2d_bn(16,32)\n        self.layer4_conv = double_conv2d_bn(32,64)\n        self.layer5_conv = double_conv2d_bn(64,128)\n        self.layer6_conv = double_conv2d_bn(128,64)\n        self.layer7_conv = double_conv2d_bn(64,32)\n        self.layer8_conv = double_conv2d_bn(32,16)\n        self.layer9_conv = double_conv2d_bn(16,8)\n        self.layer10_conv = nn.Conv2d(8,1,kernel_size=3,\n                                     stride=1,padding=1,bias=True)\n      \n        self.deconv1 = deconv2d_bn(128,64)\n        self.deconv2 = deconv2d_bn(64,32)\n        self.deconv3 = deconv2d_bn(32,16)\n        self.deconv4 = deconv2d_bn(16,8)\n      \n        self.sigmoid = nn.Sigmoid()\n      \n    def forward(self,x):\n        conv1 = self.layer1_conv(x)\n        pool1 = F.max_pool2d(conv1,2)\n      \n        conv2 = self.layer2_conv(pool1)\n        pool2 = F.max_pool2d(conv2,2)\n      \n        conv3 = self.layer3_conv(pool2)\n        pool3 = F.max_pool2d(conv3,2)\n      \n        conv4 = self.layer4_conv(pool3)\n        pool4 = F.max_pool2d(conv4,2)\n      \n        conv5 = self.layer5_conv(pool4)\n      \n        convt1 = self.deconv1(conv5)\n        concat1 = torch.cat([convt1,conv4],dim=1)\n        conv6 = self.layer6_conv(concat1)\n      \n        convt2 = self.deconv2(conv6)\n        concat2 = torch.cat([convt2,conv3],dim=1)\n        conv7 = self.layer7_conv(concat2)\n      \n        convt3 = self.deconv3(conv7)\n        concat3 = torch.cat([convt3,conv2],dim=1)\n        conv8 = self.layer8_conv(concat3)\n      \n        convt4 = self.deconv4(conv8)\n        concat4 = torch.cat([convt4,conv1],dim=1)\n        conv9 = self.layer9_conv(concat4)\n        outp = self.layer10_conv(conv9)\n        outp = self.sigmoid(outp)\n        return outp\n  \n\nmodel = Unet()\ninp = torch.rand(10,1,224,224)\noutp = model(inp)\nprint(outp.shape)\n==> torch.Size([10, 1, 224, 224])\n```\n\n#### 相关资源\n\n##### 项目\n\n> https://github.com/Andy-zhujunwen/UNET-ZOO?tab=readme-ov-file`<br>`\n> https://github.com/bigmb/Unet-Segmentation-Pytorch-Nest-of-Unets`<br>`\n> https://www.codewithgpu.com/i/bubbliiiing/unet-pytorch/UNet-PyTorch`<br>`\n> https://huggingface.co/spaces/h2chen/demo_unet\n\n##### 博客\n\n> [UNet详解（附图文和代码实现）-CSDN博客](https://blog.csdn.net/weixin_45074568/article/details/114901600)`<br>`\n> [图像分割必备知识点 | Unet详解 理论+ 代码 - 忽逢桃林 - 博客园](https://www.cnblogs.com/PythonLearner/p/14041874.html)\n\n---\n","slug":"2025-02-15-语义分割","published":1,"updated":"2025-09-26T12:15:08.448Z","_id":"cmg0saj3u000ajm8ncay9g24a","comments":1,"layout":"post","photos":[],"content":"<h1 id=\"前言\"><a href=\"#前言\" class=\"headerlink\" title=\"前言\"></a>前言</h1><p>在开始这篇文章之前，我们得首先弄明白，什么是图像分割？</p>\n<p>我们知道一个图像只不过是许多像素的集合。图像分割分类是对图像中属于特定类别的像素进行分类的过程，即像素级别的下游任务。因此图像分割简单来说就是按像素进行分类的问题。</p>\n<p>传统的图像分割算法均是基于灰度值的不连续和相似的性质。而基于深度学习的图像分割技术则是利用卷积神经网络，来理解图像中的每个像素所代表的真实世界物体，这在以前是难以想象的。</p>\n<p><img src=\"https://tk-pichost-1325224430.cos.ap-chengdu.myqcloud.com/blog/1740235822031FRBrbtq8Zogp1oxNSIhcx7Z6nVb.png\" alt=\"1740235822031FRBrbtq8Zogp1oxNSIhcx7Z6nVb.png\"></p>\n<h1 id=\"语义分割（Semantic-Segmentation）\"><a href=\"#语义分割（Semantic-Segmentation）\" class=\"headerlink\" title=\"语义分割（Semantic Segmentation）\"></a><strong>语义分割（Semantic Segmentation）</strong></h1><h2 id=\"定义\"><a href=\"#定义\" class=\"headerlink\" title=\"** 定义**\"></a>** 定义**</h2><p>“语义”是个很抽象的概念，在 2D 图像领域，每个像素点作为最小单位，它的像素值代表的就是一个特征，即“语义”信息。语义分割会为图像中的每个像素分配一个类别，但是同一类别之间的对象不会区分。而实例分割，只对特定的物体进行分类。这看起来与目标检测相似，不同的是目标检测输出目标的边界框和类别，实例分割输出的是目标的 Mask 和类别。具体而言，语义分割的目的是为了从像素级别理解图像的内容，并为图像中的每个像素分配一个对象类。</p>\n<p>语义分割是一种将图像中的每个像素分配给特定类别的技术。其目标是识别图像中存在的各种对象和背景，并为每个像素分配相应的类别标签。例如，将图像中的像素划分为人、树、草地和天空等不同区域。是图像处理和机器视觉一个重要分支。与分类任务不同，语义分割需要判断图像每个像素点的类别，进行精确分割。语义分割目前在自动驾驶、自动抠图、医疗影像等领域有着比较广泛的应用。</p>\n<h2 id=\"特点\"><a href=\"#特点\" class=\"headerlink\" title=\"** 特点**\"></a>** 特点**</h2><ul>\n<li>提供精确的像素级分类，有助于深入理解图像内容。</li>\n<li>无法区分同一类别中的不同实例。</li>\n</ul>\n<h2 id=\"语义分割的应用\"><a href=\"#语义分割的应用\" class=\"headerlink\" title=\"** 语义分割的应用**\"></a>** 语义分割的应用**</h2><p>语义分割在多个领域有广泛应用：</p>\n<ul>\n<li><strong>自动驾驶</strong>：用于道路、车辆和行人的识别。</li>\n<li><strong>医学成像</strong>：用于组织和器官的分割。</li>\n<li><strong>卫星遥感</strong>：用于土地覆盖分类。</li>\n</ul>\n<h2 id=\"常见模型\"><a href=\"#常见模型\" class=\"headerlink\" title=\"** 常见模型**\"></a>** 常见模型**</h2><h3 id=\"FCN（Fully-Convolutional-Network）\"><a href=\"#FCN（Fully-Convolutional-Network）\" class=\"headerlink\" title=\"FCN（Fully Convolutional Network）\"></a><strong>FCN（Fully Convolutional Network）</strong></h3><ul>\n<li><strong>优点</strong>：简单易用，但是现在已经很少使用了,但它的历史贡献不可忽视。</li>\n<li><strong>缺点</strong>：分割精度较低，可能无法很好地处理细节。</li>\n</ul>\n<h4 id=\"提出初衷\"><a href=\"#提出初衷\" class=\"headerlink\" title=\"提出初衷\"></a>提出初衷</h4><p><img src=\"https://tk-pichost-1325224430.cos.ap-chengdu.myqcloud.com/blog/1740236704772Z5SNbToLOosLf9xBvllcevjVnEe.png\" alt=\"1740236704772Z5SNbToLOosLf9xBvllcevjVnEe.png\"><br>FCN（全卷积网络）模型的初衷是为了解决传统卷积神经网络（CNN）在语义分割任务中的局限性。具体而言，传统 CNN 使用全连接层进行分类，这会丢失图像的空间位置信息，导致其不适合像素级的预测任务。FCN 的核心动机包括：</p>\n<ol>\n<li><strong>实现端到端的像素级预测</strong>：FCN 通过将全连接层替换为卷积层，使得网络能够接受任意尺寸的输入图像，并输出与输入尺寸相同的像素级预测结果。</li>\n<li><strong>保留空间信息</strong>：取消全连接层后，FCN 能够保留图像的空间位置信息，从而更好地适应语义分割任务。</li>\n<li><strong>提高分割效率和精度</strong>：通过引入反卷积层（上采样层）和跳跃连接（Skip Connections），FCN 能够融合不同深度的特征，兼顾全局语义信息和局部细节，从而提升分割精度。</li>\n<li><strong>利用预训练模型加速训练</strong>：FCN 可以基于预训练的分类模型（如 AlexNet、VGG 等）进行微调，从而显著加速训练过程并提高模型性能。</li>\n</ol>\n<h4 id=\"网络结构\"><a href=\"#网络结构\" class=\"headerlink\" title=\"网络结构\"></a>网络结构</h4><p><img src=\"https://tk-pichost-1325224430.cos.ap-chengdu.myqcloud.com/blog/1740236686503VcqtbHWWQoRtJIxgy6bconZQnHc.png\" alt=\"1740236686503VcqtbHWWQoRtJIxgy6bconZQnHc.png\"><br>通常 CNN 网络在卷积层之后会接上若干个全连接层, 将卷积层产生的特征图(feature map)映射成一个固定长度的特征向量。以 AlexNet 为代表的经典 CNN 结构适合于图像级的分类和回归任务，因为它们最后都期望得到整个输入图像的一个数值描述（概率）。<br>FCN 对图像进行像素级的分类，从而解决了语义级别的图像分割（semantic segmentation）问题。与经典的 CNN 在卷积层之后使用全连接层得到固定长度的特征向量进行分类（全连接层 ＋softmax 输出）不同，FCN 可以接受任意尺寸的输入图像，采用反卷积层对最后一个卷积层的 feature map 进行上采样, 使它恢复到输入图像相同的尺寸，从而可以对每个像素都产生了一个预测, 同时保留了原始输入图像中的空间信息, 最后在上采样的特征图上进行逐像素分类。<br><img src=\"https://tk-pichost-1325224430.cos.ap-chengdu.myqcloud.com/blog/1740236781446CxZ6b4zcXo9A12xuNJtcEgA7nfc.png\" alt=\"1740236781446CxZ6b4zcXo9A12xuNJtcEgA7nfc.png\"><br>FCN（全卷积网络）为了解决语义分割（semantic segmentation）问题而提出，它对图像进行像素级的分类，能够保留原始输入图像中的空间信息。与传统 CNN 不同，FCN 可以接受任意尺寸的输入图像，并通过以下方式实现像素级分类：</p>\n<ol>\n<li><strong>去除全连接层</strong>：FCN 将传统 CNN 中的全连接层替换为卷积层，从而保留空间信息。</li>\n<li><strong>上采样操作</strong>：使用反卷积层（上采样层）对最后一个卷积层的特征图进行上采样，恢复到与输入图像相同的尺寸。</li>\n<li><strong>逐像素分类</strong>：在上采样后的特征图上进行逐像素分类，为每个像素生成类别预测。</li>\n</ol>\n<blockquote>\n<p>Q:<strong>FCN 是如何通过上采样操作恢复特征图的空间分辨率的？</strong></p>\n</blockquote>\n<h4 id=\"模型代码\"><a href=\"#模型代码\" class=\"headerlink\" title=\"模型代码\"></a>模型代码</h4><h5 id=\"论文源码\"><a href=\"#论文源码\" class=\"headerlink\" title=\"论文源码\"></a>论文源码</h5><figure class=\"highlight python\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br><span class=\"line\">47</span><br><span class=\"line\">48</span><br><span class=\"line\">49</span><br><span class=\"line\">50</span><br><span class=\"line\">51</span><br><span class=\"line\">52</span><br><span class=\"line\">53</span><br><span class=\"line\">54</span><br><span class=\"line\">55</span><br><span class=\"line\">56</span><br><span class=\"line\">57</span><br><span class=\"line\">58</span><br><span class=\"line\">59</span><br><span class=\"line\">60</span><br><span class=\"line\">61</span><br><span class=\"line\">62</span><br><span class=\"line\">63</span><br><span class=\"line\">64</span><br><span class=\"line\">65</span><br><span class=\"line\">66</span><br><span class=\"line\">67</span><br><span class=\"line\">68</span><br><span class=\"line\">69</span><br><span class=\"line\">70</span><br><span class=\"line\">71</span><br><span class=\"line\">72</span><br><span class=\"line\">73</span><br><span class=\"line\">74</span><br><span class=\"line\">75</span><br><span class=\"line\">76</span><br><span class=\"line\">77</span><br><span class=\"line\">78</span><br><span class=\"line\">79</span><br><span class=\"line\">80</span><br><span class=\"line\">81</span><br><span class=\"line\">82</span><br><span class=\"line\">83</span><br><span class=\"line\">84</span><br><span class=\"line\">85</span><br><span class=\"line\">86</span><br><span class=\"line\">87</span><br><span class=\"line\">88</span><br><span class=\"line\">89</span><br><span class=\"line\">90</span><br><span class=\"line\">91</span><br><span class=\"line\">92</span><br><span class=\"line\">93</span><br><span class=\"line\">94</span><br><span class=\"line\">95</span><br><span class=\"line\">96</span><br><span class=\"line\">97</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">import</span> caffe</span><br><span class=\"line\"><span class=\"keyword\">from</span> caffe <span class=\"keyword\">import</span> layers <span class=\"keyword\">as</span> L, params <span class=\"keyword\">as</span> P</span><br><span class=\"line\"><span class=\"keyword\">from</span> caffe.coord_map <span class=\"keyword\">import</span> crop</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">def</span> <span class=\"title function_\">conv_relu</span>(<span class=\"params\">bottom, nout, ks=<span class=\"number\">3</span>, stride=<span class=\"number\">1</span>, pad=<span class=\"number\">1</span></span>):</span><br><span class=\"line\">    conv = L.Convolution(bottom, kernel_size=ks, stride=stride,</span><br><span class=\"line\">        num_output=nout, pad=pad,</span><br><span class=\"line\">        param=[<span class=\"built_in\">dict</span>(lr_mult=<span class=\"number\">1</span>, decay_mult=<span class=\"number\">1</span>), <span class=\"built_in\">dict</span>(lr_mult=<span class=\"number\">2</span>, decay_mult=<span class=\"number\">0</span>)])</span><br><span class=\"line\">    <span class=\"keyword\">return</span> conv, L.ReLU(conv, in_place=<span class=\"literal\">True</span>)</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">def</span> <span class=\"title function_\">max_pool</span>(<span class=\"params\">bottom, ks=<span class=\"number\">2</span>, stride=<span class=\"number\">2</span></span>):</span><br><span class=\"line\">    <span class=\"keyword\">return</span> L.Pooling(bottom, pool=P.Pooling.MAX, kernel_size=ks, stride=stride)</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">def</span> <span class=\"title function_\">fcn</span>(<span class=\"params\">split</span>):</span><br><span class=\"line\">    n = caffe.NetSpec()</span><br><span class=\"line\">    pydata_params = <span class=\"built_in\">dict</span>(split=split, mean=(<span class=\"number\">104.00699</span>, <span class=\"number\">116.66877</span>, <span class=\"number\">122.67892</span>),</span><br><span class=\"line\">            seed=<span class=\"number\">1337</span>)</span><br><span class=\"line\">    <span class=\"keyword\">if</span> split == <span class=\"string\">&#x27;train&#x27;</span>:</span><br><span class=\"line\">        pydata_params[<span class=\"string\">&#x27;sbdd_dir&#x27;</span>] = <span class=\"string\">&#x27;../data/sbdd/dataset&#x27;</span></span><br><span class=\"line\">        pylayer = <span class=\"string\">&#x27;SBDDSegDataLayer&#x27;</span></span><br><span class=\"line\">    <span class=\"keyword\">else</span>:</span><br><span class=\"line\">        pydata_params[<span class=\"string\">&#x27;voc_dir&#x27;</span>] = <span class=\"string\">&#x27;../data/pascal/VOC2011&#x27;</span></span><br><span class=\"line\">        pylayer = <span class=\"string\">&#x27;VOCSegDataLayer&#x27;</span></span><br><span class=\"line\">    n.data, n.label = L.Python(module=<span class=\"string\">&#x27;voc_layers&#x27;</span>, layer=pylayer,</span><br><span class=\"line\">            ntop=<span class=\"number\">2</span>, param_str=<span class=\"built_in\">str</span>(pydata_params))</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\"># the base net</span></span><br><span class=\"line\">    n.conv1_1, n.relu1_1 = conv_relu(n.data, <span class=\"number\">64</span>, pad=<span class=\"number\">100</span>)</span><br><span class=\"line\">    n.conv1_2, n.relu1_2 = conv_relu(n.relu1_1, <span class=\"number\">64</span>)</span><br><span class=\"line\">    n.pool1 = max_pool(n.relu1_2)</span><br><span class=\"line\"></span><br><span class=\"line\">    n.conv2_1, n.relu2_1 = conv_relu(n.pool1, <span class=\"number\">128</span>)</span><br><span class=\"line\">    n.conv2_2, n.relu2_2 = conv_relu(n.relu2_1, <span class=\"number\">128</span>)</span><br><span class=\"line\">    n.pool2 = max_pool(n.relu2_2)</span><br><span class=\"line\"></span><br><span class=\"line\">    n.conv3_1, n.relu3_1 = conv_relu(n.pool2, <span class=\"number\">256</span>)</span><br><span class=\"line\">    n.conv3_2, n.relu3_2 = conv_relu(n.relu3_1, <span class=\"number\">256</span>)</span><br><span class=\"line\">    n.conv3_3, n.relu3_3 = conv_relu(n.relu3_2, <span class=\"number\">256</span>)</span><br><span class=\"line\">    n.pool3 = max_pool(n.relu3_3)</span><br><span class=\"line\"></span><br><span class=\"line\">    n.conv4_1, n.relu4_1 = conv_relu(n.pool3, <span class=\"number\">512</span>)</span><br><span class=\"line\">    n.conv4_2, n.relu4_2 = conv_relu(n.relu4_1, <span class=\"number\">512</span>)</span><br><span class=\"line\">    n.conv4_3, n.relu4_3 = conv_relu(n.relu4_2, <span class=\"number\">512</span>)</span><br><span class=\"line\">    n.pool4 = max_pool(n.relu4_3)</span><br><span class=\"line\"></span><br><span class=\"line\">    n.conv5_1, n.relu5_1 = conv_relu(n.pool4, <span class=\"number\">512</span>)</span><br><span class=\"line\">    n.conv5_2, n.relu5_2 = conv_relu(n.relu5_1, <span class=\"number\">512</span>)</span><br><span class=\"line\">    n.conv5_3, n.relu5_3 = conv_relu(n.relu5_2, <span class=\"number\">512</span>)</span><br><span class=\"line\">    n.pool5 = max_pool(n.relu5_3)</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\"># fully conv</span></span><br><span class=\"line\">    n.fc6, n.relu6 = conv_relu(n.pool5, <span class=\"number\">4096</span>, ks=<span class=\"number\">7</span>, pad=<span class=\"number\">0</span>)</span><br><span class=\"line\">    n.drop6 = L.Dropout(n.relu6, dropout_ratio=<span class=\"number\">0.5</span>, in_place=<span class=\"literal\">True</span>)</span><br><span class=\"line\">    n.fc7, n.relu7 = conv_relu(n.drop6, <span class=\"number\">4096</span>, ks=<span class=\"number\">1</span>, pad=<span class=\"number\">0</span>)</span><br><span class=\"line\">    n.drop7 = L.Dropout(n.relu7, dropout_ratio=<span class=\"number\">0.5</span>, in_place=<span class=\"literal\">True</span>)</span><br><span class=\"line\">    n.score_fr = L.Convolution(n.drop7, num_output=<span class=\"number\">21</span>, kernel_size=<span class=\"number\">1</span>, pad=<span class=\"number\">0</span>,</span><br><span class=\"line\">        param=[<span class=\"built_in\">dict</span>(lr_mult=<span class=\"number\">1</span>, decay_mult=<span class=\"number\">1</span>), <span class=\"built_in\">dict</span>(lr_mult=<span class=\"number\">2</span>, decay_mult=<span class=\"number\">0</span>)])</span><br><span class=\"line\">    n.upscore2 = L.Deconvolution(n.score_fr,</span><br><span class=\"line\">        convolution_param=<span class=\"built_in\">dict</span>(num_output=<span class=\"number\">21</span>, kernel_size=<span class=\"number\">4</span>, stride=<span class=\"number\">2</span>,</span><br><span class=\"line\">            bias_term=<span class=\"literal\">False</span>),</span><br><span class=\"line\">        param=[<span class=\"built_in\">dict</span>(lr_mult=<span class=\"number\">0</span>)])</span><br><span class=\"line\"></span><br><span class=\"line\">    n.score_pool4 = L.Convolution(n.pool4, num_output=<span class=\"number\">21</span>, kernel_size=<span class=\"number\">1</span>, pad=<span class=\"number\">0</span>,</span><br><span class=\"line\">        param=[<span class=\"built_in\">dict</span>(lr_mult=<span class=\"number\">1</span>, decay_mult=<span class=\"number\">1</span>), <span class=\"built_in\">dict</span>(lr_mult=<span class=\"number\">2</span>, decay_mult=<span class=\"number\">0</span>)])</span><br><span class=\"line\">    n.score_pool4c = crop(n.score_pool4, n.upscore2)</span><br><span class=\"line\">    n.fuse_pool4 = L.Eltwise(n.upscore2, n.score_pool4c,</span><br><span class=\"line\">            operation=P.Eltwise.SUM)</span><br><span class=\"line\">    n.upscore_pool4 = L.Deconvolution(n.fuse_pool4,</span><br><span class=\"line\">        convolution_param=<span class=\"built_in\">dict</span>(num_output=<span class=\"number\">21</span>, kernel_size=<span class=\"number\">4</span>, stride=<span class=\"number\">2</span>,</span><br><span class=\"line\">            bias_term=<span class=\"literal\">False</span>),</span><br><span class=\"line\">        param=[<span class=\"built_in\">dict</span>(lr_mult=<span class=\"number\">0</span>)])</span><br><span class=\"line\"></span><br><span class=\"line\">    n.score_pool3 = L.Convolution(n.pool3, num_output=<span class=\"number\">21</span>, kernel_size=<span class=\"number\">1</span>, pad=<span class=\"number\">0</span>,</span><br><span class=\"line\">        param=[<span class=\"built_in\">dict</span>(lr_mult=<span class=\"number\">1</span>, decay_mult=<span class=\"number\">1</span>), <span class=\"built_in\">dict</span>(lr_mult=<span class=\"number\">2</span>, decay_mult=<span class=\"number\">0</span>)])</span><br><span class=\"line\">    n.score_pool3c = crop(n.score_pool3, n.upscore_pool4)</span><br><span class=\"line\">    n.fuse_pool3 = L.Eltwise(n.upscore_pool4, n.score_pool3c,</span><br><span class=\"line\">            operation=P.Eltwise.SUM)</span><br><span class=\"line\">    n.upscore8 = L.Deconvolution(n.fuse_pool3,</span><br><span class=\"line\">        convolution_param=<span class=\"built_in\">dict</span>(num_output=<span class=\"number\">21</span>, kernel_size=<span class=\"number\">16</span>, stride=<span class=\"number\">8</span>,</span><br><span class=\"line\">            bias_term=<span class=\"literal\">False</span>),</span><br><span class=\"line\">        param=[<span class=\"built_in\">dict</span>(lr_mult=<span class=\"number\">0</span>)])</span><br><span class=\"line\"></span><br><span class=\"line\">    n.score = crop(n.upscore8, n.data)</span><br><span class=\"line\">    n.loss = L.SoftmaxWithLoss(n.score, n.label,</span><br><span class=\"line\">            loss_param=<span class=\"built_in\">dict</span>(normalize=<span class=\"literal\">False</span>, ignore_label=<span class=\"number\">255</span>))</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">return</span> n.to_proto()</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">def</span> <span class=\"title function_\">make_net</span>():</span><br><span class=\"line\">    <span class=\"keyword\">with</span> <span class=\"built_in\">open</span>(<span class=\"string\">&#x27;train.prototxt&#x27;</span>, <span class=\"string\">&#x27;w&#x27;</span>) <span class=\"keyword\">as</span> f:</span><br><span class=\"line\">        f.write(<span class=\"built_in\">str</span>(fcn(<span class=\"string\">&#x27;train&#x27;</span>)))</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">with</span> <span class=\"built_in\">open</span>(<span class=\"string\">&#x27;val.prototxt&#x27;</span>, <span class=\"string\">&#x27;w&#x27;</span>) <span class=\"keyword\">as</span> f:</span><br><span class=\"line\">        f.write(<span class=\"built_in\">str</span>(fcn(<span class=\"string\">&#x27;seg11valid&#x27;</span>)))</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">if</span> __name__ == <span class=\"string\">&#x27;__main__&#x27;</span>:</span><br><span class=\"line\">    make_net()</span><br></pre></td></tr></table></figure>\n\n<h5 id=\"fcn8-vgg\"><a href=\"#fcn8-vgg\" class=\"headerlink\" title=\"fcn8_vgg\"></a>fcn8_vgg</h5><figure class=\"highlight python\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br><span class=\"line\">47</span><br><span class=\"line\">48</span><br><span class=\"line\">49</span><br><span class=\"line\">50</span><br><span class=\"line\">51</span><br><span class=\"line\">52</span><br><span class=\"line\">53</span><br><span class=\"line\">54</span><br><span class=\"line\">55</span><br><span class=\"line\">56</span><br><span class=\"line\">57</span><br><span class=\"line\">58</span><br><span class=\"line\">59</span><br><span class=\"line\">60</span><br><span class=\"line\">61</span><br><span class=\"line\">62</span><br><span class=\"line\">63</span><br><span class=\"line\">64</span><br><span class=\"line\">65</span><br><span class=\"line\">66</span><br><span class=\"line\">67</span><br><span class=\"line\">68</span><br><span class=\"line\">69</span><br><span class=\"line\">70</span><br><span class=\"line\">71</span><br><span class=\"line\">72</span><br><span class=\"line\">73</span><br><span class=\"line\">74</span><br><span class=\"line\">75</span><br><span class=\"line\">76</span><br><span class=\"line\">77</span><br><span class=\"line\">78</span><br><span class=\"line\">79</span><br><span class=\"line\">80</span><br><span class=\"line\">81</span><br><span class=\"line\">82</span><br><span class=\"line\">83</span><br><span class=\"line\">84</span><br><span class=\"line\">85</span><br><span class=\"line\">86</span><br><span class=\"line\">87</span><br><span class=\"line\">88</span><br><span class=\"line\">89</span><br><span class=\"line\">90</span><br><span class=\"line\">91</span><br><span class=\"line\">92</span><br><span class=\"line\">93</span><br><span class=\"line\">94</span><br><span class=\"line\">95</span><br><span class=\"line\">96</span><br><span class=\"line\">97</span><br><span class=\"line\">98</span><br><span class=\"line\">99</span><br><span class=\"line\">100</span><br><span class=\"line\">101</span><br><span class=\"line\">102</span><br><span class=\"line\">103</span><br><span class=\"line\">104</span><br><span class=\"line\">105</span><br><span class=\"line\">106</span><br><span class=\"line\">107</span><br><span class=\"line\">108</span><br><span class=\"line\">109</span><br><span class=\"line\">110</span><br><span class=\"line\">111</span><br><span class=\"line\">112</span><br><span class=\"line\">113</span><br><span class=\"line\">114</span><br><span class=\"line\">115</span><br><span class=\"line\">116</span><br><span class=\"line\">117</span><br><span class=\"line\">118</span><br><span class=\"line\">119</span><br><span class=\"line\">120</span><br><span class=\"line\">121</span><br><span class=\"line\">122</span><br><span class=\"line\">123</span><br><span class=\"line\">124</span><br><span class=\"line\">125</span><br><span class=\"line\">126</span><br><span class=\"line\">127</span><br><span class=\"line\">128</span><br><span class=\"line\">129</span><br><span class=\"line\">130</span><br><span class=\"line\">131</span><br><span class=\"line\">132</span><br><span class=\"line\">133</span><br><span class=\"line\">134</span><br><span class=\"line\">135</span><br><span class=\"line\">136</span><br><span class=\"line\">137</span><br><span class=\"line\">138</span><br><span class=\"line\">139</span><br><span class=\"line\">140</span><br><span class=\"line\">141</span><br><span class=\"line\">142</span><br><span class=\"line\">143</span><br><span class=\"line\">144</span><br><span class=\"line\">145</span><br><span class=\"line\">146</span><br><span class=\"line\">147</span><br><span class=\"line\">148</span><br><span class=\"line\">149</span><br><span class=\"line\">150</span><br><span class=\"line\">151</span><br><span class=\"line\">152</span><br><span class=\"line\">153</span><br><span class=\"line\">154</span><br><span class=\"line\">155</span><br><span class=\"line\">156</span><br><span class=\"line\">157</span><br><span class=\"line\">158</span><br><span class=\"line\">159</span><br><span class=\"line\">160</span><br><span class=\"line\">161</span><br><span class=\"line\">162</span><br><span class=\"line\">163</span><br><span class=\"line\">164</span><br><span class=\"line\">165</span><br><span class=\"line\">166</span><br><span class=\"line\">167</span><br><span class=\"line\">168</span><br><span class=\"line\">169</span><br><span class=\"line\">170</span><br><span class=\"line\">171</span><br><span class=\"line\">172</span><br><span class=\"line\">173</span><br><span class=\"line\">174</span><br><span class=\"line\">175</span><br><span class=\"line\">176</span><br><span class=\"line\">177</span><br><span class=\"line\">178</span><br><span class=\"line\">179</span><br><span class=\"line\">180</span><br><span class=\"line\">181</span><br><span class=\"line\">182</span><br><span class=\"line\">183</span><br><span class=\"line\">184</span><br><span class=\"line\">185</span><br><span class=\"line\">186</span><br><span class=\"line\">187</span><br><span class=\"line\">188</span><br><span class=\"line\">189</span><br><span class=\"line\">190</span><br><span class=\"line\">191</span><br><span class=\"line\">192</span><br><span class=\"line\">193</span><br><span class=\"line\">194</span><br><span class=\"line\">195</span><br><span class=\"line\">196</span><br><span class=\"line\">197</span><br><span class=\"line\">198</span><br><span class=\"line\">199</span><br><span class=\"line\">200</span><br><span class=\"line\">201</span><br><span class=\"line\">202</span><br><span class=\"line\">203</span><br><span class=\"line\">204</span><br><span class=\"line\">205</span><br><span class=\"line\">206</span><br><span class=\"line\">207</span><br><span class=\"line\">208</span><br><span class=\"line\">209</span><br><span class=\"line\">210</span><br><span class=\"line\">211</span><br><span class=\"line\">212</span><br><span class=\"line\">213</span><br><span class=\"line\">214</span><br><span class=\"line\">215</span><br><span class=\"line\">216</span><br><span class=\"line\">217</span><br><span class=\"line\">218</span><br><span class=\"line\">219</span><br><span class=\"line\">220</span><br><span class=\"line\">221</span><br><span class=\"line\">222</span><br><span class=\"line\">223</span><br><span class=\"line\">224</span><br><span class=\"line\">225</span><br><span class=\"line\">226</span><br><span class=\"line\">227</span><br><span class=\"line\">228</span><br><span class=\"line\">229</span><br><span class=\"line\">230</span><br><span class=\"line\">231</span><br><span class=\"line\">232</span><br><span class=\"line\">233</span><br><span class=\"line\">234</span><br><span class=\"line\">235</span><br><span class=\"line\">236</span><br><span class=\"line\">237</span><br><span class=\"line\">238</span><br><span class=\"line\">239</span><br><span class=\"line\">240</span><br><span class=\"line\">241</span><br><span class=\"line\">242</span><br><span class=\"line\">243</span><br><span class=\"line\">244</span><br><span class=\"line\">245</span><br><span class=\"line\">246</span><br><span class=\"line\">247</span><br><span class=\"line\">248</span><br><span class=\"line\">249</span><br><span class=\"line\">250</span><br><span class=\"line\">251</span><br><span class=\"line\">252</span><br><span class=\"line\">253</span><br><span class=\"line\">254</span><br><span class=\"line\">255</span><br><span class=\"line\">256</span><br><span class=\"line\">257</span><br><span class=\"line\">258</span><br><span class=\"line\">259</span><br><span class=\"line\">260</span><br><span class=\"line\">261</span><br><span class=\"line\">262</span><br><span class=\"line\">263</span><br><span class=\"line\">264</span><br><span class=\"line\">265</span><br><span class=\"line\">266</span><br><span class=\"line\">267</span><br><span class=\"line\">268</span><br><span class=\"line\">269</span><br><span class=\"line\">270</span><br><span class=\"line\">271</span><br><span class=\"line\">272</span><br><span class=\"line\">273</span><br><span class=\"line\">274</span><br><span class=\"line\">275</span><br><span class=\"line\">276</span><br><span class=\"line\">277</span><br><span class=\"line\">278</span><br><span class=\"line\">279</span><br><span class=\"line\">280</span><br><span class=\"line\">281</span><br><span class=\"line\">282</span><br><span class=\"line\">283</span><br><span class=\"line\">284</span><br><span class=\"line\">285</span><br><span class=\"line\">286</span><br><span class=\"line\">287</span><br><span class=\"line\">288</span><br><span class=\"line\">289</span><br><span class=\"line\">290</span><br><span class=\"line\">291</span><br><span class=\"line\">292</span><br><span class=\"line\">293</span><br><span class=\"line\">294</span><br><span class=\"line\">295</span><br><span class=\"line\">296</span><br><span class=\"line\">297</span><br><span class=\"line\">298</span><br><span class=\"line\">299</span><br><span class=\"line\">300</span><br><span class=\"line\">301</span><br><span class=\"line\">302</span><br><span class=\"line\">303</span><br><span class=\"line\">304</span><br><span class=\"line\">305</span><br><span class=\"line\">306</span><br><span class=\"line\">307</span><br><span class=\"line\">308</span><br><span class=\"line\">309</span><br><span class=\"line\">310</span><br><span class=\"line\">311</span><br><span class=\"line\">312</span><br><span class=\"line\">313</span><br><span class=\"line\">314</span><br><span class=\"line\">315</span><br><span class=\"line\">316</span><br><span class=\"line\">317</span><br><span class=\"line\">318</span><br><span class=\"line\">319</span><br><span class=\"line\">320</span><br><span class=\"line\">321</span><br><span class=\"line\">322</span><br><span class=\"line\">323</span><br><span class=\"line\">324</span><br><span class=\"line\">325</span><br><span class=\"line\">326</span><br><span class=\"line\">327</span><br><span class=\"line\">328</span><br><span class=\"line\">329</span><br><span class=\"line\">330</span><br><span class=\"line\">331</span><br><span class=\"line\">332</span><br><span class=\"line\">333</span><br><span class=\"line\">334</span><br><span class=\"line\">335</span><br><span class=\"line\">336</span><br><span class=\"line\">337</span><br><span class=\"line\">338</span><br><span class=\"line\">339</span><br><span class=\"line\">340</span><br><span class=\"line\">341</span><br><span class=\"line\">342</span><br><span class=\"line\">343</span><br><span class=\"line\">344</span><br><span class=\"line\">345</span><br><span class=\"line\">346</span><br><span class=\"line\">347</span><br><span class=\"line\">348</span><br><span class=\"line\">349</span><br><span class=\"line\">350</span><br><span class=\"line\">351</span><br><span class=\"line\">352</span><br><span class=\"line\">353</span><br><span class=\"line\">354</span><br><span class=\"line\">355</span><br><span class=\"line\">356</span><br><span class=\"line\">357</span><br><span class=\"line\">358</span><br><span class=\"line\">359</span><br><span class=\"line\">360</span><br><span class=\"line\">361</span><br><span class=\"line\">362</span><br><span class=\"line\">363</span><br><span class=\"line\">364</span><br><span class=\"line\">365</span><br><span class=\"line\">366</span><br><span class=\"line\">367</span><br><span class=\"line\">368</span><br><span class=\"line\">369</span><br><span class=\"line\">370</span><br><span class=\"line\">371</span><br><span class=\"line\">372</span><br><span class=\"line\">373</span><br><span class=\"line\">374</span><br><span class=\"line\">375</span><br><span class=\"line\">376</span><br><span class=\"line\">377</span><br><span class=\"line\">378</span><br><span class=\"line\">379</span><br><span class=\"line\">380</span><br><span class=\"line\">381</span><br><span class=\"line\">382</span><br><span class=\"line\">383</span><br><span class=\"line\">384</span><br><span class=\"line\">385</span><br><span class=\"line\">386</span><br><span class=\"line\">387</span><br><span class=\"line\">388</span><br><span class=\"line\">389</span><br><span class=\"line\">390</span><br><span class=\"line\">391</span><br><span class=\"line\">392</span><br><span class=\"line\">393</span><br><span class=\"line\">394</span><br><span class=\"line\">395</span><br><span class=\"line\">396</span><br><span class=\"line\">397</span><br><span class=\"line\">398</span><br><span class=\"line\">399</span><br><span class=\"line\">400</span><br><span class=\"line\">401</span><br><span class=\"line\">402</span><br><span class=\"line\">403</span><br><span class=\"line\">404</span><br><span class=\"line\">405</span><br><span class=\"line\">406</span><br><span class=\"line\">407</span><br><span class=\"line\">408</span><br><span class=\"line\">409</span><br><span class=\"line\">410</span><br><span class=\"line\">411</span><br><span class=\"line\">412</span><br><span class=\"line\">413</span><br><span class=\"line\">414</span><br><span class=\"line\">415</span><br><span class=\"line\">416</span><br><span class=\"line\">417</span><br><span class=\"line\">418</span><br><span class=\"line\">419</span><br><span class=\"line\">420</span><br><span class=\"line\">421</span><br><span class=\"line\">422</span><br><span class=\"line\">423</span><br><span class=\"line\">424</span><br><span class=\"line\">425</span><br><span class=\"line\">426</span><br><span class=\"line\">427</span><br><span class=\"line\">428</span><br><span class=\"line\">429</span><br><span class=\"line\">430</span><br><span class=\"line\">431</span><br><span class=\"line\">432</span><br><span class=\"line\">433</span><br><span class=\"line\">434</span><br><span class=\"line\">435</span><br><span class=\"line\">436</span><br><span class=\"line\">437</span><br><span class=\"line\">438</span><br><span class=\"line\">439</span><br><span class=\"line\">440</span><br><span class=\"line\">441</span><br><span class=\"line\">442</span><br><span class=\"line\">443</span><br><span class=\"line\">444</span><br><span class=\"line\">445</span><br><span class=\"line\">446</span><br><span class=\"line\">447</span><br><span class=\"line\">448</span><br><span class=\"line\">449</span><br><span class=\"line\">450</span><br><span class=\"line\">451</span><br><span class=\"line\">452</span><br><span class=\"line\">453</span><br><span class=\"line\">454</span><br><span class=\"line\">455</span><br><span class=\"line\">456</span><br><span class=\"line\">457</span><br><span class=\"line\">458</span><br><span class=\"line\">459</span><br><span class=\"line\">460</span><br><span class=\"line\">461</span><br><span class=\"line\">462</span><br><span class=\"line\">463</span><br><span class=\"line\">464</span><br><span class=\"line\">465</span><br><span class=\"line\">466</span><br><span class=\"line\">467</span><br><span class=\"line\">468</span><br><span class=\"line\">469</span><br><span class=\"line\">470</span><br><span class=\"line\">471</span><br><span class=\"line\">472</span><br><span class=\"line\">473</span><br><span class=\"line\">474</span><br><span class=\"line\">475</span><br><span class=\"line\">476</span><br><span class=\"line\">477</span><br><span class=\"line\">478</span><br><span class=\"line\">479</span><br><span class=\"line\">480</span><br><span class=\"line\">481</span><br><span class=\"line\">482</span><br><span class=\"line\">483</span><br><span class=\"line\">484</span><br><span class=\"line\">485</span><br><span class=\"line\">486</span><br><span class=\"line\">487</span><br><span class=\"line\">488</span><br><span class=\"line\">489</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">from</span> __future__ <span class=\"keyword\">import</span> absolute_import</span><br><span class=\"line\"><span class=\"keyword\">from</span> __future__ <span class=\"keyword\">import</span> division</span><br><span class=\"line\"><span class=\"keyword\">from</span> __future__ <span class=\"keyword\">import</span> print_function</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">import</span> os</span><br><span class=\"line\"><span class=\"keyword\">import</span> logging</span><br><span class=\"line\"><span class=\"keyword\">from</span> math <span class=\"keyword\">import</span> ceil</span><br><span class=\"line\"><span class=\"keyword\">import</span> sys</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">import</span> numpy <span class=\"keyword\">as</span> np</span><br><span class=\"line\"><span class=\"keyword\">import</span> tensorflow <span class=\"keyword\">as</span> tf</span><br><span class=\"line\"></span><br><span class=\"line\">VGG_MEAN = [<span class=\"number\">103.939</span>, <span class=\"number\">116.779</span>, <span class=\"number\">123.68</span>]</span><br><span class=\"line\"></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">class</span> <span class=\"title class_\">FCN8VGG</span>:</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">def</span> <span class=\"title function_\">__init__</span>(<span class=\"params\">self, vgg16_npy_path=<span class=\"literal\">None</span></span>):</span><br><span class=\"line\">        <span class=\"keyword\">if</span> vgg16_npy_path <span class=\"keyword\">is</span> <span class=\"literal\">None</span>:</span><br><span class=\"line\">            path = sys.modules[<span class=\"variable language_\">self</span>.__class__.__module__].__file__</span><br><span class=\"line\">            <span class=\"comment\"># print path</span></span><br><span class=\"line\">            path = os.path.abspath(os.path.join(path, os.pardir))</span><br><span class=\"line\">            <span class=\"comment\"># print path</span></span><br><span class=\"line\">            path = os.path.join(path, <span class=\"string\">&quot;vgg16.npy&quot;</span>)</span><br><span class=\"line\">            vgg16_npy_path = path</span><br><span class=\"line\">            logging.info(<span class=\"string\">&quot;Load npy file from &#x27;%s&#x27;.&quot;</span>, vgg16_npy_path)</span><br><span class=\"line\">        <span class=\"keyword\">if</span> <span class=\"keyword\">not</span> os.path.isfile(vgg16_npy_path):</span><br><span class=\"line\">            logging.error((<span class=\"string\">&quot;File &#x27;%s&#x27; not found. Download it from &quot;</span></span><br><span class=\"line\">                           <span class=\"string\">&quot;ftp://mi.eng.cam.ac.uk/pub/mttt2/&quot;</span></span><br><span class=\"line\">                           <span class=\"string\">&quot;models/vgg16.npy&quot;</span>), vgg16_npy_path)</span><br><span class=\"line\">            sys.exit(<span class=\"number\">1</span>)</span><br><span class=\"line\"></span><br><span class=\"line\">        <span class=\"variable language_\">self</span>.data_dict = np.load(vgg16_npy_path, encoding=<span class=\"string\">&#x27;latin1&#x27;</span>).item()</span><br><span class=\"line\">        <span class=\"variable language_\">self</span>.wd = <span class=\"number\">5e-4</span></span><br><span class=\"line\">        <span class=\"built_in\">print</span>(<span class=\"string\">&quot;npy file loaded&quot;</span>)</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">def</span> <span class=\"title function_\">build</span>(<span class=\"params\">self, rgb, train=<span class=\"literal\">False</span>, num_classes=<span class=\"number\">20</span>, random_init_fc8=<span class=\"literal\">False</span>,</span></span><br><span class=\"line\"><span class=\"params\">              debug=<span class=\"literal\">False</span>, use_dilated=<span class=\"literal\">False</span></span>):</span><br><span class=\"line\">        <span class=\"string\">&quot;&quot;&quot;</span></span><br><span class=\"line\"><span class=\"string\">        Build the VGG model using loaded weights</span></span><br><span class=\"line\"><span class=\"string\">        Parameters</span></span><br><span class=\"line\"><span class=\"string\">        ----------</span></span><br><span class=\"line\"><span class=\"string\">        rgb: image batch tensor</span></span><br><span class=\"line\"><span class=\"string\">            Image in rgb shap. Scaled to Intervall [0, 255]</span></span><br><span class=\"line\"><span class=\"string\">        train: bool</span></span><br><span class=\"line\"><span class=\"string\">            Whether to build train or inference graph</span></span><br><span class=\"line\"><span class=\"string\">        num_classes: int</span></span><br><span class=\"line\"><span class=\"string\">            How many classes should be predicted (by fc8)</span></span><br><span class=\"line\"><span class=\"string\">        random_init_fc8 : bool</span></span><br><span class=\"line\"><span class=\"string\">            Whether to initialize fc8 layer randomly.</span></span><br><span class=\"line\"><span class=\"string\">            Finetuning is required in this case.</span></span><br><span class=\"line\"><span class=\"string\">        debug: bool</span></span><br><span class=\"line\"><span class=\"string\">            Whether to print additional Debug Information.</span></span><br><span class=\"line\"><span class=\"string\">        &quot;&quot;&quot;</span></span><br><span class=\"line\">        <span class=\"comment\"># Convert RGB to BGR</span></span><br><span class=\"line\"></span><br><span class=\"line\">        <span class=\"keyword\">with</span> tf.name_scope(<span class=\"string\">&#x27;Processing&#x27;</span>):</span><br><span class=\"line\"></span><br><span class=\"line\">            red, green, blue = tf.split(rgb, <span class=\"number\">3</span>, <span class=\"number\">3</span>)</span><br><span class=\"line\">            <span class=\"comment\"># assert red.get_shape().as_list()[1:] == [224, 224, 1]</span></span><br><span class=\"line\">            <span class=\"comment\"># assert green.get_shape().as_list()[1:] == [224, 224, 1]</span></span><br><span class=\"line\">            <span class=\"comment\"># assert blue.get_shape().as_list()[1:] == [224, 224, 1]</span></span><br><span class=\"line\">            bgr = tf.concat([</span><br><span class=\"line\">                blue - VGG_MEAN[<span class=\"number\">0</span>],</span><br><span class=\"line\">                green - VGG_MEAN[<span class=\"number\">1</span>],</span><br><span class=\"line\">                red - VGG_MEAN[<span class=\"number\">2</span>],</span><br><span class=\"line\">            ], <span class=\"number\">3</span>)</span><br><span class=\"line\"></span><br><span class=\"line\">            <span class=\"keyword\">if</span> debug:</span><br><span class=\"line\">                bgr = tf.Print(bgr, [tf.shape(bgr)],</span><br><span class=\"line\">                               message=<span class=\"string\">&#x27;Shape of input image: &#x27;</span>,</span><br><span class=\"line\">                               summarize=<span class=\"number\">4</span>, first_n=<span class=\"number\">1</span>)</span><br><span class=\"line\"></span><br><span class=\"line\">        <span class=\"variable language_\">self</span>.conv1_1 = <span class=\"variable language_\">self</span>._conv_layer(bgr, <span class=\"string\">&quot;conv1_1&quot;</span>)</span><br><span class=\"line\">        <span class=\"variable language_\">self</span>.conv1_2 = <span class=\"variable language_\">self</span>._conv_layer(<span class=\"variable language_\">self</span>.conv1_1, <span class=\"string\">&quot;conv1_2&quot;</span>)</span><br><span class=\"line\">        <span class=\"variable language_\">self</span>.pool1 = <span class=\"variable language_\">self</span>._max_pool(<span class=\"variable language_\">self</span>.conv1_2, <span class=\"string\">&#x27;pool1&#x27;</span>, debug)</span><br><span class=\"line\"></span><br><span class=\"line\">        <span class=\"variable language_\">self</span>.conv2_1 = <span class=\"variable language_\">self</span>._conv_layer(<span class=\"variable language_\">self</span>.pool1, <span class=\"string\">&quot;conv2_1&quot;</span>)</span><br><span class=\"line\">        <span class=\"variable language_\">self</span>.conv2_2 = <span class=\"variable language_\">self</span>._conv_layer(<span class=\"variable language_\">self</span>.conv2_1, <span class=\"string\">&quot;conv2_2&quot;</span>)</span><br><span class=\"line\">        <span class=\"variable language_\">self</span>.pool2 = <span class=\"variable language_\">self</span>._max_pool(<span class=\"variable language_\">self</span>.conv2_2, <span class=\"string\">&#x27;pool2&#x27;</span>, debug)</span><br><span class=\"line\"></span><br><span class=\"line\">        <span class=\"variable language_\">self</span>.conv3_1 = <span class=\"variable language_\">self</span>._conv_layer(<span class=\"variable language_\">self</span>.pool2, <span class=\"string\">&quot;conv3_1&quot;</span>)</span><br><span class=\"line\">        <span class=\"variable language_\">self</span>.conv3_2 = <span class=\"variable language_\">self</span>._conv_layer(<span class=\"variable language_\">self</span>.conv3_1, <span class=\"string\">&quot;conv3_2&quot;</span>)</span><br><span class=\"line\">        <span class=\"variable language_\">self</span>.conv3_3 = <span class=\"variable language_\">self</span>._conv_layer(<span class=\"variable language_\">self</span>.conv3_2, <span class=\"string\">&quot;conv3_3&quot;</span>)</span><br><span class=\"line\">        <span class=\"variable language_\">self</span>.pool3 = <span class=\"variable language_\">self</span>._max_pool(<span class=\"variable language_\">self</span>.conv3_3, <span class=\"string\">&#x27;pool3&#x27;</span>, debug)</span><br><span class=\"line\"></span><br><span class=\"line\">        <span class=\"variable language_\">self</span>.conv4_1 = <span class=\"variable language_\">self</span>._conv_layer(<span class=\"variable language_\">self</span>.pool3, <span class=\"string\">&quot;conv4_1&quot;</span>)</span><br><span class=\"line\">        <span class=\"variable language_\">self</span>.conv4_2 = <span class=\"variable language_\">self</span>._conv_layer(<span class=\"variable language_\">self</span>.conv4_1, <span class=\"string\">&quot;conv4_2&quot;</span>)</span><br><span class=\"line\">        <span class=\"variable language_\">self</span>.conv4_3 = <span class=\"variable language_\">self</span>._conv_layer(<span class=\"variable language_\">self</span>.conv4_2, <span class=\"string\">&quot;conv4_3&quot;</span>)</span><br><span class=\"line\"></span><br><span class=\"line\">        <span class=\"keyword\">if</span> use_dilated:</span><br><span class=\"line\">            pad = [[<span class=\"number\">0</span>, <span class=\"number\">0</span>], [<span class=\"number\">0</span>, <span class=\"number\">0</span>]]</span><br><span class=\"line\">            <span class=\"variable language_\">self</span>.pool4 = tf.nn.max_pool(<span class=\"variable language_\">self</span>.conv4_3, ksize=[<span class=\"number\">1</span>, <span class=\"number\">2</span>, <span class=\"number\">2</span>, <span class=\"number\">1</span>],</span><br><span class=\"line\">                                        strides=[<span class=\"number\">1</span>, <span class=\"number\">1</span>, <span class=\"number\">1</span>, <span class=\"number\">1</span>],</span><br><span class=\"line\">                                        padding=<span class=\"string\">&#x27;SAME&#x27;</span>, name=<span class=\"string\">&#x27;pool4&#x27;</span>)</span><br><span class=\"line\">            <span class=\"variable language_\">self</span>.pool4 = tf.space_to_batch(<span class=\"variable language_\">self</span>.pool4,</span><br><span class=\"line\">                                           paddings=pad, block_size=<span class=\"number\">2</span>)</span><br><span class=\"line\">        <span class=\"keyword\">else</span>:</span><br><span class=\"line\">            <span class=\"variable language_\">self</span>.pool4 = <span class=\"variable language_\">self</span>._max_pool(<span class=\"variable language_\">self</span>.conv4_3, <span class=\"string\">&#x27;pool4&#x27;</span>, debug)</span><br><span class=\"line\"></span><br><span class=\"line\">        <span class=\"variable language_\">self</span>.conv5_1 = <span class=\"variable language_\">self</span>._conv_layer(<span class=\"variable language_\">self</span>.pool4, <span class=\"string\">&quot;conv5_1&quot;</span>)</span><br><span class=\"line\">        <span class=\"variable language_\">self</span>.conv5_2 = <span class=\"variable language_\">self</span>._conv_layer(<span class=\"variable language_\">self</span>.conv5_1, <span class=\"string\">&quot;conv5_2&quot;</span>)</span><br><span class=\"line\">        <span class=\"variable language_\">self</span>.conv5_3 = <span class=\"variable language_\">self</span>._conv_layer(<span class=\"variable language_\">self</span>.conv5_2, <span class=\"string\">&quot;conv5_3&quot;</span>)</span><br><span class=\"line\">        <span class=\"keyword\">if</span> use_dilated:</span><br><span class=\"line\">            pad = [[<span class=\"number\">0</span>, <span class=\"number\">0</span>], [<span class=\"number\">0</span>, <span class=\"number\">0</span>]]</span><br><span class=\"line\">            <span class=\"variable language_\">self</span>.pool5 = tf.nn.max_pool(<span class=\"variable language_\">self</span>.conv5_3, ksize=[<span class=\"number\">1</span>, <span class=\"number\">2</span>, <span class=\"number\">2</span>, <span class=\"number\">1</span>],</span><br><span class=\"line\">                                        strides=[<span class=\"number\">1</span>, <span class=\"number\">1</span>, <span class=\"number\">1</span>, <span class=\"number\">1</span>],</span><br><span class=\"line\">                                        padding=<span class=\"string\">&#x27;SAME&#x27;</span>, name=<span class=\"string\">&#x27;pool5&#x27;</span>)</span><br><span class=\"line\">            <span class=\"variable language_\">self</span>.pool5 = tf.space_to_batch(<span class=\"variable language_\">self</span>.pool5,</span><br><span class=\"line\">                                           paddings=pad, block_size=<span class=\"number\">2</span>)</span><br><span class=\"line\">        <span class=\"keyword\">else</span>:</span><br><span class=\"line\">            <span class=\"variable language_\">self</span>.pool5 = <span class=\"variable language_\">self</span>._max_pool(<span class=\"variable language_\">self</span>.conv5_3, <span class=\"string\">&#x27;pool5&#x27;</span>, debug)</span><br><span class=\"line\"></span><br><span class=\"line\">        <span class=\"variable language_\">self</span>.fc6 = <span class=\"variable language_\">self</span>._fc_layer(<span class=\"variable language_\">self</span>.pool5, <span class=\"string\">&quot;fc6&quot;</span>)</span><br><span class=\"line\"></span><br><span class=\"line\">        <span class=\"keyword\">if</span> train:</span><br><span class=\"line\">            <span class=\"variable language_\">self</span>.fc6 = tf.nn.dropout(<span class=\"variable language_\">self</span>.fc6, <span class=\"number\">0.5</span>)</span><br><span class=\"line\"></span><br><span class=\"line\">        <span class=\"variable language_\">self</span>.fc7 = <span class=\"variable language_\">self</span>._fc_layer(<span class=\"variable language_\">self</span>.fc6, <span class=\"string\">&quot;fc7&quot;</span>)</span><br><span class=\"line\">        <span class=\"keyword\">if</span> train:</span><br><span class=\"line\">            <span class=\"variable language_\">self</span>.fc7 = tf.nn.dropout(<span class=\"variable language_\">self</span>.fc7, <span class=\"number\">0.5</span>)</span><br><span class=\"line\"></span><br><span class=\"line\">        <span class=\"keyword\">if</span> use_dilated:</span><br><span class=\"line\">            <span class=\"variable language_\">self</span>.pool5 = tf.batch_to_space(<span class=\"variable language_\">self</span>.pool5, crops=pad, block_size=<span class=\"number\">2</span>)</span><br><span class=\"line\">            <span class=\"variable language_\">self</span>.pool5 = tf.batch_to_space(<span class=\"variable language_\">self</span>.pool5, crops=pad, block_size=<span class=\"number\">2</span>)</span><br><span class=\"line\">            <span class=\"variable language_\">self</span>.fc7 = tf.batch_to_space(<span class=\"variable language_\">self</span>.fc7, crops=pad, block_size=<span class=\"number\">2</span>)</span><br><span class=\"line\">            <span class=\"variable language_\">self</span>.fc7 = tf.batch_to_space(<span class=\"variable language_\">self</span>.fc7, crops=pad, block_size=<span class=\"number\">2</span>)</span><br><span class=\"line\">            <span class=\"keyword\">return</span></span><br><span class=\"line\"></span><br><span class=\"line\">        <span class=\"keyword\">if</span> random_init_fc8:</span><br><span class=\"line\">            <span class=\"variable language_\">self</span>.score_fr = <span class=\"variable language_\">self</span>._score_layer(<span class=\"variable language_\">self</span>.fc7, <span class=\"string\">&quot;score_fr&quot;</span>,</span><br><span class=\"line\">                                              num_classes)</span><br><span class=\"line\">        <span class=\"keyword\">else</span>:</span><br><span class=\"line\">            <span class=\"variable language_\">self</span>.score_fr = <span class=\"variable language_\">self</span>._fc_layer(<span class=\"variable language_\">self</span>.fc7, <span class=\"string\">&quot;score_fr&quot;</span>,</span><br><span class=\"line\">                                           num_classes=num_classes,</span><br><span class=\"line\">                                           relu=<span class=\"literal\">False</span>)</span><br><span class=\"line\"></span><br><span class=\"line\">        <span class=\"variable language_\">self</span>.pred = tf.argmax(<span class=\"variable language_\">self</span>.score_fr, dimension=<span class=\"number\">3</span>)</span><br><span class=\"line\"></span><br><span class=\"line\">        <span class=\"variable language_\">self</span>.upscore2 = <span class=\"variable language_\">self</span>._upscore_layer(<span class=\"variable language_\">self</span>.score_fr,</span><br><span class=\"line\">                                            shape=tf.shape(<span class=\"variable language_\">self</span>.pool4),</span><br><span class=\"line\">                                            num_classes=num_classes,</span><br><span class=\"line\">                                            debug=debug, name=<span class=\"string\">&#x27;upscore2&#x27;</span>,</span><br><span class=\"line\">                                            ksize=<span class=\"number\">4</span>, stride=<span class=\"number\">2</span>)</span><br><span class=\"line\">        <span class=\"variable language_\">self</span>.score_pool4 = <span class=\"variable language_\">self</span>._score_layer(<span class=\"variable language_\">self</span>.pool4, <span class=\"string\">&quot;score_pool4&quot;</span>,</span><br><span class=\"line\">                                             num_classes=num_classes)</span><br><span class=\"line\">        <span class=\"variable language_\">self</span>.fuse_pool4 = tf.add(<span class=\"variable language_\">self</span>.upscore2, <span class=\"variable language_\">self</span>.score_pool4)</span><br><span class=\"line\"></span><br><span class=\"line\">        <span class=\"variable language_\">self</span>.upscore4 = <span class=\"variable language_\">self</span>._upscore_layer(<span class=\"variable language_\">self</span>.fuse_pool4,</span><br><span class=\"line\">                                            shape=tf.shape(<span class=\"variable language_\">self</span>.pool3),</span><br><span class=\"line\">                                            num_classes=num_classes,</span><br><span class=\"line\">                                            debug=debug, name=<span class=\"string\">&#x27;upscore4&#x27;</span>,</span><br><span class=\"line\">                                            ksize=<span class=\"number\">4</span>, stride=<span class=\"number\">2</span>)</span><br><span class=\"line\">        <span class=\"variable language_\">self</span>.score_pool3 = <span class=\"variable language_\">self</span>._score_layer(<span class=\"variable language_\">self</span>.pool3, <span class=\"string\">&quot;score_pool3&quot;</span>,</span><br><span class=\"line\">                                             num_classes=num_classes)</span><br><span class=\"line\">        <span class=\"variable language_\">self</span>.fuse_pool3 = tf.add(<span class=\"variable language_\">self</span>.upscore4, <span class=\"variable language_\">self</span>.score_pool3)</span><br><span class=\"line\"></span><br><span class=\"line\">        <span class=\"variable language_\">self</span>.upscore32 = <span class=\"variable language_\">self</span>._upscore_layer(<span class=\"variable language_\">self</span>.fuse_pool3,</span><br><span class=\"line\">                                             shape=tf.shape(bgr),</span><br><span class=\"line\">                                             num_classes=num_classes,</span><br><span class=\"line\">                                             debug=debug, name=<span class=\"string\">&#x27;upscore32&#x27;</span>,</span><br><span class=\"line\">                                             ksize=<span class=\"number\">16</span>, stride=<span class=\"number\">8</span>)</span><br><span class=\"line\"></span><br><span class=\"line\">        <span class=\"variable language_\">self</span>.pred_up = tf.argmax(<span class=\"variable language_\">self</span>.upscore32, dimension=<span class=\"number\">3</span>)</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">def</span> <span class=\"title function_\">_max_pool</span>(<span class=\"params\">self, bottom, name, debug</span>):</span><br><span class=\"line\">        pool = tf.nn.max_pool(bottom, ksize=[<span class=\"number\">1</span>, <span class=\"number\">2</span>, <span class=\"number\">2</span>, <span class=\"number\">1</span>], strides=[<span class=\"number\">1</span>, <span class=\"number\">2</span>, <span class=\"number\">2</span>, <span class=\"number\">1</span>],</span><br><span class=\"line\">                              padding=<span class=\"string\">&#x27;SAME&#x27;</span>, name=name)</span><br><span class=\"line\"></span><br><span class=\"line\">        <span class=\"keyword\">if</span> debug:</span><br><span class=\"line\">            pool = tf.Print(pool, [tf.shape(pool)],</span><br><span class=\"line\">                            message=<span class=\"string\">&#x27;Shape of %s&#x27;</span> % name,</span><br><span class=\"line\">                            summarize=<span class=\"number\">4</span>, first_n=<span class=\"number\">1</span>)</span><br><span class=\"line\">        <span class=\"keyword\">return</span> pool</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">def</span> <span class=\"title function_\">_conv_layer</span>(<span class=\"params\">self, bottom, name</span>):</span><br><span class=\"line\">        <span class=\"keyword\">with</span> tf.variable_scope(name) <span class=\"keyword\">as</span> scope:</span><br><span class=\"line\">            filt = <span class=\"variable language_\">self</span>.get_conv_filter(name)</span><br><span class=\"line\">            conv = tf.nn.conv2d(bottom, filt, [<span class=\"number\">1</span>, <span class=\"number\">1</span>, <span class=\"number\">1</span>, <span class=\"number\">1</span>], padding=<span class=\"string\">&#x27;SAME&#x27;</span>)</span><br><span class=\"line\"></span><br><span class=\"line\">            conv_biases = <span class=\"variable language_\">self</span>.get_bias(name)</span><br><span class=\"line\">            bias = tf.nn.bias_add(conv, conv_biases)</span><br><span class=\"line\"></span><br><span class=\"line\">            relu = tf.nn.relu(bias)</span><br><span class=\"line\">            <span class=\"comment\"># Add summary to Tensorboard</span></span><br><span class=\"line\">            _activation_summary(relu)</span><br><span class=\"line\">            <span class=\"keyword\">return</span> relu</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">def</span> <span class=\"title function_\">_fc_layer</span>(<span class=\"params\">self, bottom, name, num_classes=<span class=\"literal\">None</span>,</span></span><br><span class=\"line\"><span class=\"params\">                  relu=<span class=\"literal\">True</span>, debug=<span class=\"literal\">False</span></span>):</span><br><span class=\"line\">        <span class=\"keyword\">with</span> tf.variable_scope(name) <span class=\"keyword\">as</span> scope:</span><br><span class=\"line\">            shape = bottom.get_shape().as_list()</span><br><span class=\"line\"></span><br><span class=\"line\">            <span class=\"keyword\">if</span> name == <span class=\"string\">&#x27;fc6&#x27;</span>:</span><br><span class=\"line\">                filt = <span class=\"variable language_\">self</span>.get_fc_weight_reshape(name, [<span class=\"number\">7</span>, <span class=\"number\">7</span>, <span class=\"number\">512</span>, <span class=\"number\">4096</span>])</span><br><span class=\"line\">            <span class=\"keyword\">elif</span> name == <span class=\"string\">&#x27;score_fr&#x27;</span>:</span><br><span class=\"line\">                name = <span class=\"string\">&#x27;fc8&#x27;</span>  <span class=\"comment\"># Name of score_fr layer in VGG Model</span></span><br><span class=\"line\">                filt = <span class=\"variable language_\">self</span>.get_fc_weight_reshape(name, [<span class=\"number\">1</span>, <span class=\"number\">1</span>, <span class=\"number\">4096</span>, <span class=\"number\">1000</span>],</span><br><span class=\"line\">                                                  num_classes=num_classes)</span><br><span class=\"line\">            <span class=\"keyword\">else</span>:</span><br><span class=\"line\">                filt = <span class=\"variable language_\">self</span>.get_fc_weight_reshape(name, [<span class=\"number\">1</span>, <span class=\"number\">1</span>, <span class=\"number\">4096</span>, <span class=\"number\">4096</span>])</span><br><span class=\"line\"></span><br><span class=\"line\">            <span class=\"variable language_\">self</span>._add_wd_and_summary(filt, <span class=\"variable language_\">self</span>.wd, <span class=\"string\">&quot;fc_wlosses&quot;</span>)</span><br><span class=\"line\"></span><br><span class=\"line\">            conv = tf.nn.conv2d(bottom, filt, [<span class=\"number\">1</span>, <span class=\"number\">1</span>, <span class=\"number\">1</span>, <span class=\"number\">1</span>], padding=<span class=\"string\">&#x27;SAME&#x27;</span>)</span><br><span class=\"line\">            conv_biases = <span class=\"variable language_\">self</span>.get_bias(name, num_classes=num_classes)</span><br><span class=\"line\">            bias = tf.nn.bias_add(conv, conv_biases)</span><br><span class=\"line\"></span><br><span class=\"line\">            <span class=\"keyword\">if</span> relu:</span><br><span class=\"line\">                bias = tf.nn.relu(bias)</span><br><span class=\"line\">            _activation_summary(bias)</span><br><span class=\"line\"></span><br><span class=\"line\">            <span class=\"keyword\">if</span> debug:</span><br><span class=\"line\">                bias = tf.Print(bias, [tf.shape(bias)],</span><br><span class=\"line\">                                message=<span class=\"string\">&#x27;Shape of %s&#x27;</span> % name,</span><br><span class=\"line\">                                summarize=<span class=\"number\">4</span>, first_n=<span class=\"number\">1</span>)</span><br><span class=\"line\">            <span class=\"keyword\">return</span> bias</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">def</span> <span class=\"title function_\">_score_layer</span>(<span class=\"params\">self, bottom, name, num_classes</span>):</span><br><span class=\"line\">        <span class=\"keyword\">with</span> tf.variable_scope(name) <span class=\"keyword\">as</span> scope:</span><br><span class=\"line\">            <span class=\"comment\"># get number of input channels</span></span><br><span class=\"line\">            in_features = bottom.get_shape()[<span class=\"number\">3</span>].value</span><br><span class=\"line\">            shape = [<span class=\"number\">1</span>, <span class=\"number\">1</span>, in_features, num_classes]</span><br><span class=\"line\">            <span class=\"comment\"># He initialization Sheme</span></span><br><span class=\"line\">            <span class=\"keyword\">if</span> name == <span class=\"string\">&quot;score_fr&quot;</span>:</span><br><span class=\"line\">                num_input = in_features</span><br><span class=\"line\">                stddev = (<span class=\"number\">2</span> / num_input)**<span class=\"number\">0.5</span></span><br><span class=\"line\">            <span class=\"keyword\">elif</span> name == <span class=\"string\">&quot;score_pool4&quot;</span>:</span><br><span class=\"line\">                stddev = <span class=\"number\">0.001</span></span><br><span class=\"line\">            <span class=\"keyword\">elif</span> name == <span class=\"string\">&quot;score_pool3&quot;</span>:</span><br><span class=\"line\">                stddev = <span class=\"number\">0.0001</span></span><br><span class=\"line\">            <span class=\"comment\"># Apply convolution</span></span><br><span class=\"line\">            w_decay = <span class=\"variable language_\">self</span>.wd</span><br><span class=\"line\"></span><br><span class=\"line\">            weights = <span class=\"variable language_\">self</span>._variable_with_weight_decay(shape, stddev, w_decay,</span><br><span class=\"line\">                                                       decoder=<span class=\"literal\">True</span>)</span><br><span class=\"line\">            conv = tf.nn.conv2d(bottom, weights, [<span class=\"number\">1</span>, <span class=\"number\">1</span>, <span class=\"number\">1</span>, <span class=\"number\">1</span>], padding=<span class=\"string\">&#x27;SAME&#x27;</span>)</span><br><span class=\"line\">            <span class=\"comment\"># Apply bias</span></span><br><span class=\"line\">            conv_biases = <span class=\"variable language_\">self</span>._bias_variable([num_classes], constant=<span class=\"number\">0.0</span>)</span><br><span class=\"line\">            bias = tf.nn.bias_add(conv, conv_biases)</span><br><span class=\"line\"></span><br><span class=\"line\">            _activation_summary(bias)</span><br><span class=\"line\"></span><br><span class=\"line\">            <span class=\"keyword\">return</span> bias</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">def</span> <span class=\"title function_\">_upscore_layer</span>(<span class=\"params\">self, bottom, shape,</span></span><br><span class=\"line\"><span class=\"params\">                       num_classes, name, debug,</span></span><br><span class=\"line\"><span class=\"params\">                       ksize=<span class=\"number\">4</span>, stride=<span class=\"number\">2</span></span>):</span><br><span class=\"line\">        strides = [<span class=\"number\">1</span>, stride, stride, <span class=\"number\">1</span>]</span><br><span class=\"line\">        <span class=\"keyword\">with</span> tf.variable_scope(name):</span><br><span class=\"line\">            in_features = bottom.get_shape()[<span class=\"number\">3</span>].value</span><br><span class=\"line\"></span><br><span class=\"line\">            <span class=\"keyword\">if</span> shape <span class=\"keyword\">is</span> <span class=\"literal\">None</span>:</span><br><span class=\"line\">                <span class=\"comment\"># Compute shape out of Bottom</span></span><br><span class=\"line\">                in_shape = tf.shape(bottom)</span><br><span class=\"line\"></span><br><span class=\"line\">                h = ((in_shape[<span class=\"number\">1</span>] - <span class=\"number\">1</span>) * stride) + <span class=\"number\">1</span></span><br><span class=\"line\">                w = ((in_shape[<span class=\"number\">2</span>] - <span class=\"number\">1</span>) * stride) + <span class=\"number\">1</span></span><br><span class=\"line\">                new_shape = [in_shape[<span class=\"number\">0</span>], h, w, num_classes]</span><br><span class=\"line\">            <span class=\"keyword\">else</span>:</span><br><span class=\"line\">                new_shape = [shape[<span class=\"number\">0</span>], shape[<span class=\"number\">1</span>], shape[<span class=\"number\">2</span>], num_classes]</span><br><span class=\"line\">            output_shape = tf.stack(new_shape)</span><br><span class=\"line\"></span><br><span class=\"line\">            logging.debug(<span class=\"string\">&quot;Layer: %s, Fan-in: %d&quot;</span> % (name, in_features))</span><br><span class=\"line\">            f_shape = [ksize, ksize, num_classes, in_features]</span><br><span class=\"line\"></span><br><span class=\"line\">            <span class=\"comment\"># create</span></span><br><span class=\"line\">            num_input = ksize * ksize * in_features / stride</span><br><span class=\"line\">            stddev = (<span class=\"number\">2</span> / num_input)**<span class=\"number\">0.5</span></span><br><span class=\"line\"></span><br><span class=\"line\">            weights = <span class=\"variable language_\">self</span>.get_deconv_filter(f_shape)</span><br><span class=\"line\">            <span class=\"variable language_\">self</span>._add_wd_and_summary(weights, <span class=\"variable language_\">self</span>.wd, <span class=\"string\">&quot;fc_wlosses&quot;</span>)</span><br><span class=\"line\">            deconv = tf.nn.conv2d_transpose(bottom, weights, output_shape,</span><br><span class=\"line\">                                            strides=strides, padding=<span class=\"string\">&#x27;SAME&#x27;</span>)</span><br><span class=\"line\"></span><br><span class=\"line\">            <span class=\"keyword\">if</span> debug:</span><br><span class=\"line\">                deconv = tf.Print(deconv, [tf.shape(deconv)],</span><br><span class=\"line\">                                  message=<span class=\"string\">&#x27;Shape of %s&#x27;</span> % name,</span><br><span class=\"line\">                                  summarize=<span class=\"number\">4</span>, first_n=<span class=\"number\">1</span>)</span><br><span class=\"line\"></span><br><span class=\"line\">        _activation_summary(deconv)</span><br><span class=\"line\">        <span class=\"keyword\">return</span> deconv</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">def</span> <span class=\"title function_\">get_deconv_filter</span>(<span class=\"params\">self, f_shape</span>):</span><br><span class=\"line\">        width = f_shape[<span class=\"number\">0</span>]</span><br><span class=\"line\">        height = f_shape[<span class=\"number\">1</span>]</span><br><span class=\"line\">        f = ceil(width/<span class=\"number\">2.0</span>)</span><br><span class=\"line\">        c = (<span class=\"number\">2</span> * f - <span class=\"number\">1</span> - f % <span class=\"number\">2</span>) / (<span class=\"number\">2.0</span> * f)</span><br><span class=\"line\">        bilinear = np.zeros([f_shape[<span class=\"number\">0</span>], f_shape[<span class=\"number\">1</span>]])</span><br><span class=\"line\">        <span class=\"keyword\">for</span> x <span class=\"keyword\">in</span> <span class=\"built_in\">range</span>(width):</span><br><span class=\"line\">            <span class=\"keyword\">for</span> y <span class=\"keyword\">in</span> <span class=\"built_in\">range</span>(height):</span><br><span class=\"line\">                value = (<span class=\"number\">1</span> - <span class=\"built_in\">abs</span>(x / f - c)) * (<span class=\"number\">1</span> - <span class=\"built_in\">abs</span>(y / f - c))</span><br><span class=\"line\">                bilinear[x, y] = value</span><br><span class=\"line\">        weights = np.zeros(f_shape)</span><br><span class=\"line\">        <span class=\"keyword\">for</span> i <span class=\"keyword\">in</span> <span class=\"built_in\">range</span>(f_shape[<span class=\"number\">2</span>]):</span><br><span class=\"line\">            weights[:, :, i, i] = bilinear</span><br><span class=\"line\"></span><br><span class=\"line\">        init = tf.constant_initializer(value=weights,</span><br><span class=\"line\">                                       dtype=tf.float32)</span><br><span class=\"line\">        var = tf.get_variable(name=<span class=\"string\">&quot;up_filter&quot;</span>, initializer=init,</span><br><span class=\"line\">                              shape=weights.shape)</span><br><span class=\"line\">        <span class=\"keyword\">return</span> var</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">def</span> <span class=\"title function_\">get_conv_filter</span>(<span class=\"params\">self, name</span>):</span><br><span class=\"line\">        init = tf.constant_initializer(value=<span class=\"variable language_\">self</span>.data_dict[name][<span class=\"number\">0</span>],</span><br><span class=\"line\">                                       dtype=tf.float32)</span><br><span class=\"line\">        shape = <span class=\"variable language_\">self</span>.data_dict[name][<span class=\"number\">0</span>].shape</span><br><span class=\"line\">        <span class=\"built_in\">print</span>(<span class=\"string\">&#x27;Layer name: %s&#x27;</span> % name)</span><br><span class=\"line\">        <span class=\"built_in\">print</span>(<span class=\"string\">&#x27;Layer shape: %s&#x27;</span> % <span class=\"built_in\">str</span>(shape))</span><br><span class=\"line\">        var = tf.get_variable(name=<span class=\"string\">&quot;filter&quot;</span>, initializer=init, shape=shape)</span><br><span class=\"line\">        <span class=\"keyword\">if</span> <span class=\"keyword\">not</span> tf.get_variable_scope().reuse:</span><br><span class=\"line\">            weight_decay = tf.multiply(tf.nn.l2_loss(var), <span class=\"variable language_\">self</span>.wd,</span><br><span class=\"line\">                                       name=<span class=\"string\">&#x27;weight_loss&#x27;</span>)</span><br><span class=\"line\">            tf.add_to_collection(tf.GraphKeys.REGULARIZATION_LOSSES,</span><br><span class=\"line\">                                 weight_decay)</span><br><span class=\"line\">        _variable_summaries(var)</span><br><span class=\"line\">        <span class=\"keyword\">return</span> var</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">def</span> <span class=\"title function_\">get_bias</span>(<span class=\"params\">self, name, num_classes=<span class=\"literal\">None</span></span>):</span><br><span class=\"line\">        bias_wights = <span class=\"variable language_\">self</span>.data_dict[name][<span class=\"number\">1</span>]</span><br><span class=\"line\">        shape = <span class=\"variable language_\">self</span>.data_dict[name][<span class=\"number\">1</span>].shape</span><br><span class=\"line\">        <span class=\"keyword\">if</span> name == <span class=\"string\">&#x27;fc8&#x27;</span>:</span><br><span class=\"line\">            bias_wights = <span class=\"variable language_\">self</span>._bias_reshape(bias_wights, shape[<span class=\"number\">0</span>],</span><br><span class=\"line\">                                             num_classes)</span><br><span class=\"line\">            shape = [num_classes]</span><br><span class=\"line\">        init = tf.constant_initializer(value=bias_wights,</span><br><span class=\"line\">                                       dtype=tf.float32)</span><br><span class=\"line\">        var = tf.get_variable(name=<span class=\"string\">&quot;biases&quot;</span>, initializer=init, shape=shape)</span><br><span class=\"line\">        _variable_summaries(var)</span><br><span class=\"line\">        <span class=\"keyword\">return</span> var</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">def</span> <span class=\"title function_\">get_fc_weight</span>(<span class=\"params\">self, name</span>):</span><br><span class=\"line\">        init = tf.constant_initializer(value=<span class=\"variable language_\">self</span>.data_dict[name][<span class=\"number\">0</span>],</span><br><span class=\"line\">                                       dtype=tf.float32)</span><br><span class=\"line\">        shape = <span class=\"variable language_\">self</span>.data_dict[name][<span class=\"number\">0</span>].shape</span><br><span class=\"line\">        var = tf.get_variable(name=<span class=\"string\">&quot;weights&quot;</span>, initializer=init, shape=shape)</span><br><span class=\"line\">        <span class=\"keyword\">if</span> <span class=\"keyword\">not</span> tf.get_variable_scope().reuse:</span><br><span class=\"line\">            weight_decay = tf.multiply(tf.nn.l2_loss(var), <span class=\"variable language_\">self</span>.wd,</span><br><span class=\"line\">                                       name=<span class=\"string\">&#x27;weight_loss&#x27;</span>)</span><br><span class=\"line\">            tf.add_to_collection(tf.GraphKeys.REGULARIZATION_LOSSES,</span><br><span class=\"line\">                                 weight_decay)</span><br><span class=\"line\">        _variable_summaries(var)</span><br><span class=\"line\">        <span class=\"keyword\">return</span> var</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">def</span> <span class=\"title function_\">_bias_reshape</span>(<span class=\"params\">self, bweight, num_orig, num_new</span>):</span><br><span class=\"line\">        <span class=\"string\">&quot;&quot;&quot; Build bias weights for filter produces with `_summary_reshape`</span></span><br><span class=\"line\"><span class=\"string\"></span></span><br><span class=\"line\"><span class=\"string\">        &quot;&quot;&quot;</span></span><br><span class=\"line\">        n_averaged_elements = num_orig//num_new</span><br><span class=\"line\">        avg_bweight = np.zeros(num_new)</span><br><span class=\"line\">        <span class=\"keyword\">for</span> i <span class=\"keyword\">in</span> <span class=\"built_in\">range</span>(<span class=\"number\">0</span>, num_orig, n_averaged_elements):</span><br><span class=\"line\">            start_idx = i</span><br><span class=\"line\">            end_idx = start_idx + n_averaged_elements</span><br><span class=\"line\">            avg_idx = start_idx//n_averaged_elements</span><br><span class=\"line\">            <span class=\"keyword\">if</span> avg_idx == num_new:</span><br><span class=\"line\">                <span class=\"keyword\">break</span></span><br><span class=\"line\">            avg_bweight[avg_idx] = np.mean(bweight[start_idx:end_idx])</span><br><span class=\"line\">        <span class=\"keyword\">return</span> avg_bweight</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">def</span> <span class=\"title function_\">_summary_reshape</span>(<span class=\"params\">self, fweight, shape, num_new</span>):</span><br><span class=\"line\">        <span class=\"string\">&quot;&quot;&quot; Produce weights for a reduced fully-connected layer.</span></span><br><span class=\"line\"><span class=\"string\"></span></span><br><span class=\"line\"><span class=\"string\">        FC8 of VGG produces 1000 classes. Most semantic segmentation</span></span><br><span class=\"line\"><span class=\"string\">        task require much less classes. This reshapes the original weights</span></span><br><span class=\"line\"><span class=\"string\">        to be used in a fully-convolutional layer which produces num_new</span></span><br><span class=\"line\"><span class=\"string\">        classes. To archive this the average (mean) of n adjanced classes is</span></span><br><span class=\"line\"><span class=\"string\">        taken.</span></span><br><span class=\"line\"><span class=\"string\"></span></span><br><span class=\"line\"><span class=\"string\">        Consider reordering fweight, to perserve semantic meaning of the</span></span><br><span class=\"line\"><span class=\"string\">        weights.</span></span><br><span class=\"line\"><span class=\"string\"></span></span><br><span class=\"line\"><span class=\"string\">        Args:</span></span><br><span class=\"line\"><span class=\"string\">          fweight: original weights</span></span><br><span class=\"line\"><span class=\"string\">          shape: shape of the desired fully-convolutional layer</span></span><br><span class=\"line\"><span class=\"string\">          num_new: number of new classes</span></span><br><span class=\"line\"><span class=\"string\"></span></span><br><span class=\"line\"><span class=\"string\"></span></span><br><span class=\"line\"><span class=\"string\">        Returns:</span></span><br><span class=\"line\"><span class=\"string\">          Filter weights for `num_new` classes.</span></span><br><span class=\"line\"><span class=\"string\">        &quot;&quot;&quot;</span></span><br><span class=\"line\">        num_orig = shape[<span class=\"number\">3</span>]</span><br><span class=\"line\">        shape[<span class=\"number\">3</span>] = num_new</span><br><span class=\"line\">        <span class=\"keyword\">assert</span>(num_new &lt; num_orig)</span><br><span class=\"line\">        n_averaged_elements = num_orig//num_new</span><br><span class=\"line\">        avg_fweight = np.zeros(shape)</span><br><span class=\"line\">        <span class=\"keyword\">for</span> i <span class=\"keyword\">in</span> <span class=\"built_in\">range</span>(<span class=\"number\">0</span>, num_orig, n_averaged_elements):</span><br><span class=\"line\">            start_idx = i</span><br><span class=\"line\">            end_idx = start_idx + n_averaged_elements</span><br><span class=\"line\">            avg_idx = start_idx//n_averaged_elements</span><br><span class=\"line\">            <span class=\"keyword\">if</span> avg_idx == num_new:</span><br><span class=\"line\">                <span class=\"keyword\">break</span></span><br><span class=\"line\">            avg_fweight[:, :, :, avg_idx] = np.mean(</span><br><span class=\"line\">                fweight[:, :, :, start_idx:end_idx], axis=<span class=\"number\">3</span>)</span><br><span class=\"line\">        <span class=\"keyword\">return</span> avg_fweight</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">def</span> <span class=\"title function_\">_variable_with_weight_decay</span>(<span class=\"params\">self, shape, stddev, wd, decoder=<span class=\"literal\">False</span></span>):</span><br><span class=\"line\">        <span class=\"string\">&quot;&quot;&quot;Helper to create an initialized Variable with weight decay.</span></span><br><span class=\"line\"><span class=\"string\"></span></span><br><span class=\"line\"><span class=\"string\">        Note that the Variable is initialized with a truncated normal</span></span><br><span class=\"line\"><span class=\"string\">        distribution.</span></span><br><span class=\"line\"><span class=\"string\">        A weight decay is added only if one is specified.</span></span><br><span class=\"line\"><span class=\"string\"></span></span><br><span class=\"line\"><span class=\"string\">        Args:</span></span><br><span class=\"line\"><span class=\"string\">          name: name of the variable</span></span><br><span class=\"line\"><span class=\"string\">          shape: list of ints</span></span><br><span class=\"line\"><span class=\"string\">          stddev: standard deviation of a truncated Gaussian</span></span><br><span class=\"line\"><span class=\"string\">          wd: add L2Loss weight decay multiplied by this float. If None, weight</span></span><br><span class=\"line\"><span class=\"string\">              decay is not added for this Variable.</span></span><br><span class=\"line\"><span class=\"string\"></span></span><br><span class=\"line\"><span class=\"string\">        Returns:</span></span><br><span class=\"line\"><span class=\"string\">          Variable Tensor</span></span><br><span class=\"line\"><span class=\"string\">        &quot;&quot;&quot;</span></span><br><span class=\"line\"></span><br><span class=\"line\">        initializer = tf.truncated_normal_initializer(stddev=stddev)</span><br><span class=\"line\">        var = tf.get_variable(<span class=\"string\">&#x27;weights&#x27;</span>, shape=shape,</span><br><span class=\"line\">                              initializer=initializer)</span><br><span class=\"line\"></span><br><span class=\"line\">        collection_name = tf.GraphKeys.REGULARIZATION_LOSSES</span><br><span class=\"line\">        <span class=\"keyword\">if</span> wd <span class=\"keyword\">and</span> (<span class=\"keyword\">not</span> tf.get_variable_scope().reuse):</span><br><span class=\"line\">            weight_decay = tf.multiply(</span><br><span class=\"line\">                tf.nn.l2_loss(var), wd, name=<span class=\"string\">&#x27;weight_loss&#x27;</span>)</span><br><span class=\"line\">            tf.add_to_collection(collection_name, weight_decay)</span><br><span class=\"line\">        _variable_summaries(var)</span><br><span class=\"line\">        <span class=\"keyword\">return</span> var</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">def</span> <span class=\"title function_\">_add_wd_and_summary</span>(<span class=\"params\">self, var, wd, collection_name=<span class=\"literal\">None</span></span>):</span><br><span class=\"line\">        <span class=\"keyword\">if</span> collection_name <span class=\"keyword\">is</span> <span class=\"literal\">None</span>:</span><br><span class=\"line\">            collection_name = tf.GraphKeys.REGULARIZATION_LOSSES</span><br><span class=\"line\">        <span class=\"keyword\">if</span> wd <span class=\"keyword\">and</span> (<span class=\"keyword\">not</span> tf.get_variable_scope().reuse):</span><br><span class=\"line\">            weight_decay = tf.multiply(</span><br><span class=\"line\">                tf.nn.l2_loss(var), wd, name=<span class=\"string\">&#x27;weight_loss&#x27;</span>)</span><br><span class=\"line\">            tf.add_to_collection(collection_name, weight_decay)</span><br><span class=\"line\">        _variable_summaries(var)</span><br><span class=\"line\">        <span class=\"keyword\">return</span> var</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">def</span> <span class=\"title function_\">_bias_variable</span>(<span class=\"params\">self, shape, constant=<span class=\"number\">0.0</span></span>):</span><br><span class=\"line\">        initializer = tf.constant_initializer(constant)</span><br><span class=\"line\">        var = tf.get_variable(name=<span class=\"string\">&#x27;biases&#x27;</span>, shape=shape,</span><br><span class=\"line\">                              initializer=initializer)</span><br><span class=\"line\">        _variable_summaries(var)</span><br><span class=\"line\">        <span class=\"keyword\">return</span> var</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">def</span> <span class=\"title function_\">get_fc_weight_reshape</span>(<span class=\"params\">self, name, shape, num_classes=<span class=\"literal\">None</span></span>):</span><br><span class=\"line\">        <span class=\"built_in\">print</span>(<span class=\"string\">&#x27;Layer name: %s&#x27;</span> % name)</span><br><span class=\"line\">        <span class=\"built_in\">print</span>(<span class=\"string\">&#x27;Layer shape: %s&#x27;</span> % shape)</span><br><span class=\"line\">        weights = <span class=\"variable language_\">self</span>.data_dict[name][<span class=\"number\">0</span>]</span><br><span class=\"line\">        weights = weights.reshape(shape)</span><br><span class=\"line\">        <span class=\"keyword\">if</span> num_classes <span class=\"keyword\">is</span> <span class=\"keyword\">not</span> <span class=\"literal\">None</span>:</span><br><span class=\"line\">            weights = <span class=\"variable language_\">self</span>._summary_reshape(weights, shape,</span><br><span class=\"line\">                                            num_new=num_classes)</span><br><span class=\"line\">        init = tf.constant_initializer(value=weights,</span><br><span class=\"line\">                                       dtype=tf.float32)</span><br><span class=\"line\">        var = tf.get_variable(name=<span class=\"string\">&quot;weights&quot;</span>, initializer=init, shape=shape)</span><br><span class=\"line\">        <span class=\"keyword\">return</span> var</span><br><span class=\"line\"></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">def</span> <span class=\"title function_\">_activation_summary</span>(<span class=\"params\">x</span>):</span><br><span class=\"line\">    <span class=\"string\">&quot;&quot;&quot;Helper to create summaries for activations.</span></span><br><span class=\"line\"><span class=\"string\"></span></span><br><span class=\"line\"><span class=\"string\">    Creates a summary that provides a histogram of activations.</span></span><br><span class=\"line\"><span class=\"string\">    Creates a summary that measure the sparsity of activations.</span></span><br><span class=\"line\"><span class=\"string\"></span></span><br><span class=\"line\"><span class=\"string\">    Args:</span></span><br><span class=\"line\"><span class=\"string\">      x: Tensor</span></span><br><span class=\"line\"><span class=\"string\">    Returns:</span></span><br><span class=\"line\"><span class=\"string\">      nothing</span></span><br><span class=\"line\"><span class=\"string\">    &quot;&quot;&quot;</span></span><br><span class=\"line\">    <span class=\"comment\"># Remove &#x27;tower_[0-9]/&#x27; from the name in case this is a multi-GPU training</span></span><br><span class=\"line\">    <span class=\"comment\"># session. This helps the clarity of presentation on tensorboard.</span></span><br><span class=\"line\">    tensor_name = x.op.name</span><br><span class=\"line\">    <span class=\"comment\"># tensor_name = re.sub(&#x27;%s_[0-9]*/&#x27; % TOWER_NAME, &#x27;&#x27;, x.op.name)</span></span><br><span class=\"line\">    tf.summary.histogram(tensor_name + <span class=\"string\">&#x27;/activations&#x27;</span>, x)</span><br><span class=\"line\">    tf.summary.scalar(tensor_name + <span class=\"string\">&#x27;/sparsity&#x27;</span>, tf.nn.zero_fraction(x))</span><br><span class=\"line\"></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">def</span> <span class=\"title function_\">_variable_summaries</span>(<span class=\"params\">var</span>):</span><br><span class=\"line\">    <span class=\"string\">&quot;&quot;&quot;Attach a lot of summaries to a Tensor.&quot;&quot;&quot;</span></span><br><span class=\"line\">    <span class=\"keyword\">if</span> <span class=\"keyword\">not</span> tf.get_variable_scope().reuse:</span><br><span class=\"line\">        name = var.op.name</span><br><span class=\"line\">        logging.info(<span class=\"string\">&quot;Creating Summary for: %s&quot;</span> % name)</span><br><span class=\"line\">        <span class=\"keyword\">with</span> tf.name_scope(<span class=\"string\">&#x27;summaries&#x27;</span>):</span><br><span class=\"line\">            mean = tf.reduce_mean(var)</span><br><span class=\"line\">            tf.summary.scalar(name + <span class=\"string\">&#x27;/mean&#x27;</span>, mean)</span><br><span class=\"line\">            <span class=\"keyword\">with</span> tf.name_scope(<span class=\"string\">&#x27;stddev&#x27;</span>):</span><br><span class=\"line\">                stddev = tf.sqrt(tf.reduce_sum(tf.square(var - mean)))</span><br><span class=\"line\">            tf.summary.scalar(name + <span class=\"string\">&#x27;/sttdev&#x27;</span>, stddev)</span><br><span class=\"line\">            tf.summary.scalar(name + <span class=\"string\">&#x27;/max&#x27;</span>, tf.reduce_max(var))</span><br><span class=\"line\">            tf.summary.scalar(name + <span class=\"string\">&#x27;/min&#x27;</span>, tf.reduce_min(var))</span><br><span class=\"line\">            tf.summary.histogram(name, var)</span><br></pre></td></tr></table></figure>\n\n<h5 id=\"fcn-调包\"><a href=\"#fcn-调包\" class=\"headerlink\" title=\"fcn 调包\"></a>fcn 调包</h5><figure class=\"highlight python\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br><span class=\"line\">47</span><br><span class=\"line\">48</span><br><span class=\"line\">49</span><br><span class=\"line\">50</span><br><span class=\"line\">51</span><br><span class=\"line\">52</span><br><span class=\"line\">53</span><br><span class=\"line\">54</span><br><span class=\"line\">55</span><br><span class=\"line\">56</span><br><span class=\"line\">57</span><br><span class=\"line\">58</span><br><span class=\"line\">59</span><br><span class=\"line\">60</span><br><span class=\"line\">61</span><br><span class=\"line\">62</span><br><span class=\"line\">63</span><br><span class=\"line\">64</span><br><span class=\"line\">65</span><br><span class=\"line\">66</span><br><span class=\"line\">67</span><br><span class=\"line\">68</span><br><span class=\"line\">69</span><br><span class=\"line\">70</span><br><span class=\"line\">71</span><br><span class=\"line\">72</span><br><span class=\"line\">73</span><br><span class=\"line\">74</span><br><span class=\"line\">75</span><br><span class=\"line\">76</span><br><span class=\"line\">77</span><br><span class=\"line\">78</span><br><span class=\"line\">79</span><br><span class=\"line\">80</span><br><span class=\"line\">81</span><br><span class=\"line\">82</span><br><span class=\"line\">83</span><br><span class=\"line\">84</span><br><span class=\"line\">85</span><br><span class=\"line\">86</span><br><span class=\"line\">87</span><br><span class=\"line\">88</span><br><span class=\"line\">89</span><br><span class=\"line\">90</span><br><span class=\"line\">91</span><br><span class=\"line\">92</span><br><span class=\"line\">93</span><br><span class=\"line\">94</span><br><span class=\"line\">95</span><br><span class=\"line\">96</span><br><span class=\"line\">97</span><br><span class=\"line\">98</span><br><span class=\"line\">99</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">import</span> torch.nn <span class=\"keyword\">as</span> nn</span><br><span class=\"line\"><span class=\"keyword\">import</span> torch.nn.functional <span class=\"keyword\">as</span> F</span><br><span class=\"line\"><span class=\"keyword\">from</span> abc <span class=\"keyword\">import</span> ABCMeta</span><br><span class=\"line\"><span class=\"keyword\">import</span> torchvision.models <span class=\"keyword\">as</span> models</span><br><span class=\"line\"></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">def</span> <span class=\"title function_\">_maybe_pad</span>(<span class=\"params\">x, size</span>):</span><br><span class=\"line\">    hpad = size[<span class=\"number\">0</span>] - x.shape[<span class=\"number\">2</span>]</span><br><span class=\"line\">    wpad = size[<span class=\"number\">1</span>] - x.shape[<span class=\"number\">3</span>]</span><br><span class=\"line\">    <span class=\"keyword\">if</span> hpad + wpad &gt; <span class=\"number\">0</span>:</span><br><span class=\"line\">        x = F.pad(x, (<span class=\"number\">0</span>, wpad, <span class=\"number\">0</span>, hpad, <span class=\"number\">0</span>, <span class=\"number\">0</span>, <span class=\"number\">0</span>, <span class=\"number\">0</span> ))</span><br><span class=\"line\">    <span class=\"keyword\">return</span> x</span><br><span class=\"line\"></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">class</span> <span class=\"title class_\">VGGFCN</span>(nn.Module, metaclass=ABCMeta):</span><br><span class=\"line\">    <span class=\"keyword\">def</span> <span class=\"title function_\">__init__</span>(<span class=\"params\">self, in_channels, n_classes</span>):</span><br><span class=\"line\">        <span class=\"built_in\">super</span>().__init__()</span><br><span class=\"line\">        <span class=\"keyword\">assert</span> in_channels == <span class=\"number\">3</span></span><br><span class=\"line\">        <span class=\"variable language_\">self</span>.n_classes = n_classes</span><br><span class=\"line\">        <span class=\"variable language_\">self</span>.vgg16 = models.vgg16(pretrained=<span class=\"literal\">True</span>)</span><br><span class=\"line\">        <span class=\"variable language_\">self</span>.classifier = nn.Sequential(</span><br><span class=\"line\">            nn.Conv2d(<span class=\"number\">512</span>, <span class=\"number\">4096</span>, kernel_size=<span class=\"number\">7</span>, padding=<span class=\"number\">3</span>),</span><br><span class=\"line\">            nn.ReLU(<span class=\"literal\">True</span>),</span><br><span class=\"line\">            nn.Dropout(),</span><br><span class=\"line\">            nn.Conv2d(<span class=\"number\">4096</span>, <span class=\"number\">4096</span>, kernel_size=<span class=\"number\">1</span>),</span><br><span class=\"line\">            nn.ReLU(<span class=\"literal\">True</span>),</span><br><span class=\"line\">            nn.Dropout(),</span><br><span class=\"line\">            nn.Conv2d(<span class=\"number\">4096</span>, n_classes, kernel_size=<span class=\"number\">1</span>),</span><br><span class=\"line\">        )</span><br><span class=\"line\"></span><br><span class=\"line\">        <span class=\"variable language_\">self</span>._initialize_weights()</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">def</span> <span class=\"title function_\">_initialize_weights</span>(<span class=\"params\">self</span>):</span><br><span class=\"line\">        <span class=\"variable language_\">self</span>.classifier[<span class=\"number\">0</span>].weight.data = (</span><br><span class=\"line\">            <span class=\"variable language_\">self</span>.vgg16.classifier[<span class=\"number\">0</span>].weight.data.view(</span><br><span class=\"line\">                <span class=\"variable language_\">self</span>.classifier[<span class=\"number\">0</span>].weight.size())</span><br><span class=\"line\">        )</span><br><span class=\"line\">        <span class=\"variable language_\">self</span>.classifier[<span class=\"number\">3</span>].weight.data = (</span><br><span class=\"line\">            <span class=\"variable language_\">self</span>.vgg16.classifier[<span class=\"number\">3</span>].weight.data.view(</span><br><span class=\"line\">                <span class=\"variable language_\">self</span>.classifier[<span class=\"number\">3</span>].weight.size())</span><br><span class=\"line\">        )</span><br><span class=\"line\"></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">class</span> <span class=\"title class_\">VGGFCN32</span>(<span class=\"title class_ inherited__\">VGGFCN</span>):</span><br><span class=\"line\">    <span class=\"keyword\">def</span> <span class=\"title function_\">forward</span>(<span class=\"params\">self, x</span>):</span><br><span class=\"line\">        input_height, input_width = x.shape[<span class=\"number\">2</span>], x.shape[<span class=\"number\">3</span>]</span><br><span class=\"line\">        x = <span class=\"variable language_\">self</span>.vgg16.features(x)</span><br><span class=\"line\">        x = <span class=\"variable language_\">self</span>.classifier(x)</span><br><span class=\"line\">        x = F.interpolate(x, size=(input_height, input_width),</span><br><span class=\"line\">                          mode=<span class=\"string\">&#x27;bilinear&#x27;</span>, align_corners=<span class=\"literal\">True</span>)</span><br><span class=\"line\">        <span class=\"keyword\">return</span> x</span><br><span class=\"line\"></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">class</span> <span class=\"title class_\">VGGFCN16</span>(<span class=\"title class_ inherited__\">VGGFCN</span>):</span><br><span class=\"line\">    <span class=\"keyword\">def</span> <span class=\"title function_\">__init__</span>(<span class=\"params\">self, in_channels, n_classes</span>):</span><br><span class=\"line\">        <span class=\"built_in\">super</span>().__init__(in_channels, n_classes)</span><br><span class=\"line\">        <span class=\"variable language_\">self</span>.score4 = nn.Conv2d(<span class=\"number\">512</span>, n_classes, kernel_size=<span class=\"number\">1</span>)</span><br><span class=\"line\">        <span class=\"variable language_\">self</span>.upscale5 = nn.ConvTranspose2d(</span><br><span class=\"line\">            n_classes, n_classes, kernel_size=<span class=\"number\">2</span>, stride=<span class=\"number\">2</span>)</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">def</span> <span class=\"title function_\">forward</span>(<span class=\"params\">self, x</span>):</span><br><span class=\"line\">        input_height, input_width = x.shape[<span class=\"number\">2</span>], x.shape[<span class=\"number\">3</span>]</span><br><span class=\"line\">        pool4 = <span class=\"variable language_\">self</span>.vgg16.features[:-<span class=\"number\">7</span>](x)</span><br><span class=\"line\">        pool5 = <span class=\"variable language_\">self</span>.vgg16.features[-<span class=\"number\">7</span>:](pool4)</span><br><span class=\"line\">        pool5_upscaled = <span class=\"variable language_\">self</span>.upscale5(<span class=\"variable language_\">self</span>.classifier(pool5))</span><br><span class=\"line\">        pool4 = <span class=\"variable language_\">self</span>.score4(pool4)</span><br><span class=\"line\">        x = pool4 + pool5_upscaled</span><br><span class=\"line\">        x = F.interpolate(x, size=(input_height, input_width),</span><br><span class=\"line\">                          mode=<span class=\"string\">&#x27;bilinear&#x27;</span>, align_corners=<span class=\"literal\">True</span>)</span><br><span class=\"line\">        <span class=\"keyword\">return</span> x</span><br><span class=\"line\"></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">class</span> <span class=\"title class_\">VGGFCN8</span>(<span class=\"title class_ inherited__\">VGGFCN</span>):</span><br><span class=\"line\">    <span class=\"keyword\">def</span> <span class=\"title function_\">__init__</span>(<span class=\"params\">self, in_channels, n_classes</span>):</span><br><span class=\"line\">        <span class=\"built_in\">super</span>().__init__(in_channels, n_classes)</span><br><span class=\"line\">        <span class=\"variable language_\">self</span>.upscale4 = nn.ConvTranspose2d(</span><br><span class=\"line\">            n_classes, n_classes, kernel_size=<span class=\"number\">2</span>, stride=<span class=\"number\">2</span>)</span><br><span class=\"line\">        <span class=\"variable language_\">self</span>.score4 = nn.Conv2d(</span><br><span class=\"line\">            <span class=\"number\">512</span>, n_classes, kernel_size=<span class=\"number\">1</span>, stride=<span class=\"number\">1</span>)</span><br><span class=\"line\">        <span class=\"variable language_\">self</span>.score3 = nn.Conv2d(</span><br><span class=\"line\">            <span class=\"number\">256</span>, n_classes, kernel_size=<span class=\"number\">1</span>, stride=<span class=\"number\">1</span>)</span><br><span class=\"line\">        <span class=\"variable language_\">self</span>.upscale5 = nn.ConvTranspose2d(</span><br><span class=\"line\">            n_classes, n_classes, kernel_size=<span class=\"number\">2</span>, stride=<span class=\"number\">2</span>)</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">def</span> <span class=\"title function_\">forward</span>(<span class=\"params\">self, x</span>):</span><br><span class=\"line\">        input_height, input_width = x.shape[<span class=\"number\">2</span>], x.shape[<span class=\"number\">3</span>]</span><br><span class=\"line\">        pool3 = <span class=\"variable language_\">self</span>.vgg16.features[:-<span class=\"number\">14</span>](x)</span><br><span class=\"line\">        pool4 = <span class=\"variable language_\">self</span>.vgg16.features[-<span class=\"number\">14</span>:-<span class=\"number\">7</span>](pool3)</span><br><span class=\"line\">        pool5 = <span class=\"variable language_\">self</span>.vgg16.features[-<span class=\"number\">7</span>:](pool4)</span><br><span class=\"line\">        pool5_upscaled = <span class=\"variable language_\">self</span>.upscale5(<span class=\"variable language_\">self</span>.classifier(pool5))</span><br><span class=\"line\">        pool5_upscaled = _maybe_pad(pool5_upscaled, pool4.shape[<span class=\"number\">2</span>:])</span><br><span class=\"line\">        pool4_scores = <span class=\"variable language_\">self</span>.score4(pool4)</span><br><span class=\"line\">        pool4_fused = pool4_scores + pool5_upscaled</span><br><span class=\"line\">        pool4_upscaled = <span class=\"variable language_\">self</span>.upscale4(pool4_fused)</span><br><span class=\"line\">        pool4_upscaled = _maybe_pad(pool4_upscaled, pool3.shape[<span class=\"number\">2</span>:])</span><br><span class=\"line\">        x = <span class=\"variable language_\">self</span>.score3(pool3) + pool4_upscaled</span><br><span class=\"line\">        x = F.interpolate(x, size=(input_height, input_width),</span><br><span class=\"line\">                          mode=<span class=\"string\">&#x27;bilinear&#x27;</span>, align_corners=<span class=\"literal\">True</span>)</span><br><span class=\"line\">        <span class=\"keyword\">return</span> x</span><br></pre></td></tr></table></figure>\n\n<h4 id=\"相关资源\"><a href=\"#相关资源\" class=\"headerlink\" title=\"相关资源\"></a>相关资源</h4><h3 id=\"U-Net\"><a href=\"#U-Net\" class=\"headerlink\" title=\"U-Net\"></a><strong>U-Net</strong></h3><ul>\n<li><strong>优点</strong>：简单易用，适用于小数据集，尤其在医学图像分割中表现良好。</li>\n<li><strong>缺点</strong>：容易过拟合，不太适合大规模数据集。</li>\n</ul>\n<p><img src=\"https://tk-pichost-1325224430.cos.ap-chengdu.myqcloud.com/blog/1740236677445SwkUbDFUtolVEKxc4dmcbrOknJf.png\" alt=\"1740236677445SwkUbDFUtolVEKxc4dmcbrOknJf.png\"></p>\n<h4 id=\"提出初衷-1\"><a href=\"#提出初衷-1\" class=\"headerlink\" title=\"提出初衷\"></a>提出初衷</h4><p>U-Net 是一种经典且广泛使用的分割模型，以其简单、高效、易于理解和构建的特点而受到青睐，尤其适合从小数据集中进行训练。该模型最早于 2015 年在论文《U-Net: Convolutional Networks for Biomedical Image Segmentation》中被提出，至今仍然是医学图像分割领域的重要基础模型。</p>\n<p><img src=\"https://tk-pichost-1325224430.cos.ap-chengdu.myqcloud.com/blog/1740236700448YM2HbihrkonVkixR0KdcPLcBnLc.png\" alt=\"1740236700448YM2HbihrkonVkixR0KdcPLcBnLc.png\"></p>\n<p><img src=\"https://tk-pichost-1325224430.cos.ap-chengdu.myqcloud.com/blog/1740236696443Voorb6LuJopG3exmtulcaySynjc.png\" alt=\"1740236696443Voorb6LuJopG3exmtulcaySynjc.png\"></p>\n<p><img src=\"https://tk-pichost-1325224430.cos.ap-chengdu.myqcloud.com/blog/1740236682500NfPrbS5SNoEjsFxFFptcl471nhb.png\" alt=\"1740236682500NfPrbS5SNoEjsFxFFptcl471nhb.png\"></p>\n<ol>\n<li>Unet 提出的初衷是为了解决医学图像分割的问题；</li>\n<li>一种 U 型的网络结构来获取上下文的信息和位置信息；</li>\n<li>在 2015 年的 ISBI cell tracking 比赛中获得了多个第一，一开始这是为了解决细胞层面的分割的任务的</li>\n</ol>\n<h4 id=\"网络结构-1\"><a href=\"#网络结构-1\" class=\"headerlink\" title=\"网络结构\"></a>网络结构</h4><p><img src=\"https://tk-pichost-1325224430.cos.ap-chengdu.myqcloud.com/blog/1740236655458N3Vab29uNorFHwxpINwc5s6unkh.png\" alt=\"1740236655458N3Vab29uNorFHwxpINwc5s6unkh.png\"></p>\n<p>U-Net 网络是一种经典的编码器-解码器结构，因其整体结构形似大写的英文字母“U”而得名。它广泛应用于医学图像分割等领域。U-Net 的设计非常简洁：前半部分用于特征提取（编码器），后半部分用于上采样（解码器）。</p>\n<h5 id=\"编码器（Encoder）\"><a href=\"#编码器（Encoder）\" class=\"headerlink\" title=\"编码器（Encoder）\"></a>编码器（Encoder）</h5><p>编码器位于网络的左半部分，主要由多个下采样模块组成。每个模块包含两个 3×3 的卷积层（激活函数为 ReLU），后接一个 2×2 的最大池化（Max Pooling）层，用于特征提取和空间尺寸的减半。通过这种结构，编码器能够逐步提取图像的深层特征，同时扩大感受野。</p>\n<h5 id=\"解码器（Decoder）\"><a href=\"#解码器（Decoder）\" class=\"headerlink\" title=\"解码器（Decoder）\"></a>解码器（Decoder）</h5><p>解码器位于网络的右半部分，主要由上采样模块组成。每个模块包含一个 2×2 的反卷积层（上采样卷积层），用于将特征图的空间尺寸恢复到与编码器对应层相同的大小。随后，解码器通过特征拼接（concatenation）将上采样后的特征图与编码器中对应层的特征图进行通道级拼接，最后通过两个 3×3 的卷积层（激活函数为 ReLU）进一步融合特征。这种结构能够有效地结合深层特征和浅层特征，兼顾全局语义信息和局部细节。</p>\n<h5 id=\"特征融合方式\"><a href=\"#特征融合方式\" class=\"headerlink\" title=\"特征融合方式\"></a>特征融合方式</h5><p>与 FCN 网络通过特征图对应像素值的相加来融合特征不同，U-Net 采用通道级拼接的方式。这种方式可以形成更厚的特征图，从而保留更多的细节信息，但也增加了显存的消耗。</p>\n<h3 id=\"U-Net-的优点\"><a href=\"#U-Net-的优点\" class=\"headerlink\" title=\"U-Net 的优点\"></a>U-Net 的优点</h3><ol>\n<li><strong>多尺度特征融合</strong>：U-Net 通过拼接深层和浅层特征图，能够充分利用不同层次的特征。浅层卷积关注纹理和细节特征，而深层网络关注更高级的语义特征。这种融合方式使得模型能够更好地处理复杂的分割任务。</li>\n<li><strong>边缘特征的保留</strong>：在下采样过程中，虽然会损失一些边缘特征，但通过特征拼接，解码器能够从编码器的浅层特征中找回这些丢失的边缘信息，从而提高分割的精度。</li>\n</ol>\n<p>Unet 的好处我感觉是：网络层越深得到的特征图，有着更大的视野域，浅层卷积关注纹理特征，深层网络关注本质的那种特征，所以深层浅层特征都是有格子的意义的；另外一点是通过反卷积得到的更大的尺寸的特征图的边缘，是缺少信息的，毕竟每一次下采样提炼特征的同时，也必然会损失一些边缘特征，而失去的特征并不能从上采样中找回，因此通过特征的拼接，来实现边缘特征的一个找回。</p>\n<p>下面是一些与医学相关的数据集以及对应的提取码,有兴趣的同学可以下载下来跑一下。</p>\n<table>\n<tr>\n<td>**数据集名称**<br/></td><td>**下载链接**<td>**提取码**<br/></td></tr>\n<tr>\n<td>Cell dataset (dsb2018)<br/></td><td>https://pan.baidu.com/share/init?surl=BaVrzYdrSP78CwYaRzZr1w<td>5l54<br/></td></tr>\n<tr>\n<td>Liver dataset<br/></td><td>https://pan.baidu.com/share/init?surl=FljGCVzu7HPYpwAKvSVN4Q<td>5l88<br/></td></tr>\n<tr>\n<td>Cell dataset (isbi)<br/></td><td>https://pan.baidu.com/share/init?surl=FkfnhU-RnYFZti62-f8AVA<td>14rz<br/></td></tr>\n<tr>\n<td>Lung dataset<br/></td><td>https://pan.baidu.com/share/init?surl=sLFRmtG2TOTEgUKniJf7AA<td>qdwo<br/></td></tr>\n<tr>\n<td>Corneal Nerve dataset<br/></td><td>https://pan.baidu.com/share/init?surl=T3-kS_FgYI6DeXv3n1I7bA<td>ih02<br/></td></tr>\n<tr>\n<td>Eye Vessels (DRIVE dataset)<br/></td><td>https://pan.baidu.com/share/init?surl=UkMLmdbM61N8ecgnKlAsPg<td>f1ek<br/></td></tr>\n<tr>\n<td>Esophagus and Esophagus Cancer dataset (First Affiliated Hospital of Sun Yat-sen University)<br/></td><td>https://pan.baidu.com/share/init?surl=0b5arIQjNpiggwdkgYNHXQ<td>hivm<br/></td></tr>\n</table>\n\n<h4 id=\"为什么-Unet-在医疗图像分割中表现好\"><a href=\"#为什么-Unet-在医疗图像分割中表现好\" class=\"headerlink\" title=\"为什么 Unet 在医疗图像分割中表现好?\"></a>为什么 Unet 在医疗图像分割中表现好?</h4><p>大多数医疗影像语义分割任务都会首先用 Unet 作为 baseline，当然上一章节讲解的 Unet 的优点肯定是可以当作这个问题的答案，这里谈一谈医疗影像的特点</p>\n<p>根据网友的讨论，得到的结果：</p>\n<ol>\n<li>医疗影像语义较为简单、结构固定。因此语义信息相比自动驾驶等较为单一，因此并不需要去筛选过滤无用的信息。医疗影像的所有特征都很重要，因此低级特征和高级语义特征都很重要，所以 U 型结构的 skip connection 结构（特征拼接）更好派上用场</li>\n<li>医学影像的数据较少，获取难度大，数据量可能只有几百甚至不到 100，因此如果使用大型的网络例如 DeepLabv3+ 等模型，很容易过拟合。大型网络的优点是更强的图像表述能力，而较为简单、数量少的医学影像并没有那么多的内容需要表述，因此也有人发现在小数量级中，分割的 SOTA 模型与轻量的 Unet 并没有神恶魔优势</li>\n<li>医学影像往往是多模态的。比方说 ISLES 脑梗竞赛中，官方提供了 CBF，MTT，CBV 等多中模态的数据（这一点听不懂也无妨）。因此医学影像任务中，往往需要自己设计网络去提取不同的模态特征，因此轻量结构简单的 Unet 可以有更大的操作空间。</li>\n</ol>\n<blockquote>\n<p>Q:过拟合与模型复杂程度有关还和什么有关呢?</p>\n</blockquote>\n<h4 id=\"模型代码-1\"><a href=\"#模型代码-1\" class=\"headerlink\" title=\"模型代码\"></a>模型代码</h4><h5 id=\"源码\"><a href=\"#源码\" class=\"headerlink\" title=\"源码\"></a>源码</h5><figure class=\"highlight python\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br><span class=\"line\">47</span><br><span class=\"line\">48</span><br><span class=\"line\">49</span><br><span class=\"line\">50</span><br><span class=\"line\">51</span><br><span class=\"line\">52</span><br><span class=\"line\">53</span><br><span class=\"line\">54</span><br><span class=\"line\">55</span><br><span class=\"line\">56</span><br><span class=\"line\">57</span><br><span class=\"line\">58</span><br><span class=\"line\">59</span><br><span class=\"line\">60</span><br><span class=\"line\">61</span><br><span class=\"line\">62</span><br><span class=\"line\">63</span><br><span class=\"line\">64</span><br><span class=\"line\">65</span><br><span class=\"line\">66</span><br><span class=\"line\">67</span><br><span class=\"line\">68</span><br><span class=\"line\">69</span><br><span class=\"line\">70</span><br><span class=\"line\">71</span><br><span class=\"line\">72</span><br><span class=\"line\">73</span><br><span class=\"line\">74</span><br><span class=\"line\">75</span><br><span class=\"line\">76</span><br><span class=\"line\">77</span><br><span class=\"line\">78</span><br><span class=\"line\">79</span><br><span class=\"line\">80</span><br><span class=\"line\">81</span><br><span class=\"line\">82</span><br><span class=\"line\">83</span><br><span class=\"line\">84</span><br><span class=\"line\">85</span><br><span class=\"line\">86</span><br><span class=\"line\">87</span><br><span class=\"line\">88</span><br><span class=\"line\">89</span><br><span class=\"line\">90</span><br><span class=\"line\">91</span><br><span class=\"line\">92</span><br><span class=\"line\">93</span><br><span class=\"line\">94</span><br><span class=\"line\">95</span><br><span class=\"line\">96</span><br><span class=\"line\">97</span><br><span class=\"line\">98</span><br><span class=\"line\">99</span><br><span class=\"line\">100</span><br><span class=\"line\">101</span><br><span class=\"line\">102</span><br><span class=\"line\">103</span><br><span class=\"line\">104</span><br><span class=\"line\">105</span><br><span class=\"line\">106</span><br><span class=\"line\">107</span><br><span class=\"line\">108</span><br><span class=\"line\">109</span><br><span class=\"line\">110</span><br><span class=\"line\">111</span><br><span class=\"line\">112</span><br><span class=\"line\">113</span><br><span class=\"line\">114</span><br><span class=\"line\">115</span><br><span class=\"line\">116</span><br><span class=\"line\">117</span><br><span class=\"line\">118</span><br><span class=\"line\">119</span><br><span class=\"line\">120</span><br><span class=\"line\">121</span><br><span class=\"line\">122</span><br><span class=\"line\">123</span><br><span class=\"line\">124</span><br><span class=\"line\">125</span><br><span class=\"line\">126</span><br><span class=\"line\">127</span><br><span class=\"line\">128</span><br><span class=\"line\">129</span><br><span class=\"line\">130</span><br><span class=\"line\">131</span><br><span class=\"line\">132</span><br><span class=\"line\">133</span><br><span class=\"line\">134</span><br><span class=\"line\">135</span><br><span class=\"line\">136</span><br><span class=\"line\">137</span><br><span class=\"line\">138</span><br><span class=\"line\">139</span><br><span class=\"line\">140</span><br><span class=\"line\">141</span><br><span class=\"line\">142</span><br><span class=\"line\">143</span><br><span class=\"line\">144</span><br><span class=\"line\">145</span><br><span class=\"line\">146</span><br><span class=\"line\">147</span><br><span class=\"line\">148</span><br><span class=\"line\">149</span><br><span class=\"line\">150</span><br><span class=\"line\">151</span><br><span class=\"line\">152</span><br><span class=\"line\">153</span><br><span class=\"line\">154</span><br><span class=\"line\">155</span><br><span class=\"line\">156</span><br><span class=\"line\">157</span><br><span class=\"line\">158</span><br><span class=\"line\">159</span><br><span class=\"line\">160</span><br><span class=\"line\">161</span><br><span class=\"line\">162</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">import</span> torch.nn <span class=\"keyword\">as</span> nn</span><br><span class=\"line\"><span class=\"keyword\">import</span> torch</span><br><span class=\"line\"><span class=\"keyword\">from</span> torch <span class=\"keyword\">import</span> autograd</span><br><span class=\"line\"><span class=\"keyword\">from</span> functools <span class=\"keyword\">import</span> partial</span><br><span class=\"line\"><span class=\"keyword\">import</span> torch.nn.functional <span class=\"keyword\">as</span> F</span><br><span class=\"line\"><span class=\"keyword\">from</span> torchvision <span class=\"keyword\">import</span> models</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">class</span> <span class=\"title class_\">DoubleConv</span>(nn.Module):</span><br><span class=\"line\">    <span class=\"keyword\">def</span> <span class=\"title function_\">__init__</span>(<span class=\"params\">self, in_ch, out_ch</span>):</span><br><span class=\"line\">        <span class=\"built_in\">super</span>(DoubleConv, <span class=\"variable language_\">self</span>).__init__()</span><br><span class=\"line\">        <span class=\"variable language_\">self</span>.**conv** = nn.Sequential(</span><br><span class=\"line\">            nn.Conv2d(in_ch, out_ch, <span class=\"number\">3</span>, _padding_=<span class=\"number\">1</span>),</span><br><span class=\"line\">            nn.BatchNorm2d(out_ch),</span><br><span class=\"line\">            nn.ReLU(_inplace_=<span class=\"literal\">True</span>),</span><br><span class=\"line\">            nn.Conv2d(out_ch, out_ch, <span class=\"number\">3</span>, _padding_=<span class=\"number\">1</span>),</span><br><span class=\"line\">            nn.BatchNorm2d(out_ch),</span><br><span class=\"line\">            nn.ReLU(_inplace_=<span class=\"literal\">True</span>)</span><br><span class=\"line\">        )</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">def</span> <span class=\"title function_\">forward</span>(<span class=\"params\">self, <span class=\"built_in\">input</span></span>):</span><br><span class=\"line\">        <span class=\"keyword\">return</span> <span class=\"variable language_\">self</span>.**conv**(<span class=\"built_in\">input</span>)</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">class</span> <span class=\"title class_\">Unet</span>(nn.Module):</span><br><span class=\"line\">    <span class=\"keyword\">def</span> <span class=\"title function_\">__init__</span>(<span class=\"params\">self, in_ch, out_ch</span>):</span><br><span class=\"line\">        <span class=\"built_in\">super</span>(Unet, <span class=\"variable language_\">self</span>).__init__()</span><br><span class=\"line\"></span><br><span class=\"line\">        <span class=\"variable language_\">self</span>.**conv1** = DoubleConv(in_ch, <span class=\"number\">32</span>)</span><br><span class=\"line\">        <span class=\"variable language_\">self</span>.**pool1** = nn.MaxPool2d(<span class=\"number\">2</span>)</span><br><span class=\"line\">        <span class=\"variable language_\">self</span>.**conv2** = DoubleConv(<span class=\"number\">32</span>, <span class=\"number\">64</span>)</span><br><span class=\"line\">        <span class=\"variable language_\">self</span>.**pool2** = nn.MaxPool2d(<span class=\"number\">2</span>)</span><br><span class=\"line\">        <span class=\"variable language_\">self</span>.**conv3** = DoubleConv(<span class=\"number\">64</span>, <span class=\"number\">128</span>)</span><br><span class=\"line\">        <span class=\"variable language_\">self</span>.**pool3** = nn.MaxPool2d(<span class=\"number\">2</span>)</span><br><span class=\"line\">        <span class=\"variable language_\">self</span>.**conv4** = DoubleConv(<span class=\"number\">128</span>, <span class=\"number\">256</span>)</span><br><span class=\"line\">        <span class=\"variable language_\">self</span>.**pool4** = nn.MaxPool2d(<span class=\"number\">2</span>)</span><br><span class=\"line\">        <span class=\"variable language_\">self</span>.**conv5** = DoubleConv(<span class=\"number\">256</span>, <span class=\"number\">512</span>)</span><br><span class=\"line\">        <span class=\"variable language_\">self</span>.**up6** = nn.ConvTranspose2d(<span class=\"number\">512</span>, <span class=\"number\">256</span>, <span class=\"number\">2</span>, _stride_=<span class=\"number\">2</span>)</span><br><span class=\"line\">        <span class=\"variable language_\">self</span>.**conv6** = DoubleConv(<span class=\"number\">512</span>, <span class=\"number\">256</span>)</span><br><span class=\"line\">        <span class=\"variable language_\">self</span>.**up7** = nn.ConvTranspose2d(<span class=\"number\">256</span>, <span class=\"number\">128</span>, <span class=\"number\">2</span>, _stride_=<span class=\"number\">2</span>)</span><br><span class=\"line\">        <span class=\"variable language_\">self</span>.**conv7** = DoubleConv(<span class=\"number\">256</span>, <span class=\"number\">128</span>)</span><br><span class=\"line\">        <span class=\"variable language_\">self</span>.**up8** = nn.ConvTranspose2d(<span class=\"number\">128</span>, <span class=\"number\">64</span>, <span class=\"number\">2</span>, _stride_=<span class=\"number\">2</span>)</span><br><span class=\"line\">        <span class=\"variable language_\">self</span>.**conv8** = DoubleConv(<span class=\"number\">128</span>, <span class=\"number\">64</span>)</span><br><span class=\"line\">        <span class=\"variable language_\">self</span>.**up9** = nn.ConvTranspose2d(<span class=\"number\">64</span>, <span class=\"number\">32</span>, <span class=\"number\">2</span>, _stride_=<span class=\"number\">2</span>)</span><br><span class=\"line\">        <span class=\"variable language_\">self</span>.**conv9** = DoubleConv(<span class=\"number\">64</span>, <span class=\"number\">32</span>)</span><br><span class=\"line\">        <span class=\"variable language_\">self</span>.**conv10** = nn.Conv2d(<span class=\"number\">32</span>, out_ch, <span class=\"number\">1</span>)</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">def</span> <span class=\"title function_\">forward</span>(<span class=\"params\">self, x</span>):</span><br><span class=\"line\">        _<span class=\"comment\">#print(x.shape)_</span></span><br><span class=\"line\">        c1 = <span class=\"variable language_\">self</span>.**conv1**(x)</span><br><span class=\"line\">        p1 = <span class=\"variable language_\">self</span>.**pool1**(c1)</span><br><span class=\"line\">        _<span class=\"comment\">#print(p1.shape)_</span></span><br><span class=\"line\">        c2 = <span class=\"variable language_\">self</span>.**conv2**(p1)</span><br><span class=\"line\">        p2 = <span class=\"variable language_\">self</span>.**pool2**(c2)</span><br><span class=\"line\">        _<span class=\"comment\">#print(p2.shape)_</span></span><br><span class=\"line\">        c3 = <span class=\"variable language_\">self</span>.**conv3**(p2)</span><br><span class=\"line\">        p3 = <span class=\"variable language_\">self</span>.**pool3**(c3)</span><br><span class=\"line\">        _<span class=\"comment\">#print(p3.shape)_</span></span><br><span class=\"line\">        c4 = <span class=\"variable language_\">self</span>.**conv4**(p3)</span><br><span class=\"line\">        p4 = <span class=\"variable language_\">self</span>.**pool4**(c4)</span><br><span class=\"line\">        _<span class=\"comment\">#print(p4.shape)_</span></span><br><span class=\"line\">        c5 = <span class=\"variable language_\">self</span>.**conv5**(p4)</span><br><span class=\"line\">        up_6 = <span class=\"variable language_\">self</span>.**up6**(c5)</span><br><span class=\"line\">        merge6 = torch.cat([up_6, c4], _dim_=<span class=\"number\">1</span>)</span><br><span class=\"line\">        c6 = <span class=\"variable language_\">self</span>.**conv6**(merge6)</span><br><span class=\"line\">        up_7 = <span class=\"variable language_\">self</span>.**up7**(c6)</span><br><span class=\"line\">        merge7 = torch.cat([up_7, c3], _dim_=<span class=\"number\">1</span>)</span><br><span class=\"line\">        c7 = <span class=\"variable language_\">self</span>.**conv7**(merge7)</span><br><span class=\"line\">        up_8 = <span class=\"variable language_\">self</span>.**up8**(c7)</span><br><span class=\"line\">        merge8 = torch.cat([up_8, c2], _dim_=<span class=\"number\">1</span>)</span><br><span class=\"line\">        c8 = <span class=\"variable language_\">self</span>.**conv8**(merge8)</span><br><span class=\"line\">        up_9 = <span class=\"variable language_\">self</span>.**up9**(c8)</span><br><span class=\"line\">        merge9 = torch.cat([up_9, c1], _dim_=<span class=\"number\">1</span>)</span><br><span class=\"line\">        c9 = <span class=\"variable language_\">self</span>.**conv9**(merge9)</span><br><span class=\"line\">        c10 = <span class=\"variable language_\">self</span>.**conv10**(c9)</span><br><span class=\"line\">        out = nn.Sigmoid()(c10)</span><br><span class=\"line\">        <span class=\"keyword\">return</span> out</span><br><span class=\"line\"></span><br><span class=\"line\">nonlinearity = partial(F.relu, _inplace_=<span class=\"literal\">True</span>)</span><br><span class=\"line\"><span class=\"keyword\">class</span> <span class=\"title class_\">DecoderBlock</span>(nn.Module):</span><br><span class=\"line\">    <span class=\"keyword\">def</span> <span class=\"title function_\">__init__</span>(<span class=\"params\">self, in_channels, n_filters</span>):</span><br><span class=\"line\">        <span class=\"built_in\">super</span>(DecoderBlock, <span class=\"variable language_\">self</span>).__init__()</span><br><span class=\"line\"></span><br><span class=\"line\">        <span class=\"variable language_\">self</span>.**conv1** = nn.Conv2d(in_channels, in_channels // <span class=\"number\">4</span>, <span class=\"number\">1</span>)</span><br><span class=\"line\">        <span class=\"variable language_\">self</span>.**norm1** = nn.BatchNorm2d(in_channels // <span class=\"number\">4</span>)</span><br><span class=\"line\">        <span class=\"variable language_\">self</span>.**relu1** = nonlinearity</span><br><span class=\"line\"></span><br><span class=\"line\">        <span class=\"variable language_\">self</span>.**deconv2** = nn.ConvTranspose2d(in_channels // <span class=\"number\">4</span>, in_channels // <span class=\"number\">4</span>, <span class=\"number\">3</span>, _stride_=<span class=\"number\">2</span>, _padding_=<span class=\"number\">1</span>, _output_padding_=<span class=\"number\">1</span>)</span><br><span class=\"line\">        <span class=\"variable language_\">self</span>.**norm2** = nn.BatchNorm2d(in_channels // <span class=\"number\">4</span>)</span><br><span class=\"line\">        <span class=\"variable language_\">self</span>.**relu2** = nonlinearity</span><br><span class=\"line\"></span><br><span class=\"line\">        <span class=\"variable language_\">self</span>.**conv3** = nn.Conv2d(in_channels // <span class=\"number\">4</span>, n_filters, <span class=\"number\">1</span>)</span><br><span class=\"line\">        <span class=\"variable language_\">self</span>.**norm3** = nn.BatchNorm2d(n_filters)</span><br><span class=\"line\">        <span class=\"variable language_\">self</span>.**relu3** = nonlinearity</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">def</span> <span class=\"title function_\">forward</span>(<span class=\"params\">self, x</span>):</span><br><span class=\"line\">        x = <span class=\"variable language_\">self</span>.**conv1**(x)</span><br><span class=\"line\">        x = <span class=\"variable language_\">self</span>.**norm1**(x)</span><br><span class=\"line\">        x = <span class=\"variable language_\">self</span>.**relu1**(x)</span><br><span class=\"line\">        x = <span class=\"variable language_\">self</span>.**deconv2**(x)</span><br><span class=\"line\">        x = <span class=\"variable language_\">self</span>.**norm2**(x)</span><br><span class=\"line\">        x = <span class=\"variable language_\">self</span>.**relu2**(x)</span><br><span class=\"line\">        x = <span class=\"variable language_\">self</span>.**conv3**(x)</span><br><span class=\"line\">        x = <span class=\"variable language_\">self</span>.**norm3**(x)</span><br><span class=\"line\">        x = <span class=\"variable language_\">self</span>.**relu3**(x)</span><br><span class=\"line\">        <span class=\"keyword\">return</span> x</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">class</span> <span class=\"title class_\">resnet34_unet</span>(nn.Module):</span><br><span class=\"line\">    <span class=\"keyword\">def</span> <span class=\"title function_\">__init__</span>(<span class=\"params\">self, num_classes=<span class=\"number\">1</span>, num_channels=<span class=\"number\">3</span>,pretrained=<span class=\"literal\">True</span></span>):</span><br><span class=\"line\">        <span class=\"built_in\">super</span>(resnet34_unet, <span class=\"variable language_\">self</span>).__init__()</span><br><span class=\"line\"></span><br><span class=\"line\">        filters = [<span class=\"number\">64</span>, <span class=\"number\">128</span>, <span class=\"number\">256</span>, <span class=\"number\">512</span>]</span><br><span class=\"line\">        resnet = models.resnet34(_pretrained_=pretrained)</span><br><span class=\"line\">        <span class=\"variable language_\">self</span>.**firstconv** = resnet.**conv1**</span><br><span class=\"line\">        <span class=\"variable language_\">self</span>.**firstbn** = resnet.**bn1**</span><br><span class=\"line\">        <span class=\"variable language_\">self</span>.**firstrelu** = resnet.**relu**</span><br><span class=\"line\">        <span class=\"variable language_\">self</span>.**firstmaxpool** = resnet.**maxpool**</span><br><span class=\"line\">        <span class=\"variable language_\">self</span>.**encoder1** = resnet.**layer1**</span><br><span class=\"line\">        <span class=\"variable language_\">self</span>.**encoder2** = resnet.**layer2**</span><br><span class=\"line\">        <span class=\"variable language_\">self</span>.**encoder3** = resnet.**layer3**</span><br><span class=\"line\">        <span class=\"variable language_\">self</span>.**encoder4** = resnet.**layer4**</span><br><span class=\"line\"></span><br><span class=\"line\">        <span class=\"variable language_\">self</span>.**decoder4** = DecoderBlock(<span class=\"number\">512</span>, filters[<span class=\"number\">2</span>])</span><br><span class=\"line\">        <span class=\"variable language_\">self</span>.**decoder3** = DecoderBlock(filters[<span class=\"number\">2</span>], filters[<span class=\"number\">1</span>])</span><br><span class=\"line\">        <span class=\"variable language_\">self</span>.**decoder2** = DecoderBlock(filters[<span class=\"number\">1</span>], filters[<span class=\"number\">0</span>])</span><br><span class=\"line\">        <span class=\"variable language_\">self</span>.**decoder1** = DecoderBlock(filters[<span class=\"number\">0</span>], filters[<span class=\"number\">0</span>])</span><br><span class=\"line\"></span><br><span class=\"line\">        <span class=\"variable language_\">self</span>.**decoder4** = DecoderBlock(<span class=\"number\">512</span>, filters[<span class=\"number\">2</span>])</span><br><span class=\"line\">        <span class=\"variable language_\">self</span>.**decoder3** = DecoderBlock(filters[<span class=\"number\">2</span>], filters[<span class=\"number\">1</span>])</span><br><span class=\"line\">        <span class=\"variable language_\">self</span>.**decoder2** = DecoderBlock(filters[<span class=\"number\">1</span>], filters[<span class=\"number\">0</span>])</span><br><span class=\"line\">        <span class=\"variable language_\">self</span>.**decoder1** = DecoderBlock(filters[<span class=\"number\">0</span>], filters[<span class=\"number\">0</span>])</span><br><span class=\"line\"></span><br><span class=\"line\">        <span class=\"variable language_\">self</span>.**finaldeconv1** = nn.ConvTranspose2d(filters[<span class=\"number\">0</span>], <span class=\"number\">32</span>, <span class=\"number\">4</span>, <span class=\"number\">2</span>, <span class=\"number\">1</span>)</span><br><span class=\"line\">        <span class=\"variable language_\">self</span>.**finalrelu1** = nonlinearity</span><br><span class=\"line\">        <span class=\"variable language_\">self</span>.**finalconv2** = nn.Conv2d(<span class=\"number\">32</span>, <span class=\"number\">32</span>, <span class=\"number\">3</span>, _padding_=<span class=\"number\">1</span>)</span><br><span class=\"line\">        <span class=\"variable language_\">self</span>.**finalrelu2** = nonlinearity</span><br><span class=\"line\">        <span class=\"variable language_\">self</span>.**finalconv3** = nn.Conv2d(<span class=\"number\">32</span>, num_classes, <span class=\"number\">3</span>, _padding_=<span class=\"number\">1</span>)</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">def</span> <span class=\"title function_\">forward</span>(<span class=\"params\">self, x</span>):</span><br><span class=\"line\">        _<span class=\"comment\"># Encoder_</span></span><br><span class=\"line\">        x = <span class=\"variable language_\">self</span>.**firstconv**(x)</span><br><span class=\"line\">        x = <span class=\"variable language_\">self</span>.**firstbn**(x)</span><br><span class=\"line\">        x = <span class=\"variable language_\">self</span>.**firstrelu**(x)</span><br><span class=\"line\">        x = <span class=\"variable language_\">self</span>.**firstmaxpool**(x)</span><br><span class=\"line\">        e1 = <span class=\"variable language_\">self</span>.**encoder1**(x)</span><br><span class=\"line\">        e2 = <span class=\"variable language_\">self</span>.**encoder2**(e1)</span><br><span class=\"line\">        e3 = <span class=\"variable language_\">self</span>.**encoder3**(e2)</span><br><span class=\"line\">        e4 = <span class=\"variable language_\">self</span>.**encoder4**(e3)</span><br><span class=\"line\"></span><br><span class=\"line\">        _<span class=\"comment\"># Center_</span></span><br><span class=\"line\"></span><br><span class=\"line\">        _<span class=\"comment\"># Decoder_</span></span><br><span class=\"line\">        d4 = <span class=\"variable language_\">self</span>.**decoder4**(e4) + e3</span><br><span class=\"line\">        d3 = <span class=\"variable language_\">self</span>.**decoder3**(d4) + e2</span><br><span class=\"line\">        d2 = <span class=\"variable language_\">self</span>.**decoder2**(d3) + e1</span><br><span class=\"line\">        d1 = <span class=\"variable language_\">self</span>.**decoder1**(d2)</span><br><span class=\"line\"></span><br><span class=\"line\">        out = <span class=\"variable language_\">self</span>.**finaldeconv1**(d1)</span><br><span class=\"line\">        out = <span class=\"variable language_\">self</span>.**finalrelu1**(out)</span><br><span class=\"line\">        out = <span class=\"variable language_\">self</span>.**finalconv2**(out)</span><br><span class=\"line\">        out = <span class=\"variable language_\">self</span>.**finalrelu2**(out)</span><br><span class=\"line\">        out = <span class=\"variable language_\">self</span>.**finalconv3**(out)</span><br><span class=\"line\"></span><br><span class=\"line\">        <span class=\"keyword\">return</span> nn.Sigmoid()(out)</span><br></pre></td></tr></table></figure>\n\n<h5 id=\"模型实现\"><a href=\"#模型实现\" class=\"headerlink\" title=\"模型实现\"></a>模型实现</h5><figure class=\"highlight python\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br><span class=\"line\">47</span><br><span class=\"line\">48</span><br><span class=\"line\">49</span><br><span class=\"line\">50</span><br><span class=\"line\">51</span><br><span class=\"line\">52</span><br><span class=\"line\">53</span><br><span class=\"line\">54</span><br><span class=\"line\">55</span><br><span class=\"line\">56</span><br><span class=\"line\">57</span><br><span class=\"line\">58</span><br><span class=\"line\">59</span><br><span class=\"line\">60</span><br><span class=\"line\">61</span><br><span class=\"line\">62</span><br><span class=\"line\">63</span><br><span class=\"line\">64</span><br><span class=\"line\">65</span><br><span class=\"line\">66</span><br><span class=\"line\">67</span><br><span class=\"line\">68</span><br><span class=\"line\">69</span><br><span class=\"line\">70</span><br><span class=\"line\">71</span><br><span class=\"line\">72</span><br><span class=\"line\">73</span><br><span class=\"line\">74</span><br><span class=\"line\">75</span><br><span class=\"line\">76</span><br><span class=\"line\">77</span><br><span class=\"line\">78</span><br><span class=\"line\">79</span><br><span class=\"line\">80</span><br><span class=\"line\">81</span><br><span class=\"line\">82</span><br><span class=\"line\">83</span><br><span class=\"line\">84</span><br><span class=\"line\">85</span><br><span class=\"line\">86</span><br><span class=\"line\">87</span><br><span class=\"line\">88</span><br><span class=\"line\">89</span><br><span class=\"line\">90</span><br><span class=\"line\">91</span><br><span class=\"line\">92</span><br><span class=\"line\">93</span><br><span class=\"line\">94</span><br><span class=\"line\">95</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">import</span> torch</span><br><span class=\"line\"><span class=\"keyword\">import</span> torch.nn <span class=\"keyword\">as</span> nn</span><br><span class=\"line\"><span class=\"keyword\">import</span> torch.nn.functional <span class=\"keyword\">as</span> F</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">class</span> <span class=\"title class_\">double_conv2d_bn</span>(nn.Module):</span><br><span class=\"line\">    <span class=\"keyword\">def</span> <span class=\"title function_\">__init__</span>(<span class=\"params\">self,in_channels,out_channels,kernel_size=<span class=\"number\">3</span>,strides=<span class=\"number\">1</span>,padding=<span class=\"number\">1</span></span>):</span><br><span class=\"line\">        <span class=\"built_in\">super</span>(double_conv2d_bn,<span class=\"variable language_\">self</span>).__init__()</span><br><span class=\"line\">        <span class=\"variable language_\">self</span>.conv1 = nn.Conv2d(in_channels,out_channels,</span><br><span class=\"line\">                               kernel_size=kernel_size,</span><br><span class=\"line\">                              stride = strides,padding=padding,bias=<span class=\"literal\">True</span>)</span><br><span class=\"line\">        <span class=\"variable language_\">self</span>.conv2 = nn.Conv2d(out_channels,out_channels,</span><br><span class=\"line\">                              kernel_size = kernel_size,</span><br><span class=\"line\">                              stride = strides,padding=padding,bias=<span class=\"literal\">True</span>)</span><br><span class=\"line\">        <span class=\"variable language_\">self</span>.bn1 = nn.BatchNorm2d(out_channels)</span><br><span class=\"line\">        <span class=\"variable language_\">self</span>.bn2 = nn.BatchNorm2d(out_channels)</span><br><span class=\"line\">  </span><br><span class=\"line\">    <span class=\"keyword\">def</span> <span class=\"title function_\">forward</span>(<span class=\"params\">self,x</span>):</span><br><span class=\"line\">        out = F.relu(<span class=\"variable language_\">self</span>.bn1(<span class=\"variable language_\">self</span>.conv1(x)))</span><br><span class=\"line\">        out = F.relu(<span class=\"variable language_\">self</span>.bn2(<span class=\"variable language_\">self</span>.conv2(out)))</span><br><span class=\"line\">        <span class=\"keyword\">return</span> out</span><br><span class=\"line\">  </span><br><span class=\"line\"><span class=\"keyword\">class</span> <span class=\"title class_\">deconv2d_bn</span>(nn.Module):</span><br><span class=\"line\">    <span class=\"keyword\">def</span> <span class=\"title function_\">__init__</span>(<span class=\"params\">self,in_channels,out_channels,kernel_size=<span class=\"number\">2</span>,strides=<span class=\"number\">2</span></span>):</span><br><span class=\"line\">        <span class=\"built_in\">super</span>(deconv2d_bn,<span class=\"variable language_\">self</span>).__init__()</span><br><span class=\"line\">        <span class=\"variable language_\">self</span>.conv1 = nn.ConvTranspose2d(in_channels,out_channels,</span><br><span class=\"line\">                                        kernel_size = kernel_size,</span><br><span class=\"line\">                                       stride = strides,bias=<span class=\"literal\">True</span>)</span><br><span class=\"line\">        <span class=\"variable language_\">self</span>.bn1 = nn.BatchNorm2d(out_channels)</span><br><span class=\"line\">      </span><br><span class=\"line\">    <span class=\"keyword\">def</span> <span class=\"title function_\">forward</span>(<span class=\"params\">self,x</span>):</span><br><span class=\"line\">        out = F.relu(<span class=\"variable language_\">self</span>.bn1(<span class=\"variable language_\">self</span>.conv1(x)))</span><br><span class=\"line\">        <span class=\"keyword\">return</span> out</span><br><span class=\"line\">  </span><br><span class=\"line\"><span class=\"keyword\">class</span> <span class=\"title class_\">Unet</span>(nn.Module):</span><br><span class=\"line\">    <span class=\"keyword\">def</span> <span class=\"title function_\">__init__</span>(<span class=\"params\">self</span>):</span><br><span class=\"line\">        <span class=\"built_in\">super</span>(Unet,<span class=\"variable language_\">self</span>).__init__()</span><br><span class=\"line\">        <span class=\"variable language_\">self</span>.layer1_conv = double_conv2d_bn(<span class=\"number\">1</span>,<span class=\"number\">8</span>)</span><br><span class=\"line\">        <span class=\"variable language_\">self</span>.layer2_conv = double_conv2d_bn(<span class=\"number\">8</span>,<span class=\"number\">16</span>)</span><br><span class=\"line\">        <span class=\"variable language_\">self</span>.layer3_conv = double_conv2d_bn(<span class=\"number\">16</span>,<span class=\"number\">32</span>)</span><br><span class=\"line\">        <span class=\"variable language_\">self</span>.layer4_conv = double_conv2d_bn(<span class=\"number\">32</span>,<span class=\"number\">64</span>)</span><br><span class=\"line\">        <span class=\"variable language_\">self</span>.layer5_conv = double_conv2d_bn(<span class=\"number\">64</span>,<span class=\"number\">128</span>)</span><br><span class=\"line\">        <span class=\"variable language_\">self</span>.layer6_conv = double_conv2d_bn(<span class=\"number\">128</span>,<span class=\"number\">64</span>)</span><br><span class=\"line\">        <span class=\"variable language_\">self</span>.layer7_conv = double_conv2d_bn(<span class=\"number\">64</span>,<span class=\"number\">32</span>)</span><br><span class=\"line\">        <span class=\"variable language_\">self</span>.layer8_conv = double_conv2d_bn(<span class=\"number\">32</span>,<span class=\"number\">16</span>)</span><br><span class=\"line\">        <span class=\"variable language_\">self</span>.layer9_conv = double_conv2d_bn(<span class=\"number\">16</span>,<span class=\"number\">8</span>)</span><br><span class=\"line\">        <span class=\"variable language_\">self</span>.layer10_conv = nn.Conv2d(<span class=\"number\">8</span>,<span class=\"number\">1</span>,kernel_size=<span class=\"number\">3</span>,</span><br><span class=\"line\">                                     stride=<span class=\"number\">1</span>,padding=<span class=\"number\">1</span>,bias=<span class=\"literal\">True</span>)</span><br><span class=\"line\">      </span><br><span class=\"line\">        <span class=\"variable language_\">self</span>.deconv1 = deconv2d_bn(<span class=\"number\">128</span>,<span class=\"number\">64</span>)</span><br><span class=\"line\">        <span class=\"variable language_\">self</span>.deconv2 = deconv2d_bn(<span class=\"number\">64</span>,<span class=\"number\">32</span>)</span><br><span class=\"line\">        <span class=\"variable language_\">self</span>.deconv3 = deconv2d_bn(<span class=\"number\">32</span>,<span class=\"number\">16</span>)</span><br><span class=\"line\">        <span class=\"variable language_\">self</span>.deconv4 = deconv2d_bn(<span class=\"number\">16</span>,<span class=\"number\">8</span>)</span><br><span class=\"line\">      </span><br><span class=\"line\">        <span class=\"variable language_\">self</span>.sigmoid = nn.Sigmoid()</span><br><span class=\"line\">      </span><br><span class=\"line\">    <span class=\"keyword\">def</span> <span class=\"title function_\">forward</span>(<span class=\"params\">self,x</span>):</span><br><span class=\"line\">        conv1 = <span class=\"variable language_\">self</span>.layer1_conv(x)</span><br><span class=\"line\">        pool1 = F.max_pool2d(conv1,<span class=\"number\">2</span>)</span><br><span class=\"line\">      </span><br><span class=\"line\">        conv2 = <span class=\"variable language_\">self</span>.layer2_conv(pool1)</span><br><span class=\"line\">        pool2 = F.max_pool2d(conv2,<span class=\"number\">2</span>)</span><br><span class=\"line\">      </span><br><span class=\"line\">        conv3 = <span class=\"variable language_\">self</span>.layer3_conv(pool2)</span><br><span class=\"line\">        pool3 = F.max_pool2d(conv3,<span class=\"number\">2</span>)</span><br><span class=\"line\">      </span><br><span class=\"line\">        conv4 = <span class=\"variable language_\">self</span>.layer4_conv(pool3)</span><br><span class=\"line\">        pool4 = F.max_pool2d(conv4,<span class=\"number\">2</span>)</span><br><span class=\"line\">      </span><br><span class=\"line\">        conv5 = <span class=\"variable language_\">self</span>.layer5_conv(pool4)</span><br><span class=\"line\">      </span><br><span class=\"line\">        convt1 = <span class=\"variable language_\">self</span>.deconv1(conv5)</span><br><span class=\"line\">        concat1 = torch.cat([convt1,conv4],dim=<span class=\"number\">1</span>)</span><br><span class=\"line\">        conv6 = <span class=\"variable language_\">self</span>.layer6_conv(concat1)</span><br><span class=\"line\">      </span><br><span class=\"line\">        convt2 = <span class=\"variable language_\">self</span>.deconv2(conv6)</span><br><span class=\"line\">        concat2 = torch.cat([convt2,conv3],dim=<span class=\"number\">1</span>)</span><br><span class=\"line\">        conv7 = <span class=\"variable language_\">self</span>.layer7_conv(concat2)</span><br><span class=\"line\">      </span><br><span class=\"line\">        convt3 = <span class=\"variable language_\">self</span>.deconv3(conv7)</span><br><span class=\"line\">        concat3 = torch.cat([convt3,conv2],dim=<span class=\"number\">1</span>)</span><br><span class=\"line\">        conv8 = <span class=\"variable language_\">self</span>.layer8_conv(concat3)</span><br><span class=\"line\">      </span><br><span class=\"line\">        convt4 = <span class=\"variable language_\">self</span>.deconv4(conv8)</span><br><span class=\"line\">        concat4 = torch.cat([convt4,conv1],dim=<span class=\"number\">1</span>)</span><br><span class=\"line\">        conv9 = <span class=\"variable language_\">self</span>.layer9_conv(concat4)</span><br><span class=\"line\">        outp = <span class=\"variable language_\">self</span>.layer10_conv(conv9)</span><br><span class=\"line\">        outp = <span class=\"variable language_\">self</span>.sigmoid(outp)</span><br><span class=\"line\">        <span class=\"keyword\">return</span> outp</span><br><span class=\"line\">  </span><br><span class=\"line\"></span><br><span class=\"line\">model = Unet()</span><br><span class=\"line\">inp = torch.rand(<span class=\"number\">10</span>,<span class=\"number\">1</span>,<span class=\"number\">224</span>,<span class=\"number\">224</span>)</span><br><span class=\"line\">outp = model(inp)</span><br><span class=\"line\"><span class=\"built_in\">print</span>(outp.shape)</span><br><span class=\"line\">==&gt; torch.Size([<span class=\"number\">10</span>, <span class=\"number\">1</span>, <span class=\"number\">224</span>, <span class=\"number\">224</span>])</span><br></pre></td></tr></table></figure>\n\n<h4 id=\"相关资源-1\"><a href=\"#相关资源-1\" class=\"headerlink\" title=\"相关资源\"></a>相关资源</h4><h5 id=\"项目\"><a href=\"#项目\" class=\"headerlink\" title=\"项目\"></a>项目</h5><blockquote>\n<p><a href=\"https://github.com/Andy-zhujunwen/UNET-ZOO?tab=readme-ov-file%60\">https://github.com/Andy-zhujunwen/UNET-ZOO?tab=readme-ov-file`</a><br><code> https://github.com/bigmb/Unet-Segmentation-Pytorch-Nest-of-Unets</code><br><code> https://www.codewithgpu.com/i/bubbliiiing/unet-pytorch/UNet-PyTorch</code><br>&#96;<br><a href=\"https://huggingface.co/spaces/h2chen/demo_unet\">https://huggingface.co/spaces/h2chen/demo_unet</a></p>\n</blockquote>\n<h5 id=\"博客\"><a href=\"#博客\" class=\"headerlink\" title=\"博客\"></a>博客</h5><blockquote>\n<p><a href=\"https://blog.csdn.net/weixin_45074568/article/details/114901600\">UNet详解（附图文和代码实现）-CSDN博客</a><code>&lt;br&gt;</code><br><a href=\"https://www.cnblogs.com/PythonLearner/p/14041874.html\">图像分割必备知识点 | Unet详解 理论+ 代码 - 忽逢桃林 - 博客园</a></p>\n</blockquote>\n<hr>\n","excerpt":"","more":"<h1 id=\"前言\"><a href=\"#前言\" class=\"headerlink\" title=\"前言\"></a>前言</h1><p>在开始这篇文章之前，我们得首先弄明白，什么是图像分割？</p>\n<p>我们知道一个图像只不过是许多像素的集合。图像分割分类是对图像中属于特定类别的像素进行分类的过程，即像素级别的下游任务。因此图像分割简单来说就是按像素进行分类的问题。</p>\n<p>传统的图像分割算法均是基于灰度值的不连续和相似的性质。而基于深度学习的图像分割技术则是利用卷积神经网络，来理解图像中的每个像素所代表的真实世界物体，这在以前是难以想象的。</p>\n<p><img src=\"https://tk-pichost-1325224430.cos.ap-chengdu.myqcloud.com/blog/1740235822031FRBrbtq8Zogp1oxNSIhcx7Z6nVb.png\" alt=\"1740235822031FRBrbtq8Zogp1oxNSIhcx7Z6nVb.png\"></p>\n<h1 id=\"语义分割（Semantic-Segmentation）\"><a href=\"#语义分割（Semantic-Segmentation）\" class=\"headerlink\" title=\"语义分割（Semantic Segmentation）\"></a><strong>语义分割（Semantic Segmentation）</strong></h1><h2 id=\"定义\"><a href=\"#定义\" class=\"headerlink\" title=\"** 定义**\"></a>** 定义**</h2><p>“语义”是个很抽象的概念，在 2D 图像领域，每个像素点作为最小单位，它的像素值代表的就是一个特征，即“语义”信息。语义分割会为图像中的每个像素分配一个类别，但是同一类别之间的对象不会区分。而实例分割，只对特定的物体进行分类。这看起来与目标检测相似，不同的是目标检测输出目标的边界框和类别，实例分割输出的是目标的 Mask 和类别。具体而言，语义分割的目的是为了从像素级别理解图像的内容，并为图像中的每个像素分配一个对象类。</p>\n<p>语义分割是一种将图像中的每个像素分配给特定类别的技术。其目标是识别图像中存在的各种对象和背景，并为每个像素分配相应的类别标签。例如，将图像中的像素划分为人、树、草地和天空等不同区域。是图像处理和机器视觉一个重要分支。与分类任务不同，语义分割需要判断图像每个像素点的类别，进行精确分割。语义分割目前在自动驾驶、自动抠图、医疗影像等领域有着比较广泛的应用。</p>\n<h2 id=\"特点\"><a href=\"#特点\" class=\"headerlink\" title=\"** 特点**\"></a>** 特点**</h2><ul>\n<li>提供精确的像素级分类，有助于深入理解图像内容。</li>\n<li>无法区分同一类别中的不同实例。</li>\n</ul>\n<h2 id=\"语义分割的应用\"><a href=\"#语义分割的应用\" class=\"headerlink\" title=\"** 语义分割的应用**\"></a>** 语义分割的应用**</h2><p>语义分割在多个领域有广泛应用：</p>\n<ul>\n<li><strong>自动驾驶</strong>：用于道路、车辆和行人的识别。</li>\n<li><strong>医学成像</strong>：用于组织和器官的分割。</li>\n<li><strong>卫星遥感</strong>：用于土地覆盖分类。</li>\n</ul>\n<h2 id=\"常见模型\"><a href=\"#常见模型\" class=\"headerlink\" title=\"** 常见模型**\"></a>** 常见模型**</h2><h3 id=\"FCN（Fully-Convolutional-Network）\"><a href=\"#FCN（Fully-Convolutional-Network）\" class=\"headerlink\" title=\"FCN（Fully Convolutional Network）\"></a><strong>FCN（Fully Convolutional Network）</strong></h3><ul>\n<li><strong>优点</strong>：简单易用，但是现在已经很少使用了,但它的历史贡献不可忽视。</li>\n<li><strong>缺点</strong>：分割精度较低，可能无法很好地处理细节。</li>\n</ul>\n<h4 id=\"提出初衷\"><a href=\"#提出初衷\" class=\"headerlink\" title=\"提出初衷\"></a>提出初衷</h4><p><img src=\"https://tk-pichost-1325224430.cos.ap-chengdu.myqcloud.com/blog/1740236704772Z5SNbToLOosLf9xBvllcevjVnEe.png\" alt=\"1740236704772Z5SNbToLOosLf9xBvllcevjVnEe.png\"><br>FCN（全卷积网络）模型的初衷是为了解决传统卷积神经网络（CNN）在语义分割任务中的局限性。具体而言，传统 CNN 使用全连接层进行分类，这会丢失图像的空间位置信息，导致其不适合像素级的预测任务。FCN 的核心动机包括：</p>\n<ol>\n<li><strong>实现端到端的像素级预测</strong>：FCN 通过将全连接层替换为卷积层，使得网络能够接受任意尺寸的输入图像，并输出与输入尺寸相同的像素级预测结果。</li>\n<li><strong>保留空间信息</strong>：取消全连接层后，FCN 能够保留图像的空间位置信息，从而更好地适应语义分割任务。</li>\n<li><strong>提高分割效率和精度</strong>：通过引入反卷积层（上采样层）和跳跃连接（Skip Connections），FCN 能够融合不同深度的特征，兼顾全局语义信息和局部细节，从而提升分割精度。</li>\n<li><strong>利用预训练模型加速训练</strong>：FCN 可以基于预训练的分类模型（如 AlexNet、VGG 等）进行微调，从而显著加速训练过程并提高模型性能。</li>\n</ol>\n<h4 id=\"网络结构\"><a href=\"#网络结构\" class=\"headerlink\" title=\"网络结构\"></a>网络结构</h4><p><img src=\"https://tk-pichost-1325224430.cos.ap-chengdu.myqcloud.com/blog/1740236686503VcqtbHWWQoRtJIxgy6bconZQnHc.png\" alt=\"1740236686503VcqtbHWWQoRtJIxgy6bconZQnHc.png\"><br>通常 CNN 网络在卷积层之后会接上若干个全连接层, 将卷积层产生的特征图(feature map)映射成一个固定长度的特征向量。以 AlexNet 为代表的经典 CNN 结构适合于图像级的分类和回归任务，因为它们最后都期望得到整个输入图像的一个数值描述（概率）。<br>FCN 对图像进行像素级的分类，从而解决了语义级别的图像分割（semantic segmentation）问题。与经典的 CNN 在卷积层之后使用全连接层得到固定长度的特征向量进行分类（全连接层 ＋softmax 输出）不同，FCN 可以接受任意尺寸的输入图像，采用反卷积层对最后一个卷积层的 feature map 进行上采样, 使它恢复到输入图像相同的尺寸，从而可以对每个像素都产生了一个预测, 同时保留了原始输入图像中的空间信息, 最后在上采样的特征图上进行逐像素分类。<br><img src=\"https://tk-pichost-1325224430.cos.ap-chengdu.myqcloud.com/blog/1740236781446CxZ6b4zcXo9A12xuNJtcEgA7nfc.png\" alt=\"1740236781446CxZ6b4zcXo9A12xuNJtcEgA7nfc.png\"><br>FCN（全卷积网络）为了解决语义分割（semantic segmentation）问题而提出，它对图像进行像素级的分类，能够保留原始输入图像中的空间信息。与传统 CNN 不同，FCN 可以接受任意尺寸的输入图像，并通过以下方式实现像素级分类：</p>\n<ol>\n<li><strong>去除全连接层</strong>：FCN 将传统 CNN 中的全连接层替换为卷积层，从而保留空间信息。</li>\n<li><strong>上采样操作</strong>：使用反卷积层（上采样层）对最后一个卷积层的特征图进行上采样，恢复到与输入图像相同的尺寸。</li>\n<li><strong>逐像素分类</strong>：在上采样后的特征图上进行逐像素分类，为每个像素生成类别预测。</li>\n</ol>\n<blockquote>\n<p>Q:<strong>FCN 是如何通过上采样操作恢复特征图的空间分辨率的？</strong></p>\n</blockquote>\n<h4 id=\"模型代码\"><a href=\"#模型代码\" class=\"headerlink\" title=\"模型代码\"></a>模型代码</h4><h5 id=\"论文源码\"><a href=\"#论文源码\" class=\"headerlink\" title=\"论文源码\"></a>论文源码</h5><figure class=\"highlight python\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br><span class=\"line\">47</span><br><span class=\"line\">48</span><br><span class=\"line\">49</span><br><span class=\"line\">50</span><br><span class=\"line\">51</span><br><span class=\"line\">52</span><br><span class=\"line\">53</span><br><span class=\"line\">54</span><br><span class=\"line\">55</span><br><span class=\"line\">56</span><br><span class=\"line\">57</span><br><span class=\"line\">58</span><br><span class=\"line\">59</span><br><span class=\"line\">60</span><br><span class=\"line\">61</span><br><span class=\"line\">62</span><br><span class=\"line\">63</span><br><span class=\"line\">64</span><br><span class=\"line\">65</span><br><span class=\"line\">66</span><br><span class=\"line\">67</span><br><span class=\"line\">68</span><br><span class=\"line\">69</span><br><span class=\"line\">70</span><br><span class=\"line\">71</span><br><span class=\"line\">72</span><br><span class=\"line\">73</span><br><span class=\"line\">74</span><br><span class=\"line\">75</span><br><span class=\"line\">76</span><br><span class=\"line\">77</span><br><span class=\"line\">78</span><br><span class=\"line\">79</span><br><span class=\"line\">80</span><br><span class=\"line\">81</span><br><span class=\"line\">82</span><br><span class=\"line\">83</span><br><span class=\"line\">84</span><br><span class=\"line\">85</span><br><span class=\"line\">86</span><br><span class=\"line\">87</span><br><span class=\"line\">88</span><br><span class=\"line\">89</span><br><span class=\"line\">90</span><br><span class=\"line\">91</span><br><span class=\"line\">92</span><br><span class=\"line\">93</span><br><span class=\"line\">94</span><br><span class=\"line\">95</span><br><span class=\"line\">96</span><br><span class=\"line\">97</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">import</span> caffe</span><br><span class=\"line\"><span class=\"keyword\">from</span> caffe <span class=\"keyword\">import</span> layers <span class=\"keyword\">as</span> L, params <span class=\"keyword\">as</span> P</span><br><span class=\"line\"><span class=\"keyword\">from</span> caffe.coord_map <span class=\"keyword\">import</span> crop</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">def</span> <span class=\"title function_\">conv_relu</span>(<span class=\"params\">bottom, nout, ks=<span class=\"number\">3</span>, stride=<span class=\"number\">1</span>, pad=<span class=\"number\">1</span></span>):</span><br><span class=\"line\">    conv = L.Convolution(bottom, kernel_size=ks, stride=stride,</span><br><span class=\"line\">        num_output=nout, pad=pad,</span><br><span class=\"line\">        param=[<span class=\"built_in\">dict</span>(lr_mult=<span class=\"number\">1</span>, decay_mult=<span class=\"number\">1</span>), <span class=\"built_in\">dict</span>(lr_mult=<span class=\"number\">2</span>, decay_mult=<span class=\"number\">0</span>)])</span><br><span class=\"line\">    <span class=\"keyword\">return</span> conv, L.ReLU(conv, in_place=<span class=\"literal\">True</span>)</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">def</span> <span class=\"title function_\">max_pool</span>(<span class=\"params\">bottom, ks=<span class=\"number\">2</span>, stride=<span class=\"number\">2</span></span>):</span><br><span class=\"line\">    <span class=\"keyword\">return</span> L.Pooling(bottom, pool=P.Pooling.MAX, kernel_size=ks, stride=stride)</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">def</span> <span class=\"title function_\">fcn</span>(<span class=\"params\">split</span>):</span><br><span class=\"line\">    n = caffe.NetSpec()</span><br><span class=\"line\">    pydata_params = <span class=\"built_in\">dict</span>(split=split, mean=(<span class=\"number\">104.00699</span>, <span class=\"number\">116.66877</span>, <span class=\"number\">122.67892</span>),</span><br><span class=\"line\">            seed=<span class=\"number\">1337</span>)</span><br><span class=\"line\">    <span class=\"keyword\">if</span> split == <span class=\"string\">&#x27;train&#x27;</span>:</span><br><span class=\"line\">        pydata_params[<span class=\"string\">&#x27;sbdd_dir&#x27;</span>] = <span class=\"string\">&#x27;../data/sbdd/dataset&#x27;</span></span><br><span class=\"line\">        pylayer = <span class=\"string\">&#x27;SBDDSegDataLayer&#x27;</span></span><br><span class=\"line\">    <span class=\"keyword\">else</span>:</span><br><span class=\"line\">        pydata_params[<span class=\"string\">&#x27;voc_dir&#x27;</span>] = <span class=\"string\">&#x27;../data/pascal/VOC2011&#x27;</span></span><br><span class=\"line\">        pylayer = <span class=\"string\">&#x27;VOCSegDataLayer&#x27;</span></span><br><span class=\"line\">    n.data, n.label = L.Python(module=<span class=\"string\">&#x27;voc_layers&#x27;</span>, layer=pylayer,</span><br><span class=\"line\">            ntop=<span class=\"number\">2</span>, param_str=<span class=\"built_in\">str</span>(pydata_params))</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\"># the base net</span></span><br><span class=\"line\">    n.conv1_1, n.relu1_1 = conv_relu(n.data, <span class=\"number\">64</span>, pad=<span class=\"number\">100</span>)</span><br><span class=\"line\">    n.conv1_2, n.relu1_2 = conv_relu(n.relu1_1, <span class=\"number\">64</span>)</span><br><span class=\"line\">    n.pool1 = max_pool(n.relu1_2)</span><br><span class=\"line\"></span><br><span class=\"line\">    n.conv2_1, n.relu2_1 = conv_relu(n.pool1, <span class=\"number\">128</span>)</span><br><span class=\"line\">    n.conv2_2, n.relu2_2 = conv_relu(n.relu2_1, <span class=\"number\">128</span>)</span><br><span class=\"line\">    n.pool2 = max_pool(n.relu2_2)</span><br><span class=\"line\"></span><br><span class=\"line\">    n.conv3_1, n.relu3_1 = conv_relu(n.pool2, <span class=\"number\">256</span>)</span><br><span class=\"line\">    n.conv3_2, n.relu3_2 = conv_relu(n.relu3_1, <span class=\"number\">256</span>)</span><br><span class=\"line\">    n.conv3_3, n.relu3_3 = conv_relu(n.relu3_2, <span class=\"number\">256</span>)</span><br><span class=\"line\">    n.pool3 = max_pool(n.relu3_3)</span><br><span class=\"line\"></span><br><span class=\"line\">    n.conv4_1, n.relu4_1 = conv_relu(n.pool3, <span class=\"number\">512</span>)</span><br><span class=\"line\">    n.conv4_2, n.relu4_2 = conv_relu(n.relu4_1, <span class=\"number\">512</span>)</span><br><span class=\"line\">    n.conv4_3, n.relu4_3 = conv_relu(n.relu4_2, <span class=\"number\">512</span>)</span><br><span class=\"line\">    n.pool4 = max_pool(n.relu4_3)</span><br><span class=\"line\"></span><br><span class=\"line\">    n.conv5_1, n.relu5_1 = conv_relu(n.pool4, <span class=\"number\">512</span>)</span><br><span class=\"line\">    n.conv5_2, n.relu5_2 = conv_relu(n.relu5_1, <span class=\"number\">512</span>)</span><br><span class=\"line\">    n.conv5_3, n.relu5_3 = conv_relu(n.relu5_2, <span class=\"number\">512</span>)</span><br><span class=\"line\">    n.pool5 = max_pool(n.relu5_3)</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\"># fully conv</span></span><br><span class=\"line\">    n.fc6, n.relu6 = conv_relu(n.pool5, <span class=\"number\">4096</span>, ks=<span class=\"number\">7</span>, pad=<span class=\"number\">0</span>)</span><br><span class=\"line\">    n.drop6 = L.Dropout(n.relu6, dropout_ratio=<span class=\"number\">0.5</span>, in_place=<span class=\"literal\">True</span>)</span><br><span class=\"line\">    n.fc7, n.relu7 = conv_relu(n.drop6, <span class=\"number\">4096</span>, ks=<span class=\"number\">1</span>, pad=<span class=\"number\">0</span>)</span><br><span class=\"line\">    n.drop7 = L.Dropout(n.relu7, dropout_ratio=<span class=\"number\">0.5</span>, in_place=<span class=\"literal\">True</span>)</span><br><span class=\"line\">    n.score_fr = L.Convolution(n.drop7, num_output=<span class=\"number\">21</span>, kernel_size=<span class=\"number\">1</span>, pad=<span class=\"number\">0</span>,</span><br><span class=\"line\">        param=[<span class=\"built_in\">dict</span>(lr_mult=<span class=\"number\">1</span>, decay_mult=<span class=\"number\">1</span>), <span class=\"built_in\">dict</span>(lr_mult=<span class=\"number\">2</span>, decay_mult=<span class=\"number\">0</span>)])</span><br><span class=\"line\">    n.upscore2 = L.Deconvolution(n.score_fr,</span><br><span class=\"line\">        convolution_param=<span class=\"built_in\">dict</span>(num_output=<span class=\"number\">21</span>, kernel_size=<span class=\"number\">4</span>, stride=<span class=\"number\">2</span>,</span><br><span class=\"line\">            bias_term=<span class=\"literal\">False</span>),</span><br><span class=\"line\">        param=[<span class=\"built_in\">dict</span>(lr_mult=<span class=\"number\">0</span>)])</span><br><span class=\"line\"></span><br><span class=\"line\">    n.score_pool4 = L.Convolution(n.pool4, num_output=<span class=\"number\">21</span>, kernel_size=<span class=\"number\">1</span>, pad=<span class=\"number\">0</span>,</span><br><span class=\"line\">        param=[<span class=\"built_in\">dict</span>(lr_mult=<span class=\"number\">1</span>, decay_mult=<span class=\"number\">1</span>), <span class=\"built_in\">dict</span>(lr_mult=<span class=\"number\">2</span>, decay_mult=<span class=\"number\">0</span>)])</span><br><span class=\"line\">    n.score_pool4c = crop(n.score_pool4, n.upscore2)</span><br><span class=\"line\">    n.fuse_pool4 = L.Eltwise(n.upscore2, n.score_pool4c,</span><br><span class=\"line\">            operation=P.Eltwise.SUM)</span><br><span class=\"line\">    n.upscore_pool4 = L.Deconvolution(n.fuse_pool4,</span><br><span class=\"line\">        convolution_param=<span class=\"built_in\">dict</span>(num_output=<span class=\"number\">21</span>, kernel_size=<span class=\"number\">4</span>, stride=<span class=\"number\">2</span>,</span><br><span class=\"line\">            bias_term=<span class=\"literal\">False</span>),</span><br><span class=\"line\">        param=[<span class=\"built_in\">dict</span>(lr_mult=<span class=\"number\">0</span>)])</span><br><span class=\"line\"></span><br><span class=\"line\">    n.score_pool3 = L.Convolution(n.pool3, num_output=<span class=\"number\">21</span>, kernel_size=<span class=\"number\">1</span>, pad=<span class=\"number\">0</span>,</span><br><span class=\"line\">        param=[<span class=\"built_in\">dict</span>(lr_mult=<span class=\"number\">1</span>, decay_mult=<span class=\"number\">1</span>), <span class=\"built_in\">dict</span>(lr_mult=<span class=\"number\">2</span>, decay_mult=<span class=\"number\">0</span>)])</span><br><span class=\"line\">    n.score_pool3c = crop(n.score_pool3, n.upscore_pool4)</span><br><span class=\"line\">    n.fuse_pool3 = L.Eltwise(n.upscore_pool4, n.score_pool3c,</span><br><span class=\"line\">            operation=P.Eltwise.SUM)</span><br><span class=\"line\">    n.upscore8 = L.Deconvolution(n.fuse_pool3,</span><br><span class=\"line\">        convolution_param=<span class=\"built_in\">dict</span>(num_output=<span class=\"number\">21</span>, kernel_size=<span class=\"number\">16</span>, stride=<span class=\"number\">8</span>,</span><br><span class=\"line\">            bias_term=<span class=\"literal\">False</span>),</span><br><span class=\"line\">        param=[<span class=\"built_in\">dict</span>(lr_mult=<span class=\"number\">0</span>)])</span><br><span class=\"line\"></span><br><span class=\"line\">    n.score = crop(n.upscore8, n.data)</span><br><span class=\"line\">    n.loss = L.SoftmaxWithLoss(n.score, n.label,</span><br><span class=\"line\">            loss_param=<span class=\"built_in\">dict</span>(normalize=<span class=\"literal\">False</span>, ignore_label=<span class=\"number\">255</span>))</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">return</span> n.to_proto()</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">def</span> <span class=\"title function_\">make_net</span>():</span><br><span class=\"line\">    <span class=\"keyword\">with</span> <span class=\"built_in\">open</span>(<span class=\"string\">&#x27;train.prototxt&#x27;</span>, <span class=\"string\">&#x27;w&#x27;</span>) <span class=\"keyword\">as</span> f:</span><br><span class=\"line\">        f.write(<span class=\"built_in\">str</span>(fcn(<span class=\"string\">&#x27;train&#x27;</span>)))</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">with</span> <span class=\"built_in\">open</span>(<span class=\"string\">&#x27;val.prototxt&#x27;</span>, <span class=\"string\">&#x27;w&#x27;</span>) <span class=\"keyword\">as</span> f:</span><br><span class=\"line\">        f.write(<span class=\"built_in\">str</span>(fcn(<span class=\"string\">&#x27;seg11valid&#x27;</span>)))</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">if</span> __name__ == <span class=\"string\">&#x27;__main__&#x27;</span>:</span><br><span class=\"line\">    make_net()</span><br></pre></td></tr></table></figure>\n\n<h5 id=\"fcn8-vgg\"><a href=\"#fcn8-vgg\" class=\"headerlink\" title=\"fcn8_vgg\"></a>fcn8_vgg</h5><figure class=\"highlight python\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br><span class=\"line\">47</span><br><span class=\"line\">48</span><br><span class=\"line\">49</span><br><span class=\"line\">50</span><br><span class=\"line\">51</span><br><span class=\"line\">52</span><br><span class=\"line\">53</span><br><span class=\"line\">54</span><br><span class=\"line\">55</span><br><span class=\"line\">56</span><br><span class=\"line\">57</span><br><span class=\"line\">58</span><br><span class=\"line\">59</span><br><span class=\"line\">60</span><br><span class=\"line\">61</span><br><span class=\"line\">62</span><br><span class=\"line\">63</span><br><span class=\"line\">64</span><br><span class=\"line\">65</span><br><span class=\"line\">66</span><br><span class=\"line\">67</span><br><span class=\"line\">68</span><br><span class=\"line\">69</span><br><span class=\"line\">70</span><br><span class=\"line\">71</span><br><span class=\"line\">72</span><br><span class=\"line\">73</span><br><span class=\"line\">74</span><br><span class=\"line\">75</span><br><span class=\"line\">76</span><br><span class=\"line\">77</span><br><span class=\"line\">78</span><br><span class=\"line\">79</span><br><span class=\"line\">80</span><br><span class=\"line\">81</span><br><span class=\"line\">82</span><br><span class=\"line\">83</span><br><span class=\"line\">84</span><br><span class=\"line\">85</span><br><span class=\"line\">86</span><br><span class=\"line\">87</span><br><span class=\"line\">88</span><br><span class=\"line\">89</span><br><span class=\"line\">90</span><br><span class=\"line\">91</span><br><span class=\"line\">92</span><br><span class=\"line\">93</span><br><span class=\"line\">94</span><br><span class=\"line\">95</span><br><span class=\"line\">96</span><br><span class=\"line\">97</span><br><span class=\"line\">98</span><br><span class=\"line\">99</span><br><span class=\"line\">100</span><br><span class=\"line\">101</span><br><span class=\"line\">102</span><br><span class=\"line\">103</span><br><span class=\"line\">104</span><br><span class=\"line\">105</span><br><span class=\"line\">106</span><br><span class=\"line\">107</span><br><span class=\"line\">108</span><br><span class=\"line\">109</span><br><span class=\"line\">110</span><br><span class=\"line\">111</span><br><span class=\"line\">112</span><br><span class=\"line\">113</span><br><span class=\"line\">114</span><br><span class=\"line\">115</span><br><span class=\"line\">116</span><br><span class=\"line\">117</span><br><span class=\"line\">118</span><br><span class=\"line\">119</span><br><span class=\"line\">120</span><br><span class=\"line\">121</span><br><span class=\"line\">122</span><br><span class=\"line\">123</span><br><span class=\"line\">124</span><br><span class=\"line\">125</span><br><span class=\"line\">126</span><br><span class=\"line\">127</span><br><span class=\"line\">128</span><br><span class=\"line\">129</span><br><span class=\"line\">130</span><br><span class=\"line\">131</span><br><span class=\"line\">132</span><br><span class=\"line\">133</span><br><span class=\"line\">134</span><br><span class=\"line\">135</span><br><span class=\"line\">136</span><br><span class=\"line\">137</span><br><span class=\"line\">138</span><br><span class=\"line\">139</span><br><span class=\"line\">140</span><br><span class=\"line\">141</span><br><span class=\"line\">142</span><br><span class=\"line\">143</span><br><span class=\"line\">144</span><br><span class=\"line\">145</span><br><span class=\"line\">146</span><br><span class=\"line\">147</span><br><span class=\"line\">148</span><br><span class=\"line\">149</span><br><span class=\"line\">150</span><br><span class=\"line\">151</span><br><span class=\"line\">152</span><br><span class=\"line\">153</span><br><span class=\"line\">154</span><br><span class=\"line\">155</span><br><span class=\"line\">156</span><br><span class=\"line\">157</span><br><span class=\"line\">158</span><br><span class=\"line\">159</span><br><span class=\"line\">160</span><br><span class=\"line\">161</span><br><span class=\"line\">162</span><br><span class=\"line\">163</span><br><span class=\"line\">164</span><br><span class=\"line\">165</span><br><span class=\"line\">166</span><br><span class=\"line\">167</span><br><span class=\"line\">168</span><br><span class=\"line\">169</span><br><span class=\"line\">170</span><br><span class=\"line\">171</span><br><span class=\"line\">172</span><br><span class=\"line\">173</span><br><span class=\"line\">174</span><br><span class=\"line\">175</span><br><span class=\"line\">176</span><br><span class=\"line\">177</span><br><span class=\"line\">178</span><br><span class=\"line\">179</span><br><span class=\"line\">180</span><br><span class=\"line\">181</span><br><span class=\"line\">182</span><br><span class=\"line\">183</span><br><span class=\"line\">184</span><br><span class=\"line\">185</span><br><span class=\"line\">186</span><br><span class=\"line\">187</span><br><span class=\"line\">188</span><br><span class=\"line\">189</span><br><span class=\"line\">190</span><br><span class=\"line\">191</span><br><span class=\"line\">192</span><br><span class=\"line\">193</span><br><span class=\"line\">194</span><br><span class=\"line\">195</span><br><span class=\"line\">196</span><br><span class=\"line\">197</span><br><span class=\"line\">198</span><br><span class=\"line\">199</span><br><span class=\"line\">200</span><br><span class=\"line\">201</span><br><span class=\"line\">202</span><br><span class=\"line\">203</span><br><span class=\"line\">204</span><br><span class=\"line\">205</span><br><span class=\"line\">206</span><br><span class=\"line\">207</span><br><span class=\"line\">208</span><br><span class=\"line\">209</span><br><span class=\"line\">210</span><br><span class=\"line\">211</span><br><span class=\"line\">212</span><br><span class=\"line\">213</span><br><span class=\"line\">214</span><br><span class=\"line\">215</span><br><span class=\"line\">216</span><br><span class=\"line\">217</span><br><span class=\"line\">218</span><br><span class=\"line\">219</span><br><span class=\"line\">220</span><br><span class=\"line\">221</span><br><span class=\"line\">222</span><br><span class=\"line\">223</span><br><span class=\"line\">224</span><br><span class=\"line\">225</span><br><span class=\"line\">226</span><br><span class=\"line\">227</span><br><span class=\"line\">228</span><br><span class=\"line\">229</span><br><span class=\"line\">230</span><br><span class=\"line\">231</span><br><span class=\"line\">232</span><br><span class=\"line\">233</span><br><span class=\"line\">234</span><br><span class=\"line\">235</span><br><span class=\"line\">236</span><br><span class=\"line\">237</span><br><span class=\"line\">238</span><br><span class=\"line\">239</span><br><span class=\"line\">240</span><br><span class=\"line\">241</span><br><span class=\"line\">242</span><br><span class=\"line\">243</span><br><span class=\"line\">244</span><br><span class=\"line\">245</span><br><span class=\"line\">246</span><br><span class=\"line\">247</span><br><span class=\"line\">248</span><br><span class=\"line\">249</span><br><span class=\"line\">250</span><br><span class=\"line\">251</span><br><span class=\"line\">252</span><br><span class=\"line\">253</span><br><span class=\"line\">254</span><br><span class=\"line\">255</span><br><span class=\"line\">256</span><br><span class=\"line\">257</span><br><span class=\"line\">258</span><br><span class=\"line\">259</span><br><span class=\"line\">260</span><br><span class=\"line\">261</span><br><span class=\"line\">262</span><br><span class=\"line\">263</span><br><span class=\"line\">264</span><br><span class=\"line\">265</span><br><span class=\"line\">266</span><br><span class=\"line\">267</span><br><span class=\"line\">268</span><br><span class=\"line\">269</span><br><span class=\"line\">270</span><br><span class=\"line\">271</span><br><span class=\"line\">272</span><br><span class=\"line\">273</span><br><span class=\"line\">274</span><br><span class=\"line\">275</span><br><span class=\"line\">276</span><br><span class=\"line\">277</span><br><span class=\"line\">278</span><br><span class=\"line\">279</span><br><span class=\"line\">280</span><br><span class=\"line\">281</span><br><span class=\"line\">282</span><br><span class=\"line\">283</span><br><span class=\"line\">284</span><br><span class=\"line\">285</span><br><span class=\"line\">286</span><br><span class=\"line\">287</span><br><span class=\"line\">288</span><br><span class=\"line\">289</span><br><span class=\"line\">290</span><br><span class=\"line\">291</span><br><span class=\"line\">292</span><br><span class=\"line\">293</span><br><span class=\"line\">294</span><br><span class=\"line\">295</span><br><span class=\"line\">296</span><br><span class=\"line\">297</span><br><span class=\"line\">298</span><br><span class=\"line\">299</span><br><span class=\"line\">300</span><br><span class=\"line\">301</span><br><span class=\"line\">302</span><br><span class=\"line\">303</span><br><span class=\"line\">304</span><br><span class=\"line\">305</span><br><span class=\"line\">306</span><br><span class=\"line\">307</span><br><span class=\"line\">308</span><br><span class=\"line\">309</span><br><span class=\"line\">310</span><br><span class=\"line\">311</span><br><span class=\"line\">312</span><br><span class=\"line\">313</span><br><span class=\"line\">314</span><br><span class=\"line\">315</span><br><span class=\"line\">316</span><br><span class=\"line\">317</span><br><span class=\"line\">318</span><br><span class=\"line\">319</span><br><span class=\"line\">320</span><br><span class=\"line\">321</span><br><span class=\"line\">322</span><br><span class=\"line\">323</span><br><span class=\"line\">324</span><br><span class=\"line\">325</span><br><span class=\"line\">326</span><br><span class=\"line\">327</span><br><span class=\"line\">328</span><br><span class=\"line\">329</span><br><span class=\"line\">330</span><br><span class=\"line\">331</span><br><span class=\"line\">332</span><br><span class=\"line\">333</span><br><span class=\"line\">334</span><br><span class=\"line\">335</span><br><span class=\"line\">336</span><br><span class=\"line\">337</span><br><span class=\"line\">338</span><br><span class=\"line\">339</span><br><span class=\"line\">340</span><br><span class=\"line\">341</span><br><span class=\"line\">342</span><br><span class=\"line\">343</span><br><span class=\"line\">344</span><br><span class=\"line\">345</span><br><span class=\"line\">346</span><br><span class=\"line\">347</span><br><span class=\"line\">348</span><br><span class=\"line\">349</span><br><span class=\"line\">350</span><br><span class=\"line\">351</span><br><span class=\"line\">352</span><br><span class=\"line\">353</span><br><span class=\"line\">354</span><br><span class=\"line\">355</span><br><span class=\"line\">356</span><br><span class=\"line\">357</span><br><span class=\"line\">358</span><br><span class=\"line\">359</span><br><span class=\"line\">360</span><br><span class=\"line\">361</span><br><span class=\"line\">362</span><br><span class=\"line\">363</span><br><span class=\"line\">364</span><br><span class=\"line\">365</span><br><span class=\"line\">366</span><br><span class=\"line\">367</span><br><span class=\"line\">368</span><br><span class=\"line\">369</span><br><span class=\"line\">370</span><br><span class=\"line\">371</span><br><span class=\"line\">372</span><br><span class=\"line\">373</span><br><span class=\"line\">374</span><br><span class=\"line\">375</span><br><span class=\"line\">376</span><br><span class=\"line\">377</span><br><span class=\"line\">378</span><br><span class=\"line\">379</span><br><span class=\"line\">380</span><br><span class=\"line\">381</span><br><span class=\"line\">382</span><br><span class=\"line\">383</span><br><span class=\"line\">384</span><br><span class=\"line\">385</span><br><span class=\"line\">386</span><br><span class=\"line\">387</span><br><span class=\"line\">388</span><br><span class=\"line\">389</span><br><span class=\"line\">390</span><br><span class=\"line\">391</span><br><span class=\"line\">392</span><br><span class=\"line\">393</span><br><span class=\"line\">394</span><br><span class=\"line\">395</span><br><span class=\"line\">396</span><br><span class=\"line\">397</span><br><span class=\"line\">398</span><br><span class=\"line\">399</span><br><span class=\"line\">400</span><br><span class=\"line\">401</span><br><span class=\"line\">402</span><br><span class=\"line\">403</span><br><span class=\"line\">404</span><br><span class=\"line\">405</span><br><span class=\"line\">406</span><br><span class=\"line\">407</span><br><span class=\"line\">408</span><br><span class=\"line\">409</span><br><span class=\"line\">410</span><br><span class=\"line\">411</span><br><span class=\"line\">412</span><br><span class=\"line\">413</span><br><span class=\"line\">414</span><br><span class=\"line\">415</span><br><span class=\"line\">416</span><br><span class=\"line\">417</span><br><span class=\"line\">418</span><br><span class=\"line\">419</span><br><span class=\"line\">420</span><br><span class=\"line\">421</span><br><span class=\"line\">422</span><br><span class=\"line\">423</span><br><span class=\"line\">424</span><br><span class=\"line\">425</span><br><span class=\"line\">426</span><br><span class=\"line\">427</span><br><span class=\"line\">428</span><br><span class=\"line\">429</span><br><span class=\"line\">430</span><br><span class=\"line\">431</span><br><span class=\"line\">432</span><br><span class=\"line\">433</span><br><span class=\"line\">434</span><br><span class=\"line\">435</span><br><span class=\"line\">436</span><br><span class=\"line\">437</span><br><span class=\"line\">438</span><br><span class=\"line\">439</span><br><span class=\"line\">440</span><br><span class=\"line\">441</span><br><span class=\"line\">442</span><br><span class=\"line\">443</span><br><span class=\"line\">444</span><br><span class=\"line\">445</span><br><span class=\"line\">446</span><br><span class=\"line\">447</span><br><span class=\"line\">448</span><br><span class=\"line\">449</span><br><span class=\"line\">450</span><br><span class=\"line\">451</span><br><span class=\"line\">452</span><br><span class=\"line\">453</span><br><span class=\"line\">454</span><br><span class=\"line\">455</span><br><span class=\"line\">456</span><br><span class=\"line\">457</span><br><span class=\"line\">458</span><br><span class=\"line\">459</span><br><span class=\"line\">460</span><br><span class=\"line\">461</span><br><span class=\"line\">462</span><br><span class=\"line\">463</span><br><span class=\"line\">464</span><br><span class=\"line\">465</span><br><span class=\"line\">466</span><br><span class=\"line\">467</span><br><span class=\"line\">468</span><br><span class=\"line\">469</span><br><span class=\"line\">470</span><br><span class=\"line\">471</span><br><span class=\"line\">472</span><br><span class=\"line\">473</span><br><span class=\"line\">474</span><br><span class=\"line\">475</span><br><span class=\"line\">476</span><br><span class=\"line\">477</span><br><span class=\"line\">478</span><br><span class=\"line\">479</span><br><span class=\"line\">480</span><br><span class=\"line\">481</span><br><span class=\"line\">482</span><br><span class=\"line\">483</span><br><span class=\"line\">484</span><br><span class=\"line\">485</span><br><span class=\"line\">486</span><br><span class=\"line\">487</span><br><span class=\"line\">488</span><br><span class=\"line\">489</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">from</span> __future__ <span class=\"keyword\">import</span> absolute_import</span><br><span class=\"line\"><span class=\"keyword\">from</span> __future__ <span class=\"keyword\">import</span> division</span><br><span class=\"line\"><span class=\"keyword\">from</span> __future__ <span class=\"keyword\">import</span> print_function</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">import</span> os</span><br><span class=\"line\"><span class=\"keyword\">import</span> logging</span><br><span class=\"line\"><span class=\"keyword\">from</span> math <span class=\"keyword\">import</span> ceil</span><br><span class=\"line\"><span class=\"keyword\">import</span> sys</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">import</span> numpy <span class=\"keyword\">as</span> np</span><br><span class=\"line\"><span class=\"keyword\">import</span> tensorflow <span class=\"keyword\">as</span> tf</span><br><span class=\"line\"></span><br><span class=\"line\">VGG_MEAN = [<span class=\"number\">103.939</span>, <span class=\"number\">116.779</span>, <span class=\"number\">123.68</span>]</span><br><span class=\"line\"></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">class</span> <span class=\"title class_\">FCN8VGG</span>:</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">def</span> <span class=\"title function_\">__init__</span>(<span class=\"params\">self, vgg16_npy_path=<span class=\"literal\">None</span></span>):</span><br><span class=\"line\">        <span class=\"keyword\">if</span> vgg16_npy_path <span class=\"keyword\">is</span> <span class=\"literal\">None</span>:</span><br><span class=\"line\">            path = sys.modules[<span class=\"variable language_\">self</span>.__class__.__module__].__file__</span><br><span class=\"line\">            <span class=\"comment\"># print path</span></span><br><span class=\"line\">            path = os.path.abspath(os.path.join(path, os.pardir))</span><br><span class=\"line\">            <span class=\"comment\"># print path</span></span><br><span class=\"line\">            path = os.path.join(path, <span class=\"string\">&quot;vgg16.npy&quot;</span>)</span><br><span class=\"line\">            vgg16_npy_path = path</span><br><span class=\"line\">            logging.info(<span class=\"string\">&quot;Load npy file from &#x27;%s&#x27;.&quot;</span>, vgg16_npy_path)</span><br><span class=\"line\">        <span class=\"keyword\">if</span> <span class=\"keyword\">not</span> os.path.isfile(vgg16_npy_path):</span><br><span class=\"line\">            logging.error((<span class=\"string\">&quot;File &#x27;%s&#x27; not found. Download it from &quot;</span></span><br><span class=\"line\">                           <span class=\"string\">&quot;ftp://mi.eng.cam.ac.uk/pub/mttt2/&quot;</span></span><br><span class=\"line\">                           <span class=\"string\">&quot;models/vgg16.npy&quot;</span>), vgg16_npy_path)</span><br><span class=\"line\">            sys.exit(<span class=\"number\">1</span>)</span><br><span class=\"line\"></span><br><span class=\"line\">        <span class=\"variable language_\">self</span>.data_dict = np.load(vgg16_npy_path, encoding=<span class=\"string\">&#x27;latin1&#x27;</span>).item()</span><br><span class=\"line\">        <span class=\"variable language_\">self</span>.wd = <span class=\"number\">5e-4</span></span><br><span class=\"line\">        <span class=\"built_in\">print</span>(<span class=\"string\">&quot;npy file loaded&quot;</span>)</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">def</span> <span class=\"title function_\">build</span>(<span class=\"params\">self, rgb, train=<span class=\"literal\">False</span>, num_classes=<span class=\"number\">20</span>, random_init_fc8=<span class=\"literal\">False</span>,</span></span><br><span class=\"line\"><span class=\"params\">              debug=<span class=\"literal\">False</span>, use_dilated=<span class=\"literal\">False</span></span>):</span><br><span class=\"line\">        <span class=\"string\">&quot;&quot;&quot;</span></span><br><span class=\"line\"><span class=\"string\">        Build the VGG model using loaded weights</span></span><br><span class=\"line\"><span class=\"string\">        Parameters</span></span><br><span class=\"line\"><span class=\"string\">        ----------</span></span><br><span class=\"line\"><span class=\"string\">        rgb: image batch tensor</span></span><br><span class=\"line\"><span class=\"string\">            Image in rgb shap. Scaled to Intervall [0, 255]</span></span><br><span class=\"line\"><span class=\"string\">        train: bool</span></span><br><span class=\"line\"><span class=\"string\">            Whether to build train or inference graph</span></span><br><span class=\"line\"><span class=\"string\">        num_classes: int</span></span><br><span class=\"line\"><span class=\"string\">            How many classes should be predicted (by fc8)</span></span><br><span class=\"line\"><span class=\"string\">        random_init_fc8 : bool</span></span><br><span class=\"line\"><span class=\"string\">            Whether to initialize fc8 layer randomly.</span></span><br><span class=\"line\"><span class=\"string\">            Finetuning is required in this case.</span></span><br><span class=\"line\"><span class=\"string\">        debug: bool</span></span><br><span class=\"line\"><span class=\"string\">            Whether to print additional Debug Information.</span></span><br><span class=\"line\"><span class=\"string\">        &quot;&quot;&quot;</span></span><br><span class=\"line\">        <span class=\"comment\"># Convert RGB to BGR</span></span><br><span class=\"line\"></span><br><span class=\"line\">        <span class=\"keyword\">with</span> tf.name_scope(<span class=\"string\">&#x27;Processing&#x27;</span>):</span><br><span class=\"line\"></span><br><span class=\"line\">            red, green, blue = tf.split(rgb, <span class=\"number\">3</span>, <span class=\"number\">3</span>)</span><br><span class=\"line\">            <span class=\"comment\"># assert red.get_shape().as_list()[1:] == [224, 224, 1]</span></span><br><span class=\"line\">            <span class=\"comment\"># assert green.get_shape().as_list()[1:] == [224, 224, 1]</span></span><br><span class=\"line\">            <span class=\"comment\"># assert blue.get_shape().as_list()[1:] == [224, 224, 1]</span></span><br><span class=\"line\">            bgr = tf.concat([</span><br><span class=\"line\">                blue - VGG_MEAN[<span class=\"number\">0</span>],</span><br><span class=\"line\">                green - VGG_MEAN[<span class=\"number\">1</span>],</span><br><span class=\"line\">                red - VGG_MEAN[<span class=\"number\">2</span>],</span><br><span class=\"line\">            ], <span class=\"number\">3</span>)</span><br><span class=\"line\"></span><br><span class=\"line\">            <span class=\"keyword\">if</span> debug:</span><br><span class=\"line\">                bgr = tf.Print(bgr, [tf.shape(bgr)],</span><br><span class=\"line\">                               message=<span class=\"string\">&#x27;Shape of input image: &#x27;</span>,</span><br><span class=\"line\">                               summarize=<span class=\"number\">4</span>, first_n=<span class=\"number\">1</span>)</span><br><span class=\"line\"></span><br><span class=\"line\">        <span class=\"variable language_\">self</span>.conv1_1 = <span class=\"variable language_\">self</span>._conv_layer(bgr, <span class=\"string\">&quot;conv1_1&quot;</span>)</span><br><span class=\"line\">        <span class=\"variable language_\">self</span>.conv1_2 = <span class=\"variable language_\">self</span>._conv_layer(<span class=\"variable language_\">self</span>.conv1_1, <span class=\"string\">&quot;conv1_2&quot;</span>)</span><br><span class=\"line\">        <span class=\"variable language_\">self</span>.pool1 = <span class=\"variable language_\">self</span>._max_pool(<span class=\"variable language_\">self</span>.conv1_2, <span class=\"string\">&#x27;pool1&#x27;</span>, debug)</span><br><span class=\"line\"></span><br><span class=\"line\">        <span class=\"variable language_\">self</span>.conv2_1 = <span class=\"variable language_\">self</span>._conv_layer(<span class=\"variable language_\">self</span>.pool1, <span class=\"string\">&quot;conv2_1&quot;</span>)</span><br><span class=\"line\">        <span class=\"variable language_\">self</span>.conv2_2 = <span class=\"variable language_\">self</span>._conv_layer(<span class=\"variable language_\">self</span>.conv2_1, <span class=\"string\">&quot;conv2_2&quot;</span>)</span><br><span class=\"line\">        <span class=\"variable language_\">self</span>.pool2 = <span class=\"variable language_\">self</span>._max_pool(<span class=\"variable language_\">self</span>.conv2_2, <span class=\"string\">&#x27;pool2&#x27;</span>, debug)</span><br><span class=\"line\"></span><br><span class=\"line\">        <span class=\"variable language_\">self</span>.conv3_1 = <span class=\"variable language_\">self</span>._conv_layer(<span class=\"variable language_\">self</span>.pool2, <span class=\"string\">&quot;conv3_1&quot;</span>)</span><br><span class=\"line\">        <span class=\"variable language_\">self</span>.conv3_2 = <span class=\"variable language_\">self</span>._conv_layer(<span class=\"variable language_\">self</span>.conv3_1, <span class=\"string\">&quot;conv3_2&quot;</span>)</span><br><span class=\"line\">        <span class=\"variable language_\">self</span>.conv3_3 = <span class=\"variable language_\">self</span>._conv_layer(<span class=\"variable language_\">self</span>.conv3_2, <span class=\"string\">&quot;conv3_3&quot;</span>)</span><br><span class=\"line\">        <span class=\"variable language_\">self</span>.pool3 = <span class=\"variable language_\">self</span>._max_pool(<span class=\"variable language_\">self</span>.conv3_3, <span class=\"string\">&#x27;pool3&#x27;</span>, debug)</span><br><span class=\"line\"></span><br><span class=\"line\">        <span class=\"variable language_\">self</span>.conv4_1 = <span class=\"variable language_\">self</span>._conv_layer(<span class=\"variable language_\">self</span>.pool3, <span class=\"string\">&quot;conv4_1&quot;</span>)</span><br><span class=\"line\">        <span class=\"variable language_\">self</span>.conv4_2 = <span class=\"variable language_\">self</span>._conv_layer(<span class=\"variable language_\">self</span>.conv4_1, <span class=\"string\">&quot;conv4_2&quot;</span>)</span><br><span class=\"line\">        <span class=\"variable language_\">self</span>.conv4_3 = <span class=\"variable language_\">self</span>._conv_layer(<span class=\"variable language_\">self</span>.conv4_2, <span class=\"string\">&quot;conv4_3&quot;</span>)</span><br><span class=\"line\"></span><br><span class=\"line\">        <span class=\"keyword\">if</span> use_dilated:</span><br><span class=\"line\">            pad = [[<span class=\"number\">0</span>, <span class=\"number\">0</span>], [<span class=\"number\">0</span>, <span class=\"number\">0</span>]]</span><br><span class=\"line\">            <span class=\"variable language_\">self</span>.pool4 = tf.nn.max_pool(<span class=\"variable language_\">self</span>.conv4_3, ksize=[<span class=\"number\">1</span>, <span class=\"number\">2</span>, <span class=\"number\">2</span>, <span class=\"number\">1</span>],</span><br><span class=\"line\">                                        strides=[<span class=\"number\">1</span>, <span class=\"number\">1</span>, <span class=\"number\">1</span>, <span class=\"number\">1</span>],</span><br><span class=\"line\">                                        padding=<span class=\"string\">&#x27;SAME&#x27;</span>, name=<span class=\"string\">&#x27;pool4&#x27;</span>)</span><br><span class=\"line\">            <span class=\"variable language_\">self</span>.pool4 = tf.space_to_batch(<span class=\"variable language_\">self</span>.pool4,</span><br><span class=\"line\">                                           paddings=pad, block_size=<span class=\"number\">2</span>)</span><br><span class=\"line\">        <span class=\"keyword\">else</span>:</span><br><span class=\"line\">            <span class=\"variable language_\">self</span>.pool4 = <span class=\"variable language_\">self</span>._max_pool(<span class=\"variable language_\">self</span>.conv4_3, <span class=\"string\">&#x27;pool4&#x27;</span>, debug)</span><br><span class=\"line\"></span><br><span class=\"line\">        <span class=\"variable language_\">self</span>.conv5_1 = <span class=\"variable language_\">self</span>._conv_layer(<span class=\"variable language_\">self</span>.pool4, <span class=\"string\">&quot;conv5_1&quot;</span>)</span><br><span class=\"line\">        <span class=\"variable language_\">self</span>.conv5_2 = <span class=\"variable language_\">self</span>._conv_layer(<span class=\"variable language_\">self</span>.conv5_1, <span class=\"string\">&quot;conv5_2&quot;</span>)</span><br><span class=\"line\">        <span class=\"variable language_\">self</span>.conv5_3 = <span class=\"variable language_\">self</span>._conv_layer(<span class=\"variable language_\">self</span>.conv5_2, <span class=\"string\">&quot;conv5_3&quot;</span>)</span><br><span class=\"line\">        <span class=\"keyword\">if</span> use_dilated:</span><br><span class=\"line\">            pad = [[<span class=\"number\">0</span>, <span class=\"number\">0</span>], [<span class=\"number\">0</span>, <span class=\"number\">0</span>]]</span><br><span class=\"line\">            <span class=\"variable language_\">self</span>.pool5 = tf.nn.max_pool(<span class=\"variable language_\">self</span>.conv5_3, ksize=[<span class=\"number\">1</span>, <span class=\"number\">2</span>, <span class=\"number\">2</span>, <span class=\"number\">1</span>],</span><br><span class=\"line\">                                        strides=[<span class=\"number\">1</span>, <span class=\"number\">1</span>, <span class=\"number\">1</span>, <span class=\"number\">1</span>],</span><br><span class=\"line\">                                        padding=<span class=\"string\">&#x27;SAME&#x27;</span>, name=<span class=\"string\">&#x27;pool5&#x27;</span>)</span><br><span class=\"line\">            <span class=\"variable language_\">self</span>.pool5 = tf.space_to_batch(<span class=\"variable language_\">self</span>.pool5,</span><br><span class=\"line\">                                           paddings=pad, block_size=<span class=\"number\">2</span>)</span><br><span class=\"line\">        <span class=\"keyword\">else</span>:</span><br><span class=\"line\">            <span class=\"variable language_\">self</span>.pool5 = <span class=\"variable language_\">self</span>._max_pool(<span class=\"variable language_\">self</span>.conv5_3, <span class=\"string\">&#x27;pool5&#x27;</span>, debug)</span><br><span class=\"line\"></span><br><span class=\"line\">        <span class=\"variable language_\">self</span>.fc6 = <span class=\"variable language_\">self</span>._fc_layer(<span class=\"variable language_\">self</span>.pool5, <span class=\"string\">&quot;fc6&quot;</span>)</span><br><span class=\"line\"></span><br><span class=\"line\">        <span class=\"keyword\">if</span> train:</span><br><span class=\"line\">            <span class=\"variable language_\">self</span>.fc6 = tf.nn.dropout(<span class=\"variable language_\">self</span>.fc6, <span class=\"number\">0.5</span>)</span><br><span class=\"line\"></span><br><span class=\"line\">        <span class=\"variable language_\">self</span>.fc7 = <span class=\"variable language_\">self</span>._fc_layer(<span class=\"variable language_\">self</span>.fc6, <span class=\"string\">&quot;fc7&quot;</span>)</span><br><span class=\"line\">        <span class=\"keyword\">if</span> train:</span><br><span class=\"line\">            <span class=\"variable language_\">self</span>.fc7 = tf.nn.dropout(<span class=\"variable language_\">self</span>.fc7, <span class=\"number\">0.5</span>)</span><br><span class=\"line\"></span><br><span class=\"line\">        <span class=\"keyword\">if</span> use_dilated:</span><br><span class=\"line\">            <span class=\"variable language_\">self</span>.pool5 = tf.batch_to_space(<span class=\"variable language_\">self</span>.pool5, crops=pad, block_size=<span class=\"number\">2</span>)</span><br><span class=\"line\">            <span class=\"variable language_\">self</span>.pool5 = tf.batch_to_space(<span class=\"variable language_\">self</span>.pool5, crops=pad, block_size=<span class=\"number\">2</span>)</span><br><span class=\"line\">            <span class=\"variable language_\">self</span>.fc7 = tf.batch_to_space(<span class=\"variable language_\">self</span>.fc7, crops=pad, block_size=<span class=\"number\">2</span>)</span><br><span class=\"line\">            <span class=\"variable language_\">self</span>.fc7 = tf.batch_to_space(<span class=\"variable language_\">self</span>.fc7, crops=pad, block_size=<span class=\"number\">2</span>)</span><br><span class=\"line\">            <span class=\"keyword\">return</span></span><br><span class=\"line\"></span><br><span class=\"line\">        <span class=\"keyword\">if</span> random_init_fc8:</span><br><span class=\"line\">            <span class=\"variable language_\">self</span>.score_fr = <span class=\"variable language_\">self</span>._score_layer(<span class=\"variable language_\">self</span>.fc7, <span class=\"string\">&quot;score_fr&quot;</span>,</span><br><span class=\"line\">                                              num_classes)</span><br><span class=\"line\">        <span class=\"keyword\">else</span>:</span><br><span class=\"line\">            <span class=\"variable language_\">self</span>.score_fr = <span class=\"variable language_\">self</span>._fc_layer(<span class=\"variable language_\">self</span>.fc7, <span class=\"string\">&quot;score_fr&quot;</span>,</span><br><span class=\"line\">                                           num_classes=num_classes,</span><br><span class=\"line\">                                           relu=<span class=\"literal\">False</span>)</span><br><span class=\"line\"></span><br><span class=\"line\">        <span class=\"variable language_\">self</span>.pred = tf.argmax(<span class=\"variable language_\">self</span>.score_fr, dimension=<span class=\"number\">3</span>)</span><br><span class=\"line\"></span><br><span class=\"line\">        <span class=\"variable language_\">self</span>.upscore2 = <span class=\"variable language_\">self</span>._upscore_layer(<span class=\"variable language_\">self</span>.score_fr,</span><br><span class=\"line\">                                            shape=tf.shape(<span class=\"variable language_\">self</span>.pool4),</span><br><span class=\"line\">                                            num_classes=num_classes,</span><br><span class=\"line\">                                            debug=debug, name=<span class=\"string\">&#x27;upscore2&#x27;</span>,</span><br><span class=\"line\">                                            ksize=<span class=\"number\">4</span>, stride=<span class=\"number\">2</span>)</span><br><span class=\"line\">        <span class=\"variable language_\">self</span>.score_pool4 = <span class=\"variable language_\">self</span>._score_layer(<span class=\"variable language_\">self</span>.pool4, <span class=\"string\">&quot;score_pool4&quot;</span>,</span><br><span class=\"line\">                                             num_classes=num_classes)</span><br><span class=\"line\">        <span class=\"variable language_\">self</span>.fuse_pool4 = tf.add(<span class=\"variable language_\">self</span>.upscore2, <span class=\"variable language_\">self</span>.score_pool4)</span><br><span class=\"line\"></span><br><span class=\"line\">        <span class=\"variable language_\">self</span>.upscore4 = <span class=\"variable language_\">self</span>._upscore_layer(<span class=\"variable language_\">self</span>.fuse_pool4,</span><br><span class=\"line\">                                            shape=tf.shape(<span class=\"variable language_\">self</span>.pool3),</span><br><span class=\"line\">                                            num_classes=num_classes,</span><br><span class=\"line\">                                            debug=debug, name=<span class=\"string\">&#x27;upscore4&#x27;</span>,</span><br><span class=\"line\">                                            ksize=<span class=\"number\">4</span>, stride=<span class=\"number\">2</span>)</span><br><span class=\"line\">        <span class=\"variable language_\">self</span>.score_pool3 = <span class=\"variable language_\">self</span>._score_layer(<span class=\"variable language_\">self</span>.pool3, <span class=\"string\">&quot;score_pool3&quot;</span>,</span><br><span class=\"line\">                                             num_classes=num_classes)</span><br><span class=\"line\">        <span class=\"variable language_\">self</span>.fuse_pool3 = tf.add(<span class=\"variable language_\">self</span>.upscore4, <span class=\"variable language_\">self</span>.score_pool3)</span><br><span class=\"line\"></span><br><span class=\"line\">        <span class=\"variable language_\">self</span>.upscore32 = <span class=\"variable language_\">self</span>._upscore_layer(<span class=\"variable language_\">self</span>.fuse_pool3,</span><br><span class=\"line\">                                             shape=tf.shape(bgr),</span><br><span class=\"line\">                                             num_classes=num_classes,</span><br><span class=\"line\">                                             debug=debug, name=<span class=\"string\">&#x27;upscore32&#x27;</span>,</span><br><span class=\"line\">                                             ksize=<span class=\"number\">16</span>, stride=<span class=\"number\">8</span>)</span><br><span class=\"line\"></span><br><span class=\"line\">        <span class=\"variable language_\">self</span>.pred_up = tf.argmax(<span class=\"variable language_\">self</span>.upscore32, dimension=<span class=\"number\">3</span>)</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">def</span> <span class=\"title function_\">_max_pool</span>(<span class=\"params\">self, bottom, name, debug</span>):</span><br><span class=\"line\">        pool = tf.nn.max_pool(bottom, ksize=[<span class=\"number\">1</span>, <span class=\"number\">2</span>, <span class=\"number\">2</span>, <span class=\"number\">1</span>], strides=[<span class=\"number\">1</span>, <span class=\"number\">2</span>, <span class=\"number\">2</span>, <span class=\"number\">1</span>],</span><br><span class=\"line\">                              padding=<span class=\"string\">&#x27;SAME&#x27;</span>, name=name)</span><br><span class=\"line\"></span><br><span class=\"line\">        <span class=\"keyword\">if</span> debug:</span><br><span class=\"line\">            pool = tf.Print(pool, [tf.shape(pool)],</span><br><span class=\"line\">                            message=<span class=\"string\">&#x27;Shape of %s&#x27;</span> % name,</span><br><span class=\"line\">                            summarize=<span class=\"number\">4</span>, first_n=<span class=\"number\">1</span>)</span><br><span class=\"line\">        <span class=\"keyword\">return</span> pool</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">def</span> <span class=\"title function_\">_conv_layer</span>(<span class=\"params\">self, bottom, name</span>):</span><br><span class=\"line\">        <span class=\"keyword\">with</span> tf.variable_scope(name) <span class=\"keyword\">as</span> scope:</span><br><span class=\"line\">            filt = <span class=\"variable language_\">self</span>.get_conv_filter(name)</span><br><span class=\"line\">            conv = tf.nn.conv2d(bottom, filt, [<span class=\"number\">1</span>, <span class=\"number\">1</span>, <span class=\"number\">1</span>, <span class=\"number\">1</span>], padding=<span class=\"string\">&#x27;SAME&#x27;</span>)</span><br><span class=\"line\"></span><br><span class=\"line\">            conv_biases = <span class=\"variable language_\">self</span>.get_bias(name)</span><br><span class=\"line\">            bias = tf.nn.bias_add(conv, conv_biases)</span><br><span class=\"line\"></span><br><span class=\"line\">            relu = tf.nn.relu(bias)</span><br><span class=\"line\">            <span class=\"comment\"># Add summary to Tensorboard</span></span><br><span class=\"line\">            _activation_summary(relu)</span><br><span class=\"line\">            <span class=\"keyword\">return</span> relu</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">def</span> <span class=\"title function_\">_fc_layer</span>(<span class=\"params\">self, bottom, name, num_classes=<span class=\"literal\">None</span>,</span></span><br><span class=\"line\"><span class=\"params\">                  relu=<span class=\"literal\">True</span>, debug=<span class=\"literal\">False</span></span>):</span><br><span class=\"line\">        <span class=\"keyword\">with</span> tf.variable_scope(name) <span class=\"keyword\">as</span> scope:</span><br><span class=\"line\">            shape = bottom.get_shape().as_list()</span><br><span class=\"line\"></span><br><span class=\"line\">            <span class=\"keyword\">if</span> name == <span class=\"string\">&#x27;fc6&#x27;</span>:</span><br><span class=\"line\">                filt = <span class=\"variable language_\">self</span>.get_fc_weight_reshape(name, [<span class=\"number\">7</span>, <span class=\"number\">7</span>, <span class=\"number\">512</span>, <span class=\"number\">4096</span>])</span><br><span class=\"line\">            <span class=\"keyword\">elif</span> name == <span class=\"string\">&#x27;score_fr&#x27;</span>:</span><br><span class=\"line\">                name = <span class=\"string\">&#x27;fc8&#x27;</span>  <span class=\"comment\"># Name of score_fr layer in VGG Model</span></span><br><span class=\"line\">                filt = <span class=\"variable language_\">self</span>.get_fc_weight_reshape(name, [<span class=\"number\">1</span>, <span class=\"number\">1</span>, <span class=\"number\">4096</span>, <span class=\"number\">1000</span>],</span><br><span class=\"line\">                                                  num_classes=num_classes)</span><br><span class=\"line\">            <span class=\"keyword\">else</span>:</span><br><span class=\"line\">                filt = <span class=\"variable language_\">self</span>.get_fc_weight_reshape(name, [<span class=\"number\">1</span>, <span class=\"number\">1</span>, <span class=\"number\">4096</span>, <span class=\"number\">4096</span>])</span><br><span class=\"line\"></span><br><span class=\"line\">            <span class=\"variable language_\">self</span>._add_wd_and_summary(filt, <span class=\"variable language_\">self</span>.wd, <span class=\"string\">&quot;fc_wlosses&quot;</span>)</span><br><span class=\"line\"></span><br><span class=\"line\">            conv = tf.nn.conv2d(bottom, filt, [<span class=\"number\">1</span>, <span class=\"number\">1</span>, <span class=\"number\">1</span>, <span class=\"number\">1</span>], padding=<span class=\"string\">&#x27;SAME&#x27;</span>)</span><br><span class=\"line\">            conv_biases = <span class=\"variable language_\">self</span>.get_bias(name, num_classes=num_classes)</span><br><span class=\"line\">            bias = tf.nn.bias_add(conv, conv_biases)</span><br><span class=\"line\"></span><br><span class=\"line\">            <span class=\"keyword\">if</span> relu:</span><br><span class=\"line\">                bias = tf.nn.relu(bias)</span><br><span class=\"line\">            _activation_summary(bias)</span><br><span class=\"line\"></span><br><span class=\"line\">            <span class=\"keyword\">if</span> debug:</span><br><span class=\"line\">                bias = tf.Print(bias, [tf.shape(bias)],</span><br><span class=\"line\">                                message=<span class=\"string\">&#x27;Shape of %s&#x27;</span> % name,</span><br><span class=\"line\">                                summarize=<span class=\"number\">4</span>, first_n=<span class=\"number\">1</span>)</span><br><span class=\"line\">            <span class=\"keyword\">return</span> bias</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">def</span> <span class=\"title function_\">_score_layer</span>(<span class=\"params\">self, bottom, name, num_classes</span>):</span><br><span class=\"line\">        <span class=\"keyword\">with</span> tf.variable_scope(name) <span class=\"keyword\">as</span> scope:</span><br><span class=\"line\">            <span class=\"comment\"># get number of input channels</span></span><br><span class=\"line\">            in_features = bottom.get_shape()[<span class=\"number\">3</span>].value</span><br><span class=\"line\">            shape = [<span class=\"number\">1</span>, <span class=\"number\">1</span>, in_features, num_classes]</span><br><span class=\"line\">            <span class=\"comment\"># He initialization Sheme</span></span><br><span class=\"line\">            <span class=\"keyword\">if</span> name == <span class=\"string\">&quot;score_fr&quot;</span>:</span><br><span class=\"line\">                num_input = in_features</span><br><span class=\"line\">                stddev = (<span class=\"number\">2</span> / num_input)**<span class=\"number\">0.5</span></span><br><span class=\"line\">            <span class=\"keyword\">elif</span> name == <span class=\"string\">&quot;score_pool4&quot;</span>:</span><br><span class=\"line\">                stddev = <span class=\"number\">0.001</span></span><br><span class=\"line\">            <span class=\"keyword\">elif</span> name == <span class=\"string\">&quot;score_pool3&quot;</span>:</span><br><span class=\"line\">                stddev = <span class=\"number\">0.0001</span></span><br><span class=\"line\">            <span class=\"comment\"># Apply convolution</span></span><br><span class=\"line\">            w_decay = <span class=\"variable language_\">self</span>.wd</span><br><span class=\"line\"></span><br><span class=\"line\">            weights = <span class=\"variable language_\">self</span>._variable_with_weight_decay(shape, stddev, w_decay,</span><br><span class=\"line\">                                                       decoder=<span class=\"literal\">True</span>)</span><br><span class=\"line\">            conv = tf.nn.conv2d(bottom, weights, [<span class=\"number\">1</span>, <span class=\"number\">1</span>, <span class=\"number\">1</span>, <span class=\"number\">1</span>], padding=<span class=\"string\">&#x27;SAME&#x27;</span>)</span><br><span class=\"line\">            <span class=\"comment\"># Apply bias</span></span><br><span class=\"line\">            conv_biases = <span class=\"variable language_\">self</span>._bias_variable([num_classes], constant=<span class=\"number\">0.0</span>)</span><br><span class=\"line\">            bias = tf.nn.bias_add(conv, conv_biases)</span><br><span class=\"line\"></span><br><span class=\"line\">            _activation_summary(bias)</span><br><span class=\"line\"></span><br><span class=\"line\">            <span class=\"keyword\">return</span> bias</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">def</span> <span class=\"title function_\">_upscore_layer</span>(<span class=\"params\">self, bottom, shape,</span></span><br><span class=\"line\"><span class=\"params\">                       num_classes, name, debug,</span></span><br><span class=\"line\"><span class=\"params\">                       ksize=<span class=\"number\">4</span>, stride=<span class=\"number\">2</span></span>):</span><br><span class=\"line\">        strides = [<span class=\"number\">1</span>, stride, stride, <span class=\"number\">1</span>]</span><br><span class=\"line\">        <span class=\"keyword\">with</span> tf.variable_scope(name):</span><br><span class=\"line\">            in_features = bottom.get_shape()[<span class=\"number\">3</span>].value</span><br><span class=\"line\"></span><br><span class=\"line\">            <span class=\"keyword\">if</span> shape <span class=\"keyword\">is</span> <span class=\"literal\">None</span>:</span><br><span class=\"line\">                <span class=\"comment\"># Compute shape out of Bottom</span></span><br><span class=\"line\">                in_shape = tf.shape(bottom)</span><br><span class=\"line\"></span><br><span class=\"line\">                h = ((in_shape[<span class=\"number\">1</span>] - <span class=\"number\">1</span>) * stride) + <span class=\"number\">1</span></span><br><span class=\"line\">                w = ((in_shape[<span class=\"number\">2</span>] - <span class=\"number\">1</span>) * stride) + <span class=\"number\">1</span></span><br><span class=\"line\">                new_shape = [in_shape[<span class=\"number\">0</span>], h, w, num_classes]</span><br><span class=\"line\">            <span class=\"keyword\">else</span>:</span><br><span class=\"line\">                new_shape = [shape[<span class=\"number\">0</span>], shape[<span class=\"number\">1</span>], shape[<span class=\"number\">2</span>], num_classes]</span><br><span class=\"line\">            output_shape = tf.stack(new_shape)</span><br><span class=\"line\"></span><br><span class=\"line\">            logging.debug(<span class=\"string\">&quot;Layer: %s, Fan-in: %d&quot;</span> % (name, in_features))</span><br><span class=\"line\">            f_shape = [ksize, ksize, num_classes, in_features]</span><br><span class=\"line\"></span><br><span class=\"line\">            <span class=\"comment\"># create</span></span><br><span class=\"line\">            num_input = ksize * ksize * in_features / stride</span><br><span class=\"line\">            stddev = (<span class=\"number\">2</span> / num_input)**<span class=\"number\">0.5</span></span><br><span class=\"line\"></span><br><span class=\"line\">            weights = <span class=\"variable language_\">self</span>.get_deconv_filter(f_shape)</span><br><span class=\"line\">            <span class=\"variable language_\">self</span>._add_wd_and_summary(weights, <span class=\"variable language_\">self</span>.wd, <span class=\"string\">&quot;fc_wlosses&quot;</span>)</span><br><span class=\"line\">            deconv = tf.nn.conv2d_transpose(bottom, weights, output_shape,</span><br><span class=\"line\">                                            strides=strides, padding=<span class=\"string\">&#x27;SAME&#x27;</span>)</span><br><span class=\"line\"></span><br><span class=\"line\">            <span class=\"keyword\">if</span> debug:</span><br><span class=\"line\">                deconv = tf.Print(deconv, [tf.shape(deconv)],</span><br><span class=\"line\">                                  message=<span class=\"string\">&#x27;Shape of %s&#x27;</span> % name,</span><br><span class=\"line\">                                  summarize=<span class=\"number\">4</span>, first_n=<span class=\"number\">1</span>)</span><br><span class=\"line\"></span><br><span class=\"line\">        _activation_summary(deconv)</span><br><span class=\"line\">        <span class=\"keyword\">return</span> deconv</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">def</span> <span class=\"title function_\">get_deconv_filter</span>(<span class=\"params\">self, f_shape</span>):</span><br><span class=\"line\">        width = f_shape[<span class=\"number\">0</span>]</span><br><span class=\"line\">        height = f_shape[<span class=\"number\">1</span>]</span><br><span class=\"line\">        f = ceil(width/<span class=\"number\">2.0</span>)</span><br><span class=\"line\">        c = (<span class=\"number\">2</span> * f - <span class=\"number\">1</span> - f % <span class=\"number\">2</span>) / (<span class=\"number\">2.0</span> * f)</span><br><span class=\"line\">        bilinear = np.zeros([f_shape[<span class=\"number\">0</span>], f_shape[<span class=\"number\">1</span>]])</span><br><span class=\"line\">        <span class=\"keyword\">for</span> x <span class=\"keyword\">in</span> <span class=\"built_in\">range</span>(width):</span><br><span class=\"line\">            <span class=\"keyword\">for</span> y <span class=\"keyword\">in</span> <span class=\"built_in\">range</span>(height):</span><br><span class=\"line\">                value = (<span class=\"number\">1</span> - <span class=\"built_in\">abs</span>(x / f - c)) * (<span class=\"number\">1</span> - <span class=\"built_in\">abs</span>(y / f - c))</span><br><span class=\"line\">                bilinear[x, y] = value</span><br><span class=\"line\">        weights = np.zeros(f_shape)</span><br><span class=\"line\">        <span class=\"keyword\">for</span> i <span class=\"keyword\">in</span> <span class=\"built_in\">range</span>(f_shape[<span class=\"number\">2</span>]):</span><br><span class=\"line\">            weights[:, :, i, i] = bilinear</span><br><span class=\"line\"></span><br><span class=\"line\">        init = tf.constant_initializer(value=weights,</span><br><span class=\"line\">                                       dtype=tf.float32)</span><br><span class=\"line\">        var = tf.get_variable(name=<span class=\"string\">&quot;up_filter&quot;</span>, initializer=init,</span><br><span class=\"line\">                              shape=weights.shape)</span><br><span class=\"line\">        <span class=\"keyword\">return</span> var</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">def</span> <span class=\"title function_\">get_conv_filter</span>(<span class=\"params\">self, name</span>):</span><br><span class=\"line\">        init = tf.constant_initializer(value=<span class=\"variable language_\">self</span>.data_dict[name][<span class=\"number\">0</span>],</span><br><span class=\"line\">                                       dtype=tf.float32)</span><br><span class=\"line\">        shape = <span class=\"variable language_\">self</span>.data_dict[name][<span class=\"number\">0</span>].shape</span><br><span class=\"line\">        <span class=\"built_in\">print</span>(<span class=\"string\">&#x27;Layer name: %s&#x27;</span> % name)</span><br><span class=\"line\">        <span class=\"built_in\">print</span>(<span class=\"string\">&#x27;Layer shape: %s&#x27;</span> % <span class=\"built_in\">str</span>(shape))</span><br><span class=\"line\">        var = tf.get_variable(name=<span class=\"string\">&quot;filter&quot;</span>, initializer=init, shape=shape)</span><br><span class=\"line\">        <span class=\"keyword\">if</span> <span class=\"keyword\">not</span> tf.get_variable_scope().reuse:</span><br><span class=\"line\">            weight_decay = tf.multiply(tf.nn.l2_loss(var), <span class=\"variable language_\">self</span>.wd,</span><br><span class=\"line\">                                       name=<span class=\"string\">&#x27;weight_loss&#x27;</span>)</span><br><span class=\"line\">            tf.add_to_collection(tf.GraphKeys.REGULARIZATION_LOSSES,</span><br><span class=\"line\">                                 weight_decay)</span><br><span class=\"line\">        _variable_summaries(var)</span><br><span class=\"line\">        <span class=\"keyword\">return</span> var</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">def</span> <span class=\"title function_\">get_bias</span>(<span class=\"params\">self, name, num_classes=<span class=\"literal\">None</span></span>):</span><br><span class=\"line\">        bias_wights = <span class=\"variable language_\">self</span>.data_dict[name][<span class=\"number\">1</span>]</span><br><span class=\"line\">        shape = <span class=\"variable language_\">self</span>.data_dict[name][<span class=\"number\">1</span>].shape</span><br><span class=\"line\">        <span class=\"keyword\">if</span> name == <span class=\"string\">&#x27;fc8&#x27;</span>:</span><br><span class=\"line\">            bias_wights = <span class=\"variable language_\">self</span>._bias_reshape(bias_wights, shape[<span class=\"number\">0</span>],</span><br><span class=\"line\">                                             num_classes)</span><br><span class=\"line\">            shape = [num_classes]</span><br><span class=\"line\">        init = tf.constant_initializer(value=bias_wights,</span><br><span class=\"line\">                                       dtype=tf.float32)</span><br><span class=\"line\">        var = tf.get_variable(name=<span class=\"string\">&quot;biases&quot;</span>, initializer=init, shape=shape)</span><br><span class=\"line\">        _variable_summaries(var)</span><br><span class=\"line\">        <span class=\"keyword\">return</span> var</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">def</span> <span class=\"title function_\">get_fc_weight</span>(<span class=\"params\">self, name</span>):</span><br><span class=\"line\">        init = tf.constant_initializer(value=<span class=\"variable language_\">self</span>.data_dict[name][<span class=\"number\">0</span>],</span><br><span class=\"line\">                                       dtype=tf.float32)</span><br><span class=\"line\">        shape = <span class=\"variable language_\">self</span>.data_dict[name][<span class=\"number\">0</span>].shape</span><br><span class=\"line\">        var = tf.get_variable(name=<span class=\"string\">&quot;weights&quot;</span>, initializer=init, shape=shape)</span><br><span class=\"line\">        <span class=\"keyword\">if</span> <span class=\"keyword\">not</span> tf.get_variable_scope().reuse:</span><br><span class=\"line\">            weight_decay = tf.multiply(tf.nn.l2_loss(var), <span class=\"variable language_\">self</span>.wd,</span><br><span class=\"line\">                                       name=<span class=\"string\">&#x27;weight_loss&#x27;</span>)</span><br><span class=\"line\">            tf.add_to_collection(tf.GraphKeys.REGULARIZATION_LOSSES,</span><br><span class=\"line\">                                 weight_decay)</span><br><span class=\"line\">        _variable_summaries(var)</span><br><span class=\"line\">        <span class=\"keyword\">return</span> var</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">def</span> <span class=\"title function_\">_bias_reshape</span>(<span class=\"params\">self, bweight, num_orig, num_new</span>):</span><br><span class=\"line\">        <span class=\"string\">&quot;&quot;&quot; Build bias weights for filter produces with `_summary_reshape`</span></span><br><span class=\"line\"><span class=\"string\"></span></span><br><span class=\"line\"><span class=\"string\">        &quot;&quot;&quot;</span></span><br><span class=\"line\">        n_averaged_elements = num_orig//num_new</span><br><span class=\"line\">        avg_bweight = np.zeros(num_new)</span><br><span class=\"line\">        <span class=\"keyword\">for</span> i <span class=\"keyword\">in</span> <span class=\"built_in\">range</span>(<span class=\"number\">0</span>, num_orig, n_averaged_elements):</span><br><span class=\"line\">            start_idx = i</span><br><span class=\"line\">            end_idx = start_idx + n_averaged_elements</span><br><span class=\"line\">            avg_idx = start_idx//n_averaged_elements</span><br><span class=\"line\">            <span class=\"keyword\">if</span> avg_idx == num_new:</span><br><span class=\"line\">                <span class=\"keyword\">break</span></span><br><span class=\"line\">            avg_bweight[avg_idx] = np.mean(bweight[start_idx:end_idx])</span><br><span class=\"line\">        <span class=\"keyword\">return</span> avg_bweight</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">def</span> <span class=\"title function_\">_summary_reshape</span>(<span class=\"params\">self, fweight, shape, num_new</span>):</span><br><span class=\"line\">        <span class=\"string\">&quot;&quot;&quot; Produce weights for a reduced fully-connected layer.</span></span><br><span class=\"line\"><span class=\"string\"></span></span><br><span class=\"line\"><span class=\"string\">        FC8 of VGG produces 1000 classes. Most semantic segmentation</span></span><br><span class=\"line\"><span class=\"string\">        task require much less classes. This reshapes the original weights</span></span><br><span class=\"line\"><span class=\"string\">        to be used in a fully-convolutional layer which produces num_new</span></span><br><span class=\"line\"><span class=\"string\">        classes. To archive this the average (mean) of n adjanced classes is</span></span><br><span class=\"line\"><span class=\"string\">        taken.</span></span><br><span class=\"line\"><span class=\"string\"></span></span><br><span class=\"line\"><span class=\"string\">        Consider reordering fweight, to perserve semantic meaning of the</span></span><br><span class=\"line\"><span class=\"string\">        weights.</span></span><br><span class=\"line\"><span class=\"string\"></span></span><br><span class=\"line\"><span class=\"string\">        Args:</span></span><br><span class=\"line\"><span class=\"string\">          fweight: original weights</span></span><br><span class=\"line\"><span class=\"string\">          shape: shape of the desired fully-convolutional layer</span></span><br><span class=\"line\"><span class=\"string\">          num_new: number of new classes</span></span><br><span class=\"line\"><span class=\"string\"></span></span><br><span class=\"line\"><span class=\"string\"></span></span><br><span class=\"line\"><span class=\"string\">        Returns:</span></span><br><span class=\"line\"><span class=\"string\">          Filter weights for `num_new` classes.</span></span><br><span class=\"line\"><span class=\"string\">        &quot;&quot;&quot;</span></span><br><span class=\"line\">        num_orig = shape[<span class=\"number\">3</span>]</span><br><span class=\"line\">        shape[<span class=\"number\">3</span>] = num_new</span><br><span class=\"line\">        <span class=\"keyword\">assert</span>(num_new &lt; num_orig)</span><br><span class=\"line\">        n_averaged_elements = num_orig//num_new</span><br><span class=\"line\">        avg_fweight = np.zeros(shape)</span><br><span class=\"line\">        <span class=\"keyword\">for</span> i <span class=\"keyword\">in</span> <span class=\"built_in\">range</span>(<span class=\"number\">0</span>, num_orig, n_averaged_elements):</span><br><span class=\"line\">            start_idx = i</span><br><span class=\"line\">            end_idx = start_idx + n_averaged_elements</span><br><span class=\"line\">            avg_idx = start_idx//n_averaged_elements</span><br><span class=\"line\">            <span class=\"keyword\">if</span> avg_idx == num_new:</span><br><span class=\"line\">                <span class=\"keyword\">break</span></span><br><span class=\"line\">            avg_fweight[:, :, :, avg_idx] = np.mean(</span><br><span class=\"line\">                fweight[:, :, :, start_idx:end_idx], axis=<span class=\"number\">3</span>)</span><br><span class=\"line\">        <span class=\"keyword\">return</span> avg_fweight</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">def</span> <span class=\"title function_\">_variable_with_weight_decay</span>(<span class=\"params\">self, shape, stddev, wd, decoder=<span class=\"literal\">False</span></span>):</span><br><span class=\"line\">        <span class=\"string\">&quot;&quot;&quot;Helper to create an initialized Variable with weight decay.</span></span><br><span class=\"line\"><span class=\"string\"></span></span><br><span class=\"line\"><span class=\"string\">        Note that the Variable is initialized with a truncated normal</span></span><br><span class=\"line\"><span class=\"string\">        distribution.</span></span><br><span class=\"line\"><span class=\"string\">        A weight decay is added only if one is specified.</span></span><br><span class=\"line\"><span class=\"string\"></span></span><br><span class=\"line\"><span class=\"string\">        Args:</span></span><br><span class=\"line\"><span class=\"string\">          name: name of the variable</span></span><br><span class=\"line\"><span class=\"string\">          shape: list of ints</span></span><br><span class=\"line\"><span class=\"string\">          stddev: standard deviation of a truncated Gaussian</span></span><br><span class=\"line\"><span class=\"string\">          wd: add L2Loss weight decay multiplied by this float. If None, weight</span></span><br><span class=\"line\"><span class=\"string\">              decay is not added for this Variable.</span></span><br><span class=\"line\"><span class=\"string\"></span></span><br><span class=\"line\"><span class=\"string\">        Returns:</span></span><br><span class=\"line\"><span class=\"string\">          Variable Tensor</span></span><br><span class=\"line\"><span class=\"string\">        &quot;&quot;&quot;</span></span><br><span class=\"line\"></span><br><span class=\"line\">        initializer = tf.truncated_normal_initializer(stddev=stddev)</span><br><span class=\"line\">        var = tf.get_variable(<span class=\"string\">&#x27;weights&#x27;</span>, shape=shape,</span><br><span class=\"line\">                              initializer=initializer)</span><br><span class=\"line\"></span><br><span class=\"line\">        collection_name = tf.GraphKeys.REGULARIZATION_LOSSES</span><br><span class=\"line\">        <span class=\"keyword\">if</span> wd <span class=\"keyword\">and</span> (<span class=\"keyword\">not</span> tf.get_variable_scope().reuse):</span><br><span class=\"line\">            weight_decay = tf.multiply(</span><br><span class=\"line\">                tf.nn.l2_loss(var), wd, name=<span class=\"string\">&#x27;weight_loss&#x27;</span>)</span><br><span class=\"line\">            tf.add_to_collection(collection_name, weight_decay)</span><br><span class=\"line\">        _variable_summaries(var)</span><br><span class=\"line\">        <span class=\"keyword\">return</span> var</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">def</span> <span class=\"title function_\">_add_wd_and_summary</span>(<span class=\"params\">self, var, wd, collection_name=<span class=\"literal\">None</span></span>):</span><br><span class=\"line\">        <span class=\"keyword\">if</span> collection_name <span class=\"keyword\">is</span> <span class=\"literal\">None</span>:</span><br><span class=\"line\">            collection_name = tf.GraphKeys.REGULARIZATION_LOSSES</span><br><span class=\"line\">        <span class=\"keyword\">if</span> wd <span class=\"keyword\">and</span> (<span class=\"keyword\">not</span> tf.get_variable_scope().reuse):</span><br><span class=\"line\">            weight_decay = tf.multiply(</span><br><span class=\"line\">                tf.nn.l2_loss(var), wd, name=<span class=\"string\">&#x27;weight_loss&#x27;</span>)</span><br><span class=\"line\">            tf.add_to_collection(collection_name, weight_decay)</span><br><span class=\"line\">        _variable_summaries(var)</span><br><span class=\"line\">        <span class=\"keyword\">return</span> var</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">def</span> <span class=\"title function_\">_bias_variable</span>(<span class=\"params\">self, shape, constant=<span class=\"number\">0.0</span></span>):</span><br><span class=\"line\">        initializer = tf.constant_initializer(constant)</span><br><span class=\"line\">        var = tf.get_variable(name=<span class=\"string\">&#x27;biases&#x27;</span>, shape=shape,</span><br><span class=\"line\">                              initializer=initializer)</span><br><span class=\"line\">        _variable_summaries(var)</span><br><span class=\"line\">        <span class=\"keyword\">return</span> var</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">def</span> <span class=\"title function_\">get_fc_weight_reshape</span>(<span class=\"params\">self, name, shape, num_classes=<span class=\"literal\">None</span></span>):</span><br><span class=\"line\">        <span class=\"built_in\">print</span>(<span class=\"string\">&#x27;Layer name: %s&#x27;</span> % name)</span><br><span class=\"line\">        <span class=\"built_in\">print</span>(<span class=\"string\">&#x27;Layer shape: %s&#x27;</span> % shape)</span><br><span class=\"line\">        weights = <span class=\"variable language_\">self</span>.data_dict[name][<span class=\"number\">0</span>]</span><br><span class=\"line\">        weights = weights.reshape(shape)</span><br><span class=\"line\">        <span class=\"keyword\">if</span> num_classes <span class=\"keyword\">is</span> <span class=\"keyword\">not</span> <span class=\"literal\">None</span>:</span><br><span class=\"line\">            weights = <span class=\"variable language_\">self</span>._summary_reshape(weights, shape,</span><br><span class=\"line\">                                            num_new=num_classes)</span><br><span class=\"line\">        init = tf.constant_initializer(value=weights,</span><br><span class=\"line\">                                       dtype=tf.float32)</span><br><span class=\"line\">        var = tf.get_variable(name=<span class=\"string\">&quot;weights&quot;</span>, initializer=init, shape=shape)</span><br><span class=\"line\">        <span class=\"keyword\">return</span> var</span><br><span class=\"line\"></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">def</span> <span class=\"title function_\">_activation_summary</span>(<span class=\"params\">x</span>):</span><br><span class=\"line\">    <span class=\"string\">&quot;&quot;&quot;Helper to create summaries for activations.</span></span><br><span class=\"line\"><span class=\"string\"></span></span><br><span class=\"line\"><span class=\"string\">    Creates a summary that provides a histogram of activations.</span></span><br><span class=\"line\"><span class=\"string\">    Creates a summary that measure the sparsity of activations.</span></span><br><span class=\"line\"><span class=\"string\"></span></span><br><span class=\"line\"><span class=\"string\">    Args:</span></span><br><span class=\"line\"><span class=\"string\">      x: Tensor</span></span><br><span class=\"line\"><span class=\"string\">    Returns:</span></span><br><span class=\"line\"><span class=\"string\">      nothing</span></span><br><span class=\"line\"><span class=\"string\">    &quot;&quot;&quot;</span></span><br><span class=\"line\">    <span class=\"comment\"># Remove &#x27;tower_[0-9]/&#x27; from the name in case this is a multi-GPU training</span></span><br><span class=\"line\">    <span class=\"comment\"># session. This helps the clarity of presentation on tensorboard.</span></span><br><span class=\"line\">    tensor_name = x.op.name</span><br><span class=\"line\">    <span class=\"comment\"># tensor_name = re.sub(&#x27;%s_[0-9]*/&#x27; % TOWER_NAME, &#x27;&#x27;, x.op.name)</span></span><br><span class=\"line\">    tf.summary.histogram(tensor_name + <span class=\"string\">&#x27;/activations&#x27;</span>, x)</span><br><span class=\"line\">    tf.summary.scalar(tensor_name + <span class=\"string\">&#x27;/sparsity&#x27;</span>, tf.nn.zero_fraction(x))</span><br><span class=\"line\"></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">def</span> <span class=\"title function_\">_variable_summaries</span>(<span class=\"params\">var</span>):</span><br><span class=\"line\">    <span class=\"string\">&quot;&quot;&quot;Attach a lot of summaries to a Tensor.&quot;&quot;&quot;</span></span><br><span class=\"line\">    <span class=\"keyword\">if</span> <span class=\"keyword\">not</span> tf.get_variable_scope().reuse:</span><br><span class=\"line\">        name = var.op.name</span><br><span class=\"line\">        logging.info(<span class=\"string\">&quot;Creating Summary for: %s&quot;</span> % name)</span><br><span class=\"line\">        <span class=\"keyword\">with</span> tf.name_scope(<span class=\"string\">&#x27;summaries&#x27;</span>):</span><br><span class=\"line\">            mean = tf.reduce_mean(var)</span><br><span class=\"line\">            tf.summary.scalar(name + <span class=\"string\">&#x27;/mean&#x27;</span>, mean)</span><br><span class=\"line\">            <span class=\"keyword\">with</span> tf.name_scope(<span class=\"string\">&#x27;stddev&#x27;</span>):</span><br><span class=\"line\">                stddev = tf.sqrt(tf.reduce_sum(tf.square(var - mean)))</span><br><span class=\"line\">            tf.summary.scalar(name + <span class=\"string\">&#x27;/sttdev&#x27;</span>, stddev)</span><br><span class=\"line\">            tf.summary.scalar(name + <span class=\"string\">&#x27;/max&#x27;</span>, tf.reduce_max(var))</span><br><span class=\"line\">            tf.summary.scalar(name + <span class=\"string\">&#x27;/min&#x27;</span>, tf.reduce_min(var))</span><br><span class=\"line\">            tf.summary.histogram(name, var)</span><br></pre></td></tr></table></figure>\n\n<h5 id=\"fcn-调包\"><a href=\"#fcn-调包\" class=\"headerlink\" title=\"fcn 调包\"></a>fcn 调包</h5><figure class=\"highlight python\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br><span class=\"line\">47</span><br><span class=\"line\">48</span><br><span class=\"line\">49</span><br><span class=\"line\">50</span><br><span class=\"line\">51</span><br><span class=\"line\">52</span><br><span class=\"line\">53</span><br><span class=\"line\">54</span><br><span class=\"line\">55</span><br><span class=\"line\">56</span><br><span class=\"line\">57</span><br><span class=\"line\">58</span><br><span class=\"line\">59</span><br><span class=\"line\">60</span><br><span class=\"line\">61</span><br><span class=\"line\">62</span><br><span class=\"line\">63</span><br><span class=\"line\">64</span><br><span class=\"line\">65</span><br><span class=\"line\">66</span><br><span class=\"line\">67</span><br><span class=\"line\">68</span><br><span class=\"line\">69</span><br><span class=\"line\">70</span><br><span class=\"line\">71</span><br><span class=\"line\">72</span><br><span class=\"line\">73</span><br><span class=\"line\">74</span><br><span class=\"line\">75</span><br><span class=\"line\">76</span><br><span class=\"line\">77</span><br><span class=\"line\">78</span><br><span class=\"line\">79</span><br><span class=\"line\">80</span><br><span class=\"line\">81</span><br><span class=\"line\">82</span><br><span class=\"line\">83</span><br><span class=\"line\">84</span><br><span class=\"line\">85</span><br><span class=\"line\">86</span><br><span class=\"line\">87</span><br><span class=\"line\">88</span><br><span class=\"line\">89</span><br><span class=\"line\">90</span><br><span class=\"line\">91</span><br><span class=\"line\">92</span><br><span class=\"line\">93</span><br><span class=\"line\">94</span><br><span class=\"line\">95</span><br><span class=\"line\">96</span><br><span class=\"line\">97</span><br><span class=\"line\">98</span><br><span class=\"line\">99</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">import</span> torch.nn <span class=\"keyword\">as</span> nn</span><br><span class=\"line\"><span class=\"keyword\">import</span> torch.nn.functional <span class=\"keyword\">as</span> F</span><br><span class=\"line\"><span class=\"keyword\">from</span> abc <span class=\"keyword\">import</span> ABCMeta</span><br><span class=\"line\"><span class=\"keyword\">import</span> torchvision.models <span class=\"keyword\">as</span> models</span><br><span class=\"line\"></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">def</span> <span class=\"title function_\">_maybe_pad</span>(<span class=\"params\">x, size</span>):</span><br><span class=\"line\">    hpad = size[<span class=\"number\">0</span>] - x.shape[<span class=\"number\">2</span>]</span><br><span class=\"line\">    wpad = size[<span class=\"number\">1</span>] - x.shape[<span class=\"number\">3</span>]</span><br><span class=\"line\">    <span class=\"keyword\">if</span> hpad + wpad &gt; <span class=\"number\">0</span>:</span><br><span class=\"line\">        x = F.pad(x, (<span class=\"number\">0</span>, wpad, <span class=\"number\">0</span>, hpad, <span class=\"number\">0</span>, <span class=\"number\">0</span>, <span class=\"number\">0</span>, <span class=\"number\">0</span> ))</span><br><span class=\"line\">    <span class=\"keyword\">return</span> x</span><br><span class=\"line\"></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">class</span> <span class=\"title class_\">VGGFCN</span>(nn.Module, metaclass=ABCMeta):</span><br><span class=\"line\">    <span class=\"keyword\">def</span> <span class=\"title function_\">__init__</span>(<span class=\"params\">self, in_channels, n_classes</span>):</span><br><span class=\"line\">        <span class=\"built_in\">super</span>().__init__()</span><br><span class=\"line\">        <span class=\"keyword\">assert</span> in_channels == <span class=\"number\">3</span></span><br><span class=\"line\">        <span class=\"variable language_\">self</span>.n_classes = n_classes</span><br><span class=\"line\">        <span class=\"variable language_\">self</span>.vgg16 = models.vgg16(pretrained=<span class=\"literal\">True</span>)</span><br><span class=\"line\">        <span class=\"variable language_\">self</span>.classifier = nn.Sequential(</span><br><span class=\"line\">            nn.Conv2d(<span class=\"number\">512</span>, <span class=\"number\">4096</span>, kernel_size=<span class=\"number\">7</span>, padding=<span class=\"number\">3</span>),</span><br><span class=\"line\">            nn.ReLU(<span class=\"literal\">True</span>),</span><br><span class=\"line\">            nn.Dropout(),</span><br><span class=\"line\">            nn.Conv2d(<span class=\"number\">4096</span>, <span class=\"number\">4096</span>, kernel_size=<span class=\"number\">1</span>),</span><br><span class=\"line\">            nn.ReLU(<span class=\"literal\">True</span>),</span><br><span class=\"line\">            nn.Dropout(),</span><br><span class=\"line\">            nn.Conv2d(<span class=\"number\">4096</span>, n_classes, kernel_size=<span class=\"number\">1</span>),</span><br><span class=\"line\">        )</span><br><span class=\"line\"></span><br><span class=\"line\">        <span class=\"variable language_\">self</span>._initialize_weights()</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">def</span> <span class=\"title function_\">_initialize_weights</span>(<span class=\"params\">self</span>):</span><br><span class=\"line\">        <span class=\"variable language_\">self</span>.classifier[<span class=\"number\">0</span>].weight.data = (</span><br><span class=\"line\">            <span class=\"variable language_\">self</span>.vgg16.classifier[<span class=\"number\">0</span>].weight.data.view(</span><br><span class=\"line\">                <span class=\"variable language_\">self</span>.classifier[<span class=\"number\">0</span>].weight.size())</span><br><span class=\"line\">        )</span><br><span class=\"line\">        <span class=\"variable language_\">self</span>.classifier[<span class=\"number\">3</span>].weight.data = (</span><br><span class=\"line\">            <span class=\"variable language_\">self</span>.vgg16.classifier[<span class=\"number\">3</span>].weight.data.view(</span><br><span class=\"line\">                <span class=\"variable language_\">self</span>.classifier[<span class=\"number\">3</span>].weight.size())</span><br><span class=\"line\">        )</span><br><span class=\"line\"></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">class</span> <span class=\"title class_\">VGGFCN32</span>(<span class=\"title class_ inherited__\">VGGFCN</span>):</span><br><span class=\"line\">    <span class=\"keyword\">def</span> <span class=\"title function_\">forward</span>(<span class=\"params\">self, x</span>):</span><br><span class=\"line\">        input_height, input_width = x.shape[<span class=\"number\">2</span>], x.shape[<span class=\"number\">3</span>]</span><br><span class=\"line\">        x = <span class=\"variable language_\">self</span>.vgg16.features(x)</span><br><span class=\"line\">        x = <span class=\"variable language_\">self</span>.classifier(x)</span><br><span class=\"line\">        x = F.interpolate(x, size=(input_height, input_width),</span><br><span class=\"line\">                          mode=<span class=\"string\">&#x27;bilinear&#x27;</span>, align_corners=<span class=\"literal\">True</span>)</span><br><span class=\"line\">        <span class=\"keyword\">return</span> x</span><br><span class=\"line\"></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">class</span> <span class=\"title class_\">VGGFCN16</span>(<span class=\"title class_ inherited__\">VGGFCN</span>):</span><br><span class=\"line\">    <span class=\"keyword\">def</span> <span class=\"title function_\">__init__</span>(<span class=\"params\">self, in_channels, n_classes</span>):</span><br><span class=\"line\">        <span class=\"built_in\">super</span>().__init__(in_channels, n_classes)</span><br><span class=\"line\">        <span class=\"variable language_\">self</span>.score4 = nn.Conv2d(<span class=\"number\">512</span>, n_classes, kernel_size=<span class=\"number\">1</span>)</span><br><span class=\"line\">        <span class=\"variable language_\">self</span>.upscale5 = nn.ConvTranspose2d(</span><br><span class=\"line\">            n_classes, n_classes, kernel_size=<span class=\"number\">2</span>, stride=<span class=\"number\">2</span>)</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">def</span> <span class=\"title function_\">forward</span>(<span class=\"params\">self, x</span>):</span><br><span class=\"line\">        input_height, input_width = x.shape[<span class=\"number\">2</span>], x.shape[<span class=\"number\">3</span>]</span><br><span class=\"line\">        pool4 = <span class=\"variable language_\">self</span>.vgg16.features[:-<span class=\"number\">7</span>](x)</span><br><span class=\"line\">        pool5 = <span class=\"variable language_\">self</span>.vgg16.features[-<span class=\"number\">7</span>:](pool4)</span><br><span class=\"line\">        pool5_upscaled = <span class=\"variable language_\">self</span>.upscale5(<span class=\"variable language_\">self</span>.classifier(pool5))</span><br><span class=\"line\">        pool4 = <span class=\"variable language_\">self</span>.score4(pool4)</span><br><span class=\"line\">        x = pool4 + pool5_upscaled</span><br><span class=\"line\">        x = F.interpolate(x, size=(input_height, input_width),</span><br><span class=\"line\">                          mode=<span class=\"string\">&#x27;bilinear&#x27;</span>, align_corners=<span class=\"literal\">True</span>)</span><br><span class=\"line\">        <span class=\"keyword\">return</span> x</span><br><span class=\"line\"></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">class</span> <span class=\"title class_\">VGGFCN8</span>(<span class=\"title class_ inherited__\">VGGFCN</span>):</span><br><span class=\"line\">    <span class=\"keyword\">def</span> <span class=\"title function_\">__init__</span>(<span class=\"params\">self, in_channels, n_classes</span>):</span><br><span class=\"line\">        <span class=\"built_in\">super</span>().__init__(in_channels, n_classes)</span><br><span class=\"line\">        <span class=\"variable language_\">self</span>.upscale4 = nn.ConvTranspose2d(</span><br><span class=\"line\">            n_classes, n_classes, kernel_size=<span class=\"number\">2</span>, stride=<span class=\"number\">2</span>)</span><br><span class=\"line\">        <span class=\"variable language_\">self</span>.score4 = nn.Conv2d(</span><br><span class=\"line\">            <span class=\"number\">512</span>, n_classes, kernel_size=<span class=\"number\">1</span>, stride=<span class=\"number\">1</span>)</span><br><span class=\"line\">        <span class=\"variable language_\">self</span>.score3 = nn.Conv2d(</span><br><span class=\"line\">            <span class=\"number\">256</span>, n_classes, kernel_size=<span class=\"number\">1</span>, stride=<span class=\"number\">1</span>)</span><br><span class=\"line\">        <span class=\"variable language_\">self</span>.upscale5 = nn.ConvTranspose2d(</span><br><span class=\"line\">            n_classes, n_classes, kernel_size=<span class=\"number\">2</span>, stride=<span class=\"number\">2</span>)</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">def</span> <span class=\"title function_\">forward</span>(<span class=\"params\">self, x</span>):</span><br><span class=\"line\">        input_height, input_width = x.shape[<span class=\"number\">2</span>], x.shape[<span class=\"number\">3</span>]</span><br><span class=\"line\">        pool3 = <span class=\"variable language_\">self</span>.vgg16.features[:-<span class=\"number\">14</span>](x)</span><br><span class=\"line\">        pool4 = <span class=\"variable language_\">self</span>.vgg16.features[-<span class=\"number\">14</span>:-<span class=\"number\">7</span>](pool3)</span><br><span class=\"line\">        pool5 = <span class=\"variable language_\">self</span>.vgg16.features[-<span class=\"number\">7</span>:](pool4)</span><br><span class=\"line\">        pool5_upscaled = <span class=\"variable language_\">self</span>.upscale5(<span class=\"variable language_\">self</span>.classifier(pool5))</span><br><span class=\"line\">        pool5_upscaled = _maybe_pad(pool5_upscaled, pool4.shape[<span class=\"number\">2</span>:])</span><br><span class=\"line\">        pool4_scores = <span class=\"variable language_\">self</span>.score4(pool4)</span><br><span class=\"line\">        pool4_fused = pool4_scores + pool5_upscaled</span><br><span class=\"line\">        pool4_upscaled = <span class=\"variable language_\">self</span>.upscale4(pool4_fused)</span><br><span class=\"line\">        pool4_upscaled = _maybe_pad(pool4_upscaled, pool3.shape[<span class=\"number\">2</span>:])</span><br><span class=\"line\">        x = <span class=\"variable language_\">self</span>.score3(pool3) + pool4_upscaled</span><br><span class=\"line\">        x = F.interpolate(x, size=(input_height, input_width),</span><br><span class=\"line\">                          mode=<span class=\"string\">&#x27;bilinear&#x27;</span>, align_corners=<span class=\"literal\">True</span>)</span><br><span class=\"line\">        <span class=\"keyword\">return</span> x</span><br></pre></td></tr></table></figure>\n\n<h4 id=\"相关资源\"><a href=\"#相关资源\" class=\"headerlink\" title=\"相关资源\"></a>相关资源</h4><h3 id=\"U-Net\"><a href=\"#U-Net\" class=\"headerlink\" title=\"U-Net\"></a><strong>U-Net</strong></h3><ul>\n<li><strong>优点</strong>：简单易用，适用于小数据集，尤其在医学图像分割中表现良好。</li>\n<li><strong>缺点</strong>：容易过拟合，不太适合大规模数据集。</li>\n</ul>\n<p><img src=\"https://tk-pichost-1325224430.cos.ap-chengdu.myqcloud.com/blog/1740236677445SwkUbDFUtolVEKxc4dmcbrOknJf.png\" alt=\"1740236677445SwkUbDFUtolVEKxc4dmcbrOknJf.png\"></p>\n<h4 id=\"提出初衷-1\"><a href=\"#提出初衷-1\" class=\"headerlink\" title=\"提出初衷\"></a>提出初衷</h4><p>U-Net 是一种经典且广泛使用的分割模型，以其简单、高效、易于理解和构建的特点而受到青睐，尤其适合从小数据集中进行训练。该模型最早于 2015 年在论文《U-Net: Convolutional Networks for Biomedical Image Segmentation》中被提出，至今仍然是医学图像分割领域的重要基础模型。</p>\n<p><img src=\"https://tk-pichost-1325224430.cos.ap-chengdu.myqcloud.com/blog/1740236700448YM2HbihrkonVkixR0KdcPLcBnLc.png\" alt=\"1740236700448YM2HbihrkonVkixR0KdcPLcBnLc.png\"></p>\n<p><img src=\"https://tk-pichost-1325224430.cos.ap-chengdu.myqcloud.com/blog/1740236696443Voorb6LuJopG3exmtulcaySynjc.png\" alt=\"1740236696443Voorb6LuJopG3exmtulcaySynjc.png\"></p>\n<p><img src=\"https://tk-pichost-1325224430.cos.ap-chengdu.myqcloud.com/blog/1740236682500NfPrbS5SNoEjsFxFFptcl471nhb.png\" alt=\"1740236682500NfPrbS5SNoEjsFxFFptcl471nhb.png\"></p>\n<ol>\n<li>Unet 提出的初衷是为了解决医学图像分割的问题；</li>\n<li>一种 U 型的网络结构来获取上下文的信息和位置信息；</li>\n<li>在 2015 年的 ISBI cell tracking 比赛中获得了多个第一，一开始这是为了解决细胞层面的分割的任务的</li>\n</ol>\n<h4 id=\"网络结构-1\"><a href=\"#网络结构-1\" class=\"headerlink\" title=\"网络结构\"></a>网络结构</h4><p><img src=\"https://tk-pichost-1325224430.cos.ap-chengdu.myqcloud.com/blog/1740236655458N3Vab29uNorFHwxpINwc5s6unkh.png\" alt=\"1740236655458N3Vab29uNorFHwxpINwc5s6unkh.png\"></p>\n<p>U-Net 网络是一种经典的编码器-解码器结构，因其整体结构形似大写的英文字母“U”而得名。它广泛应用于医学图像分割等领域。U-Net 的设计非常简洁：前半部分用于特征提取（编码器），后半部分用于上采样（解码器）。</p>\n<h5 id=\"编码器（Encoder）\"><a href=\"#编码器（Encoder）\" class=\"headerlink\" title=\"编码器（Encoder）\"></a>编码器（Encoder）</h5><p>编码器位于网络的左半部分，主要由多个下采样模块组成。每个模块包含两个 3×3 的卷积层（激活函数为 ReLU），后接一个 2×2 的最大池化（Max Pooling）层，用于特征提取和空间尺寸的减半。通过这种结构，编码器能够逐步提取图像的深层特征，同时扩大感受野。</p>\n<h5 id=\"解码器（Decoder）\"><a href=\"#解码器（Decoder）\" class=\"headerlink\" title=\"解码器（Decoder）\"></a>解码器（Decoder）</h5><p>解码器位于网络的右半部分，主要由上采样模块组成。每个模块包含一个 2×2 的反卷积层（上采样卷积层），用于将特征图的空间尺寸恢复到与编码器对应层相同的大小。随后，解码器通过特征拼接（concatenation）将上采样后的特征图与编码器中对应层的特征图进行通道级拼接，最后通过两个 3×3 的卷积层（激活函数为 ReLU）进一步融合特征。这种结构能够有效地结合深层特征和浅层特征，兼顾全局语义信息和局部细节。</p>\n<h5 id=\"特征融合方式\"><a href=\"#特征融合方式\" class=\"headerlink\" title=\"特征融合方式\"></a>特征融合方式</h5><p>与 FCN 网络通过特征图对应像素值的相加来融合特征不同，U-Net 采用通道级拼接的方式。这种方式可以形成更厚的特征图，从而保留更多的细节信息，但也增加了显存的消耗。</p>\n<h3 id=\"U-Net-的优点\"><a href=\"#U-Net-的优点\" class=\"headerlink\" title=\"U-Net 的优点\"></a>U-Net 的优点</h3><ol>\n<li><strong>多尺度特征融合</strong>：U-Net 通过拼接深层和浅层特征图，能够充分利用不同层次的特征。浅层卷积关注纹理和细节特征，而深层网络关注更高级的语义特征。这种融合方式使得模型能够更好地处理复杂的分割任务。</li>\n<li><strong>边缘特征的保留</strong>：在下采样过程中，虽然会损失一些边缘特征，但通过特征拼接，解码器能够从编码器的浅层特征中找回这些丢失的边缘信息，从而提高分割的精度。</li>\n</ol>\n<p>Unet 的好处我感觉是：网络层越深得到的特征图，有着更大的视野域，浅层卷积关注纹理特征，深层网络关注本质的那种特征，所以深层浅层特征都是有格子的意义的；另外一点是通过反卷积得到的更大的尺寸的特征图的边缘，是缺少信息的，毕竟每一次下采样提炼特征的同时，也必然会损失一些边缘特征，而失去的特征并不能从上采样中找回，因此通过特征的拼接，来实现边缘特征的一个找回。</p>\n<p>下面是一些与医学相关的数据集以及对应的提取码,有兴趣的同学可以下载下来跑一下。</p>\n<table>\n<tr>\n<td>**数据集名称**<br/></td><td>**下载链接**<td>**提取码**<br/></td></tr>\n<tr>\n<td>Cell dataset (dsb2018)<br/></td><td>https://pan.baidu.com/share/init?surl=BaVrzYdrSP78CwYaRzZr1w<td>5l54<br/></td></tr>\n<tr>\n<td>Liver dataset<br/></td><td>https://pan.baidu.com/share/init?surl=FljGCVzu7HPYpwAKvSVN4Q<td>5l88<br/></td></tr>\n<tr>\n<td>Cell dataset (isbi)<br/></td><td>https://pan.baidu.com/share/init?surl=FkfnhU-RnYFZti62-f8AVA<td>14rz<br/></td></tr>\n<tr>\n<td>Lung dataset<br/></td><td>https://pan.baidu.com/share/init?surl=sLFRmtG2TOTEgUKniJf7AA<td>qdwo<br/></td></tr>\n<tr>\n<td>Corneal Nerve dataset<br/></td><td>https://pan.baidu.com/share/init?surl=T3-kS_FgYI6DeXv3n1I7bA<td>ih02<br/></td></tr>\n<tr>\n<td>Eye Vessels (DRIVE dataset)<br/></td><td>https://pan.baidu.com/share/init?surl=UkMLmdbM61N8ecgnKlAsPg<td>f1ek<br/></td></tr>\n<tr>\n<td>Esophagus and Esophagus Cancer dataset (First Affiliated Hospital of Sun Yat-sen University)<br/></td><td>https://pan.baidu.com/share/init?surl=0b5arIQjNpiggwdkgYNHXQ<td>hivm<br/></td></tr>\n</table>\n\n<h4 id=\"为什么-Unet-在医疗图像分割中表现好\"><a href=\"#为什么-Unet-在医疗图像分割中表现好\" class=\"headerlink\" title=\"为什么 Unet 在医疗图像分割中表现好?\"></a>为什么 Unet 在医疗图像分割中表现好?</h4><p>大多数医疗影像语义分割任务都会首先用 Unet 作为 baseline，当然上一章节讲解的 Unet 的优点肯定是可以当作这个问题的答案，这里谈一谈医疗影像的特点</p>\n<p>根据网友的讨论，得到的结果：</p>\n<ol>\n<li>医疗影像语义较为简单、结构固定。因此语义信息相比自动驾驶等较为单一，因此并不需要去筛选过滤无用的信息。医疗影像的所有特征都很重要，因此低级特征和高级语义特征都很重要，所以 U 型结构的 skip connection 结构（特征拼接）更好派上用场</li>\n<li>医学影像的数据较少，获取难度大，数据量可能只有几百甚至不到 100，因此如果使用大型的网络例如 DeepLabv3+ 等模型，很容易过拟合。大型网络的优点是更强的图像表述能力，而较为简单、数量少的医学影像并没有那么多的内容需要表述，因此也有人发现在小数量级中，分割的 SOTA 模型与轻量的 Unet 并没有神恶魔优势</li>\n<li>医学影像往往是多模态的。比方说 ISLES 脑梗竞赛中，官方提供了 CBF，MTT，CBV 等多中模态的数据（这一点听不懂也无妨）。因此医学影像任务中，往往需要自己设计网络去提取不同的模态特征，因此轻量结构简单的 Unet 可以有更大的操作空间。</li>\n</ol>\n<blockquote>\n<p>Q:过拟合与模型复杂程度有关还和什么有关呢?</p>\n</blockquote>\n<h4 id=\"模型代码-1\"><a href=\"#模型代码-1\" class=\"headerlink\" title=\"模型代码\"></a>模型代码</h4><h5 id=\"源码\"><a href=\"#源码\" class=\"headerlink\" title=\"源码\"></a>源码</h5><figure class=\"highlight python\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br><span class=\"line\">47</span><br><span class=\"line\">48</span><br><span class=\"line\">49</span><br><span class=\"line\">50</span><br><span class=\"line\">51</span><br><span class=\"line\">52</span><br><span class=\"line\">53</span><br><span class=\"line\">54</span><br><span class=\"line\">55</span><br><span class=\"line\">56</span><br><span class=\"line\">57</span><br><span class=\"line\">58</span><br><span class=\"line\">59</span><br><span class=\"line\">60</span><br><span class=\"line\">61</span><br><span class=\"line\">62</span><br><span class=\"line\">63</span><br><span class=\"line\">64</span><br><span class=\"line\">65</span><br><span class=\"line\">66</span><br><span class=\"line\">67</span><br><span class=\"line\">68</span><br><span class=\"line\">69</span><br><span class=\"line\">70</span><br><span class=\"line\">71</span><br><span class=\"line\">72</span><br><span class=\"line\">73</span><br><span class=\"line\">74</span><br><span class=\"line\">75</span><br><span class=\"line\">76</span><br><span class=\"line\">77</span><br><span class=\"line\">78</span><br><span class=\"line\">79</span><br><span class=\"line\">80</span><br><span class=\"line\">81</span><br><span class=\"line\">82</span><br><span class=\"line\">83</span><br><span class=\"line\">84</span><br><span class=\"line\">85</span><br><span class=\"line\">86</span><br><span class=\"line\">87</span><br><span class=\"line\">88</span><br><span class=\"line\">89</span><br><span class=\"line\">90</span><br><span class=\"line\">91</span><br><span class=\"line\">92</span><br><span class=\"line\">93</span><br><span class=\"line\">94</span><br><span class=\"line\">95</span><br><span class=\"line\">96</span><br><span class=\"line\">97</span><br><span class=\"line\">98</span><br><span class=\"line\">99</span><br><span class=\"line\">100</span><br><span class=\"line\">101</span><br><span class=\"line\">102</span><br><span class=\"line\">103</span><br><span class=\"line\">104</span><br><span class=\"line\">105</span><br><span class=\"line\">106</span><br><span class=\"line\">107</span><br><span class=\"line\">108</span><br><span class=\"line\">109</span><br><span class=\"line\">110</span><br><span class=\"line\">111</span><br><span class=\"line\">112</span><br><span class=\"line\">113</span><br><span class=\"line\">114</span><br><span class=\"line\">115</span><br><span class=\"line\">116</span><br><span class=\"line\">117</span><br><span class=\"line\">118</span><br><span class=\"line\">119</span><br><span class=\"line\">120</span><br><span class=\"line\">121</span><br><span class=\"line\">122</span><br><span class=\"line\">123</span><br><span class=\"line\">124</span><br><span class=\"line\">125</span><br><span class=\"line\">126</span><br><span class=\"line\">127</span><br><span class=\"line\">128</span><br><span class=\"line\">129</span><br><span class=\"line\">130</span><br><span class=\"line\">131</span><br><span class=\"line\">132</span><br><span class=\"line\">133</span><br><span class=\"line\">134</span><br><span class=\"line\">135</span><br><span class=\"line\">136</span><br><span class=\"line\">137</span><br><span class=\"line\">138</span><br><span class=\"line\">139</span><br><span class=\"line\">140</span><br><span class=\"line\">141</span><br><span class=\"line\">142</span><br><span class=\"line\">143</span><br><span class=\"line\">144</span><br><span class=\"line\">145</span><br><span class=\"line\">146</span><br><span class=\"line\">147</span><br><span class=\"line\">148</span><br><span class=\"line\">149</span><br><span class=\"line\">150</span><br><span class=\"line\">151</span><br><span class=\"line\">152</span><br><span class=\"line\">153</span><br><span class=\"line\">154</span><br><span class=\"line\">155</span><br><span class=\"line\">156</span><br><span class=\"line\">157</span><br><span class=\"line\">158</span><br><span class=\"line\">159</span><br><span class=\"line\">160</span><br><span class=\"line\">161</span><br><span class=\"line\">162</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">import</span> torch.nn <span class=\"keyword\">as</span> nn</span><br><span class=\"line\"><span class=\"keyword\">import</span> torch</span><br><span class=\"line\"><span class=\"keyword\">from</span> torch <span class=\"keyword\">import</span> autograd</span><br><span class=\"line\"><span class=\"keyword\">from</span> functools <span class=\"keyword\">import</span> partial</span><br><span class=\"line\"><span class=\"keyword\">import</span> torch.nn.functional <span class=\"keyword\">as</span> F</span><br><span class=\"line\"><span class=\"keyword\">from</span> torchvision <span class=\"keyword\">import</span> models</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">class</span> <span class=\"title class_\">DoubleConv</span>(nn.Module):</span><br><span class=\"line\">    <span class=\"keyword\">def</span> <span class=\"title function_\">__init__</span>(<span class=\"params\">self, in_ch, out_ch</span>):</span><br><span class=\"line\">        <span class=\"built_in\">super</span>(DoubleConv, <span class=\"variable language_\">self</span>).__init__()</span><br><span class=\"line\">        <span class=\"variable language_\">self</span>.**conv** = nn.Sequential(</span><br><span class=\"line\">            nn.Conv2d(in_ch, out_ch, <span class=\"number\">3</span>, _padding_=<span class=\"number\">1</span>),</span><br><span class=\"line\">            nn.BatchNorm2d(out_ch),</span><br><span class=\"line\">            nn.ReLU(_inplace_=<span class=\"literal\">True</span>),</span><br><span class=\"line\">            nn.Conv2d(out_ch, out_ch, <span class=\"number\">3</span>, _padding_=<span class=\"number\">1</span>),</span><br><span class=\"line\">            nn.BatchNorm2d(out_ch),</span><br><span class=\"line\">            nn.ReLU(_inplace_=<span class=\"literal\">True</span>)</span><br><span class=\"line\">        )</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">def</span> <span class=\"title function_\">forward</span>(<span class=\"params\">self, <span class=\"built_in\">input</span></span>):</span><br><span class=\"line\">        <span class=\"keyword\">return</span> <span class=\"variable language_\">self</span>.**conv**(<span class=\"built_in\">input</span>)</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">class</span> <span class=\"title class_\">Unet</span>(nn.Module):</span><br><span class=\"line\">    <span class=\"keyword\">def</span> <span class=\"title function_\">__init__</span>(<span class=\"params\">self, in_ch, out_ch</span>):</span><br><span class=\"line\">        <span class=\"built_in\">super</span>(Unet, <span class=\"variable language_\">self</span>).__init__()</span><br><span class=\"line\"></span><br><span class=\"line\">        <span class=\"variable language_\">self</span>.**conv1** = DoubleConv(in_ch, <span class=\"number\">32</span>)</span><br><span class=\"line\">        <span class=\"variable language_\">self</span>.**pool1** = nn.MaxPool2d(<span class=\"number\">2</span>)</span><br><span class=\"line\">        <span class=\"variable language_\">self</span>.**conv2** = DoubleConv(<span class=\"number\">32</span>, <span class=\"number\">64</span>)</span><br><span class=\"line\">        <span class=\"variable language_\">self</span>.**pool2** = nn.MaxPool2d(<span class=\"number\">2</span>)</span><br><span class=\"line\">        <span class=\"variable language_\">self</span>.**conv3** = DoubleConv(<span class=\"number\">64</span>, <span class=\"number\">128</span>)</span><br><span class=\"line\">        <span class=\"variable language_\">self</span>.**pool3** = nn.MaxPool2d(<span class=\"number\">2</span>)</span><br><span class=\"line\">        <span class=\"variable language_\">self</span>.**conv4** = DoubleConv(<span class=\"number\">128</span>, <span class=\"number\">256</span>)</span><br><span class=\"line\">        <span class=\"variable language_\">self</span>.**pool4** = nn.MaxPool2d(<span class=\"number\">2</span>)</span><br><span class=\"line\">        <span class=\"variable language_\">self</span>.**conv5** = DoubleConv(<span class=\"number\">256</span>, <span class=\"number\">512</span>)</span><br><span class=\"line\">        <span class=\"variable language_\">self</span>.**up6** = nn.ConvTranspose2d(<span class=\"number\">512</span>, <span class=\"number\">256</span>, <span class=\"number\">2</span>, _stride_=<span class=\"number\">2</span>)</span><br><span class=\"line\">        <span class=\"variable language_\">self</span>.**conv6** = DoubleConv(<span class=\"number\">512</span>, <span class=\"number\">256</span>)</span><br><span class=\"line\">        <span class=\"variable language_\">self</span>.**up7** = nn.ConvTranspose2d(<span class=\"number\">256</span>, <span class=\"number\">128</span>, <span class=\"number\">2</span>, _stride_=<span class=\"number\">2</span>)</span><br><span class=\"line\">        <span class=\"variable language_\">self</span>.**conv7** = DoubleConv(<span class=\"number\">256</span>, <span class=\"number\">128</span>)</span><br><span class=\"line\">        <span class=\"variable language_\">self</span>.**up8** = nn.ConvTranspose2d(<span class=\"number\">128</span>, <span class=\"number\">64</span>, <span class=\"number\">2</span>, _stride_=<span class=\"number\">2</span>)</span><br><span class=\"line\">        <span class=\"variable language_\">self</span>.**conv8** = DoubleConv(<span class=\"number\">128</span>, <span class=\"number\">64</span>)</span><br><span class=\"line\">        <span class=\"variable language_\">self</span>.**up9** = nn.ConvTranspose2d(<span class=\"number\">64</span>, <span class=\"number\">32</span>, <span class=\"number\">2</span>, _stride_=<span class=\"number\">2</span>)</span><br><span class=\"line\">        <span class=\"variable language_\">self</span>.**conv9** = DoubleConv(<span class=\"number\">64</span>, <span class=\"number\">32</span>)</span><br><span class=\"line\">        <span class=\"variable language_\">self</span>.**conv10** = nn.Conv2d(<span class=\"number\">32</span>, out_ch, <span class=\"number\">1</span>)</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">def</span> <span class=\"title function_\">forward</span>(<span class=\"params\">self, x</span>):</span><br><span class=\"line\">        _<span class=\"comment\">#print(x.shape)_</span></span><br><span class=\"line\">        c1 = <span class=\"variable language_\">self</span>.**conv1**(x)</span><br><span class=\"line\">        p1 = <span class=\"variable language_\">self</span>.**pool1**(c1)</span><br><span class=\"line\">        _<span class=\"comment\">#print(p1.shape)_</span></span><br><span class=\"line\">        c2 = <span class=\"variable language_\">self</span>.**conv2**(p1)</span><br><span class=\"line\">        p2 = <span class=\"variable language_\">self</span>.**pool2**(c2)</span><br><span class=\"line\">        _<span class=\"comment\">#print(p2.shape)_</span></span><br><span class=\"line\">        c3 = <span class=\"variable language_\">self</span>.**conv3**(p2)</span><br><span class=\"line\">        p3 = <span class=\"variable language_\">self</span>.**pool3**(c3)</span><br><span class=\"line\">        _<span class=\"comment\">#print(p3.shape)_</span></span><br><span class=\"line\">        c4 = <span class=\"variable language_\">self</span>.**conv4**(p3)</span><br><span class=\"line\">        p4 = <span class=\"variable language_\">self</span>.**pool4**(c4)</span><br><span class=\"line\">        _<span class=\"comment\">#print(p4.shape)_</span></span><br><span class=\"line\">        c5 = <span class=\"variable language_\">self</span>.**conv5**(p4)</span><br><span class=\"line\">        up_6 = <span class=\"variable language_\">self</span>.**up6**(c5)</span><br><span class=\"line\">        merge6 = torch.cat([up_6, c4], _dim_=<span class=\"number\">1</span>)</span><br><span class=\"line\">        c6 = <span class=\"variable language_\">self</span>.**conv6**(merge6)</span><br><span class=\"line\">        up_7 = <span class=\"variable language_\">self</span>.**up7**(c6)</span><br><span class=\"line\">        merge7 = torch.cat([up_7, c3], _dim_=<span class=\"number\">1</span>)</span><br><span class=\"line\">        c7 = <span class=\"variable language_\">self</span>.**conv7**(merge7)</span><br><span class=\"line\">        up_8 = <span class=\"variable language_\">self</span>.**up8**(c7)</span><br><span class=\"line\">        merge8 = torch.cat([up_8, c2], _dim_=<span class=\"number\">1</span>)</span><br><span class=\"line\">        c8 = <span class=\"variable language_\">self</span>.**conv8**(merge8)</span><br><span class=\"line\">        up_9 = <span class=\"variable language_\">self</span>.**up9**(c8)</span><br><span class=\"line\">        merge9 = torch.cat([up_9, c1], _dim_=<span class=\"number\">1</span>)</span><br><span class=\"line\">        c9 = <span class=\"variable language_\">self</span>.**conv9**(merge9)</span><br><span class=\"line\">        c10 = <span class=\"variable language_\">self</span>.**conv10**(c9)</span><br><span class=\"line\">        out = nn.Sigmoid()(c10)</span><br><span class=\"line\">        <span class=\"keyword\">return</span> out</span><br><span class=\"line\"></span><br><span class=\"line\">nonlinearity = partial(F.relu, _inplace_=<span class=\"literal\">True</span>)</span><br><span class=\"line\"><span class=\"keyword\">class</span> <span class=\"title class_\">DecoderBlock</span>(nn.Module):</span><br><span class=\"line\">    <span class=\"keyword\">def</span> <span class=\"title function_\">__init__</span>(<span class=\"params\">self, in_channels, n_filters</span>):</span><br><span class=\"line\">        <span class=\"built_in\">super</span>(DecoderBlock, <span class=\"variable language_\">self</span>).__init__()</span><br><span class=\"line\"></span><br><span class=\"line\">        <span class=\"variable language_\">self</span>.**conv1** = nn.Conv2d(in_channels, in_channels // <span class=\"number\">4</span>, <span class=\"number\">1</span>)</span><br><span class=\"line\">        <span class=\"variable language_\">self</span>.**norm1** = nn.BatchNorm2d(in_channels // <span class=\"number\">4</span>)</span><br><span class=\"line\">        <span class=\"variable language_\">self</span>.**relu1** = nonlinearity</span><br><span class=\"line\"></span><br><span class=\"line\">        <span class=\"variable language_\">self</span>.**deconv2** = nn.ConvTranspose2d(in_channels // <span class=\"number\">4</span>, in_channels // <span class=\"number\">4</span>, <span class=\"number\">3</span>, _stride_=<span class=\"number\">2</span>, _padding_=<span class=\"number\">1</span>, _output_padding_=<span class=\"number\">1</span>)</span><br><span class=\"line\">        <span class=\"variable language_\">self</span>.**norm2** = nn.BatchNorm2d(in_channels // <span class=\"number\">4</span>)</span><br><span class=\"line\">        <span class=\"variable language_\">self</span>.**relu2** = nonlinearity</span><br><span class=\"line\"></span><br><span class=\"line\">        <span class=\"variable language_\">self</span>.**conv3** = nn.Conv2d(in_channels // <span class=\"number\">4</span>, n_filters, <span class=\"number\">1</span>)</span><br><span class=\"line\">        <span class=\"variable language_\">self</span>.**norm3** = nn.BatchNorm2d(n_filters)</span><br><span class=\"line\">        <span class=\"variable language_\">self</span>.**relu3** = nonlinearity</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">def</span> <span class=\"title function_\">forward</span>(<span class=\"params\">self, x</span>):</span><br><span class=\"line\">        x = <span class=\"variable language_\">self</span>.**conv1**(x)</span><br><span class=\"line\">        x = <span class=\"variable language_\">self</span>.**norm1**(x)</span><br><span class=\"line\">        x = <span class=\"variable language_\">self</span>.**relu1**(x)</span><br><span class=\"line\">        x = <span class=\"variable language_\">self</span>.**deconv2**(x)</span><br><span class=\"line\">        x = <span class=\"variable language_\">self</span>.**norm2**(x)</span><br><span class=\"line\">        x = <span class=\"variable language_\">self</span>.**relu2**(x)</span><br><span class=\"line\">        x = <span class=\"variable language_\">self</span>.**conv3**(x)</span><br><span class=\"line\">        x = <span class=\"variable language_\">self</span>.**norm3**(x)</span><br><span class=\"line\">        x = <span class=\"variable language_\">self</span>.**relu3**(x)</span><br><span class=\"line\">        <span class=\"keyword\">return</span> x</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">class</span> <span class=\"title class_\">resnet34_unet</span>(nn.Module):</span><br><span class=\"line\">    <span class=\"keyword\">def</span> <span class=\"title function_\">__init__</span>(<span class=\"params\">self, num_classes=<span class=\"number\">1</span>, num_channels=<span class=\"number\">3</span>,pretrained=<span class=\"literal\">True</span></span>):</span><br><span class=\"line\">        <span class=\"built_in\">super</span>(resnet34_unet, <span class=\"variable language_\">self</span>).__init__()</span><br><span class=\"line\"></span><br><span class=\"line\">        filters = [<span class=\"number\">64</span>, <span class=\"number\">128</span>, <span class=\"number\">256</span>, <span class=\"number\">512</span>]</span><br><span class=\"line\">        resnet = models.resnet34(_pretrained_=pretrained)</span><br><span class=\"line\">        <span class=\"variable language_\">self</span>.**firstconv** = resnet.**conv1**</span><br><span class=\"line\">        <span class=\"variable language_\">self</span>.**firstbn** = resnet.**bn1**</span><br><span class=\"line\">        <span class=\"variable language_\">self</span>.**firstrelu** = resnet.**relu**</span><br><span class=\"line\">        <span class=\"variable language_\">self</span>.**firstmaxpool** = resnet.**maxpool**</span><br><span class=\"line\">        <span class=\"variable language_\">self</span>.**encoder1** = resnet.**layer1**</span><br><span class=\"line\">        <span class=\"variable language_\">self</span>.**encoder2** = resnet.**layer2**</span><br><span class=\"line\">        <span class=\"variable language_\">self</span>.**encoder3** = resnet.**layer3**</span><br><span class=\"line\">        <span class=\"variable language_\">self</span>.**encoder4** = resnet.**layer4**</span><br><span class=\"line\"></span><br><span class=\"line\">        <span class=\"variable language_\">self</span>.**decoder4** = DecoderBlock(<span class=\"number\">512</span>, filters[<span class=\"number\">2</span>])</span><br><span class=\"line\">        <span class=\"variable language_\">self</span>.**decoder3** = DecoderBlock(filters[<span class=\"number\">2</span>], filters[<span class=\"number\">1</span>])</span><br><span class=\"line\">        <span class=\"variable language_\">self</span>.**decoder2** = DecoderBlock(filters[<span class=\"number\">1</span>], filters[<span class=\"number\">0</span>])</span><br><span class=\"line\">        <span class=\"variable language_\">self</span>.**decoder1** = DecoderBlock(filters[<span class=\"number\">0</span>], filters[<span class=\"number\">0</span>])</span><br><span class=\"line\"></span><br><span class=\"line\">        <span class=\"variable language_\">self</span>.**decoder4** = DecoderBlock(<span class=\"number\">512</span>, filters[<span class=\"number\">2</span>])</span><br><span class=\"line\">        <span class=\"variable language_\">self</span>.**decoder3** = DecoderBlock(filters[<span class=\"number\">2</span>], filters[<span class=\"number\">1</span>])</span><br><span class=\"line\">        <span class=\"variable language_\">self</span>.**decoder2** = DecoderBlock(filters[<span class=\"number\">1</span>], filters[<span class=\"number\">0</span>])</span><br><span class=\"line\">        <span class=\"variable language_\">self</span>.**decoder1** = DecoderBlock(filters[<span class=\"number\">0</span>], filters[<span class=\"number\">0</span>])</span><br><span class=\"line\"></span><br><span class=\"line\">        <span class=\"variable language_\">self</span>.**finaldeconv1** = nn.ConvTranspose2d(filters[<span class=\"number\">0</span>], <span class=\"number\">32</span>, <span class=\"number\">4</span>, <span class=\"number\">2</span>, <span class=\"number\">1</span>)</span><br><span class=\"line\">        <span class=\"variable language_\">self</span>.**finalrelu1** = nonlinearity</span><br><span class=\"line\">        <span class=\"variable language_\">self</span>.**finalconv2** = nn.Conv2d(<span class=\"number\">32</span>, <span class=\"number\">32</span>, <span class=\"number\">3</span>, _padding_=<span class=\"number\">1</span>)</span><br><span class=\"line\">        <span class=\"variable language_\">self</span>.**finalrelu2** = nonlinearity</span><br><span class=\"line\">        <span class=\"variable language_\">self</span>.**finalconv3** = nn.Conv2d(<span class=\"number\">32</span>, num_classes, <span class=\"number\">3</span>, _padding_=<span class=\"number\">1</span>)</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">def</span> <span class=\"title function_\">forward</span>(<span class=\"params\">self, x</span>):</span><br><span class=\"line\">        _<span class=\"comment\"># Encoder_</span></span><br><span class=\"line\">        x = <span class=\"variable language_\">self</span>.**firstconv**(x)</span><br><span class=\"line\">        x = <span class=\"variable language_\">self</span>.**firstbn**(x)</span><br><span class=\"line\">        x = <span class=\"variable language_\">self</span>.**firstrelu**(x)</span><br><span class=\"line\">        x = <span class=\"variable language_\">self</span>.**firstmaxpool**(x)</span><br><span class=\"line\">        e1 = <span class=\"variable language_\">self</span>.**encoder1**(x)</span><br><span class=\"line\">        e2 = <span class=\"variable language_\">self</span>.**encoder2**(e1)</span><br><span class=\"line\">        e3 = <span class=\"variable language_\">self</span>.**encoder3**(e2)</span><br><span class=\"line\">        e4 = <span class=\"variable language_\">self</span>.**encoder4**(e3)</span><br><span class=\"line\"></span><br><span class=\"line\">        _<span class=\"comment\"># Center_</span></span><br><span class=\"line\"></span><br><span class=\"line\">        _<span class=\"comment\"># Decoder_</span></span><br><span class=\"line\">        d4 = <span class=\"variable language_\">self</span>.**decoder4**(e4) + e3</span><br><span class=\"line\">        d3 = <span class=\"variable language_\">self</span>.**decoder3**(d4) + e2</span><br><span class=\"line\">        d2 = <span class=\"variable language_\">self</span>.**decoder2**(d3) + e1</span><br><span class=\"line\">        d1 = <span class=\"variable language_\">self</span>.**decoder1**(d2)</span><br><span class=\"line\"></span><br><span class=\"line\">        out = <span class=\"variable language_\">self</span>.**finaldeconv1**(d1)</span><br><span class=\"line\">        out = <span class=\"variable language_\">self</span>.**finalrelu1**(out)</span><br><span class=\"line\">        out = <span class=\"variable language_\">self</span>.**finalconv2**(out)</span><br><span class=\"line\">        out = <span class=\"variable language_\">self</span>.**finalrelu2**(out)</span><br><span class=\"line\">        out = <span class=\"variable language_\">self</span>.**finalconv3**(out)</span><br><span class=\"line\"></span><br><span class=\"line\">        <span class=\"keyword\">return</span> nn.Sigmoid()(out)</span><br></pre></td></tr></table></figure>\n\n<h5 id=\"模型实现\"><a href=\"#模型实现\" class=\"headerlink\" title=\"模型实现\"></a>模型实现</h5><figure class=\"highlight python\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br><span class=\"line\">47</span><br><span class=\"line\">48</span><br><span class=\"line\">49</span><br><span class=\"line\">50</span><br><span class=\"line\">51</span><br><span class=\"line\">52</span><br><span class=\"line\">53</span><br><span class=\"line\">54</span><br><span class=\"line\">55</span><br><span class=\"line\">56</span><br><span class=\"line\">57</span><br><span class=\"line\">58</span><br><span class=\"line\">59</span><br><span class=\"line\">60</span><br><span class=\"line\">61</span><br><span class=\"line\">62</span><br><span class=\"line\">63</span><br><span class=\"line\">64</span><br><span class=\"line\">65</span><br><span class=\"line\">66</span><br><span class=\"line\">67</span><br><span class=\"line\">68</span><br><span class=\"line\">69</span><br><span class=\"line\">70</span><br><span class=\"line\">71</span><br><span class=\"line\">72</span><br><span class=\"line\">73</span><br><span class=\"line\">74</span><br><span class=\"line\">75</span><br><span class=\"line\">76</span><br><span class=\"line\">77</span><br><span class=\"line\">78</span><br><span class=\"line\">79</span><br><span class=\"line\">80</span><br><span class=\"line\">81</span><br><span class=\"line\">82</span><br><span class=\"line\">83</span><br><span class=\"line\">84</span><br><span class=\"line\">85</span><br><span class=\"line\">86</span><br><span class=\"line\">87</span><br><span class=\"line\">88</span><br><span class=\"line\">89</span><br><span class=\"line\">90</span><br><span class=\"line\">91</span><br><span class=\"line\">92</span><br><span class=\"line\">93</span><br><span class=\"line\">94</span><br><span class=\"line\">95</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">import</span> torch</span><br><span class=\"line\"><span class=\"keyword\">import</span> torch.nn <span class=\"keyword\">as</span> nn</span><br><span class=\"line\"><span class=\"keyword\">import</span> torch.nn.functional <span class=\"keyword\">as</span> F</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">class</span> <span class=\"title class_\">double_conv2d_bn</span>(nn.Module):</span><br><span class=\"line\">    <span class=\"keyword\">def</span> <span class=\"title function_\">__init__</span>(<span class=\"params\">self,in_channels,out_channels,kernel_size=<span class=\"number\">3</span>,strides=<span class=\"number\">1</span>,padding=<span class=\"number\">1</span></span>):</span><br><span class=\"line\">        <span class=\"built_in\">super</span>(double_conv2d_bn,<span class=\"variable language_\">self</span>).__init__()</span><br><span class=\"line\">        <span class=\"variable language_\">self</span>.conv1 = nn.Conv2d(in_channels,out_channels,</span><br><span class=\"line\">                               kernel_size=kernel_size,</span><br><span class=\"line\">                              stride = strides,padding=padding,bias=<span class=\"literal\">True</span>)</span><br><span class=\"line\">        <span class=\"variable language_\">self</span>.conv2 = nn.Conv2d(out_channels,out_channels,</span><br><span class=\"line\">                              kernel_size = kernel_size,</span><br><span class=\"line\">                              stride = strides,padding=padding,bias=<span class=\"literal\">True</span>)</span><br><span class=\"line\">        <span class=\"variable language_\">self</span>.bn1 = nn.BatchNorm2d(out_channels)</span><br><span class=\"line\">        <span class=\"variable language_\">self</span>.bn2 = nn.BatchNorm2d(out_channels)</span><br><span class=\"line\">  </span><br><span class=\"line\">    <span class=\"keyword\">def</span> <span class=\"title function_\">forward</span>(<span class=\"params\">self,x</span>):</span><br><span class=\"line\">        out = F.relu(<span class=\"variable language_\">self</span>.bn1(<span class=\"variable language_\">self</span>.conv1(x)))</span><br><span class=\"line\">        out = F.relu(<span class=\"variable language_\">self</span>.bn2(<span class=\"variable language_\">self</span>.conv2(out)))</span><br><span class=\"line\">        <span class=\"keyword\">return</span> out</span><br><span class=\"line\">  </span><br><span class=\"line\"><span class=\"keyword\">class</span> <span class=\"title class_\">deconv2d_bn</span>(nn.Module):</span><br><span class=\"line\">    <span class=\"keyword\">def</span> <span class=\"title function_\">__init__</span>(<span class=\"params\">self,in_channels,out_channels,kernel_size=<span class=\"number\">2</span>,strides=<span class=\"number\">2</span></span>):</span><br><span class=\"line\">        <span class=\"built_in\">super</span>(deconv2d_bn,<span class=\"variable language_\">self</span>).__init__()</span><br><span class=\"line\">        <span class=\"variable language_\">self</span>.conv1 = nn.ConvTranspose2d(in_channels,out_channels,</span><br><span class=\"line\">                                        kernel_size = kernel_size,</span><br><span class=\"line\">                                       stride = strides,bias=<span class=\"literal\">True</span>)</span><br><span class=\"line\">        <span class=\"variable language_\">self</span>.bn1 = nn.BatchNorm2d(out_channels)</span><br><span class=\"line\">      </span><br><span class=\"line\">    <span class=\"keyword\">def</span> <span class=\"title function_\">forward</span>(<span class=\"params\">self,x</span>):</span><br><span class=\"line\">        out = F.relu(<span class=\"variable language_\">self</span>.bn1(<span class=\"variable language_\">self</span>.conv1(x)))</span><br><span class=\"line\">        <span class=\"keyword\">return</span> out</span><br><span class=\"line\">  </span><br><span class=\"line\"><span class=\"keyword\">class</span> <span class=\"title class_\">Unet</span>(nn.Module):</span><br><span class=\"line\">    <span class=\"keyword\">def</span> <span class=\"title function_\">__init__</span>(<span class=\"params\">self</span>):</span><br><span class=\"line\">        <span class=\"built_in\">super</span>(Unet,<span class=\"variable language_\">self</span>).__init__()</span><br><span class=\"line\">        <span class=\"variable language_\">self</span>.layer1_conv = double_conv2d_bn(<span class=\"number\">1</span>,<span class=\"number\">8</span>)</span><br><span class=\"line\">        <span class=\"variable language_\">self</span>.layer2_conv = double_conv2d_bn(<span class=\"number\">8</span>,<span class=\"number\">16</span>)</span><br><span class=\"line\">        <span class=\"variable language_\">self</span>.layer3_conv = double_conv2d_bn(<span class=\"number\">16</span>,<span class=\"number\">32</span>)</span><br><span class=\"line\">        <span class=\"variable language_\">self</span>.layer4_conv = double_conv2d_bn(<span class=\"number\">32</span>,<span class=\"number\">64</span>)</span><br><span class=\"line\">        <span class=\"variable language_\">self</span>.layer5_conv = double_conv2d_bn(<span class=\"number\">64</span>,<span class=\"number\">128</span>)</span><br><span class=\"line\">        <span class=\"variable language_\">self</span>.layer6_conv = double_conv2d_bn(<span class=\"number\">128</span>,<span class=\"number\">64</span>)</span><br><span class=\"line\">        <span class=\"variable language_\">self</span>.layer7_conv = double_conv2d_bn(<span class=\"number\">64</span>,<span class=\"number\">32</span>)</span><br><span class=\"line\">        <span class=\"variable language_\">self</span>.layer8_conv = double_conv2d_bn(<span class=\"number\">32</span>,<span class=\"number\">16</span>)</span><br><span class=\"line\">        <span class=\"variable language_\">self</span>.layer9_conv = double_conv2d_bn(<span class=\"number\">16</span>,<span class=\"number\">8</span>)</span><br><span class=\"line\">        <span class=\"variable language_\">self</span>.layer10_conv = nn.Conv2d(<span class=\"number\">8</span>,<span class=\"number\">1</span>,kernel_size=<span class=\"number\">3</span>,</span><br><span class=\"line\">                                     stride=<span class=\"number\">1</span>,padding=<span class=\"number\">1</span>,bias=<span class=\"literal\">True</span>)</span><br><span class=\"line\">      </span><br><span class=\"line\">        <span class=\"variable language_\">self</span>.deconv1 = deconv2d_bn(<span class=\"number\">128</span>,<span class=\"number\">64</span>)</span><br><span class=\"line\">        <span class=\"variable language_\">self</span>.deconv2 = deconv2d_bn(<span class=\"number\">64</span>,<span class=\"number\">32</span>)</span><br><span class=\"line\">        <span class=\"variable language_\">self</span>.deconv3 = deconv2d_bn(<span class=\"number\">32</span>,<span class=\"number\">16</span>)</span><br><span class=\"line\">        <span class=\"variable language_\">self</span>.deconv4 = deconv2d_bn(<span class=\"number\">16</span>,<span class=\"number\">8</span>)</span><br><span class=\"line\">      </span><br><span class=\"line\">        <span class=\"variable language_\">self</span>.sigmoid = nn.Sigmoid()</span><br><span class=\"line\">      </span><br><span class=\"line\">    <span class=\"keyword\">def</span> <span class=\"title function_\">forward</span>(<span class=\"params\">self,x</span>):</span><br><span class=\"line\">        conv1 = <span class=\"variable language_\">self</span>.layer1_conv(x)</span><br><span class=\"line\">        pool1 = F.max_pool2d(conv1,<span class=\"number\">2</span>)</span><br><span class=\"line\">      </span><br><span class=\"line\">        conv2 = <span class=\"variable language_\">self</span>.layer2_conv(pool1)</span><br><span class=\"line\">        pool2 = F.max_pool2d(conv2,<span class=\"number\">2</span>)</span><br><span class=\"line\">      </span><br><span class=\"line\">        conv3 = <span class=\"variable language_\">self</span>.layer3_conv(pool2)</span><br><span class=\"line\">        pool3 = F.max_pool2d(conv3,<span class=\"number\">2</span>)</span><br><span class=\"line\">      </span><br><span class=\"line\">        conv4 = <span class=\"variable language_\">self</span>.layer4_conv(pool3)</span><br><span class=\"line\">        pool4 = F.max_pool2d(conv4,<span class=\"number\">2</span>)</span><br><span class=\"line\">      </span><br><span class=\"line\">        conv5 = <span class=\"variable language_\">self</span>.layer5_conv(pool4)</span><br><span class=\"line\">      </span><br><span class=\"line\">        convt1 = <span class=\"variable language_\">self</span>.deconv1(conv5)</span><br><span class=\"line\">        concat1 = torch.cat([convt1,conv4],dim=<span class=\"number\">1</span>)</span><br><span class=\"line\">        conv6 = <span class=\"variable language_\">self</span>.layer6_conv(concat1)</span><br><span class=\"line\">      </span><br><span class=\"line\">        convt2 = <span class=\"variable language_\">self</span>.deconv2(conv6)</span><br><span class=\"line\">        concat2 = torch.cat([convt2,conv3],dim=<span class=\"number\">1</span>)</span><br><span class=\"line\">        conv7 = <span class=\"variable language_\">self</span>.layer7_conv(concat2)</span><br><span class=\"line\">      </span><br><span class=\"line\">        convt3 = <span class=\"variable language_\">self</span>.deconv3(conv7)</span><br><span class=\"line\">        concat3 = torch.cat([convt3,conv2],dim=<span class=\"number\">1</span>)</span><br><span class=\"line\">        conv8 = <span class=\"variable language_\">self</span>.layer8_conv(concat3)</span><br><span class=\"line\">      </span><br><span class=\"line\">        convt4 = <span class=\"variable language_\">self</span>.deconv4(conv8)</span><br><span class=\"line\">        concat4 = torch.cat([convt4,conv1],dim=<span class=\"number\">1</span>)</span><br><span class=\"line\">        conv9 = <span class=\"variable language_\">self</span>.layer9_conv(concat4)</span><br><span class=\"line\">        outp = <span class=\"variable language_\">self</span>.layer10_conv(conv9)</span><br><span class=\"line\">        outp = <span class=\"variable language_\">self</span>.sigmoid(outp)</span><br><span class=\"line\">        <span class=\"keyword\">return</span> outp</span><br><span class=\"line\">  </span><br><span class=\"line\"></span><br><span class=\"line\">model = Unet()</span><br><span class=\"line\">inp = torch.rand(<span class=\"number\">10</span>,<span class=\"number\">1</span>,<span class=\"number\">224</span>,<span class=\"number\">224</span>)</span><br><span class=\"line\">outp = model(inp)</span><br><span class=\"line\"><span class=\"built_in\">print</span>(outp.shape)</span><br><span class=\"line\">==&gt; torch.Size([<span class=\"number\">10</span>, <span class=\"number\">1</span>, <span class=\"number\">224</span>, <span class=\"number\">224</span>])</span><br></pre></td></tr></table></figure>\n\n<h4 id=\"相关资源-1\"><a href=\"#相关资源-1\" class=\"headerlink\" title=\"相关资源\"></a>相关资源</h4><h5 id=\"项目\"><a href=\"#项目\" class=\"headerlink\" title=\"项目\"></a>项目</h5><blockquote>\n<p><a href=\"https://github.com/Andy-zhujunwen/UNET-ZOO?tab=readme-ov-file%60\">https://github.com/Andy-zhujunwen/UNET-ZOO?tab=readme-ov-file`</a><br><code> https://github.com/bigmb/Unet-Segmentation-Pytorch-Nest-of-Unets</code><br><code> https://www.codewithgpu.com/i/bubbliiiing/unet-pytorch/UNet-PyTorch</code><br>&#96;<br><a href=\"https://huggingface.co/spaces/h2chen/demo_unet\">https://huggingface.co/spaces/h2chen/demo_unet</a></p>\n</blockquote>\n<h5 id=\"博客\"><a href=\"#博客\" class=\"headerlink\" title=\"博客\"></a>博客</h5><blockquote>\n<p><a href=\"https://blog.csdn.net/weixin_45074568/article/details/114901600\">UNet详解（附图文和代码实现）-CSDN博客</a><code>&lt;br&gt;</code><br><a href=\"https://www.cnblogs.com/PythonLearner/p/14041874.html\">图像分割必备知识点 | Unet详解 理论+ 代码 - 忽逢桃林 - 博客园</a></p>\n</blockquote>\n<hr>\n"},{"title":"实例分割","date":"2025-02-15T16:00:00.000Z","_content":"\n# **实例分割（Instance Segmentation）**\n\n## ** 定义**\n\n实例分割是目标检测和语义分割的结合，旨在精确识别图像中的每个目标对象，并区分同一类别中的不同实例。例如，在一张包含多个人的图像中，实例分割不仅需要识别出“人”这一类别，还需要将每个人单独区分开来，为每个人生成独立的分割掩码（Mask）。\n\n实例分割通过融合目标检测和语义分割的结果来实现这一目标。具体而言，它利用目标检测提供的目标类别和位置信息（如边界框和置信度），从语义分割的结果中提取出对应目标的像素级掩码。简而言之，实例分割的任务是将同一类别中的具体对象（即实例）分别分割出来。\n\n举个例子,近年来，随着自动驾驶等领域的快速发展，实例分割任务受到了广泛关注。自动驾驶场景中，精确区分和分割道路上的行人、车辆等目标对于环境感知和决策至关重要。此外，一些实例分割任务还会输出检测结果（如边界框），以提供更全面的目标描述。\n\n对实例分割、语义分割和目标检测混合任务感兴趣的读者，可以参考 CVPR 2019 的论文《Hybrid Task Cascade》（HTC），该研究提出了一种混合任务级联框架，能够同时处理这三种任务，为多任务学习提供了新的思路。\n\n## **特点**\n\n- 能够精确地定位和区分同一类别的不同实例。\n- 计算成本较高，因为需要对每个目标实例进行单独检测和分类。\n\n## ** 应用**\n\n实例分割在以下领域有重要应用：\n\n- **自动驾驶**：用于检测和分割车辆、行人。\n- **医学成像**：用于检测组织和病理的特定边界。\n- **机器人视觉**：用于识别和隔离目标物体。\n\n## ** 常见模型**\n\n### **Mask R-CNN**\n\n- **优点**：能够同时进行目标检测和语义分割，具有较好的性能。\n- **缺点**：模型参数多，训练和推理速度较慢；大目标的边缘分割较为粗糙。\n\n#### 提出初衷\n\nMask R-CNN 是 2017 年发表的文章，一作是何恺明大神，没错就是那个男人，除此之外还有 Faster R-CNN 系列的大神 Ross Girshick，可以说是强强联合。该论文也获得了 ICCV 2017 的最佳论文奖（Marr Prize）。并且该网络提出后，又霸榜了 MS COCO 的各项任务，包括目标检测、实例分割以及人体关键点检测任务。Mask R-CNN 的结构很简洁而且很灵活效果又很好（仅仅是在 Faster R-CNN 的基础上根据需求加入一些新的分支）。\nMask R-CNN 的提出初衷是为了实现高效且精确的实例分割任务，同时继承 Faster R-CNN 在目标检测方面的优势。具体而言，Mask R-CNN 的核心动机是将目标检测与语义分割相结合，既能检测图像中的目标并定位其边界框，又能为每个目标生成精确的像素级分割掩码。此外，Mask R-CNN 通过引入 RoI Align 技术，解决了 Faster R-CNN 中 RoI Pooling 导致的特征图与原始图像区域对齐不精确的问题，显著提高了分割掩码的精度。Mask R-CNN 在 Faster R-CNN 的基础上增加了全卷积网络（FCN）分支，用于预测每个感兴趣区域（RoI）的分割掩码，这种设计不仅简单高效，且只增加了较小的计算开销。\n![1740407201646JSjbb2yMTo66D3xSrKfcVwQCnSc.png](https://tk-pichost-1325224430.cos.ap-chengdu.myqcloud.com/blog/1740407201646JSjbb2yMTo66D3xSrKfcVwQCnSc.png)\n它还具备良好的多任务扩展性，能够轻松扩展到其他任务（如人体关键点检测），成为一种通用的视觉框架。通过为每个类别预测独立的二元掩码，Mask R-CNN 能够更好地提取目标的空间布局信息，从而生成更精确的分割掩码，并在 COCO 等数据集上取得了显著优于当时其他模型的性能。总之，Mask R-CNN 的提出填补了目标检测和语义分割之间的空白，提供了一种高精度、高效率的实例分割解决方案。\n![1740407212685Z2kFbwjzroUn5Xx4JNDcueDNnK2.png](https://tk-pichost-1325224430.cos.ap-chengdu.myqcloud.com/blog/1740407212685Z2kFbwjzroUn5Xx4JNDcueDNnK2.png)\nMask R-CNN 的提出初衷是为了实现高效且精确的实例分割任务，同时继承 Faster R-CNN 在目标检测方面的优势。具体动机和背景如下：\n\n1. **结合目标检测与语义分割**\n   在 Mask R-CNN 提出之前，目标检测（如 Faster R-CNN）和语义分割（如 FCN）是两个独立的领域。Mask R-CNN 的核心动机是将两者结合起来，既能够检测图像中的目标并定位其边界框，还能为每个目标生成精确的像素级分割掩码。\n2. **解决像素级对齐问题**\n   Faster R-CNN 在处理像素级任务时存在局限性，尤其是其 RoI Pooling 操作会导致特征图与原始图像区域的对齐不精确。Mask R-CNN 通过引入 RoI Align 技术，解决了这一问题，显著提高了分割掩码的精度。\n3. **简单高效的架构设计**\n   Mask R-CNN 在 Faster R-CNN 的基础上，增加了一个全卷积网络（FCN）分支，用于预测每个感兴趣区域（RoI）的分割掩码。这种设计不仅简单高效，而且只增加了较小的计算开销。\n4. **多任务学习的扩展性**\n   Mask R-CNN 不仅适用于实例分割，还可以轻松扩展到其他任务，如人体关键点检测。这种多任务扩展性使其成为一种通用的视觉框架。\n5. **提升实例分割精度**\n   通过为每个类别预测独立的二元掩码，Mask R-CNN 能够更好地提取目标的空间布局信息，从而生成更精确的分割掩码。这一改进使其在 COCO 等数据集上取得了显著优于当时其他模型的性能。\n\n#### 网络结构\n\nMask R-CNN 的结构也很简单，就是在通过 RoIAlign（在原 Faster R-CNN 中是 RoIPool）得到的 RoI 基础上并行添加一个 Mask 分支（小型的 FCN）。见下图，之前 Faster R-CNN 是在 RoI 基础上接上一个 Fast R-CNN 检测头，即图中 class, box 分支，现在又并行了一个 Mask 分支。\n![1740407241647NcMPbytf4o9G40xNM1UcgSMbn4f.png](https://tk-pichost-1325224430.cos.ap-chengdu.myqcloud.com/blog/1740407241647NcMPbytf4o9G40xNM1UcgSMbn4f.png)\n\n![1740407249647WI67bCnZrobIRSx9aWhclwDEnlj.png](https://tk-pichost-1325224430.cos.ap-chengdu.myqcloud.com/blog/1740407249647WI67bCnZrobIRSx9aWhclwDEnlj.png)\n注意带和不带 FPN 结构的 Mask R-CNN 在 Mask 分支上略有不同，对于带有 FPN 结构的 Mask R-CNN 它的 class、box 分支和 Mask 分支并不是共用一个 RoIAlign。在训练过程中，对于 class, box 分支 RoIAlign 将 RPN（Region Proposal Network）得到的 Proposals 池化到 7x7 大小，而对于 Mask 分支 RoIAlign 将 Proposals 池化到 14x14 大小。\n![1740407261695EyHvbUkC0ouDKnxVfEGcm0iKnKd.png](https://tk-pichost-1325224430.cos.ap-chengdu.myqcloud.com/blog/1740407261695EyHvbUkC0ouDKnxVfEGcm0iKnKd.png)\n\n![1740407267643MVthb679voUnaYxQpPBcDtJCnIf.png](https://tk-pichost-1325224430.cos.ap-chengdu.myqcloud.com/blog/1740407267643MVthb679voUnaYxQpPBcDtJCnIf.png)\n\n> Q:**Mask R-CNN 中的 RoI Align 技术是如何解决 Faster R-CNN 中 RoI Pooling 导致的特征图与原始图像区域对齐不精确的问题的呢？**\n\n#### 模型代码\n\n```python\n\"\"\"\nModel definitions\n\n\"\"\"\nfrom torch.autograd import Variable\nimport torch.nn as nn\nimport torch.nn.functional as F\nimport torch\nimport numpy as np\nimport math\n\nfrom model.resnet import resnet50\nfrom model.rpn import RPN\n#from model.lib.roi_align.roi_align.roi_align import RoIAlign\nfrom model.lib.roi_align.roi_align.crop_and_resize import CropAndResize\nfrom model.lib.bbox.generate_anchors import generate_pyramid_anchors\nfrom model.lib.bbox.nms import torch_nms as nms\n\n\ndef log2_graph(x):\n    \"\"\"Implementatin of Log2. pytorch doesn't have a native implemenation.\"\"\"\n    return torch.div(torch.log(x), math.log(2.))\n\n\ndef ROIAlign(feature_maps, rois, config, pool_size, mode='bilinear'):\n    \"\"\"Implements ROI Align on the features.\n    Params:\n    - pool_shape: [height, width] of the output pooled regions. Usually [7, 7]\n    - image_shape: [height, width, chanells]. Shape of input image in pixels\n    Inputs:\n    - boxes: [batch, num_boxes, (x1, y1, x2, y2)] in normalized\n             coordinates. Possibly padded with zeros if not enough\n             boxes to fill the array.\n    - Feature maps: List of feature maps from different levels of the pyramid.\n                    Each is [batch, channels, height, width]\n    Output:\n    Pooled regions in the shape: [batch, num_boxes, height, width, channels].\n    The width and height are those specific in the pool_shape in the layer\n    constructor.\n    \"\"\"\n    \"\"\"\n    [  x2-x1             x1 + x2 - W + 1  ]\n    [  -----      0      ---------------  ]\n    [  W - 1                  W - 1       ]\n    [                                     ]\n    [           y2-y1    y1 + y2 - H + 1  ]\n    [    0      -----    ---------------  ]\n    [           H - 1         H - 1      ]\n    \"\"\"\n    #feature_maps= [P2, P3, P4, P5]\n    rois = rois.detach()\n    crop_resize = CropAndResize(pool_size, pool_size, 0)\n\n    roi_number = rois.size()[1]\n\n    pooled = rois.data.new(\n            config.IMAGES_PER_GPU*rois.size(\n            1), 256, pool_size, pool_size).zero_()\n\n    rois = rois.view(\n            config.IMAGES_PER_GPU*rois.size(1),\n            4)\n\n    # Loop through levels and apply ROI pooling to each. P2 to P5.\n    x_1 = rois[:, 0]\n    y_1 = rois[:, 1]\n    x_2 = rois[:, 2]\n    y_2 = rois[:, 3]\n\n    roi_level = log2_graph(\n        torch.div(torch.sqrt((y_2 - y_1) * (x_2 - x_1)), 224.0))\n\n    roi_level = torch.clamp(torch.clamp(\n        torch.add(torch.round(roi_level), 4), min=2), max=5)\n\n    # P2 is 256x256, P3 is 128x128, P4 is 64x64, P5 is 32x32\n    # P2 is 4, P3 is 8, P4 is 16, P5 is 32\n    for i, level in enumerate(range(2, 6)):\n\n        scaling_ratio = 2**level\n\n        height = float(config.IMAGE_MAX_DIM)/ scaling_ratio\n        width = float(config.IMAGE_MAX_DIM) / scaling_ratio\n\n        ixx = torch.eq(roi_level, level)\n\n        box_indices = ixx.view(-1).int() * 0\n        ix = torch.unsqueeze(ixx, 1)\n        level_boxes = torch.masked_select(rois, ix)\n        if level_boxes.size()[0] == 0:\n            continue\n        level_boxes = level_boxes.view(-1, 4)\n\n        crops = crop_resize(feature_maps[i], torch.div(\n                level_boxes, float(config.IMAGE_MAX_DIM)\n                )[:, [1, 0, 3, 2]], box_indices)\n\n        indices_pooled = ixx.nonzero()[:, 0]\n        pooled[indices_pooled.data, :, :, :] = crops.data\n\n    pooled = pooled.view(config.IMAGES_PER_GPU, roi_number,\n               256, pool_size, pool_size)\n    pooled = Variable(pooled).cuda()\n    return pooled\n\n\n# ---------------------------------------------------------------\n# Heads\n\nclass MaskHead(nn.Module):\n\n    def __init__(self, config):\n        super(MaskHead, self).__init__()\n        self.config = config\n        self.num_classes = config.NUM_CLASSES\n        #self.crop_size = config.mask_crop_size\n\n        #self.roi_align = RoIAlign(self.crop_size, self.crop_size)\n        self.conv1 = nn.Conv2d(256, 256, kernel_size=3, padding=1, stride=1)\n        self.bn1 = nn.BatchNorm2d(256)\n        self.conv2 = nn.Conv2d(256, 256, kernel_size=3, padding=1, stride=1)\n        self.bn2 = nn.BatchNorm2d(256)\n        self.conv3 = nn.Conv2d(256, 256, kernel_size=3, padding=1, stride=1)\n        self.bn3 = nn.BatchNorm2d(256)\n        self.conv4 = nn.Conv2d(256, 256, kernel_size=3, padding=1, stride=1)\n        self.bn4 = nn.BatchNorm2d(256)\n\n        self.deconv = nn.ConvTranspose2d(256, 256, kernel_size=4, padding=1, stride=2, bias=False)\n        self.mask = nn.Conv2d(256, self.num_classes, kernel_size=1, padding=0, stride=1)\n\n    def forward(self, x, rpn_rois):\n        #x = self.roi_align(x, rpn_rois)\n        x = ROIAlign(x, rpn_rois, self.config, self.config.MASK_POOL_SIZE)\n\n        roi_number = x.size()[1]\n\n        # merge batch and roi number together\n        x = x.view(self.config.IMAGES_PER_GPU * roi_number,\n                   256, self.config.MASK_POOL_SIZE,\n                   self.config.MASK_POOL_SIZE)\n\n        x = F.relu(self.bn1(self.conv1(x)), inplace=True)\n        x = F.relu(self.bn2(self.conv2(x)), inplace=True)\n        x = F.relu(self.bn3(self.conv3(x)), inplace=True)\n        x = F.relu(self.bn4(self.conv4(x)), inplace=True)\n        x = self.deconv(x)\n        rcnn_mask_logits = self.mask(x)\n\n        rcnn_mask_logits = rcnn_mask_logits.view(self.config.IMAGES_PER_GPU,\n                                                 roi_number,\n                                                 self.config.NUM_CLASSES,\n                                                 self.config.MASK_POOL_SIZE * 2,\n                                                 self.config.MASK_POOL_SIZE * 2)\n\n        return rcnn_mask_logits\n\n\nclass RCNNHead(nn.Module):\n    def __init__(self, config):\n        super(RCNNHead, self).__init__()\n        self.config = config\n        self.num_classes = config.NUM_CLASSES\n        #self.crop_size = config.rcnn_crop_size\n\n        #self.roi_align = RoIAlign(self.crop_size, self.crop_size)\n        self.fc1 = nn.Linear(1024, 1024)\n        self.fc2 = nn.Linear(1024, 1024)\n        self.class_logits = nn.Linear(1024, self.num_classes)\n        self.bbox = nn.Linear(1024, self.num_classes * 4)\n\n        self.conv1 = nn.Conv2d(256, 1024, kernel_size=self.config.POOL_SIZE, stride=1, padding=0)\n        self.bn1 = nn.BatchNorm2d(1024, eps=0.001)\n\n    def forward(self, x, rpn_rois):\n        x = ROIAlign(x, rpn_rois, self.config, self.config.POOL_SIZE)\n        roi_number = x.size()[1]\n\n        x = x.view(self.config.IMAGES_PER_GPU * roi_number,\n                   256, self.config.POOL_SIZE,\n                   self.config.POOL_SIZE)\n        #print(x.shape)\n        #x = self.roi_align(x, rpn_rois, self.config, self.config.POOL_SIZE)\n        #x = crops.view(crops.size(0), -1)\n        x = self.bn1(self.conv1(x))\n        x = x.permute(0, 2, 3, 1).contiguous().view(x.size(0), -1)\n        x = F.relu(self.fc1(x), inplace=True)\n        x = F.relu(self.fc2(x), inplace=True)\n        #x = F.dropout(x, 0.5, training=self.training)\n        rcnn_class_logits = self.class_logits(x)\n        rcnn_probs = F.softmax(rcnn_class_logits, dim=-1)\n\n        rcnn_bbox = self.bbox(x)\n\n        rcnn_class_logits = rcnn_class_logits.view(self.config.IMAGES_PER_GPU,\n                                                   roi_number,\n                                                   rcnn_class_logits.size()[-1])\n\n        rcnn_probs = rcnn_probs.view(self.config.IMAGES_PER_GPU,\n                                     roi_number,\n                                     rcnn_probs.size()[-1])\n\n        rcnn_bbox = rcnn_bbox.view(self.config.IMAGES_PER_GPU,\n                                   roi_number,\n                                   self.config.NUM_CLASSES,\n                                   4)\n\n        return rcnn_class_logits, rcnn_probs, rcnn_bbox\n\n\n#\n# ---------------------------------------------------------------\n# Mask R-CNN\n\nclass MaskRCNN(nn.Module):\n    \"\"\"\n    Mask R-CNN model\n    \"\"\"\n\n    def __init__(self, config):\n        super(MaskRCNN, self).__init__()\n        self.config = config\n        self.__mode = 'train'\n        feature_channels = 128\n        # define modules (set of layers)\n#        self.feature_net = FeatureNet(cfg, 3, feature_channels)\n        self.feature_net = resnet50().cuda()\n        #self.rpn_head = RpnMultiHead(cfg,feature_channels)\n        self.rpn = RPN(256, len(self.config.RPN_ANCHOR_RATIOS),\n                             self.config.RPN_ANCHOR_STRIDE)\n        #self.rcnn_crop = CropRoi(cfg, cfg.rcnn_crop_size)\n        self.rcnn_head = RCNNHead(config)\n        #self.mask_crop = CropRoi(cfg, cfg.mask_crop_size)\n        self.mask_head = MaskHead(config)\n\n        self.anchors = generate_pyramid_anchors(self.config.RPN_ANCHOR_SCALES,\n                                                self.config.RPN_ANCHOR_RATIOS,\n                                                self.config.BACKBONE_SHAPES,\n                                                self.config.BACKBONE_STRIDES,\n                                                self.config.RPN_ANCHOR_STRIDE)\n        self.anchors = self.anchors.astype(np.float32)\n        self.proposal_count = self.config.POST_NMS_ROIS_TRAINING\n        # FPN\n        self.fpn_c5p5 = nn.Conv2d(\n            512 * 4, 256, kernel_size=1, stride=1, padding=0)\n        self.fpn_c4p4 = nn.Conv2d(\n            256 * 4, 256, kernel_size=1, stride=1, padding=0)\n        self.fpn_c3p3 = nn.Conv2d(\n            128 * 4, 256, kernel_size=1, stride=1, padding=0)\n        self.fpn_c2p2 = nn.Conv2d(\n            64 * 4, 256, kernel_size=1, stride=1,  padding=0)\n\n        self.fpn_p2 = nn.Conv2d(256, 256, kernel_size=3, stride=1, padding=1)\n        self.fpn_p3 = nn.Conv2d(256, 256, kernel_size=3, stride=1, padding=1)\n        self.fpn_p4 = nn.Conv2d(256, 256, kernel_size=3, stride=1, padding=1)\n        self.fpn_p5 = nn.Conv2d(256, 256, kernel_size=3, stride=1, padding=1)\n\n        self.scale_ratios = [4, 8, 16, 32]\n        self.fpn_p6 = nn.MaxPool2d(\n            kernel_size=1, stride=2, padding=0, ceil_mode=False)\n\n    def forward(self, x):\n        # Extract features\n        C1, C2, C3, C4, C5 = self.feature_net(x)\n        P5 = self.fpn_c5p5(C5)\n        P4 = self.fpn_c4p4(C4) + F.upsample(P5,\n                                            scale_factor=2, mode='bilinear')\n        P3 = self.fpn_c3p3(C3) + F.upsample(P4,\n                                            scale_factor=2, mode='bilinear')\n        P2 = self.fpn_c2p2(C2) + F.upsample(P3,\n                                            scale_factor=2, mode='bilinear')\n\n        # Attach 3x3 conv to all P layers to get the final feature maps.\n        # P2 is 256, P3 is 128, P4 is 64, P5 is 32\n        P2 = self.fpn_p2(P2)\n        P3 = self.fpn_p3(P3)\n        P4 = self.fpn_p4(P4)\n        P5 = self.fpn_p5(P5)\n        # P6 is used for the 5th anchor scale in RPN. Generated by\n        # subsampling from P5 with stride of 2.\n        P6 = self.fpn_p6(P5)\n\n        # Note that P6 is used in RPN, but not in the classifier heads.\n        rpn_feature_maps = [P2, P3, P4, P5, P6]\n\n        self.mrcnn_feature_maps = [P2, P3, P4, P5]\n\n        rpn_class_logits_outputs = []\n        rpn_class_outputs = []\n        rpn_bbox_outputs = []\n        # RPN proposals\n        for feature in rpn_feature_maps:\n            rpn_class_logits, rpn_probs, rpn_bbox = self.rpn(feature)\n            rpn_class_logits_outputs.append(rpn_class_logits)\n            rpn_class_outputs.append(rpn_probs)\n            rpn_bbox_outputs.append(rpn_bbox)\n\n        rpn_class_logits = torch.cat(rpn_class_logits_outputs, dim=1)\n        rpn_class = torch.cat(rpn_class_outputs, dim=1)\n        rpn_bbox = torch.cat(rpn_bbox_outputs, dim=1)\n\n        rpn_proposals = self.proposal_layer(rpn_class, rpn_bbox)\n\n        # RCNN proposals\n        rcnn_class_logits, rcnn_class, rcnn_bbox = self.rcnn_head(self.mrcnn_feature_maps, rpn_proposals)\n        rcnn_mask_logits = self.mask_head(self.mrcnn_feature_maps, rpn_proposals)\n        # <todo> mask nms\n\n        return [rpn_class_logits, rpn_class, rpn_bbox, rpn_proposals,\n                rcnn_class_logits, rcnn_class, rcnn_bbox,\n                rcnn_mask_logits]\n\n    def proposal_layer(self, rpn_class, rpn_bbox):\n        # handling proposals\n        scores = rpn_class[:, :, 1]\n        #print(scores.shape)\n        # Box deltas [batch, num_rois, 4]\n        deltas_mul = Variable(torch.from_numpy(np.reshape(\n            self.config.RPN_BBOX_STD_DEV, [1, 1, 4]).astype(np.float32))).cuda()\n        deltas = rpn_bbox * deltas_mul\n\n        pre_nms_limit = min(6000, self.anchors.shape[0])\n\n        scores, ix = torch.topk(scores, pre_nms_limit, dim=-1,\n                                largest=True, sorted=True)\n\n        ix = torch.unsqueeze(ix, 2)\n        ix = torch.cat([ix, ix, ix, ix], dim=2)\n        deltas = torch.gather(deltas, 1, ix)\n\n        _anchors = []\n        for i in range(self.config.IMAGES_PER_GPU):\n            anchors = Variable(torch.from_numpy(\n                self.anchors.astype(np.float32))).cuda()\n            _anchors.append(anchors)\n        anchors = torch.stack(_anchors, 0)\n\n        pre_nms_anchors = torch.gather(anchors, 1, ix)\n        refined_anchors = apply_box_deltas_graph(pre_nms_anchors, deltas)\n\n        # Clip to image boundaries. [batch, N, (y1, x1, y2, x2)]\n        height, width = self.config.IMAGE_SHAPE[:2]\n        window = np.array([0, 0, height, width]).astype(np.float32)\n        window = Variable(torch.from_numpy(window)).cuda()\n\n        refined_anchors_clipped = clip_boxes_graph(refined_anchors, window)\n\n        refined_proposals = []\n        scores = scores[:,:,None]\n        #print(scores.data.shape)\n        #print(refined_anchors_clipped.data.shape)\n        for i in range(self.config.IMAGES_PER_GPU):\n            indices = nms(\n                torch.cat([refined_anchors_clipped.data[i], scores.data[i]], 1), 0.7)\n            indices = indices[:self.proposal_count]\n            indices = torch.stack([indices, indices, indices, indices], dim=1)\n            indices = Variable(indices).cuda()\n            proposals = torch.gather(refined_anchors_clipped[i], 0, indices)\n            padding = self.proposal_count - proposals.size()[0]\n            proposals = torch.cat(\n                [proposals, Variable(torch.zeros([padding, 4])).cuda()], 0)\n            refined_proposals.append(proposals)\n\n        rpn_rois = torch.stack(refined_proposals, 0)\n\n        return rpn_rois\n\n\ndef apply_box_deltas_graph(boxes, deltas):\n    \"\"\"Applies the given deltas to the given boxes.\n    boxes: [N, 4] where each row is y1, x1, y2, x2\n    deltas: [N, 4] where each row is [dy, dx, log(dh), log(dw)]\n    \"\"\"\n    # Convert to y, x, h, w\n    height = boxes[:, :, 2] - boxes[:, :, 0]\n    width = boxes[:, :, 3] - boxes[:, :, 1]\n    center_y = boxes[:, :, 0] + 0.5 * height\n    center_x = boxes[:, :, 1] + 0.5 * width\n    # Apply deltas\n    center_y += deltas[:, :, 0] * height\n    center_x += deltas[:, :, 1] * width\n    height *= torch.exp(deltas[:, :, 2])\n    width *= torch.exp(deltas[:, :, 3])\n    # Convert back to y1, x1, y2, x2\n    y1 = center_y - 0.5 * height\n    x1 = center_x - 0.5 * width\n    y2 = y1 + height\n    x2 = x1 + width\n    result = [y1, x1, y2, x2]\n    return result\n\n\ndef clip_boxes_graph(boxes, window):\n    \"\"\"\n    boxes: [N, 4] each row is y1, x1, y2, x2\n    window: [4] in the form y1, x1, y2, x2\n    \"\"\"\n    # Split corners\n    wy1, wx1, wy2, wx2 = window\n    y1, x1, y2, x2 = boxes\n    # Clip\n\n    y1 = torch.max(torch.min(y1, wy2), wy1)\n    x1 = torch.max(torch.min(x1, wx2), wx1)\n    y2 = torch.max(torch.min(y2, wy2), wy1)\n    x2 = torch.max(torch.min(x2, wx2), wx1)\n\n    clipped = torch.stack([x1, y1, x2, y2], dim=2)\n    return clipped\n```\n\n#### 相关资源\n\n##### **项目**\n\n1. [JenifferWuUCLA/pulmonary-nodules-MaskRCNN: Mask R-CNN for Pulmonary Nodules Diagnosis, using TensorFlow 天池医疗 AI 大赛：Mask R-CNN 肺部结节智能检测（Segmentation + Classification）](https://github.com/JenifferWuUCLA/pulmonary-nodules-MaskRCNN/tree/master)\n2. [facebookresearch/maskrcnn-benchmark: Fast, modular reference implementation of Instance Segmentation and Object Detection algorithms in PyTorch.](https://github.com/facebookresearch/maskrcnn-benchmark)\n3. [leon-liangwu/MaskYolo_Caffe: YOLO V2 & V3 , YOLO Combined with RCNN and MaskRCNN](https://github.com/leon-liangwu/MaskYolo_Caffe?tab=readme-ov-file)\n4. [TannerGilbert/MaskRCNN-Object-Detection-and-Segmentation: Train your own custom MaskRCNN Object Detection and Instance Segmentation model.](https://github.com/TannerGilbert/MaskRCNN-Object-Detection-and-Segmentation)\n5. [CharlesShang/FastMaskRCNN: Mask RCNN in TensorFlow](https://github.com/CharlesShang/FastMaskRCNN)\n6. [buseyaren/installation-guide-of-maskrcnn: Mask R-CNN creates a high-quality segmentation mask in addition to the Faster R-CNN network. In addition to class labels and scores, a segmentation mask is created for the objects detected by this neural network. In this repository, using Anaconda prompt step by step Mask R-CNN setup is shown.](https://github.com/buseyaren/installation-guide-of-maskrcnn?tab=readme-ov-file)\n\n##### 博客\n\n1. [Mask R-CNN 网络详解_maskrcnn-CSDN 博客](https://blog.csdn.net/qq_37541097/article/details/123754766)\n2. [目标分割：Mask RCNN_mask r-cnn-CSDN 博客](https://blog.csdn.net/zimiao552147572/article/details/105300202?utm_medium=distribute.pc_relevant.none-task-blog-2~default~baidujs_baidulandingword~default-0-105300202-blog-123754766.235%5Ev43%5Epc_blog_bottom_relevance_base8&spm=1001.2101.3001.4242.1&utm_relevant_index=2)\n\n##### 论文\n\n1. [arxiv.org/pdf/1703.06870](https://arxiv.org/pdf/1703.06870)\n2. [MULAN: Multitask Universal Lesion Analysis Network for Joint Lesion Detection, Tagging, and Segmentation](https://arxiv.org/abs/1908.04373)\n3. [RetinaMask: Learning to predict masks improves state-of-the-art single-shot detection for free](https://arxiv.org/abs/1901.03353)\n4. [FCOS: Fully Convolutional One-Stage Object Detection](https://arxiv.org/abs/1904.01355)\n5. [Is Sampling Heuristics Necessary in Training Deep Object Detectors?](https://arxiv.org/abs/1909.04868)\n\n---\n","source":"_posts/2025-02-16-实例分割.md","raw":"---\ntitle: 实例分割\ndate: 2025-02-16\ntags: 深度学习\n---\n\n# **实例分割（Instance Segmentation）**\n\n## ** 定义**\n\n实例分割是目标检测和语义分割的结合，旨在精确识别图像中的每个目标对象，并区分同一类别中的不同实例。例如，在一张包含多个人的图像中，实例分割不仅需要识别出“人”这一类别，还需要将每个人单独区分开来，为每个人生成独立的分割掩码（Mask）。\n\n实例分割通过融合目标检测和语义分割的结果来实现这一目标。具体而言，它利用目标检测提供的目标类别和位置信息（如边界框和置信度），从语义分割的结果中提取出对应目标的像素级掩码。简而言之，实例分割的任务是将同一类别中的具体对象（即实例）分别分割出来。\n\n举个例子,近年来，随着自动驾驶等领域的快速发展，实例分割任务受到了广泛关注。自动驾驶场景中，精确区分和分割道路上的行人、车辆等目标对于环境感知和决策至关重要。此外，一些实例分割任务还会输出检测结果（如边界框），以提供更全面的目标描述。\n\n对实例分割、语义分割和目标检测混合任务感兴趣的读者，可以参考 CVPR 2019 的论文《Hybrid Task Cascade》（HTC），该研究提出了一种混合任务级联框架，能够同时处理这三种任务，为多任务学习提供了新的思路。\n\n## **特点**\n\n- 能够精确地定位和区分同一类别的不同实例。\n- 计算成本较高，因为需要对每个目标实例进行单独检测和分类。\n\n## ** 应用**\n\n实例分割在以下领域有重要应用：\n\n- **自动驾驶**：用于检测和分割车辆、行人。\n- **医学成像**：用于检测组织和病理的特定边界。\n- **机器人视觉**：用于识别和隔离目标物体。\n\n## ** 常见模型**\n\n### **Mask R-CNN**\n\n- **优点**：能够同时进行目标检测和语义分割，具有较好的性能。\n- **缺点**：模型参数多，训练和推理速度较慢；大目标的边缘分割较为粗糙。\n\n#### 提出初衷\n\nMask R-CNN 是 2017 年发表的文章，一作是何恺明大神，没错就是那个男人，除此之外还有 Faster R-CNN 系列的大神 Ross Girshick，可以说是强强联合。该论文也获得了 ICCV 2017 的最佳论文奖（Marr Prize）。并且该网络提出后，又霸榜了 MS COCO 的各项任务，包括目标检测、实例分割以及人体关键点检测任务。Mask R-CNN 的结构很简洁而且很灵活效果又很好（仅仅是在 Faster R-CNN 的基础上根据需求加入一些新的分支）。\nMask R-CNN 的提出初衷是为了实现高效且精确的实例分割任务，同时继承 Faster R-CNN 在目标检测方面的优势。具体而言，Mask R-CNN 的核心动机是将目标检测与语义分割相结合，既能检测图像中的目标并定位其边界框，又能为每个目标生成精确的像素级分割掩码。此外，Mask R-CNN 通过引入 RoI Align 技术，解决了 Faster R-CNN 中 RoI Pooling 导致的特征图与原始图像区域对齐不精确的问题，显著提高了分割掩码的精度。Mask R-CNN 在 Faster R-CNN 的基础上增加了全卷积网络（FCN）分支，用于预测每个感兴趣区域（RoI）的分割掩码，这种设计不仅简单高效，且只增加了较小的计算开销。\n![1740407201646JSjbb2yMTo66D3xSrKfcVwQCnSc.png](https://tk-pichost-1325224430.cos.ap-chengdu.myqcloud.com/blog/1740407201646JSjbb2yMTo66D3xSrKfcVwQCnSc.png)\n它还具备良好的多任务扩展性，能够轻松扩展到其他任务（如人体关键点检测），成为一种通用的视觉框架。通过为每个类别预测独立的二元掩码，Mask R-CNN 能够更好地提取目标的空间布局信息，从而生成更精确的分割掩码，并在 COCO 等数据集上取得了显著优于当时其他模型的性能。总之，Mask R-CNN 的提出填补了目标检测和语义分割之间的空白，提供了一种高精度、高效率的实例分割解决方案。\n![1740407212685Z2kFbwjzroUn5Xx4JNDcueDNnK2.png](https://tk-pichost-1325224430.cos.ap-chengdu.myqcloud.com/blog/1740407212685Z2kFbwjzroUn5Xx4JNDcueDNnK2.png)\nMask R-CNN 的提出初衷是为了实现高效且精确的实例分割任务，同时继承 Faster R-CNN 在目标检测方面的优势。具体动机和背景如下：\n\n1. **结合目标检测与语义分割**\n   在 Mask R-CNN 提出之前，目标检测（如 Faster R-CNN）和语义分割（如 FCN）是两个独立的领域。Mask R-CNN 的核心动机是将两者结合起来，既能够检测图像中的目标并定位其边界框，还能为每个目标生成精确的像素级分割掩码。\n2. **解决像素级对齐问题**\n   Faster R-CNN 在处理像素级任务时存在局限性，尤其是其 RoI Pooling 操作会导致特征图与原始图像区域的对齐不精确。Mask R-CNN 通过引入 RoI Align 技术，解决了这一问题，显著提高了分割掩码的精度。\n3. **简单高效的架构设计**\n   Mask R-CNN 在 Faster R-CNN 的基础上，增加了一个全卷积网络（FCN）分支，用于预测每个感兴趣区域（RoI）的分割掩码。这种设计不仅简单高效，而且只增加了较小的计算开销。\n4. **多任务学习的扩展性**\n   Mask R-CNN 不仅适用于实例分割，还可以轻松扩展到其他任务，如人体关键点检测。这种多任务扩展性使其成为一种通用的视觉框架。\n5. **提升实例分割精度**\n   通过为每个类别预测独立的二元掩码，Mask R-CNN 能够更好地提取目标的空间布局信息，从而生成更精确的分割掩码。这一改进使其在 COCO 等数据集上取得了显著优于当时其他模型的性能。\n\n#### 网络结构\n\nMask R-CNN 的结构也很简单，就是在通过 RoIAlign（在原 Faster R-CNN 中是 RoIPool）得到的 RoI 基础上并行添加一个 Mask 分支（小型的 FCN）。见下图，之前 Faster R-CNN 是在 RoI 基础上接上一个 Fast R-CNN 检测头，即图中 class, box 分支，现在又并行了一个 Mask 分支。\n![1740407241647NcMPbytf4o9G40xNM1UcgSMbn4f.png](https://tk-pichost-1325224430.cos.ap-chengdu.myqcloud.com/blog/1740407241647NcMPbytf4o9G40xNM1UcgSMbn4f.png)\n\n![1740407249647WI67bCnZrobIRSx9aWhclwDEnlj.png](https://tk-pichost-1325224430.cos.ap-chengdu.myqcloud.com/blog/1740407249647WI67bCnZrobIRSx9aWhclwDEnlj.png)\n注意带和不带 FPN 结构的 Mask R-CNN 在 Mask 分支上略有不同，对于带有 FPN 结构的 Mask R-CNN 它的 class、box 分支和 Mask 分支并不是共用一个 RoIAlign。在训练过程中，对于 class, box 分支 RoIAlign 将 RPN（Region Proposal Network）得到的 Proposals 池化到 7x7 大小，而对于 Mask 分支 RoIAlign 将 Proposals 池化到 14x14 大小。\n![1740407261695EyHvbUkC0ouDKnxVfEGcm0iKnKd.png](https://tk-pichost-1325224430.cos.ap-chengdu.myqcloud.com/blog/1740407261695EyHvbUkC0ouDKnxVfEGcm0iKnKd.png)\n\n![1740407267643MVthb679voUnaYxQpPBcDtJCnIf.png](https://tk-pichost-1325224430.cos.ap-chengdu.myqcloud.com/blog/1740407267643MVthb679voUnaYxQpPBcDtJCnIf.png)\n\n> Q:**Mask R-CNN 中的 RoI Align 技术是如何解决 Faster R-CNN 中 RoI Pooling 导致的特征图与原始图像区域对齐不精确的问题的呢？**\n\n#### 模型代码\n\n```python\n\"\"\"\nModel definitions\n\n\"\"\"\nfrom torch.autograd import Variable\nimport torch.nn as nn\nimport torch.nn.functional as F\nimport torch\nimport numpy as np\nimport math\n\nfrom model.resnet import resnet50\nfrom model.rpn import RPN\n#from model.lib.roi_align.roi_align.roi_align import RoIAlign\nfrom model.lib.roi_align.roi_align.crop_and_resize import CropAndResize\nfrom model.lib.bbox.generate_anchors import generate_pyramid_anchors\nfrom model.lib.bbox.nms import torch_nms as nms\n\n\ndef log2_graph(x):\n    \"\"\"Implementatin of Log2. pytorch doesn't have a native implemenation.\"\"\"\n    return torch.div(torch.log(x), math.log(2.))\n\n\ndef ROIAlign(feature_maps, rois, config, pool_size, mode='bilinear'):\n    \"\"\"Implements ROI Align on the features.\n    Params:\n    - pool_shape: [height, width] of the output pooled regions. Usually [7, 7]\n    - image_shape: [height, width, chanells]. Shape of input image in pixels\n    Inputs:\n    - boxes: [batch, num_boxes, (x1, y1, x2, y2)] in normalized\n             coordinates. Possibly padded with zeros if not enough\n             boxes to fill the array.\n    - Feature maps: List of feature maps from different levels of the pyramid.\n                    Each is [batch, channels, height, width]\n    Output:\n    Pooled regions in the shape: [batch, num_boxes, height, width, channels].\n    The width and height are those specific in the pool_shape in the layer\n    constructor.\n    \"\"\"\n    \"\"\"\n    [  x2-x1             x1 + x2 - W + 1  ]\n    [  -----      0      ---------------  ]\n    [  W - 1                  W - 1       ]\n    [                                     ]\n    [           y2-y1    y1 + y2 - H + 1  ]\n    [    0      -----    ---------------  ]\n    [           H - 1         H - 1      ]\n    \"\"\"\n    #feature_maps= [P2, P3, P4, P5]\n    rois = rois.detach()\n    crop_resize = CropAndResize(pool_size, pool_size, 0)\n\n    roi_number = rois.size()[1]\n\n    pooled = rois.data.new(\n            config.IMAGES_PER_GPU*rois.size(\n            1), 256, pool_size, pool_size).zero_()\n\n    rois = rois.view(\n            config.IMAGES_PER_GPU*rois.size(1),\n            4)\n\n    # Loop through levels and apply ROI pooling to each. P2 to P5.\n    x_1 = rois[:, 0]\n    y_1 = rois[:, 1]\n    x_2 = rois[:, 2]\n    y_2 = rois[:, 3]\n\n    roi_level = log2_graph(\n        torch.div(torch.sqrt((y_2 - y_1) * (x_2 - x_1)), 224.0))\n\n    roi_level = torch.clamp(torch.clamp(\n        torch.add(torch.round(roi_level), 4), min=2), max=5)\n\n    # P2 is 256x256, P3 is 128x128, P4 is 64x64, P5 is 32x32\n    # P2 is 4, P3 is 8, P4 is 16, P5 is 32\n    for i, level in enumerate(range(2, 6)):\n\n        scaling_ratio = 2**level\n\n        height = float(config.IMAGE_MAX_DIM)/ scaling_ratio\n        width = float(config.IMAGE_MAX_DIM) / scaling_ratio\n\n        ixx = torch.eq(roi_level, level)\n\n        box_indices = ixx.view(-1).int() * 0\n        ix = torch.unsqueeze(ixx, 1)\n        level_boxes = torch.masked_select(rois, ix)\n        if level_boxes.size()[0] == 0:\n            continue\n        level_boxes = level_boxes.view(-1, 4)\n\n        crops = crop_resize(feature_maps[i], torch.div(\n                level_boxes, float(config.IMAGE_MAX_DIM)\n                )[:, [1, 0, 3, 2]], box_indices)\n\n        indices_pooled = ixx.nonzero()[:, 0]\n        pooled[indices_pooled.data, :, :, :] = crops.data\n\n    pooled = pooled.view(config.IMAGES_PER_GPU, roi_number,\n               256, pool_size, pool_size)\n    pooled = Variable(pooled).cuda()\n    return pooled\n\n\n# ---------------------------------------------------------------\n# Heads\n\nclass MaskHead(nn.Module):\n\n    def __init__(self, config):\n        super(MaskHead, self).__init__()\n        self.config = config\n        self.num_classes = config.NUM_CLASSES\n        #self.crop_size = config.mask_crop_size\n\n        #self.roi_align = RoIAlign(self.crop_size, self.crop_size)\n        self.conv1 = nn.Conv2d(256, 256, kernel_size=3, padding=1, stride=1)\n        self.bn1 = nn.BatchNorm2d(256)\n        self.conv2 = nn.Conv2d(256, 256, kernel_size=3, padding=1, stride=1)\n        self.bn2 = nn.BatchNorm2d(256)\n        self.conv3 = nn.Conv2d(256, 256, kernel_size=3, padding=1, stride=1)\n        self.bn3 = nn.BatchNorm2d(256)\n        self.conv4 = nn.Conv2d(256, 256, kernel_size=3, padding=1, stride=1)\n        self.bn4 = nn.BatchNorm2d(256)\n\n        self.deconv = nn.ConvTranspose2d(256, 256, kernel_size=4, padding=1, stride=2, bias=False)\n        self.mask = nn.Conv2d(256, self.num_classes, kernel_size=1, padding=0, stride=1)\n\n    def forward(self, x, rpn_rois):\n        #x = self.roi_align(x, rpn_rois)\n        x = ROIAlign(x, rpn_rois, self.config, self.config.MASK_POOL_SIZE)\n\n        roi_number = x.size()[1]\n\n        # merge batch and roi number together\n        x = x.view(self.config.IMAGES_PER_GPU * roi_number,\n                   256, self.config.MASK_POOL_SIZE,\n                   self.config.MASK_POOL_SIZE)\n\n        x = F.relu(self.bn1(self.conv1(x)), inplace=True)\n        x = F.relu(self.bn2(self.conv2(x)), inplace=True)\n        x = F.relu(self.bn3(self.conv3(x)), inplace=True)\n        x = F.relu(self.bn4(self.conv4(x)), inplace=True)\n        x = self.deconv(x)\n        rcnn_mask_logits = self.mask(x)\n\n        rcnn_mask_logits = rcnn_mask_logits.view(self.config.IMAGES_PER_GPU,\n                                                 roi_number,\n                                                 self.config.NUM_CLASSES,\n                                                 self.config.MASK_POOL_SIZE * 2,\n                                                 self.config.MASK_POOL_SIZE * 2)\n\n        return rcnn_mask_logits\n\n\nclass RCNNHead(nn.Module):\n    def __init__(self, config):\n        super(RCNNHead, self).__init__()\n        self.config = config\n        self.num_classes = config.NUM_CLASSES\n        #self.crop_size = config.rcnn_crop_size\n\n        #self.roi_align = RoIAlign(self.crop_size, self.crop_size)\n        self.fc1 = nn.Linear(1024, 1024)\n        self.fc2 = nn.Linear(1024, 1024)\n        self.class_logits = nn.Linear(1024, self.num_classes)\n        self.bbox = nn.Linear(1024, self.num_classes * 4)\n\n        self.conv1 = nn.Conv2d(256, 1024, kernel_size=self.config.POOL_SIZE, stride=1, padding=0)\n        self.bn1 = nn.BatchNorm2d(1024, eps=0.001)\n\n    def forward(self, x, rpn_rois):\n        x = ROIAlign(x, rpn_rois, self.config, self.config.POOL_SIZE)\n        roi_number = x.size()[1]\n\n        x = x.view(self.config.IMAGES_PER_GPU * roi_number,\n                   256, self.config.POOL_SIZE,\n                   self.config.POOL_SIZE)\n        #print(x.shape)\n        #x = self.roi_align(x, rpn_rois, self.config, self.config.POOL_SIZE)\n        #x = crops.view(crops.size(0), -1)\n        x = self.bn1(self.conv1(x))\n        x = x.permute(0, 2, 3, 1).contiguous().view(x.size(0), -1)\n        x = F.relu(self.fc1(x), inplace=True)\n        x = F.relu(self.fc2(x), inplace=True)\n        #x = F.dropout(x, 0.5, training=self.training)\n        rcnn_class_logits = self.class_logits(x)\n        rcnn_probs = F.softmax(rcnn_class_logits, dim=-1)\n\n        rcnn_bbox = self.bbox(x)\n\n        rcnn_class_logits = rcnn_class_logits.view(self.config.IMAGES_PER_GPU,\n                                                   roi_number,\n                                                   rcnn_class_logits.size()[-1])\n\n        rcnn_probs = rcnn_probs.view(self.config.IMAGES_PER_GPU,\n                                     roi_number,\n                                     rcnn_probs.size()[-1])\n\n        rcnn_bbox = rcnn_bbox.view(self.config.IMAGES_PER_GPU,\n                                   roi_number,\n                                   self.config.NUM_CLASSES,\n                                   4)\n\n        return rcnn_class_logits, rcnn_probs, rcnn_bbox\n\n\n#\n# ---------------------------------------------------------------\n# Mask R-CNN\n\nclass MaskRCNN(nn.Module):\n    \"\"\"\n    Mask R-CNN model\n    \"\"\"\n\n    def __init__(self, config):\n        super(MaskRCNN, self).__init__()\n        self.config = config\n        self.__mode = 'train'\n        feature_channels = 128\n        # define modules (set of layers)\n#        self.feature_net = FeatureNet(cfg, 3, feature_channels)\n        self.feature_net = resnet50().cuda()\n        #self.rpn_head = RpnMultiHead(cfg,feature_channels)\n        self.rpn = RPN(256, len(self.config.RPN_ANCHOR_RATIOS),\n                             self.config.RPN_ANCHOR_STRIDE)\n        #self.rcnn_crop = CropRoi(cfg, cfg.rcnn_crop_size)\n        self.rcnn_head = RCNNHead(config)\n        #self.mask_crop = CropRoi(cfg, cfg.mask_crop_size)\n        self.mask_head = MaskHead(config)\n\n        self.anchors = generate_pyramid_anchors(self.config.RPN_ANCHOR_SCALES,\n                                                self.config.RPN_ANCHOR_RATIOS,\n                                                self.config.BACKBONE_SHAPES,\n                                                self.config.BACKBONE_STRIDES,\n                                                self.config.RPN_ANCHOR_STRIDE)\n        self.anchors = self.anchors.astype(np.float32)\n        self.proposal_count = self.config.POST_NMS_ROIS_TRAINING\n        # FPN\n        self.fpn_c5p5 = nn.Conv2d(\n            512 * 4, 256, kernel_size=1, stride=1, padding=0)\n        self.fpn_c4p4 = nn.Conv2d(\n            256 * 4, 256, kernel_size=1, stride=1, padding=0)\n        self.fpn_c3p3 = nn.Conv2d(\n            128 * 4, 256, kernel_size=1, stride=1, padding=0)\n        self.fpn_c2p2 = nn.Conv2d(\n            64 * 4, 256, kernel_size=1, stride=1,  padding=0)\n\n        self.fpn_p2 = nn.Conv2d(256, 256, kernel_size=3, stride=1, padding=1)\n        self.fpn_p3 = nn.Conv2d(256, 256, kernel_size=3, stride=1, padding=1)\n        self.fpn_p4 = nn.Conv2d(256, 256, kernel_size=3, stride=1, padding=1)\n        self.fpn_p5 = nn.Conv2d(256, 256, kernel_size=3, stride=1, padding=1)\n\n        self.scale_ratios = [4, 8, 16, 32]\n        self.fpn_p6 = nn.MaxPool2d(\n            kernel_size=1, stride=2, padding=0, ceil_mode=False)\n\n    def forward(self, x):\n        # Extract features\n        C1, C2, C3, C4, C5 = self.feature_net(x)\n        P5 = self.fpn_c5p5(C5)\n        P4 = self.fpn_c4p4(C4) + F.upsample(P5,\n                                            scale_factor=2, mode='bilinear')\n        P3 = self.fpn_c3p3(C3) + F.upsample(P4,\n                                            scale_factor=2, mode='bilinear')\n        P2 = self.fpn_c2p2(C2) + F.upsample(P3,\n                                            scale_factor=2, mode='bilinear')\n\n        # Attach 3x3 conv to all P layers to get the final feature maps.\n        # P2 is 256, P3 is 128, P4 is 64, P5 is 32\n        P2 = self.fpn_p2(P2)\n        P3 = self.fpn_p3(P3)\n        P4 = self.fpn_p4(P4)\n        P5 = self.fpn_p5(P5)\n        # P6 is used for the 5th anchor scale in RPN. Generated by\n        # subsampling from P5 with stride of 2.\n        P6 = self.fpn_p6(P5)\n\n        # Note that P6 is used in RPN, but not in the classifier heads.\n        rpn_feature_maps = [P2, P3, P4, P5, P6]\n\n        self.mrcnn_feature_maps = [P2, P3, P4, P5]\n\n        rpn_class_logits_outputs = []\n        rpn_class_outputs = []\n        rpn_bbox_outputs = []\n        # RPN proposals\n        for feature in rpn_feature_maps:\n            rpn_class_logits, rpn_probs, rpn_bbox = self.rpn(feature)\n            rpn_class_logits_outputs.append(rpn_class_logits)\n            rpn_class_outputs.append(rpn_probs)\n            rpn_bbox_outputs.append(rpn_bbox)\n\n        rpn_class_logits = torch.cat(rpn_class_logits_outputs, dim=1)\n        rpn_class = torch.cat(rpn_class_outputs, dim=1)\n        rpn_bbox = torch.cat(rpn_bbox_outputs, dim=1)\n\n        rpn_proposals = self.proposal_layer(rpn_class, rpn_bbox)\n\n        # RCNN proposals\n        rcnn_class_logits, rcnn_class, rcnn_bbox = self.rcnn_head(self.mrcnn_feature_maps, rpn_proposals)\n        rcnn_mask_logits = self.mask_head(self.mrcnn_feature_maps, rpn_proposals)\n        # <todo> mask nms\n\n        return [rpn_class_logits, rpn_class, rpn_bbox, rpn_proposals,\n                rcnn_class_logits, rcnn_class, rcnn_bbox,\n                rcnn_mask_logits]\n\n    def proposal_layer(self, rpn_class, rpn_bbox):\n        # handling proposals\n        scores = rpn_class[:, :, 1]\n        #print(scores.shape)\n        # Box deltas [batch, num_rois, 4]\n        deltas_mul = Variable(torch.from_numpy(np.reshape(\n            self.config.RPN_BBOX_STD_DEV, [1, 1, 4]).astype(np.float32))).cuda()\n        deltas = rpn_bbox * deltas_mul\n\n        pre_nms_limit = min(6000, self.anchors.shape[0])\n\n        scores, ix = torch.topk(scores, pre_nms_limit, dim=-1,\n                                largest=True, sorted=True)\n\n        ix = torch.unsqueeze(ix, 2)\n        ix = torch.cat([ix, ix, ix, ix], dim=2)\n        deltas = torch.gather(deltas, 1, ix)\n\n        _anchors = []\n        for i in range(self.config.IMAGES_PER_GPU):\n            anchors = Variable(torch.from_numpy(\n                self.anchors.astype(np.float32))).cuda()\n            _anchors.append(anchors)\n        anchors = torch.stack(_anchors, 0)\n\n        pre_nms_anchors = torch.gather(anchors, 1, ix)\n        refined_anchors = apply_box_deltas_graph(pre_nms_anchors, deltas)\n\n        # Clip to image boundaries. [batch, N, (y1, x1, y2, x2)]\n        height, width = self.config.IMAGE_SHAPE[:2]\n        window = np.array([0, 0, height, width]).astype(np.float32)\n        window = Variable(torch.from_numpy(window)).cuda()\n\n        refined_anchors_clipped = clip_boxes_graph(refined_anchors, window)\n\n        refined_proposals = []\n        scores = scores[:,:,None]\n        #print(scores.data.shape)\n        #print(refined_anchors_clipped.data.shape)\n        for i in range(self.config.IMAGES_PER_GPU):\n            indices = nms(\n                torch.cat([refined_anchors_clipped.data[i], scores.data[i]], 1), 0.7)\n            indices = indices[:self.proposal_count]\n            indices = torch.stack([indices, indices, indices, indices], dim=1)\n            indices = Variable(indices).cuda()\n            proposals = torch.gather(refined_anchors_clipped[i], 0, indices)\n            padding = self.proposal_count - proposals.size()[0]\n            proposals = torch.cat(\n                [proposals, Variable(torch.zeros([padding, 4])).cuda()], 0)\n            refined_proposals.append(proposals)\n\n        rpn_rois = torch.stack(refined_proposals, 0)\n\n        return rpn_rois\n\n\ndef apply_box_deltas_graph(boxes, deltas):\n    \"\"\"Applies the given deltas to the given boxes.\n    boxes: [N, 4] where each row is y1, x1, y2, x2\n    deltas: [N, 4] where each row is [dy, dx, log(dh), log(dw)]\n    \"\"\"\n    # Convert to y, x, h, w\n    height = boxes[:, :, 2] - boxes[:, :, 0]\n    width = boxes[:, :, 3] - boxes[:, :, 1]\n    center_y = boxes[:, :, 0] + 0.5 * height\n    center_x = boxes[:, :, 1] + 0.5 * width\n    # Apply deltas\n    center_y += deltas[:, :, 0] * height\n    center_x += deltas[:, :, 1] * width\n    height *= torch.exp(deltas[:, :, 2])\n    width *= torch.exp(deltas[:, :, 3])\n    # Convert back to y1, x1, y2, x2\n    y1 = center_y - 0.5 * height\n    x1 = center_x - 0.5 * width\n    y2 = y1 + height\n    x2 = x1 + width\n    result = [y1, x1, y2, x2]\n    return result\n\n\ndef clip_boxes_graph(boxes, window):\n    \"\"\"\n    boxes: [N, 4] each row is y1, x1, y2, x2\n    window: [4] in the form y1, x1, y2, x2\n    \"\"\"\n    # Split corners\n    wy1, wx1, wy2, wx2 = window\n    y1, x1, y2, x2 = boxes\n    # Clip\n\n    y1 = torch.max(torch.min(y1, wy2), wy1)\n    x1 = torch.max(torch.min(x1, wx2), wx1)\n    y2 = torch.max(torch.min(y2, wy2), wy1)\n    x2 = torch.max(torch.min(x2, wx2), wx1)\n\n    clipped = torch.stack([x1, y1, x2, y2], dim=2)\n    return clipped\n```\n\n#### 相关资源\n\n##### **项目**\n\n1. [JenifferWuUCLA/pulmonary-nodules-MaskRCNN: Mask R-CNN for Pulmonary Nodules Diagnosis, using TensorFlow 天池医疗 AI 大赛：Mask R-CNN 肺部结节智能检测（Segmentation + Classification）](https://github.com/JenifferWuUCLA/pulmonary-nodules-MaskRCNN/tree/master)\n2. [facebookresearch/maskrcnn-benchmark: Fast, modular reference implementation of Instance Segmentation and Object Detection algorithms in PyTorch.](https://github.com/facebookresearch/maskrcnn-benchmark)\n3. [leon-liangwu/MaskYolo_Caffe: YOLO V2 & V3 , YOLO Combined with RCNN and MaskRCNN](https://github.com/leon-liangwu/MaskYolo_Caffe?tab=readme-ov-file)\n4. [TannerGilbert/MaskRCNN-Object-Detection-and-Segmentation: Train your own custom MaskRCNN Object Detection and Instance Segmentation model.](https://github.com/TannerGilbert/MaskRCNN-Object-Detection-and-Segmentation)\n5. [CharlesShang/FastMaskRCNN: Mask RCNN in TensorFlow](https://github.com/CharlesShang/FastMaskRCNN)\n6. [buseyaren/installation-guide-of-maskrcnn: Mask R-CNN creates a high-quality segmentation mask in addition to the Faster R-CNN network. In addition to class labels and scores, a segmentation mask is created for the objects detected by this neural network. In this repository, using Anaconda prompt step by step Mask R-CNN setup is shown.](https://github.com/buseyaren/installation-guide-of-maskrcnn?tab=readme-ov-file)\n\n##### 博客\n\n1. [Mask R-CNN 网络详解_maskrcnn-CSDN 博客](https://blog.csdn.net/qq_37541097/article/details/123754766)\n2. [目标分割：Mask RCNN_mask r-cnn-CSDN 博客](https://blog.csdn.net/zimiao552147572/article/details/105300202?utm_medium=distribute.pc_relevant.none-task-blog-2~default~baidujs_baidulandingword~default-0-105300202-blog-123754766.235%5Ev43%5Epc_blog_bottom_relevance_base8&spm=1001.2101.3001.4242.1&utm_relevant_index=2)\n\n##### 论文\n\n1. [arxiv.org/pdf/1703.06870](https://arxiv.org/pdf/1703.06870)\n2. [MULAN: Multitask Universal Lesion Analysis Network for Joint Lesion Detection, Tagging, and Segmentation](https://arxiv.org/abs/1908.04373)\n3. [RetinaMask: Learning to predict masks improves state-of-the-art single-shot detection for free](https://arxiv.org/abs/1901.03353)\n4. [FCOS: Fully Convolutional One-Stage Object Detection](https://arxiv.org/abs/1904.01355)\n5. [Is Sampling Heuristics Necessary in Training Deep Object Detectors?](https://arxiv.org/abs/1909.04868)\n\n---\n","slug":"2025-02-16-实例分割","published":1,"updated":"2025-09-26T12:15:21.847Z","_id":"cmg0saj3v000bjm8n7j0f6rda","comments":1,"layout":"post","photos":[],"content":"<h1 id=\"实例分割（Instance-Segmentation）\"><a href=\"#实例分割（Instance-Segmentation）\" class=\"headerlink\" title=\"实例分割（Instance Segmentation）\"></a><strong>实例分割（Instance Segmentation）</strong></h1><h2 id=\"定义\"><a href=\"#定义\" class=\"headerlink\" title=\"** 定义**\"></a>** 定义**</h2><p>实例分割是目标检测和语义分割的结合，旨在精确识别图像中的每个目标对象，并区分同一类别中的不同实例。例如，在一张包含多个人的图像中，实例分割不仅需要识别出“人”这一类别，还需要将每个人单独区分开来，为每个人生成独立的分割掩码（Mask）。</p>\n<p>实例分割通过融合目标检测和语义分割的结果来实现这一目标。具体而言，它利用目标检测提供的目标类别和位置信息（如边界框和置信度），从语义分割的结果中提取出对应目标的像素级掩码。简而言之，实例分割的任务是将同一类别中的具体对象（即实例）分别分割出来。</p>\n<p>举个例子,近年来，随着自动驾驶等领域的快速发展，实例分割任务受到了广泛关注。自动驾驶场景中，精确区分和分割道路上的行人、车辆等目标对于环境感知和决策至关重要。此外，一些实例分割任务还会输出检测结果（如边界框），以提供更全面的目标描述。</p>\n<p>对实例分割、语义分割和目标检测混合任务感兴趣的读者，可以参考 CVPR 2019 的论文《Hybrid Task Cascade》（HTC），该研究提出了一种混合任务级联框架，能够同时处理这三种任务，为多任务学习提供了新的思路。</p>\n<h2 id=\"特点\"><a href=\"#特点\" class=\"headerlink\" title=\"特点\"></a><strong>特点</strong></h2><ul>\n<li>能够精确地定位和区分同一类别的不同实例。</li>\n<li>计算成本较高，因为需要对每个目标实例进行单独检测和分类。</li>\n</ul>\n<h2 id=\"应用\"><a href=\"#应用\" class=\"headerlink\" title=\"** 应用**\"></a>** 应用**</h2><p>实例分割在以下领域有重要应用：</p>\n<ul>\n<li><strong>自动驾驶</strong>：用于检测和分割车辆、行人。</li>\n<li><strong>医学成像</strong>：用于检测组织和病理的特定边界。</li>\n<li><strong>机器人视觉</strong>：用于识别和隔离目标物体。</li>\n</ul>\n<h2 id=\"常见模型\"><a href=\"#常见模型\" class=\"headerlink\" title=\"** 常见模型**\"></a>** 常见模型**</h2><h3 id=\"Mask-R-CNN\"><a href=\"#Mask-R-CNN\" class=\"headerlink\" title=\"Mask R-CNN\"></a><strong>Mask R-CNN</strong></h3><ul>\n<li><strong>优点</strong>：能够同时进行目标检测和语义分割，具有较好的性能。</li>\n<li><strong>缺点</strong>：模型参数多，训练和推理速度较慢；大目标的边缘分割较为粗糙。</li>\n</ul>\n<h4 id=\"提出初衷\"><a href=\"#提出初衷\" class=\"headerlink\" title=\"提出初衷\"></a>提出初衷</h4><p>Mask R-CNN 是 2017 年发表的文章，一作是何恺明大神，没错就是那个男人，除此之外还有 Faster R-CNN 系列的大神 Ross Girshick，可以说是强强联合。该论文也获得了 ICCV 2017 的最佳论文奖（Marr Prize）。并且该网络提出后，又霸榜了 MS COCO 的各项任务，包括目标检测、实例分割以及人体关键点检测任务。Mask R-CNN 的结构很简洁而且很灵活效果又很好（仅仅是在 Faster R-CNN 的基础上根据需求加入一些新的分支）。<br>Mask R-CNN 的提出初衷是为了实现高效且精确的实例分割任务，同时继承 Faster R-CNN 在目标检测方面的优势。具体而言，Mask R-CNN 的核心动机是将目标检测与语义分割相结合，既能检测图像中的目标并定位其边界框，又能为每个目标生成精确的像素级分割掩码。此外，Mask R-CNN 通过引入 RoI Align 技术，解决了 Faster R-CNN 中 RoI Pooling 导致的特征图与原始图像区域对齐不精确的问题，显著提高了分割掩码的精度。Mask R-CNN 在 Faster R-CNN 的基础上增加了全卷积网络（FCN）分支，用于预测每个感兴趣区域（RoI）的分割掩码，这种设计不仅简单高效，且只增加了较小的计算开销。<br><img src=\"https://tk-pichost-1325224430.cos.ap-chengdu.myqcloud.com/blog/1740407201646JSjbb2yMTo66D3xSrKfcVwQCnSc.png\" alt=\"1740407201646JSjbb2yMTo66D3xSrKfcVwQCnSc.png\"><br>它还具备良好的多任务扩展性，能够轻松扩展到其他任务（如人体关键点检测），成为一种通用的视觉框架。通过为每个类别预测独立的二元掩码，Mask R-CNN 能够更好地提取目标的空间布局信息，从而生成更精确的分割掩码，并在 COCO 等数据集上取得了显著优于当时其他模型的性能。总之，Mask R-CNN 的提出填补了目标检测和语义分割之间的空白，提供了一种高精度、高效率的实例分割解决方案。<br><img src=\"https://tk-pichost-1325224430.cos.ap-chengdu.myqcloud.com/blog/1740407212685Z2kFbwjzroUn5Xx4JNDcueDNnK2.png\" alt=\"1740407212685Z2kFbwjzroUn5Xx4JNDcueDNnK2.png\"><br>Mask R-CNN 的提出初衷是为了实现高效且精确的实例分割任务，同时继承 Faster R-CNN 在目标检测方面的优势。具体动机和背景如下：</p>\n<ol>\n<li><strong>结合目标检测与语义分割</strong><br>在 Mask R-CNN 提出之前，目标检测（如 Faster R-CNN）和语义分割（如 FCN）是两个独立的领域。Mask R-CNN 的核心动机是将两者结合起来，既能够检测图像中的目标并定位其边界框，还能为每个目标生成精确的像素级分割掩码。</li>\n<li><strong>解决像素级对齐问题</strong><br>Faster R-CNN 在处理像素级任务时存在局限性，尤其是其 RoI Pooling 操作会导致特征图与原始图像区域的对齐不精确。Mask R-CNN 通过引入 RoI Align 技术，解决了这一问题，显著提高了分割掩码的精度。</li>\n<li><strong>简单高效的架构设计</strong><br>Mask R-CNN 在 Faster R-CNN 的基础上，增加了一个全卷积网络（FCN）分支，用于预测每个感兴趣区域（RoI）的分割掩码。这种设计不仅简单高效，而且只增加了较小的计算开销。</li>\n<li><strong>多任务学习的扩展性</strong><br>Mask R-CNN 不仅适用于实例分割，还可以轻松扩展到其他任务，如人体关键点检测。这种多任务扩展性使其成为一种通用的视觉框架。</li>\n<li><strong>提升实例分割精度</strong><br>通过为每个类别预测独立的二元掩码，Mask R-CNN 能够更好地提取目标的空间布局信息，从而生成更精确的分割掩码。这一改进使其在 COCO 等数据集上取得了显著优于当时其他模型的性能。</li>\n</ol>\n<h4 id=\"网络结构\"><a href=\"#网络结构\" class=\"headerlink\" title=\"网络结构\"></a>网络结构</h4><p>Mask R-CNN 的结构也很简单，就是在通过 RoIAlign（在原 Faster R-CNN 中是 RoIPool）得到的 RoI 基础上并行添加一个 Mask 分支（小型的 FCN）。见下图，之前 Faster R-CNN 是在 RoI 基础上接上一个 Fast R-CNN 检测头，即图中 class, box 分支，现在又并行了一个 Mask 分支。<br><img src=\"https://tk-pichost-1325224430.cos.ap-chengdu.myqcloud.com/blog/1740407241647NcMPbytf4o9G40xNM1UcgSMbn4f.png\" alt=\"1740407241647NcMPbytf4o9G40xNM1UcgSMbn4f.png\"></p>\n<p><img src=\"https://tk-pichost-1325224430.cos.ap-chengdu.myqcloud.com/blog/1740407249647WI67bCnZrobIRSx9aWhclwDEnlj.png\" alt=\"1740407249647WI67bCnZrobIRSx9aWhclwDEnlj.png\"><br>注意带和不带 FPN 结构的 Mask R-CNN 在 Mask 分支上略有不同，对于带有 FPN 结构的 Mask R-CNN 它的 class、box 分支和 Mask 分支并不是共用一个 RoIAlign。在训练过程中，对于 class, box 分支 RoIAlign 将 RPN（Region Proposal Network）得到的 Proposals 池化到 7x7 大小，而对于 Mask 分支 RoIAlign 将 Proposals 池化到 14x14 大小。<br><img src=\"https://tk-pichost-1325224430.cos.ap-chengdu.myqcloud.com/blog/1740407261695EyHvbUkC0ouDKnxVfEGcm0iKnKd.png\" alt=\"1740407261695EyHvbUkC0ouDKnxVfEGcm0iKnKd.png\"></p>\n<p><img src=\"https://tk-pichost-1325224430.cos.ap-chengdu.myqcloud.com/blog/1740407267643MVthb679voUnaYxQpPBcDtJCnIf.png\" alt=\"1740407267643MVthb679voUnaYxQpPBcDtJCnIf.png\"></p>\n<blockquote>\n<p>Q:<strong>Mask R-CNN 中的 RoI Align 技术是如何解决 Faster R-CNN 中 RoI Pooling 导致的特征图与原始图像区域对齐不精确的问题的呢？</strong></p>\n</blockquote>\n<h4 id=\"模型代码\"><a href=\"#模型代码\" class=\"headerlink\" title=\"模型代码\"></a>模型代码</h4><figure class=\"highlight python\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br><span class=\"line\">47</span><br><span class=\"line\">48</span><br><span class=\"line\">49</span><br><span class=\"line\">50</span><br><span class=\"line\">51</span><br><span class=\"line\">52</span><br><span class=\"line\">53</span><br><span class=\"line\">54</span><br><span class=\"line\">55</span><br><span class=\"line\">56</span><br><span class=\"line\">57</span><br><span class=\"line\">58</span><br><span class=\"line\">59</span><br><span class=\"line\">60</span><br><span class=\"line\">61</span><br><span class=\"line\">62</span><br><span class=\"line\">63</span><br><span class=\"line\">64</span><br><span class=\"line\">65</span><br><span class=\"line\">66</span><br><span class=\"line\">67</span><br><span class=\"line\">68</span><br><span class=\"line\">69</span><br><span class=\"line\">70</span><br><span class=\"line\">71</span><br><span class=\"line\">72</span><br><span class=\"line\">73</span><br><span class=\"line\">74</span><br><span class=\"line\">75</span><br><span class=\"line\">76</span><br><span class=\"line\">77</span><br><span class=\"line\">78</span><br><span class=\"line\">79</span><br><span class=\"line\">80</span><br><span class=\"line\">81</span><br><span class=\"line\">82</span><br><span class=\"line\">83</span><br><span class=\"line\">84</span><br><span class=\"line\">85</span><br><span class=\"line\">86</span><br><span class=\"line\">87</span><br><span class=\"line\">88</span><br><span class=\"line\">89</span><br><span class=\"line\">90</span><br><span class=\"line\">91</span><br><span class=\"line\">92</span><br><span class=\"line\">93</span><br><span class=\"line\">94</span><br><span class=\"line\">95</span><br><span class=\"line\">96</span><br><span class=\"line\">97</span><br><span class=\"line\">98</span><br><span class=\"line\">99</span><br><span class=\"line\">100</span><br><span class=\"line\">101</span><br><span class=\"line\">102</span><br><span class=\"line\">103</span><br><span class=\"line\">104</span><br><span class=\"line\">105</span><br><span class=\"line\">106</span><br><span class=\"line\">107</span><br><span class=\"line\">108</span><br><span class=\"line\">109</span><br><span class=\"line\">110</span><br><span class=\"line\">111</span><br><span class=\"line\">112</span><br><span class=\"line\">113</span><br><span class=\"line\">114</span><br><span class=\"line\">115</span><br><span class=\"line\">116</span><br><span class=\"line\">117</span><br><span class=\"line\">118</span><br><span class=\"line\">119</span><br><span class=\"line\">120</span><br><span class=\"line\">121</span><br><span class=\"line\">122</span><br><span class=\"line\">123</span><br><span class=\"line\">124</span><br><span class=\"line\">125</span><br><span class=\"line\">126</span><br><span class=\"line\">127</span><br><span class=\"line\">128</span><br><span class=\"line\">129</span><br><span class=\"line\">130</span><br><span class=\"line\">131</span><br><span class=\"line\">132</span><br><span class=\"line\">133</span><br><span class=\"line\">134</span><br><span class=\"line\">135</span><br><span class=\"line\">136</span><br><span class=\"line\">137</span><br><span class=\"line\">138</span><br><span class=\"line\">139</span><br><span class=\"line\">140</span><br><span class=\"line\">141</span><br><span class=\"line\">142</span><br><span class=\"line\">143</span><br><span class=\"line\">144</span><br><span class=\"line\">145</span><br><span class=\"line\">146</span><br><span class=\"line\">147</span><br><span class=\"line\">148</span><br><span class=\"line\">149</span><br><span class=\"line\">150</span><br><span class=\"line\">151</span><br><span class=\"line\">152</span><br><span class=\"line\">153</span><br><span class=\"line\">154</span><br><span class=\"line\">155</span><br><span class=\"line\">156</span><br><span class=\"line\">157</span><br><span class=\"line\">158</span><br><span class=\"line\">159</span><br><span class=\"line\">160</span><br><span class=\"line\">161</span><br><span class=\"line\">162</span><br><span class=\"line\">163</span><br><span class=\"line\">164</span><br><span class=\"line\">165</span><br><span class=\"line\">166</span><br><span class=\"line\">167</span><br><span class=\"line\">168</span><br><span class=\"line\">169</span><br><span class=\"line\">170</span><br><span class=\"line\">171</span><br><span class=\"line\">172</span><br><span class=\"line\">173</span><br><span class=\"line\">174</span><br><span class=\"line\">175</span><br><span class=\"line\">176</span><br><span class=\"line\">177</span><br><span class=\"line\">178</span><br><span class=\"line\">179</span><br><span class=\"line\">180</span><br><span class=\"line\">181</span><br><span class=\"line\">182</span><br><span class=\"line\">183</span><br><span class=\"line\">184</span><br><span class=\"line\">185</span><br><span class=\"line\">186</span><br><span class=\"line\">187</span><br><span class=\"line\">188</span><br><span class=\"line\">189</span><br><span class=\"line\">190</span><br><span class=\"line\">191</span><br><span class=\"line\">192</span><br><span class=\"line\">193</span><br><span class=\"line\">194</span><br><span class=\"line\">195</span><br><span class=\"line\">196</span><br><span class=\"line\">197</span><br><span class=\"line\">198</span><br><span class=\"line\">199</span><br><span class=\"line\">200</span><br><span class=\"line\">201</span><br><span class=\"line\">202</span><br><span class=\"line\">203</span><br><span class=\"line\">204</span><br><span class=\"line\">205</span><br><span class=\"line\">206</span><br><span class=\"line\">207</span><br><span class=\"line\">208</span><br><span class=\"line\">209</span><br><span class=\"line\">210</span><br><span class=\"line\">211</span><br><span class=\"line\">212</span><br><span class=\"line\">213</span><br><span class=\"line\">214</span><br><span class=\"line\">215</span><br><span class=\"line\">216</span><br><span class=\"line\">217</span><br><span class=\"line\">218</span><br><span class=\"line\">219</span><br><span class=\"line\">220</span><br><span class=\"line\">221</span><br><span class=\"line\">222</span><br><span class=\"line\">223</span><br><span class=\"line\">224</span><br><span class=\"line\">225</span><br><span class=\"line\">226</span><br><span class=\"line\">227</span><br><span class=\"line\">228</span><br><span class=\"line\">229</span><br><span class=\"line\">230</span><br><span class=\"line\">231</span><br><span class=\"line\">232</span><br><span class=\"line\">233</span><br><span class=\"line\">234</span><br><span class=\"line\">235</span><br><span class=\"line\">236</span><br><span class=\"line\">237</span><br><span class=\"line\">238</span><br><span class=\"line\">239</span><br><span class=\"line\">240</span><br><span class=\"line\">241</span><br><span class=\"line\">242</span><br><span class=\"line\">243</span><br><span class=\"line\">244</span><br><span class=\"line\">245</span><br><span class=\"line\">246</span><br><span class=\"line\">247</span><br><span class=\"line\">248</span><br><span class=\"line\">249</span><br><span class=\"line\">250</span><br><span class=\"line\">251</span><br><span class=\"line\">252</span><br><span class=\"line\">253</span><br><span class=\"line\">254</span><br><span class=\"line\">255</span><br><span class=\"line\">256</span><br><span class=\"line\">257</span><br><span class=\"line\">258</span><br><span class=\"line\">259</span><br><span class=\"line\">260</span><br><span class=\"line\">261</span><br><span class=\"line\">262</span><br><span class=\"line\">263</span><br><span class=\"line\">264</span><br><span class=\"line\">265</span><br><span class=\"line\">266</span><br><span class=\"line\">267</span><br><span class=\"line\">268</span><br><span class=\"line\">269</span><br><span class=\"line\">270</span><br><span class=\"line\">271</span><br><span class=\"line\">272</span><br><span class=\"line\">273</span><br><span class=\"line\">274</span><br><span class=\"line\">275</span><br><span class=\"line\">276</span><br><span class=\"line\">277</span><br><span class=\"line\">278</span><br><span class=\"line\">279</span><br><span class=\"line\">280</span><br><span class=\"line\">281</span><br><span class=\"line\">282</span><br><span class=\"line\">283</span><br><span class=\"line\">284</span><br><span class=\"line\">285</span><br><span class=\"line\">286</span><br><span class=\"line\">287</span><br><span class=\"line\">288</span><br><span class=\"line\">289</span><br><span class=\"line\">290</span><br><span class=\"line\">291</span><br><span class=\"line\">292</span><br><span class=\"line\">293</span><br><span class=\"line\">294</span><br><span class=\"line\">295</span><br><span class=\"line\">296</span><br><span class=\"line\">297</span><br><span class=\"line\">298</span><br><span class=\"line\">299</span><br><span class=\"line\">300</span><br><span class=\"line\">301</span><br><span class=\"line\">302</span><br><span class=\"line\">303</span><br><span class=\"line\">304</span><br><span class=\"line\">305</span><br><span class=\"line\">306</span><br><span class=\"line\">307</span><br><span class=\"line\">308</span><br><span class=\"line\">309</span><br><span class=\"line\">310</span><br><span class=\"line\">311</span><br><span class=\"line\">312</span><br><span class=\"line\">313</span><br><span class=\"line\">314</span><br><span class=\"line\">315</span><br><span class=\"line\">316</span><br><span class=\"line\">317</span><br><span class=\"line\">318</span><br><span class=\"line\">319</span><br><span class=\"line\">320</span><br><span class=\"line\">321</span><br><span class=\"line\">322</span><br><span class=\"line\">323</span><br><span class=\"line\">324</span><br><span class=\"line\">325</span><br><span class=\"line\">326</span><br><span class=\"line\">327</span><br><span class=\"line\">328</span><br><span class=\"line\">329</span><br><span class=\"line\">330</span><br><span class=\"line\">331</span><br><span class=\"line\">332</span><br><span class=\"line\">333</span><br><span class=\"line\">334</span><br><span class=\"line\">335</span><br><span class=\"line\">336</span><br><span class=\"line\">337</span><br><span class=\"line\">338</span><br><span class=\"line\">339</span><br><span class=\"line\">340</span><br><span class=\"line\">341</span><br><span class=\"line\">342</span><br><span class=\"line\">343</span><br><span class=\"line\">344</span><br><span class=\"line\">345</span><br><span class=\"line\">346</span><br><span class=\"line\">347</span><br><span class=\"line\">348</span><br><span class=\"line\">349</span><br><span class=\"line\">350</span><br><span class=\"line\">351</span><br><span class=\"line\">352</span><br><span class=\"line\">353</span><br><span class=\"line\">354</span><br><span class=\"line\">355</span><br><span class=\"line\">356</span><br><span class=\"line\">357</span><br><span class=\"line\">358</span><br><span class=\"line\">359</span><br><span class=\"line\">360</span><br><span class=\"line\">361</span><br><span class=\"line\">362</span><br><span class=\"line\">363</span><br><span class=\"line\">364</span><br><span class=\"line\">365</span><br><span class=\"line\">366</span><br><span class=\"line\">367</span><br><span class=\"line\">368</span><br><span class=\"line\">369</span><br><span class=\"line\">370</span><br><span class=\"line\">371</span><br><span class=\"line\">372</span><br><span class=\"line\">373</span><br><span class=\"line\">374</span><br><span class=\"line\">375</span><br><span class=\"line\">376</span><br><span class=\"line\">377</span><br><span class=\"line\">378</span><br><span class=\"line\">379</span><br><span class=\"line\">380</span><br><span class=\"line\">381</span><br><span class=\"line\">382</span><br><span class=\"line\">383</span><br><span class=\"line\">384</span><br><span class=\"line\">385</span><br><span class=\"line\">386</span><br><span class=\"line\">387</span><br><span class=\"line\">388</span><br><span class=\"line\">389</span><br><span class=\"line\">390</span><br><span class=\"line\">391</span><br><span class=\"line\">392</span><br><span class=\"line\">393</span><br><span class=\"line\">394</span><br><span class=\"line\">395</span><br><span class=\"line\">396</span><br><span class=\"line\">397</span><br><span class=\"line\">398</span><br><span class=\"line\">399</span><br><span class=\"line\">400</span><br><span class=\"line\">401</span><br><span class=\"line\">402</span><br><span class=\"line\">403</span><br><span class=\"line\">404</span><br><span class=\"line\">405</span><br><span class=\"line\">406</span><br><span class=\"line\">407</span><br><span class=\"line\">408</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"string\">&quot;&quot;&quot;</span></span><br><span class=\"line\"><span class=\"string\">Model definitions</span></span><br><span class=\"line\"><span class=\"string\"></span></span><br><span class=\"line\"><span class=\"string\">&quot;&quot;&quot;</span></span><br><span class=\"line\"><span class=\"keyword\">from</span> torch.autograd <span class=\"keyword\">import</span> Variable</span><br><span class=\"line\"><span class=\"keyword\">import</span> torch.nn <span class=\"keyword\">as</span> nn</span><br><span class=\"line\"><span class=\"keyword\">import</span> torch.nn.functional <span class=\"keyword\">as</span> F</span><br><span class=\"line\"><span class=\"keyword\">import</span> torch</span><br><span class=\"line\"><span class=\"keyword\">import</span> numpy <span class=\"keyword\">as</span> np</span><br><span class=\"line\"><span class=\"keyword\">import</span> math</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">from</span> model.resnet <span class=\"keyword\">import</span> resnet50</span><br><span class=\"line\"><span class=\"keyword\">from</span> model.rpn <span class=\"keyword\">import</span> RPN</span><br><span class=\"line\"><span class=\"comment\">#from model.lib.roi_align.roi_align.roi_align import RoIAlign</span></span><br><span class=\"line\"><span class=\"keyword\">from</span> model.lib.roi_align.roi_align.crop_and_resize <span class=\"keyword\">import</span> CropAndResize</span><br><span class=\"line\"><span class=\"keyword\">from</span> model.lib.bbox.generate_anchors <span class=\"keyword\">import</span> generate_pyramid_anchors</span><br><span class=\"line\"><span class=\"keyword\">from</span> model.lib.bbox.nms <span class=\"keyword\">import</span> torch_nms <span class=\"keyword\">as</span> nms</span><br><span class=\"line\"></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">def</span> <span class=\"title function_\">log2_graph</span>(<span class=\"params\">x</span>):</span><br><span class=\"line\">    <span class=\"string\">&quot;&quot;&quot;Implementatin of Log2. pytorch doesn&#x27;t have a native implemenation.&quot;&quot;&quot;</span></span><br><span class=\"line\">    <span class=\"keyword\">return</span> torch.div(torch.log(x), math.log(<span class=\"number\">2.</span>))</span><br><span class=\"line\"></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">def</span> <span class=\"title function_\">ROIAlign</span>(<span class=\"params\">feature_maps, rois, config, pool_size, mode=<span class=\"string\">&#x27;bilinear&#x27;</span></span>):</span><br><span class=\"line\">    <span class=\"string\">&quot;&quot;&quot;Implements ROI Align on the features.</span></span><br><span class=\"line\"><span class=\"string\">    Params:</span></span><br><span class=\"line\"><span class=\"string\">    - pool_shape: [height, width] of the output pooled regions. Usually [7, 7]</span></span><br><span class=\"line\"><span class=\"string\">    - image_shape: [height, width, chanells]. Shape of input image in pixels</span></span><br><span class=\"line\"><span class=\"string\">    Inputs:</span></span><br><span class=\"line\"><span class=\"string\">    - boxes: [batch, num_boxes, (x1, y1, x2, y2)] in normalized</span></span><br><span class=\"line\"><span class=\"string\">             coordinates. Possibly padded with zeros if not enough</span></span><br><span class=\"line\"><span class=\"string\">             boxes to fill the array.</span></span><br><span class=\"line\"><span class=\"string\">    - Feature maps: List of feature maps from different levels of the pyramid.</span></span><br><span class=\"line\"><span class=\"string\">                    Each is [batch, channels, height, width]</span></span><br><span class=\"line\"><span class=\"string\">    Output:</span></span><br><span class=\"line\"><span class=\"string\">    Pooled regions in the shape: [batch, num_boxes, height, width, channels].</span></span><br><span class=\"line\"><span class=\"string\">    The width and height are those specific in the pool_shape in the layer</span></span><br><span class=\"line\"><span class=\"string\">    constructor.</span></span><br><span class=\"line\"><span class=\"string\">    &quot;&quot;&quot;</span></span><br><span class=\"line\">    <span class=\"string\">&quot;&quot;&quot;</span></span><br><span class=\"line\"><span class=\"string\">    [  x2-x1             x1 + x2 - W + 1  ]</span></span><br><span class=\"line\"><span class=\"string\">    [  -----      0      ---------------  ]</span></span><br><span class=\"line\"><span class=\"string\">    [  W - 1                  W - 1       ]</span></span><br><span class=\"line\"><span class=\"string\">    [                                     ]</span></span><br><span class=\"line\"><span class=\"string\">    [           y2-y1    y1 + y2 - H + 1  ]</span></span><br><span class=\"line\"><span class=\"string\">    [    0      -----    ---------------  ]</span></span><br><span class=\"line\"><span class=\"string\">    [           H - 1         H - 1      ]</span></span><br><span class=\"line\"><span class=\"string\">    &quot;&quot;&quot;</span></span><br><span class=\"line\">    <span class=\"comment\">#feature_maps= [P2, P3, P4, P5]</span></span><br><span class=\"line\">    rois = rois.detach()</span><br><span class=\"line\">    crop_resize = CropAndResize(pool_size, pool_size, <span class=\"number\">0</span>)</span><br><span class=\"line\"></span><br><span class=\"line\">    roi_number = rois.size()[<span class=\"number\">1</span>]</span><br><span class=\"line\"></span><br><span class=\"line\">    pooled = rois.data.new(</span><br><span class=\"line\">            config.IMAGES_PER_GPU*rois.size(</span><br><span class=\"line\">            <span class=\"number\">1</span>), <span class=\"number\">256</span>, pool_size, pool_size).zero_()</span><br><span class=\"line\"></span><br><span class=\"line\">    rois = rois.view(</span><br><span class=\"line\">            config.IMAGES_PER_GPU*rois.size(<span class=\"number\">1</span>),</span><br><span class=\"line\">            <span class=\"number\">4</span>)</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\"># Loop through levels and apply ROI pooling to each. P2 to P5.</span></span><br><span class=\"line\">    x_1 = rois[:, <span class=\"number\">0</span>]</span><br><span class=\"line\">    y_1 = rois[:, <span class=\"number\">1</span>]</span><br><span class=\"line\">    x_2 = rois[:, <span class=\"number\">2</span>]</span><br><span class=\"line\">    y_2 = rois[:, <span class=\"number\">3</span>]</span><br><span class=\"line\"></span><br><span class=\"line\">    roi_level = log2_graph(</span><br><span class=\"line\">        torch.div(torch.sqrt((y_2 - y_1) * (x_2 - x_1)), <span class=\"number\">224.0</span>))</span><br><span class=\"line\"></span><br><span class=\"line\">    roi_level = torch.clamp(torch.clamp(</span><br><span class=\"line\">        torch.add(torch.<span class=\"built_in\">round</span>(roi_level), <span class=\"number\">4</span>), <span class=\"built_in\">min</span>=<span class=\"number\">2</span>), <span class=\"built_in\">max</span>=<span class=\"number\">5</span>)</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\"># P2 is 256x256, P3 is 128x128, P4 is 64x64, P5 is 32x32</span></span><br><span class=\"line\">    <span class=\"comment\"># P2 is 4, P3 is 8, P4 is 16, P5 is 32</span></span><br><span class=\"line\">    <span class=\"keyword\">for</span> i, level <span class=\"keyword\">in</span> <span class=\"built_in\">enumerate</span>(<span class=\"built_in\">range</span>(<span class=\"number\">2</span>, <span class=\"number\">6</span>)):</span><br><span class=\"line\"></span><br><span class=\"line\">        scaling_ratio = <span class=\"number\">2</span>**level</span><br><span class=\"line\"></span><br><span class=\"line\">        height = <span class=\"built_in\">float</span>(config.IMAGE_MAX_DIM)/ scaling_ratio</span><br><span class=\"line\">        width = <span class=\"built_in\">float</span>(config.IMAGE_MAX_DIM) / scaling_ratio</span><br><span class=\"line\"></span><br><span class=\"line\">        ixx = torch.eq(roi_level, level)</span><br><span class=\"line\"></span><br><span class=\"line\">        box_indices = ixx.view(-<span class=\"number\">1</span>).<span class=\"built_in\">int</span>() * <span class=\"number\">0</span></span><br><span class=\"line\">        ix = torch.unsqueeze(ixx, <span class=\"number\">1</span>)</span><br><span class=\"line\">        level_boxes = torch.masked_select(rois, ix)</span><br><span class=\"line\">        <span class=\"keyword\">if</span> level_boxes.size()[<span class=\"number\">0</span>] == <span class=\"number\">0</span>:</span><br><span class=\"line\">            <span class=\"keyword\">continue</span></span><br><span class=\"line\">        level_boxes = level_boxes.view(-<span class=\"number\">1</span>, <span class=\"number\">4</span>)</span><br><span class=\"line\"></span><br><span class=\"line\">        crops = crop_resize(feature_maps[i], torch.div(</span><br><span class=\"line\">                level_boxes, <span class=\"built_in\">float</span>(config.IMAGE_MAX_DIM)</span><br><span class=\"line\">                )[:, [<span class=\"number\">1</span>, <span class=\"number\">0</span>, <span class=\"number\">3</span>, <span class=\"number\">2</span>]], box_indices)</span><br><span class=\"line\"></span><br><span class=\"line\">        indices_pooled = ixx.nonzero()[:, <span class=\"number\">0</span>]</span><br><span class=\"line\">        pooled[indices_pooled.data, :, :, :] = crops.data</span><br><span class=\"line\"></span><br><span class=\"line\">    pooled = pooled.view(config.IMAGES_PER_GPU, roi_number,</span><br><span class=\"line\">               <span class=\"number\">256</span>, pool_size, pool_size)</span><br><span class=\"line\">    pooled = Variable(pooled).cuda()</span><br><span class=\"line\">    <span class=\"keyword\">return</span> pooled</span><br><span class=\"line\"></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\"># ---------------------------------------------------------------</span></span><br><span class=\"line\"><span class=\"comment\"># Heads</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">class</span> <span class=\"title class_\">MaskHead</span>(nn.Module):</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">def</span> <span class=\"title function_\">__init__</span>(<span class=\"params\">self, config</span>):</span><br><span class=\"line\">        <span class=\"built_in\">super</span>(MaskHead, <span class=\"variable language_\">self</span>).__init__()</span><br><span class=\"line\">        <span class=\"variable language_\">self</span>.config = config</span><br><span class=\"line\">        <span class=\"variable language_\">self</span>.num_classes = config.NUM_CLASSES</span><br><span class=\"line\">        <span class=\"comment\">#self.crop_size = config.mask_crop_size</span></span><br><span class=\"line\"></span><br><span class=\"line\">        <span class=\"comment\">#self.roi_align = RoIAlign(self.crop_size, self.crop_size)</span></span><br><span class=\"line\">        <span class=\"variable language_\">self</span>.conv1 = nn.Conv2d(<span class=\"number\">256</span>, <span class=\"number\">256</span>, kernel_size=<span class=\"number\">3</span>, padding=<span class=\"number\">1</span>, stride=<span class=\"number\">1</span>)</span><br><span class=\"line\">        <span class=\"variable language_\">self</span>.bn1 = nn.BatchNorm2d(<span class=\"number\">256</span>)</span><br><span class=\"line\">        <span class=\"variable language_\">self</span>.conv2 = nn.Conv2d(<span class=\"number\">256</span>, <span class=\"number\">256</span>, kernel_size=<span class=\"number\">3</span>, padding=<span class=\"number\">1</span>, stride=<span class=\"number\">1</span>)</span><br><span class=\"line\">        <span class=\"variable language_\">self</span>.bn2 = nn.BatchNorm2d(<span class=\"number\">256</span>)</span><br><span class=\"line\">        <span class=\"variable language_\">self</span>.conv3 = nn.Conv2d(<span class=\"number\">256</span>, <span class=\"number\">256</span>, kernel_size=<span class=\"number\">3</span>, padding=<span class=\"number\">1</span>, stride=<span class=\"number\">1</span>)</span><br><span class=\"line\">        <span class=\"variable language_\">self</span>.bn3 = nn.BatchNorm2d(<span class=\"number\">256</span>)</span><br><span class=\"line\">        <span class=\"variable language_\">self</span>.conv4 = nn.Conv2d(<span class=\"number\">256</span>, <span class=\"number\">256</span>, kernel_size=<span class=\"number\">3</span>, padding=<span class=\"number\">1</span>, stride=<span class=\"number\">1</span>)</span><br><span class=\"line\">        <span class=\"variable language_\">self</span>.bn4 = nn.BatchNorm2d(<span class=\"number\">256</span>)</span><br><span class=\"line\"></span><br><span class=\"line\">        <span class=\"variable language_\">self</span>.deconv = nn.ConvTranspose2d(<span class=\"number\">256</span>, <span class=\"number\">256</span>, kernel_size=<span class=\"number\">4</span>, padding=<span class=\"number\">1</span>, stride=<span class=\"number\">2</span>, bias=<span class=\"literal\">False</span>)</span><br><span class=\"line\">        <span class=\"variable language_\">self</span>.mask = nn.Conv2d(<span class=\"number\">256</span>, <span class=\"variable language_\">self</span>.num_classes, kernel_size=<span class=\"number\">1</span>, padding=<span class=\"number\">0</span>, stride=<span class=\"number\">1</span>)</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">def</span> <span class=\"title function_\">forward</span>(<span class=\"params\">self, x, rpn_rois</span>):</span><br><span class=\"line\">        <span class=\"comment\">#x = self.roi_align(x, rpn_rois)</span></span><br><span class=\"line\">        x = ROIAlign(x, rpn_rois, <span class=\"variable language_\">self</span>.config, <span class=\"variable language_\">self</span>.config.MASK_POOL_SIZE)</span><br><span class=\"line\"></span><br><span class=\"line\">        roi_number = x.size()[<span class=\"number\">1</span>]</span><br><span class=\"line\"></span><br><span class=\"line\">        <span class=\"comment\"># merge batch and roi number together</span></span><br><span class=\"line\">        x = x.view(<span class=\"variable language_\">self</span>.config.IMAGES_PER_GPU * roi_number,</span><br><span class=\"line\">                   <span class=\"number\">256</span>, <span class=\"variable language_\">self</span>.config.MASK_POOL_SIZE,</span><br><span class=\"line\">                   <span class=\"variable language_\">self</span>.config.MASK_POOL_SIZE)</span><br><span class=\"line\"></span><br><span class=\"line\">        x = F.relu(<span class=\"variable language_\">self</span>.bn1(<span class=\"variable language_\">self</span>.conv1(x)), inplace=<span class=\"literal\">True</span>)</span><br><span class=\"line\">        x = F.relu(<span class=\"variable language_\">self</span>.bn2(<span class=\"variable language_\">self</span>.conv2(x)), inplace=<span class=\"literal\">True</span>)</span><br><span class=\"line\">        x = F.relu(<span class=\"variable language_\">self</span>.bn3(<span class=\"variable language_\">self</span>.conv3(x)), inplace=<span class=\"literal\">True</span>)</span><br><span class=\"line\">        x = F.relu(<span class=\"variable language_\">self</span>.bn4(<span class=\"variable language_\">self</span>.conv4(x)), inplace=<span class=\"literal\">True</span>)</span><br><span class=\"line\">        x = <span class=\"variable language_\">self</span>.deconv(x)</span><br><span class=\"line\">        rcnn_mask_logits = <span class=\"variable language_\">self</span>.mask(x)</span><br><span class=\"line\"></span><br><span class=\"line\">        rcnn_mask_logits = rcnn_mask_logits.view(<span class=\"variable language_\">self</span>.config.IMAGES_PER_GPU,</span><br><span class=\"line\">                                                 roi_number,</span><br><span class=\"line\">                                                 <span class=\"variable language_\">self</span>.config.NUM_CLASSES,</span><br><span class=\"line\">                                                 <span class=\"variable language_\">self</span>.config.MASK_POOL_SIZE * <span class=\"number\">2</span>,</span><br><span class=\"line\">                                                 <span class=\"variable language_\">self</span>.config.MASK_POOL_SIZE * <span class=\"number\">2</span>)</span><br><span class=\"line\"></span><br><span class=\"line\">        <span class=\"keyword\">return</span> rcnn_mask_logits</span><br><span class=\"line\"></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">class</span> <span class=\"title class_\">RCNNHead</span>(nn.Module):</span><br><span class=\"line\">    <span class=\"keyword\">def</span> <span class=\"title function_\">__init__</span>(<span class=\"params\">self, config</span>):</span><br><span class=\"line\">        <span class=\"built_in\">super</span>(RCNNHead, <span class=\"variable language_\">self</span>).__init__()</span><br><span class=\"line\">        <span class=\"variable language_\">self</span>.config = config</span><br><span class=\"line\">        <span class=\"variable language_\">self</span>.num_classes = config.NUM_CLASSES</span><br><span class=\"line\">        <span class=\"comment\">#self.crop_size = config.rcnn_crop_size</span></span><br><span class=\"line\"></span><br><span class=\"line\">        <span class=\"comment\">#self.roi_align = RoIAlign(self.crop_size, self.crop_size)</span></span><br><span class=\"line\">        <span class=\"variable language_\">self</span>.fc1 = nn.Linear(<span class=\"number\">1024</span>, <span class=\"number\">1024</span>)</span><br><span class=\"line\">        <span class=\"variable language_\">self</span>.fc2 = nn.Linear(<span class=\"number\">1024</span>, <span class=\"number\">1024</span>)</span><br><span class=\"line\">        <span class=\"variable language_\">self</span>.class_logits = nn.Linear(<span class=\"number\">1024</span>, <span class=\"variable language_\">self</span>.num_classes)</span><br><span class=\"line\">        <span class=\"variable language_\">self</span>.bbox = nn.Linear(<span class=\"number\">1024</span>, <span class=\"variable language_\">self</span>.num_classes * <span class=\"number\">4</span>)</span><br><span class=\"line\"></span><br><span class=\"line\">        <span class=\"variable language_\">self</span>.conv1 = nn.Conv2d(<span class=\"number\">256</span>, <span class=\"number\">1024</span>, kernel_size=<span class=\"variable language_\">self</span>.config.POOL_SIZE, stride=<span class=\"number\">1</span>, padding=<span class=\"number\">0</span>)</span><br><span class=\"line\">        <span class=\"variable language_\">self</span>.bn1 = nn.BatchNorm2d(<span class=\"number\">1024</span>, eps=<span class=\"number\">0.001</span>)</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">def</span> <span class=\"title function_\">forward</span>(<span class=\"params\">self, x, rpn_rois</span>):</span><br><span class=\"line\">        x = ROIAlign(x, rpn_rois, <span class=\"variable language_\">self</span>.config, <span class=\"variable language_\">self</span>.config.POOL_SIZE)</span><br><span class=\"line\">        roi_number = x.size()[<span class=\"number\">1</span>]</span><br><span class=\"line\"></span><br><span class=\"line\">        x = x.view(<span class=\"variable language_\">self</span>.config.IMAGES_PER_GPU * roi_number,</span><br><span class=\"line\">                   <span class=\"number\">256</span>, <span class=\"variable language_\">self</span>.config.POOL_SIZE,</span><br><span class=\"line\">                   <span class=\"variable language_\">self</span>.config.POOL_SIZE)</span><br><span class=\"line\">        <span class=\"comment\">#print(x.shape)</span></span><br><span class=\"line\">        <span class=\"comment\">#x = self.roi_align(x, rpn_rois, self.config, self.config.POOL_SIZE)</span></span><br><span class=\"line\">        <span class=\"comment\">#x = crops.view(crops.size(0), -1)</span></span><br><span class=\"line\">        x = <span class=\"variable language_\">self</span>.bn1(<span class=\"variable language_\">self</span>.conv1(x))</span><br><span class=\"line\">        x = x.permute(<span class=\"number\">0</span>, <span class=\"number\">2</span>, <span class=\"number\">3</span>, <span class=\"number\">1</span>).contiguous().view(x.size(<span class=\"number\">0</span>), -<span class=\"number\">1</span>)</span><br><span class=\"line\">        x = F.relu(<span class=\"variable language_\">self</span>.fc1(x), inplace=<span class=\"literal\">True</span>)</span><br><span class=\"line\">        x = F.relu(<span class=\"variable language_\">self</span>.fc2(x), inplace=<span class=\"literal\">True</span>)</span><br><span class=\"line\">        <span class=\"comment\">#x = F.dropout(x, 0.5, training=self.training)</span></span><br><span class=\"line\">        rcnn_class_logits = <span class=\"variable language_\">self</span>.class_logits(x)</span><br><span class=\"line\">        rcnn_probs = F.softmax(rcnn_class_logits, dim=-<span class=\"number\">1</span>)</span><br><span class=\"line\"></span><br><span class=\"line\">        rcnn_bbox = <span class=\"variable language_\">self</span>.bbox(x)</span><br><span class=\"line\"></span><br><span class=\"line\">        rcnn_class_logits = rcnn_class_logits.view(<span class=\"variable language_\">self</span>.config.IMAGES_PER_GPU,</span><br><span class=\"line\">                                                   roi_number,</span><br><span class=\"line\">                                                   rcnn_class_logits.size()[-<span class=\"number\">1</span>])</span><br><span class=\"line\"></span><br><span class=\"line\">        rcnn_probs = rcnn_probs.view(<span class=\"variable language_\">self</span>.config.IMAGES_PER_GPU,</span><br><span class=\"line\">                                     roi_number,</span><br><span class=\"line\">                                     rcnn_probs.size()[-<span class=\"number\">1</span>])</span><br><span class=\"line\"></span><br><span class=\"line\">        rcnn_bbox = rcnn_bbox.view(<span class=\"variable language_\">self</span>.config.IMAGES_PER_GPU,</span><br><span class=\"line\">                                   roi_number,</span><br><span class=\"line\">                                   <span class=\"variable language_\">self</span>.config.NUM_CLASSES,</span><br><span class=\"line\">                                   <span class=\"number\">4</span>)</span><br><span class=\"line\"></span><br><span class=\"line\">        <span class=\"keyword\">return</span> rcnn_class_logits, rcnn_probs, rcnn_bbox</span><br><span class=\"line\"></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">#</span></span><br><span class=\"line\"><span class=\"comment\"># ---------------------------------------------------------------</span></span><br><span class=\"line\"><span class=\"comment\"># Mask R-CNN</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">class</span> <span class=\"title class_\">MaskRCNN</span>(nn.Module):</span><br><span class=\"line\">    <span class=\"string\">&quot;&quot;&quot;</span></span><br><span class=\"line\"><span class=\"string\">    Mask R-CNN model</span></span><br><span class=\"line\"><span class=\"string\">    &quot;&quot;&quot;</span></span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">def</span> <span class=\"title function_\">__init__</span>(<span class=\"params\">self, config</span>):</span><br><span class=\"line\">        <span class=\"built_in\">super</span>(MaskRCNN, <span class=\"variable language_\">self</span>).__init__()</span><br><span class=\"line\">        <span class=\"variable language_\">self</span>.config = config</span><br><span class=\"line\">        <span class=\"variable language_\">self</span>.__mode = <span class=\"string\">&#x27;train&#x27;</span></span><br><span class=\"line\">        feature_channels = <span class=\"number\">128</span></span><br><span class=\"line\">        <span class=\"comment\"># define modules (set of layers)</span></span><br><span class=\"line\"><span class=\"comment\">#        self.feature_net = FeatureNet(cfg, 3, feature_channels)</span></span><br><span class=\"line\">        <span class=\"variable language_\">self</span>.feature_net = resnet50().cuda()</span><br><span class=\"line\">        <span class=\"comment\">#self.rpn_head = RpnMultiHead(cfg,feature_channels)</span></span><br><span class=\"line\">        <span class=\"variable language_\">self</span>.rpn = RPN(<span class=\"number\">256</span>, <span class=\"built_in\">len</span>(<span class=\"variable language_\">self</span>.config.RPN_ANCHOR_RATIOS),</span><br><span class=\"line\">                             <span class=\"variable language_\">self</span>.config.RPN_ANCHOR_STRIDE)</span><br><span class=\"line\">        <span class=\"comment\">#self.rcnn_crop = CropRoi(cfg, cfg.rcnn_crop_size)</span></span><br><span class=\"line\">        <span class=\"variable language_\">self</span>.rcnn_head = RCNNHead(config)</span><br><span class=\"line\">        <span class=\"comment\">#self.mask_crop = CropRoi(cfg, cfg.mask_crop_size)</span></span><br><span class=\"line\">        <span class=\"variable language_\">self</span>.mask_head = MaskHead(config)</span><br><span class=\"line\"></span><br><span class=\"line\">        <span class=\"variable language_\">self</span>.anchors = generate_pyramid_anchors(<span class=\"variable language_\">self</span>.config.RPN_ANCHOR_SCALES,</span><br><span class=\"line\">                                                <span class=\"variable language_\">self</span>.config.RPN_ANCHOR_RATIOS,</span><br><span class=\"line\">                                                <span class=\"variable language_\">self</span>.config.BACKBONE_SHAPES,</span><br><span class=\"line\">                                                <span class=\"variable language_\">self</span>.config.BACKBONE_STRIDES,</span><br><span class=\"line\">                                                <span class=\"variable language_\">self</span>.config.RPN_ANCHOR_STRIDE)</span><br><span class=\"line\">        <span class=\"variable language_\">self</span>.anchors = <span class=\"variable language_\">self</span>.anchors.astype(np.float32)</span><br><span class=\"line\">        <span class=\"variable language_\">self</span>.proposal_count = <span class=\"variable language_\">self</span>.config.POST_NMS_ROIS_TRAINING</span><br><span class=\"line\">        <span class=\"comment\"># FPN</span></span><br><span class=\"line\">        <span class=\"variable language_\">self</span>.fpn_c5p5 = nn.Conv2d(</span><br><span class=\"line\">            <span class=\"number\">512</span> * <span class=\"number\">4</span>, <span class=\"number\">256</span>, kernel_size=<span class=\"number\">1</span>, stride=<span class=\"number\">1</span>, padding=<span class=\"number\">0</span>)</span><br><span class=\"line\">        <span class=\"variable language_\">self</span>.fpn_c4p4 = nn.Conv2d(</span><br><span class=\"line\">            <span class=\"number\">256</span> * <span class=\"number\">4</span>, <span class=\"number\">256</span>, kernel_size=<span class=\"number\">1</span>, stride=<span class=\"number\">1</span>, padding=<span class=\"number\">0</span>)</span><br><span class=\"line\">        <span class=\"variable language_\">self</span>.fpn_c3p3 = nn.Conv2d(</span><br><span class=\"line\">            <span class=\"number\">128</span> * <span class=\"number\">4</span>, <span class=\"number\">256</span>, kernel_size=<span class=\"number\">1</span>, stride=<span class=\"number\">1</span>, padding=<span class=\"number\">0</span>)</span><br><span class=\"line\">        <span class=\"variable language_\">self</span>.fpn_c2p2 = nn.Conv2d(</span><br><span class=\"line\">            <span class=\"number\">64</span> * <span class=\"number\">4</span>, <span class=\"number\">256</span>, kernel_size=<span class=\"number\">1</span>, stride=<span class=\"number\">1</span>,  padding=<span class=\"number\">0</span>)</span><br><span class=\"line\"></span><br><span class=\"line\">        <span class=\"variable language_\">self</span>.fpn_p2 = nn.Conv2d(<span class=\"number\">256</span>, <span class=\"number\">256</span>, kernel_size=<span class=\"number\">3</span>, stride=<span class=\"number\">1</span>, padding=<span class=\"number\">1</span>)</span><br><span class=\"line\">        <span class=\"variable language_\">self</span>.fpn_p3 = nn.Conv2d(<span class=\"number\">256</span>, <span class=\"number\">256</span>, kernel_size=<span class=\"number\">3</span>, stride=<span class=\"number\">1</span>, padding=<span class=\"number\">1</span>)</span><br><span class=\"line\">        <span class=\"variable language_\">self</span>.fpn_p4 = nn.Conv2d(<span class=\"number\">256</span>, <span class=\"number\">256</span>, kernel_size=<span class=\"number\">3</span>, stride=<span class=\"number\">1</span>, padding=<span class=\"number\">1</span>)</span><br><span class=\"line\">        <span class=\"variable language_\">self</span>.fpn_p5 = nn.Conv2d(<span class=\"number\">256</span>, <span class=\"number\">256</span>, kernel_size=<span class=\"number\">3</span>, stride=<span class=\"number\">1</span>, padding=<span class=\"number\">1</span>)</span><br><span class=\"line\"></span><br><span class=\"line\">        <span class=\"variable language_\">self</span>.scale_ratios = [<span class=\"number\">4</span>, <span class=\"number\">8</span>, <span class=\"number\">16</span>, <span class=\"number\">32</span>]</span><br><span class=\"line\">        <span class=\"variable language_\">self</span>.fpn_p6 = nn.MaxPool2d(</span><br><span class=\"line\">            kernel_size=<span class=\"number\">1</span>, stride=<span class=\"number\">2</span>, padding=<span class=\"number\">0</span>, ceil_mode=<span class=\"literal\">False</span>)</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">def</span> <span class=\"title function_\">forward</span>(<span class=\"params\">self, x</span>):</span><br><span class=\"line\">        <span class=\"comment\"># Extract features</span></span><br><span class=\"line\">        C1, C2, C3, C4, C5 = <span class=\"variable language_\">self</span>.feature_net(x)</span><br><span class=\"line\">        P5 = <span class=\"variable language_\">self</span>.fpn_c5p5(C5)</span><br><span class=\"line\">        P4 = <span class=\"variable language_\">self</span>.fpn_c4p4(C4) + F.upsample(P5,</span><br><span class=\"line\">                                            scale_factor=<span class=\"number\">2</span>, mode=<span class=\"string\">&#x27;bilinear&#x27;</span>)</span><br><span class=\"line\">        P3 = <span class=\"variable language_\">self</span>.fpn_c3p3(C3) + F.upsample(P4,</span><br><span class=\"line\">                                            scale_factor=<span class=\"number\">2</span>, mode=<span class=\"string\">&#x27;bilinear&#x27;</span>)</span><br><span class=\"line\">        P2 = <span class=\"variable language_\">self</span>.fpn_c2p2(C2) + F.upsample(P3,</span><br><span class=\"line\">                                            scale_factor=<span class=\"number\">2</span>, mode=<span class=\"string\">&#x27;bilinear&#x27;</span>)</span><br><span class=\"line\"></span><br><span class=\"line\">        <span class=\"comment\"># Attach 3x3 conv to all P layers to get the final feature maps.</span></span><br><span class=\"line\">        <span class=\"comment\"># P2 is 256, P3 is 128, P4 is 64, P5 is 32</span></span><br><span class=\"line\">        P2 = <span class=\"variable language_\">self</span>.fpn_p2(P2)</span><br><span class=\"line\">        P3 = <span class=\"variable language_\">self</span>.fpn_p3(P3)</span><br><span class=\"line\">        P4 = <span class=\"variable language_\">self</span>.fpn_p4(P4)</span><br><span class=\"line\">        P5 = <span class=\"variable language_\">self</span>.fpn_p5(P5)</span><br><span class=\"line\">        <span class=\"comment\"># P6 is used for the 5th anchor scale in RPN. Generated by</span></span><br><span class=\"line\">        <span class=\"comment\"># subsampling from P5 with stride of 2.</span></span><br><span class=\"line\">        P6 = <span class=\"variable language_\">self</span>.fpn_p6(P5)</span><br><span class=\"line\"></span><br><span class=\"line\">        <span class=\"comment\"># Note that P6 is used in RPN, but not in the classifier heads.</span></span><br><span class=\"line\">        rpn_feature_maps = [P2, P3, P4, P5, P6]</span><br><span class=\"line\"></span><br><span class=\"line\">        <span class=\"variable language_\">self</span>.mrcnn_feature_maps = [P2, P3, P4, P5]</span><br><span class=\"line\"></span><br><span class=\"line\">        rpn_class_logits_outputs = []</span><br><span class=\"line\">        rpn_class_outputs = []</span><br><span class=\"line\">        rpn_bbox_outputs = []</span><br><span class=\"line\">        <span class=\"comment\"># RPN proposals</span></span><br><span class=\"line\">        <span class=\"keyword\">for</span> feature <span class=\"keyword\">in</span> rpn_feature_maps:</span><br><span class=\"line\">            rpn_class_logits, rpn_probs, rpn_bbox = <span class=\"variable language_\">self</span>.rpn(feature)</span><br><span class=\"line\">            rpn_class_logits_outputs.append(rpn_class_logits)</span><br><span class=\"line\">            rpn_class_outputs.append(rpn_probs)</span><br><span class=\"line\">            rpn_bbox_outputs.append(rpn_bbox)</span><br><span class=\"line\"></span><br><span class=\"line\">        rpn_class_logits = torch.cat(rpn_class_logits_outputs, dim=<span class=\"number\">1</span>)</span><br><span class=\"line\">        rpn_class = torch.cat(rpn_class_outputs, dim=<span class=\"number\">1</span>)</span><br><span class=\"line\">        rpn_bbox = torch.cat(rpn_bbox_outputs, dim=<span class=\"number\">1</span>)</span><br><span class=\"line\"></span><br><span class=\"line\">        rpn_proposals = <span class=\"variable language_\">self</span>.proposal_layer(rpn_class, rpn_bbox)</span><br><span class=\"line\"></span><br><span class=\"line\">        <span class=\"comment\"># RCNN proposals</span></span><br><span class=\"line\">        rcnn_class_logits, rcnn_class, rcnn_bbox = <span class=\"variable language_\">self</span>.rcnn_head(<span class=\"variable language_\">self</span>.mrcnn_feature_maps, rpn_proposals)</span><br><span class=\"line\">        rcnn_mask_logits = <span class=\"variable language_\">self</span>.mask_head(<span class=\"variable language_\">self</span>.mrcnn_feature_maps, rpn_proposals)</span><br><span class=\"line\">        <span class=\"comment\"># &lt;todo&gt; mask nms</span></span><br><span class=\"line\"></span><br><span class=\"line\">        <span class=\"keyword\">return</span> [rpn_class_logits, rpn_class, rpn_bbox, rpn_proposals,</span><br><span class=\"line\">                rcnn_class_logits, rcnn_class, rcnn_bbox,</span><br><span class=\"line\">                rcnn_mask_logits]</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">def</span> <span class=\"title function_\">proposal_layer</span>(<span class=\"params\">self, rpn_class, rpn_bbox</span>):</span><br><span class=\"line\">        <span class=\"comment\"># handling proposals</span></span><br><span class=\"line\">        scores = rpn_class[:, :, <span class=\"number\">1</span>]</span><br><span class=\"line\">        <span class=\"comment\">#print(scores.shape)</span></span><br><span class=\"line\">        <span class=\"comment\"># Box deltas [batch, num_rois, 4]</span></span><br><span class=\"line\">        deltas_mul = Variable(torch.from_numpy(np.reshape(</span><br><span class=\"line\">            <span class=\"variable language_\">self</span>.config.RPN_BBOX_STD_DEV, [<span class=\"number\">1</span>, <span class=\"number\">1</span>, <span class=\"number\">4</span>]).astype(np.float32))).cuda()</span><br><span class=\"line\">        deltas = rpn_bbox * deltas_mul</span><br><span class=\"line\"></span><br><span class=\"line\">        pre_nms_limit = <span class=\"built_in\">min</span>(<span class=\"number\">6000</span>, <span class=\"variable language_\">self</span>.anchors.shape[<span class=\"number\">0</span>])</span><br><span class=\"line\"></span><br><span class=\"line\">        scores, ix = torch.topk(scores, pre_nms_limit, dim=-<span class=\"number\">1</span>,</span><br><span class=\"line\">                                largest=<span class=\"literal\">True</span>, <span class=\"built_in\">sorted</span>=<span class=\"literal\">True</span>)</span><br><span class=\"line\"></span><br><span class=\"line\">        ix = torch.unsqueeze(ix, <span class=\"number\">2</span>)</span><br><span class=\"line\">        ix = torch.cat([ix, ix, ix, ix], dim=<span class=\"number\">2</span>)</span><br><span class=\"line\">        deltas = torch.gather(deltas, <span class=\"number\">1</span>, ix)</span><br><span class=\"line\"></span><br><span class=\"line\">        _anchors = []</span><br><span class=\"line\">        <span class=\"keyword\">for</span> i <span class=\"keyword\">in</span> <span class=\"built_in\">range</span>(<span class=\"variable language_\">self</span>.config.IMAGES_PER_GPU):</span><br><span class=\"line\">            anchors = Variable(torch.from_numpy(</span><br><span class=\"line\">                <span class=\"variable language_\">self</span>.anchors.astype(np.float32))).cuda()</span><br><span class=\"line\">            _anchors.append(anchors)</span><br><span class=\"line\">        anchors = torch.stack(_anchors, <span class=\"number\">0</span>)</span><br><span class=\"line\"></span><br><span class=\"line\">        pre_nms_anchors = torch.gather(anchors, <span class=\"number\">1</span>, ix)</span><br><span class=\"line\">        refined_anchors = apply_box_deltas_graph(pre_nms_anchors, deltas)</span><br><span class=\"line\"></span><br><span class=\"line\">        <span class=\"comment\"># Clip to image boundaries. [batch, N, (y1, x1, y2, x2)]</span></span><br><span class=\"line\">        height, width = <span class=\"variable language_\">self</span>.config.IMAGE_SHAPE[:<span class=\"number\">2</span>]</span><br><span class=\"line\">        window = np.array([<span class=\"number\">0</span>, <span class=\"number\">0</span>, height, width]).astype(np.float32)</span><br><span class=\"line\">        window = Variable(torch.from_numpy(window)).cuda()</span><br><span class=\"line\"></span><br><span class=\"line\">        refined_anchors_clipped = clip_boxes_graph(refined_anchors, window)</span><br><span class=\"line\"></span><br><span class=\"line\">        refined_proposals = []</span><br><span class=\"line\">        scores = scores[:,:,<span class=\"literal\">None</span>]</span><br><span class=\"line\">        <span class=\"comment\">#print(scores.data.shape)</span></span><br><span class=\"line\">        <span class=\"comment\">#print(refined_anchors_clipped.data.shape)</span></span><br><span class=\"line\">        <span class=\"keyword\">for</span> i <span class=\"keyword\">in</span> <span class=\"built_in\">range</span>(<span class=\"variable language_\">self</span>.config.IMAGES_PER_GPU):</span><br><span class=\"line\">            indices = nms(</span><br><span class=\"line\">                torch.cat([refined_anchors_clipped.data[i], scores.data[i]], <span class=\"number\">1</span>), <span class=\"number\">0.7</span>)</span><br><span class=\"line\">            indices = indices[:<span class=\"variable language_\">self</span>.proposal_count]</span><br><span class=\"line\">            indices = torch.stack([indices, indices, indices, indices], dim=<span class=\"number\">1</span>)</span><br><span class=\"line\">            indices = Variable(indices).cuda()</span><br><span class=\"line\">            proposals = torch.gather(refined_anchors_clipped[i], <span class=\"number\">0</span>, indices)</span><br><span class=\"line\">            padding = <span class=\"variable language_\">self</span>.proposal_count - proposals.size()[<span class=\"number\">0</span>]</span><br><span class=\"line\">            proposals = torch.cat(</span><br><span class=\"line\">                [proposals, Variable(torch.zeros([padding, <span class=\"number\">4</span>])).cuda()], <span class=\"number\">0</span>)</span><br><span class=\"line\">            refined_proposals.append(proposals)</span><br><span class=\"line\"></span><br><span class=\"line\">        rpn_rois = torch.stack(refined_proposals, <span class=\"number\">0</span>)</span><br><span class=\"line\"></span><br><span class=\"line\">        <span class=\"keyword\">return</span> rpn_rois</span><br><span class=\"line\"></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">def</span> <span class=\"title function_\">apply_box_deltas_graph</span>(<span class=\"params\">boxes, deltas</span>):</span><br><span class=\"line\">    <span class=\"string\">&quot;&quot;&quot;Applies the given deltas to the given boxes.</span></span><br><span class=\"line\"><span class=\"string\">    boxes: [N, 4] where each row is y1, x1, y2, x2</span></span><br><span class=\"line\"><span class=\"string\">    deltas: [N, 4] where each row is [dy, dx, log(dh), log(dw)]</span></span><br><span class=\"line\"><span class=\"string\">    &quot;&quot;&quot;</span></span><br><span class=\"line\">    <span class=\"comment\"># Convert to y, x, h, w</span></span><br><span class=\"line\">    height = boxes[:, :, <span class=\"number\">2</span>] - boxes[:, :, <span class=\"number\">0</span>]</span><br><span class=\"line\">    width = boxes[:, :, <span class=\"number\">3</span>] - boxes[:, :, <span class=\"number\">1</span>]</span><br><span class=\"line\">    center_y = boxes[:, :, <span class=\"number\">0</span>] + <span class=\"number\">0.5</span> * height</span><br><span class=\"line\">    center_x = boxes[:, :, <span class=\"number\">1</span>] + <span class=\"number\">0.5</span> * width</span><br><span class=\"line\">    <span class=\"comment\"># Apply deltas</span></span><br><span class=\"line\">    center_y += deltas[:, :, <span class=\"number\">0</span>] * height</span><br><span class=\"line\">    center_x += deltas[:, :, <span class=\"number\">1</span>] * width</span><br><span class=\"line\">    height *= torch.exp(deltas[:, :, <span class=\"number\">2</span>])</span><br><span class=\"line\">    width *= torch.exp(deltas[:, :, <span class=\"number\">3</span>])</span><br><span class=\"line\">    <span class=\"comment\"># Convert back to y1, x1, y2, x2</span></span><br><span class=\"line\">    y1 = center_y - <span class=\"number\">0.5</span> * height</span><br><span class=\"line\">    x1 = center_x - <span class=\"number\">0.5</span> * width</span><br><span class=\"line\">    y2 = y1 + height</span><br><span class=\"line\">    x2 = x1 + width</span><br><span class=\"line\">    result = [y1, x1, y2, x2]</span><br><span class=\"line\">    <span class=\"keyword\">return</span> result</span><br><span class=\"line\"></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">def</span> <span class=\"title function_\">clip_boxes_graph</span>(<span class=\"params\">boxes, window</span>):</span><br><span class=\"line\">    <span class=\"string\">&quot;&quot;&quot;</span></span><br><span class=\"line\"><span class=\"string\">    boxes: [N, 4] each row is y1, x1, y2, x2</span></span><br><span class=\"line\"><span class=\"string\">    window: [4] in the form y1, x1, y2, x2</span></span><br><span class=\"line\"><span class=\"string\">    &quot;&quot;&quot;</span></span><br><span class=\"line\">    <span class=\"comment\"># Split corners</span></span><br><span class=\"line\">    wy1, wx1, wy2, wx2 = window</span><br><span class=\"line\">    y1, x1, y2, x2 = boxes</span><br><span class=\"line\">    <span class=\"comment\"># Clip</span></span><br><span class=\"line\"></span><br><span class=\"line\">    y1 = torch.<span class=\"built_in\">max</span>(torch.<span class=\"built_in\">min</span>(y1, wy2), wy1)</span><br><span class=\"line\">    x1 = torch.<span class=\"built_in\">max</span>(torch.<span class=\"built_in\">min</span>(x1, wx2), wx1)</span><br><span class=\"line\">    y2 = torch.<span class=\"built_in\">max</span>(torch.<span class=\"built_in\">min</span>(y2, wy2), wy1)</span><br><span class=\"line\">    x2 = torch.<span class=\"built_in\">max</span>(torch.<span class=\"built_in\">min</span>(x2, wx2), wx1)</span><br><span class=\"line\"></span><br><span class=\"line\">    clipped = torch.stack([x1, y1, x2, y2], dim=<span class=\"number\">2</span>)</span><br><span class=\"line\">    <span class=\"keyword\">return</span> clipped</span><br></pre></td></tr></table></figure>\n\n<h4 id=\"相关资源\"><a href=\"#相关资源\" class=\"headerlink\" title=\"相关资源\"></a>相关资源</h4><h5 id=\"项目\"><a href=\"#项目\" class=\"headerlink\" title=\"项目\"></a><strong>项目</strong></h5><ol>\n<li><a href=\"https://github.com/JenifferWuUCLA/pulmonary-nodules-MaskRCNN/tree/master\">JenifferWuUCLA&#x2F;pulmonary-nodules-MaskRCNN: Mask R-CNN for Pulmonary Nodules Diagnosis, using TensorFlow 天池医疗 AI 大赛：Mask R-CNN 肺部结节智能检测（Segmentation + Classification）</a></li>\n<li><a href=\"https://github.com/facebookresearch/maskrcnn-benchmark\">facebookresearch&#x2F;maskrcnn-benchmark: Fast, modular reference implementation of Instance Segmentation and Object Detection algorithms in PyTorch.</a></li>\n<li><a href=\"https://github.com/leon-liangwu/MaskYolo_Caffe?tab=readme-ov-file\">leon-liangwu&#x2F;MaskYolo_Caffe: YOLO V2 &amp; V3 , YOLO Combined with RCNN and MaskRCNN</a></li>\n<li><a href=\"https://github.com/TannerGilbert/MaskRCNN-Object-Detection-and-Segmentation\">TannerGilbert&#x2F;MaskRCNN-Object-Detection-and-Segmentation: Train your own custom MaskRCNN Object Detection and Instance Segmentation model.</a></li>\n<li><a href=\"https://github.com/CharlesShang/FastMaskRCNN\">CharlesShang&#x2F;FastMaskRCNN: Mask RCNN in TensorFlow</a></li>\n<li><a href=\"https://github.com/buseyaren/installation-guide-of-maskrcnn?tab=readme-ov-file\">buseyaren&#x2F;installation-guide-of-maskrcnn: Mask R-CNN creates a high-quality segmentation mask in addition to the Faster R-CNN network. In addition to class labels and scores, a segmentation mask is created for the objects detected by this neural network. In this repository, using Anaconda prompt step by step Mask R-CNN setup is shown.</a></li>\n</ol>\n<h5 id=\"博客\"><a href=\"#博客\" class=\"headerlink\" title=\"博客\"></a>博客</h5><ol>\n<li><a href=\"https://blog.csdn.net/qq_37541097/article/details/123754766\">Mask R-CNN 网络详解_maskrcnn-CSDN 博客</a></li>\n<li><a href=\"https://blog.csdn.net/zimiao552147572/article/details/105300202?utm_medium=distribute.pc_relevant.none-task-blog-2~default~baidujs_baidulandingword~default-0-105300202-blog-123754766.235%5Ev43%5Epc_blog_bottom_relevance_base8&spm=1001.2101.3001.4242.1&utm_relevant_index=2\">目标分割：Mask RCNN_mask r-cnn-CSDN 博客</a></li>\n</ol>\n<h5 id=\"论文\"><a href=\"#论文\" class=\"headerlink\" title=\"论文\"></a>论文</h5><ol>\n<li><a href=\"https://arxiv.org/pdf/1703.06870\">arxiv.org&#x2F;pdf&#x2F;1703.06870</a></li>\n<li><a href=\"https://arxiv.org/abs/1908.04373\">MULAN: Multitask Universal Lesion Analysis Network for Joint Lesion Detection, Tagging, and Segmentation</a></li>\n<li><a href=\"https://arxiv.org/abs/1901.03353\">RetinaMask: Learning to predict masks improves state-of-the-art single-shot detection for free</a></li>\n<li><a href=\"https://arxiv.org/abs/1904.01355\">FCOS: Fully Convolutional One-Stage Object Detection</a></li>\n<li><a href=\"https://arxiv.org/abs/1909.04868\">Is Sampling Heuristics Necessary in Training Deep Object Detectors?</a></li>\n</ol>\n<hr>\n","excerpt":"","more":"<h1 id=\"实例分割（Instance-Segmentation）\"><a href=\"#实例分割（Instance-Segmentation）\" class=\"headerlink\" title=\"实例分割（Instance Segmentation）\"></a><strong>实例分割（Instance Segmentation）</strong></h1><h2 id=\"定义\"><a href=\"#定义\" class=\"headerlink\" title=\"** 定义**\"></a>** 定义**</h2><p>实例分割是目标检测和语义分割的结合，旨在精确识别图像中的每个目标对象，并区分同一类别中的不同实例。例如，在一张包含多个人的图像中，实例分割不仅需要识别出“人”这一类别，还需要将每个人单独区分开来，为每个人生成独立的分割掩码（Mask）。</p>\n<p>实例分割通过融合目标检测和语义分割的结果来实现这一目标。具体而言，它利用目标检测提供的目标类别和位置信息（如边界框和置信度），从语义分割的结果中提取出对应目标的像素级掩码。简而言之，实例分割的任务是将同一类别中的具体对象（即实例）分别分割出来。</p>\n<p>举个例子,近年来，随着自动驾驶等领域的快速发展，实例分割任务受到了广泛关注。自动驾驶场景中，精确区分和分割道路上的行人、车辆等目标对于环境感知和决策至关重要。此外，一些实例分割任务还会输出检测结果（如边界框），以提供更全面的目标描述。</p>\n<p>对实例分割、语义分割和目标检测混合任务感兴趣的读者，可以参考 CVPR 2019 的论文《Hybrid Task Cascade》（HTC），该研究提出了一种混合任务级联框架，能够同时处理这三种任务，为多任务学习提供了新的思路。</p>\n<h2 id=\"特点\"><a href=\"#特点\" class=\"headerlink\" title=\"特点\"></a><strong>特点</strong></h2><ul>\n<li>能够精确地定位和区分同一类别的不同实例。</li>\n<li>计算成本较高，因为需要对每个目标实例进行单独检测和分类。</li>\n</ul>\n<h2 id=\"应用\"><a href=\"#应用\" class=\"headerlink\" title=\"** 应用**\"></a>** 应用**</h2><p>实例分割在以下领域有重要应用：</p>\n<ul>\n<li><strong>自动驾驶</strong>：用于检测和分割车辆、行人。</li>\n<li><strong>医学成像</strong>：用于检测组织和病理的特定边界。</li>\n<li><strong>机器人视觉</strong>：用于识别和隔离目标物体。</li>\n</ul>\n<h2 id=\"常见模型\"><a href=\"#常见模型\" class=\"headerlink\" title=\"** 常见模型**\"></a>** 常见模型**</h2><h3 id=\"Mask-R-CNN\"><a href=\"#Mask-R-CNN\" class=\"headerlink\" title=\"Mask R-CNN\"></a><strong>Mask R-CNN</strong></h3><ul>\n<li><strong>优点</strong>：能够同时进行目标检测和语义分割，具有较好的性能。</li>\n<li><strong>缺点</strong>：模型参数多，训练和推理速度较慢；大目标的边缘分割较为粗糙。</li>\n</ul>\n<h4 id=\"提出初衷\"><a href=\"#提出初衷\" class=\"headerlink\" title=\"提出初衷\"></a>提出初衷</h4><p>Mask R-CNN 是 2017 年发表的文章，一作是何恺明大神，没错就是那个男人，除此之外还有 Faster R-CNN 系列的大神 Ross Girshick，可以说是强强联合。该论文也获得了 ICCV 2017 的最佳论文奖（Marr Prize）。并且该网络提出后，又霸榜了 MS COCO 的各项任务，包括目标检测、实例分割以及人体关键点检测任务。Mask R-CNN 的结构很简洁而且很灵活效果又很好（仅仅是在 Faster R-CNN 的基础上根据需求加入一些新的分支）。<br>Mask R-CNN 的提出初衷是为了实现高效且精确的实例分割任务，同时继承 Faster R-CNN 在目标检测方面的优势。具体而言，Mask R-CNN 的核心动机是将目标检测与语义分割相结合，既能检测图像中的目标并定位其边界框，又能为每个目标生成精确的像素级分割掩码。此外，Mask R-CNN 通过引入 RoI Align 技术，解决了 Faster R-CNN 中 RoI Pooling 导致的特征图与原始图像区域对齐不精确的问题，显著提高了分割掩码的精度。Mask R-CNN 在 Faster R-CNN 的基础上增加了全卷积网络（FCN）分支，用于预测每个感兴趣区域（RoI）的分割掩码，这种设计不仅简单高效，且只增加了较小的计算开销。<br><img src=\"https://tk-pichost-1325224430.cos.ap-chengdu.myqcloud.com/blog/1740407201646JSjbb2yMTo66D3xSrKfcVwQCnSc.png\" alt=\"1740407201646JSjbb2yMTo66D3xSrKfcVwQCnSc.png\"><br>它还具备良好的多任务扩展性，能够轻松扩展到其他任务（如人体关键点检测），成为一种通用的视觉框架。通过为每个类别预测独立的二元掩码，Mask R-CNN 能够更好地提取目标的空间布局信息，从而生成更精确的分割掩码，并在 COCO 等数据集上取得了显著优于当时其他模型的性能。总之，Mask R-CNN 的提出填补了目标检测和语义分割之间的空白，提供了一种高精度、高效率的实例分割解决方案。<br><img src=\"https://tk-pichost-1325224430.cos.ap-chengdu.myqcloud.com/blog/1740407212685Z2kFbwjzroUn5Xx4JNDcueDNnK2.png\" alt=\"1740407212685Z2kFbwjzroUn5Xx4JNDcueDNnK2.png\"><br>Mask R-CNN 的提出初衷是为了实现高效且精确的实例分割任务，同时继承 Faster R-CNN 在目标检测方面的优势。具体动机和背景如下：</p>\n<ol>\n<li><strong>结合目标检测与语义分割</strong><br>在 Mask R-CNN 提出之前，目标检测（如 Faster R-CNN）和语义分割（如 FCN）是两个独立的领域。Mask R-CNN 的核心动机是将两者结合起来，既能够检测图像中的目标并定位其边界框，还能为每个目标生成精确的像素级分割掩码。</li>\n<li><strong>解决像素级对齐问题</strong><br>Faster R-CNN 在处理像素级任务时存在局限性，尤其是其 RoI Pooling 操作会导致特征图与原始图像区域的对齐不精确。Mask R-CNN 通过引入 RoI Align 技术，解决了这一问题，显著提高了分割掩码的精度。</li>\n<li><strong>简单高效的架构设计</strong><br>Mask R-CNN 在 Faster R-CNN 的基础上，增加了一个全卷积网络（FCN）分支，用于预测每个感兴趣区域（RoI）的分割掩码。这种设计不仅简单高效，而且只增加了较小的计算开销。</li>\n<li><strong>多任务学习的扩展性</strong><br>Mask R-CNN 不仅适用于实例分割，还可以轻松扩展到其他任务，如人体关键点检测。这种多任务扩展性使其成为一种通用的视觉框架。</li>\n<li><strong>提升实例分割精度</strong><br>通过为每个类别预测独立的二元掩码，Mask R-CNN 能够更好地提取目标的空间布局信息，从而生成更精确的分割掩码。这一改进使其在 COCO 等数据集上取得了显著优于当时其他模型的性能。</li>\n</ol>\n<h4 id=\"网络结构\"><a href=\"#网络结构\" class=\"headerlink\" title=\"网络结构\"></a>网络结构</h4><p>Mask R-CNN 的结构也很简单，就是在通过 RoIAlign（在原 Faster R-CNN 中是 RoIPool）得到的 RoI 基础上并行添加一个 Mask 分支（小型的 FCN）。见下图，之前 Faster R-CNN 是在 RoI 基础上接上一个 Fast R-CNN 检测头，即图中 class, box 分支，现在又并行了一个 Mask 分支。<br><img src=\"https://tk-pichost-1325224430.cos.ap-chengdu.myqcloud.com/blog/1740407241647NcMPbytf4o9G40xNM1UcgSMbn4f.png\" alt=\"1740407241647NcMPbytf4o9G40xNM1UcgSMbn4f.png\"></p>\n<p><img src=\"https://tk-pichost-1325224430.cos.ap-chengdu.myqcloud.com/blog/1740407249647WI67bCnZrobIRSx9aWhclwDEnlj.png\" alt=\"1740407249647WI67bCnZrobIRSx9aWhclwDEnlj.png\"><br>注意带和不带 FPN 结构的 Mask R-CNN 在 Mask 分支上略有不同，对于带有 FPN 结构的 Mask R-CNN 它的 class、box 分支和 Mask 分支并不是共用一个 RoIAlign。在训练过程中，对于 class, box 分支 RoIAlign 将 RPN（Region Proposal Network）得到的 Proposals 池化到 7x7 大小，而对于 Mask 分支 RoIAlign 将 Proposals 池化到 14x14 大小。<br><img src=\"https://tk-pichost-1325224430.cos.ap-chengdu.myqcloud.com/blog/1740407261695EyHvbUkC0ouDKnxVfEGcm0iKnKd.png\" alt=\"1740407261695EyHvbUkC0ouDKnxVfEGcm0iKnKd.png\"></p>\n<p><img src=\"https://tk-pichost-1325224430.cos.ap-chengdu.myqcloud.com/blog/1740407267643MVthb679voUnaYxQpPBcDtJCnIf.png\" alt=\"1740407267643MVthb679voUnaYxQpPBcDtJCnIf.png\"></p>\n<blockquote>\n<p>Q:<strong>Mask R-CNN 中的 RoI Align 技术是如何解决 Faster R-CNN 中 RoI Pooling 导致的特征图与原始图像区域对齐不精确的问题的呢？</strong></p>\n</blockquote>\n<h4 id=\"模型代码\"><a href=\"#模型代码\" class=\"headerlink\" title=\"模型代码\"></a>模型代码</h4><figure class=\"highlight python\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br><span class=\"line\">47</span><br><span class=\"line\">48</span><br><span class=\"line\">49</span><br><span class=\"line\">50</span><br><span class=\"line\">51</span><br><span class=\"line\">52</span><br><span class=\"line\">53</span><br><span class=\"line\">54</span><br><span class=\"line\">55</span><br><span class=\"line\">56</span><br><span class=\"line\">57</span><br><span class=\"line\">58</span><br><span class=\"line\">59</span><br><span class=\"line\">60</span><br><span class=\"line\">61</span><br><span class=\"line\">62</span><br><span class=\"line\">63</span><br><span class=\"line\">64</span><br><span class=\"line\">65</span><br><span class=\"line\">66</span><br><span class=\"line\">67</span><br><span class=\"line\">68</span><br><span class=\"line\">69</span><br><span class=\"line\">70</span><br><span class=\"line\">71</span><br><span class=\"line\">72</span><br><span class=\"line\">73</span><br><span class=\"line\">74</span><br><span class=\"line\">75</span><br><span class=\"line\">76</span><br><span class=\"line\">77</span><br><span class=\"line\">78</span><br><span class=\"line\">79</span><br><span class=\"line\">80</span><br><span class=\"line\">81</span><br><span class=\"line\">82</span><br><span class=\"line\">83</span><br><span class=\"line\">84</span><br><span class=\"line\">85</span><br><span class=\"line\">86</span><br><span class=\"line\">87</span><br><span class=\"line\">88</span><br><span class=\"line\">89</span><br><span class=\"line\">90</span><br><span class=\"line\">91</span><br><span class=\"line\">92</span><br><span class=\"line\">93</span><br><span class=\"line\">94</span><br><span class=\"line\">95</span><br><span class=\"line\">96</span><br><span class=\"line\">97</span><br><span class=\"line\">98</span><br><span class=\"line\">99</span><br><span class=\"line\">100</span><br><span class=\"line\">101</span><br><span class=\"line\">102</span><br><span class=\"line\">103</span><br><span class=\"line\">104</span><br><span class=\"line\">105</span><br><span class=\"line\">106</span><br><span class=\"line\">107</span><br><span class=\"line\">108</span><br><span class=\"line\">109</span><br><span class=\"line\">110</span><br><span class=\"line\">111</span><br><span class=\"line\">112</span><br><span class=\"line\">113</span><br><span class=\"line\">114</span><br><span class=\"line\">115</span><br><span class=\"line\">116</span><br><span class=\"line\">117</span><br><span class=\"line\">118</span><br><span class=\"line\">119</span><br><span class=\"line\">120</span><br><span class=\"line\">121</span><br><span class=\"line\">122</span><br><span class=\"line\">123</span><br><span class=\"line\">124</span><br><span class=\"line\">125</span><br><span class=\"line\">126</span><br><span class=\"line\">127</span><br><span class=\"line\">128</span><br><span class=\"line\">129</span><br><span class=\"line\">130</span><br><span class=\"line\">131</span><br><span class=\"line\">132</span><br><span class=\"line\">133</span><br><span class=\"line\">134</span><br><span class=\"line\">135</span><br><span class=\"line\">136</span><br><span class=\"line\">137</span><br><span class=\"line\">138</span><br><span class=\"line\">139</span><br><span class=\"line\">140</span><br><span class=\"line\">141</span><br><span class=\"line\">142</span><br><span class=\"line\">143</span><br><span class=\"line\">144</span><br><span class=\"line\">145</span><br><span class=\"line\">146</span><br><span class=\"line\">147</span><br><span class=\"line\">148</span><br><span class=\"line\">149</span><br><span class=\"line\">150</span><br><span class=\"line\">151</span><br><span class=\"line\">152</span><br><span class=\"line\">153</span><br><span class=\"line\">154</span><br><span class=\"line\">155</span><br><span class=\"line\">156</span><br><span class=\"line\">157</span><br><span class=\"line\">158</span><br><span class=\"line\">159</span><br><span class=\"line\">160</span><br><span class=\"line\">161</span><br><span class=\"line\">162</span><br><span class=\"line\">163</span><br><span class=\"line\">164</span><br><span class=\"line\">165</span><br><span class=\"line\">166</span><br><span class=\"line\">167</span><br><span class=\"line\">168</span><br><span class=\"line\">169</span><br><span class=\"line\">170</span><br><span class=\"line\">171</span><br><span class=\"line\">172</span><br><span class=\"line\">173</span><br><span class=\"line\">174</span><br><span class=\"line\">175</span><br><span class=\"line\">176</span><br><span class=\"line\">177</span><br><span class=\"line\">178</span><br><span class=\"line\">179</span><br><span class=\"line\">180</span><br><span class=\"line\">181</span><br><span class=\"line\">182</span><br><span class=\"line\">183</span><br><span class=\"line\">184</span><br><span class=\"line\">185</span><br><span class=\"line\">186</span><br><span class=\"line\">187</span><br><span class=\"line\">188</span><br><span class=\"line\">189</span><br><span class=\"line\">190</span><br><span class=\"line\">191</span><br><span class=\"line\">192</span><br><span class=\"line\">193</span><br><span class=\"line\">194</span><br><span class=\"line\">195</span><br><span class=\"line\">196</span><br><span class=\"line\">197</span><br><span class=\"line\">198</span><br><span class=\"line\">199</span><br><span class=\"line\">200</span><br><span class=\"line\">201</span><br><span class=\"line\">202</span><br><span class=\"line\">203</span><br><span class=\"line\">204</span><br><span class=\"line\">205</span><br><span class=\"line\">206</span><br><span class=\"line\">207</span><br><span class=\"line\">208</span><br><span class=\"line\">209</span><br><span class=\"line\">210</span><br><span class=\"line\">211</span><br><span class=\"line\">212</span><br><span class=\"line\">213</span><br><span class=\"line\">214</span><br><span class=\"line\">215</span><br><span class=\"line\">216</span><br><span class=\"line\">217</span><br><span class=\"line\">218</span><br><span class=\"line\">219</span><br><span class=\"line\">220</span><br><span class=\"line\">221</span><br><span class=\"line\">222</span><br><span class=\"line\">223</span><br><span class=\"line\">224</span><br><span class=\"line\">225</span><br><span class=\"line\">226</span><br><span class=\"line\">227</span><br><span class=\"line\">228</span><br><span class=\"line\">229</span><br><span class=\"line\">230</span><br><span class=\"line\">231</span><br><span class=\"line\">232</span><br><span class=\"line\">233</span><br><span class=\"line\">234</span><br><span class=\"line\">235</span><br><span class=\"line\">236</span><br><span class=\"line\">237</span><br><span class=\"line\">238</span><br><span class=\"line\">239</span><br><span class=\"line\">240</span><br><span class=\"line\">241</span><br><span class=\"line\">242</span><br><span class=\"line\">243</span><br><span class=\"line\">244</span><br><span class=\"line\">245</span><br><span class=\"line\">246</span><br><span class=\"line\">247</span><br><span class=\"line\">248</span><br><span class=\"line\">249</span><br><span class=\"line\">250</span><br><span class=\"line\">251</span><br><span class=\"line\">252</span><br><span class=\"line\">253</span><br><span class=\"line\">254</span><br><span class=\"line\">255</span><br><span class=\"line\">256</span><br><span class=\"line\">257</span><br><span class=\"line\">258</span><br><span class=\"line\">259</span><br><span class=\"line\">260</span><br><span class=\"line\">261</span><br><span class=\"line\">262</span><br><span class=\"line\">263</span><br><span class=\"line\">264</span><br><span class=\"line\">265</span><br><span class=\"line\">266</span><br><span class=\"line\">267</span><br><span class=\"line\">268</span><br><span class=\"line\">269</span><br><span class=\"line\">270</span><br><span class=\"line\">271</span><br><span class=\"line\">272</span><br><span class=\"line\">273</span><br><span class=\"line\">274</span><br><span class=\"line\">275</span><br><span class=\"line\">276</span><br><span class=\"line\">277</span><br><span class=\"line\">278</span><br><span class=\"line\">279</span><br><span class=\"line\">280</span><br><span class=\"line\">281</span><br><span class=\"line\">282</span><br><span class=\"line\">283</span><br><span class=\"line\">284</span><br><span class=\"line\">285</span><br><span class=\"line\">286</span><br><span class=\"line\">287</span><br><span class=\"line\">288</span><br><span class=\"line\">289</span><br><span class=\"line\">290</span><br><span class=\"line\">291</span><br><span class=\"line\">292</span><br><span class=\"line\">293</span><br><span class=\"line\">294</span><br><span class=\"line\">295</span><br><span class=\"line\">296</span><br><span class=\"line\">297</span><br><span class=\"line\">298</span><br><span class=\"line\">299</span><br><span class=\"line\">300</span><br><span class=\"line\">301</span><br><span class=\"line\">302</span><br><span class=\"line\">303</span><br><span class=\"line\">304</span><br><span class=\"line\">305</span><br><span class=\"line\">306</span><br><span class=\"line\">307</span><br><span class=\"line\">308</span><br><span class=\"line\">309</span><br><span class=\"line\">310</span><br><span class=\"line\">311</span><br><span class=\"line\">312</span><br><span class=\"line\">313</span><br><span class=\"line\">314</span><br><span class=\"line\">315</span><br><span class=\"line\">316</span><br><span class=\"line\">317</span><br><span class=\"line\">318</span><br><span class=\"line\">319</span><br><span class=\"line\">320</span><br><span class=\"line\">321</span><br><span class=\"line\">322</span><br><span class=\"line\">323</span><br><span class=\"line\">324</span><br><span class=\"line\">325</span><br><span class=\"line\">326</span><br><span class=\"line\">327</span><br><span class=\"line\">328</span><br><span class=\"line\">329</span><br><span class=\"line\">330</span><br><span class=\"line\">331</span><br><span class=\"line\">332</span><br><span class=\"line\">333</span><br><span class=\"line\">334</span><br><span class=\"line\">335</span><br><span class=\"line\">336</span><br><span class=\"line\">337</span><br><span class=\"line\">338</span><br><span class=\"line\">339</span><br><span class=\"line\">340</span><br><span class=\"line\">341</span><br><span class=\"line\">342</span><br><span class=\"line\">343</span><br><span class=\"line\">344</span><br><span class=\"line\">345</span><br><span class=\"line\">346</span><br><span class=\"line\">347</span><br><span class=\"line\">348</span><br><span class=\"line\">349</span><br><span class=\"line\">350</span><br><span class=\"line\">351</span><br><span class=\"line\">352</span><br><span class=\"line\">353</span><br><span class=\"line\">354</span><br><span class=\"line\">355</span><br><span class=\"line\">356</span><br><span class=\"line\">357</span><br><span class=\"line\">358</span><br><span class=\"line\">359</span><br><span class=\"line\">360</span><br><span class=\"line\">361</span><br><span class=\"line\">362</span><br><span class=\"line\">363</span><br><span class=\"line\">364</span><br><span class=\"line\">365</span><br><span class=\"line\">366</span><br><span class=\"line\">367</span><br><span class=\"line\">368</span><br><span class=\"line\">369</span><br><span class=\"line\">370</span><br><span class=\"line\">371</span><br><span class=\"line\">372</span><br><span class=\"line\">373</span><br><span class=\"line\">374</span><br><span class=\"line\">375</span><br><span class=\"line\">376</span><br><span class=\"line\">377</span><br><span class=\"line\">378</span><br><span class=\"line\">379</span><br><span class=\"line\">380</span><br><span class=\"line\">381</span><br><span class=\"line\">382</span><br><span class=\"line\">383</span><br><span class=\"line\">384</span><br><span class=\"line\">385</span><br><span class=\"line\">386</span><br><span class=\"line\">387</span><br><span class=\"line\">388</span><br><span class=\"line\">389</span><br><span class=\"line\">390</span><br><span class=\"line\">391</span><br><span class=\"line\">392</span><br><span class=\"line\">393</span><br><span class=\"line\">394</span><br><span class=\"line\">395</span><br><span class=\"line\">396</span><br><span class=\"line\">397</span><br><span class=\"line\">398</span><br><span class=\"line\">399</span><br><span class=\"line\">400</span><br><span class=\"line\">401</span><br><span class=\"line\">402</span><br><span class=\"line\">403</span><br><span class=\"line\">404</span><br><span class=\"line\">405</span><br><span class=\"line\">406</span><br><span class=\"line\">407</span><br><span class=\"line\">408</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"string\">&quot;&quot;&quot;</span></span><br><span class=\"line\"><span class=\"string\">Model definitions</span></span><br><span class=\"line\"><span class=\"string\"></span></span><br><span class=\"line\"><span class=\"string\">&quot;&quot;&quot;</span></span><br><span class=\"line\"><span class=\"keyword\">from</span> torch.autograd <span class=\"keyword\">import</span> Variable</span><br><span class=\"line\"><span class=\"keyword\">import</span> torch.nn <span class=\"keyword\">as</span> nn</span><br><span class=\"line\"><span class=\"keyword\">import</span> torch.nn.functional <span class=\"keyword\">as</span> F</span><br><span class=\"line\"><span class=\"keyword\">import</span> torch</span><br><span class=\"line\"><span class=\"keyword\">import</span> numpy <span class=\"keyword\">as</span> np</span><br><span class=\"line\"><span class=\"keyword\">import</span> math</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">from</span> model.resnet <span class=\"keyword\">import</span> resnet50</span><br><span class=\"line\"><span class=\"keyword\">from</span> model.rpn <span class=\"keyword\">import</span> RPN</span><br><span class=\"line\"><span class=\"comment\">#from model.lib.roi_align.roi_align.roi_align import RoIAlign</span></span><br><span class=\"line\"><span class=\"keyword\">from</span> model.lib.roi_align.roi_align.crop_and_resize <span class=\"keyword\">import</span> CropAndResize</span><br><span class=\"line\"><span class=\"keyword\">from</span> model.lib.bbox.generate_anchors <span class=\"keyword\">import</span> generate_pyramid_anchors</span><br><span class=\"line\"><span class=\"keyword\">from</span> model.lib.bbox.nms <span class=\"keyword\">import</span> torch_nms <span class=\"keyword\">as</span> nms</span><br><span class=\"line\"></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">def</span> <span class=\"title function_\">log2_graph</span>(<span class=\"params\">x</span>):</span><br><span class=\"line\">    <span class=\"string\">&quot;&quot;&quot;Implementatin of Log2. pytorch doesn&#x27;t have a native implemenation.&quot;&quot;&quot;</span></span><br><span class=\"line\">    <span class=\"keyword\">return</span> torch.div(torch.log(x), math.log(<span class=\"number\">2.</span>))</span><br><span class=\"line\"></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">def</span> <span class=\"title function_\">ROIAlign</span>(<span class=\"params\">feature_maps, rois, config, pool_size, mode=<span class=\"string\">&#x27;bilinear&#x27;</span></span>):</span><br><span class=\"line\">    <span class=\"string\">&quot;&quot;&quot;Implements ROI Align on the features.</span></span><br><span class=\"line\"><span class=\"string\">    Params:</span></span><br><span class=\"line\"><span class=\"string\">    - pool_shape: [height, width] of the output pooled regions. Usually [7, 7]</span></span><br><span class=\"line\"><span class=\"string\">    - image_shape: [height, width, chanells]. Shape of input image in pixels</span></span><br><span class=\"line\"><span class=\"string\">    Inputs:</span></span><br><span class=\"line\"><span class=\"string\">    - boxes: [batch, num_boxes, (x1, y1, x2, y2)] in normalized</span></span><br><span class=\"line\"><span class=\"string\">             coordinates. Possibly padded with zeros if not enough</span></span><br><span class=\"line\"><span class=\"string\">             boxes to fill the array.</span></span><br><span class=\"line\"><span class=\"string\">    - Feature maps: List of feature maps from different levels of the pyramid.</span></span><br><span class=\"line\"><span class=\"string\">                    Each is [batch, channels, height, width]</span></span><br><span class=\"line\"><span class=\"string\">    Output:</span></span><br><span class=\"line\"><span class=\"string\">    Pooled regions in the shape: [batch, num_boxes, height, width, channels].</span></span><br><span class=\"line\"><span class=\"string\">    The width and height are those specific in the pool_shape in the layer</span></span><br><span class=\"line\"><span class=\"string\">    constructor.</span></span><br><span class=\"line\"><span class=\"string\">    &quot;&quot;&quot;</span></span><br><span class=\"line\">    <span class=\"string\">&quot;&quot;&quot;</span></span><br><span class=\"line\"><span class=\"string\">    [  x2-x1             x1 + x2 - W + 1  ]</span></span><br><span class=\"line\"><span class=\"string\">    [  -----      0      ---------------  ]</span></span><br><span class=\"line\"><span class=\"string\">    [  W - 1                  W - 1       ]</span></span><br><span class=\"line\"><span class=\"string\">    [                                     ]</span></span><br><span class=\"line\"><span class=\"string\">    [           y2-y1    y1 + y2 - H + 1  ]</span></span><br><span class=\"line\"><span class=\"string\">    [    0      -----    ---------------  ]</span></span><br><span class=\"line\"><span class=\"string\">    [           H - 1         H - 1      ]</span></span><br><span class=\"line\"><span class=\"string\">    &quot;&quot;&quot;</span></span><br><span class=\"line\">    <span class=\"comment\">#feature_maps= [P2, P3, P4, P5]</span></span><br><span class=\"line\">    rois = rois.detach()</span><br><span class=\"line\">    crop_resize = CropAndResize(pool_size, pool_size, <span class=\"number\">0</span>)</span><br><span class=\"line\"></span><br><span class=\"line\">    roi_number = rois.size()[<span class=\"number\">1</span>]</span><br><span class=\"line\"></span><br><span class=\"line\">    pooled = rois.data.new(</span><br><span class=\"line\">            config.IMAGES_PER_GPU*rois.size(</span><br><span class=\"line\">            <span class=\"number\">1</span>), <span class=\"number\">256</span>, pool_size, pool_size).zero_()</span><br><span class=\"line\"></span><br><span class=\"line\">    rois = rois.view(</span><br><span class=\"line\">            config.IMAGES_PER_GPU*rois.size(<span class=\"number\">1</span>),</span><br><span class=\"line\">            <span class=\"number\">4</span>)</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\"># Loop through levels and apply ROI pooling to each. P2 to P5.</span></span><br><span class=\"line\">    x_1 = rois[:, <span class=\"number\">0</span>]</span><br><span class=\"line\">    y_1 = rois[:, <span class=\"number\">1</span>]</span><br><span class=\"line\">    x_2 = rois[:, <span class=\"number\">2</span>]</span><br><span class=\"line\">    y_2 = rois[:, <span class=\"number\">3</span>]</span><br><span class=\"line\"></span><br><span class=\"line\">    roi_level = log2_graph(</span><br><span class=\"line\">        torch.div(torch.sqrt((y_2 - y_1) * (x_2 - x_1)), <span class=\"number\">224.0</span>))</span><br><span class=\"line\"></span><br><span class=\"line\">    roi_level = torch.clamp(torch.clamp(</span><br><span class=\"line\">        torch.add(torch.<span class=\"built_in\">round</span>(roi_level), <span class=\"number\">4</span>), <span class=\"built_in\">min</span>=<span class=\"number\">2</span>), <span class=\"built_in\">max</span>=<span class=\"number\">5</span>)</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\"># P2 is 256x256, P3 is 128x128, P4 is 64x64, P5 is 32x32</span></span><br><span class=\"line\">    <span class=\"comment\"># P2 is 4, P3 is 8, P4 is 16, P5 is 32</span></span><br><span class=\"line\">    <span class=\"keyword\">for</span> i, level <span class=\"keyword\">in</span> <span class=\"built_in\">enumerate</span>(<span class=\"built_in\">range</span>(<span class=\"number\">2</span>, <span class=\"number\">6</span>)):</span><br><span class=\"line\"></span><br><span class=\"line\">        scaling_ratio = <span class=\"number\">2</span>**level</span><br><span class=\"line\"></span><br><span class=\"line\">        height = <span class=\"built_in\">float</span>(config.IMAGE_MAX_DIM)/ scaling_ratio</span><br><span class=\"line\">        width = <span class=\"built_in\">float</span>(config.IMAGE_MAX_DIM) / scaling_ratio</span><br><span class=\"line\"></span><br><span class=\"line\">        ixx = torch.eq(roi_level, level)</span><br><span class=\"line\"></span><br><span class=\"line\">        box_indices = ixx.view(-<span class=\"number\">1</span>).<span class=\"built_in\">int</span>() * <span class=\"number\">0</span></span><br><span class=\"line\">        ix = torch.unsqueeze(ixx, <span class=\"number\">1</span>)</span><br><span class=\"line\">        level_boxes = torch.masked_select(rois, ix)</span><br><span class=\"line\">        <span class=\"keyword\">if</span> level_boxes.size()[<span class=\"number\">0</span>] == <span class=\"number\">0</span>:</span><br><span class=\"line\">            <span class=\"keyword\">continue</span></span><br><span class=\"line\">        level_boxes = level_boxes.view(-<span class=\"number\">1</span>, <span class=\"number\">4</span>)</span><br><span class=\"line\"></span><br><span class=\"line\">        crops = crop_resize(feature_maps[i], torch.div(</span><br><span class=\"line\">                level_boxes, <span class=\"built_in\">float</span>(config.IMAGE_MAX_DIM)</span><br><span class=\"line\">                )[:, [<span class=\"number\">1</span>, <span class=\"number\">0</span>, <span class=\"number\">3</span>, <span class=\"number\">2</span>]], box_indices)</span><br><span class=\"line\"></span><br><span class=\"line\">        indices_pooled = ixx.nonzero()[:, <span class=\"number\">0</span>]</span><br><span class=\"line\">        pooled[indices_pooled.data, :, :, :] = crops.data</span><br><span class=\"line\"></span><br><span class=\"line\">    pooled = pooled.view(config.IMAGES_PER_GPU, roi_number,</span><br><span class=\"line\">               <span class=\"number\">256</span>, pool_size, pool_size)</span><br><span class=\"line\">    pooled = Variable(pooled).cuda()</span><br><span class=\"line\">    <span class=\"keyword\">return</span> pooled</span><br><span class=\"line\"></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\"># ---------------------------------------------------------------</span></span><br><span class=\"line\"><span class=\"comment\"># Heads</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">class</span> <span class=\"title class_\">MaskHead</span>(nn.Module):</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">def</span> <span class=\"title function_\">__init__</span>(<span class=\"params\">self, config</span>):</span><br><span class=\"line\">        <span class=\"built_in\">super</span>(MaskHead, <span class=\"variable language_\">self</span>).__init__()</span><br><span class=\"line\">        <span class=\"variable language_\">self</span>.config = config</span><br><span class=\"line\">        <span class=\"variable language_\">self</span>.num_classes = config.NUM_CLASSES</span><br><span class=\"line\">        <span class=\"comment\">#self.crop_size = config.mask_crop_size</span></span><br><span class=\"line\"></span><br><span class=\"line\">        <span class=\"comment\">#self.roi_align = RoIAlign(self.crop_size, self.crop_size)</span></span><br><span class=\"line\">        <span class=\"variable language_\">self</span>.conv1 = nn.Conv2d(<span class=\"number\">256</span>, <span class=\"number\">256</span>, kernel_size=<span class=\"number\">3</span>, padding=<span class=\"number\">1</span>, stride=<span class=\"number\">1</span>)</span><br><span class=\"line\">        <span class=\"variable language_\">self</span>.bn1 = nn.BatchNorm2d(<span class=\"number\">256</span>)</span><br><span class=\"line\">        <span class=\"variable language_\">self</span>.conv2 = nn.Conv2d(<span class=\"number\">256</span>, <span class=\"number\">256</span>, kernel_size=<span class=\"number\">3</span>, padding=<span class=\"number\">1</span>, stride=<span class=\"number\">1</span>)</span><br><span class=\"line\">        <span class=\"variable language_\">self</span>.bn2 = nn.BatchNorm2d(<span class=\"number\">256</span>)</span><br><span class=\"line\">        <span class=\"variable language_\">self</span>.conv3 = nn.Conv2d(<span class=\"number\">256</span>, <span class=\"number\">256</span>, kernel_size=<span class=\"number\">3</span>, padding=<span class=\"number\">1</span>, stride=<span class=\"number\">1</span>)</span><br><span class=\"line\">        <span class=\"variable language_\">self</span>.bn3 = nn.BatchNorm2d(<span class=\"number\">256</span>)</span><br><span class=\"line\">        <span class=\"variable language_\">self</span>.conv4 = nn.Conv2d(<span class=\"number\">256</span>, <span class=\"number\">256</span>, kernel_size=<span class=\"number\">3</span>, padding=<span class=\"number\">1</span>, stride=<span class=\"number\">1</span>)</span><br><span class=\"line\">        <span class=\"variable language_\">self</span>.bn4 = nn.BatchNorm2d(<span class=\"number\">256</span>)</span><br><span class=\"line\"></span><br><span class=\"line\">        <span class=\"variable language_\">self</span>.deconv = nn.ConvTranspose2d(<span class=\"number\">256</span>, <span class=\"number\">256</span>, kernel_size=<span class=\"number\">4</span>, padding=<span class=\"number\">1</span>, stride=<span class=\"number\">2</span>, bias=<span class=\"literal\">False</span>)</span><br><span class=\"line\">        <span class=\"variable language_\">self</span>.mask = nn.Conv2d(<span class=\"number\">256</span>, <span class=\"variable language_\">self</span>.num_classes, kernel_size=<span class=\"number\">1</span>, padding=<span class=\"number\">0</span>, stride=<span class=\"number\">1</span>)</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">def</span> <span class=\"title function_\">forward</span>(<span class=\"params\">self, x, rpn_rois</span>):</span><br><span class=\"line\">        <span class=\"comment\">#x = self.roi_align(x, rpn_rois)</span></span><br><span class=\"line\">        x = ROIAlign(x, rpn_rois, <span class=\"variable language_\">self</span>.config, <span class=\"variable language_\">self</span>.config.MASK_POOL_SIZE)</span><br><span class=\"line\"></span><br><span class=\"line\">        roi_number = x.size()[<span class=\"number\">1</span>]</span><br><span class=\"line\"></span><br><span class=\"line\">        <span class=\"comment\"># merge batch and roi number together</span></span><br><span class=\"line\">        x = x.view(<span class=\"variable language_\">self</span>.config.IMAGES_PER_GPU * roi_number,</span><br><span class=\"line\">                   <span class=\"number\">256</span>, <span class=\"variable language_\">self</span>.config.MASK_POOL_SIZE,</span><br><span class=\"line\">                   <span class=\"variable language_\">self</span>.config.MASK_POOL_SIZE)</span><br><span class=\"line\"></span><br><span class=\"line\">        x = F.relu(<span class=\"variable language_\">self</span>.bn1(<span class=\"variable language_\">self</span>.conv1(x)), inplace=<span class=\"literal\">True</span>)</span><br><span class=\"line\">        x = F.relu(<span class=\"variable language_\">self</span>.bn2(<span class=\"variable language_\">self</span>.conv2(x)), inplace=<span class=\"literal\">True</span>)</span><br><span class=\"line\">        x = F.relu(<span class=\"variable language_\">self</span>.bn3(<span class=\"variable language_\">self</span>.conv3(x)), inplace=<span class=\"literal\">True</span>)</span><br><span class=\"line\">        x = F.relu(<span class=\"variable language_\">self</span>.bn4(<span class=\"variable language_\">self</span>.conv4(x)), inplace=<span class=\"literal\">True</span>)</span><br><span class=\"line\">        x = <span class=\"variable language_\">self</span>.deconv(x)</span><br><span class=\"line\">        rcnn_mask_logits = <span class=\"variable language_\">self</span>.mask(x)</span><br><span class=\"line\"></span><br><span class=\"line\">        rcnn_mask_logits = rcnn_mask_logits.view(<span class=\"variable language_\">self</span>.config.IMAGES_PER_GPU,</span><br><span class=\"line\">                                                 roi_number,</span><br><span class=\"line\">                                                 <span class=\"variable language_\">self</span>.config.NUM_CLASSES,</span><br><span class=\"line\">                                                 <span class=\"variable language_\">self</span>.config.MASK_POOL_SIZE * <span class=\"number\">2</span>,</span><br><span class=\"line\">                                                 <span class=\"variable language_\">self</span>.config.MASK_POOL_SIZE * <span class=\"number\">2</span>)</span><br><span class=\"line\"></span><br><span class=\"line\">        <span class=\"keyword\">return</span> rcnn_mask_logits</span><br><span class=\"line\"></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">class</span> <span class=\"title class_\">RCNNHead</span>(nn.Module):</span><br><span class=\"line\">    <span class=\"keyword\">def</span> <span class=\"title function_\">__init__</span>(<span class=\"params\">self, config</span>):</span><br><span class=\"line\">        <span class=\"built_in\">super</span>(RCNNHead, <span class=\"variable language_\">self</span>).__init__()</span><br><span class=\"line\">        <span class=\"variable language_\">self</span>.config = config</span><br><span class=\"line\">        <span class=\"variable language_\">self</span>.num_classes = config.NUM_CLASSES</span><br><span class=\"line\">        <span class=\"comment\">#self.crop_size = config.rcnn_crop_size</span></span><br><span class=\"line\"></span><br><span class=\"line\">        <span class=\"comment\">#self.roi_align = RoIAlign(self.crop_size, self.crop_size)</span></span><br><span class=\"line\">        <span class=\"variable language_\">self</span>.fc1 = nn.Linear(<span class=\"number\">1024</span>, <span class=\"number\">1024</span>)</span><br><span class=\"line\">        <span class=\"variable language_\">self</span>.fc2 = nn.Linear(<span class=\"number\">1024</span>, <span class=\"number\">1024</span>)</span><br><span class=\"line\">        <span class=\"variable language_\">self</span>.class_logits = nn.Linear(<span class=\"number\">1024</span>, <span class=\"variable language_\">self</span>.num_classes)</span><br><span class=\"line\">        <span class=\"variable language_\">self</span>.bbox = nn.Linear(<span class=\"number\">1024</span>, <span class=\"variable language_\">self</span>.num_classes * <span class=\"number\">4</span>)</span><br><span class=\"line\"></span><br><span class=\"line\">        <span class=\"variable language_\">self</span>.conv1 = nn.Conv2d(<span class=\"number\">256</span>, <span class=\"number\">1024</span>, kernel_size=<span class=\"variable language_\">self</span>.config.POOL_SIZE, stride=<span class=\"number\">1</span>, padding=<span class=\"number\">0</span>)</span><br><span class=\"line\">        <span class=\"variable language_\">self</span>.bn1 = nn.BatchNorm2d(<span class=\"number\">1024</span>, eps=<span class=\"number\">0.001</span>)</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">def</span> <span class=\"title function_\">forward</span>(<span class=\"params\">self, x, rpn_rois</span>):</span><br><span class=\"line\">        x = ROIAlign(x, rpn_rois, <span class=\"variable language_\">self</span>.config, <span class=\"variable language_\">self</span>.config.POOL_SIZE)</span><br><span class=\"line\">        roi_number = x.size()[<span class=\"number\">1</span>]</span><br><span class=\"line\"></span><br><span class=\"line\">        x = x.view(<span class=\"variable language_\">self</span>.config.IMAGES_PER_GPU * roi_number,</span><br><span class=\"line\">                   <span class=\"number\">256</span>, <span class=\"variable language_\">self</span>.config.POOL_SIZE,</span><br><span class=\"line\">                   <span class=\"variable language_\">self</span>.config.POOL_SIZE)</span><br><span class=\"line\">        <span class=\"comment\">#print(x.shape)</span></span><br><span class=\"line\">        <span class=\"comment\">#x = self.roi_align(x, rpn_rois, self.config, self.config.POOL_SIZE)</span></span><br><span class=\"line\">        <span class=\"comment\">#x = crops.view(crops.size(0), -1)</span></span><br><span class=\"line\">        x = <span class=\"variable language_\">self</span>.bn1(<span class=\"variable language_\">self</span>.conv1(x))</span><br><span class=\"line\">        x = x.permute(<span class=\"number\">0</span>, <span class=\"number\">2</span>, <span class=\"number\">3</span>, <span class=\"number\">1</span>).contiguous().view(x.size(<span class=\"number\">0</span>), -<span class=\"number\">1</span>)</span><br><span class=\"line\">        x = F.relu(<span class=\"variable language_\">self</span>.fc1(x), inplace=<span class=\"literal\">True</span>)</span><br><span class=\"line\">        x = F.relu(<span class=\"variable language_\">self</span>.fc2(x), inplace=<span class=\"literal\">True</span>)</span><br><span class=\"line\">        <span class=\"comment\">#x = F.dropout(x, 0.5, training=self.training)</span></span><br><span class=\"line\">        rcnn_class_logits = <span class=\"variable language_\">self</span>.class_logits(x)</span><br><span class=\"line\">        rcnn_probs = F.softmax(rcnn_class_logits, dim=-<span class=\"number\">1</span>)</span><br><span class=\"line\"></span><br><span class=\"line\">        rcnn_bbox = <span class=\"variable language_\">self</span>.bbox(x)</span><br><span class=\"line\"></span><br><span class=\"line\">        rcnn_class_logits = rcnn_class_logits.view(<span class=\"variable language_\">self</span>.config.IMAGES_PER_GPU,</span><br><span class=\"line\">                                                   roi_number,</span><br><span class=\"line\">                                                   rcnn_class_logits.size()[-<span class=\"number\">1</span>])</span><br><span class=\"line\"></span><br><span class=\"line\">        rcnn_probs = rcnn_probs.view(<span class=\"variable language_\">self</span>.config.IMAGES_PER_GPU,</span><br><span class=\"line\">                                     roi_number,</span><br><span class=\"line\">                                     rcnn_probs.size()[-<span class=\"number\">1</span>])</span><br><span class=\"line\"></span><br><span class=\"line\">        rcnn_bbox = rcnn_bbox.view(<span class=\"variable language_\">self</span>.config.IMAGES_PER_GPU,</span><br><span class=\"line\">                                   roi_number,</span><br><span class=\"line\">                                   <span class=\"variable language_\">self</span>.config.NUM_CLASSES,</span><br><span class=\"line\">                                   <span class=\"number\">4</span>)</span><br><span class=\"line\"></span><br><span class=\"line\">        <span class=\"keyword\">return</span> rcnn_class_logits, rcnn_probs, rcnn_bbox</span><br><span class=\"line\"></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">#</span></span><br><span class=\"line\"><span class=\"comment\"># ---------------------------------------------------------------</span></span><br><span class=\"line\"><span class=\"comment\"># Mask R-CNN</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">class</span> <span class=\"title class_\">MaskRCNN</span>(nn.Module):</span><br><span class=\"line\">    <span class=\"string\">&quot;&quot;&quot;</span></span><br><span class=\"line\"><span class=\"string\">    Mask R-CNN model</span></span><br><span class=\"line\"><span class=\"string\">    &quot;&quot;&quot;</span></span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">def</span> <span class=\"title function_\">__init__</span>(<span class=\"params\">self, config</span>):</span><br><span class=\"line\">        <span class=\"built_in\">super</span>(MaskRCNN, <span class=\"variable language_\">self</span>).__init__()</span><br><span class=\"line\">        <span class=\"variable language_\">self</span>.config = config</span><br><span class=\"line\">        <span class=\"variable language_\">self</span>.__mode = <span class=\"string\">&#x27;train&#x27;</span></span><br><span class=\"line\">        feature_channels = <span class=\"number\">128</span></span><br><span class=\"line\">        <span class=\"comment\"># define modules (set of layers)</span></span><br><span class=\"line\"><span class=\"comment\">#        self.feature_net = FeatureNet(cfg, 3, feature_channels)</span></span><br><span class=\"line\">        <span class=\"variable language_\">self</span>.feature_net = resnet50().cuda()</span><br><span class=\"line\">        <span class=\"comment\">#self.rpn_head = RpnMultiHead(cfg,feature_channels)</span></span><br><span class=\"line\">        <span class=\"variable language_\">self</span>.rpn = RPN(<span class=\"number\">256</span>, <span class=\"built_in\">len</span>(<span class=\"variable language_\">self</span>.config.RPN_ANCHOR_RATIOS),</span><br><span class=\"line\">                             <span class=\"variable language_\">self</span>.config.RPN_ANCHOR_STRIDE)</span><br><span class=\"line\">        <span class=\"comment\">#self.rcnn_crop = CropRoi(cfg, cfg.rcnn_crop_size)</span></span><br><span class=\"line\">        <span class=\"variable language_\">self</span>.rcnn_head = RCNNHead(config)</span><br><span class=\"line\">        <span class=\"comment\">#self.mask_crop = CropRoi(cfg, cfg.mask_crop_size)</span></span><br><span class=\"line\">        <span class=\"variable language_\">self</span>.mask_head = MaskHead(config)</span><br><span class=\"line\"></span><br><span class=\"line\">        <span class=\"variable language_\">self</span>.anchors = generate_pyramid_anchors(<span class=\"variable language_\">self</span>.config.RPN_ANCHOR_SCALES,</span><br><span class=\"line\">                                                <span class=\"variable language_\">self</span>.config.RPN_ANCHOR_RATIOS,</span><br><span class=\"line\">                                                <span class=\"variable language_\">self</span>.config.BACKBONE_SHAPES,</span><br><span class=\"line\">                                                <span class=\"variable language_\">self</span>.config.BACKBONE_STRIDES,</span><br><span class=\"line\">                                                <span class=\"variable language_\">self</span>.config.RPN_ANCHOR_STRIDE)</span><br><span class=\"line\">        <span class=\"variable language_\">self</span>.anchors = <span class=\"variable language_\">self</span>.anchors.astype(np.float32)</span><br><span class=\"line\">        <span class=\"variable language_\">self</span>.proposal_count = <span class=\"variable language_\">self</span>.config.POST_NMS_ROIS_TRAINING</span><br><span class=\"line\">        <span class=\"comment\"># FPN</span></span><br><span class=\"line\">        <span class=\"variable language_\">self</span>.fpn_c5p5 = nn.Conv2d(</span><br><span class=\"line\">            <span class=\"number\">512</span> * <span class=\"number\">4</span>, <span class=\"number\">256</span>, kernel_size=<span class=\"number\">1</span>, stride=<span class=\"number\">1</span>, padding=<span class=\"number\">0</span>)</span><br><span class=\"line\">        <span class=\"variable language_\">self</span>.fpn_c4p4 = nn.Conv2d(</span><br><span class=\"line\">            <span class=\"number\">256</span> * <span class=\"number\">4</span>, <span class=\"number\">256</span>, kernel_size=<span class=\"number\">1</span>, stride=<span class=\"number\">1</span>, padding=<span class=\"number\">0</span>)</span><br><span class=\"line\">        <span class=\"variable language_\">self</span>.fpn_c3p3 = nn.Conv2d(</span><br><span class=\"line\">            <span class=\"number\">128</span> * <span class=\"number\">4</span>, <span class=\"number\">256</span>, kernel_size=<span class=\"number\">1</span>, stride=<span class=\"number\">1</span>, padding=<span class=\"number\">0</span>)</span><br><span class=\"line\">        <span class=\"variable language_\">self</span>.fpn_c2p2 = nn.Conv2d(</span><br><span class=\"line\">            <span class=\"number\">64</span> * <span class=\"number\">4</span>, <span class=\"number\">256</span>, kernel_size=<span class=\"number\">1</span>, stride=<span class=\"number\">1</span>,  padding=<span class=\"number\">0</span>)</span><br><span class=\"line\"></span><br><span class=\"line\">        <span class=\"variable language_\">self</span>.fpn_p2 = nn.Conv2d(<span class=\"number\">256</span>, <span class=\"number\">256</span>, kernel_size=<span class=\"number\">3</span>, stride=<span class=\"number\">1</span>, padding=<span class=\"number\">1</span>)</span><br><span class=\"line\">        <span class=\"variable language_\">self</span>.fpn_p3 = nn.Conv2d(<span class=\"number\">256</span>, <span class=\"number\">256</span>, kernel_size=<span class=\"number\">3</span>, stride=<span class=\"number\">1</span>, padding=<span class=\"number\">1</span>)</span><br><span class=\"line\">        <span class=\"variable language_\">self</span>.fpn_p4 = nn.Conv2d(<span class=\"number\">256</span>, <span class=\"number\">256</span>, kernel_size=<span class=\"number\">3</span>, stride=<span class=\"number\">1</span>, padding=<span class=\"number\">1</span>)</span><br><span class=\"line\">        <span class=\"variable language_\">self</span>.fpn_p5 = nn.Conv2d(<span class=\"number\">256</span>, <span class=\"number\">256</span>, kernel_size=<span class=\"number\">3</span>, stride=<span class=\"number\">1</span>, padding=<span class=\"number\">1</span>)</span><br><span class=\"line\"></span><br><span class=\"line\">        <span class=\"variable language_\">self</span>.scale_ratios = [<span class=\"number\">4</span>, <span class=\"number\">8</span>, <span class=\"number\">16</span>, <span class=\"number\">32</span>]</span><br><span class=\"line\">        <span class=\"variable language_\">self</span>.fpn_p6 = nn.MaxPool2d(</span><br><span class=\"line\">            kernel_size=<span class=\"number\">1</span>, stride=<span class=\"number\">2</span>, padding=<span class=\"number\">0</span>, ceil_mode=<span class=\"literal\">False</span>)</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">def</span> <span class=\"title function_\">forward</span>(<span class=\"params\">self, x</span>):</span><br><span class=\"line\">        <span class=\"comment\"># Extract features</span></span><br><span class=\"line\">        C1, C2, C3, C4, C5 = <span class=\"variable language_\">self</span>.feature_net(x)</span><br><span class=\"line\">        P5 = <span class=\"variable language_\">self</span>.fpn_c5p5(C5)</span><br><span class=\"line\">        P4 = <span class=\"variable language_\">self</span>.fpn_c4p4(C4) + F.upsample(P5,</span><br><span class=\"line\">                                            scale_factor=<span class=\"number\">2</span>, mode=<span class=\"string\">&#x27;bilinear&#x27;</span>)</span><br><span class=\"line\">        P3 = <span class=\"variable language_\">self</span>.fpn_c3p3(C3) + F.upsample(P4,</span><br><span class=\"line\">                                            scale_factor=<span class=\"number\">2</span>, mode=<span class=\"string\">&#x27;bilinear&#x27;</span>)</span><br><span class=\"line\">        P2 = <span class=\"variable language_\">self</span>.fpn_c2p2(C2) + F.upsample(P3,</span><br><span class=\"line\">                                            scale_factor=<span class=\"number\">2</span>, mode=<span class=\"string\">&#x27;bilinear&#x27;</span>)</span><br><span class=\"line\"></span><br><span class=\"line\">        <span class=\"comment\"># Attach 3x3 conv to all P layers to get the final feature maps.</span></span><br><span class=\"line\">        <span class=\"comment\"># P2 is 256, P3 is 128, P4 is 64, P5 is 32</span></span><br><span class=\"line\">        P2 = <span class=\"variable language_\">self</span>.fpn_p2(P2)</span><br><span class=\"line\">        P3 = <span class=\"variable language_\">self</span>.fpn_p3(P3)</span><br><span class=\"line\">        P4 = <span class=\"variable language_\">self</span>.fpn_p4(P4)</span><br><span class=\"line\">        P5 = <span class=\"variable language_\">self</span>.fpn_p5(P5)</span><br><span class=\"line\">        <span class=\"comment\"># P6 is used for the 5th anchor scale in RPN. Generated by</span></span><br><span class=\"line\">        <span class=\"comment\"># subsampling from P5 with stride of 2.</span></span><br><span class=\"line\">        P6 = <span class=\"variable language_\">self</span>.fpn_p6(P5)</span><br><span class=\"line\"></span><br><span class=\"line\">        <span class=\"comment\"># Note that P6 is used in RPN, but not in the classifier heads.</span></span><br><span class=\"line\">        rpn_feature_maps = [P2, P3, P4, P5, P6]</span><br><span class=\"line\"></span><br><span class=\"line\">        <span class=\"variable language_\">self</span>.mrcnn_feature_maps = [P2, P3, P4, P5]</span><br><span class=\"line\"></span><br><span class=\"line\">        rpn_class_logits_outputs = []</span><br><span class=\"line\">        rpn_class_outputs = []</span><br><span class=\"line\">        rpn_bbox_outputs = []</span><br><span class=\"line\">        <span class=\"comment\"># RPN proposals</span></span><br><span class=\"line\">        <span class=\"keyword\">for</span> feature <span class=\"keyword\">in</span> rpn_feature_maps:</span><br><span class=\"line\">            rpn_class_logits, rpn_probs, rpn_bbox = <span class=\"variable language_\">self</span>.rpn(feature)</span><br><span class=\"line\">            rpn_class_logits_outputs.append(rpn_class_logits)</span><br><span class=\"line\">            rpn_class_outputs.append(rpn_probs)</span><br><span class=\"line\">            rpn_bbox_outputs.append(rpn_bbox)</span><br><span class=\"line\"></span><br><span class=\"line\">        rpn_class_logits = torch.cat(rpn_class_logits_outputs, dim=<span class=\"number\">1</span>)</span><br><span class=\"line\">        rpn_class = torch.cat(rpn_class_outputs, dim=<span class=\"number\">1</span>)</span><br><span class=\"line\">        rpn_bbox = torch.cat(rpn_bbox_outputs, dim=<span class=\"number\">1</span>)</span><br><span class=\"line\"></span><br><span class=\"line\">        rpn_proposals = <span class=\"variable language_\">self</span>.proposal_layer(rpn_class, rpn_bbox)</span><br><span class=\"line\"></span><br><span class=\"line\">        <span class=\"comment\"># RCNN proposals</span></span><br><span class=\"line\">        rcnn_class_logits, rcnn_class, rcnn_bbox = <span class=\"variable language_\">self</span>.rcnn_head(<span class=\"variable language_\">self</span>.mrcnn_feature_maps, rpn_proposals)</span><br><span class=\"line\">        rcnn_mask_logits = <span class=\"variable language_\">self</span>.mask_head(<span class=\"variable language_\">self</span>.mrcnn_feature_maps, rpn_proposals)</span><br><span class=\"line\">        <span class=\"comment\"># &lt;todo&gt; mask nms</span></span><br><span class=\"line\"></span><br><span class=\"line\">        <span class=\"keyword\">return</span> [rpn_class_logits, rpn_class, rpn_bbox, rpn_proposals,</span><br><span class=\"line\">                rcnn_class_logits, rcnn_class, rcnn_bbox,</span><br><span class=\"line\">                rcnn_mask_logits]</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">def</span> <span class=\"title function_\">proposal_layer</span>(<span class=\"params\">self, rpn_class, rpn_bbox</span>):</span><br><span class=\"line\">        <span class=\"comment\"># handling proposals</span></span><br><span class=\"line\">        scores = rpn_class[:, :, <span class=\"number\">1</span>]</span><br><span class=\"line\">        <span class=\"comment\">#print(scores.shape)</span></span><br><span class=\"line\">        <span class=\"comment\"># Box deltas [batch, num_rois, 4]</span></span><br><span class=\"line\">        deltas_mul = Variable(torch.from_numpy(np.reshape(</span><br><span class=\"line\">            <span class=\"variable language_\">self</span>.config.RPN_BBOX_STD_DEV, [<span class=\"number\">1</span>, <span class=\"number\">1</span>, <span class=\"number\">4</span>]).astype(np.float32))).cuda()</span><br><span class=\"line\">        deltas = rpn_bbox * deltas_mul</span><br><span class=\"line\"></span><br><span class=\"line\">        pre_nms_limit = <span class=\"built_in\">min</span>(<span class=\"number\">6000</span>, <span class=\"variable language_\">self</span>.anchors.shape[<span class=\"number\">0</span>])</span><br><span class=\"line\"></span><br><span class=\"line\">        scores, ix = torch.topk(scores, pre_nms_limit, dim=-<span class=\"number\">1</span>,</span><br><span class=\"line\">                                largest=<span class=\"literal\">True</span>, <span class=\"built_in\">sorted</span>=<span class=\"literal\">True</span>)</span><br><span class=\"line\"></span><br><span class=\"line\">        ix = torch.unsqueeze(ix, <span class=\"number\">2</span>)</span><br><span class=\"line\">        ix = torch.cat([ix, ix, ix, ix], dim=<span class=\"number\">2</span>)</span><br><span class=\"line\">        deltas = torch.gather(deltas, <span class=\"number\">1</span>, ix)</span><br><span class=\"line\"></span><br><span class=\"line\">        _anchors = []</span><br><span class=\"line\">        <span class=\"keyword\">for</span> i <span class=\"keyword\">in</span> <span class=\"built_in\">range</span>(<span class=\"variable language_\">self</span>.config.IMAGES_PER_GPU):</span><br><span class=\"line\">            anchors = Variable(torch.from_numpy(</span><br><span class=\"line\">                <span class=\"variable language_\">self</span>.anchors.astype(np.float32))).cuda()</span><br><span class=\"line\">            _anchors.append(anchors)</span><br><span class=\"line\">        anchors = torch.stack(_anchors, <span class=\"number\">0</span>)</span><br><span class=\"line\"></span><br><span class=\"line\">        pre_nms_anchors = torch.gather(anchors, <span class=\"number\">1</span>, ix)</span><br><span class=\"line\">        refined_anchors = apply_box_deltas_graph(pre_nms_anchors, deltas)</span><br><span class=\"line\"></span><br><span class=\"line\">        <span class=\"comment\"># Clip to image boundaries. [batch, N, (y1, x1, y2, x2)]</span></span><br><span class=\"line\">        height, width = <span class=\"variable language_\">self</span>.config.IMAGE_SHAPE[:<span class=\"number\">2</span>]</span><br><span class=\"line\">        window = np.array([<span class=\"number\">0</span>, <span class=\"number\">0</span>, height, width]).astype(np.float32)</span><br><span class=\"line\">        window = Variable(torch.from_numpy(window)).cuda()</span><br><span class=\"line\"></span><br><span class=\"line\">        refined_anchors_clipped = clip_boxes_graph(refined_anchors, window)</span><br><span class=\"line\"></span><br><span class=\"line\">        refined_proposals = []</span><br><span class=\"line\">        scores = scores[:,:,<span class=\"literal\">None</span>]</span><br><span class=\"line\">        <span class=\"comment\">#print(scores.data.shape)</span></span><br><span class=\"line\">        <span class=\"comment\">#print(refined_anchors_clipped.data.shape)</span></span><br><span class=\"line\">        <span class=\"keyword\">for</span> i <span class=\"keyword\">in</span> <span class=\"built_in\">range</span>(<span class=\"variable language_\">self</span>.config.IMAGES_PER_GPU):</span><br><span class=\"line\">            indices = nms(</span><br><span class=\"line\">                torch.cat([refined_anchors_clipped.data[i], scores.data[i]], <span class=\"number\">1</span>), <span class=\"number\">0.7</span>)</span><br><span class=\"line\">            indices = indices[:<span class=\"variable language_\">self</span>.proposal_count]</span><br><span class=\"line\">            indices = torch.stack([indices, indices, indices, indices], dim=<span class=\"number\">1</span>)</span><br><span class=\"line\">            indices = Variable(indices).cuda()</span><br><span class=\"line\">            proposals = torch.gather(refined_anchors_clipped[i], <span class=\"number\">0</span>, indices)</span><br><span class=\"line\">            padding = <span class=\"variable language_\">self</span>.proposal_count - proposals.size()[<span class=\"number\">0</span>]</span><br><span class=\"line\">            proposals = torch.cat(</span><br><span class=\"line\">                [proposals, Variable(torch.zeros([padding, <span class=\"number\">4</span>])).cuda()], <span class=\"number\">0</span>)</span><br><span class=\"line\">            refined_proposals.append(proposals)</span><br><span class=\"line\"></span><br><span class=\"line\">        rpn_rois = torch.stack(refined_proposals, <span class=\"number\">0</span>)</span><br><span class=\"line\"></span><br><span class=\"line\">        <span class=\"keyword\">return</span> rpn_rois</span><br><span class=\"line\"></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">def</span> <span class=\"title function_\">apply_box_deltas_graph</span>(<span class=\"params\">boxes, deltas</span>):</span><br><span class=\"line\">    <span class=\"string\">&quot;&quot;&quot;Applies the given deltas to the given boxes.</span></span><br><span class=\"line\"><span class=\"string\">    boxes: [N, 4] where each row is y1, x1, y2, x2</span></span><br><span class=\"line\"><span class=\"string\">    deltas: [N, 4] where each row is [dy, dx, log(dh), log(dw)]</span></span><br><span class=\"line\"><span class=\"string\">    &quot;&quot;&quot;</span></span><br><span class=\"line\">    <span class=\"comment\"># Convert to y, x, h, w</span></span><br><span class=\"line\">    height = boxes[:, :, <span class=\"number\">2</span>] - boxes[:, :, <span class=\"number\">0</span>]</span><br><span class=\"line\">    width = boxes[:, :, <span class=\"number\">3</span>] - boxes[:, :, <span class=\"number\">1</span>]</span><br><span class=\"line\">    center_y = boxes[:, :, <span class=\"number\">0</span>] + <span class=\"number\">0.5</span> * height</span><br><span class=\"line\">    center_x = boxes[:, :, <span class=\"number\">1</span>] + <span class=\"number\">0.5</span> * width</span><br><span class=\"line\">    <span class=\"comment\"># Apply deltas</span></span><br><span class=\"line\">    center_y += deltas[:, :, <span class=\"number\">0</span>] * height</span><br><span class=\"line\">    center_x += deltas[:, :, <span class=\"number\">1</span>] * width</span><br><span class=\"line\">    height *= torch.exp(deltas[:, :, <span class=\"number\">2</span>])</span><br><span class=\"line\">    width *= torch.exp(deltas[:, :, <span class=\"number\">3</span>])</span><br><span class=\"line\">    <span class=\"comment\"># Convert back to y1, x1, y2, x2</span></span><br><span class=\"line\">    y1 = center_y - <span class=\"number\">0.5</span> * height</span><br><span class=\"line\">    x1 = center_x - <span class=\"number\">0.5</span> * width</span><br><span class=\"line\">    y2 = y1 + height</span><br><span class=\"line\">    x2 = x1 + width</span><br><span class=\"line\">    result = [y1, x1, y2, x2]</span><br><span class=\"line\">    <span class=\"keyword\">return</span> result</span><br><span class=\"line\"></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">def</span> <span class=\"title function_\">clip_boxes_graph</span>(<span class=\"params\">boxes, window</span>):</span><br><span class=\"line\">    <span class=\"string\">&quot;&quot;&quot;</span></span><br><span class=\"line\"><span class=\"string\">    boxes: [N, 4] each row is y1, x1, y2, x2</span></span><br><span class=\"line\"><span class=\"string\">    window: [4] in the form y1, x1, y2, x2</span></span><br><span class=\"line\"><span class=\"string\">    &quot;&quot;&quot;</span></span><br><span class=\"line\">    <span class=\"comment\"># Split corners</span></span><br><span class=\"line\">    wy1, wx1, wy2, wx2 = window</span><br><span class=\"line\">    y1, x1, y2, x2 = boxes</span><br><span class=\"line\">    <span class=\"comment\"># Clip</span></span><br><span class=\"line\"></span><br><span class=\"line\">    y1 = torch.<span class=\"built_in\">max</span>(torch.<span class=\"built_in\">min</span>(y1, wy2), wy1)</span><br><span class=\"line\">    x1 = torch.<span class=\"built_in\">max</span>(torch.<span class=\"built_in\">min</span>(x1, wx2), wx1)</span><br><span class=\"line\">    y2 = torch.<span class=\"built_in\">max</span>(torch.<span class=\"built_in\">min</span>(y2, wy2), wy1)</span><br><span class=\"line\">    x2 = torch.<span class=\"built_in\">max</span>(torch.<span class=\"built_in\">min</span>(x2, wx2), wx1)</span><br><span class=\"line\"></span><br><span class=\"line\">    clipped = torch.stack([x1, y1, x2, y2], dim=<span class=\"number\">2</span>)</span><br><span class=\"line\">    <span class=\"keyword\">return</span> clipped</span><br></pre></td></tr></table></figure>\n\n<h4 id=\"相关资源\"><a href=\"#相关资源\" class=\"headerlink\" title=\"相关资源\"></a>相关资源</h4><h5 id=\"项目\"><a href=\"#项目\" class=\"headerlink\" title=\"项目\"></a><strong>项目</strong></h5><ol>\n<li><a href=\"https://github.com/JenifferWuUCLA/pulmonary-nodules-MaskRCNN/tree/master\">JenifferWuUCLA&#x2F;pulmonary-nodules-MaskRCNN: Mask R-CNN for Pulmonary Nodules Diagnosis, using TensorFlow 天池医疗 AI 大赛：Mask R-CNN 肺部结节智能检测（Segmentation + Classification）</a></li>\n<li><a href=\"https://github.com/facebookresearch/maskrcnn-benchmark\">facebookresearch&#x2F;maskrcnn-benchmark: Fast, modular reference implementation of Instance Segmentation and Object Detection algorithms in PyTorch.</a></li>\n<li><a href=\"https://github.com/leon-liangwu/MaskYolo_Caffe?tab=readme-ov-file\">leon-liangwu&#x2F;MaskYolo_Caffe: YOLO V2 &amp; V3 , YOLO Combined with RCNN and MaskRCNN</a></li>\n<li><a href=\"https://github.com/TannerGilbert/MaskRCNN-Object-Detection-and-Segmentation\">TannerGilbert&#x2F;MaskRCNN-Object-Detection-and-Segmentation: Train your own custom MaskRCNN Object Detection and Instance Segmentation model.</a></li>\n<li><a href=\"https://github.com/CharlesShang/FastMaskRCNN\">CharlesShang&#x2F;FastMaskRCNN: Mask RCNN in TensorFlow</a></li>\n<li><a href=\"https://github.com/buseyaren/installation-guide-of-maskrcnn?tab=readme-ov-file\">buseyaren&#x2F;installation-guide-of-maskrcnn: Mask R-CNN creates a high-quality segmentation mask in addition to the Faster R-CNN network. In addition to class labels and scores, a segmentation mask is created for the objects detected by this neural network. In this repository, using Anaconda prompt step by step Mask R-CNN setup is shown.</a></li>\n</ol>\n<h5 id=\"博客\"><a href=\"#博客\" class=\"headerlink\" title=\"博客\"></a>博客</h5><ol>\n<li><a href=\"https://blog.csdn.net/qq_37541097/article/details/123754766\">Mask R-CNN 网络详解_maskrcnn-CSDN 博客</a></li>\n<li><a href=\"https://blog.csdn.net/zimiao552147572/article/details/105300202?utm_medium=distribute.pc_relevant.none-task-blog-2~default~baidujs_baidulandingword~default-0-105300202-blog-123754766.235%5Ev43%5Epc_blog_bottom_relevance_base8&spm=1001.2101.3001.4242.1&utm_relevant_index=2\">目标分割：Mask RCNN_mask r-cnn-CSDN 博客</a></li>\n</ol>\n<h5 id=\"论文\"><a href=\"#论文\" class=\"headerlink\" title=\"论文\"></a>论文</h5><ol>\n<li><a href=\"https://arxiv.org/pdf/1703.06870\">arxiv.org&#x2F;pdf&#x2F;1703.06870</a></li>\n<li><a href=\"https://arxiv.org/abs/1908.04373\">MULAN: Multitask Universal Lesion Analysis Network for Joint Lesion Detection, Tagging, and Segmentation</a></li>\n<li><a href=\"https://arxiv.org/abs/1901.03353\">RetinaMask: Learning to predict masks improves state-of-the-art single-shot detection for free</a></li>\n<li><a href=\"https://arxiv.org/abs/1904.01355\">FCOS: Fully Convolutional One-Stage Object Detection</a></li>\n<li><a href=\"https://arxiv.org/abs/1909.04868\">Is Sampling Heuristics Necessary in Training Deep Object Detectors?</a></li>\n</ol>\n<hr>\n"},{"title":"2025-03-03-java 学习","date":"2025-03-02T16:00:00.000Z","_content":"\n# 2025-03-03-java 学习\n\n# 运行结果\n\n![1740984761380Um6XbA84PoE5OZxgGQmcbH7anbc.png](https://tk-pichost-1325224430.cos.ap-chengdu.myqcloud.com/blog/1740984761380Um6XbA84PoE5OZxgGQmcbH7anbc.png)\n\n> 参考博客\n> [立方公式 及 完全立方公式-CSDN 博客](https://blog.csdn.net/weixin_44178736/article/details/108380732)\n\n![1740984767380ZEywblubeoDIfnx53h1ccesknjd.png](https://tk-pichost-1325224430.cos.ap-chengdu.myqcloud.com/blog/1740984767380ZEywblubeoDIfnx53h1ccesknjd.png)\n\n# 基础任务\n\n> 由自然数前 n 项立方和公式:\n>\n> $$\n> 1^{3}+2^{3}+\\cdot \\cdot \\cdot+\\mathrm{n}^{3}=[\\frac{\\mathrm{n}*(\\mathrm{n}+1)}{2}]^{2}=(1+2+\\cdot \\cdot \\cdot+\\mathrm{n})^{2}\n> $$\n>\n> 我们可以得到对于公式 1:只需验证 $$(\\frac{5*6}{2})^2 -(\\frac{2*3}{2})^2 = 6^3$$\n>\n> 对于公式 2:只需验证 $$(\\frac{69*70}{2})^2 -(\\frac{5*6}{2})^2 = 180^3$$\n\n```java\npublic class Main {\n    public static void main(String[] args) {\n        // 验证基本等式\n        System._out_.println(\"验证基本等式...\\n\");\n        _verifyBasicEquations_();\n\n        // 附加任务\n        System._out_.println(\"寻找更多的满足条件的整数序列...\");\n        _findMoreSequences_();\n    }\n\n    // 验证基本等式\n    private static void verifyBasicEquations() {\n        // 使用自然数立方和公式验证\n        // 公式：1^3 + 2^3 + ... + n^3 = [n(n+1)/2]^2\n        \n        // 验证公式1: 3^3 + 4^3 + 5^3 = 6^3\n        // 等价于 (5*6/2)^2 - (2*3/2)^2 = 6^3\n        double leftSide1 = Math._pow_(5 * 6.0 / 2, 2) - Math._pow_(2 * 3.0 / 2, 2);\n        double rightSide1 = Math._pow_(6, 3);\n        if (Math._abs_(leftSide1 - rightSide1) < 1e-10) {\n            System._out_.println(\"公式1:3^3 + 4^3 + 5^3 = 6^3 成立\");\n            System._out_.printf(\"左边 = %.2f, 右边 = %.2f\\n\", leftSide1, rightSide1);\n        } else {\n            System._out_.println(\"公式1:3^3 + 4^3 + 5^3 = 6^3 不成立\");\n        }\n\n        // 验证公式2: 6^3 + 7^3 + ... + 69^3 = 180^3\n        // 等价于 (69*70/2)^2 - (5*6/2)^2 = 180^3\n        double leftSide2 = Math._pow_(69 * 70.0 / 2, 2) - Math._pow_(5 * 6.0 / 2, 2);\n        double rightSide2 = Math._pow_(180, 3);\n        if (Math._abs_(leftSide2 - rightSide2) < 1e-10) {\n            System._out_.println(\"\\n公式2:6^3 + 7^3 + ... + 69^3 = 180^3 成立\");\n            System._out_.printf(\"左边 = %.2f, 右边 = %.2f\\n\", leftSide2, rightSide2);\n        } else {\n            System._out_.println(\"\\n公式2:6^3 + 7^3 + ... + 69^3 = 180^3 不成立\");\n        }\n    }\n}\n```\n\n# 附加任务\n\n> 我的思路是用两个嵌套循环,暴力搜索满足要求的整数序列,使用立方和公式化简来直接计算区间和，避免了循环计算每个数的立方：\n> 对于区间[start, end]，使用 $(\\frac{end(end+1)}{2})^2 - (\\frac{(start-1)(start)}{2})^2$\n> 代码避免了大量的立方计算，运行速度会比直接使用立方和 + 暴力搜索快。如果想要搜索更大范围的数，只需要修改循环中的上限（1000）即可。\n\n```java\nprivate static void findMoreSequences() {\n    System._out_.println(\"找到的满足条件的整数序列：\");\n    for (int start = 1; start < 100; start++) {\n        for (int end = start; end < 100; end++) {  \n            // 使用立方和公式计算区间[start, end]的立方和\n            double sum = Math._pow_(end * (end + 1.0) / 2, 2) - \n                       Math._pow_((start - 1) * start / 2.0, 2);\n            \n            // 计算立方根\n            double cubeRoot = Math._cbrt_(sum);\n            // 检查是否为整数\n            if (Math._abs_(cubeRoot - Math._round_(cubeRoot)) < 1e-10) {\n                int cubeRootInt = (int) Math._round_(cubeRoot);\n                // 验证这个序列是否真的满足条件\n                double verification = Math._pow_(cubeRootInt, 3);\n                if (Math._abs_(verification - sum) < 1e-10) {\n                    // 只输出有意义的序列（立方根大于序列中的所有数）\n                    if (cubeRootInt > end) {\n                        System._out_.printf(\"%d^3 + %d^3 + ... + %d^3 = %d^3\\n\", \n                            start, start + 1, end, cubeRootInt);\n                    }\n                }\n            }\n        }\n    }\n}\n```\n","source":"_posts/2025-03-03-java作业(week2).md","raw":"---\ntitle: 2025-03-03-java 学习\ndate: 2025-03-03\ntags: 算法练习\n---\n\n# 2025-03-03-java 学习\n\n# 运行结果\n\n![1740984761380Um6XbA84PoE5OZxgGQmcbH7anbc.png](https://tk-pichost-1325224430.cos.ap-chengdu.myqcloud.com/blog/1740984761380Um6XbA84PoE5OZxgGQmcbH7anbc.png)\n\n> 参考博客\n> [立方公式 及 完全立方公式-CSDN 博客](https://blog.csdn.net/weixin_44178736/article/details/108380732)\n\n![1740984767380ZEywblubeoDIfnx53h1ccesknjd.png](https://tk-pichost-1325224430.cos.ap-chengdu.myqcloud.com/blog/1740984767380ZEywblubeoDIfnx53h1ccesknjd.png)\n\n# 基础任务\n\n> 由自然数前 n 项立方和公式:\n>\n> $$\n> 1^{3}+2^{3}+\\cdot \\cdot \\cdot+\\mathrm{n}^{3}=[\\frac{\\mathrm{n}*(\\mathrm{n}+1)}{2}]^{2}=(1+2+\\cdot \\cdot \\cdot+\\mathrm{n})^{2}\n> $$\n>\n> 我们可以得到对于公式 1:只需验证 $$(\\frac{5*6}{2})^2 -(\\frac{2*3}{2})^2 = 6^3$$\n>\n> 对于公式 2:只需验证 $$(\\frac{69*70}{2})^2 -(\\frac{5*6}{2})^2 = 180^3$$\n\n```java\npublic class Main {\n    public static void main(String[] args) {\n        // 验证基本等式\n        System._out_.println(\"验证基本等式...\\n\");\n        _verifyBasicEquations_();\n\n        // 附加任务\n        System._out_.println(\"寻找更多的满足条件的整数序列...\");\n        _findMoreSequences_();\n    }\n\n    // 验证基本等式\n    private static void verifyBasicEquations() {\n        // 使用自然数立方和公式验证\n        // 公式：1^3 + 2^3 + ... + n^3 = [n(n+1)/2]^2\n        \n        // 验证公式1: 3^3 + 4^3 + 5^3 = 6^3\n        // 等价于 (5*6/2)^2 - (2*3/2)^2 = 6^3\n        double leftSide1 = Math._pow_(5 * 6.0 / 2, 2) - Math._pow_(2 * 3.0 / 2, 2);\n        double rightSide1 = Math._pow_(6, 3);\n        if (Math._abs_(leftSide1 - rightSide1) < 1e-10) {\n            System._out_.println(\"公式1:3^3 + 4^3 + 5^3 = 6^3 成立\");\n            System._out_.printf(\"左边 = %.2f, 右边 = %.2f\\n\", leftSide1, rightSide1);\n        } else {\n            System._out_.println(\"公式1:3^3 + 4^3 + 5^3 = 6^3 不成立\");\n        }\n\n        // 验证公式2: 6^3 + 7^3 + ... + 69^3 = 180^3\n        // 等价于 (69*70/2)^2 - (5*6/2)^2 = 180^3\n        double leftSide2 = Math._pow_(69 * 70.0 / 2, 2) - Math._pow_(5 * 6.0 / 2, 2);\n        double rightSide2 = Math._pow_(180, 3);\n        if (Math._abs_(leftSide2 - rightSide2) < 1e-10) {\n            System._out_.println(\"\\n公式2:6^3 + 7^3 + ... + 69^3 = 180^3 成立\");\n            System._out_.printf(\"左边 = %.2f, 右边 = %.2f\\n\", leftSide2, rightSide2);\n        } else {\n            System._out_.println(\"\\n公式2:6^3 + 7^3 + ... + 69^3 = 180^3 不成立\");\n        }\n    }\n}\n```\n\n# 附加任务\n\n> 我的思路是用两个嵌套循环,暴力搜索满足要求的整数序列,使用立方和公式化简来直接计算区间和，避免了循环计算每个数的立方：\n> 对于区间[start, end]，使用 $(\\frac{end(end+1)}{2})^2 - (\\frac{(start-1)(start)}{2})^2$\n> 代码避免了大量的立方计算，运行速度会比直接使用立方和 + 暴力搜索快。如果想要搜索更大范围的数，只需要修改循环中的上限（1000）即可。\n\n```java\nprivate static void findMoreSequences() {\n    System._out_.println(\"找到的满足条件的整数序列：\");\n    for (int start = 1; start < 100; start++) {\n        for (int end = start; end < 100; end++) {  \n            // 使用立方和公式计算区间[start, end]的立方和\n            double sum = Math._pow_(end * (end + 1.0) / 2, 2) - \n                       Math._pow_((start - 1) * start / 2.0, 2);\n            \n            // 计算立方根\n            double cubeRoot = Math._cbrt_(sum);\n            // 检查是否为整数\n            if (Math._abs_(cubeRoot - Math._round_(cubeRoot)) < 1e-10) {\n                int cubeRootInt = (int) Math._round_(cubeRoot);\n                // 验证这个序列是否真的满足条件\n                double verification = Math._pow_(cubeRootInt, 3);\n                if (Math._abs_(verification - sum) < 1e-10) {\n                    // 只输出有意义的序列（立方根大于序列中的所有数）\n                    if (cubeRootInt > end) {\n                        System._out_.printf(\"%d^3 + %d^3 + ... + %d^3 = %d^3\\n\", \n                            start, start + 1, end, cubeRootInt);\n                    }\n                }\n            }\n        }\n    }\n}\n```\n","slug":"2025-03-03-java作业(week2)","published":1,"updated":"2025-09-26T12:15:38.944Z","_id":"cmg0saj3w000ejm8nhz3b48m1","comments":1,"layout":"post","photos":[],"content":"<h1 id=\"2025-03-03-java-学习\"><a href=\"#2025-03-03-java-学习\" class=\"headerlink\" title=\"2025-03-03-java 学习\"></a>2025-03-03-java 学习</h1><h1 id=\"运行结果\"><a href=\"#运行结果\" class=\"headerlink\" title=\"运行结果\"></a>运行结果</h1><p><img src=\"https://tk-pichost-1325224430.cos.ap-chengdu.myqcloud.com/blog/1740984761380Um6XbA84PoE5OZxgGQmcbH7anbc.png\" alt=\"1740984761380Um6XbA84PoE5OZxgGQmcbH7anbc.png\"></p>\n<blockquote>\n<p>参考博客<br><a href=\"https://blog.csdn.net/weixin_44178736/article/details/108380732\">立方公式 及 完全立方公式-CSDN 博客</a></p>\n</blockquote>\n<p><img src=\"https://tk-pichost-1325224430.cos.ap-chengdu.myqcloud.com/blog/1740984767380ZEywblubeoDIfnx53h1ccesknjd.png\" alt=\"1740984767380ZEywblubeoDIfnx53h1ccesknjd.png\"></p>\n<h1 id=\"基础任务\"><a href=\"#基础任务\" class=\"headerlink\" title=\"基础任务\"></a>基础任务</h1><blockquote>\n<p>由自然数前 n 项立方和公式:</p>\n<p>$$<br>1^{3}+2^{3}+\\cdot \\cdot \\cdot+\\mathrm{n}^{3}&#x3D;[\\frac{\\mathrm{n}*(\\mathrm{n}+1)}{2}]^{2}&#x3D;(1+2+\\cdot \\cdot \\cdot+\\mathrm{n})^{2}<br>$$</p>\n<p>我们可以得到对于公式 1:只需验证 $$(\\frac{5<em>6}{2})^2 -(\\frac{2</em>3}{2})^2 &#x3D; 6^3$$</p>\n<p>对于公式 2:只需验证 $$(\\frac{69<em>70}{2})^2 -(\\frac{5</em>6}{2})^2 &#x3D; 180^3$$</p>\n</blockquote>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"keyword\">class</span> <span class=\"title class_\">Main</span> &#123;</span><br><span class=\"line\">    <span class=\"keyword\">public</span> <span class=\"keyword\">static</span> <span class=\"keyword\">void</span> <span class=\"title function_\">main</span><span class=\"params\">(String[] args)</span> &#123;</span><br><span class=\"line\">        <span class=\"comment\">// 验证基本等式</span></span><br><span class=\"line\">        System._out_.println(<span class=\"string\">&quot;验证基本等式...\\n&quot;</span>);</span><br><span class=\"line\">        _verifyBasicEquations_();</span><br><span class=\"line\"></span><br><span class=\"line\">        <span class=\"comment\">// 附加任务</span></span><br><span class=\"line\">        System._out_.println(<span class=\"string\">&quot;寻找更多的满足条件的整数序列...&quot;</span>);</span><br><span class=\"line\">        _findMoreSequences_();</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\">// 验证基本等式</span></span><br><span class=\"line\">    <span class=\"keyword\">private</span> <span class=\"keyword\">static</span> <span class=\"keyword\">void</span> <span class=\"title function_\">verifyBasicEquations</span><span class=\"params\">()</span> &#123;</span><br><span class=\"line\">        <span class=\"comment\">// 使用自然数立方和公式验证</span></span><br><span class=\"line\">        <span class=\"comment\">// 公式：1^3 + 2^3 + ... + n^3 = [n(n+1)/2]^2</span></span><br><span class=\"line\">        </span><br><span class=\"line\">        <span class=\"comment\">// 验证公式1: 3^3 + 4^3 + 5^3 = 6^3</span></span><br><span class=\"line\">        <span class=\"comment\">// 等价于 (5*6/2)^2 - (2*3/2)^2 = 6^3</span></span><br><span class=\"line\">        <span class=\"type\">double</span> <span class=\"variable\">leftSide1</span> <span class=\"operator\">=</span> Math._pow_(<span class=\"number\">5</span> * <span class=\"number\">6.0</span> / <span class=\"number\">2</span>, <span class=\"number\">2</span>) - Math._pow_(<span class=\"number\">2</span> * <span class=\"number\">3.0</span> / <span class=\"number\">2</span>, <span class=\"number\">2</span>);</span><br><span class=\"line\">        <span class=\"type\">double</span> <span class=\"variable\">rightSide1</span> <span class=\"operator\">=</span> Math._pow_(<span class=\"number\">6</span>, <span class=\"number\">3</span>);</span><br><span class=\"line\">        <span class=\"keyword\">if</span> (Math._abs_(leftSide1 - rightSide1) &lt; <span class=\"number\">1e-10</span>) &#123;</span><br><span class=\"line\">            System._out_.println(<span class=\"string\">&quot;公式1:3^3 + 4^3 + 5^3 = 6^3 成立&quot;</span>);</span><br><span class=\"line\">            System._out_.printf(<span class=\"string\">&quot;左边 = %.2f, 右边 = %.2f\\n&quot;</span>, leftSide1, rightSide1);</span><br><span class=\"line\">        &#125; <span class=\"keyword\">else</span> &#123;</span><br><span class=\"line\">            System._out_.println(<span class=\"string\">&quot;公式1:3^3 + 4^3 + 5^3 = 6^3 不成立&quot;</span>);</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">        <span class=\"comment\">// 验证公式2: 6^3 + 7^3 + ... + 69^3 = 180^3</span></span><br><span class=\"line\">        <span class=\"comment\">// 等价于 (69*70/2)^2 - (5*6/2)^2 = 180^3</span></span><br><span class=\"line\">        <span class=\"type\">double</span> <span class=\"variable\">leftSide2</span> <span class=\"operator\">=</span> Math._pow_(<span class=\"number\">69</span> * <span class=\"number\">70.0</span> / <span class=\"number\">2</span>, <span class=\"number\">2</span>) - Math._pow_(<span class=\"number\">5</span> * <span class=\"number\">6.0</span> / <span class=\"number\">2</span>, <span class=\"number\">2</span>);</span><br><span class=\"line\">        <span class=\"type\">double</span> <span class=\"variable\">rightSide2</span> <span class=\"operator\">=</span> Math._pow_(<span class=\"number\">180</span>, <span class=\"number\">3</span>);</span><br><span class=\"line\">        <span class=\"keyword\">if</span> (Math._abs_(leftSide2 - rightSide2) &lt; <span class=\"number\">1e-10</span>) &#123;</span><br><span class=\"line\">            System._out_.println(<span class=\"string\">&quot;\\n公式2:6^3 + 7^3 + ... + 69^3 = 180^3 成立&quot;</span>);</span><br><span class=\"line\">            System._out_.printf(<span class=\"string\">&quot;左边 = %.2f, 右边 = %.2f\\n&quot;</span>, leftSide2, rightSide2);</span><br><span class=\"line\">        &#125; <span class=\"keyword\">else</span> &#123;</span><br><span class=\"line\">            System._out_.println(<span class=\"string\">&quot;\\n公式2:6^3 + 7^3 + ... + 69^3 = 180^3 不成立&quot;</span>);</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<h1 id=\"附加任务\"><a href=\"#附加任务\" class=\"headerlink\" title=\"附加任务\"></a>附加任务</h1><blockquote>\n<p>我的思路是用两个嵌套循环,暴力搜索满足要求的整数序列,使用立方和公式化简来直接计算区间和，避免了循环计算每个数的立方：<br>对于区间[start, end]，使用 $(\\frac{end(end+1)}{2})^2 - (\\frac{(start-1)(start)}{2})^2$<br>代码避免了大量的立方计算，运行速度会比直接使用立方和 + 暴力搜索快。如果想要搜索更大范围的数，只需要修改循环中的上限（1000）即可。</p>\n</blockquote>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">private</span> <span class=\"keyword\">static</span> <span class=\"keyword\">void</span> <span class=\"title function_\">findMoreSequences</span><span class=\"params\">()</span> &#123;</span><br><span class=\"line\">    System._out_.println(<span class=\"string\">&quot;找到的满足条件的整数序列：&quot;</span>);</span><br><span class=\"line\">    <span class=\"keyword\">for</span> (<span class=\"type\">int</span> <span class=\"variable\">start</span> <span class=\"operator\">=</span> <span class=\"number\">1</span>; start &lt; <span class=\"number\">100</span>; start++) &#123;</span><br><span class=\"line\">        <span class=\"keyword\">for</span> (<span class=\"type\">int</span> <span class=\"variable\">end</span> <span class=\"operator\">=</span> start; end &lt; <span class=\"number\">100</span>; end++) &#123;  </span><br><span class=\"line\">            <span class=\"comment\">// 使用立方和公式计算区间[start, end]的立方和</span></span><br><span class=\"line\">            <span class=\"type\">double</span> <span class=\"variable\">sum</span> <span class=\"operator\">=</span> Math._pow_(end * (end + <span class=\"number\">1.0</span>) / <span class=\"number\">2</span>, <span class=\"number\">2</span>) - </span><br><span class=\"line\">                       Math._pow_((start - <span class=\"number\">1</span>) * start / <span class=\"number\">2.0</span>, <span class=\"number\">2</span>);</span><br><span class=\"line\">            </span><br><span class=\"line\">            <span class=\"comment\">// 计算立方根</span></span><br><span class=\"line\">            <span class=\"type\">double</span> <span class=\"variable\">cubeRoot</span> <span class=\"operator\">=</span> Math._cbrt_(sum);</span><br><span class=\"line\">            <span class=\"comment\">// 检查是否为整数</span></span><br><span class=\"line\">            <span class=\"keyword\">if</span> (Math._abs_(cubeRoot - Math._round_(cubeRoot)) &lt; <span class=\"number\">1e-10</span>) &#123;</span><br><span class=\"line\">                <span class=\"type\">int</span> <span class=\"variable\">cubeRootInt</span> <span class=\"operator\">=</span> (<span class=\"type\">int</span>) Math._round_(cubeRoot);</span><br><span class=\"line\">                <span class=\"comment\">// 验证这个序列是否真的满足条件</span></span><br><span class=\"line\">                <span class=\"type\">double</span> <span class=\"variable\">verification</span> <span class=\"operator\">=</span> Math._pow_(cubeRootInt, <span class=\"number\">3</span>);</span><br><span class=\"line\">                <span class=\"keyword\">if</span> (Math._abs_(verification - sum) &lt; <span class=\"number\">1e-10</span>) &#123;</span><br><span class=\"line\">                    <span class=\"comment\">// 只输出有意义的序列（立方根大于序列中的所有数）</span></span><br><span class=\"line\">                    <span class=\"keyword\">if</span> (cubeRootInt &gt; end) &#123;</span><br><span class=\"line\">                        System._out_.printf(<span class=\"string\">&quot;%d^3 + %d^3 + ... + %d^3 = %d^3\\n&quot;</span>, </span><br><span class=\"line\">                            start, start + <span class=\"number\">1</span>, end, cubeRootInt);</span><br><span class=\"line\">                    &#125;</span><br><span class=\"line\">                &#125;</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n","excerpt":"","more":"<h1 id=\"2025-03-03-java-学习\"><a href=\"#2025-03-03-java-学习\" class=\"headerlink\" title=\"2025-03-03-java 学习\"></a>2025-03-03-java 学习</h1><h1 id=\"运行结果\"><a href=\"#运行结果\" class=\"headerlink\" title=\"运行结果\"></a>运行结果</h1><p><img src=\"https://tk-pichost-1325224430.cos.ap-chengdu.myqcloud.com/blog/1740984761380Um6XbA84PoE5OZxgGQmcbH7anbc.png\" alt=\"1740984761380Um6XbA84PoE5OZxgGQmcbH7anbc.png\"></p>\n<blockquote>\n<p>参考博客<br><a href=\"https://blog.csdn.net/weixin_44178736/article/details/108380732\">立方公式 及 完全立方公式-CSDN 博客</a></p>\n</blockquote>\n<p><img src=\"https://tk-pichost-1325224430.cos.ap-chengdu.myqcloud.com/blog/1740984767380ZEywblubeoDIfnx53h1ccesknjd.png\" alt=\"1740984767380ZEywblubeoDIfnx53h1ccesknjd.png\"></p>\n<h1 id=\"基础任务\"><a href=\"#基础任务\" class=\"headerlink\" title=\"基础任务\"></a>基础任务</h1><blockquote>\n<p>由自然数前 n 项立方和公式:</p>\n<p>$$<br>1^{3}+2^{3}+\\cdot \\cdot \\cdot+\\mathrm{n}^{3}&#x3D;[\\frac{\\mathrm{n}*(\\mathrm{n}+1)}{2}]^{2}&#x3D;(1+2+\\cdot \\cdot \\cdot+\\mathrm{n})^{2}<br>$$</p>\n<p>我们可以得到对于公式 1:只需验证 $$(\\frac{5<em>6}{2})^2 -(\\frac{2</em>3}{2})^2 &#x3D; 6^3$$</p>\n<p>对于公式 2:只需验证 $$(\\frac{69<em>70}{2})^2 -(\\frac{5</em>6}{2})^2 &#x3D; 180^3$$</p>\n</blockquote>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"keyword\">class</span> <span class=\"title class_\">Main</span> &#123;</span><br><span class=\"line\">    <span class=\"keyword\">public</span> <span class=\"keyword\">static</span> <span class=\"keyword\">void</span> <span class=\"title function_\">main</span><span class=\"params\">(String[] args)</span> &#123;</span><br><span class=\"line\">        <span class=\"comment\">// 验证基本等式</span></span><br><span class=\"line\">        System._out_.println(<span class=\"string\">&quot;验证基本等式...\\n&quot;</span>);</span><br><span class=\"line\">        _verifyBasicEquations_();</span><br><span class=\"line\"></span><br><span class=\"line\">        <span class=\"comment\">// 附加任务</span></span><br><span class=\"line\">        System._out_.println(<span class=\"string\">&quot;寻找更多的满足条件的整数序列...&quot;</span>);</span><br><span class=\"line\">        _findMoreSequences_();</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\">// 验证基本等式</span></span><br><span class=\"line\">    <span class=\"keyword\">private</span> <span class=\"keyword\">static</span> <span class=\"keyword\">void</span> <span class=\"title function_\">verifyBasicEquations</span><span class=\"params\">()</span> &#123;</span><br><span class=\"line\">        <span class=\"comment\">// 使用自然数立方和公式验证</span></span><br><span class=\"line\">        <span class=\"comment\">// 公式：1^3 + 2^3 + ... + n^3 = [n(n+1)/2]^2</span></span><br><span class=\"line\">        </span><br><span class=\"line\">        <span class=\"comment\">// 验证公式1: 3^3 + 4^3 + 5^3 = 6^3</span></span><br><span class=\"line\">        <span class=\"comment\">// 等价于 (5*6/2)^2 - (2*3/2)^2 = 6^3</span></span><br><span class=\"line\">        <span class=\"type\">double</span> <span class=\"variable\">leftSide1</span> <span class=\"operator\">=</span> Math._pow_(<span class=\"number\">5</span> * <span class=\"number\">6.0</span> / <span class=\"number\">2</span>, <span class=\"number\">2</span>) - Math._pow_(<span class=\"number\">2</span> * <span class=\"number\">3.0</span> / <span class=\"number\">2</span>, <span class=\"number\">2</span>);</span><br><span class=\"line\">        <span class=\"type\">double</span> <span class=\"variable\">rightSide1</span> <span class=\"operator\">=</span> Math._pow_(<span class=\"number\">6</span>, <span class=\"number\">3</span>);</span><br><span class=\"line\">        <span class=\"keyword\">if</span> (Math._abs_(leftSide1 - rightSide1) &lt; <span class=\"number\">1e-10</span>) &#123;</span><br><span class=\"line\">            System._out_.println(<span class=\"string\">&quot;公式1:3^3 + 4^3 + 5^3 = 6^3 成立&quot;</span>);</span><br><span class=\"line\">            System._out_.printf(<span class=\"string\">&quot;左边 = %.2f, 右边 = %.2f\\n&quot;</span>, leftSide1, rightSide1);</span><br><span class=\"line\">        &#125; <span class=\"keyword\">else</span> &#123;</span><br><span class=\"line\">            System._out_.println(<span class=\"string\">&quot;公式1:3^3 + 4^3 + 5^3 = 6^3 不成立&quot;</span>);</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">        <span class=\"comment\">// 验证公式2: 6^3 + 7^3 + ... + 69^3 = 180^3</span></span><br><span class=\"line\">        <span class=\"comment\">// 等价于 (69*70/2)^2 - (5*6/2)^2 = 180^3</span></span><br><span class=\"line\">        <span class=\"type\">double</span> <span class=\"variable\">leftSide2</span> <span class=\"operator\">=</span> Math._pow_(<span class=\"number\">69</span> * <span class=\"number\">70.0</span> / <span class=\"number\">2</span>, <span class=\"number\">2</span>) - Math._pow_(<span class=\"number\">5</span> * <span class=\"number\">6.0</span> / <span class=\"number\">2</span>, <span class=\"number\">2</span>);</span><br><span class=\"line\">        <span class=\"type\">double</span> <span class=\"variable\">rightSide2</span> <span class=\"operator\">=</span> Math._pow_(<span class=\"number\">180</span>, <span class=\"number\">3</span>);</span><br><span class=\"line\">        <span class=\"keyword\">if</span> (Math._abs_(leftSide2 - rightSide2) &lt; <span class=\"number\">1e-10</span>) &#123;</span><br><span class=\"line\">            System._out_.println(<span class=\"string\">&quot;\\n公式2:6^3 + 7^3 + ... + 69^3 = 180^3 成立&quot;</span>);</span><br><span class=\"line\">            System._out_.printf(<span class=\"string\">&quot;左边 = %.2f, 右边 = %.2f\\n&quot;</span>, leftSide2, rightSide2);</span><br><span class=\"line\">        &#125; <span class=\"keyword\">else</span> &#123;</span><br><span class=\"line\">            System._out_.println(<span class=\"string\">&quot;\\n公式2:6^3 + 7^3 + ... + 69^3 = 180^3 不成立&quot;</span>);</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<h1 id=\"附加任务\"><a href=\"#附加任务\" class=\"headerlink\" title=\"附加任务\"></a>附加任务</h1><blockquote>\n<p>我的思路是用两个嵌套循环,暴力搜索满足要求的整数序列,使用立方和公式化简来直接计算区间和，避免了循环计算每个数的立方：<br>对于区间[start, end]，使用 $(\\frac{end(end+1)}{2})^2 - (\\frac{(start-1)(start)}{2})^2$<br>代码避免了大量的立方计算，运行速度会比直接使用立方和 + 暴力搜索快。如果想要搜索更大范围的数，只需要修改循环中的上限（1000）即可。</p>\n</blockquote>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">private</span> <span class=\"keyword\">static</span> <span class=\"keyword\">void</span> <span class=\"title function_\">findMoreSequences</span><span class=\"params\">()</span> &#123;</span><br><span class=\"line\">    System._out_.println(<span class=\"string\">&quot;找到的满足条件的整数序列：&quot;</span>);</span><br><span class=\"line\">    <span class=\"keyword\">for</span> (<span class=\"type\">int</span> <span class=\"variable\">start</span> <span class=\"operator\">=</span> <span class=\"number\">1</span>; start &lt; <span class=\"number\">100</span>; start++) &#123;</span><br><span class=\"line\">        <span class=\"keyword\">for</span> (<span class=\"type\">int</span> <span class=\"variable\">end</span> <span class=\"operator\">=</span> start; end &lt; <span class=\"number\">100</span>; end++) &#123;  </span><br><span class=\"line\">            <span class=\"comment\">// 使用立方和公式计算区间[start, end]的立方和</span></span><br><span class=\"line\">            <span class=\"type\">double</span> <span class=\"variable\">sum</span> <span class=\"operator\">=</span> Math._pow_(end * (end + <span class=\"number\">1.0</span>) / <span class=\"number\">2</span>, <span class=\"number\">2</span>) - </span><br><span class=\"line\">                       Math._pow_((start - <span class=\"number\">1</span>) * start / <span class=\"number\">2.0</span>, <span class=\"number\">2</span>);</span><br><span class=\"line\">            </span><br><span class=\"line\">            <span class=\"comment\">// 计算立方根</span></span><br><span class=\"line\">            <span class=\"type\">double</span> <span class=\"variable\">cubeRoot</span> <span class=\"operator\">=</span> Math._cbrt_(sum);</span><br><span class=\"line\">            <span class=\"comment\">// 检查是否为整数</span></span><br><span class=\"line\">            <span class=\"keyword\">if</span> (Math._abs_(cubeRoot - Math._round_(cubeRoot)) &lt; <span class=\"number\">1e-10</span>) &#123;</span><br><span class=\"line\">                <span class=\"type\">int</span> <span class=\"variable\">cubeRootInt</span> <span class=\"operator\">=</span> (<span class=\"type\">int</span>) Math._round_(cubeRoot);</span><br><span class=\"line\">                <span class=\"comment\">// 验证这个序列是否真的满足条件</span></span><br><span class=\"line\">                <span class=\"type\">double</span> <span class=\"variable\">verification</span> <span class=\"operator\">=</span> Math._pow_(cubeRootInt, <span class=\"number\">3</span>);</span><br><span class=\"line\">                <span class=\"keyword\">if</span> (Math._abs_(verification - sum) &lt; <span class=\"number\">1e-10</span>) &#123;</span><br><span class=\"line\">                    <span class=\"comment\">// 只输出有意义的序列（立方根大于序列中的所有数）</span></span><br><span class=\"line\">                    <span class=\"keyword\">if</span> (cubeRootInt &gt; end) &#123;</span><br><span class=\"line\">                        System._out_.printf(<span class=\"string\">&quot;%d^3 + %d^3 + ... + %d^3 = %d^3\\n&quot;</span>, </span><br><span class=\"line\">                            start, start + <span class=\"number\">1</span>, end, cubeRootInt);</span><br><span class=\"line\">                    &#125;</span><br><span class=\"line\">                &#125;</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n"},{"title":"2025-02-23-Atcoder abc394","date":"2025-02-22T16:00:00.000Z","_content":"\n# Atcoder abc394\n\n# A\n\n> ## [22222](https://atcoder.jp/contests/abc394/tasks/abc394a)\n\n### code\n\n```cpp\n#include <bits/stdc++.h>\n\nusing namespace std;\n\nint main(){\n    string s;\n    cin >> s;\n    int n = s.size();\n    for(int i = 0; i < n; i++){\n        if(s[i] == '2'){\n            cout << 2 ;\n        }\n    }\n    return 0;\n}\n```\n\n# B\n\n> ## [cat](https://atcoder.jp/contests/abc394/tasks/abc394b)\n\n### code\n\n```cpp\n// 包含C++标准库的头文件\n#include <bits/stdc++.h>\n\n// 使用标准命名空间\nusing namespace std;\n\nint main(){\n    // 声明变量n用于存储输入的字符串个数\n    int n;\n    cin >> n;\n    // 创建一个大小为n的字符串向量s用于存储输入的字符串\n    vector<string> s(n);\n    // 循环读入n个字符串\n    for(int i = 0; i < n; i++){\n        cin >> s[i];\n    }\n    // 创建一个pair向量a,用于存储字符串及其长度\n    vector<pair<string,int>> a;\n    // 遍历字符串向量s,将每个字符串及其长度作为pair存入向量a\n    for(int i = 0; i < n; i++){\n        a.pushback(makepair(s[i],s[i].size()));\n    }\n    // 使用lambda表达式对向量a按照字符串长度进行升序排序\n    // sort(a.begin(), a.end(), [](const pair<string,int>& x, const pair<string,int>& y){\n    //     return x.second < y.second;\n    // });\n    // const 和 & 是为了提高效率，可以暂时不用太关注\n    sort(a.begin(), a.end(), [](pair<string, int> x, pair<string, int> y)\n         { return x.**second** < y.**second**; });\n    // 按顺序输出排序后的字符串\n    for(int i = 0; i < n; i++){\n        cout << a[i].**first**;\n    }\n    return 0;\n}\n```\n\n# C\n\n> ## <u>Debug</u>\n\n### code\n\n```cpp\n#include <bits/stdc++.h>\n\nusing namespace std;\n\nint main()\n{\n    string s;\n    cin >> s;\n\n    vector<char> chars(s.begin(), s.end());\n    bool changed = true;\n\n    while (changed)\n    {\n        changed = false;\n        vector<char> next = chars;\n\n        for (int i = 0; i < chars.size() - 1; i++)\n        {\n            if (next[i] == 'W' && next[i + 1] == 'A')\n            {\n                next[i] = 'A';\n                next[i + 1] = 'C';\n                changed = true;\n                i++; // 跳过下一个字符，因为已经处理过了\n            }\n        }\n        chars = next;\n    }\n\n    for (char c : chars)\n    {\n        cout << c;\n    }\n    cout << endl;\n    return 0;\n}\n```\n\n# D\n\n> ## [Colorful Bracket Sequence](https://atcoder.jp/contests/abc394/tasks/abc394d)\n\n### code\n\n```cpp\n#include <bits/stdc++.h>\n\nusing namespace std;\n\n// 将函数定义移到 main 函数外部\nint bracketmatch(string &s1, string &s2)\n{\n    if (s1 == \"(\" && s2 == \")\")\n    {\n        return 1;\n    }\n    else if (s1 == \"[\" && s2 == \"]\")\n    {\n        return 1;\n    }\n    else if (s1 == \"{\" && s2 == \"}\")\n    {\n        return 1;\n    }\n    return 0;\n}\n\nint main()\n{\n    string bracket;\n    cin >> bracket;\n\n    stack<string> bracketstack;\n\n    for (int i = 0; i < bracket.size(); i++)\n    {\n        string current(1, bracket[i]); // 将 char 转换为 string\n\n        if (current == \"(\" || current == \"[\" || current == \"{\")\n        {\n            bracketstack.push(current);\n        }\n        else if (current == \")\" || current == \"]\" || current == \"}\")\n        {\n            if (bracketstack.empty())\n            {\n                cout << \"No\" << endl;\n                return 0;\n            }\n            if (bracketmatch(bracketstack.top(), current))\n            {\n                bracketstack.pop();\n            }\n            else\n            {\n                cout << \"No\" << endl;\n                return 0;\n            }\n        }\n    }\n\n    // 最后检查栈是否为空\n    if (!bracketstack.empty())\n    {\n        cout << \"No\" << endl;\n    }\n    else\n    {\n        cout << \"Yes\" << endl;\n    }\n\n    return 0;\n}\n```\n\n# E\n\n> ## [Palindromic Shortest Path](https://atcoder.jp/contests/abc394/tasks/abc394e)\n\n### code\n\n```cpp\n#include <bits/stdc++.h>\n// 定义一个简化的循环宏\n#define rep(i, n) for (int i = 0; i < (n); i++)\nusing namespace std;\n\n// 定义一个表示无穷大的常量\nint inf = 1000000010;\n\nint main()\n{\n    // 读入矩阵大小n\n    int n;\n    cin >> n;\n    // 创建n*n的字符矩阵c用于存储输入\n    vector<vector<char>> c(n, vector<char>(n));\n    rep(i, n) rep(j, n) cin >> c[i][j];\n    \n    // 创建n*n的距离矩阵a，初始化为无穷大\n    vector<vector<int>> a(n, vector<int>(n, inf));\n    // 创建队列用于BFS搜索\n    queue<pair<int, int>> que;\n    \n    // 对角线元素距离初始化为0\n    rep(i, n)\n    {\n        que.push({i, i});\n        a[i][i] = 0;\n    }\n    \n    // 直接相连的元素距离初始化为1\n    rep(i, n) rep(j, n)\n    {\n        if (i == j or c[i][j] == '-')\n            continue;\n        que.push({i, j});\n        a[i][j] = 1;\n    }\n    \n    // BFS搜索计算所有点对之间的最短距离\n    while (!que.empty()) // 当队列不为空时继续搜索\n    {\n        auto q = que.front(); // 获取队首元素\n        que.pop(); // 弹出队首元素\n        int i = q.**first**, j = q.**second**; // 获取当前处理的点对(i,j)的坐标\n        \n        // 遍历所有可能的新点对(k,l)\n        rep(k, n) rep(l, n) \n        {\n            // 判断是否可以通过当前点对(i,j)构建到新点对(k,l)的路径:\n            // 1. c[k][i]不是'-' - 表示k到i有边\n            // 2. c[j][l]不是'-' - 表示j到l有边\n            // 3. c[k][i] == c[j][l] - 两条边的字符相同\n            // 4. a[k][l] == inf - 点对(k,l)还未被访问过\n            if (c[k][i] != '-' && c[j][l] != '-' && c[k][i] == c[j][l] && a[k][l] == inf)\n            {\n                // 新路径的距离 = 当前点对的距离 + 2\n                // +2是因为需要经过两条新的边(k->i和j->l)\n                a[k][l] = a[i][j] + 2;\n                que.push({k, l}); // 将新的点对加入队列以继续搜索\n            }\n        }\n    }\n    \n    // 输出结果矩阵\n    rep(i, n)\n    {\n        rep(j, n)\n        {\n            // 如果距离仍为无穷大，输出-1，否则输出实际距离\n            cout << (a[i][j] == inf ? -1 : a[i][j]) << \" \\n\"[j == n - 1];\n        }\n    }\n}\n```\n\n# F\n\n> ## <u>Alkane</u>\n\n### code\n\n```cpp\n#include <bits/stdc++.h> // 包含C++标准库\n\nusing namespace std; // 使用标准命名空间\n\n#define mp makepair // 定义makepair的简写\n#define pb pushback // 定义pushback的简写\n#define fi first // 定义first的简写\n#define se second // 定义second的简写\n#define li long long // 定义long long的简写\n#define pii pair<int, int> // 定义pair<int,int>的简写\n#define vi vector<int> // 定义vector<int>的简写\n\n#define forn(i, n) for (int i = 0; i < (int)n; i++) // 定义从0到n-1的循环宏\n#define fore(i, b, e) for (int i = (int)b; i <= (int)e; i++) // 定义从b到e的循环宏\n#define all(x) (x).begin(), (x).end() // 定义容器的begin和end迭代器\n\nint ans = 0; // 存储最终答案\nvector<vi> edges; // 存储图的邻接表\nvi f; // 存储每个节点的状态值\n\nvoid dfs(int v, int p) // 深度优先搜索函数，v是当前节点，p是父节点\n{\n    for (int u : edges[v]) // 遍历当前节点的所有邻接点\n    {\n        if (u != p) // 如果邻接点不是父节点\n        {\n            dfs(u, v); // 递归处理子节点\n        }\n    }\n    f[v] = 1; // 初始化当前节点的状态值为1\n    if (edges[v].size() >= 4) // 如果当前节点的度数大于等于4\n    {\n        vi children; // 存储子节点的状态值\n        for (int u : edges[v]) // 遍历所有邻接点\n        {\n            if (u != p) // 如果不是父节点\n            {\n                children.pb(f[u]); // 添加子节点的状态值\n            }\n            else\n            {\n                children.pb(1); // 父节点贡献值为1\n            }\n        }\n        sort(all(children), greater<int>()); // 对子节点状态值降序排序\n        forn(j, 3) // 选择前3大的值\n        {\n            f[v] += children[j]; // 累加到当前节点的状态值\n        }\n        int here = 1; // 计算包含4个子节点的路径长度\n        forn(j, 4)\n        {\n            here += children[j];\n        }\n        ans = max(ans, here); // 更新最大答案\n    }\n    else if (p == -1) // 如果是根节点\n    {\n        for (int u : edges[v]) // 遍历所有子节点\n        {\n            f[v] = max(f[v], f[u] + 1); // 更新根节点状态值\n        }\n    }\n    // printf(\"f[%d] = %d edges count = %d\\n\", v, f[v], (int)edges[v].size());\n    ans = max(ans, f[v] + (p == -1 ? 0 : 1)); // 更新最大答案\n}\n\nint main()\n{\n    int n; // 节点数量\n    cin >> n;\n    edges.resize(n + 1); // 初始化邻接表大小\n    forn(i, n - 1) // 读入n-1条边\n    {\n        int u, v;\n        cin >> u >> v;\n        edges[u].pb(v); // 添加无向边\n        edges[v].pb(u);\n    }\n    f.resize(n + 1); // 初始化状态数组大小\n    dfs(1, -1); // 从节点1开始深度优先搜索\n    if (ans < 5) // 如果最大路径长度小于5\n    {\n        ans = -1; // 输出-1\n    }\n    cout << ans; // 输出答案\n}\n```\n\n# G\n\n> ## <u>Dense Buildings</u>\n\n### code\n\n```cpp\n// 包含C++标准库和atcoder的并查集库\n#include <bits/stdc++.h>\n#include <atcoder/dsu>\n\n// 使用标准命名空间和atcoder命名空间\nusing namespace std;\nusing namespace atcoder;\n\n// 定义常量\n#define H 500          // 最大高度\n#define W 500          // 最大宽度\n#define Q (int)2e+5    // 最大查询次数\n#define F (int)1e+6    // 最大权值\n\nint main(void)\n{\n    int h, w, q;                   // h,w为网格大小,q为查询次数\n    int f[H][W];                   // f[i][j]存储网格中每个位置的权值\n    int a[Q], b[Q], y[Q];          // 每个查询的起点坐标(a,b)和权值y\n    int c[Q], d[Q], z[Q];          // 每个查询的终点坐标(c,d)和权值z\n    int l[Q], r[Q];                // 二分查找的左右边界\n    vector<pair<int, int>> e[F + 1];    // e[i]存储权值为i的边\n    vector<int> check[F + 1];           // check[i]存储需要在权值i处检查的查询\n\n    // 读入网格大小\n    cin >> h >> w;\n    // 读入网格中的权值\n    for (int i = 0; i < h; i++)\n        for (int j = 0; j < w; j++)\n            cin >> f[i][j];\n    // 读入查询次数和查询信息\n    cin >> q;\n    for (int i = 0; i < q; i++)\n    {\n        cin >> a[i] >> b[i] >> y[i] >> c[i] >> d[i] >> z[i];\n        a[i]--, b[i]--, c[i]--, d[i]--;  // 坐标从0开始\n    }\n\n    // 构建边集合\n    // 添加竖直方向的边\n    for (int i = 0; i < h - 1; i++)\n        for (int j = 0; j < w; j++)\n            e[min(f[i][j], f[i + 1][j])].pushback({i * w + j, (i + 1) * w + j});\n    // 添加水平方向的边\n    for (int i = 0; i < h; i++)\n        for (int j = 0; j < w - 1; j++)\n            e[min(f[i][j], f[i][j + 1])].pushback({i * w + j, i * w + (j + 1)});\n    // 初始化二分查找的边界\n    for (int i = 0; i < q; i++)\n        l[i] = 1, r[i] = F + 1;\n\n    // 二分查找过程\n    while (true)\n    {\n        bool flag = true;\n        // 清空check数组\n        for (int i = 0; i <= F; i++)\n            check[i].clear();\n        // 对每个查询,如果二分区间未收敛,则加入check数组\n        for (int i = 0; i < q; i++)\n        {\n            if (r[i] - l[i] > 1)\n            {\n                check[(l[i] + r[i]) / 2].pushback(i);\n                flag = false;\n            }\n        }\n        if (flag) break;  // 如果所有查询都已收敛,退出循环\n\n        // 使用并查集检查连通性\n        dsu uf(h * w);\n        // 从大到小遍历权值\n        for (int i = F; i >= 0; i--)\n        {\n            // 合并权值为i的所有边\n            int sz = e[i].size();\n            for (int j = 0; j < sz; j++)\n                uf.merge(e[i][j].**first**, e[i][j].**second**);\n            // 检查需要在权值i处判断的查询\n            sz = check[i].size();\n            for (int j = 0; j < sz; j++)\n            {\n                int idxs = a[check[i][j]] * w + b[check[i][j]];  // 起点在一维数组中的索引\n                int idxt = c[check[i][j]] * w + d[check[i][j]];  // 终点在一维数组中的索引\n                // 根据连通性更新二分边界\n                if (uf.same(idxs, idxt))\n                    l[check[i][j]] = i;\n                else\n                    r[check[i][j]] = i;\n            }\n        }\n    }\n\n    // 输出每个查询的结果\n    for (int i = 0; i < q; i++)\n        cout << (y[i] + z[i] - 2 * min(l[i], min(y[i], z[i]))) << endl;\n    return 0;\n}\n```\n","source":"_posts/2025-02-23-abc394.md","raw":"---\ntitle: 2025-02-23-Atcoder abc394\ndate: 2025-02-23\ntags: 算法练习\n---\n\n# Atcoder abc394\n\n# A\n\n> ## [22222](https://atcoder.jp/contests/abc394/tasks/abc394a)\n\n### code\n\n```cpp\n#include <bits/stdc++.h>\n\nusing namespace std;\n\nint main(){\n    string s;\n    cin >> s;\n    int n = s.size();\n    for(int i = 0; i < n; i++){\n        if(s[i] == '2'){\n            cout << 2 ;\n        }\n    }\n    return 0;\n}\n```\n\n# B\n\n> ## [cat](https://atcoder.jp/contests/abc394/tasks/abc394b)\n\n### code\n\n```cpp\n// 包含C++标准库的头文件\n#include <bits/stdc++.h>\n\n// 使用标准命名空间\nusing namespace std;\n\nint main(){\n    // 声明变量n用于存储输入的字符串个数\n    int n;\n    cin >> n;\n    // 创建一个大小为n的字符串向量s用于存储输入的字符串\n    vector<string> s(n);\n    // 循环读入n个字符串\n    for(int i = 0; i < n; i++){\n        cin >> s[i];\n    }\n    // 创建一个pair向量a,用于存储字符串及其长度\n    vector<pair<string,int>> a;\n    // 遍历字符串向量s,将每个字符串及其长度作为pair存入向量a\n    for(int i = 0; i < n; i++){\n        a.pushback(makepair(s[i],s[i].size()));\n    }\n    // 使用lambda表达式对向量a按照字符串长度进行升序排序\n    // sort(a.begin(), a.end(), [](const pair<string,int>& x, const pair<string,int>& y){\n    //     return x.second < y.second;\n    // });\n    // const 和 & 是为了提高效率，可以暂时不用太关注\n    sort(a.begin(), a.end(), [](pair<string, int> x, pair<string, int> y)\n         { return x.**second** < y.**second**; });\n    // 按顺序输出排序后的字符串\n    for(int i = 0; i < n; i++){\n        cout << a[i].**first**;\n    }\n    return 0;\n}\n```\n\n# C\n\n> ## <u>Debug</u>\n\n### code\n\n```cpp\n#include <bits/stdc++.h>\n\nusing namespace std;\n\nint main()\n{\n    string s;\n    cin >> s;\n\n    vector<char> chars(s.begin(), s.end());\n    bool changed = true;\n\n    while (changed)\n    {\n        changed = false;\n        vector<char> next = chars;\n\n        for (int i = 0; i < chars.size() - 1; i++)\n        {\n            if (next[i] == 'W' && next[i + 1] == 'A')\n            {\n                next[i] = 'A';\n                next[i + 1] = 'C';\n                changed = true;\n                i++; // 跳过下一个字符，因为已经处理过了\n            }\n        }\n        chars = next;\n    }\n\n    for (char c : chars)\n    {\n        cout << c;\n    }\n    cout << endl;\n    return 0;\n}\n```\n\n# D\n\n> ## [Colorful Bracket Sequence](https://atcoder.jp/contests/abc394/tasks/abc394d)\n\n### code\n\n```cpp\n#include <bits/stdc++.h>\n\nusing namespace std;\n\n// 将函数定义移到 main 函数外部\nint bracketmatch(string &s1, string &s2)\n{\n    if (s1 == \"(\" && s2 == \")\")\n    {\n        return 1;\n    }\n    else if (s1 == \"[\" && s2 == \"]\")\n    {\n        return 1;\n    }\n    else if (s1 == \"{\" && s2 == \"}\")\n    {\n        return 1;\n    }\n    return 0;\n}\n\nint main()\n{\n    string bracket;\n    cin >> bracket;\n\n    stack<string> bracketstack;\n\n    for (int i = 0; i < bracket.size(); i++)\n    {\n        string current(1, bracket[i]); // 将 char 转换为 string\n\n        if (current == \"(\" || current == \"[\" || current == \"{\")\n        {\n            bracketstack.push(current);\n        }\n        else if (current == \")\" || current == \"]\" || current == \"}\")\n        {\n            if (bracketstack.empty())\n            {\n                cout << \"No\" << endl;\n                return 0;\n            }\n            if (bracketmatch(bracketstack.top(), current))\n            {\n                bracketstack.pop();\n            }\n            else\n            {\n                cout << \"No\" << endl;\n                return 0;\n            }\n        }\n    }\n\n    // 最后检查栈是否为空\n    if (!bracketstack.empty())\n    {\n        cout << \"No\" << endl;\n    }\n    else\n    {\n        cout << \"Yes\" << endl;\n    }\n\n    return 0;\n}\n```\n\n# E\n\n> ## [Palindromic Shortest Path](https://atcoder.jp/contests/abc394/tasks/abc394e)\n\n### code\n\n```cpp\n#include <bits/stdc++.h>\n// 定义一个简化的循环宏\n#define rep(i, n) for (int i = 0; i < (n); i++)\nusing namespace std;\n\n// 定义一个表示无穷大的常量\nint inf = 1000000010;\n\nint main()\n{\n    // 读入矩阵大小n\n    int n;\n    cin >> n;\n    // 创建n*n的字符矩阵c用于存储输入\n    vector<vector<char>> c(n, vector<char>(n));\n    rep(i, n) rep(j, n) cin >> c[i][j];\n    \n    // 创建n*n的距离矩阵a，初始化为无穷大\n    vector<vector<int>> a(n, vector<int>(n, inf));\n    // 创建队列用于BFS搜索\n    queue<pair<int, int>> que;\n    \n    // 对角线元素距离初始化为0\n    rep(i, n)\n    {\n        que.push({i, i});\n        a[i][i] = 0;\n    }\n    \n    // 直接相连的元素距离初始化为1\n    rep(i, n) rep(j, n)\n    {\n        if (i == j or c[i][j] == '-')\n            continue;\n        que.push({i, j});\n        a[i][j] = 1;\n    }\n    \n    // BFS搜索计算所有点对之间的最短距离\n    while (!que.empty()) // 当队列不为空时继续搜索\n    {\n        auto q = que.front(); // 获取队首元素\n        que.pop(); // 弹出队首元素\n        int i = q.**first**, j = q.**second**; // 获取当前处理的点对(i,j)的坐标\n        \n        // 遍历所有可能的新点对(k,l)\n        rep(k, n) rep(l, n) \n        {\n            // 判断是否可以通过当前点对(i,j)构建到新点对(k,l)的路径:\n            // 1. c[k][i]不是'-' - 表示k到i有边\n            // 2. c[j][l]不是'-' - 表示j到l有边\n            // 3. c[k][i] == c[j][l] - 两条边的字符相同\n            // 4. a[k][l] == inf - 点对(k,l)还未被访问过\n            if (c[k][i] != '-' && c[j][l] != '-' && c[k][i] == c[j][l] && a[k][l] == inf)\n            {\n                // 新路径的距离 = 当前点对的距离 + 2\n                // +2是因为需要经过两条新的边(k->i和j->l)\n                a[k][l] = a[i][j] + 2;\n                que.push({k, l}); // 将新的点对加入队列以继续搜索\n            }\n        }\n    }\n    \n    // 输出结果矩阵\n    rep(i, n)\n    {\n        rep(j, n)\n        {\n            // 如果距离仍为无穷大，输出-1，否则输出实际距离\n            cout << (a[i][j] == inf ? -1 : a[i][j]) << \" \\n\"[j == n - 1];\n        }\n    }\n}\n```\n\n# F\n\n> ## <u>Alkane</u>\n\n### code\n\n```cpp\n#include <bits/stdc++.h> // 包含C++标准库\n\nusing namespace std; // 使用标准命名空间\n\n#define mp makepair // 定义makepair的简写\n#define pb pushback // 定义pushback的简写\n#define fi first // 定义first的简写\n#define se second // 定义second的简写\n#define li long long // 定义long long的简写\n#define pii pair<int, int> // 定义pair<int,int>的简写\n#define vi vector<int> // 定义vector<int>的简写\n\n#define forn(i, n) for (int i = 0; i < (int)n; i++) // 定义从0到n-1的循环宏\n#define fore(i, b, e) for (int i = (int)b; i <= (int)e; i++) // 定义从b到e的循环宏\n#define all(x) (x).begin(), (x).end() // 定义容器的begin和end迭代器\n\nint ans = 0; // 存储最终答案\nvector<vi> edges; // 存储图的邻接表\nvi f; // 存储每个节点的状态值\n\nvoid dfs(int v, int p) // 深度优先搜索函数，v是当前节点，p是父节点\n{\n    for (int u : edges[v]) // 遍历当前节点的所有邻接点\n    {\n        if (u != p) // 如果邻接点不是父节点\n        {\n            dfs(u, v); // 递归处理子节点\n        }\n    }\n    f[v] = 1; // 初始化当前节点的状态值为1\n    if (edges[v].size() >= 4) // 如果当前节点的度数大于等于4\n    {\n        vi children; // 存储子节点的状态值\n        for (int u : edges[v]) // 遍历所有邻接点\n        {\n            if (u != p) // 如果不是父节点\n            {\n                children.pb(f[u]); // 添加子节点的状态值\n            }\n            else\n            {\n                children.pb(1); // 父节点贡献值为1\n            }\n        }\n        sort(all(children), greater<int>()); // 对子节点状态值降序排序\n        forn(j, 3) // 选择前3大的值\n        {\n            f[v] += children[j]; // 累加到当前节点的状态值\n        }\n        int here = 1; // 计算包含4个子节点的路径长度\n        forn(j, 4)\n        {\n            here += children[j];\n        }\n        ans = max(ans, here); // 更新最大答案\n    }\n    else if (p == -1) // 如果是根节点\n    {\n        for (int u : edges[v]) // 遍历所有子节点\n        {\n            f[v] = max(f[v], f[u] + 1); // 更新根节点状态值\n        }\n    }\n    // printf(\"f[%d] = %d edges count = %d\\n\", v, f[v], (int)edges[v].size());\n    ans = max(ans, f[v] + (p == -1 ? 0 : 1)); // 更新最大答案\n}\n\nint main()\n{\n    int n; // 节点数量\n    cin >> n;\n    edges.resize(n + 1); // 初始化邻接表大小\n    forn(i, n - 1) // 读入n-1条边\n    {\n        int u, v;\n        cin >> u >> v;\n        edges[u].pb(v); // 添加无向边\n        edges[v].pb(u);\n    }\n    f.resize(n + 1); // 初始化状态数组大小\n    dfs(1, -1); // 从节点1开始深度优先搜索\n    if (ans < 5) // 如果最大路径长度小于5\n    {\n        ans = -1; // 输出-1\n    }\n    cout << ans; // 输出答案\n}\n```\n\n# G\n\n> ## <u>Dense Buildings</u>\n\n### code\n\n```cpp\n// 包含C++标准库和atcoder的并查集库\n#include <bits/stdc++.h>\n#include <atcoder/dsu>\n\n// 使用标准命名空间和atcoder命名空间\nusing namespace std;\nusing namespace atcoder;\n\n// 定义常量\n#define H 500          // 最大高度\n#define W 500          // 最大宽度\n#define Q (int)2e+5    // 最大查询次数\n#define F (int)1e+6    // 最大权值\n\nint main(void)\n{\n    int h, w, q;                   // h,w为网格大小,q为查询次数\n    int f[H][W];                   // f[i][j]存储网格中每个位置的权值\n    int a[Q], b[Q], y[Q];          // 每个查询的起点坐标(a,b)和权值y\n    int c[Q], d[Q], z[Q];          // 每个查询的终点坐标(c,d)和权值z\n    int l[Q], r[Q];                // 二分查找的左右边界\n    vector<pair<int, int>> e[F + 1];    // e[i]存储权值为i的边\n    vector<int> check[F + 1];           // check[i]存储需要在权值i处检查的查询\n\n    // 读入网格大小\n    cin >> h >> w;\n    // 读入网格中的权值\n    for (int i = 0; i < h; i++)\n        for (int j = 0; j < w; j++)\n            cin >> f[i][j];\n    // 读入查询次数和查询信息\n    cin >> q;\n    for (int i = 0; i < q; i++)\n    {\n        cin >> a[i] >> b[i] >> y[i] >> c[i] >> d[i] >> z[i];\n        a[i]--, b[i]--, c[i]--, d[i]--;  // 坐标从0开始\n    }\n\n    // 构建边集合\n    // 添加竖直方向的边\n    for (int i = 0; i < h - 1; i++)\n        for (int j = 0; j < w; j++)\n            e[min(f[i][j], f[i + 1][j])].pushback({i * w + j, (i + 1) * w + j});\n    // 添加水平方向的边\n    for (int i = 0; i < h; i++)\n        for (int j = 0; j < w - 1; j++)\n            e[min(f[i][j], f[i][j + 1])].pushback({i * w + j, i * w + (j + 1)});\n    // 初始化二分查找的边界\n    for (int i = 0; i < q; i++)\n        l[i] = 1, r[i] = F + 1;\n\n    // 二分查找过程\n    while (true)\n    {\n        bool flag = true;\n        // 清空check数组\n        for (int i = 0; i <= F; i++)\n            check[i].clear();\n        // 对每个查询,如果二分区间未收敛,则加入check数组\n        for (int i = 0; i < q; i++)\n        {\n            if (r[i] - l[i] > 1)\n            {\n                check[(l[i] + r[i]) / 2].pushback(i);\n                flag = false;\n            }\n        }\n        if (flag) break;  // 如果所有查询都已收敛,退出循环\n\n        // 使用并查集检查连通性\n        dsu uf(h * w);\n        // 从大到小遍历权值\n        for (int i = F; i >= 0; i--)\n        {\n            // 合并权值为i的所有边\n            int sz = e[i].size();\n            for (int j = 0; j < sz; j++)\n                uf.merge(e[i][j].**first**, e[i][j].**second**);\n            // 检查需要在权值i处判断的查询\n            sz = check[i].size();\n            for (int j = 0; j < sz; j++)\n            {\n                int idxs = a[check[i][j]] * w + b[check[i][j]];  // 起点在一维数组中的索引\n                int idxt = c[check[i][j]] * w + d[check[i][j]];  // 终点在一维数组中的索引\n                // 根据连通性更新二分边界\n                if (uf.same(idxs, idxt))\n                    l[check[i][j]] = i;\n                else\n                    r[check[i][j]] = i;\n            }\n        }\n    }\n\n    // 输出每个查询的结果\n    for (int i = 0; i < q; i++)\n        cout << (y[i] + z[i] - 2 * min(l[i], min(y[i], z[i]))) << endl;\n    return 0;\n}\n```\n","slug":"2025-02-23-abc394","published":1,"updated":"2025-09-26T12:15:28.974Z","_id":"cmg0saj3w000fjm8n1xk13pnn","comments":1,"layout":"post","photos":[],"content":"<h1 id=\"Atcoder-abc394\"><a href=\"#Atcoder-abc394\" class=\"headerlink\" title=\"Atcoder abc394\"></a>Atcoder abc394</h1><h1 id=\"A\"><a href=\"#A\" class=\"headerlink\" title=\"A\"></a>A</h1><blockquote>\n<h2 id=\"22222\"><a href=\"#22222\" class=\"headerlink\" title=\"22222\"></a><a href=\"https://atcoder.jp/contests/abc394/tasks/abc394a\">22222</a></h2></blockquote>\n<h3 id=\"code\"><a href=\"#code\" class=\"headerlink\" title=\"code\"></a>code</h3><figure class=\"highlight cpp\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">#<span class=\"keyword\">include</span> <span class=\"string\">&lt;bits/stdc++.h&gt;</span></span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">using</span> <span class=\"keyword\">namespace</span> std;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"type\">int</span> <span class=\"title\">main</span><span class=\"params\">()</span></span>&#123;</span><br><span class=\"line\">    string s;</span><br><span class=\"line\">    cin &gt;&gt; s;</span><br><span class=\"line\">    <span class=\"type\">int</span> n = s.<span class=\"built_in\">size</span>();</span><br><span class=\"line\">    <span class=\"keyword\">for</span>(<span class=\"type\">int</span> i = <span class=\"number\">0</span>; i &lt; n; i++)&#123;</span><br><span class=\"line\">        <span class=\"keyword\">if</span>(s[i] == <span class=\"string\">&#x27;2&#x27;</span>)&#123;</span><br><span class=\"line\">            cout &lt;&lt; <span class=\"number\">2</span> ;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> <span class=\"number\">0</span>;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<h1 id=\"B\"><a href=\"#B\" class=\"headerlink\" title=\"B\"></a>B</h1><blockquote>\n<h2 id=\"cat\"><a href=\"#cat\" class=\"headerlink\" title=\"cat\"></a><a href=\"https://atcoder.jp/contests/abc394/tasks/abc394b\">cat</a></h2></blockquote>\n<h3 id=\"code-1\"><a href=\"#code-1\" class=\"headerlink\" title=\"code\"></a>code</h3><figure class=\"highlight cpp\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// 包含C++标准库的头文件</span></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"keyword\">include</span> <span class=\"string\">&lt;bits/stdc++.h&gt;</span></span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// 使用标准命名空间</span></span><br><span class=\"line\"><span class=\"keyword\">using</span> <span class=\"keyword\">namespace</span> std;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"type\">int</span> <span class=\"title\">main</span><span class=\"params\">()</span></span>&#123;</span><br><span class=\"line\">    <span class=\"comment\">// 声明变量n用于存储输入的字符串个数</span></span><br><span class=\"line\">    <span class=\"type\">int</span> n;</span><br><span class=\"line\">    cin &gt;&gt; n;</span><br><span class=\"line\">    <span class=\"comment\">// 创建一个大小为n的字符串向量s用于存储输入的字符串</span></span><br><span class=\"line\">    <span class=\"function\">vector&lt;string&gt; <span class=\"title\">s</span><span class=\"params\">(n)</span></span>;</span><br><span class=\"line\">    <span class=\"comment\">// 循环读入n个字符串</span></span><br><span class=\"line\">    <span class=\"keyword\">for</span>(<span class=\"type\">int</span> i = <span class=\"number\">0</span>; i &lt; n; i++)&#123;</span><br><span class=\"line\">        cin &gt;&gt; s[i];</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"comment\">// 创建一个pair向量a,用于存储字符串及其长度</span></span><br><span class=\"line\">    vector&lt;pair&lt;string,<span class=\"type\">int</span>&gt;&gt; a;</span><br><span class=\"line\">    <span class=\"comment\">// 遍历字符串向量s,将每个字符串及其长度作为pair存入向量a</span></span><br><span class=\"line\">    <span class=\"keyword\">for</span>(<span class=\"type\">int</span> i = <span class=\"number\">0</span>; i &lt; n; i++)&#123;</span><br><span class=\"line\">        a.<span class=\"built_in\">pushback</span>(<span class=\"built_in\">makepair</span>(s[i],s[i].<span class=\"built_in\">size</span>()));</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"comment\">// 使用lambda表达式对向量a按照字符串长度进行升序排序</span></span><br><span class=\"line\">    <span class=\"comment\">// sort(a.begin(), a.end(), [](const pair&lt;string,int&gt;&amp; x, const pair&lt;string,int&gt;&amp; y)&#123;</span></span><br><span class=\"line\">    <span class=\"comment\">//     return x.second &lt; y.second;</span></span><br><span class=\"line\">    <span class=\"comment\">// &#125;);</span></span><br><span class=\"line\">    <span class=\"comment\">// const 和 &amp; 是为了提高效率，可以暂时不用太关注</span></span><br><span class=\"line\">    <span class=\"built_in\">sort</span>(a.<span class=\"built_in\">begin</span>(), a.<span class=\"built_in\">end</span>(), [](pair&lt;string, <span class=\"type\">int</span>&gt; x, pair&lt;string, <span class=\"type\">int</span>&gt; y)</span><br><span class=\"line\">         &#123; <span class=\"keyword\">return</span> x.**second** &lt; y.**second**; &#125;);</span><br><span class=\"line\">    <span class=\"comment\">// 按顺序输出排序后的字符串</span></span><br><span class=\"line\">    <span class=\"keyword\">for</span>(<span class=\"type\">int</span> i = <span class=\"number\">0</span>; i &lt; n; i++)&#123;</span><br><span class=\"line\">        cout &lt;&lt; a[i].**first**;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> <span class=\"number\">0</span>;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<h1 id=\"C\"><a href=\"#C\" class=\"headerlink\" title=\"C\"></a>C</h1><blockquote>\n<h2 id=\"Debug\"><a href=\"#Debug\" class=\"headerlink\" title=\"Debug\"></a><u>Debug</u></h2></blockquote>\n<h3 id=\"code-2\"><a href=\"#code-2\" class=\"headerlink\" title=\"code\"></a>code</h3><figure class=\"highlight cpp\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">#<span class=\"keyword\">include</span> <span class=\"string\">&lt;bits/stdc++.h&gt;</span></span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">using</span> <span class=\"keyword\">namespace</span> std;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"type\">int</span> <span class=\"title\">main</span><span class=\"params\">()</span></span></span><br><span class=\"line\"><span class=\"function\"></span>&#123;</span><br><span class=\"line\">    string s;</span><br><span class=\"line\">    cin &gt;&gt; s;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"function\">vector&lt;<span class=\"type\">char</span>&gt; <span class=\"title\">chars</span><span class=\"params\">(s.begin(), s.end())</span></span>;</span><br><span class=\"line\">    <span class=\"type\">bool</span> changed = <span class=\"literal\">true</span>;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">while</span> (changed)</span><br><span class=\"line\">    &#123;</span><br><span class=\"line\">        changed = <span class=\"literal\">false</span>;</span><br><span class=\"line\">        vector&lt;<span class=\"type\">char</span>&gt; next = chars;</span><br><span class=\"line\"></span><br><span class=\"line\">        <span class=\"keyword\">for</span> (<span class=\"type\">int</span> i = <span class=\"number\">0</span>; i &lt; chars.<span class=\"built_in\">size</span>() - <span class=\"number\">1</span>; i++)</span><br><span class=\"line\">        &#123;</span><br><span class=\"line\">            <span class=\"keyword\">if</span> (next[i] == <span class=\"string\">&#x27;W&#x27;</span> &amp;&amp; next[i + <span class=\"number\">1</span>] == <span class=\"string\">&#x27;A&#x27;</span>)</span><br><span class=\"line\">            &#123;</span><br><span class=\"line\">                next[i] = <span class=\"string\">&#x27;A&#x27;</span>;</span><br><span class=\"line\">                next[i + <span class=\"number\">1</span>] = <span class=\"string\">&#x27;C&#x27;</span>;</span><br><span class=\"line\">                changed = <span class=\"literal\">true</span>;</span><br><span class=\"line\">                i++; <span class=\"comment\">// 跳过下一个字符，因为已经处理过了</span></span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        chars = next;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">for</span> (<span class=\"type\">char</span> c : chars)</span><br><span class=\"line\">    &#123;</span><br><span class=\"line\">        cout &lt;&lt; c;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    cout &lt;&lt; endl;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> <span class=\"number\">0</span>;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<h1 id=\"D\"><a href=\"#D\" class=\"headerlink\" title=\"D\"></a>D</h1><blockquote>\n<h2 id=\"Colorful-Bracket-Sequence\"><a href=\"#Colorful-Bracket-Sequence\" class=\"headerlink\" title=\"Colorful Bracket Sequence\"></a><a href=\"https://atcoder.jp/contests/abc394/tasks/abc394d\">Colorful Bracket Sequence</a></h2></blockquote>\n<h3 id=\"code-3\"><a href=\"#code-3\" class=\"headerlink\" title=\"code\"></a>code</h3><figure class=\"highlight cpp\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br><span class=\"line\">47</span><br><span class=\"line\">48</span><br><span class=\"line\">49</span><br><span class=\"line\">50</span><br><span class=\"line\">51</span><br><span class=\"line\">52</span><br><span class=\"line\">53</span><br><span class=\"line\">54</span><br><span class=\"line\">55</span><br><span class=\"line\">56</span><br><span class=\"line\">57</span><br><span class=\"line\">58</span><br><span class=\"line\">59</span><br><span class=\"line\">60</span><br><span class=\"line\">61</span><br><span class=\"line\">62</span><br><span class=\"line\">63</span><br><span class=\"line\">64</span><br><span class=\"line\">65</span><br><span class=\"line\">66</span><br><span class=\"line\">67</span><br><span class=\"line\">68</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">#<span class=\"keyword\">include</span> <span class=\"string\">&lt;bits/stdc++.h&gt;</span></span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">using</span> <span class=\"keyword\">namespace</span> std;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// 将函数定义移到 main 函数外部</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"type\">int</span> <span class=\"title\">bracketmatch</span><span class=\"params\">(string &amp;s1, string &amp;s2)</span></span></span><br><span class=\"line\"><span class=\"function\"></span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (s1 == <span class=\"string\">&quot;(&quot;</span> &amp;&amp; s2 == <span class=\"string\">&quot;)&quot;</span>)</span><br><span class=\"line\">    &#123;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> <span class=\"number\">1</span>;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"keyword\">else</span> <span class=\"keyword\">if</span> (s1 == <span class=\"string\">&quot;[&quot;</span> &amp;&amp; s2 == <span class=\"string\">&quot;]&quot;</span>)</span><br><span class=\"line\">    &#123;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> <span class=\"number\">1</span>;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"keyword\">else</span> <span class=\"keyword\">if</span> (s1 == <span class=\"string\">&quot;&#123;&quot;</span> &amp;&amp; s2 == <span class=\"string\">&quot;&#125;&quot;</span>)</span><br><span class=\"line\">    &#123;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> <span class=\"number\">1</span>;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> <span class=\"number\">0</span>;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"type\">int</span> <span class=\"title\">main</span><span class=\"params\">()</span></span></span><br><span class=\"line\"><span class=\"function\"></span>&#123;</span><br><span class=\"line\">    string bracket;</span><br><span class=\"line\">    cin &gt;&gt; bracket;</span><br><span class=\"line\"></span><br><span class=\"line\">    stack&lt;string&gt; bracketstack;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">for</span> (<span class=\"type\">int</span> i = <span class=\"number\">0</span>; i &lt; bracket.<span class=\"built_in\">size</span>(); i++)</span><br><span class=\"line\">    &#123;</span><br><span class=\"line\">        <span class=\"function\">string <span class=\"title\">current</span><span class=\"params\">(<span class=\"number\">1</span>, bracket[i])</span></span>; <span class=\"comment\">// 将 char 转换为 string</span></span><br><span class=\"line\"></span><br><span class=\"line\">        <span class=\"keyword\">if</span> (current == <span class=\"string\">&quot;(&quot;</span> || current == <span class=\"string\">&quot;[&quot;</span> || current == <span class=\"string\">&quot;&#123;&quot;</span>)</span><br><span class=\"line\">        &#123;</span><br><span class=\"line\">            bracketstack.<span class=\"built_in\">push</span>(current);</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        <span class=\"keyword\">else</span> <span class=\"keyword\">if</span> (current == <span class=\"string\">&quot;)&quot;</span> || current == <span class=\"string\">&quot;]&quot;</span> || current == <span class=\"string\">&quot;&#125;&quot;</span>)</span><br><span class=\"line\">        &#123;</span><br><span class=\"line\">            <span class=\"keyword\">if</span> (bracketstack.<span class=\"built_in\">empty</span>())</span><br><span class=\"line\">            &#123;</span><br><span class=\"line\">                cout &lt;&lt; <span class=\"string\">&quot;No&quot;</span> &lt;&lt; endl;</span><br><span class=\"line\">                <span class=\"keyword\">return</span> <span class=\"number\">0</span>;</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">            <span class=\"keyword\">if</span> (<span class=\"built_in\">bracketmatch</span>(bracketstack.<span class=\"built_in\">top</span>(), current))</span><br><span class=\"line\">            &#123;</span><br><span class=\"line\">                bracketstack.<span class=\"built_in\">pop</span>();</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">            <span class=\"keyword\">else</span></span><br><span class=\"line\">            &#123;</span><br><span class=\"line\">                cout &lt;&lt; <span class=\"string\">&quot;No&quot;</span> &lt;&lt; endl;</span><br><span class=\"line\">                <span class=\"keyword\">return</span> <span class=\"number\">0</span>;</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\">// 最后检查栈是否为空</span></span><br><span class=\"line\">    <span class=\"keyword\">if</span> (!bracketstack.<span class=\"built_in\">empty</span>())</span><br><span class=\"line\">    &#123;</span><br><span class=\"line\">        cout &lt;&lt; <span class=\"string\">&quot;No&quot;</span> &lt;&lt; endl;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"keyword\">else</span></span><br><span class=\"line\">    &#123;</span><br><span class=\"line\">        cout &lt;&lt; <span class=\"string\">&quot;Yes&quot;</span> &lt;&lt; endl;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">return</span> <span class=\"number\">0</span>;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<h1 id=\"E\"><a href=\"#E\" class=\"headerlink\" title=\"E\"></a>E</h1><blockquote>\n<h2 id=\"Palindromic-Shortest-Path\"><a href=\"#Palindromic-Shortest-Path\" class=\"headerlink\" title=\"Palindromic Shortest Path\"></a><a href=\"https://atcoder.jp/contests/abc394/tasks/abc394e\">Palindromic Shortest Path</a></h2></blockquote>\n<h3 id=\"code-4\"><a href=\"#code-4\" class=\"headerlink\" title=\"code\"></a>code</h3><figure class=\"highlight cpp\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br><span class=\"line\">47</span><br><span class=\"line\">48</span><br><span class=\"line\">49</span><br><span class=\"line\">50</span><br><span class=\"line\">51</span><br><span class=\"line\">52</span><br><span class=\"line\">53</span><br><span class=\"line\">54</span><br><span class=\"line\">55</span><br><span class=\"line\">56</span><br><span class=\"line\">57</span><br><span class=\"line\">58</span><br><span class=\"line\">59</span><br><span class=\"line\">60</span><br><span class=\"line\">61</span><br><span class=\"line\">62</span><br><span class=\"line\">63</span><br><span class=\"line\">64</span><br><span class=\"line\">65</span><br><span class=\"line\">66</span><br><span class=\"line\">67</span><br><span class=\"line\">68</span><br><span class=\"line\">69</span><br><span class=\"line\">70</span><br><span class=\"line\">71</span><br><span class=\"line\">72</span><br><span class=\"line\">73</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">#<span class=\"keyword\">include</span> <span class=\"string\">&lt;bits/stdc++.h&gt;</span></span></span><br><span class=\"line\"><span class=\"comment\">// 定义一个简化的循环宏</span></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"keyword\">define</span> rep(i, n) for (int i = 0; i &lt; (n); i++)</span></span><br><span class=\"line\"><span class=\"keyword\">using</span> <span class=\"keyword\">namespace</span> std;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// 定义一个表示无穷大的常量</span></span><br><span class=\"line\"><span class=\"type\">int</span> inf = <span class=\"number\">1000000010</span>;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"type\">int</span> <span class=\"title\">main</span><span class=\"params\">()</span></span></span><br><span class=\"line\"><span class=\"function\"></span>&#123;</span><br><span class=\"line\">    <span class=\"comment\">// 读入矩阵大小n</span></span><br><span class=\"line\">    <span class=\"type\">int</span> n;</span><br><span class=\"line\">    cin &gt;&gt; n;</span><br><span class=\"line\">    <span class=\"comment\">// 创建n*n的字符矩阵c用于存储输入</span></span><br><span class=\"line\">    vector&lt;vector&lt;<span class=\"type\">char</span>&gt;&gt; <span class=\"built_in\">c</span>(n, <span class=\"built_in\">vector</span>&lt;<span class=\"type\">char</span>&gt;(n));</span><br><span class=\"line\">    <span class=\"built_in\">rep</span>(i, n) <span class=\"built_in\">rep</span>(j, n) cin &gt;&gt; c[i][j];</span><br><span class=\"line\">    </span><br><span class=\"line\">    <span class=\"comment\">// 创建n*n的距离矩阵a，初始化为无穷大</span></span><br><span class=\"line\">    vector&lt;vector&lt;<span class=\"type\">int</span>&gt;&gt; <span class=\"built_in\">a</span>(n, <span class=\"built_in\">vector</span>&lt;<span class=\"type\">int</span>&gt;(n, inf));</span><br><span class=\"line\">    <span class=\"comment\">// 创建队列用于BFS搜索</span></span><br><span class=\"line\">    queue&lt;pair&lt;<span class=\"type\">int</span>, <span class=\"type\">int</span>&gt;&gt; que;</span><br><span class=\"line\">    </span><br><span class=\"line\">    <span class=\"comment\">// 对角线元素距离初始化为0</span></span><br><span class=\"line\">    <span class=\"built_in\">rep</span>(i, n)</span><br><span class=\"line\">    &#123;</span><br><span class=\"line\">        que.<span class=\"built_in\">push</span>(&#123;i, i&#125;);</span><br><span class=\"line\">        a[i][i] = <span class=\"number\">0</span>;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    </span><br><span class=\"line\">    <span class=\"comment\">// 直接相连的元素距离初始化为1</span></span><br><span class=\"line\">    <span class=\"built_in\">rep</span>(i, n) <span class=\"built_in\">rep</span>(j, n)</span><br><span class=\"line\">    &#123;</span><br><span class=\"line\">        <span class=\"keyword\">if</span> (i == j <span class=\"keyword\">or</span> c[i][j] == <span class=\"string\">&#x27;-&#x27;</span>)</span><br><span class=\"line\">            <span class=\"keyword\">continue</span>;</span><br><span class=\"line\">        que.<span class=\"built_in\">push</span>(&#123;i, j&#125;);</span><br><span class=\"line\">        a[i][j] = <span class=\"number\">1</span>;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    </span><br><span class=\"line\">    <span class=\"comment\">// BFS搜索计算所有点对之间的最短距离</span></span><br><span class=\"line\">    <span class=\"keyword\">while</span> (!que.<span class=\"built_in\">empty</span>()) <span class=\"comment\">// 当队列不为空时继续搜索</span></span><br><span class=\"line\">    &#123;</span><br><span class=\"line\">        <span class=\"keyword\">auto</span> q = que.<span class=\"built_in\">front</span>(); <span class=\"comment\">// 获取队首元素</span></span><br><span class=\"line\">        que.<span class=\"built_in\">pop</span>(); <span class=\"comment\">// 弹出队首元素</span></span><br><span class=\"line\">        <span class=\"type\">int</span> i = q.**first**, j = q.**second**; <span class=\"comment\">// 获取当前处理的点对(i,j)的坐标</span></span><br><span class=\"line\">        </span><br><span class=\"line\">        <span class=\"comment\">// 遍历所有可能的新点对(k,l)</span></span><br><span class=\"line\">        <span class=\"built_in\">rep</span>(k, n) <span class=\"built_in\">rep</span>(l, n) </span><br><span class=\"line\">        &#123;</span><br><span class=\"line\">            <span class=\"comment\">// 判断是否可以通过当前点对(i,j)构建到新点对(k,l)的路径:</span></span><br><span class=\"line\">            <span class=\"comment\">// 1. c[k][i]不是&#x27;-&#x27; - 表示k到i有边</span></span><br><span class=\"line\">            <span class=\"comment\">// 2. c[j][l]不是&#x27;-&#x27; - 表示j到l有边</span></span><br><span class=\"line\">            <span class=\"comment\">// 3. c[k][i] == c[j][l] - 两条边的字符相同</span></span><br><span class=\"line\">            <span class=\"comment\">// 4. a[k][l] == inf - 点对(k,l)还未被访问过</span></span><br><span class=\"line\">            <span class=\"keyword\">if</span> (c[k][i] != <span class=\"string\">&#x27;-&#x27;</span> &amp;&amp; c[j][l] != <span class=\"string\">&#x27;-&#x27;</span> &amp;&amp; c[k][i] == c[j][l] &amp;&amp; a[k][l] == inf)</span><br><span class=\"line\">            &#123;</span><br><span class=\"line\">                <span class=\"comment\">// 新路径的距离 = 当前点对的距离 + 2</span></span><br><span class=\"line\">                <span class=\"comment\">// +2是因为需要经过两条新的边(k-&gt;i和j-&gt;l)</span></span><br><span class=\"line\">                a[k][l] = a[i][j] + <span class=\"number\">2</span>;</span><br><span class=\"line\">                que.<span class=\"built_in\">push</span>(&#123;k, l&#125;); <span class=\"comment\">// 将新的点对加入队列以继续搜索</span></span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    </span><br><span class=\"line\">    <span class=\"comment\">// 输出结果矩阵</span></span><br><span class=\"line\">    <span class=\"built_in\">rep</span>(i, n)</span><br><span class=\"line\">    &#123;</span><br><span class=\"line\">        <span class=\"built_in\">rep</span>(j, n)</span><br><span class=\"line\">        &#123;</span><br><span class=\"line\">            <span class=\"comment\">// 如果距离仍为无穷大，输出-1，否则输出实际距离</span></span><br><span class=\"line\">            cout &lt;&lt; (a[i][j] == inf ? <span class=\"number\">-1</span> : a[i][j]) &lt;&lt; <span class=\"string\">&quot; \\n&quot;</span>[j == n - <span class=\"number\">1</span>];</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<h1 id=\"F\"><a href=\"#F\" class=\"headerlink\" title=\"F\"></a>F</h1><blockquote>\n<h2 id=\"Alkane\"><a href=\"#Alkane\" class=\"headerlink\" title=\"Alkane\"></a><u>Alkane</u></h2></blockquote>\n<h3 id=\"code-5\"><a href=\"#code-5\" class=\"headerlink\" title=\"code\"></a>code</h3><figure class=\"highlight cpp\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br><span class=\"line\">47</span><br><span class=\"line\">48</span><br><span class=\"line\">49</span><br><span class=\"line\">50</span><br><span class=\"line\">51</span><br><span class=\"line\">52</span><br><span class=\"line\">53</span><br><span class=\"line\">54</span><br><span class=\"line\">55</span><br><span class=\"line\">56</span><br><span class=\"line\">57</span><br><span class=\"line\">58</span><br><span class=\"line\">59</span><br><span class=\"line\">60</span><br><span class=\"line\">61</span><br><span class=\"line\">62</span><br><span class=\"line\">63</span><br><span class=\"line\">64</span><br><span class=\"line\">65</span><br><span class=\"line\">66</span><br><span class=\"line\">67</span><br><span class=\"line\">68</span><br><span class=\"line\">69</span><br><span class=\"line\">70</span><br><span class=\"line\">71</span><br><span class=\"line\">72</span><br><span class=\"line\">73</span><br><span class=\"line\">74</span><br><span class=\"line\">75</span><br><span class=\"line\">76</span><br><span class=\"line\">77</span><br><span class=\"line\">78</span><br><span class=\"line\">79</span><br><span class=\"line\">80</span><br><span class=\"line\">81</span><br><span class=\"line\">82</span><br><span class=\"line\">83</span><br><span class=\"line\">84</span><br><span class=\"line\">85</span><br><span class=\"line\">86</span><br><span class=\"line\">87</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">#<span class=\"keyword\">include</span> <span class=\"string\">&lt;bits/stdc++.h&gt;</span> <span class=\"comment\">// 包含C++标准库</span></span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">using</span> <span class=\"keyword\">namespace</span> std; <span class=\"comment\">// 使用标准命名空间</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"keyword\">define</span> mp makepair <span class=\"comment\">// 定义makepair的简写</span></span></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"keyword\">define</span> pb pushback <span class=\"comment\">// 定义pushback的简写</span></span></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"keyword\">define</span> fi first <span class=\"comment\">// 定义first的简写</span></span></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"keyword\">define</span> se second <span class=\"comment\">// 定义second的简写</span></span></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"keyword\">define</span> li long long <span class=\"comment\">// 定义long long的简写</span></span></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"keyword\">define</span> pii pair<span class=\"string\">&lt;int, int&gt;</span> <span class=\"comment\">// 定义pair&lt;int,int&gt;的简写</span></span></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"keyword\">define</span> vi vector<span class=\"string\">&lt;int&gt;</span> <span class=\"comment\">// 定义vector&lt;int&gt;的简写</span></span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"keyword\">define</span> forn(i, n) for (int i = 0; i &lt; (int)n; i++) <span class=\"comment\">// 定义从0到n-1的循环宏</span></span></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"keyword\">define</span> fore(i, b, e) for (int i = (int)b; i &lt;= (int)e; i++) <span class=\"comment\">// 定义从b到e的循环宏</span></span></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"keyword\">define</span> all(x) (x).begin(), (x).end() <span class=\"comment\">// 定义容器的begin和end迭代器</span></span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"type\">int</span> ans = <span class=\"number\">0</span>; <span class=\"comment\">// 存储最终答案</span></span><br><span class=\"line\">vector&lt;vi&gt; edges; <span class=\"comment\">// 存储图的邻接表</span></span><br><span class=\"line\">vi f; <span class=\"comment\">// 存储每个节点的状态值</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"type\">void</span> <span class=\"title\">dfs</span><span class=\"params\">(<span class=\"type\">int</span> v, <span class=\"type\">int</span> p)</span> <span class=\"comment\">// 深度优先搜索函数，v是当前节点，p是父节点</span></span></span><br><span class=\"line\"><span class=\"function\"></span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">for</span> (<span class=\"type\">int</span> u : edges[v]) <span class=\"comment\">// 遍历当前节点的所有邻接点</span></span><br><span class=\"line\">    &#123;</span><br><span class=\"line\">        <span class=\"keyword\">if</span> (u != p) <span class=\"comment\">// 如果邻接点不是父节点</span></span><br><span class=\"line\">        &#123;</span><br><span class=\"line\">            <span class=\"built_in\">dfs</span>(u, v); <span class=\"comment\">// 递归处理子节点</span></span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    f[v] = <span class=\"number\">1</span>; <span class=\"comment\">// 初始化当前节点的状态值为1</span></span><br><span class=\"line\">    <span class=\"keyword\">if</span> (edges[v].<span class=\"built_in\">size</span>() &gt;= <span class=\"number\">4</span>) <span class=\"comment\">// 如果当前节点的度数大于等于4</span></span><br><span class=\"line\">    &#123;</span><br><span class=\"line\">        vi children; <span class=\"comment\">// 存储子节点的状态值</span></span><br><span class=\"line\">        <span class=\"keyword\">for</span> (<span class=\"type\">int</span> u : edges[v]) <span class=\"comment\">// 遍历所有邻接点</span></span><br><span class=\"line\">        &#123;</span><br><span class=\"line\">            <span class=\"keyword\">if</span> (u != p) <span class=\"comment\">// 如果不是父节点</span></span><br><span class=\"line\">            &#123;</span><br><span class=\"line\">                children.<span class=\"built_in\">pb</span>(f[u]); <span class=\"comment\">// 添加子节点的状态值</span></span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">            <span class=\"keyword\">else</span></span><br><span class=\"line\">            &#123;</span><br><span class=\"line\">                children.<span class=\"built_in\">pb</span>(<span class=\"number\">1</span>); <span class=\"comment\">// 父节点贡献值为1</span></span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        <span class=\"built_in\">sort</span>(<span class=\"built_in\">all</span>(children), <span class=\"built_in\">greater</span>&lt;<span class=\"type\">int</span>&gt;()); <span class=\"comment\">// 对子节点状态值降序排序</span></span><br><span class=\"line\">        forn(j, <span class=\"number\">3</span>) <span class=\"comment\">// 选择前3大的值</span></span><br><span class=\"line\">        &#123;</span><br><span class=\"line\">            f[v] += children[j]; <span class=\"comment\">// 累加到当前节点的状态值</span></span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        <span class=\"type\">int</span> here = <span class=\"number\">1</span>; <span class=\"comment\">// 计算包含4个子节点的路径长度</span></span><br><span class=\"line\">        forn(j, <span class=\"number\">4</span>)</span><br><span class=\"line\">        &#123;</span><br><span class=\"line\">            here += children[j];</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        ans = <span class=\"built_in\">max</span>(ans, here); <span class=\"comment\">// 更新最大答案</span></span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"keyword\">else</span> <span class=\"keyword\">if</span> (p == <span class=\"number\">-1</span>) <span class=\"comment\">// 如果是根节点</span></span><br><span class=\"line\">    &#123;</span><br><span class=\"line\">        <span class=\"keyword\">for</span> (<span class=\"type\">int</span> u : edges[v]) <span class=\"comment\">// 遍历所有子节点</span></span><br><span class=\"line\">        &#123;</span><br><span class=\"line\">            f[v] = <span class=\"built_in\">max</span>(f[v], f[u] + <span class=\"number\">1</span>); <span class=\"comment\">// 更新根节点状态值</span></span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"comment\">// printf(&quot;f[%d] = %d edges count = %d\\n&quot;, v, f[v], (int)edges[v].size());</span></span><br><span class=\"line\">    ans = <span class=\"built_in\">max</span>(ans, f[v] + (p == <span class=\"number\">-1</span> ? <span class=\"number\">0</span> : <span class=\"number\">1</span>)); <span class=\"comment\">// 更新最大答案</span></span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"type\">int</span> <span class=\"title\">main</span><span class=\"params\">()</span></span></span><br><span class=\"line\"><span class=\"function\"></span>&#123;</span><br><span class=\"line\">    <span class=\"type\">int</span> n; <span class=\"comment\">// 节点数量</span></span><br><span class=\"line\">    cin &gt;&gt; n;</span><br><span class=\"line\">    edges.<span class=\"built_in\">resize</span>(n + <span class=\"number\">1</span>); <span class=\"comment\">// 初始化邻接表大小</span></span><br><span class=\"line\">    forn(i, n - <span class=\"number\">1</span>) <span class=\"comment\">// 读入n-1条边</span></span><br><span class=\"line\">    &#123;</span><br><span class=\"line\">        <span class=\"type\">int</span> u, v;</span><br><span class=\"line\">        cin &gt;&gt; u &gt;&gt; v;</span><br><span class=\"line\">        edges[u].<span class=\"built_in\">pb</span>(v); <span class=\"comment\">// 添加无向边</span></span><br><span class=\"line\">        edges[v].<span class=\"built_in\">pb</span>(u);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    f.<span class=\"built_in\">resize</span>(n + <span class=\"number\">1</span>); <span class=\"comment\">// 初始化状态数组大小</span></span><br><span class=\"line\">    <span class=\"built_in\">dfs</span>(<span class=\"number\">1</span>, <span class=\"number\">-1</span>); <span class=\"comment\">// 从节点1开始深度优先搜索</span></span><br><span class=\"line\">    <span class=\"keyword\">if</span> (ans &lt; <span class=\"number\">5</span>) <span class=\"comment\">// 如果最大路径长度小于5</span></span><br><span class=\"line\">    &#123;</span><br><span class=\"line\">        ans = <span class=\"number\">-1</span>; <span class=\"comment\">// 输出-1</span></span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    cout &lt;&lt; ans; <span class=\"comment\">// 输出答案</span></span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<h1 id=\"G\"><a href=\"#G\" class=\"headerlink\" title=\"G\"></a>G</h1><blockquote>\n<h2 id=\"Dense-Buildings\"><a href=\"#Dense-Buildings\" class=\"headerlink\" title=\"Dense Buildings\"></a><u>Dense Buildings</u></h2></blockquote>\n<h3 id=\"code-6\"><a href=\"#code-6\" class=\"headerlink\" title=\"code\"></a>code</h3><figure class=\"highlight cpp\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br><span class=\"line\">47</span><br><span class=\"line\">48</span><br><span class=\"line\">49</span><br><span class=\"line\">50</span><br><span class=\"line\">51</span><br><span class=\"line\">52</span><br><span class=\"line\">53</span><br><span class=\"line\">54</span><br><span class=\"line\">55</span><br><span class=\"line\">56</span><br><span class=\"line\">57</span><br><span class=\"line\">58</span><br><span class=\"line\">59</span><br><span class=\"line\">60</span><br><span class=\"line\">61</span><br><span class=\"line\">62</span><br><span class=\"line\">63</span><br><span class=\"line\">64</span><br><span class=\"line\">65</span><br><span class=\"line\">66</span><br><span class=\"line\">67</span><br><span class=\"line\">68</span><br><span class=\"line\">69</span><br><span class=\"line\">70</span><br><span class=\"line\">71</span><br><span class=\"line\">72</span><br><span class=\"line\">73</span><br><span class=\"line\">74</span><br><span class=\"line\">75</span><br><span class=\"line\">76</span><br><span class=\"line\">77</span><br><span class=\"line\">78</span><br><span class=\"line\">79</span><br><span class=\"line\">80</span><br><span class=\"line\">81</span><br><span class=\"line\">82</span><br><span class=\"line\">83</span><br><span class=\"line\">84</span><br><span class=\"line\">85</span><br><span class=\"line\">86</span><br><span class=\"line\">87</span><br><span class=\"line\">88</span><br><span class=\"line\">89</span><br><span class=\"line\">90</span><br><span class=\"line\">91</span><br><span class=\"line\">92</span><br><span class=\"line\">93</span><br><span class=\"line\">94</span><br><span class=\"line\">95</span><br><span class=\"line\">96</span><br><span class=\"line\">97</span><br><span class=\"line\">98</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// 包含C++标准库和atcoder的并查集库</span></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"keyword\">include</span> <span class=\"string\">&lt;bits/stdc++.h&gt;</span></span></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"keyword\">include</span> <span class=\"string\">&lt;atcoder/dsu&gt;</span></span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// 使用标准命名空间和atcoder命名空间</span></span><br><span class=\"line\"><span class=\"keyword\">using</span> <span class=\"keyword\">namespace</span> std;</span><br><span class=\"line\"><span class=\"keyword\">using</span> <span class=\"keyword\">namespace</span> atcoder;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// 定义常量</span></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"keyword\">define</span> H 500          <span class=\"comment\">// 最大高度</span></span></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"keyword\">define</span> W 500          <span class=\"comment\">// 最大宽度</span></span></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"keyword\">define</span> Q (int)2e+5    <span class=\"comment\">// 最大查询次数</span></span></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"keyword\">define</span> F (int)1e+6    <span class=\"comment\">// 最大权值</span></span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"type\">int</span> <span class=\"title\">main</span><span class=\"params\">(<span class=\"type\">void</span>)</span></span></span><br><span class=\"line\"><span class=\"function\"></span>&#123;</span><br><span class=\"line\">    <span class=\"type\">int</span> h, w, q;                   <span class=\"comment\">// h,w为网格大小,q为查询次数</span></span><br><span class=\"line\">    <span class=\"type\">int</span> f[H][W];                   <span class=\"comment\">// f[i][j]存储网格中每个位置的权值</span></span><br><span class=\"line\">    <span class=\"type\">int</span> a[Q], b[Q], y[Q];          <span class=\"comment\">// 每个查询的起点坐标(a,b)和权值y</span></span><br><span class=\"line\">    <span class=\"type\">int</span> c[Q], d[Q], z[Q];          <span class=\"comment\">// 每个查询的终点坐标(c,d)和权值z</span></span><br><span class=\"line\">    <span class=\"type\">int</span> l[Q], r[Q];                <span class=\"comment\">// 二分查找的左右边界</span></span><br><span class=\"line\">    vector&lt;pair&lt;<span class=\"type\">int</span>, <span class=\"type\">int</span>&gt;&gt; e[F + <span class=\"number\">1</span>];    <span class=\"comment\">// e[i]存储权值为i的边</span></span><br><span class=\"line\">    vector&lt;<span class=\"type\">int</span>&gt; check[F + <span class=\"number\">1</span>];           <span class=\"comment\">// check[i]存储需要在权值i处检查的查询</span></span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\">// 读入网格大小</span></span><br><span class=\"line\">    cin &gt;&gt; h &gt;&gt; w;</span><br><span class=\"line\">    <span class=\"comment\">// 读入网格中的权值</span></span><br><span class=\"line\">    <span class=\"keyword\">for</span> (<span class=\"type\">int</span> i = <span class=\"number\">0</span>; i &lt; h; i++)</span><br><span class=\"line\">        <span class=\"keyword\">for</span> (<span class=\"type\">int</span> j = <span class=\"number\">0</span>; j &lt; w; j++)</span><br><span class=\"line\">            cin &gt;&gt; f[i][j];</span><br><span class=\"line\">    <span class=\"comment\">// 读入查询次数和查询信息</span></span><br><span class=\"line\">    cin &gt;&gt; q;</span><br><span class=\"line\">    <span class=\"keyword\">for</span> (<span class=\"type\">int</span> i = <span class=\"number\">0</span>; i &lt; q; i++)</span><br><span class=\"line\">    &#123;</span><br><span class=\"line\">        cin &gt;&gt; a[i] &gt;&gt; b[i] &gt;&gt; y[i] &gt;&gt; c[i] &gt;&gt; d[i] &gt;&gt; z[i];</span><br><span class=\"line\">        a[i]--, b[i]--, c[i]--, d[i]--;  <span class=\"comment\">// 坐标从0开始</span></span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\">// 构建边集合</span></span><br><span class=\"line\">    <span class=\"comment\">// 添加竖直方向的边</span></span><br><span class=\"line\">    <span class=\"keyword\">for</span> (<span class=\"type\">int</span> i = <span class=\"number\">0</span>; i &lt; h - <span class=\"number\">1</span>; i++)</span><br><span class=\"line\">        <span class=\"keyword\">for</span> (<span class=\"type\">int</span> j = <span class=\"number\">0</span>; j &lt; w; j++)</span><br><span class=\"line\">            e[<span class=\"built_in\">min</span>(f[i][j], f[i + <span class=\"number\">1</span>][j])].<span class=\"built_in\">pushback</span>(&#123;i * w + j, (i + <span class=\"number\">1</span>) * w + j&#125;);</span><br><span class=\"line\">    <span class=\"comment\">// 添加水平方向的边</span></span><br><span class=\"line\">    <span class=\"keyword\">for</span> (<span class=\"type\">int</span> i = <span class=\"number\">0</span>; i &lt; h; i++)</span><br><span class=\"line\">        <span class=\"keyword\">for</span> (<span class=\"type\">int</span> j = <span class=\"number\">0</span>; j &lt; w - <span class=\"number\">1</span>; j++)</span><br><span class=\"line\">            e[<span class=\"built_in\">min</span>(f[i][j], f[i][j + <span class=\"number\">1</span>])].<span class=\"built_in\">pushback</span>(&#123;i * w + j, i * w + (j + <span class=\"number\">1</span>)&#125;);</span><br><span class=\"line\">    <span class=\"comment\">// 初始化二分查找的边界</span></span><br><span class=\"line\">    <span class=\"keyword\">for</span> (<span class=\"type\">int</span> i = <span class=\"number\">0</span>; i &lt; q; i++)</span><br><span class=\"line\">        l[i] = <span class=\"number\">1</span>, r[i] = F + <span class=\"number\">1</span>;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\">// 二分查找过程</span></span><br><span class=\"line\">    <span class=\"keyword\">while</span> (<span class=\"literal\">true</span>)</span><br><span class=\"line\">    &#123;</span><br><span class=\"line\">        <span class=\"type\">bool</span> flag = <span class=\"literal\">true</span>;</span><br><span class=\"line\">        <span class=\"comment\">// 清空check数组</span></span><br><span class=\"line\">        <span class=\"keyword\">for</span> (<span class=\"type\">int</span> i = <span class=\"number\">0</span>; i &lt;= F; i++)</span><br><span class=\"line\">            check[i].<span class=\"built_in\">clear</span>();</span><br><span class=\"line\">        <span class=\"comment\">// 对每个查询,如果二分区间未收敛,则加入check数组</span></span><br><span class=\"line\">        <span class=\"keyword\">for</span> (<span class=\"type\">int</span> i = <span class=\"number\">0</span>; i &lt; q; i++)</span><br><span class=\"line\">        &#123;</span><br><span class=\"line\">            <span class=\"keyword\">if</span> (r[i] - l[i] &gt; <span class=\"number\">1</span>)</span><br><span class=\"line\">            &#123;</span><br><span class=\"line\">                check[(l[i] + r[i]) / <span class=\"number\">2</span>].<span class=\"built_in\">pushback</span>(i);</span><br><span class=\"line\">                flag = <span class=\"literal\">false</span>;</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        <span class=\"keyword\">if</span> (flag) <span class=\"keyword\">break</span>;  <span class=\"comment\">// 如果所有查询都已收敛,退出循环</span></span><br><span class=\"line\"></span><br><span class=\"line\">        <span class=\"comment\">// 使用并查集检查连通性</span></span><br><span class=\"line\">        <span class=\"function\">dsu <span class=\"title\">uf</span><span class=\"params\">(h * w)</span></span>;</span><br><span class=\"line\">        <span class=\"comment\">// 从大到小遍历权值</span></span><br><span class=\"line\">        <span class=\"keyword\">for</span> (<span class=\"type\">int</span> i = F; i &gt;= <span class=\"number\">0</span>; i--)</span><br><span class=\"line\">        &#123;</span><br><span class=\"line\">            <span class=\"comment\">// 合并权值为i的所有边</span></span><br><span class=\"line\">            <span class=\"type\">int</span> sz = e[i].<span class=\"built_in\">size</span>();</span><br><span class=\"line\">            <span class=\"keyword\">for</span> (<span class=\"type\">int</span> j = <span class=\"number\">0</span>; j &lt; sz; j++)</span><br><span class=\"line\">                uf.<span class=\"built_in\">merge</span>(e[i][j].**first**, e[i][j].**second**);</span><br><span class=\"line\">            <span class=\"comment\">// 检查需要在权值i处判断的查询</span></span><br><span class=\"line\">            sz = check[i].<span class=\"built_in\">size</span>();</span><br><span class=\"line\">            <span class=\"keyword\">for</span> (<span class=\"type\">int</span> j = <span class=\"number\">0</span>; j &lt; sz; j++)</span><br><span class=\"line\">            &#123;</span><br><span class=\"line\">                <span class=\"type\">int</span> idxs = a[check[i][j]] * w + b[check[i][j]];  <span class=\"comment\">// 起点在一维数组中的索引</span></span><br><span class=\"line\">                <span class=\"type\">int</span> idxt = c[check[i][j]] * w + d[check[i][j]];  <span class=\"comment\">// 终点在一维数组中的索引</span></span><br><span class=\"line\">                <span class=\"comment\">// 根据连通性更新二分边界</span></span><br><span class=\"line\">                <span class=\"keyword\">if</span> (uf.<span class=\"built_in\">same</span>(idxs, idxt))</span><br><span class=\"line\">                    l[check[i][j]] = i;</span><br><span class=\"line\">                <span class=\"keyword\">else</span></span><br><span class=\"line\">                    r[check[i][j]] = i;</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\">// 输出每个查询的结果</span></span><br><span class=\"line\">    <span class=\"keyword\">for</span> (<span class=\"type\">int</span> i = <span class=\"number\">0</span>; i &lt; q; i++)</span><br><span class=\"line\">        cout &lt;&lt; (y[i] + z[i] - <span class=\"number\">2</span> * <span class=\"built_in\">min</span>(l[i], <span class=\"built_in\">min</span>(y[i], z[i]))) &lt;&lt; endl;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> <span class=\"number\">0</span>;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n","excerpt":"","more":"<h1 id=\"Atcoder-abc394\"><a href=\"#Atcoder-abc394\" class=\"headerlink\" title=\"Atcoder abc394\"></a>Atcoder abc394</h1><h1 id=\"A\"><a href=\"#A\" class=\"headerlink\" title=\"A\"></a>A</h1><blockquote>\n<h2 id=\"22222\"><a href=\"#22222\" class=\"headerlink\" title=\"22222\"></a><a href=\"https://atcoder.jp/contests/abc394/tasks/abc394a\">22222</a></h2></blockquote>\n<h3 id=\"code\"><a href=\"#code\" class=\"headerlink\" title=\"code\"></a>code</h3><figure class=\"highlight cpp\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">#<span class=\"keyword\">include</span> <span class=\"string\">&lt;bits/stdc++.h&gt;</span></span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">using</span> <span class=\"keyword\">namespace</span> std;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"type\">int</span> <span class=\"title\">main</span><span class=\"params\">()</span></span>&#123;</span><br><span class=\"line\">    string s;</span><br><span class=\"line\">    cin &gt;&gt; s;</span><br><span class=\"line\">    <span class=\"type\">int</span> n = s.<span class=\"built_in\">size</span>();</span><br><span class=\"line\">    <span class=\"keyword\">for</span>(<span class=\"type\">int</span> i = <span class=\"number\">0</span>; i &lt; n; i++)&#123;</span><br><span class=\"line\">        <span class=\"keyword\">if</span>(s[i] == <span class=\"string\">&#x27;2&#x27;</span>)&#123;</span><br><span class=\"line\">            cout &lt;&lt; <span class=\"number\">2</span> ;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> <span class=\"number\">0</span>;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<h1 id=\"B\"><a href=\"#B\" class=\"headerlink\" title=\"B\"></a>B</h1><blockquote>\n<h2 id=\"cat\"><a href=\"#cat\" class=\"headerlink\" title=\"cat\"></a><a href=\"https://atcoder.jp/contests/abc394/tasks/abc394b\">cat</a></h2></blockquote>\n<h3 id=\"code-1\"><a href=\"#code-1\" class=\"headerlink\" title=\"code\"></a>code</h3><figure class=\"highlight cpp\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// 包含C++标准库的头文件</span></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"keyword\">include</span> <span class=\"string\">&lt;bits/stdc++.h&gt;</span></span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// 使用标准命名空间</span></span><br><span class=\"line\"><span class=\"keyword\">using</span> <span class=\"keyword\">namespace</span> std;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"type\">int</span> <span class=\"title\">main</span><span class=\"params\">()</span></span>&#123;</span><br><span class=\"line\">    <span class=\"comment\">// 声明变量n用于存储输入的字符串个数</span></span><br><span class=\"line\">    <span class=\"type\">int</span> n;</span><br><span class=\"line\">    cin &gt;&gt; n;</span><br><span class=\"line\">    <span class=\"comment\">// 创建一个大小为n的字符串向量s用于存储输入的字符串</span></span><br><span class=\"line\">    <span class=\"function\">vector&lt;string&gt; <span class=\"title\">s</span><span class=\"params\">(n)</span></span>;</span><br><span class=\"line\">    <span class=\"comment\">// 循环读入n个字符串</span></span><br><span class=\"line\">    <span class=\"keyword\">for</span>(<span class=\"type\">int</span> i = <span class=\"number\">0</span>; i &lt; n; i++)&#123;</span><br><span class=\"line\">        cin &gt;&gt; s[i];</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"comment\">// 创建一个pair向量a,用于存储字符串及其长度</span></span><br><span class=\"line\">    vector&lt;pair&lt;string,<span class=\"type\">int</span>&gt;&gt; a;</span><br><span class=\"line\">    <span class=\"comment\">// 遍历字符串向量s,将每个字符串及其长度作为pair存入向量a</span></span><br><span class=\"line\">    <span class=\"keyword\">for</span>(<span class=\"type\">int</span> i = <span class=\"number\">0</span>; i &lt; n; i++)&#123;</span><br><span class=\"line\">        a.<span class=\"built_in\">pushback</span>(<span class=\"built_in\">makepair</span>(s[i],s[i].<span class=\"built_in\">size</span>()));</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"comment\">// 使用lambda表达式对向量a按照字符串长度进行升序排序</span></span><br><span class=\"line\">    <span class=\"comment\">// sort(a.begin(), a.end(), [](const pair&lt;string,int&gt;&amp; x, const pair&lt;string,int&gt;&amp; y)&#123;</span></span><br><span class=\"line\">    <span class=\"comment\">//     return x.second &lt; y.second;</span></span><br><span class=\"line\">    <span class=\"comment\">// &#125;);</span></span><br><span class=\"line\">    <span class=\"comment\">// const 和 &amp; 是为了提高效率，可以暂时不用太关注</span></span><br><span class=\"line\">    <span class=\"built_in\">sort</span>(a.<span class=\"built_in\">begin</span>(), a.<span class=\"built_in\">end</span>(), [](pair&lt;string, <span class=\"type\">int</span>&gt; x, pair&lt;string, <span class=\"type\">int</span>&gt; y)</span><br><span class=\"line\">         &#123; <span class=\"keyword\">return</span> x.**second** &lt; y.**second**; &#125;);</span><br><span class=\"line\">    <span class=\"comment\">// 按顺序输出排序后的字符串</span></span><br><span class=\"line\">    <span class=\"keyword\">for</span>(<span class=\"type\">int</span> i = <span class=\"number\">0</span>; i &lt; n; i++)&#123;</span><br><span class=\"line\">        cout &lt;&lt; a[i].**first**;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> <span class=\"number\">0</span>;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<h1 id=\"C\"><a href=\"#C\" class=\"headerlink\" title=\"C\"></a>C</h1><blockquote>\n<h2 id=\"Debug\"><a href=\"#Debug\" class=\"headerlink\" title=\"Debug\"></a><u>Debug</u></h2></blockquote>\n<h3 id=\"code-2\"><a href=\"#code-2\" class=\"headerlink\" title=\"code\"></a>code</h3><figure class=\"highlight cpp\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">#<span class=\"keyword\">include</span> <span class=\"string\">&lt;bits/stdc++.h&gt;</span></span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">using</span> <span class=\"keyword\">namespace</span> std;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"type\">int</span> <span class=\"title\">main</span><span class=\"params\">()</span></span></span><br><span class=\"line\"><span class=\"function\"></span>&#123;</span><br><span class=\"line\">    string s;</span><br><span class=\"line\">    cin &gt;&gt; s;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"function\">vector&lt;<span class=\"type\">char</span>&gt; <span class=\"title\">chars</span><span class=\"params\">(s.begin(), s.end())</span></span>;</span><br><span class=\"line\">    <span class=\"type\">bool</span> changed = <span class=\"literal\">true</span>;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">while</span> (changed)</span><br><span class=\"line\">    &#123;</span><br><span class=\"line\">        changed = <span class=\"literal\">false</span>;</span><br><span class=\"line\">        vector&lt;<span class=\"type\">char</span>&gt; next = chars;</span><br><span class=\"line\"></span><br><span class=\"line\">        <span class=\"keyword\">for</span> (<span class=\"type\">int</span> i = <span class=\"number\">0</span>; i &lt; chars.<span class=\"built_in\">size</span>() - <span class=\"number\">1</span>; i++)</span><br><span class=\"line\">        &#123;</span><br><span class=\"line\">            <span class=\"keyword\">if</span> (next[i] == <span class=\"string\">&#x27;W&#x27;</span> &amp;&amp; next[i + <span class=\"number\">1</span>] == <span class=\"string\">&#x27;A&#x27;</span>)</span><br><span class=\"line\">            &#123;</span><br><span class=\"line\">                next[i] = <span class=\"string\">&#x27;A&#x27;</span>;</span><br><span class=\"line\">                next[i + <span class=\"number\">1</span>] = <span class=\"string\">&#x27;C&#x27;</span>;</span><br><span class=\"line\">                changed = <span class=\"literal\">true</span>;</span><br><span class=\"line\">                i++; <span class=\"comment\">// 跳过下一个字符，因为已经处理过了</span></span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        chars = next;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">for</span> (<span class=\"type\">char</span> c : chars)</span><br><span class=\"line\">    &#123;</span><br><span class=\"line\">        cout &lt;&lt; c;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    cout &lt;&lt; endl;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> <span class=\"number\">0</span>;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<h1 id=\"D\"><a href=\"#D\" class=\"headerlink\" title=\"D\"></a>D</h1><blockquote>\n<h2 id=\"Colorful-Bracket-Sequence\"><a href=\"#Colorful-Bracket-Sequence\" class=\"headerlink\" title=\"Colorful Bracket Sequence\"></a><a href=\"https://atcoder.jp/contests/abc394/tasks/abc394d\">Colorful Bracket Sequence</a></h2></blockquote>\n<h3 id=\"code-3\"><a href=\"#code-3\" class=\"headerlink\" title=\"code\"></a>code</h3><figure class=\"highlight cpp\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br><span class=\"line\">47</span><br><span class=\"line\">48</span><br><span class=\"line\">49</span><br><span class=\"line\">50</span><br><span class=\"line\">51</span><br><span class=\"line\">52</span><br><span class=\"line\">53</span><br><span class=\"line\">54</span><br><span class=\"line\">55</span><br><span class=\"line\">56</span><br><span class=\"line\">57</span><br><span class=\"line\">58</span><br><span class=\"line\">59</span><br><span class=\"line\">60</span><br><span class=\"line\">61</span><br><span class=\"line\">62</span><br><span class=\"line\">63</span><br><span class=\"line\">64</span><br><span class=\"line\">65</span><br><span class=\"line\">66</span><br><span class=\"line\">67</span><br><span class=\"line\">68</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">#<span class=\"keyword\">include</span> <span class=\"string\">&lt;bits/stdc++.h&gt;</span></span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">using</span> <span class=\"keyword\">namespace</span> std;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// 将函数定义移到 main 函数外部</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"type\">int</span> <span class=\"title\">bracketmatch</span><span class=\"params\">(string &amp;s1, string &amp;s2)</span></span></span><br><span class=\"line\"><span class=\"function\"></span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (s1 == <span class=\"string\">&quot;(&quot;</span> &amp;&amp; s2 == <span class=\"string\">&quot;)&quot;</span>)</span><br><span class=\"line\">    &#123;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> <span class=\"number\">1</span>;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"keyword\">else</span> <span class=\"keyword\">if</span> (s1 == <span class=\"string\">&quot;[&quot;</span> &amp;&amp; s2 == <span class=\"string\">&quot;]&quot;</span>)</span><br><span class=\"line\">    &#123;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> <span class=\"number\">1</span>;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"keyword\">else</span> <span class=\"keyword\">if</span> (s1 == <span class=\"string\">&quot;&#123;&quot;</span> &amp;&amp; s2 == <span class=\"string\">&quot;&#125;&quot;</span>)</span><br><span class=\"line\">    &#123;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> <span class=\"number\">1</span>;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> <span class=\"number\">0</span>;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"type\">int</span> <span class=\"title\">main</span><span class=\"params\">()</span></span></span><br><span class=\"line\"><span class=\"function\"></span>&#123;</span><br><span class=\"line\">    string bracket;</span><br><span class=\"line\">    cin &gt;&gt; bracket;</span><br><span class=\"line\"></span><br><span class=\"line\">    stack&lt;string&gt; bracketstack;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">for</span> (<span class=\"type\">int</span> i = <span class=\"number\">0</span>; i &lt; bracket.<span class=\"built_in\">size</span>(); i++)</span><br><span class=\"line\">    &#123;</span><br><span class=\"line\">        <span class=\"function\">string <span class=\"title\">current</span><span class=\"params\">(<span class=\"number\">1</span>, bracket[i])</span></span>; <span class=\"comment\">// 将 char 转换为 string</span></span><br><span class=\"line\"></span><br><span class=\"line\">        <span class=\"keyword\">if</span> (current == <span class=\"string\">&quot;(&quot;</span> || current == <span class=\"string\">&quot;[&quot;</span> || current == <span class=\"string\">&quot;&#123;&quot;</span>)</span><br><span class=\"line\">        &#123;</span><br><span class=\"line\">            bracketstack.<span class=\"built_in\">push</span>(current);</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        <span class=\"keyword\">else</span> <span class=\"keyword\">if</span> (current == <span class=\"string\">&quot;)&quot;</span> || current == <span class=\"string\">&quot;]&quot;</span> || current == <span class=\"string\">&quot;&#125;&quot;</span>)</span><br><span class=\"line\">        &#123;</span><br><span class=\"line\">            <span class=\"keyword\">if</span> (bracketstack.<span class=\"built_in\">empty</span>())</span><br><span class=\"line\">            &#123;</span><br><span class=\"line\">                cout &lt;&lt; <span class=\"string\">&quot;No&quot;</span> &lt;&lt; endl;</span><br><span class=\"line\">                <span class=\"keyword\">return</span> <span class=\"number\">0</span>;</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">            <span class=\"keyword\">if</span> (<span class=\"built_in\">bracketmatch</span>(bracketstack.<span class=\"built_in\">top</span>(), current))</span><br><span class=\"line\">            &#123;</span><br><span class=\"line\">                bracketstack.<span class=\"built_in\">pop</span>();</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">            <span class=\"keyword\">else</span></span><br><span class=\"line\">            &#123;</span><br><span class=\"line\">                cout &lt;&lt; <span class=\"string\">&quot;No&quot;</span> &lt;&lt; endl;</span><br><span class=\"line\">                <span class=\"keyword\">return</span> <span class=\"number\">0</span>;</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\">// 最后检查栈是否为空</span></span><br><span class=\"line\">    <span class=\"keyword\">if</span> (!bracketstack.<span class=\"built_in\">empty</span>())</span><br><span class=\"line\">    &#123;</span><br><span class=\"line\">        cout &lt;&lt; <span class=\"string\">&quot;No&quot;</span> &lt;&lt; endl;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"keyword\">else</span></span><br><span class=\"line\">    &#123;</span><br><span class=\"line\">        cout &lt;&lt; <span class=\"string\">&quot;Yes&quot;</span> &lt;&lt; endl;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">return</span> <span class=\"number\">0</span>;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<h1 id=\"E\"><a href=\"#E\" class=\"headerlink\" title=\"E\"></a>E</h1><blockquote>\n<h2 id=\"Palindromic-Shortest-Path\"><a href=\"#Palindromic-Shortest-Path\" class=\"headerlink\" title=\"Palindromic Shortest Path\"></a><a href=\"https://atcoder.jp/contests/abc394/tasks/abc394e\">Palindromic Shortest Path</a></h2></blockquote>\n<h3 id=\"code-4\"><a href=\"#code-4\" class=\"headerlink\" title=\"code\"></a>code</h3><figure class=\"highlight cpp\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br><span class=\"line\">47</span><br><span class=\"line\">48</span><br><span class=\"line\">49</span><br><span class=\"line\">50</span><br><span class=\"line\">51</span><br><span class=\"line\">52</span><br><span class=\"line\">53</span><br><span class=\"line\">54</span><br><span class=\"line\">55</span><br><span class=\"line\">56</span><br><span class=\"line\">57</span><br><span class=\"line\">58</span><br><span class=\"line\">59</span><br><span class=\"line\">60</span><br><span class=\"line\">61</span><br><span class=\"line\">62</span><br><span class=\"line\">63</span><br><span class=\"line\">64</span><br><span class=\"line\">65</span><br><span class=\"line\">66</span><br><span class=\"line\">67</span><br><span class=\"line\">68</span><br><span class=\"line\">69</span><br><span class=\"line\">70</span><br><span class=\"line\">71</span><br><span class=\"line\">72</span><br><span class=\"line\">73</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">#<span class=\"keyword\">include</span> <span class=\"string\">&lt;bits/stdc++.h&gt;</span></span></span><br><span class=\"line\"><span class=\"comment\">// 定义一个简化的循环宏</span></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"keyword\">define</span> rep(i, n) for (int i = 0; i &lt; (n); i++)</span></span><br><span class=\"line\"><span class=\"keyword\">using</span> <span class=\"keyword\">namespace</span> std;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// 定义一个表示无穷大的常量</span></span><br><span class=\"line\"><span class=\"type\">int</span> inf = <span class=\"number\">1000000010</span>;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"type\">int</span> <span class=\"title\">main</span><span class=\"params\">()</span></span></span><br><span class=\"line\"><span class=\"function\"></span>&#123;</span><br><span class=\"line\">    <span class=\"comment\">// 读入矩阵大小n</span></span><br><span class=\"line\">    <span class=\"type\">int</span> n;</span><br><span class=\"line\">    cin &gt;&gt; n;</span><br><span class=\"line\">    <span class=\"comment\">// 创建n*n的字符矩阵c用于存储输入</span></span><br><span class=\"line\">    vector&lt;vector&lt;<span class=\"type\">char</span>&gt;&gt; <span class=\"built_in\">c</span>(n, <span class=\"built_in\">vector</span>&lt;<span class=\"type\">char</span>&gt;(n));</span><br><span class=\"line\">    <span class=\"built_in\">rep</span>(i, n) <span class=\"built_in\">rep</span>(j, n) cin &gt;&gt; c[i][j];</span><br><span class=\"line\">    </span><br><span class=\"line\">    <span class=\"comment\">// 创建n*n的距离矩阵a，初始化为无穷大</span></span><br><span class=\"line\">    vector&lt;vector&lt;<span class=\"type\">int</span>&gt;&gt; <span class=\"built_in\">a</span>(n, <span class=\"built_in\">vector</span>&lt;<span class=\"type\">int</span>&gt;(n, inf));</span><br><span class=\"line\">    <span class=\"comment\">// 创建队列用于BFS搜索</span></span><br><span class=\"line\">    queue&lt;pair&lt;<span class=\"type\">int</span>, <span class=\"type\">int</span>&gt;&gt; que;</span><br><span class=\"line\">    </span><br><span class=\"line\">    <span class=\"comment\">// 对角线元素距离初始化为0</span></span><br><span class=\"line\">    <span class=\"built_in\">rep</span>(i, n)</span><br><span class=\"line\">    &#123;</span><br><span class=\"line\">        que.<span class=\"built_in\">push</span>(&#123;i, i&#125;);</span><br><span class=\"line\">        a[i][i] = <span class=\"number\">0</span>;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    </span><br><span class=\"line\">    <span class=\"comment\">// 直接相连的元素距离初始化为1</span></span><br><span class=\"line\">    <span class=\"built_in\">rep</span>(i, n) <span class=\"built_in\">rep</span>(j, n)</span><br><span class=\"line\">    &#123;</span><br><span class=\"line\">        <span class=\"keyword\">if</span> (i == j <span class=\"keyword\">or</span> c[i][j] == <span class=\"string\">&#x27;-&#x27;</span>)</span><br><span class=\"line\">            <span class=\"keyword\">continue</span>;</span><br><span class=\"line\">        que.<span class=\"built_in\">push</span>(&#123;i, j&#125;);</span><br><span class=\"line\">        a[i][j] = <span class=\"number\">1</span>;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    </span><br><span class=\"line\">    <span class=\"comment\">// BFS搜索计算所有点对之间的最短距离</span></span><br><span class=\"line\">    <span class=\"keyword\">while</span> (!que.<span class=\"built_in\">empty</span>()) <span class=\"comment\">// 当队列不为空时继续搜索</span></span><br><span class=\"line\">    &#123;</span><br><span class=\"line\">        <span class=\"keyword\">auto</span> q = que.<span class=\"built_in\">front</span>(); <span class=\"comment\">// 获取队首元素</span></span><br><span class=\"line\">        que.<span class=\"built_in\">pop</span>(); <span class=\"comment\">// 弹出队首元素</span></span><br><span class=\"line\">        <span class=\"type\">int</span> i = q.**first**, j = q.**second**; <span class=\"comment\">// 获取当前处理的点对(i,j)的坐标</span></span><br><span class=\"line\">        </span><br><span class=\"line\">        <span class=\"comment\">// 遍历所有可能的新点对(k,l)</span></span><br><span class=\"line\">        <span class=\"built_in\">rep</span>(k, n) <span class=\"built_in\">rep</span>(l, n) </span><br><span class=\"line\">        &#123;</span><br><span class=\"line\">            <span class=\"comment\">// 判断是否可以通过当前点对(i,j)构建到新点对(k,l)的路径:</span></span><br><span class=\"line\">            <span class=\"comment\">// 1. c[k][i]不是&#x27;-&#x27; - 表示k到i有边</span></span><br><span class=\"line\">            <span class=\"comment\">// 2. c[j][l]不是&#x27;-&#x27; - 表示j到l有边</span></span><br><span class=\"line\">            <span class=\"comment\">// 3. c[k][i] == c[j][l] - 两条边的字符相同</span></span><br><span class=\"line\">            <span class=\"comment\">// 4. a[k][l] == inf - 点对(k,l)还未被访问过</span></span><br><span class=\"line\">            <span class=\"keyword\">if</span> (c[k][i] != <span class=\"string\">&#x27;-&#x27;</span> &amp;&amp; c[j][l] != <span class=\"string\">&#x27;-&#x27;</span> &amp;&amp; c[k][i] == c[j][l] &amp;&amp; a[k][l] == inf)</span><br><span class=\"line\">            &#123;</span><br><span class=\"line\">                <span class=\"comment\">// 新路径的距离 = 当前点对的距离 + 2</span></span><br><span class=\"line\">                <span class=\"comment\">// +2是因为需要经过两条新的边(k-&gt;i和j-&gt;l)</span></span><br><span class=\"line\">                a[k][l] = a[i][j] + <span class=\"number\">2</span>;</span><br><span class=\"line\">                que.<span class=\"built_in\">push</span>(&#123;k, l&#125;); <span class=\"comment\">// 将新的点对加入队列以继续搜索</span></span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    </span><br><span class=\"line\">    <span class=\"comment\">// 输出结果矩阵</span></span><br><span class=\"line\">    <span class=\"built_in\">rep</span>(i, n)</span><br><span class=\"line\">    &#123;</span><br><span class=\"line\">        <span class=\"built_in\">rep</span>(j, n)</span><br><span class=\"line\">        &#123;</span><br><span class=\"line\">            <span class=\"comment\">// 如果距离仍为无穷大，输出-1，否则输出实际距离</span></span><br><span class=\"line\">            cout &lt;&lt; (a[i][j] == inf ? <span class=\"number\">-1</span> : a[i][j]) &lt;&lt; <span class=\"string\">&quot; \\n&quot;</span>[j == n - <span class=\"number\">1</span>];</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<h1 id=\"F\"><a href=\"#F\" class=\"headerlink\" title=\"F\"></a>F</h1><blockquote>\n<h2 id=\"Alkane\"><a href=\"#Alkane\" class=\"headerlink\" title=\"Alkane\"></a><u>Alkane</u></h2></blockquote>\n<h3 id=\"code-5\"><a href=\"#code-5\" class=\"headerlink\" title=\"code\"></a>code</h3><figure class=\"highlight cpp\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br><span class=\"line\">47</span><br><span class=\"line\">48</span><br><span class=\"line\">49</span><br><span class=\"line\">50</span><br><span class=\"line\">51</span><br><span class=\"line\">52</span><br><span class=\"line\">53</span><br><span class=\"line\">54</span><br><span class=\"line\">55</span><br><span class=\"line\">56</span><br><span class=\"line\">57</span><br><span class=\"line\">58</span><br><span class=\"line\">59</span><br><span class=\"line\">60</span><br><span class=\"line\">61</span><br><span class=\"line\">62</span><br><span class=\"line\">63</span><br><span class=\"line\">64</span><br><span class=\"line\">65</span><br><span class=\"line\">66</span><br><span class=\"line\">67</span><br><span class=\"line\">68</span><br><span class=\"line\">69</span><br><span class=\"line\">70</span><br><span class=\"line\">71</span><br><span class=\"line\">72</span><br><span class=\"line\">73</span><br><span class=\"line\">74</span><br><span class=\"line\">75</span><br><span class=\"line\">76</span><br><span class=\"line\">77</span><br><span class=\"line\">78</span><br><span class=\"line\">79</span><br><span class=\"line\">80</span><br><span class=\"line\">81</span><br><span class=\"line\">82</span><br><span class=\"line\">83</span><br><span class=\"line\">84</span><br><span class=\"line\">85</span><br><span class=\"line\">86</span><br><span class=\"line\">87</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">#<span class=\"keyword\">include</span> <span class=\"string\">&lt;bits/stdc++.h&gt;</span> <span class=\"comment\">// 包含C++标准库</span></span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">using</span> <span class=\"keyword\">namespace</span> std; <span class=\"comment\">// 使用标准命名空间</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"keyword\">define</span> mp makepair <span class=\"comment\">// 定义makepair的简写</span></span></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"keyword\">define</span> pb pushback <span class=\"comment\">// 定义pushback的简写</span></span></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"keyword\">define</span> fi first <span class=\"comment\">// 定义first的简写</span></span></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"keyword\">define</span> se second <span class=\"comment\">// 定义second的简写</span></span></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"keyword\">define</span> li long long <span class=\"comment\">// 定义long long的简写</span></span></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"keyword\">define</span> pii pair<span class=\"string\">&lt;int, int&gt;</span> <span class=\"comment\">// 定义pair&lt;int,int&gt;的简写</span></span></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"keyword\">define</span> vi vector<span class=\"string\">&lt;int&gt;</span> <span class=\"comment\">// 定义vector&lt;int&gt;的简写</span></span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"keyword\">define</span> forn(i, n) for (int i = 0; i &lt; (int)n; i++) <span class=\"comment\">// 定义从0到n-1的循环宏</span></span></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"keyword\">define</span> fore(i, b, e) for (int i = (int)b; i &lt;= (int)e; i++) <span class=\"comment\">// 定义从b到e的循环宏</span></span></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"keyword\">define</span> all(x) (x).begin(), (x).end() <span class=\"comment\">// 定义容器的begin和end迭代器</span></span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"type\">int</span> ans = <span class=\"number\">0</span>; <span class=\"comment\">// 存储最终答案</span></span><br><span class=\"line\">vector&lt;vi&gt; edges; <span class=\"comment\">// 存储图的邻接表</span></span><br><span class=\"line\">vi f; <span class=\"comment\">// 存储每个节点的状态值</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"type\">void</span> <span class=\"title\">dfs</span><span class=\"params\">(<span class=\"type\">int</span> v, <span class=\"type\">int</span> p)</span> <span class=\"comment\">// 深度优先搜索函数，v是当前节点，p是父节点</span></span></span><br><span class=\"line\"><span class=\"function\"></span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">for</span> (<span class=\"type\">int</span> u : edges[v]) <span class=\"comment\">// 遍历当前节点的所有邻接点</span></span><br><span class=\"line\">    &#123;</span><br><span class=\"line\">        <span class=\"keyword\">if</span> (u != p) <span class=\"comment\">// 如果邻接点不是父节点</span></span><br><span class=\"line\">        &#123;</span><br><span class=\"line\">            <span class=\"built_in\">dfs</span>(u, v); <span class=\"comment\">// 递归处理子节点</span></span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    f[v] = <span class=\"number\">1</span>; <span class=\"comment\">// 初始化当前节点的状态值为1</span></span><br><span class=\"line\">    <span class=\"keyword\">if</span> (edges[v].<span class=\"built_in\">size</span>() &gt;= <span class=\"number\">4</span>) <span class=\"comment\">// 如果当前节点的度数大于等于4</span></span><br><span class=\"line\">    &#123;</span><br><span class=\"line\">        vi children; <span class=\"comment\">// 存储子节点的状态值</span></span><br><span class=\"line\">        <span class=\"keyword\">for</span> (<span class=\"type\">int</span> u : edges[v]) <span class=\"comment\">// 遍历所有邻接点</span></span><br><span class=\"line\">        &#123;</span><br><span class=\"line\">            <span class=\"keyword\">if</span> (u != p) <span class=\"comment\">// 如果不是父节点</span></span><br><span class=\"line\">            &#123;</span><br><span class=\"line\">                children.<span class=\"built_in\">pb</span>(f[u]); <span class=\"comment\">// 添加子节点的状态值</span></span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">            <span class=\"keyword\">else</span></span><br><span class=\"line\">            &#123;</span><br><span class=\"line\">                children.<span class=\"built_in\">pb</span>(<span class=\"number\">1</span>); <span class=\"comment\">// 父节点贡献值为1</span></span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        <span class=\"built_in\">sort</span>(<span class=\"built_in\">all</span>(children), <span class=\"built_in\">greater</span>&lt;<span class=\"type\">int</span>&gt;()); <span class=\"comment\">// 对子节点状态值降序排序</span></span><br><span class=\"line\">        forn(j, <span class=\"number\">3</span>) <span class=\"comment\">// 选择前3大的值</span></span><br><span class=\"line\">        &#123;</span><br><span class=\"line\">            f[v] += children[j]; <span class=\"comment\">// 累加到当前节点的状态值</span></span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        <span class=\"type\">int</span> here = <span class=\"number\">1</span>; <span class=\"comment\">// 计算包含4个子节点的路径长度</span></span><br><span class=\"line\">        forn(j, <span class=\"number\">4</span>)</span><br><span class=\"line\">        &#123;</span><br><span class=\"line\">            here += children[j];</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        ans = <span class=\"built_in\">max</span>(ans, here); <span class=\"comment\">// 更新最大答案</span></span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"keyword\">else</span> <span class=\"keyword\">if</span> (p == <span class=\"number\">-1</span>) <span class=\"comment\">// 如果是根节点</span></span><br><span class=\"line\">    &#123;</span><br><span class=\"line\">        <span class=\"keyword\">for</span> (<span class=\"type\">int</span> u : edges[v]) <span class=\"comment\">// 遍历所有子节点</span></span><br><span class=\"line\">        &#123;</span><br><span class=\"line\">            f[v] = <span class=\"built_in\">max</span>(f[v], f[u] + <span class=\"number\">1</span>); <span class=\"comment\">// 更新根节点状态值</span></span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"comment\">// printf(&quot;f[%d] = %d edges count = %d\\n&quot;, v, f[v], (int)edges[v].size());</span></span><br><span class=\"line\">    ans = <span class=\"built_in\">max</span>(ans, f[v] + (p == <span class=\"number\">-1</span> ? <span class=\"number\">0</span> : <span class=\"number\">1</span>)); <span class=\"comment\">// 更新最大答案</span></span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"type\">int</span> <span class=\"title\">main</span><span class=\"params\">()</span></span></span><br><span class=\"line\"><span class=\"function\"></span>&#123;</span><br><span class=\"line\">    <span class=\"type\">int</span> n; <span class=\"comment\">// 节点数量</span></span><br><span class=\"line\">    cin &gt;&gt; n;</span><br><span class=\"line\">    edges.<span class=\"built_in\">resize</span>(n + <span class=\"number\">1</span>); <span class=\"comment\">// 初始化邻接表大小</span></span><br><span class=\"line\">    forn(i, n - <span class=\"number\">1</span>) <span class=\"comment\">// 读入n-1条边</span></span><br><span class=\"line\">    &#123;</span><br><span class=\"line\">        <span class=\"type\">int</span> u, v;</span><br><span class=\"line\">        cin &gt;&gt; u &gt;&gt; v;</span><br><span class=\"line\">        edges[u].<span class=\"built_in\">pb</span>(v); <span class=\"comment\">// 添加无向边</span></span><br><span class=\"line\">        edges[v].<span class=\"built_in\">pb</span>(u);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    f.<span class=\"built_in\">resize</span>(n + <span class=\"number\">1</span>); <span class=\"comment\">// 初始化状态数组大小</span></span><br><span class=\"line\">    <span class=\"built_in\">dfs</span>(<span class=\"number\">1</span>, <span class=\"number\">-1</span>); <span class=\"comment\">// 从节点1开始深度优先搜索</span></span><br><span class=\"line\">    <span class=\"keyword\">if</span> (ans &lt; <span class=\"number\">5</span>) <span class=\"comment\">// 如果最大路径长度小于5</span></span><br><span class=\"line\">    &#123;</span><br><span class=\"line\">        ans = <span class=\"number\">-1</span>; <span class=\"comment\">// 输出-1</span></span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    cout &lt;&lt; ans; <span class=\"comment\">// 输出答案</span></span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<h1 id=\"G\"><a href=\"#G\" class=\"headerlink\" title=\"G\"></a>G</h1><blockquote>\n<h2 id=\"Dense-Buildings\"><a href=\"#Dense-Buildings\" class=\"headerlink\" title=\"Dense Buildings\"></a><u>Dense Buildings</u></h2></blockquote>\n<h3 id=\"code-6\"><a href=\"#code-6\" class=\"headerlink\" title=\"code\"></a>code</h3><figure class=\"highlight cpp\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br><span class=\"line\">47</span><br><span class=\"line\">48</span><br><span class=\"line\">49</span><br><span class=\"line\">50</span><br><span class=\"line\">51</span><br><span class=\"line\">52</span><br><span class=\"line\">53</span><br><span class=\"line\">54</span><br><span class=\"line\">55</span><br><span class=\"line\">56</span><br><span class=\"line\">57</span><br><span class=\"line\">58</span><br><span class=\"line\">59</span><br><span class=\"line\">60</span><br><span class=\"line\">61</span><br><span class=\"line\">62</span><br><span class=\"line\">63</span><br><span class=\"line\">64</span><br><span class=\"line\">65</span><br><span class=\"line\">66</span><br><span class=\"line\">67</span><br><span class=\"line\">68</span><br><span class=\"line\">69</span><br><span class=\"line\">70</span><br><span class=\"line\">71</span><br><span class=\"line\">72</span><br><span class=\"line\">73</span><br><span class=\"line\">74</span><br><span class=\"line\">75</span><br><span class=\"line\">76</span><br><span class=\"line\">77</span><br><span class=\"line\">78</span><br><span class=\"line\">79</span><br><span class=\"line\">80</span><br><span class=\"line\">81</span><br><span class=\"line\">82</span><br><span class=\"line\">83</span><br><span class=\"line\">84</span><br><span class=\"line\">85</span><br><span class=\"line\">86</span><br><span class=\"line\">87</span><br><span class=\"line\">88</span><br><span class=\"line\">89</span><br><span class=\"line\">90</span><br><span class=\"line\">91</span><br><span class=\"line\">92</span><br><span class=\"line\">93</span><br><span class=\"line\">94</span><br><span class=\"line\">95</span><br><span class=\"line\">96</span><br><span class=\"line\">97</span><br><span class=\"line\">98</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// 包含C++标准库和atcoder的并查集库</span></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"keyword\">include</span> <span class=\"string\">&lt;bits/stdc++.h&gt;</span></span></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"keyword\">include</span> <span class=\"string\">&lt;atcoder/dsu&gt;</span></span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// 使用标准命名空间和atcoder命名空间</span></span><br><span class=\"line\"><span class=\"keyword\">using</span> <span class=\"keyword\">namespace</span> std;</span><br><span class=\"line\"><span class=\"keyword\">using</span> <span class=\"keyword\">namespace</span> atcoder;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// 定义常量</span></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"keyword\">define</span> H 500          <span class=\"comment\">// 最大高度</span></span></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"keyword\">define</span> W 500          <span class=\"comment\">// 最大宽度</span></span></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"keyword\">define</span> Q (int)2e+5    <span class=\"comment\">// 最大查询次数</span></span></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"keyword\">define</span> F (int)1e+6    <span class=\"comment\">// 最大权值</span></span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"type\">int</span> <span class=\"title\">main</span><span class=\"params\">(<span class=\"type\">void</span>)</span></span></span><br><span class=\"line\"><span class=\"function\"></span>&#123;</span><br><span class=\"line\">    <span class=\"type\">int</span> h, w, q;                   <span class=\"comment\">// h,w为网格大小,q为查询次数</span></span><br><span class=\"line\">    <span class=\"type\">int</span> f[H][W];                   <span class=\"comment\">// f[i][j]存储网格中每个位置的权值</span></span><br><span class=\"line\">    <span class=\"type\">int</span> a[Q], b[Q], y[Q];          <span class=\"comment\">// 每个查询的起点坐标(a,b)和权值y</span></span><br><span class=\"line\">    <span class=\"type\">int</span> c[Q], d[Q], z[Q];          <span class=\"comment\">// 每个查询的终点坐标(c,d)和权值z</span></span><br><span class=\"line\">    <span class=\"type\">int</span> l[Q], r[Q];                <span class=\"comment\">// 二分查找的左右边界</span></span><br><span class=\"line\">    vector&lt;pair&lt;<span class=\"type\">int</span>, <span class=\"type\">int</span>&gt;&gt; e[F + <span class=\"number\">1</span>];    <span class=\"comment\">// e[i]存储权值为i的边</span></span><br><span class=\"line\">    vector&lt;<span class=\"type\">int</span>&gt; check[F + <span class=\"number\">1</span>];           <span class=\"comment\">// check[i]存储需要在权值i处检查的查询</span></span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\">// 读入网格大小</span></span><br><span class=\"line\">    cin &gt;&gt; h &gt;&gt; w;</span><br><span class=\"line\">    <span class=\"comment\">// 读入网格中的权值</span></span><br><span class=\"line\">    <span class=\"keyword\">for</span> (<span class=\"type\">int</span> i = <span class=\"number\">0</span>; i &lt; h; i++)</span><br><span class=\"line\">        <span class=\"keyword\">for</span> (<span class=\"type\">int</span> j = <span class=\"number\">0</span>; j &lt; w; j++)</span><br><span class=\"line\">            cin &gt;&gt; f[i][j];</span><br><span class=\"line\">    <span class=\"comment\">// 读入查询次数和查询信息</span></span><br><span class=\"line\">    cin &gt;&gt; q;</span><br><span class=\"line\">    <span class=\"keyword\">for</span> (<span class=\"type\">int</span> i = <span class=\"number\">0</span>; i &lt; q; i++)</span><br><span class=\"line\">    &#123;</span><br><span class=\"line\">        cin &gt;&gt; a[i] &gt;&gt; b[i] &gt;&gt; y[i] &gt;&gt; c[i] &gt;&gt; d[i] &gt;&gt; z[i];</span><br><span class=\"line\">        a[i]--, b[i]--, c[i]--, d[i]--;  <span class=\"comment\">// 坐标从0开始</span></span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\">// 构建边集合</span></span><br><span class=\"line\">    <span class=\"comment\">// 添加竖直方向的边</span></span><br><span class=\"line\">    <span class=\"keyword\">for</span> (<span class=\"type\">int</span> i = <span class=\"number\">0</span>; i &lt; h - <span class=\"number\">1</span>; i++)</span><br><span class=\"line\">        <span class=\"keyword\">for</span> (<span class=\"type\">int</span> j = <span class=\"number\">0</span>; j &lt; w; j++)</span><br><span class=\"line\">            e[<span class=\"built_in\">min</span>(f[i][j], f[i + <span class=\"number\">1</span>][j])].<span class=\"built_in\">pushback</span>(&#123;i * w + j, (i + <span class=\"number\">1</span>) * w + j&#125;);</span><br><span class=\"line\">    <span class=\"comment\">// 添加水平方向的边</span></span><br><span class=\"line\">    <span class=\"keyword\">for</span> (<span class=\"type\">int</span> i = <span class=\"number\">0</span>; i &lt; h; i++)</span><br><span class=\"line\">        <span class=\"keyword\">for</span> (<span class=\"type\">int</span> j = <span class=\"number\">0</span>; j &lt; w - <span class=\"number\">1</span>; j++)</span><br><span class=\"line\">            e[<span class=\"built_in\">min</span>(f[i][j], f[i][j + <span class=\"number\">1</span>])].<span class=\"built_in\">pushback</span>(&#123;i * w + j, i * w + (j + <span class=\"number\">1</span>)&#125;);</span><br><span class=\"line\">    <span class=\"comment\">// 初始化二分查找的边界</span></span><br><span class=\"line\">    <span class=\"keyword\">for</span> (<span class=\"type\">int</span> i = <span class=\"number\">0</span>; i &lt; q; i++)</span><br><span class=\"line\">        l[i] = <span class=\"number\">1</span>, r[i] = F + <span class=\"number\">1</span>;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\">// 二分查找过程</span></span><br><span class=\"line\">    <span class=\"keyword\">while</span> (<span class=\"literal\">true</span>)</span><br><span class=\"line\">    &#123;</span><br><span class=\"line\">        <span class=\"type\">bool</span> flag = <span class=\"literal\">true</span>;</span><br><span class=\"line\">        <span class=\"comment\">// 清空check数组</span></span><br><span class=\"line\">        <span class=\"keyword\">for</span> (<span class=\"type\">int</span> i = <span class=\"number\">0</span>; i &lt;= F; i++)</span><br><span class=\"line\">            check[i].<span class=\"built_in\">clear</span>();</span><br><span class=\"line\">        <span class=\"comment\">// 对每个查询,如果二分区间未收敛,则加入check数组</span></span><br><span class=\"line\">        <span class=\"keyword\">for</span> (<span class=\"type\">int</span> i = <span class=\"number\">0</span>; i &lt; q; i++)</span><br><span class=\"line\">        &#123;</span><br><span class=\"line\">            <span class=\"keyword\">if</span> (r[i] - l[i] &gt; <span class=\"number\">1</span>)</span><br><span class=\"line\">            &#123;</span><br><span class=\"line\">                check[(l[i] + r[i]) / <span class=\"number\">2</span>].<span class=\"built_in\">pushback</span>(i);</span><br><span class=\"line\">                flag = <span class=\"literal\">false</span>;</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        <span class=\"keyword\">if</span> (flag) <span class=\"keyword\">break</span>;  <span class=\"comment\">// 如果所有查询都已收敛,退出循环</span></span><br><span class=\"line\"></span><br><span class=\"line\">        <span class=\"comment\">// 使用并查集检查连通性</span></span><br><span class=\"line\">        <span class=\"function\">dsu <span class=\"title\">uf</span><span class=\"params\">(h * w)</span></span>;</span><br><span class=\"line\">        <span class=\"comment\">// 从大到小遍历权值</span></span><br><span class=\"line\">        <span class=\"keyword\">for</span> (<span class=\"type\">int</span> i = F; i &gt;= <span class=\"number\">0</span>; i--)</span><br><span class=\"line\">        &#123;</span><br><span class=\"line\">            <span class=\"comment\">// 合并权值为i的所有边</span></span><br><span class=\"line\">            <span class=\"type\">int</span> sz = e[i].<span class=\"built_in\">size</span>();</span><br><span class=\"line\">            <span class=\"keyword\">for</span> (<span class=\"type\">int</span> j = <span class=\"number\">0</span>; j &lt; sz; j++)</span><br><span class=\"line\">                uf.<span class=\"built_in\">merge</span>(e[i][j].**first**, e[i][j].**second**);</span><br><span class=\"line\">            <span class=\"comment\">// 检查需要在权值i处判断的查询</span></span><br><span class=\"line\">            sz = check[i].<span class=\"built_in\">size</span>();</span><br><span class=\"line\">            <span class=\"keyword\">for</span> (<span class=\"type\">int</span> j = <span class=\"number\">0</span>; j &lt; sz; j++)</span><br><span class=\"line\">            &#123;</span><br><span class=\"line\">                <span class=\"type\">int</span> idxs = a[check[i][j]] * w + b[check[i][j]];  <span class=\"comment\">// 起点在一维数组中的索引</span></span><br><span class=\"line\">                <span class=\"type\">int</span> idxt = c[check[i][j]] * w + d[check[i][j]];  <span class=\"comment\">// 终点在一维数组中的索引</span></span><br><span class=\"line\">                <span class=\"comment\">// 根据连通性更新二分边界</span></span><br><span class=\"line\">                <span class=\"keyword\">if</span> (uf.<span class=\"built_in\">same</span>(idxs, idxt))</span><br><span class=\"line\">                    l[check[i][j]] = i;</span><br><span class=\"line\">                <span class=\"keyword\">else</span></span><br><span class=\"line\">                    r[check[i][j]] = i;</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\">// 输出每个查询的结果</span></span><br><span class=\"line\">    <span class=\"keyword\">for</span> (<span class=\"type\">int</span> i = <span class=\"number\">0</span>; i &lt; q; i++)</span><br><span class=\"line\">        cout &lt;&lt; (y[i] + z[i] - <span class=\"number\">2</span> * <span class=\"built_in\">min</span>(l[i], <span class=\"built_in\">min</span>(y[i], z[i]))) &lt;&lt; endl;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> <span class=\"number\">0</span>;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n"},{"title":"2025-03-01-牛客周赛83","date":"2025-02-28T16:00:00.000Z","_content":"\n# 2025-02-25-牛客周赛 83\n\n> 官方题解\n> [牛客周赛 83 - 题解_牛客博客](https://blog.nowcoder.net/n/d1c25e46a4854a379e3672e71d3be671)\n\n# A [和猫猫一起起舞！](https://ac.nowcoder.com/acm/contest/102896/A)\n\n> ![1741003226383FLVIblfE0oZNGgxV74VcmrTpn9d.png](https://tk-pichost-1325224430.cos.ap-chengdu.myqcloud.com/blog/1741003226383FLVIblfE0oZNGgxV74VcmrTpn9d.png)\n\n### C++\n\n```cpp\nvoid solve(){\n    char c;\n    cin >> c;\n    if(c == 'U' or c == 'D') cout << 'L';\n    else cout << 'U';\n    cout << endl;\n    return;\n}\n```\n\n### python\n\n```python\nprint(\"L\" if input() in list(\"UD\") else \"U\")\n```\n\n# B [冒险猫猫参上！！](https://ac.nowcoder.com/acm/contest/102896/B)\n\n> ![17410034453801741003444954.png](https://tk-pichost-1325224430.cos.ap-chengdu.myqcloud.com/blog/17410034453801741003444954.png)\n\n```cpp\nvoid solve(){\n    int n;\n    cin >> n;\n    for(int i = 0; i < n; ++i){ // ++i是在循环里一个常数优化，可以不管\n        cout << i % 2 + 1 << \" \";\n    }\n    cout << endl;\n}\n```\n\n# C  [泉神，启动！！！](https://ac.nowcoder.com/acm/contest/102896/C)\n\n>![17410035073811741003507023.png](https://tk-pichost-1325224430.cos.ap-chengdu.myqcloud.com/blog/17410035073811741003507023.png)\n\n```cpp\nvoid solve(){\n    string s; cin >> s;\n    cout << (LL)(pow(10, s.length()) + 1) << endl;\n    return;\n}\n```\n\n# D [大预言家！！！！](https://ac.nowcoder.com/acm/contest/102896/D)\n\n> ![17410035273871741003527363.png](https://tk-pichost-1325224430.cos.ap-chengdu.myqcloud.com/blog/17410035273871741003527363.png)\n\n```python\ndef solve():\n    t = int(input())\n    n = int(math.ceil(math.sqrt(t)))\n    n += 1 if n % 2 == 0 else 0 # 右上角定位，强制取大于等于t秒的第一个抵达秒数是一个奇数的平方的位置\n    tmp = n * n - t\n    if tmp < n: # 上边\n        y = n // 2\n        x = (n // 2) - tmp\n    elif tmp < (2 * n - 1): # 左边\n        tmp -= n\n        x = -(n // 2)\n        y = (n // 2 - 1) - tmp\n    elif tmp < (3 * n - 2): # 下边\n        tmp -= (2 * n - 1)\n        y = -(n // 2)\n        x = -(n // 2 - 1) + tmp\n    else: # 只剩下右边\n        base = (n - 2) * (n - 2)\n        tmp = t - base\n        x = (n // 2)\n        y = (n // 2) - tmp\n    print(x, y)\n    return\n```\n\n# E [全都要！！！！！](https://ac.nowcoder.com/acm/contest/102896/E)\n\n> ![17410035633811741003563230.png](https://tk-pichost-1325224430.cos.ap-chengdu.myqcloud.com/blog/17410035633811741003563230.png)\n\n```cpp\nvoid solve(){\n    int n, k; cin >> n >> k;\n    vector<LL> a(n + 5);\n    for(int i = 1; i <= n; ++i){\n        cin >> a[i];\n    }\n    vector<vector<LL>> f(n + 5, vector<LL>(k + 5, -1145141919810)); // 魔法的数字，助您日入百亿\n    LL R = -1145141919810;\n    f[0][0] = 0;\n    for(int i = 1; i <= n; ++i){\n        for(int j = 1; j <= min(i, k); ++j){\n            for(int p = max(0, i - 6); p <= i - 1; ++p){\n                f[i][j] = max(f[i][j], f[p][j - 1] + a[i]);\n            }\n        }\n        R = max(R, f[i][k]);\n    }\n    cout << R << endl;\n}\n```\n\n# F [水题！！！！！！](https://ac.nowcoder.com/acm/contest/102896/F)\n\n> ![17410036113861741003610943.png](https://tk-pichost-1325224430.cos.ap-chengdu.myqcloud.com/blog/17410036113861741003610943.png)\n\n```cpp\nstruct Node{\n    int x, y, nowT, abi;\n    bool operator<(const Node& y) const{\n        return y.nowT < nowT;\n    }\n};\n\nvoid solve(){\n    int n, m, t;\n    cin >> n >> m >> t;\n    ++t; // 我们默认水流直接进入新节点，所以t自增比较方便。\n    vector<vector<char>> G(n + 5, vector<char>(m + 5, '^'));\n    pair<int, int> stp, enp;\n    for(int i = 1; i <= n; ++i){\n        for(int j = 1; j <= m; ++j){\n            cin >> G[i][j];\n            if(G[i][j] == '*') stp = {i, j};\n            if(G[i][j] == '%') enp = {i, j};\n        }\n    }\n    priority_queue<Node> q;\n    q.push({stp.first, stp.second, 0, 1});\n    vector<vector<bool>> vis(n + 5, vector<bool>(m + 5, 0));\n    while(!q.empty()){\n        auto [x, y, nowT, can] = q.top();\n        q.pop();\n        if(can != 1) if(vis[x][y]) continue;\n        vis[x][y] = true;\n        if(G[x][y] == '%'){ // 搜到了就直接强制终止，因为堆和模型的性质，一定是最优的之一。\n            cout << nowT << endl;\n            return;\n        }\n        if(G[x + 1][y] == '#'){\n            if(can and !vis[x + 1][y]) q.push({x + 1, y, nowT + t, 1}); // 塞\n            if(y + 1 <= m and G[x][y + 1] != '#') q.push({x, y + 1, nowT + 1, 0}); // 左右扩散判定\n            if(y - 1 >= 1 and G[x][y - 1] != '#') q.push({x, y - 1, nowT + 1, 0});\n        }else{\n            if(x + 1 <= n) q.push({x + 1, y, nowT + 1, 1}); // 垂直扩散判定\n        }\n    }\n    cout << -1 << endl;\n    return;\n}\n```\n","source":"_posts/2025-03-01-牛客周赛83.md","raw":"---\ntitle: 2025-03-01-牛客周赛83 \ndate: 2025-03-01\ntags: 算法练习\n---\n\n# 2025-02-25-牛客周赛 83\n\n> 官方题解\n> [牛客周赛 83 - 题解_牛客博客](https://blog.nowcoder.net/n/d1c25e46a4854a379e3672e71d3be671)\n\n# A [和猫猫一起起舞！](https://ac.nowcoder.com/acm/contest/102896/A)\n\n> ![1741003226383FLVIblfE0oZNGgxV74VcmrTpn9d.png](https://tk-pichost-1325224430.cos.ap-chengdu.myqcloud.com/blog/1741003226383FLVIblfE0oZNGgxV74VcmrTpn9d.png)\n\n### C++\n\n```cpp\nvoid solve(){\n    char c;\n    cin >> c;\n    if(c == 'U' or c == 'D') cout << 'L';\n    else cout << 'U';\n    cout << endl;\n    return;\n}\n```\n\n### python\n\n```python\nprint(\"L\" if input() in list(\"UD\") else \"U\")\n```\n\n# B [冒险猫猫参上！！](https://ac.nowcoder.com/acm/contest/102896/B)\n\n> ![17410034453801741003444954.png](https://tk-pichost-1325224430.cos.ap-chengdu.myqcloud.com/blog/17410034453801741003444954.png)\n\n```cpp\nvoid solve(){\n    int n;\n    cin >> n;\n    for(int i = 0; i < n; ++i){ // ++i是在循环里一个常数优化，可以不管\n        cout << i % 2 + 1 << \" \";\n    }\n    cout << endl;\n}\n```\n\n# C  [泉神，启动！！！](https://ac.nowcoder.com/acm/contest/102896/C)\n\n>![17410035073811741003507023.png](https://tk-pichost-1325224430.cos.ap-chengdu.myqcloud.com/blog/17410035073811741003507023.png)\n\n```cpp\nvoid solve(){\n    string s; cin >> s;\n    cout << (LL)(pow(10, s.length()) + 1) << endl;\n    return;\n}\n```\n\n# D [大预言家！！！！](https://ac.nowcoder.com/acm/contest/102896/D)\n\n> ![17410035273871741003527363.png](https://tk-pichost-1325224430.cos.ap-chengdu.myqcloud.com/blog/17410035273871741003527363.png)\n\n```python\ndef solve():\n    t = int(input())\n    n = int(math.ceil(math.sqrt(t)))\n    n += 1 if n % 2 == 0 else 0 # 右上角定位，强制取大于等于t秒的第一个抵达秒数是一个奇数的平方的位置\n    tmp = n * n - t\n    if tmp < n: # 上边\n        y = n // 2\n        x = (n // 2) - tmp\n    elif tmp < (2 * n - 1): # 左边\n        tmp -= n\n        x = -(n // 2)\n        y = (n // 2 - 1) - tmp\n    elif tmp < (3 * n - 2): # 下边\n        tmp -= (2 * n - 1)\n        y = -(n // 2)\n        x = -(n // 2 - 1) + tmp\n    else: # 只剩下右边\n        base = (n - 2) * (n - 2)\n        tmp = t - base\n        x = (n // 2)\n        y = (n // 2) - tmp\n    print(x, y)\n    return\n```\n\n# E [全都要！！！！！](https://ac.nowcoder.com/acm/contest/102896/E)\n\n> ![17410035633811741003563230.png](https://tk-pichost-1325224430.cos.ap-chengdu.myqcloud.com/blog/17410035633811741003563230.png)\n\n```cpp\nvoid solve(){\n    int n, k; cin >> n >> k;\n    vector<LL> a(n + 5);\n    for(int i = 1; i <= n; ++i){\n        cin >> a[i];\n    }\n    vector<vector<LL>> f(n + 5, vector<LL>(k + 5, -1145141919810)); // 魔法的数字，助您日入百亿\n    LL R = -1145141919810;\n    f[0][0] = 0;\n    for(int i = 1; i <= n; ++i){\n        for(int j = 1; j <= min(i, k); ++j){\n            for(int p = max(0, i - 6); p <= i - 1; ++p){\n                f[i][j] = max(f[i][j], f[p][j - 1] + a[i]);\n            }\n        }\n        R = max(R, f[i][k]);\n    }\n    cout << R << endl;\n}\n```\n\n# F [水题！！！！！！](https://ac.nowcoder.com/acm/contest/102896/F)\n\n> ![17410036113861741003610943.png](https://tk-pichost-1325224430.cos.ap-chengdu.myqcloud.com/blog/17410036113861741003610943.png)\n\n```cpp\nstruct Node{\n    int x, y, nowT, abi;\n    bool operator<(const Node& y) const{\n        return y.nowT < nowT;\n    }\n};\n\nvoid solve(){\n    int n, m, t;\n    cin >> n >> m >> t;\n    ++t; // 我们默认水流直接进入新节点，所以t自增比较方便。\n    vector<vector<char>> G(n + 5, vector<char>(m + 5, '^'));\n    pair<int, int> stp, enp;\n    for(int i = 1; i <= n; ++i){\n        for(int j = 1; j <= m; ++j){\n            cin >> G[i][j];\n            if(G[i][j] == '*') stp = {i, j};\n            if(G[i][j] == '%') enp = {i, j};\n        }\n    }\n    priority_queue<Node> q;\n    q.push({stp.first, stp.second, 0, 1});\n    vector<vector<bool>> vis(n + 5, vector<bool>(m + 5, 0));\n    while(!q.empty()){\n        auto [x, y, nowT, can] = q.top();\n        q.pop();\n        if(can != 1) if(vis[x][y]) continue;\n        vis[x][y] = true;\n        if(G[x][y] == '%'){ // 搜到了就直接强制终止，因为堆和模型的性质，一定是最优的之一。\n            cout << nowT << endl;\n            return;\n        }\n        if(G[x + 1][y] == '#'){\n            if(can and !vis[x + 1][y]) q.push({x + 1, y, nowT + t, 1}); // 塞\n            if(y + 1 <= m and G[x][y + 1] != '#') q.push({x, y + 1, nowT + 1, 0}); // 左右扩散判定\n            if(y - 1 >= 1 and G[x][y - 1] != '#') q.push({x, y - 1, nowT + 1, 0});\n        }else{\n            if(x + 1 <= n) q.push({x + 1, y, nowT + 1, 1}); // 垂直扩散判定\n        }\n    }\n    cout << -1 << endl;\n    return;\n}\n```\n","slug":"2025-03-01-牛客周赛83","published":1,"updated":"2025-09-26T12:15:35.385Z","_id":"cmg0saj3x000hjm8n2ky48hbg","comments":1,"layout":"post","photos":[],"content":"<h1 id=\"2025-02-25-牛客周赛-83\"><a href=\"#2025-02-25-牛客周赛-83\" class=\"headerlink\" title=\"2025-02-25-牛客周赛 83\"></a>2025-02-25-牛客周赛 83</h1><blockquote>\n<p>官方题解<br><a href=\"https://blog.nowcoder.net/n/d1c25e46a4854a379e3672e71d3be671\">牛客周赛 83 - 题解_牛客博客</a></p>\n</blockquote>\n<h1 id=\"A-和猫猫一起起舞！\"><a href=\"#A-和猫猫一起起舞！\" class=\"headerlink\" title=\"A 和猫猫一起起舞！\"></a>A <a href=\"https://ac.nowcoder.com/acm/contest/102896/A\">和猫猫一起起舞！</a></h1><blockquote>\n<p><img src=\"https://tk-pichost-1325224430.cos.ap-chengdu.myqcloud.com/blog/1741003226383FLVIblfE0oZNGgxV74VcmrTpn9d.png\" alt=\"1741003226383FLVIblfE0oZNGgxV74VcmrTpn9d.png\"></p>\n</blockquote>\n<h3 id=\"C\"><a href=\"#C\" class=\"headerlink\" title=\"C++\"></a>C++</h3><figure class=\"highlight cpp\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"type\">void</span> <span class=\"title\">solve</span><span class=\"params\">()</span></span>&#123;</span><br><span class=\"line\">    <span class=\"type\">char</span> c;</span><br><span class=\"line\">    cin &gt;&gt; c;</span><br><span class=\"line\">    <span class=\"keyword\">if</span>(c == <span class=\"string\">&#x27;U&#x27;</span> <span class=\"keyword\">or</span> c == <span class=\"string\">&#x27;D&#x27;</span>) cout &lt;&lt; <span class=\"string\">&#x27;L&#x27;</span>;</span><br><span class=\"line\">    <span class=\"keyword\">else</span> cout &lt;&lt; <span class=\"string\">&#x27;U&#x27;</span>;</span><br><span class=\"line\">    cout &lt;&lt; endl;</span><br><span class=\"line\">    <span class=\"keyword\">return</span>;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<h3 id=\"python\"><a href=\"#python\" class=\"headerlink\" title=\"python\"></a>python</h3><figure class=\"highlight python\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"built_in\">print</span>(<span class=\"string\">&quot;L&quot;</span> <span class=\"keyword\">if</span> <span class=\"built_in\">input</span>() <span class=\"keyword\">in</span> <span class=\"built_in\">list</span>(<span class=\"string\">&quot;UD&quot;</span>) <span class=\"keyword\">else</span> <span class=\"string\">&quot;U&quot;</span>)</span><br></pre></td></tr></table></figure>\n\n<h1 id=\"B-冒险猫猫参上！！\"><a href=\"#B-冒险猫猫参上！！\" class=\"headerlink\" title=\"B 冒险猫猫参上！！\"></a>B <a href=\"https://ac.nowcoder.com/acm/contest/102896/B\">冒险猫猫参上！！</a></h1><blockquote>\n<p><img src=\"https://tk-pichost-1325224430.cos.ap-chengdu.myqcloud.com/blog/17410034453801741003444954.png\" alt=\"17410034453801741003444954.png\"></p>\n</blockquote>\n<figure class=\"highlight cpp\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"type\">void</span> <span class=\"title\">solve</span><span class=\"params\">()</span></span>&#123;</span><br><span class=\"line\">    <span class=\"type\">int</span> n;</span><br><span class=\"line\">    cin &gt;&gt; n;</span><br><span class=\"line\">    <span class=\"keyword\">for</span>(<span class=\"type\">int</span> i = <span class=\"number\">0</span>; i &lt; n; ++i)&#123; <span class=\"comment\">// ++i是在循环里一个常数优化，可以不管</span></span><br><span class=\"line\">        cout &lt;&lt; i % <span class=\"number\">2</span> + <span class=\"number\">1</span> &lt;&lt; <span class=\"string\">&quot; &quot;</span>;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    cout &lt;&lt; endl;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<h1 id=\"C-泉神，启动！！！\"><a href=\"#C-泉神，启动！！！\" class=\"headerlink\" title=\"C  泉神，启动！！！\"></a>C  <a href=\"https://ac.nowcoder.com/acm/contest/102896/C\">泉神，启动！！！</a></h1><blockquote>\n<p><img src=\"https://tk-pichost-1325224430.cos.ap-chengdu.myqcloud.com/blog/17410035073811741003507023.png\" alt=\"17410035073811741003507023.png\"></p>\n</blockquote>\n<figure class=\"highlight cpp\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"type\">void</span> <span class=\"title\">solve</span><span class=\"params\">()</span></span>&#123;</span><br><span class=\"line\">    string s; cin &gt;&gt; s;</span><br><span class=\"line\">    cout &lt;&lt; (LL)(<span class=\"built_in\">pow</span>(<span class=\"number\">10</span>, s.<span class=\"built_in\">length</span>()) + <span class=\"number\">1</span>) &lt;&lt; endl;</span><br><span class=\"line\">    <span class=\"keyword\">return</span>;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<h1 id=\"D-大预言家！！！！\"><a href=\"#D-大预言家！！！！\" class=\"headerlink\" title=\"D 大预言家！！！！\"></a>D <a href=\"https://ac.nowcoder.com/acm/contest/102896/D\">大预言家！！！！</a></h1><blockquote>\n<p><img src=\"https://tk-pichost-1325224430.cos.ap-chengdu.myqcloud.com/blog/17410035273871741003527363.png\" alt=\"17410035273871741003527363.png\"></p>\n</blockquote>\n<figure class=\"highlight python\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">def</span> <span class=\"title function_\">solve</span>():</span><br><span class=\"line\">    t = <span class=\"built_in\">int</span>(<span class=\"built_in\">input</span>())</span><br><span class=\"line\">    n = <span class=\"built_in\">int</span>(math.ceil(math.sqrt(t)))</span><br><span class=\"line\">    n += <span class=\"number\">1</span> <span class=\"keyword\">if</span> n % <span class=\"number\">2</span> == <span class=\"number\">0</span> <span class=\"keyword\">else</span> <span class=\"number\">0</span> <span class=\"comment\"># 右上角定位，强制取大于等于t秒的第一个抵达秒数是一个奇数的平方的位置</span></span><br><span class=\"line\">    tmp = n * n - t</span><br><span class=\"line\">    <span class=\"keyword\">if</span> tmp &lt; n: <span class=\"comment\"># 上边</span></span><br><span class=\"line\">        y = n // <span class=\"number\">2</span></span><br><span class=\"line\">        x = (n // <span class=\"number\">2</span>) - tmp</span><br><span class=\"line\">    <span class=\"keyword\">elif</span> tmp &lt; (<span class=\"number\">2</span> * n - <span class=\"number\">1</span>): <span class=\"comment\"># 左边</span></span><br><span class=\"line\">        tmp -= n</span><br><span class=\"line\">        x = -(n // <span class=\"number\">2</span>)</span><br><span class=\"line\">        y = (n // <span class=\"number\">2</span> - <span class=\"number\">1</span>) - tmp</span><br><span class=\"line\">    <span class=\"keyword\">elif</span> tmp &lt; (<span class=\"number\">3</span> * n - <span class=\"number\">2</span>): <span class=\"comment\"># 下边</span></span><br><span class=\"line\">        tmp -= (<span class=\"number\">2</span> * n - <span class=\"number\">1</span>)</span><br><span class=\"line\">        y = -(n // <span class=\"number\">2</span>)</span><br><span class=\"line\">        x = -(n // <span class=\"number\">2</span> - <span class=\"number\">1</span>) + tmp</span><br><span class=\"line\">    <span class=\"keyword\">else</span>: <span class=\"comment\"># 只剩下右边</span></span><br><span class=\"line\">        base = (n - <span class=\"number\">2</span>) * (n - <span class=\"number\">2</span>)</span><br><span class=\"line\">        tmp = t - base</span><br><span class=\"line\">        x = (n // <span class=\"number\">2</span>)</span><br><span class=\"line\">        y = (n // <span class=\"number\">2</span>) - tmp</span><br><span class=\"line\">    <span class=\"built_in\">print</span>(x, y)</span><br><span class=\"line\">    <span class=\"keyword\">return</span></span><br></pre></td></tr></table></figure>\n\n<h1 id=\"E-全都要！！！！！\"><a href=\"#E-全都要！！！！！\" class=\"headerlink\" title=\"E 全都要！！！！！\"></a>E <a href=\"https://ac.nowcoder.com/acm/contest/102896/E\">全都要！！！！！</a></h1><blockquote>\n<p><img src=\"https://tk-pichost-1325224430.cos.ap-chengdu.myqcloud.com/blog/17410035633811741003563230.png\" alt=\"17410035633811741003563230.png\"></p>\n</blockquote>\n<figure class=\"highlight cpp\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"type\">void</span> <span class=\"title\">solve</span><span class=\"params\">()</span></span>&#123;</span><br><span class=\"line\">    <span class=\"type\">int</span> n, k; cin &gt;&gt; n &gt;&gt; k;</span><br><span class=\"line\">    <span class=\"function\">vector&lt;LL&gt; <span class=\"title\">a</span><span class=\"params\">(n + <span class=\"number\">5</span>)</span></span>;</span><br><span class=\"line\">    <span class=\"keyword\">for</span>(<span class=\"type\">int</span> i = <span class=\"number\">1</span>; i &lt;= n; ++i)&#123;</span><br><span class=\"line\">        cin &gt;&gt; a[i];</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    vector&lt;vector&lt;LL&gt;&gt; <span class=\"built_in\">f</span>(n + <span class=\"number\">5</span>, <span class=\"built_in\">vector</span>&lt;LL&gt;(k + <span class=\"number\">5</span>, <span class=\"number\">-1145141919810</span>)); <span class=\"comment\">// 魔法的数字，助您日入百亿</span></span><br><span class=\"line\">    LL R = <span class=\"number\">-1145141919810</span>;</span><br><span class=\"line\">    f[<span class=\"number\">0</span>][<span class=\"number\">0</span>] = <span class=\"number\">0</span>;</span><br><span class=\"line\">    <span class=\"keyword\">for</span>(<span class=\"type\">int</span> i = <span class=\"number\">1</span>; i &lt;= n; ++i)&#123;</span><br><span class=\"line\">        <span class=\"keyword\">for</span>(<span class=\"type\">int</span> j = <span class=\"number\">1</span>; j &lt;= <span class=\"built_in\">min</span>(i, k); ++j)&#123;</span><br><span class=\"line\">            <span class=\"keyword\">for</span>(<span class=\"type\">int</span> p = <span class=\"built_in\">max</span>(<span class=\"number\">0</span>, i - <span class=\"number\">6</span>); p &lt;= i - <span class=\"number\">1</span>; ++p)&#123;</span><br><span class=\"line\">                f[i][j] = <span class=\"built_in\">max</span>(f[i][j], f[p][j - <span class=\"number\">1</span>] + a[i]);</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        R = <span class=\"built_in\">max</span>(R, f[i][k]);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    cout &lt;&lt; R &lt;&lt; endl;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<h1 id=\"F-水题！！！！！！\"><a href=\"#F-水题！！！！！！\" class=\"headerlink\" title=\"F 水题！！！！！！\"></a>F <a href=\"https://ac.nowcoder.com/acm/contest/102896/F\">水题！！！！！！</a></h1><blockquote>\n<p><img src=\"https://tk-pichost-1325224430.cos.ap-chengdu.myqcloud.com/blog/17410036113861741003610943.png\" alt=\"17410036113861741003610943.png\"></p>\n</blockquote>\n<figure class=\"highlight cpp\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">struct</span> <span class=\"title class_\">Node</span>&#123;</span><br><span class=\"line\">    <span class=\"type\">int</span> x, y, nowT, abi;</span><br><span class=\"line\">    <span class=\"type\">bool</span> <span class=\"keyword\">operator</span>&lt;(<span class=\"type\">const</span> Node&amp; y) <span class=\"type\">const</span>&#123;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> y.nowT &lt; nowT;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"type\">void</span> <span class=\"title\">solve</span><span class=\"params\">()</span></span>&#123;</span><br><span class=\"line\">    <span class=\"type\">int</span> n, m, t;</span><br><span class=\"line\">    cin &gt;&gt; n &gt;&gt; m &gt;&gt; t;</span><br><span class=\"line\">    ++t; <span class=\"comment\">// 我们默认水流直接进入新节点，所以t自增比较方便。</span></span><br><span class=\"line\">    vector&lt;vector&lt;<span class=\"type\">char</span>&gt;&gt; <span class=\"built_in\">G</span>(n + <span class=\"number\">5</span>, <span class=\"built_in\">vector</span>&lt;<span class=\"type\">char</span>&gt;(m + <span class=\"number\">5</span>, <span class=\"string\">&#x27;^&#x27;</span>));</span><br><span class=\"line\">    pair&lt;<span class=\"type\">int</span>, <span class=\"type\">int</span>&gt; stp, enp;</span><br><span class=\"line\">    <span class=\"keyword\">for</span>(<span class=\"type\">int</span> i = <span class=\"number\">1</span>; i &lt;= n; ++i)&#123;</span><br><span class=\"line\">        <span class=\"keyword\">for</span>(<span class=\"type\">int</span> j = <span class=\"number\">1</span>; j &lt;= m; ++j)&#123;</span><br><span class=\"line\">            cin &gt;&gt; G[i][j];</span><br><span class=\"line\">            <span class=\"keyword\">if</span>(G[i][j] == <span class=\"string\">&#x27;*&#x27;</span>) stp = &#123;i, j&#125;;</span><br><span class=\"line\">            <span class=\"keyword\">if</span>(G[i][j] == <span class=\"string\">&#x27;%&#x27;</span>) enp = &#123;i, j&#125;;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    priority_queue&lt;Node&gt; q;</span><br><span class=\"line\">    q.<span class=\"built_in\">push</span>(&#123;stp.first, stp.second, <span class=\"number\">0</span>, <span class=\"number\">1</span>&#125;);</span><br><span class=\"line\">    vector&lt;vector&lt;<span class=\"type\">bool</span>&gt;&gt; <span class=\"built_in\">vis</span>(n + <span class=\"number\">5</span>, <span class=\"built_in\">vector</span>&lt;<span class=\"type\">bool</span>&gt;(m + <span class=\"number\">5</span>, <span class=\"number\">0</span>));</span><br><span class=\"line\">    <span class=\"keyword\">while</span>(!q.<span class=\"built_in\">empty</span>())&#123;</span><br><span class=\"line\">        <span class=\"keyword\">auto</span> [x, y, nowT, can] = q.<span class=\"built_in\">top</span>();</span><br><span class=\"line\">        q.<span class=\"built_in\">pop</span>();</span><br><span class=\"line\">        <span class=\"keyword\">if</span>(can != <span class=\"number\">1</span>) <span class=\"keyword\">if</span>(vis[x][y]) <span class=\"keyword\">continue</span>;</span><br><span class=\"line\">        vis[x][y] = <span class=\"literal\">true</span>;</span><br><span class=\"line\">        <span class=\"keyword\">if</span>(G[x][y] == <span class=\"string\">&#x27;%&#x27;</span>)&#123; <span class=\"comment\">// 搜到了就直接强制终止，因为堆和模型的性质，一定是最优的之一。</span></span><br><span class=\"line\">            cout &lt;&lt; nowT &lt;&lt; endl;</span><br><span class=\"line\">            <span class=\"keyword\">return</span>;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        <span class=\"keyword\">if</span>(G[x + <span class=\"number\">1</span>][y] == <span class=\"string\">&#x27;#&#x27;</span>)&#123;</span><br><span class=\"line\">            <span class=\"keyword\">if</span>(can <span class=\"keyword\">and</span> !vis[x + <span class=\"number\">1</span>][y]) q.<span class=\"built_in\">push</span>(&#123;x + <span class=\"number\">1</span>, y, nowT + t, <span class=\"number\">1</span>&#125;); <span class=\"comment\">// 塞</span></span><br><span class=\"line\">            <span class=\"keyword\">if</span>(y + <span class=\"number\">1</span> &lt;= m <span class=\"keyword\">and</span> G[x][y + <span class=\"number\">1</span>] != <span class=\"string\">&#x27;#&#x27;</span>) q.<span class=\"built_in\">push</span>(&#123;x, y + <span class=\"number\">1</span>, nowT + <span class=\"number\">1</span>, <span class=\"number\">0</span>&#125;); <span class=\"comment\">// 左右扩散判定</span></span><br><span class=\"line\">            <span class=\"keyword\">if</span>(y - <span class=\"number\">1</span> &gt;= <span class=\"number\">1</span> <span class=\"keyword\">and</span> G[x][y - <span class=\"number\">1</span>] != <span class=\"string\">&#x27;#&#x27;</span>) q.<span class=\"built_in\">push</span>(&#123;x, y - <span class=\"number\">1</span>, nowT + <span class=\"number\">1</span>, <span class=\"number\">0</span>&#125;);</span><br><span class=\"line\">        &#125;<span class=\"keyword\">else</span>&#123;</span><br><span class=\"line\">            <span class=\"keyword\">if</span>(x + <span class=\"number\">1</span> &lt;= n) q.<span class=\"built_in\">push</span>(&#123;x + <span class=\"number\">1</span>, y, nowT + <span class=\"number\">1</span>, <span class=\"number\">1</span>&#125;); <span class=\"comment\">// 垂直扩散判定</span></span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    cout &lt;&lt; <span class=\"number\">-1</span> &lt;&lt; endl;</span><br><span class=\"line\">    <span class=\"keyword\">return</span>;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n","excerpt":"","more":"<h1 id=\"2025-02-25-牛客周赛-83\"><a href=\"#2025-02-25-牛客周赛-83\" class=\"headerlink\" title=\"2025-02-25-牛客周赛 83\"></a>2025-02-25-牛客周赛 83</h1><blockquote>\n<p>官方题解<br><a href=\"https://blog.nowcoder.net/n/d1c25e46a4854a379e3672e71d3be671\">牛客周赛 83 - 题解_牛客博客</a></p>\n</blockquote>\n<h1 id=\"A-和猫猫一起起舞！\"><a href=\"#A-和猫猫一起起舞！\" class=\"headerlink\" title=\"A 和猫猫一起起舞！\"></a>A <a href=\"https://ac.nowcoder.com/acm/contest/102896/A\">和猫猫一起起舞！</a></h1><blockquote>\n<p><img src=\"https://tk-pichost-1325224430.cos.ap-chengdu.myqcloud.com/blog/1741003226383FLVIblfE0oZNGgxV74VcmrTpn9d.png\" alt=\"1741003226383FLVIblfE0oZNGgxV74VcmrTpn9d.png\"></p>\n</blockquote>\n<h3 id=\"C\"><a href=\"#C\" class=\"headerlink\" title=\"C++\"></a>C++</h3><figure class=\"highlight cpp\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"type\">void</span> <span class=\"title\">solve</span><span class=\"params\">()</span></span>&#123;</span><br><span class=\"line\">    <span class=\"type\">char</span> c;</span><br><span class=\"line\">    cin &gt;&gt; c;</span><br><span class=\"line\">    <span class=\"keyword\">if</span>(c == <span class=\"string\">&#x27;U&#x27;</span> <span class=\"keyword\">or</span> c == <span class=\"string\">&#x27;D&#x27;</span>) cout &lt;&lt; <span class=\"string\">&#x27;L&#x27;</span>;</span><br><span class=\"line\">    <span class=\"keyword\">else</span> cout &lt;&lt; <span class=\"string\">&#x27;U&#x27;</span>;</span><br><span class=\"line\">    cout &lt;&lt; endl;</span><br><span class=\"line\">    <span class=\"keyword\">return</span>;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<h3 id=\"python\"><a href=\"#python\" class=\"headerlink\" title=\"python\"></a>python</h3><figure class=\"highlight python\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"built_in\">print</span>(<span class=\"string\">&quot;L&quot;</span> <span class=\"keyword\">if</span> <span class=\"built_in\">input</span>() <span class=\"keyword\">in</span> <span class=\"built_in\">list</span>(<span class=\"string\">&quot;UD&quot;</span>) <span class=\"keyword\">else</span> <span class=\"string\">&quot;U&quot;</span>)</span><br></pre></td></tr></table></figure>\n\n<h1 id=\"B-冒险猫猫参上！！\"><a href=\"#B-冒险猫猫参上！！\" class=\"headerlink\" title=\"B 冒险猫猫参上！！\"></a>B <a href=\"https://ac.nowcoder.com/acm/contest/102896/B\">冒险猫猫参上！！</a></h1><blockquote>\n<p><img src=\"https://tk-pichost-1325224430.cos.ap-chengdu.myqcloud.com/blog/17410034453801741003444954.png\" alt=\"17410034453801741003444954.png\"></p>\n</blockquote>\n<figure class=\"highlight cpp\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"type\">void</span> <span class=\"title\">solve</span><span class=\"params\">()</span></span>&#123;</span><br><span class=\"line\">    <span class=\"type\">int</span> n;</span><br><span class=\"line\">    cin &gt;&gt; n;</span><br><span class=\"line\">    <span class=\"keyword\">for</span>(<span class=\"type\">int</span> i = <span class=\"number\">0</span>; i &lt; n; ++i)&#123; <span class=\"comment\">// ++i是在循环里一个常数优化，可以不管</span></span><br><span class=\"line\">        cout &lt;&lt; i % <span class=\"number\">2</span> + <span class=\"number\">1</span> &lt;&lt; <span class=\"string\">&quot; &quot;</span>;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    cout &lt;&lt; endl;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<h1 id=\"C-泉神，启动！！！\"><a href=\"#C-泉神，启动！！！\" class=\"headerlink\" title=\"C  泉神，启动！！！\"></a>C  <a href=\"https://ac.nowcoder.com/acm/contest/102896/C\">泉神，启动！！！</a></h1><blockquote>\n<p><img src=\"https://tk-pichost-1325224430.cos.ap-chengdu.myqcloud.com/blog/17410035073811741003507023.png\" alt=\"17410035073811741003507023.png\"></p>\n</blockquote>\n<figure class=\"highlight cpp\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"type\">void</span> <span class=\"title\">solve</span><span class=\"params\">()</span></span>&#123;</span><br><span class=\"line\">    string s; cin &gt;&gt; s;</span><br><span class=\"line\">    cout &lt;&lt; (LL)(<span class=\"built_in\">pow</span>(<span class=\"number\">10</span>, s.<span class=\"built_in\">length</span>()) + <span class=\"number\">1</span>) &lt;&lt; endl;</span><br><span class=\"line\">    <span class=\"keyword\">return</span>;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<h1 id=\"D-大预言家！！！！\"><a href=\"#D-大预言家！！！！\" class=\"headerlink\" title=\"D 大预言家！！！！\"></a>D <a href=\"https://ac.nowcoder.com/acm/contest/102896/D\">大预言家！！！！</a></h1><blockquote>\n<p><img src=\"https://tk-pichost-1325224430.cos.ap-chengdu.myqcloud.com/blog/17410035273871741003527363.png\" alt=\"17410035273871741003527363.png\"></p>\n</blockquote>\n<figure class=\"highlight python\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">def</span> <span class=\"title function_\">solve</span>():</span><br><span class=\"line\">    t = <span class=\"built_in\">int</span>(<span class=\"built_in\">input</span>())</span><br><span class=\"line\">    n = <span class=\"built_in\">int</span>(math.ceil(math.sqrt(t)))</span><br><span class=\"line\">    n += <span class=\"number\">1</span> <span class=\"keyword\">if</span> n % <span class=\"number\">2</span> == <span class=\"number\">0</span> <span class=\"keyword\">else</span> <span class=\"number\">0</span> <span class=\"comment\"># 右上角定位，强制取大于等于t秒的第一个抵达秒数是一个奇数的平方的位置</span></span><br><span class=\"line\">    tmp = n * n - t</span><br><span class=\"line\">    <span class=\"keyword\">if</span> tmp &lt; n: <span class=\"comment\"># 上边</span></span><br><span class=\"line\">        y = n // <span class=\"number\">2</span></span><br><span class=\"line\">        x = (n // <span class=\"number\">2</span>) - tmp</span><br><span class=\"line\">    <span class=\"keyword\">elif</span> tmp &lt; (<span class=\"number\">2</span> * n - <span class=\"number\">1</span>): <span class=\"comment\"># 左边</span></span><br><span class=\"line\">        tmp -= n</span><br><span class=\"line\">        x = -(n // <span class=\"number\">2</span>)</span><br><span class=\"line\">        y = (n // <span class=\"number\">2</span> - <span class=\"number\">1</span>) - tmp</span><br><span class=\"line\">    <span class=\"keyword\">elif</span> tmp &lt; (<span class=\"number\">3</span> * n - <span class=\"number\">2</span>): <span class=\"comment\"># 下边</span></span><br><span class=\"line\">        tmp -= (<span class=\"number\">2</span> * n - <span class=\"number\">1</span>)</span><br><span class=\"line\">        y = -(n // <span class=\"number\">2</span>)</span><br><span class=\"line\">        x = -(n // <span class=\"number\">2</span> - <span class=\"number\">1</span>) + tmp</span><br><span class=\"line\">    <span class=\"keyword\">else</span>: <span class=\"comment\"># 只剩下右边</span></span><br><span class=\"line\">        base = (n - <span class=\"number\">2</span>) * (n - <span class=\"number\">2</span>)</span><br><span class=\"line\">        tmp = t - base</span><br><span class=\"line\">        x = (n // <span class=\"number\">2</span>)</span><br><span class=\"line\">        y = (n // <span class=\"number\">2</span>) - tmp</span><br><span class=\"line\">    <span class=\"built_in\">print</span>(x, y)</span><br><span class=\"line\">    <span class=\"keyword\">return</span></span><br></pre></td></tr></table></figure>\n\n<h1 id=\"E-全都要！！！！！\"><a href=\"#E-全都要！！！！！\" class=\"headerlink\" title=\"E 全都要！！！！！\"></a>E <a href=\"https://ac.nowcoder.com/acm/contest/102896/E\">全都要！！！！！</a></h1><blockquote>\n<p><img src=\"https://tk-pichost-1325224430.cos.ap-chengdu.myqcloud.com/blog/17410035633811741003563230.png\" alt=\"17410035633811741003563230.png\"></p>\n</blockquote>\n<figure class=\"highlight cpp\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"type\">void</span> <span class=\"title\">solve</span><span class=\"params\">()</span></span>&#123;</span><br><span class=\"line\">    <span class=\"type\">int</span> n, k; cin &gt;&gt; n &gt;&gt; k;</span><br><span class=\"line\">    <span class=\"function\">vector&lt;LL&gt; <span class=\"title\">a</span><span class=\"params\">(n + <span class=\"number\">5</span>)</span></span>;</span><br><span class=\"line\">    <span class=\"keyword\">for</span>(<span class=\"type\">int</span> i = <span class=\"number\">1</span>; i &lt;= n; ++i)&#123;</span><br><span class=\"line\">        cin &gt;&gt; a[i];</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    vector&lt;vector&lt;LL&gt;&gt; <span class=\"built_in\">f</span>(n + <span class=\"number\">5</span>, <span class=\"built_in\">vector</span>&lt;LL&gt;(k + <span class=\"number\">5</span>, <span class=\"number\">-1145141919810</span>)); <span class=\"comment\">// 魔法的数字，助您日入百亿</span></span><br><span class=\"line\">    LL R = <span class=\"number\">-1145141919810</span>;</span><br><span class=\"line\">    f[<span class=\"number\">0</span>][<span class=\"number\">0</span>] = <span class=\"number\">0</span>;</span><br><span class=\"line\">    <span class=\"keyword\">for</span>(<span class=\"type\">int</span> i = <span class=\"number\">1</span>; i &lt;= n; ++i)&#123;</span><br><span class=\"line\">        <span class=\"keyword\">for</span>(<span class=\"type\">int</span> j = <span class=\"number\">1</span>; j &lt;= <span class=\"built_in\">min</span>(i, k); ++j)&#123;</span><br><span class=\"line\">            <span class=\"keyword\">for</span>(<span class=\"type\">int</span> p = <span class=\"built_in\">max</span>(<span class=\"number\">0</span>, i - <span class=\"number\">6</span>); p &lt;= i - <span class=\"number\">1</span>; ++p)&#123;</span><br><span class=\"line\">                f[i][j] = <span class=\"built_in\">max</span>(f[i][j], f[p][j - <span class=\"number\">1</span>] + a[i]);</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        R = <span class=\"built_in\">max</span>(R, f[i][k]);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    cout &lt;&lt; R &lt;&lt; endl;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<h1 id=\"F-水题！！！！！！\"><a href=\"#F-水题！！！！！！\" class=\"headerlink\" title=\"F 水题！！！！！！\"></a>F <a href=\"https://ac.nowcoder.com/acm/contest/102896/F\">水题！！！！！！</a></h1><blockquote>\n<p><img src=\"https://tk-pichost-1325224430.cos.ap-chengdu.myqcloud.com/blog/17410036113861741003610943.png\" alt=\"17410036113861741003610943.png\"></p>\n</blockquote>\n<figure class=\"highlight cpp\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">struct</span> <span class=\"title class_\">Node</span>&#123;</span><br><span class=\"line\">    <span class=\"type\">int</span> x, y, nowT, abi;</span><br><span class=\"line\">    <span class=\"type\">bool</span> <span class=\"keyword\">operator</span>&lt;(<span class=\"type\">const</span> Node&amp; y) <span class=\"type\">const</span>&#123;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> y.nowT &lt; nowT;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"type\">void</span> <span class=\"title\">solve</span><span class=\"params\">()</span></span>&#123;</span><br><span class=\"line\">    <span class=\"type\">int</span> n, m, t;</span><br><span class=\"line\">    cin &gt;&gt; n &gt;&gt; m &gt;&gt; t;</span><br><span class=\"line\">    ++t; <span class=\"comment\">// 我们默认水流直接进入新节点，所以t自增比较方便。</span></span><br><span class=\"line\">    vector&lt;vector&lt;<span class=\"type\">char</span>&gt;&gt; <span class=\"built_in\">G</span>(n + <span class=\"number\">5</span>, <span class=\"built_in\">vector</span>&lt;<span class=\"type\">char</span>&gt;(m + <span class=\"number\">5</span>, <span class=\"string\">&#x27;^&#x27;</span>));</span><br><span class=\"line\">    pair&lt;<span class=\"type\">int</span>, <span class=\"type\">int</span>&gt; stp, enp;</span><br><span class=\"line\">    <span class=\"keyword\">for</span>(<span class=\"type\">int</span> i = <span class=\"number\">1</span>; i &lt;= n; ++i)&#123;</span><br><span class=\"line\">        <span class=\"keyword\">for</span>(<span class=\"type\">int</span> j = <span class=\"number\">1</span>; j &lt;= m; ++j)&#123;</span><br><span class=\"line\">            cin &gt;&gt; G[i][j];</span><br><span class=\"line\">            <span class=\"keyword\">if</span>(G[i][j] == <span class=\"string\">&#x27;*&#x27;</span>) stp = &#123;i, j&#125;;</span><br><span class=\"line\">            <span class=\"keyword\">if</span>(G[i][j] == <span class=\"string\">&#x27;%&#x27;</span>) enp = &#123;i, j&#125;;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    priority_queue&lt;Node&gt; q;</span><br><span class=\"line\">    q.<span class=\"built_in\">push</span>(&#123;stp.first, stp.second, <span class=\"number\">0</span>, <span class=\"number\">1</span>&#125;);</span><br><span class=\"line\">    vector&lt;vector&lt;<span class=\"type\">bool</span>&gt;&gt; <span class=\"built_in\">vis</span>(n + <span class=\"number\">5</span>, <span class=\"built_in\">vector</span>&lt;<span class=\"type\">bool</span>&gt;(m + <span class=\"number\">5</span>, <span class=\"number\">0</span>));</span><br><span class=\"line\">    <span class=\"keyword\">while</span>(!q.<span class=\"built_in\">empty</span>())&#123;</span><br><span class=\"line\">        <span class=\"keyword\">auto</span> [x, y, nowT, can] = q.<span class=\"built_in\">top</span>();</span><br><span class=\"line\">        q.<span class=\"built_in\">pop</span>();</span><br><span class=\"line\">        <span class=\"keyword\">if</span>(can != <span class=\"number\">1</span>) <span class=\"keyword\">if</span>(vis[x][y]) <span class=\"keyword\">continue</span>;</span><br><span class=\"line\">        vis[x][y] = <span class=\"literal\">true</span>;</span><br><span class=\"line\">        <span class=\"keyword\">if</span>(G[x][y] == <span class=\"string\">&#x27;%&#x27;</span>)&#123; <span class=\"comment\">// 搜到了就直接强制终止，因为堆和模型的性质，一定是最优的之一。</span></span><br><span class=\"line\">            cout &lt;&lt; nowT &lt;&lt; endl;</span><br><span class=\"line\">            <span class=\"keyword\">return</span>;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        <span class=\"keyword\">if</span>(G[x + <span class=\"number\">1</span>][y] == <span class=\"string\">&#x27;#&#x27;</span>)&#123;</span><br><span class=\"line\">            <span class=\"keyword\">if</span>(can <span class=\"keyword\">and</span> !vis[x + <span class=\"number\">1</span>][y]) q.<span class=\"built_in\">push</span>(&#123;x + <span class=\"number\">1</span>, y, nowT + t, <span class=\"number\">1</span>&#125;); <span class=\"comment\">// 塞</span></span><br><span class=\"line\">            <span class=\"keyword\">if</span>(y + <span class=\"number\">1</span> &lt;= m <span class=\"keyword\">and</span> G[x][y + <span class=\"number\">1</span>] != <span class=\"string\">&#x27;#&#x27;</span>) q.<span class=\"built_in\">push</span>(&#123;x, y + <span class=\"number\">1</span>, nowT + <span class=\"number\">1</span>, <span class=\"number\">0</span>&#125;); <span class=\"comment\">// 左右扩散判定</span></span><br><span class=\"line\">            <span class=\"keyword\">if</span>(y - <span class=\"number\">1</span> &gt;= <span class=\"number\">1</span> <span class=\"keyword\">and</span> G[x][y - <span class=\"number\">1</span>] != <span class=\"string\">&#x27;#&#x27;</span>) q.<span class=\"built_in\">push</span>(&#123;x, y - <span class=\"number\">1</span>, nowT + <span class=\"number\">1</span>, <span class=\"number\">0</span>&#125;);</span><br><span class=\"line\">        &#125;<span class=\"keyword\">else</span>&#123;</span><br><span class=\"line\">            <span class=\"keyword\">if</span>(x + <span class=\"number\">1</span> &lt;= n) q.<span class=\"built_in\">push</span>(&#123;x + <span class=\"number\">1</span>, y, nowT + <span class=\"number\">1</span>, <span class=\"number\">1</span>&#125;); <span class=\"comment\">// 垂直扩散判定</span></span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    cout &lt;&lt; <span class=\"number\">-1</span> &lt;&lt; endl;</span><br><span class=\"line\">    <span class=\"keyword\">return</span>;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n"},{"title":"2025-02-16-全景分割","date":"2025-02-15T16:00:00.000Z","_content":"# **全景分割（Panoptic Segmentation）**\n\n## ** 定义**\n\n全景分割是语义分割和实例分割的结合。它要求对图像中的每个像素分配一个语义标签，并识别出单独的对象实例。全景分割的目标是提供一个连贯、丰富和完整的场景分割。\n\n![17404074366431740407436111.png](https://tk-pichost-1325224430.cos.ap-chengdu.myqcloud.com/blog/17404074366431740407436111.png)\n\n1. **统一处理“Things”和“Stuff”**：\n\n   - **Things**（可数目标）：如人、动物、车辆等，需要检测并区分每个实例。\n   - **Stuff**（不可数目标）：如天空、草地、道路等，只需进行语义分割。\n     全景分割通过为每个像素分配类别和实例 ID，同时处理这两种类型的目标。\n2. **提供完整的场景理解**：\n   全景分割不仅关注前景目标的分割和识别，还涵盖了背景区域的语义理解，从而生成连贯且完整的场景分割。\n3. **解决语义分割和实例分割的局限性**：\n\n   - 语义分割无法区分同一类别中的不同实例。\n   - 实例分割仅关注前景目标，且分割结果可能重叠。\n     全景分割通过统一的格式和度量，克服了这些局限性。\n\n## ** 特点**\n\n- 同时处理“物体”（如人、车辆）和“非物体”（如草地、天空）区域。\n- 输出格式为每个像素分配一个语义标签和一个唯一的实例标识符。\n\n## ** 应用**\n\n全景分割在以下领域有重要应用：\n\n- **自动驾驶**：提供全面的场景理解，包括车辆、行人和背景。\n- **增强现实**：用于构建虚拟与现实融合的场景。\n- **场景解析**：用于复杂场景的全面理解。\n\n## ** 常见模型**\n\n### **Mask2Former**\n\n- **优点**：统一框架，能够处理语义、实例和全景分割任务，高精度。\n- **缺点**：基于 Transformer 的架构复杂，训练难度大，资源密集型。\n\n#### 提出初衷\n\nMask2Former 的提出初衷是为了进一步改进 MaskFormer 的性能，并解决其在实例分割任务中的不足。MaskFormer 虽然在多个分割任务上取得了不错的结果，但在实例分割任务上与当时的 SOTA 模型仍有较大差距,Mask2Former 的主要动机和改进点如下：\n\n1. **引入掩码注意力（Masked Attention）**：Mask2Former 将交叉注意力限制在预测的掩码区域内，而不是关注整个特征图。这种局部注意力机制能够更高效地提取目标特征，同时减少计算量。\n2. **多尺度高分辨率特征**：为了更好地处理小目标，Mask2Former 利用多尺度特征金字塔，并将不同分辨率的特征分别输入到 Transformer 解码器的不同层中。这一改进显著提升了对小目标的分割性能。\n3. **优化训练过程**：Mask2Former 对 Transformer 解码器进行了多项优化，包括调整自注意力和交叉注意力的顺序、使查询特征（query embedding）可学习、移除 dropout 等。这些改进在不增加计算开销的情况下提升了模型性能。\n4. **重要性采样（Importance Sampling）**：Mask2Former 在计算损失时，采用随机采样的方式，仅在部分像素点上计算损失，而不是在整个图像上计算。这一策略加快了训练速度。\n5. **通用性与高效性**：Mask2Former 的目标是提供一个通用的图像分割框架，能够同时处理语义分割、实例分割和全景分割任务。相比为每个任务设计专门的模型，Mask2Former 显著减少了研究工作量，并在多个数据集上达到了 SOTA 性能。\n   ![1740407397648HwWrbOxAeoarRyxEZ8vckW7Snif.png](https://tk-pichost-1325224430.cos.ap-chengdu.myqcloud.com/blog/1740407397648HwWrbOxAeoarRyxEZ8vckW7Snif.png)\n\n#### 网络结构\n\n![1740407421645ZhT6bgJLvom4n8xIAnzcdyG1n2b.png](https://tk-pichost-1325224430.cos.ap-chengdu.myqcloud.com/blog/1740407421645ZhT6bgJLvom4n8xIAnzcdyG1n2b.png)\nMask2Former 是一种通用的图像分割架构，能够同时处理全景分割、实例分割和语义分割任务。其网络结构主要由以下三个核心部分组成：\n\n### 1. **Backbone（骨干网络）**\n\n骨干网络用于从输入图像中提取低分辨率的特征图。Mask2Former 可以使用多种流行的骨干网络，例如 ResNet 或 Swin Transformer。这些特征图将被传递到后续模块以进行进一步处理。\n\n### 2. **Pixel Decoder（像素解码器）**\n\n像素解码器的作用是将骨干网络提取的低分辨率特征逐步上采样到高分辨率特征图。这一模块通过多尺度特征金字塔处理不同分辨率的特征，并生成高分辨率的逐像素特征嵌入。例如，Mask2Former 使用了多尺度可变形注意力（MSDeformAttn）作为像素解码器的结构，处理 1/8、1/16、1/32 大小的特征图，并通过上采样生成 1/4 分辨率的特征图。\n\n### 3. **Transformer Decoder（Transformer 解码器）**\n\nTransformer 解码器是 Mask2Former 的核心模块，负责处理对象查询（object queries）并生成最终的分割掩码。Mask2Former 引入了掩码注意力（masked attention），将交叉注意力的范围限制在预测的掩码区域内，从而提取局部特征。此外，解码器还进行了多项优化：\n\n- **掩码注意力**：通过限制交叉注意力的范围，提高模型对小目标的分割性能。\n- **多尺度特征利用**：将不同分辨率的特征分别输入到 Transformer 解码器的不同层中，以更好地处理小目标。\n- **优化训练过程**：调整自注意力和交叉注意力的顺序，使查询特征可学习，并移除 dropout，从而提高计算效率。\n\n### 4. **损失计算**\n\nMask2Former 在训练时采用了一种高效的损失计算方式。它通过随机采样点计算掩码损失，而不是在整个掩码上计算损失。具体来说：\n\n- **匹配损失（Matching Loss）**：在 Transformer 预测类别时，采用均匀采样计算损失。\n- **最终损失（Final Loss）**：采用重要性采样（importance sampling），针对不同的预测结果采样不同的点计算损失。这种策略显著减少了显存占用，提高了训练效率。\n\n> Q:**Mask2Former 是如何通过掩码注意力（Masked Attention）提升实例分割性能的呢？**\n\n#### 相关资源\n\n##### **项目**\n\n1. [facebookresearch/Mask2Former: Code release for &#34;Masked-attention Mask Transformer for Universal Image Segmentation&#34;](https://github.com/facebookresearch/Mask2Former?tab=readme-ov-file)\n2. [Mask2former Demo - a Hugging Face Space by hugging-fellows](https://huggingface.co/spaces/hugging-fellows/mask2former-demo)\n3. [zzubqh/Mask2Former-Simplify](https://github.com/zzubqh/Mask2Former-Simplify?tab=readme-ov-file)\n4. [https://bowenc0221.github.io/maskformer/](https://bowenc0221.github.io/maskformer/)\n\n##### 博客\n\n1. [【计算机视觉】MaskFormer:将语义分割和实例分割作为同一任务进行训练_语义分割标签作为输入-CSDN 博客](https://blog.csdn.net/wzk4869/article/details/131378109)\n2. [LLM 大模型: Maskformer/Mask2Former 语义分割原理详解 - 第七子 007 - 博客园](https://www.cnblogs.com/theseventhson/p/18513038)\n\n##### 论文\n\n1. [[2112.01527] Masked-attention Mask Transformer for Universal Image Segmentation](https://arxiv.org/abs/2112.01527)\n\n---\n","source":"_posts/2025-02-16-全景分割.md","raw":"---\ntitle: 2025-02-16-全景分割\ndate: 2025-02-16\ntags: 深度学习\n---\n# **全景分割（Panoptic Segmentation）**\n\n## ** 定义**\n\n全景分割是语义分割和实例分割的结合。它要求对图像中的每个像素分配一个语义标签，并识别出单独的对象实例。全景分割的目标是提供一个连贯、丰富和完整的场景分割。\n\n![17404074366431740407436111.png](https://tk-pichost-1325224430.cos.ap-chengdu.myqcloud.com/blog/17404074366431740407436111.png)\n\n1. **统一处理“Things”和“Stuff”**：\n\n   - **Things**（可数目标）：如人、动物、车辆等，需要检测并区分每个实例。\n   - **Stuff**（不可数目标）：如天空、草地、道路等，只需进行语义分割。\n     全景分割通过为每个像素分配类别和实例 ID，同时处理这两种类型的目标。\n2. **提供完整的场景理解**：\n   全景分割不仅关注前景目标的分割和识别，还涵盖了背景区域的语义理解，从而生成连贯且完整的场景分割。\n3. **解决语义分割和实例分割的局限性**：\n\n   - 语义分割无法区分同一类别中的不同实例。\n   - 实例分割仅关注前景目标，且分割结果可能重叠。\n     全景分割通过统一的格式和度量，克服了这些局限性。\n\n## ** 特点**\n\n- 同时处理“物体”（如人、车辆）和“非物体”（如草地、天空）区域。\n- 输出格式为每个像素分配一个语义标签和一个唯一的实例标识符。\n\n## ** 应用**\n\n全景分割在以下领域有重要应用：\n\n- **自动驾驶**：提供全面的场景理解，包括车辆、行人和背景。\n- **增强现实**：用于构建虚拟与现实融合的场景。\n- **场景解析**：用于复杂场景的全面理解。\n\n## ** 常见模型**\n\n### **Mask2Former**\n\n- **优点**：统一框架，能够处理语义、实例和全景分割任务，高精度。\n- **缺点**：基于 Transformer 的架构复杂，训练难度大，资源密集型。\n\n#### 提出初衷\n\nMask2Former 的提出初衷是为了进一步改进 MaskFormer 的性能，并解决其在实例分割任务中的不足。MaskFormer 虽然在多个分割任务上取得了不错的结果，但在实例分割任务上与当时的 SOTA 模型仍有较大差距,Mask2Former 的主要动机和改进点如下：\n\n1. **引入掩码注意力（Masked Attention）**：Mask2Former 将交叉注意力限制在预测的掩码区域内，而不是关注整个特征图。这种局部注意力机制能够更高效地提取目标特征，同时减少计算量。\n2. **多尺度高分辨率特征**：为了更好地处理小目标，Mask2Former 利用多尺度特征金字塔，并将不同分辨率的特征分别输入到 Transformer 解码器的不同层中。这一改进显著提升了对小目标的分割性能。\n3. **优化训练过程**：Mask2Former 对 Transformer 解码器进行了多项优化，包括调整自注意力和交叉注意力的顺序、使查询特征（query embedding）可学习、移除 dropout 等。这些改进在不增加计算开销的情况下提升了模型性能。\n4. **重要性采样（Importance Sampling）**：Mask2Former 在计算损失时，采用随机采样的方式，仅在部分像素点上计算损失，而不是在整个图像上计算。这一策略加快了训练速度。\n5. **通用性与高效性**：Mask2Former 的目标是提供一个通用的图像分割框架，能够同时处理语义分割、实例分割和全景分割任务。相比为每个任务设计专门的模型，Mask2Former 显著减少了研究工作量，并在多个数据集上达到了 SOTA 性能。\n   ![1740407397648HwWrbOxAeoarRyxEZ8vckW7Snif.png](https://tk-pichost-1325224430.cos.ap-chengdu.myqcloud.com/blog/1740407397648HwWrbOxAeoarRyxEZ8vckW7Snif.png)\n\n#### 网络结构\n\n![1740407421645ZhT6bgJLvom4n8xIAnzcdyG1n2b.png](https://tk-pichost-1325224430.cos.ap-chengdu.myqcloud.com/blog/1740407421645ZhT6bgJLvom4n8xIAnzcdyG1n2b.png)\nMask2Former 是一种通用的图像分割架构，能够同时处理全景分割、实例分割和语义分割任务。其网络结构主要由以下三个核心部分组成：\n\n### 1. **Backbone（骨干网络）**\n\n骨干网络用于从输入图像中提取低分辨率的特征图。Mask2Former 可以使用多种流行的骨干网络，例如 ResNet 或 Swin Transformer。这些特征图将被传递到后续模块以进行进一步处理。\n\n### 2. **Pixel Decoder（像素解码器）**\n\n像素解码器的作用是将骨干网络提取的低分辨率特征逐步上采样到高分辨率特征图。这一模块通过多尺度特征金字塔处理不同分辨率的特征，并生成高分辨率的逐像素特征嵌入。例如，Mask2Former 使用了多尺度可变形注意力（MSDeformAttn）作为像素解码器的结构，处理 1/8、1/16、1/32 大小的特征图，并通过上采样生成 1/4 分辨率的特征图。\n\n### 3. **Transformer Decoder（Transformer 解码器）**\n\nTransformer 解码器是 Mask2Former 的核心模块，负责处理对象查询（object queries）并生成最终的分割掩码。Mask2Former 引入了掩码注意力（masked attention），将交叉注意力的范围限制在预测的掩码区域内，从而提取局部特征。此外，解码器还进行了多项优化：\n\n- **掩码注意力**：通过限制交叉注意力的范围，提高模型对小目标的分割性能。\n- **多尺度特征利用**：将不同分辨率的特征分别输入到 Transformer 解码器的不同层中，以更好地处理小目标。\n- **优化训练过程**：调整自注意力和交叉注意力的顺序，使查询特征可学习，并移除 dropout，从而提高计算效率。\n\n### 4. **损失计算**\n\nMask2Former 在训练时采用了一种高效的损失计算方式。它通过随机采样点计算掩码损失，而不是在整个掩码上计算损失。具体来说：\n\n- **匹配损失（Matching Loss）**：在 Transformer 预测类别时，采用均匀采样计算损失。\n- **最终损失（Final Loss）**：采用重要性采样（importance sampling），针对不同的预测结果采样不同的点计算损失。这种策略显著减少了显存占用，提高了训练效率。\n\n> Q:**Mask2Former 是如何通过掩码注意力（Masked Attention）提升实例分割性能的呢？**\n\n#### 相关资源\n\n##### **项目**\n\n1. [facebookresearch/Mask2Former: Code release for &#34;Masked-attention Mask Transformer for Universal Image Segmentation&#34;](https://github.com/facebookresearch/Mask2Former?tab=readme-ov-file)\n2. [Mask2former Demo - a Hugging Face Space by hugging-fellows](https://huggingface.co/spaces/hugging-fellows/mask2former-demo)\n3. [zzubqh/Mask2Former-Simplify](https://github.com/zzubqh/Mask2Former-Simplify?tab=readme-ov-file)\n4. [https://bowenc0221.github.io/maskformer/](https://bowenc0221.github.io/maskformer/)\n\n##### 博客\n\n1. [【计算机视觉】MaskFormer:将语义分割和实例分割作为同一任务进行训练_语义分割标签作为输入-CSDN 博客](https://blog.csdn.net/wzk4869/article/details/131378109)\n2. [LLM 大模型: Maskformer/Mask2Former 语义分割原理详解 - 第七子 007 - 博客园](https://www.cnblogs.com/theseventhson/p/18513038)\n\n##### 论文\n\n1. [[2112.01527] Masked-attention Mask Transformer for Universal Image Segmentation](https://arxiv.org/abs/2112.01527)\n\n---\n","slug":"2025-02-16-全景分割","published":1,"updated":"2025-09-26T12:15:16.487Z","_id":"cmg0saj3x000jjm8n9uu46n7r","comments":1,"layout":"post","photos":[],"content":"<h1 id=\"全景分割（Panoptic-Segmentation）\"><a href=\"#全景分割（Panoptic-Segmentation）\" class=\"headerlink\" title=\"全景分割（Panoptic Segmentation）\"></a><strong>全景分割（Panoptic Segmentation）</strong></h1><h2 id=\"定义\"><a href=\"#定义\" class=\"headerlink\" title=\"** 定义**\"></a>** 定义**</h2><p>全景分割是语义分割和实例分割的结合。它要求对图像中的每个像素分配一个语义标签，并识别出单独的对象实例。全景分割的目标是提供一个连贯、丰富和完整的场景分割。</p>\n<p><img src=\"https://tk-pichost-1325224430.cos.ap-chengdu.myqcloud.com/blog/17404074366431740407436111.png\" alt=\"17404074366431740407436111.png\"></p>\n<ol>\n<li><p><strong>统一处理“Things”和“Stuff”</strong>：</p>\n<ul>\n<li><strong>Things</strong>（可数目标）：如人、动物、车辆等，需要检测并区分每个实例。</li>\n<li><strong>Stuff</strong>（不可数目标）：如天空、草地、道路等，只需进行语义分割。<br>全景分割通过为每个像素分配类别和实例 ID，同时处理这两种类型的目标。</li>\n</ul>\n</li>\n<li><p><strong>提供完整的场景理解</strong>：<br>全景分割不仅关注前景目标的分割和识别，还涵盖了背景区域的语义理解，从而生成连贯且完整的场景分割。</p>\n</li>\n<li><p><strong>解决语义分割和实例分割的局限性</strong>：</p>\n<ul>\n<li>语义分割无法区分同一类别中的不同实例。</li>\n<li>实例分割仅关注前景目标，且分割结果可能重叠。<br>全景分割通过统一的格式和度量，克服了这些局限性。</li>\n</ul>\n</li>\n</ol>\n<h2 id=\"特点\"><a href=\"#特点\" class=\"headerlink\" title=\"** 特点**\"></a>** 特点**</h2><ul>\n<li>同时处理“物体”（如人、车辆）和“非物体”（如草地、天空）区域。</li>\n<li>输出格式为每个像素分配一个语义标签和一个唯一的实例标识符。</li>\n</ul>\n<h2 id=\"应用\"><a href=\"#应用\" class=\"headerlink\" title=\"** 应用**\"></a>** 应用**</h2><p>全景分割在以下领域有重要应用：</p>\n<ul>\n<li><strong>自动驾驶</strong>：提供全面的场景理解，包括车辆、行人和背景。</li>\n<li><strong>增强现实</strong>：用于构建虚拟与现实融合的场景。</li>\n<li><strong>场景解析</strong>：用于复杂场景的全面理解。</li>\n</ul>\n<h2 id=\"常见模型\"><a href=\"#常见模型\" class=\"headerlink\" title=\"** 常见模型**\"></a>** 常见模型**</h2><h3 id=\"Mask2Former\"><a href=\"#Mask2Former\" class=\"headerlink\" title=\"Mask2Former\"></a><strong>Mask2Former</strong></h3><ul>\n<li><strong>优点</strong>：统一框架，能够处理语义、实例和全景分割任务，高精度。</li>\n<li><strong>缺点</strong>：基于 Transformer 的架构复杂，训练难度大，资源密集型。</li>\n</ul>\n<h4 id=\"提出初衷\"><a href=\"#提出初衷\" class=\"headerlink\" title=\"提出初衷\"></a>提出初衷</h4><p>Mask2Former 的提出初衷是为了进一步改进 MaskFormer 的性能，并解决其在实例分割任务中的不足。MaskFormer 虽然在多个分割任务上取得了不错的结果，但在实例分割任务上与当时的 SOTA 模型仍有较大差距,Mask2Former 的主要动机和改进点如下：</p>\n<ol>\n<li><strong>引入掩码注意力（Masked Attention）</strong>：Mask2Former 将交叉注意力限制在预测的掩码区域内，而不是关注整个特征图。这种局部注意力机制能够更高效地提取目标特征，同时减少计算量。</li>\n<li><strong>多尺度高分辨率特征</strong>：为了更好地处理小目标，Mask2Former 利用多尺度特征金字塔，并将不同分辨率的特征分别输入到 Transformer 解码器的不同层中。这一改进显著提升了对小目标的分割性能。</li>\n<li><strong>优化训练过程</strong>：Mask2Former 对 Transformer 解码器进行了多项优化，包括调整自注意力和交叉注意力的顺序、使查询特征（query embedding）可学习、移除 dropout 等。这些改进在不增加计算开销的情况下提升了模型性能。</li>\n<li><strong>重要性采样（Importance Sampling）</strong>：Mask2Former 在计算损失时，采用随机采样的方式，仅在部分像素点上计算损失，而不是在整个图像上计算。这一策略加快了训练速度。</li>\n<li><strong>通用性与高效性</strong>：Mask2Former 的目标是提供一个通用的图像分割框架，能够同时处理语义分割、实例分割和全景分割任务。相比为每个任务设计专门的模型，Mask2Former 显著减少了研究工作量，并在多个数据集上达到了 SOTA 性能。<br><img src=\"https://tk-pichost-1325224430.cos.ap-chengdu.myqcloud.com/blog/1740407397648HwWrbOxAeoarRyxEZ8vckW7Snif.png\" alt=\"1740407397648HwWrbOxAeoarRyxEZ8vckW7Snif.png\"></li>\n</ol>\n<h4 id=\"网络结构\"><a href=\"#网络结构\" class=\"headerlink\" title=\"网络结构\"></a>网络结构</h4><p><img src=\"https://tk-pichost-1325224430.cos.ap-chengdu.myqcloud.com/blog/1740407421645ZhT6bgJLvom4n8xIAnzcdyG1n2b.png\" alt=\"1740407421645ZhT6bgJLvom4n8xIAnzcdyG1n2b.png\"><br>Mask2Former 是一种通用的图像分割架构，能够同时处理全景分割、实例分割和语义分割任务。其网络结构主要由以下三个核心部分组成：</p>\n<h3 id=\"1-Backbone（骨干网络）\"><a href=\"#1-Backbone（骨干网络）\" class=\"headerlink\" title=\"1. Backbone（骨干网络）\"></a>1. <strong>Backbone（骨干网络）</strong></h3><p>骨干网络用于从输入图像中提取低分辨率的特征图。Mask2Former 可以使用多种流行的骨干网络，例如 ResNet 或 Swin Transformer。这些特征图将被传递到后续模块以进行进一步处理。</p>\n<h3 id=\"2-Pixel-Decoder（像素解码器）\"><a href=\"#2-Pixel-Decoder（像素解码器）\" class=\"headerlink\" title=\"2. Pixel Decoder（像素解码器）\"></a>2. <strong>Pixel Decoder（像素解码器）</strong></h3><p>像素解码器的作用是将骨干网络提取的低分辨率特征逐步上采样到高分辨率特征图。这一模块通过多尺度特征金字塔处理不同分辨率的特征，并生成高分辨率的逐像素特征嵌入。例如，Mask2Former 使用了多尺度可变形注意力（MSDeformAttn）作为像素解码器的结构，处理 1&#x2F;8、1&#x2F;16、1&#x2F;32 大小的特征图，并通过上采样生成 1&#x2F;4 分辨率的特征图。</p>\n<h3 id=\"3-Transformer-Decoder（Transformer-解码器）\"><a href=\"#3-Transformer-Decoder（Transformer-解码器）\" class=\"headerlink\" title=\"3. Transformer Decoder（Transformer 解码器）\"></a>3. <strong>Transformer Decoder（Transformer 解码器）</strong></h3><p>Transformer 解码器是 Mask2Former 的核心模块，负责处理对象查询（object queries）并生成最终的分割掩码。Mask2Former 引入了掩码注意力（masked attention），将交叉注意力的范围限制在预测的掩码区域内，从而提取局部特征。此外，解码器还进行了多项优化：</p>\n<ul>\n<li><strong>掩码注意力</strong>：通过限制交叉注意力的范围，提高模型对小目标的分割性能。</li>\n<li><strong>多尺度特征利用</strong>：将不同分辨率的特征分别输入到 Transformer 解码器的不同层中，以更好地处理小目标。</li>\n<li><strong>优化训练过程</strong>：调整自注意力和交叉注意力的顺序，使查询特征可学习，并移除 dropout，从而提高计算效率。</li>\n</ul>\n<h3 id=\"4-损失计算\"><a href=\"#4-损失计算\" class=\"headerlink\" title=\"4. 损失计算\"></a>4. <strong>损失计算</strong></h3><p>Mask2Former 在训练时采用了一种高效的损失计算方式。它通过随机采样点计算掩码损失，而不是在整个掩码上计算损失。具体来说：</p>\n<ul>\n<li><strong>匹配损失（Matching Loss）</strong>：在 Transformer 预测类别时，采用均匀采样计算损失。</li>\n<li><strong>最终损失（Final Loss）</strong>：采用重要性采样（importance sampling），针对不同的预测结果采样不同的点计算损失。这种策略显著减少了显存占用，提高了训练效率。</li>\n</ul>\n<blockquote>\n<p>Q:<strong>Mask2Former 是如何通过掩码注意力（Masked Attention）提升实例分割性能的呢？</strong></p>\n</blockquote>\n<h4 id=\"相关资源\"><a href=\"#相关资源\" class=\"headerlink\" title=\"相关资源\"></a>相关资源</h4><h5 id=\"项目\"><a href=\"#项目\" class=\"headerlink\" title=\"项目\"></a><strong>项目</strong></h5><ol>\n<li><a href=\"https://github.com/facebookresearch/Mask2Former?tab=readme-ov-file\">facebookresearch&#x2F;Mask2Former: Code release for &#34;Masked-attention Mask Transformer for Universal Image Segmentation&#34;</a></li>\n<li><a href=\"https://huggingface.co/spaces/hugging-fellows/mask2former-demo\">Mask2former Demo - a Hugging Face Space by hugging-fellows</a></li>\n<li><a href=\"https://github.com/zzubqh/Mask2Former-Simplify?tab=readme-ov-file\">zzubqh&#x2F;Mask2Former-Simplify</a></li>\n<li><a href=\"https://bowenc0221.github.io/maskformer/\">https://bowenc0221.github.io/maskformer/</a></li>\n</ol>\n<h5 id=\"博客\"><a href=\"#博客\" class=\"headerlink\" title=\"博客\"></a>博客</h5><ol>\n<li><a href=\"https://blog.csdn.net/wzk4869/article/details/131378109\">【计算机视觉】MaskFormer:将语义分割和实例分割作为同一任务进行训练_语义分割标签作为输入-CSDN 博客</a></li>\n<li><a href=\"https://www.cnblogs.com/theseventhson/p/18513038\">LLM 大模型: Maskformer&#x2F;Mask2Former 语义分割原理详解 - 第七子 007 - 博客园</a></li>\n</ol>\n<h5 id=\"论文\"><a href=\"#论文\" class=\"headerlink\" title=\"论文\"></a>论文</h5><ol>\n<li><a href=\"https://arxiv.org/abs/2112.01527\">[2112.01527] Masked-attention Mask Transformer for Universal Image Segmentation</a></li>\n</ol>\n<hr>\n","excerpt":"","more":"<h1 id=\"全景分割（Panoptic-Segmentation）\"><a href=\"#全景分割（Panoptic-Segmentation）\" class=\"headerlink\" title=\"全景分割（Panoptic Segmentation）\"></a><strong>全景分割（Panoptic Segmentation）</strong></h1><h2 id=\"定义\"><a href=\"#定义\" class=\"headerlink\" title=\"** 定义**\"></a>** 定义**</h2><p>全景分割是语义分割和实例分割的结合。它要求对图像中的每个像素分配一个语义标签，并识别出单独的对象实例。全景分割的目标是提供一个连贯、丰富和完整的场景分割。</p>\n<p><img src=\"https://tk-pichost-1325224430.cos.ap-chengdu.myqcloud.com/blog/17404074366431740407436111.png\" alt=\"17404074366431740407436111.png\"></p>\n<ol>\n<li><p><strong>统一处理“Things”和“Stuff”</strong>：</p>\n<ul>\n<li><strong>Things</strong>（可数目标）：如人、动物、车辆等，需要检测并区分每个实例。</li>\n<li><strong>Stuff</strong>（不可数目标）：如天空、草地、道路等，只需进行语义分割。<br>全景分割通过为每个像素分配类别和实例 ID，同时处理这两种类型的目标。</li>\n</ul>\n</li>\n<li><p><strong>提供完整的场景理解</strong>：<br>全景分割不仅关注前景目标的分割和识别，还涵盖了背景区域的语义理解，从而生成连贯且完整的场景分割。</p>\n</li>\n<li><p><strong>解决语义分割和实例分割的局限性</strong>：</p>\n<ul>\n<li>语义分割无法区分同一类别中的不同实例。</li>\n<li>实例分割仅关注前景目标，且分割结果可能重叠。<br>全景分割通过统一的格式和度量，克服了这些局限性。</li>\n</ul>\n</li>\n</ol>\n<h2 id=\"特点\"><a href=\"#特点\" class=\"headerlink\" title=\"** 特点**\"></a>** 特点**</h2><ul>\n<li>同时处理“物体”（如人、车辆）和“非物体”（如草地、天空）区域。</li>\n<li>输出格式为每个像素分配一个语义标签和一个唯一的实例标识符。</li>\n</ul>\n<h2 id=\"应用\"><a href=\"#应用\" class=\"headerlink\" title=\"** 应用**\"></a>** 应用**</h2><p>全景分割在以下领域有重要应用：</p>\n<ul>\n<li><strong>自动驾驶</strong>：提供全面的场景理解，包括车辆、行人和背景。</li>\n<li><strong>增强现实</strong>：用于构建虚拟与现实融合的场景。</li>\n<li><strong>场景解析</strong>：用于复杂场景的全面理解。</li>\n</ul>\n<h2 id=\"常见模型\"><a href=\"#常见模型\" class=\"headerlink\" title=\"** 常见模型**\"></a>** 常见模型**</h2><h3 id=\"Mask2Former\"><a href=\"#Mask2Former\" class=\"headerlink\" title=\"Mask2Former\"></a><strong>Mask2Former</strong></h3><ul>\n<li><strong>优点</strong>：统一框架，能够处理语义、实例和全景分割任务，高精度。</li>\n<li><strong>缺点</strong>：基于 Transformer 的架构复杂，训练难度大，资源密集型。</li>\n</ul>\n<h4 id=\"提出初衷\"><a href=\"#提出初衷\" class=\"headerlink\" title=\"提出初衷\"></a>提出初衷</h4><p>Mask2Former 的提出初衷是为了进一步改进 MaskFormer 的性能，并解决其在实例分割任务中的不足。MaskFormer 虽然在多个分割任务上取得了不错的结果，但在实例分割任务上与当时的 SOTA 模型仍有较大差距,Mask2Former 的主要动机和改进点如下：</p>\n<ol>\n<li><strong>引入掩码注意力（Masked Attention）</strong>：Mask2Former 将交叉注意力限制在预测的掩码区域内，而不是关注整个特征图。这种局部注意力机制能够更高效地提取目标特征，同时减少计算量。</li>\n<li><strong>多尺度高分辨率特征</strong>：为了更好地处理小目标，Mask2Former 利用多尺度特征金字塔，并将不同分辨率的特征分别输入到 Transformer 解码器的不同层中。这一改进显著提升了对小目标的分割性能。</li>\n<li><strong>优化训练过程</strong>：Mask2Former 对 Transformer 解码器进行了多项优化，包括调整自注意力和交叉注意力的顺序、使查询特征（query embedding）可学习、移除 dropout 等。这些改进在不增加计算开销的情况下提升了模型性能。</li>\n<li><strong>重要性采样（Importance Sampling）</strong>：Mask2Former 在计算损失时，采用随机采样的方式，仅在部分像素点上计算损失，而不是在整个图像上计算。这一策略加快了训练速度。</li>\n<li><strong>通用性与高效性</strong>：Mask2Former 的目标是提供一个通用的图像分割框架，能够同时处理语义分割、实例分割和全景分割任务。相比为每个任务设计专门的模型，Mask2Former 显著减少了研究工作量，并在多个数据集上达到了 SOTA 性能。<br><img src=\"https://tk-pichost-1325224430.cos.ap-chengdu.myqcloud.com/blog/1740407397648HwWrbOxAeoarRyxEZ8vckW7Snif.png\" alt=\"1740407397648HwWrbOxAeoarRyxEZ8vckW7Snif.png\"></li>\n</ol>\n<h4 id=\"网络结构\"><a href=\"#网络结构\" class=\"headerlink\" title=\"网络结构\"></a>网络结构</h4><p><img src=\"https://tk-pichost-1325224430.cos.ap-chengdu.myqcloud.com/blog/1740407421645ZhT6bgJLvom4n8xIAnzcdyG1n2b.png\" alt=\"1740407421645ZhT6bgJLvom4n8xIAnzcdyG1n2b.png\"><br>Mask2Former 是一种通用的图像分割架构，能够同时处理全景分割、实例分割和语义分割任务。其网络结构主要由以下三个核心部分组成：</p>\n<h3 id=\"1-Backbone（骨干网络）\"><a href=\"#1-Backbone（骨干网络）\" class=\"headerlink\" title=\"1. Backbone（骨干网络）\"></a>1. <strong>Backbone（骨干网络）</strong></h3><p>骨干网络用于从输入图像中提取低分辨率的特征图。Mask2Former 可以使用多种流行的骨干网络，例如 ResNet 或 Swin Transformer。这些特征图将被传递到后续模块以进行进一步处理。</p>\n<h3 id=\"2-Pixel-Decoder（像素解码器）\"><a href=\"#2-Pixel-Decoder（像素解码器）\" class=\"headerlink\" title=\"2. Pixel Decoder（像素解码器）\"></a>2. <strong>Pixel Decoder（像素解码器）</strong></h3><p>像素解码器的作用是将骨干网络提取的低分辨率特征逐步上采样到高分辨率特征图。这一模块通过多尺度特征金字塔处理不同分辨率的特征，并生成高分辨率的逐像素特征嵌入。例如，Mask2Former 使用了多尺度可变形注意力（MSDeformAttn）作为像素解码器的结构，处理 1&#x2F;8、1&#x2F;16、1&#x2F;32 大小的特征图，并通过上采样生成 1&#x2F;4 分辨率的特征图。</p>\n<h3 id=\"3-Transformer-Decoder（Transformer-解码器）\"><a href=\"#3-Transformer-Decoder（Transformer-解码器）\" class=\"headerlink\" title=\"3. Transformer Decoder（Transformer 解码器）\"></a>3. <strong>Transformer Decoder（Transformer 解码器）</strong></h3><p>Transformer 解码器是 Mask2Former 的核心模块，负责处理对象查询（object queries）并生成最终的分割掩码。Mask2Former 引入了掩码注意力（masked attention），将交叉注意力的范围限制在预测的掩码区域内，从而提取局部特征。此外，解码器还进行了多项优化：</p>\n<ul>\n<li><strong>掩码注意力</strong>：通过限制交叉注意力的范围，提高模型对小目标的分割性能。</li>\n<li><strong>多尺度特征利用</strong>：将不同分辨率的特征分别输入到 Transformer 解码器的不同层中，以更好地处理小目标。</li>\n<li><strong>优化训练过程</strong>：调整自注意力和交叉注意力的顺序，使查询特征可学习，并移除 dropout，从而提高计算效率。</li>\n</ul>\n<h3 id=\"4-损失计算\"><a href=\"#4-损失计算\" class=\"headerlink\" title=\"4. 损失计算\"></a>4. <strong>损失计算</strong></h3><p>Mask2Former 在训练时采用了一种高效的损失计算方式。它通过随机采样点计算掩码损失，而不是在整个掩码上计算损失。具体来说：</p>\n<ul>\n<li><strong>匹配损失（Matching Loss）</strong>：在 Transformer 预测类别时，采用均匀采样计算损失。</li>\n<li><strong>最终损失（Final Loss）</strong>：采用重要性采样（importance sampling），针对不同的预测结果采样不同的点计算损失。这种策略显著减少了显存占用，提高了训练效率。</li>\n</ul>\n<blockquote>\n<p>Q:<strong>Mask2Former 是如何通过掩码注意力（Masked Attention）提升实例分割性能的呢？</strong></p>\n</blockquote>\n<h4 id=\"相关资源\"><a href=\"#相关资源\" class=\"headerlink\" title=\"相关资源\"></a>相关资源</h4><h5 id=\"项目\"><a href=\"#项目\" class=\"headerlink\" title=\"项目\"></a><strong>项目</strong></h5><ol>\n<li><a href=\"https://github.com/facebookresearch/Mask2Former?tab=readme-ov-file\">facebookresearch&#x2F;Mask2Former: Code release for &#34;Masked-attention Mask Transformer for Universal Image Segmentation&#34;</a></li>\n<li><a href=\"https://huggingface.co/spaces/hugging-fellows/mask2former-demo\">Mask2former Demo - a Hugging Face Space by hugging-fellows</a></li>\n<li><a href=\"https://github.com/zzubqh/Mask2Former-Simplify?tab=readme-ov-file\">zzubqh&#x2F;Mask2Former-Simplify</a></li>\n<li><a href=\"https://bowenc0221.github.io/maskformer/\">https://bowenc0221.github.io/maskformer/</a></li>\n</ol>\n<h5 id=\"博客\"><a href=\"#博客\" class=\"headerlink\" title=\"博客\"></a>博客</h5><ol>\n<li><a href=\"https://blog.csdn.net/wzk4869/article/details/131378109\">【计算机视觉】MaskFormer:将语义分割和实例分割作为同一任务进行训练_语义分割标签作为输入-CSDN 博客</a></li>\n<li><a href=\"https://www.cnblogs.com/theseventhson/p/18513038\">LLM 大模型: Maskformer&#x2F;Mask2Former 语义分割原理详解 - 第七子 007 - 博客园</a></li>\n</ol>\n<h5 id=\"论文\"><a href=\"#论文\" class=\"headerlink\" title=\"论文\"></a>论文</h5><ol>\n<li><a href=\"https://arxiv.org/abs/2112.01527\">[2112.01527] Masked-attention Mask Transformer for Universal Image Segmentation</a></li>\n</ol>\n<hr>\n"},{"title":"2025-03-04-判断素数","date":"2025-03-03T16:00:00.000Z","_content":"\n# 2025-03-04-判断素数的方法\n\n> 参考博客\n> [判断一个数是不是质数(素数)，3 种方式介绍_判断一个数是否为素数-CSDN 博客](https://blog.csdn.net/afei__/article/details/80638460)\n> [C-CrashCourse/content/c-notes/你不知道的几种素数判断方法，由浅入深，详解.md at master · hairrrrr/C-CrashCourse](https://github.com/hairrrrr/C-CrashCourse/blob/master/content/c-notes/%E4%BD%A0%E4%B8%8D%E7%9F%A5%E9%81%93%E7%9A%84%E5%87%A0%E7%A7%8D%E7%B4%A0%E6%95%B0%E5%88%A4%E6%96%AD%E6%96%B9%E6%B3%95%EF%BC%8C%E7%94%B1%E6%B5%85%E5%85%A5%E6%B7%B1%EF%BC%8C%E8%AF%A6%E8%A7%A3.md)\n\n# **暴力求解**\n\n> 根据素数的定义思考。素数是大于 1 的自然数，除了 1 和自身外，其他数都不是它的因子。 那我们就可以用一个循环，从 2 开始遍历到这个数减去 1，如果这个数都不能被整除，那么这个数就是素数。 也就是说： 给定一个数 n , i 从 2 开始取值，直到 n - 1(取整数),如果 n % i != 0 , n 就是素数 进一步思考，有必要遍历到 n - 1 吗？ 除了 1 以外，任何合数最小的因子就是 2，那最大的因子就是 n/2 那我们就遍历到 n/2 就足够了\n\n```\nint isPrime(int target) {\n\n    int i = 0;\n\n    if (target <= 1) {\n        printf(\"illegal input!\\n\");//素数定义\n        return -1;\n    }\n\n    for (i = 2; i <= target / 2; i++) {\n        if (target % i == 0)\n            return 0;//不是素数直接返回0\n    }\n\n    return 1;//是素数返回1\n}\n```\n\n## 求解范围改进\n\n> 在上面的基础上，其实不需要遍历到 $\\frac{n}{2}$，只需要到 $\\sqrt{n}$（包含 $\\sqrt{n}$） 就可以了。\n>\n> - **为什么只需要检查到** $\\sqrt{n}$**？**\n>   1. **因数成对出现**：\n>   - 如果 _n_ 不是质数，那么它可以分解为两个因数的乘积，即 _n_=_a_×_b_。\n>   - 假设 _a_≤_b_，那么一定有 _a_≤_n_ 且 _b_≥_n_。\n>   - 因此，如果 _n_ 有大于 _n_ 的因数 _b_，那么它必然有一个小于或等于 _n_ 的因数 _a_。\n>   2. **只需检查较小的因数**：\n>   - 如果 _n_ 能被某个数 _i_ 整除（即 _n_%_i_==0），那么 _i_ 就是 _n_ 的一个因数。\n>   - 根据上述性质，如果 _n_ 有大于 _n_ 的因数，那么它必然已经被小于或等于 _n_ 的因数检查过了。\n>   3. **举例说明**：\n>   - 假设 _n_=36， $\\sqrt{36}$=6。\n>   - 检查 2 到 6 的整数：\n>   - 2 是 36 的因数（36%2==0），因此 36 不是质数。\n>   - 如果继续检查 4 和 6，会发现它们也是 36 的因数，但已经不需要了，因为 2 已经证明了 36 不是质数。\n\n```\nint isPrime(int target) {\n\n    int i = 0;\n\n    if (target <= 1) {\n        printf(\"illegal input!\\n\");//素数定义\n        return -1;\n    }\n\n    for (i = 2; i <= (int)sqrt(target); i++) {\n        if (target % i == 0)\n            return 0;\n    }\n\n    return 1;\n}\n```\n\n# **用素数表来判断素数**\n\n> 从第二种方法开始，我们都是先完成判断素数数组，然后用二分法去查找判断数组\n> 这里说一下以下三种方法牵扯的概念：\n>\n> - 范围：1 ~ 范围上限 N\n> - 范围上限 N：判断素数需要用户输入随机素数，这个随机素数的范围是 1 ~ N\n> - 判断素数数组：将数组的 `下标` 与 `1 ~ N` 的自然数一一对应起来。 判断 1 到 N 的自然数是否为素数，其实就是判断数组的下标是否为素数，如果是 给这个下标所对应的判断素数数组元素赋 1，否则赋 0 比如：我要判断 3 是否为素数，我们就找到 `判断素数数组isPrime` 中的下标为 3 的元素，即：`isPrime[3]` 如果 `3` 是素数 ， 赋值 1，即 `isPrime[3] = 1` `如果 3 不是素数，赋值0 ，即isPrime[3] = 0` 这样我们在用二分法查找时，查找数组下标就可以，找到下标后返回下标对应的判断素数数组的值。 如果是 1 说明下标对应的自然数是素数，否则不是\n> - 思路:如果一个数不能整除比它小的任何素数，那么这个数就是素数 这种“打印”素数表的方法效率很低，不推荐使用，可以学习思想\n\n```\n//target：输入的要查找的数\n//count：当前已知的素数个数\n//PrimeArray：存放素数的数组\nint isPrime(int target, int count, int* PrimeArray) {\n\n    int i = 0;\n    for (i = 0; i < count; i++) {\n        if (target % PrimeArray[i] == 0)\n            return 0;\n    }\n\n    return 1;\n}\n```\n\n# **普通筛法——埃拉托斯特尼(Eratosthenes)筛法**\n\n> **思路**:\n>\n> 1. 我们的想法是，创建一个比范围上限大 1 的数组，我们只关注下标为 1 ~ N（要求的上限） 的数组元素与数组下标（一一对应）。\n> 2. 将数组初始化为 1。然后用 for 循环，遍历范围为： $[2,\\sqrt{N}]$。如果数组元素为 1，则说明这个数组元素的下标所对应的数是素数。\n> 3. 随后我们将这个下标（除 1 以外）的整数倍所对应的数组元素全部置为 0，也就是判断其为非素数。 这样，我们就知道了范围内（1 ~ 范围上限 N）所有数是素数（下标对应的数组元素值为 1）或不是素数（下标对应的数组元素值为 0）\n> 4. 用百度百科对埃拉托斯特尼筛法简单描述：**要得到自然数 n 以内的全部素数，必须把不大于 的所有素数的倍数剔除，剩下的就是素数。**\n\n```\n//                 判断素数的数组    范围上限N\nvoid Eratprime(int* isprime, int upper_board) {\n\n    int i = 0;\n    int j = 0;\n    //初始化isprime\n    for (i = 2; i <= upper_board; i++)\n        isprime[i] = 1;\n\n\n    for (i = 2; i < (int)sqrt(upper_board); i++) {\n        if (isprime[i]) {\n            isprime[i] = 1;\n        }\n        for (j = 2; i * j <= upper_board; j++) {//素数的n倍（n >= 2）不是素数\n            isprime[i * j] = 0;\n        }\n    }\n\n}\n```\n\n# **线性筛法——欧拉筛法**\n\n> **思路**: 我们再思考一下上面的埃拉托斯特尼筛法，会发现，在“剔除“非素数时，有些合数会重复赋值。这样就会增加复杂度，降低效率。 比如：范围上限 N = 16 时\n>\n> - 2 是素数，剔除”2 的倍数“，它们是：4，6， 8，10， 12， 14， 16\n> - 3 是素数，剔除”3 的倍数”，它们是，6，9，12，15\n>   6，12 是重复的。如何减少重复呢？\n\n```\nvoid PrimeList(int* Prime, bool* isPrime, int n) {\n\n    int i = 0;\n    int j = 0;\n    int count = 0;\n\n    if (isPrime != NULL) {//确保isPrime不是空指针\n        //将isPrime数组初始化为 1\n        for (i = 2; i <= N; i++) {\n            isPrime[i] = true;\n        }\n    }\n\n    if (isPrime != NULL && Prime != NULL) {\n        //从2遍历到范围上限N\n        for (i = 2; i <= N; i++) {\n            if (isPrime[i])//如果下标（下标对应着1 ~ 范围上限N）对应的isPrime值没有被置为false，说明这个数是素数，将下标放入素数数组\n                Prime[count++] = i;\n            //循环控制表达式的意义：j小于等于素数数组的个数 或 素数数组中的每一个素数与 i 的积小于范围上限N\n            for (j = 0; (j < count) && (Prime[j] * (long long)i) <= N; j++)//将i强制转换是因为vs上有warning，要求转换为宽类型防止算术溢出。数据上不产生影响\n            {\n                isPrime[i * Prime[j]] = false;//每一个素数的 i 倍（i >= 2）都不是素数，置为false\n\n                //这个是欧拉筛法的核心，它可以减少非素数置false的重复率\n                //意义是将每一个合数（非素数）拆成 2（最小因数）与最大因数 的乘积\n                if (i % Prime[j] == 0)\n                    break;\n            }\n        }\n    }\n}\n```\n","source":"_posts/2025-03-04-判断素数.md","raw":"---\ntitle: 2025-03-04-判断素数\ndate: 2025-03-04\ntags: 算法练习\n---\n\n# 2025-03-04-判断素数的方法\n\n> 参考博客\n> [判断一个数是不是质数(素数)，3 种方式介绍_判断一个数是否为素数-CSDN 博客](https://blog.csdn.net/afei__/article/details/80638460)\n> [C-CrashCourse/content/c-notes/你不知道的几种素数判断方法，由浅入深，详解.md at master · hairrrrr/C-CrashCourse](https://github.com/hairrrrr/C-CrashCourse/blob/master/content/c-notes/%E4%BD%A0%E4%B8%8D%E7%9F%A5%E9%81%93%E7%9A%84%E5%87%A0%E7%A7%8D%E7%B4%A0%E6%95%B0%E5%88%A4%E6%96%AD%E6%96%B9%E6%B3%95%EF%BC%8C%E7%94%B1%E6%B5%85%E5%85%A5%E6%B7%B1%EF%BC%8C%E8%AF%A6%E8%A7%A3.md)\n\n# **暴力求解**\n\n> 根据素数的定义思考。素数是大于 1 的自然数，除了 1 和自身外，其他数都不是它的因子。 那我们就可以用一个循环，从 2 开始遍历到这个数减去 1，如果这个数都不能被整除，那么这个数就是素数。 也就是说： 给定一个数 n , i 从 2 开始取值，直到 n - 1(取整数),如果 n % i != 0 , n 就是素数 进一步思考，有必要遍历到 n - 1 吗？ 除了 1 以外，任何合数最小的因子就是 2，那最大的因子就是 n/2 那我们就遍历到 n/2 就足够了\n\n```\nint isPrime(int target) {\n\n    int i = 0;\n\n    if (target <= 1) {\n        printf(\"illegal input!\\n\");//素数定义\n        return -1;\n    }\n\n    for (i = 2; i <= target / 2; i++) {\n        if (target % i == 0)\n            return 0;//不是素数直接返回0\n    }\n\n    return 1;//是素数返回1\n}\n```\n\n## 求解范围改进\n\n> 在上面的基础上，其实不需要遍历到 $\\frac{n}{2}$，只需要到 $\\sqrt{n}$（包含 $\\sqrt{n}$） 就可以了。\n>\n> - **为什么只需要检查到** $\\sqrt{n}$**？**\n>   1. **因数成对出现**：\n>   - 如果 _n_ 不是质数，那么它可以分解为两个因数的乘积，即 _n_=_a_×_b_。\n>   - 假设 _a_≤_b_，那么一定有 _a_≤_n_ 且 _b_≥_n_。\n>   - 因此，如果 _n_ 有大于 _n_ 的因数 _b_，那么它必然有一个小于或等于 _n_ 的因数 _a_。\n>   2. **只需检查较小的因数**：\n>   - 如果 _n_ 能被某个数 _i_ 整除（即 _n_%_i_==0），那么 _i_ 就是 _n_ 的一个因数。\n>   - 根据上述性质，如果 _n_ 有大于 _n_ 的因数，那么它必然已经被小于或等于 _n_ 的因数检查过了。\n>   3. **举例说明**：\n>   - 假设 _n_=36， $\\sqrt{36}$=6。\n>   - 检查 2 到 6 的整数：\n>   - 2 是 36 的因数（36%2==0），因此 36 不是质数。\n>   - 如果继续检查 4 和 6，会发现它们也是 36 的因数，但已经不需要了，因为 2 已经证明了 36 不是质数。\n\n```\nint isPrime(int target) {\n\n    int i = 0;\n\n    if (target <= 1) {\n        printf(\"illegal input!\\n\");//素数定义\n        return -1;\n    }\n\n    for (i = 2; i <= (int)sqrt(target); i++) {\n        if (target % i == 0)\n            return 0;\n    }\n\n    return 1;\n}\n```\n\n# **用素数表来判断素数**\n\n> 从第二种方法开始，我们都是先完成判断素数数组，然后用二分法去查找判断数组\n> 这里说一下以下三种方法牵扯的概念：\n>\n> - 范围：1 ~ 范围上限 N\n> - 范围上限 N：判断素数需要用户输入随机素数，这个随机素数的范围是 1 ~ N\n> - 判断素数数组：将数组的 `下标` 与 `1 ~ N` 的自然数一一对应起来。 判断 1 到 N 的自然数是否为素数，其实就是判断数组的下标是否为素数，如果是 给这个下标所对应的判断素数数组元素赋 1，否则赋 0 比如：我要判断 3 是否为素数，我们就找到 `判断素数数组isPrime` 中的下标为 3 的元素，即：`isPrime[3]` 如果 `3` 是素数 ， 赋值 1，即 `isPrime[3] = 1` `如果 3 不是素数，赋值0 ，即isPrime[3] = 0` 这样我们在用二分法查找时，查找数组下标就可以，找到下标后返回下标对应的判断素数数组的值。 如果是 1 说明下标对应的自然数是素数，否则不是\n> - 思路:如果一个数不能整除比它小的任何素数，那么这个数就是素数 这种“打印”素数表的方法效率很低，不推荐使用，可以学习思想\n\n```\n//target：输入的要查找的数\n//count：当前已知的素数个数\n//PrimeArray：存放素数的数组\nint isPrime(int target, int count, int* PrimeArray) {\n\n    int i = 0;\n    for (i = 0; i < count; i++) {\n        if (target % PrimeArray[i] == 0)\n            return 0;\n    }\n\n    return 1;\n}\n```\n\n# **普通筛法——埃拉托斯特尼(Eratosthenes)筛法**\n\n> **思路**:\n>\n> 1. 我们的想法是，创建一个比范围上限大 1 的数组，我们只关注下标为 1 ~ N（要求的上限） 的数组元素与数组下标（一一对应）。\n> 2. 将数组初始化为 1。然后用 for 循环，遍历范围为： $[2,\\sqrt{N}]$。如果数组元素为 1，则说明这个数组元素的下标所对应的数是素数。\n> 3. 随后我们将这个下标（除 1 以外）的整数倍所对应的数组元素全部置为 0，也就是判断其为非素数。 这样，我们就知道了范围内（1 ~ 范围上限 N）所有数是素数（下标对应的数组元素值为 1）或不是素数（下标对应的数组元素值为 0）\n> 4. 用百度百科对埃拉托斯特尼筛法简单描述：**要得到自然数 n 以内的全部素数，必须把不大于 的所有素数的倍数剔除，剩下的就是素数。**\n\n```\n//                 判断素数的数组    范围上限N\nvoid Eratprime(int* isprime, int upper_board) {\n\n    int i = 0;\n    int j = 0;\n    //初始化isprime\n    for (i = 2; i <= upper_board; i++)\n        isprime[i] = 1;\n\n\n    for (i = 2; i < (int)sqrt(upper_board); i++) {\n        if (isprime[i]) {\n            isprime[i] = 1;\n        }\n        for (j = 2; i * j <= upper_board; j++) {//素数的n倍（n >= 2）不是素数\n            isprime[i * j] = 0;\n        }\n    }\n\n}\n```\n\n# **线性筛法——欧拉筛法**\n\n> **思路**: 我们再思考一下上面的埃拉托斯特尼筛法，会发现，在“剔除“非素数时，有些合数会重复赋值。这样就会增加复杂度，降低效率。 比如：范围上限 N = 16 时\n>\n> - 2 是素数，剔除”2 的倍数“，它们是：4，6， 8，10， 12， 14， 16\n> - 3 是素数，剔除”3 的倍数”，它们是，6，9，12，15\n>   6，12 是重复的。如何减少重复呢？\n\n```\nvoid PrimeList(int* Prime, bool* isPrime, int n) {\n\n    int i = 0;\n    int j = 0;\n    int count = 0;\n\n    if (isPrime != NULL) {//确保isPrime不是空指针\n        //将isPrime数组初始化为 1\n        for (i = 2; i <= N; i++) {\n            isPrime[i] = true;\n        }\n    }\n\n    if (isPrime != NULL && Prime != NULL) {\n        //从2遍历到范围上限N\n        for (i = 2; i <= N; i++) {\n            if (isPrime[i])//如果下标（下标对应着1 ~ 范围上限N）对应的isPrime值没有被置为false，说明这个数是素数，将下标放入素数数组\n                Prime[count++] = i;\n            //循环控制表达式的意义：j小于等于素数数组的个数 或 素数数组中的每一个素数与 i 的积小于范围上限N\n            for (j = 0; (j < count) && (Prime[j] * (long long)i) <= N; j++)//将i强制转换是因为vs上有warning，要求转换为宽类型防止算术溢出。数据上不产生影响\n            {\n                isPrime[i * Prime[j]] = false;//每一个素数的 i 倍（i >= 2）都不是素数，置为false\n\n                //这个是欧拉筛法的核心，它可以减少非素数置false的重复率\n                //意义是将每一个合数（非素数）拆成 2（最小因数）与最大因数 的乘积\n                if (i % Prime[j] == 0)\n                    break;\n            }\n        }\n    }\n}\n```\n","slug":"2025-03-04-判断素数","published":1,"updated":"2025-09-26T12:15:44.193Z","_id":"cmg0saj3y000ljm8nfu0m5rtj","comments":1,"layout":"post","photos":[],"content":"<h1 id=\"2025-03-04-判断素数的方法\"><a href=\"#2025-03-04-判断素数的方法\" class=\"headerlink\" title=\"2025-03-04-判断素数的方法\"></a>2025-03-04-判断素数的方法</h1><blockquote>\n<p>参考博客<br><a href=\"https://blog.csdn.net/afei__/article/details/80638460\">判断一个数是不是质数(素数)，3 种方式介绍_判断一个数是否为素数-CSDN 博客</a><br><a href=\"https://github.com/hairrrrr/C-CrashCourse/blob/master/content/c-notes/%E4%BD%A0%E4%B8%8D%E7%9F%A5%E9%81%93%E7%9A%84%E5%87%A0%E7%A7%8D%E7%B4%A0%E6%95%B0%E5%88%A4%E6%96%AD%E6%96%B9%E6%B3%95%EF%BC%8C%E7%94%B1%E6%B5%85%E5%85%A5%E6%B7%B1%EF%BC%8C%E8%AF%A6%E8%A7%A3.md\">C-CrashCourse&#x2F;content&#x2F;c-notes&#x2F;你不知道的几种素数判断方法，由浅入深，详解.md at master · hairrrrr&#x2F;C-CrashCourse</a></p>\n</blockquote>\n<h1 id=\"暴力求解\"><a href=\"#暴力求解\" class=\"headerlink\" title=\"暴力求解\"></a><strong>暴力求解</strong></h1><blockquote>\n<p>根据素数的定义思考。素数是大于 1 的自然数，除了 1 和自身外，其他数都不是它的因子。 那我们就可以用一个循环，从 2 开始遍历到这个数减去 1，如果这个数都不能被整除，那么这个数就是素数。 也就是说： 给定一个数 n , i 从 2 开始取值，直到 n - 1(取整数),如果 n % i !&#x3D; 0 , n 就是素数 进一步思考，有必要遍历到 n - 1 吗？ 除了 1 以外，任何合数最小的因子就是 2，那最大的因子就是 n&#x2F;2 那我们就遍历到 n&#x2F;2 就足够了</p>\n</blockquote>\n<figure class=\"highlight aspectj\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">int</span> <span class=\"title\">isPrime</span><span class=\"params\">(<span class=\"keyword\">int</span> <span class=\"keyword\">target</span>)</span> </span>&#123;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">int</span> i = <span class=\"number\">0</span>;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">if</span> (<span class=\"keyword\">target</span> &lt;= <span class=\"number\">1</span>) &#123;</span><br><span class=\"line\">        printf(<span class=\"string\">&quot;illegal input!\\n&quot;</span>);<span class=\"comment\">//素数定义</span></span><br><span class=\"line\">        <span class=\"keyword\">return</span> <span class=\"number\">-1</span>;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">for</span> (i = <span class=\"number\">2</span>; i &lt;= <span class=\"keyword\">target</span> / <span class=\"number\">2</span>; i++) &#123;</span><br><span class=\"line\">        <span class=\"keyword\">if</span> (<span class=\"keyword\">target</span> % i == <span class=\"number\">0</span>)</span><br><span class=\"line\">            <span class=\"keyword\">return</span> <span class=\"number\">0</span>;<span class=\"comment\">//不是素数直接返回0</span></span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">return</span> <span class=\"number\">1</span>;<span class=\"comment\">//是素数返回1</span></span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<h2 id=\"求解范围改进\"><a href=\"#求解范围改进\" class=\"headerlink\" title=\"求解范围改进\"></a>求解范围改进</h2><blockquote>\n<p>在上面的基础上，其实不需要遍历到 $\\frac{n}{2}$，只需要到 $\\sqrt{n}$（包含 $\\sqrt{n}$） 就可以了。</p>\n<ul>\n<li><strong>为什么只需要检查到</strong> $\\sqrt{n}$<strong>？</strong><ol>\n<li><strong>因数成对出现</strong>：</li>\n</ol>\n<ul>\n<li>如果 <em>n</em> 不是质数，那么它可以分解为两个因数的乘积，即 <em>n</em>&#x3D;_a_×_b_。</li>\n<li>假设 _a_≤_b_，那么一定有 <em>a_≤_n</em> 且 _b_≥_n_。</li>\n<li>因此，如果 <em>n</em> 有大于 <em>n</em> 的因数 _b_，那么它必然有一个小于或等于 <em>n</em> 的因数 _a_。</li>\n</ul>\n<ol start=\"2\">\n<li><strong>只需检查较小的因数</strong>：</li>\n</ol>\n<ul>\n<li>如果 <em>n</em> 能被某个数 <em>i</em> 整除（即 <em>n</em>%<em>i</em>&#x3D;&#x3D;0），那么 <em>i</em> 就是 <em>n</em> 的一个因数。</li>\n<li>根据上述性质，如果 <em>n</em> 有大于 <em>n</em> 的因数，那么它必然已经被小于或等于 <em>n</em> 的因数检查过了。</li>\n</ul>\n<ol start=\"3\">\n<li><strong>举例说明</strong>：</li>\n</ol>\n<ul>\n<li>假设 <em>n</em>&#x3D;36， $\\sqrt{36}$&#x3D;6。</li>\n<li>检查 2 到 6 的整数：</li>\n<li>2 是 36 的因数（36%2&#x3D;&#x3D;0），因此 36 不是质数。</li>\n<li>如果继续检查 4 和 6，会发现它们也是 36 的因数，但已经不需要了，因为 2 已经证明了 36 不是质数。</li>\n</ul>\n</li>\n</ul>\n</blockquote>\n<figure class=\"highlight aspectj\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">int</span> <span class=\"title\">isPrime</span><span class=\"params\">(<span class=\"keyword\">int</span> <span class=\"keyword\">target</span>)</span> </span>&#123;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">int</span> i = <span class=\"number\">0</span>;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">if</span> (<span class=\"keyword\">target</span> &lt;= <span class=\"number\">1</span>) &#123;</span><br><span class=\"line\">        printf(<span class=\"string\">&quot;illegal input!\\n&quot;</span>);<span class=\"comment\">//素数定义</span></span><br><span class=\"line\">        <span class=\"keyword\">return</span> <span class=\"number\">-1</span>;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">for</span> (i = <span class=\"number\">2</span>; i &lt;= (<span class=\"keyword\">int</span>)sqrt(<span class=\"keyword\">target</span>); i++) &#123;</span><br><span class=\"line\">        <span class=\"keyword\">if</span> (<span class=\"keyword\">target</span> % i == <span class=\"number\">0</span>)</span><br><span class=\"line\">            <span class=\"keyword\">return</span> <span class=\"number\">0</span>;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">return</span> <span class=\"number\">1</span>;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<h1 id=\"用素数表来判断素数\"><a href=\"#用素数表来判断素数\" class=\"headerlink\" title=\"用素数表来判断素数\"></a><strong>用素数表来判断素数</strong></h1><blockquote>\n<p>从第二种方法开始，我们都是先完成判断素数数组，然后用二分法去查找判断数组<br>这里说一下以下三种方法牵扯的概念：</p>\n<ul>\n<li>范围：1 ~ 范围上限 N</li>\n<li>范围上限 N：判断素数需要用户输入随机素数，这个随机素数的范围是 1 ~ N</li>\n<li>判断素数数组：将数组的 <code>下标</code> 与 <code>1 ~ N</code> 的自然数一一对应起来。 判断 1 到 N 的自然数是否为素数，其实就是判断数组的下标是否为素数，如果是 给这个下标所对应的判断素数数组元素赋 1，否则赋 0 比如：我要判断 3 是否为素数，我们就找到 <code>判断素数数组isPrime</code> 中的下标为 3 的元素，即：<code>isPrime[3]</code> 如果 <code>3</code> 是素数 ， 赋值 1，即 <code>isPrime[3] = 1</code> <code>如果 3 不是素数，赋值0 ，即isPrime[3] = 0</code> 这样我们在用二分法查找时，查找数组下标就可以，找到下标后返回下标对应的判断素数数组的值。 如果是 1 说明下标对应的自然数是素数，否则不是</li>\n<li>思路:如果一个数不能整除比它小的任何素数，那么这个数就是素数 这种“打印”素数表的方法效率很低，不推荐使用，可以学习思想</li>\n</ul>\n</blockquote>\n<figure class=\"highlight aspectj\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">//target：输入的要查找的数</span></span><br><span class=\"line\"><span class=\"comment\">//count：当前已知的素数个数</span></span><br><span class=\"line\"><span class=\"comment\">//PrimeArray：存放素数的数组</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">int</span> <span class=\"title\">isPrime</span><span class=\"params\">(<span class=\"keyword\">int</span> <span class=\"keyword\">target</span>, <span class=\"keyword\">int</span> count, <span class=\"keyword\">int</span>* PrimeArray)</span> </span>&#123;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">int</span> i = <span class=\"number\">0</span>;</span><br><span class=\"line\">    <span class=\"keyword\">for</span> (i = <span class=\"number\">0</span>; i &lt; count; i++) &#123;</span><br><span class=\"line\">        <span class=\"keyword\">if</span> (<span class=\"keyword\">target</span> % PrimeArray[i] == <span class=\"number\">0</span>)</span><br><span class=\"line\">            <span class=\"keyword\">return</span> <span class=\"number\">0</span>;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">return</span> <span class=\"number\">1</span>;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<h1 id=\"普通筛法——埃拉托斯特尼-Eratosthenes-筛法\"><a href=\"#普通筛法——埃拉托斯特尼-Eratosthenes-筛法\" class=\"headerlink\" title=\"普通筛法——埃拉托斯特尼(Eratosthenes)筛法\"></a><strong>普通筛法——埃拉托斯特尼(Eratosthenes)筛法</strong></h1><blockquote>\n<p><strong>思路</strong>:</p>\n<ol>\n<li>我们的想法是，创建一个比范围上限大 1 的数组，我们只关注下标为 1 ~ N（要求的上限） 的数组元素与数组下标（一一对应）。</li>\n<li>将数组初始化为 1。然后用 for 循环，遍历范围为： $[2,\\sqrt{N}]$。如果数组元素为 1，则说明这个数组元素的下标所对应的数是素数。</li>\n<li>随后我们将这个下标（除 1 以外）的整数倍所对应的数组元素全部置为 0，也就是判断其为非素数。 这样，我们就知道了范围内（1 ~ 范围上限 N）所有数是素数（下标对应的数组元素值为 1）或不是素数（下标对应的数组元素值为 0）</li>\n<li>用百度百科对埃拉托斯特尼筛法简单描述：<strong>要得到自然数 n 以内的全部素数，必须把不大于 的所有素数的倍数剔除，剩下的就是素数。</strong></li>\n</ol>\n</blockquote>\n<figure class=\"highlight cpp\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">//                 判断素数的数组    范围上限N</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"type\">void</span> <span class=\"title\">Eratprime</span><span class=\"params\">(<span class=\"type\">int</span>* isprime, <span class=\"type\">int</span> upper_board)</span> </span>&#123;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"type\">int</span> i = <span class=\"number\">0</span>;</span><br><span class=\"line\">    <span class=\"type\">int</span> j = <span class=\"number\">0</span>;</span><br><span class=\"line\">    <span class=\"comment\">//初始化isprime</span></span><br><span class=\"line\">    <span class=\"keyword\">for</span> (i = <span class=\"number\">2</span>; i &lt;= upper_board; i++)</span><br><span class=\"line\">        isprime[i] = <span class=\"number\">1</span>;</span><br><span class=\"line\"></span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">for</span> (i = <span class=\"number\">2</span>; i &lt; (<span class=\"type\">int</span>)<span class=\"built_in\">sqrt</span>(upper_board); i++) &#123;</span><br><span class=\"line\">        <span class=\"keyword\">if</span> (isprime[i]) &#123;</span><br><span class=\"line\">            isprime[i] = <span class=\"number\">1</span>;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        <span class=\"keyword\">for</span> (j = <span class=\"number\">2</span>; i * j &lt;= upper_board; j++) &#123;<span class=\"comment\">//素数的n倍（n &gt;= 2）不是素数</span></span><br><span class=\"line\">            isprime[i * j] = <span class=\"number\">0</span>;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<h1 id=\"线性筛法——欧拉筛法\"><a href=\"#线性筛法——欧拉筛法\" class=\"headerlink\" title=\"线性筛法——欧拉筛法\"></a><strong>线性筛法——欧拉筛法</strong></h1><blockquote>\n<p><strong>思路</strong>: 我们再思考一下上面的埃拉托斯特尼筛法，会发现，在“剔除“非素数时，有些合数会重复赋值。这样就会增加复杂度，降低效率。 比如：范围上限 N &#x3D; 16 时</p>\n<ul>\n<li>2 是素数，剔除”2 的倍数“，它们是：4，6， 8，10， 12， 14， 16</li>\n<li>3 是素数，剔除”3 的倍数”，它们是，6，9，12，15<br>6，12 是重复的。如何减少重复呢？</li>\n</ul>\n</blockquote>\n<figure class=\"highlight gradle\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">void</span> PrimeList(<span class=\"keyword\">int</span>* Prime, bool* isPrime, <span class=\"keyword\">int</span> n) &#123;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">int</span> i = <span class=\"number\">0</span>;</span><br><span class=\"line\">    <span class=\"keyword\">int</span> j = <span class=\"number\">0</span>;</span><br><span class=\"line\">    <span class=\"keyword\">int</span> <span class=\"keyword\">count</span> = <span class=\"number\">0</span>;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">if</span> (isPrime != <span class=\"keyword\">NULL</span>) &#123;<span class=\"comment\">//确保isPrime不是空指针</span></span><br><span class=\"line\">        <span class=\"comment\">//将isPrime数组初始化为 1</span></span><br><span class=\"line\">        <span class=\"keyword\">for</span> (i = <span class=\"number\">2</span>; i &lt;= N; i++) &#123;</span><br><span class=\"line\">            isPrime[i] = <span class=\"keyword\">true</span>;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">if</span> (isPrime != <span class=\"keyword\">NULL</span> &amp;&amp; Prime != <span class=\"keyword\">NULL</span>) &#123;</span><br><span class=\"line\">        <span class=\"comment\">//从2遍历到范围上限N</span></span><br><span class=\"line\">        <span class=\"keyword\">for</span> (i = <span class=\"number\">2</span>; i &lt;= N; i++) &#123;</span><br><span class=\"line\">            <span class=\"keyword\">if</span> (isPrime[i])<span class=\"comment\">//如果下标（下标对应着1 ~ 范围上限N）对应的isPrime值没有被置为false，说明这个数是素数，将下标放入素数数组</span></span><br><span class=\"line\">                Prime[<span class=\"keyword\">count</span>++] = i;</span><br><span class=\"line\">            <span class=\"comment\">//循环控制表达式的意义：j小于等于素数数组的个数 或 素数数组中的每一个素数与 i 的积小于范围上限N</span></span><br><span class=\"line\">            <span class=\"keyword\">for</span> (j = <span class=\"number\">0</span>; (j &lt; <span class=\"keyword\">count</span>) &amp;&amp; (Prime[j] * (<span class=\"keyword\">long</span> <span class=\"keyword\">long</span>)i) &lt;= N; j++)<span class=\"comment\">//将i强制转换是因为vs上有warning，要求转换为宽类型防止算术溢出。数据上不产生影响</span></span><br><span class=\"line\">            &#123;</span><br><span class=\"line\">                isPrime[i * Prime[j]] = <span class=\"keyword\">false</span>;<span class=\"comment\">//每一个素数的 i 倍（i &gt;= 2）都不是素数，置为false</span></span><br><span class=\"line\"></span><br><span class=\"line\">                <span class=\"comment\">//这个是欧拉筛法的核心，它可以减少非素数置false的重复率</span></span><br><span class=\"line\">                <span class=\"comment\">//意义是将每一个合数（非素数）拆成 2（最小因数）与最大因数 的乘积</span></span><br><span class=\"line\">                <span class=\"keyword\">if</span> (i % Prime[j] == <span class=\"number\">0</span>)</span><br><span class=\"line\">                    <span class=\"keyword\">break</span>;</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n","excerpt":"","more":"<h1 id=\"2025-03-04-判断素数的方法\"><a href=\"#2025-03-04-判断素数的方法\" class=\"headerlink\" title=\"2025-03-04-判断素数的方法\"></a>2025-03-04-判断素数的方法</h1><blockquote>\n<p>参考博客<br><a href=\"https://blog.csdn.net/afei__/article/details/80638460\">判断一个数是不是质数(素数)，3 种方式介绍_判断一个数是否为素数-CSDN 博客</a><br><a href=\"https://github.com/hairrrrr/C-CrashCourse/blob/master/content/c-notes/%E4%BD%A0%E4%B8%8D%E7%9F%A5%E9%81%93%E7%9A%84%E5%87%A0%E7%A7%8D%E7%B4%A0%E6%95%B0%E5%88%A4%E6%96%AD%E6%96%B9%E6%B3%95%EF%BC%8C%E7%94%B1%E6%B5%85%E5%85%A5%E6%B7%B1%EF%BC%8C%E8%AF%A6%E8%A7%A3.md\">C-CrashCourse&#x2F;content&#x2F;c-notes&#x2F;你不知道的几种素数判断方法，由浅入深，详解.md at master · hairrrrr&#x2F;C-CrashCourse</a></p>\n</blockquote>\n<h1 id=\"暴力求解\"><a href=\"#暴力求解\" class=\"headerlink\" title=\"暴力求解\"></a><strong>暴力求解</strong></h1><blockquote>\n<p>根据素数的定义思考。素数是大于 1 的自然数，除了 1 和自身外，其他数都不是它的因子。 那我们就可以用一个循环，从 2 开始遍历到这个数减去 1，如果这个数都不能被整除，那么这个数就是素数。 也就是说： 给定一个数 n , i 从 2 开始取值，直到 n - 1(取整数),如果 n % i !&#x3D; 0 , n 就是素数 进一步思考，有必要遍历到 n - 1 吗？ 除了 1 以外，任何合数最小的因子就是 2，那最大的因子就是 n&#x2F;2 那我们就遍历到 n&#x2F;2 就足够了</p>\n</blockquote>\n<figure class=\"highlight aspectj\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">int</span> <span class=\"title\">isPrime</span><span class=\"params\">(<span class=\"keyword\">int</span> <span class=\"keyword\">target</span>)</span> </span>&#123;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">int</span> i = <span class=\"number\">0</span>;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">if</span> (<span class=\"keyword\">target</span> &lt;= <span class=\"number\">1</span>) &#123;</span><br><span class=\"line\">        printf(<span class=\"string\">&quot;illegal input!\\n&quot;</span>);<span class=\"comment\">//素数定义</span></span><br><span class=\"line\">        <span class=\"keyword\">return</span> <span class=\"number\">-1</span>;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">for</span> (i = <span class=\"number\">2</span>; i &lt;= <span class=\"keyword\">target</span> / <span class=\"number\">2</span>; i++) &#123;</span><br><span class=\"line\">        <span class=\"keyword\">if</span> (<span class=\"keyword\">target</span> % i == <span class=\"number\">0</span>)</span><br><span class=\"line\">            <span class=\"keyword\">return</span> <span class=\"number\">0</span>;<span class=\"comment\">//不是素数直接返回0</span></span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">return</span> <span class=\"number\">1</span>;<span class=\"comment\">//是素数返回1</span></span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<h2 id=\"求解范围改进\"><a href=\"#求解范围改进\" class=\"headerlink\" title=\"求解范围改进\"></a>求解范围改进</h2><blockquote>\n<p>在上面的基础上，其实不需要遍历到 $\\frac{n}{2}$，只需要到 $\\sqrt{n}$（包含 $\\sqrt{n}$） 就可以了。</p>\n<ul>\n<li><strong>为什么只需要检查到</strong> $\\sqrt{n}$<strong>？</strong><ol>\n<li><strong>因数成对出现</strong>：</li>\n</ol>\n<ul>\n<li>如果 <em>n</em> 不是质数，那么它可以分解为两个因数的乘积，即 <em>n</em>&#x3D;_a_×_b_。</li>\n<li>假设 _a_≤_b_，那么一定有 <em>a_≤_n</em> 且 _b_≥_n_。</li>\n<li>因此，如果 <em>n</em> 有大于 <em>n</em> 的因数 _b_，那么它必然有一个小于或等于 <em>n</em> 的因数 _a_。</li>\n</ul>\n<ol start=\"2\">\n<li><strong>只需检查较小的因数</strong>：</li>\n</ol>\n<ul>\n<li>如果 <em>n</em> 能被某个数 <em>i</em> 整除（即 <em>n</em>%<em>i</em>&#x3D;&#x3D;0），那么 <em>i</em> 就是 <em>n</em> 的一个因数。</li>\n<li>根据上述性质，如果 <em>n</em> 有大于 <em>n</em> 的因数，那么它必然已经被小于或等于 <em>n</em> 的因数检查过了。</li>\n</ul>\n<ol start=\"3\">\n<li><strong>举例说明</strong>：</li>\n</ol>\n<ul>\n<li>假设 <em>n</em>&#x3D;36， $\\sqrt{36}$&#x3D;6。</li>\n<li>检查 2 到 6 的整数：</li>\n<li>2 是 36 的因数（36%2&#x3D;&#x3D;0），因此 36 不是质数。</li>\n<li>如果继续检查 4 和 6，会发现它们也是 36 的因数，但已经不需要了，因为 2 已经证明了 36 不是质数。</li>\n</ul>\n</li>\n</ul>\n</blockquote>\n<figure class=\"highlight aspectj\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">int</span> <span class=\"title\">isPrime</span><span class=\"params\">(<span class=\"keyword\">int</span> <span class=\"keyword\">target</span>)</span> </span>&#123;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">int</span> i = <span class=\"number\">0</span>;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">if</span> (<span class=\"keyword\">target</span> &lt;= <span class=\"number\">1</span>) &#123;</span><br><span class=\"line\">        printf(<span class=\"string\">&quot;illegal input!\\n&quot;</span>);<span class=\"comment\">//素数定义</span></span><br><span class=\"line\">        <span class=\"keyword\">return</span> <span class=\"number\">-1</span>;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">for</span> (i = <span class=\"number\">2</span>; i &lt;= (<span class=\"keyword\">int</span>)sqrt(<span class=\"keyword\">target</span>); i++) &#123;</span><br><span class=\"line\">        <span class=\"keyword\">if</span> (<span class=\"keyword\">target</span> % i == <span class=\"number\">0</span>)</span><br><span class=\"line\">            <span class=\"keyword\">return</span> <span class=\"number\">0</span>;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">return</span> <span class=\"number\">1</span>;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<h1 id=\"用素数表来判断素数\"><a href=\"#用素数表来判断素数\" class=\"headerlink\" title=\"用素数表来判断素数\"></a><strong>用素数表来判断素数</strong></h1><blockquote>\n<p>从第二种方法开始，我们都是先完成判断素数数组，然后用二分法去查找判断数组<br>这里说一下以下三种方法牵扯的概念：</p>\n<ul>\n<li>范围：1 ~ 范围上限 N</li>\n<li>范围上限 N：判断素数需要用户输入随机素数，这个随机素数的范围是 1 ~ N</li>\n<li>判断素数数组：将数组的 <code>下标</code> 与 <code>1 ~ N</code> 的自然数一一对应起来。 判断 1 到 N 的自然数是否为素数，其实就是判断数组的下标是否为素数，如果是 给这个下标所对应的判断素数数组元素赋 1，否则赋 0 比如：我要判断 3 是否为素数，我们就找到 <code>判断素数数组isPrime</code> 中的下标为 3 的元素，即：<code>isPrime[3]</code> 如果 <code>3</code> 是素数 ， 赋值 1，即 <code>isPrime[3] = 1</code> <code>如果 3 不是素数，赋值0 ，即isPrime[3] = 0</code> 这样我们在用二分法查找时，查找数组下标就可以，找到下标后返回下标对应的判断素数数组的值。 如果是 1 说明下标对应的自然数是素数，否则不是</li>\n<li>思路:如果一个数不能整除比它小的任何素数，那么这个数就是素数 这种“打印”素数表的方法效率很低，不推荐使用，可以学习思想</li>\n</ul>\n</blockquote>\n<figure class=\"highlight aspectj\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">//target：输入的要查找的数</span></span><br><span class=\"line\"><span class=\"comment\">//count：当前已知的素数个数</span></span><br><span class=\"line\"><span class=\"comment\">//PrimeArray：存放素数的数组</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">int</span> <span class=\"title\">isPrime</span><span class=\"params\">(<span class=\"keyword\">int</span> <span class=\"keyword\">target</span>, <span class=\"keyword\">int</span> count, <span class=\"keyword\">int</span>* PrimeArray)</span> </span>&#123;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">int</span> i = <span class=\"number\">0</span>;</span><br><span class=\"line\">    <span class=\"keyword\">for</span> (i = <span class=\"number\">0</span>; i &lt; count; i++) &#123;</span><br><span class=\"line\">        <span class=\"keyword\">if</span> (<span class=\"keyword\">target</span> % PrimeArray[i] == <span class=\"number\">0</span>)</span><br><span class=\"line\">            <span class=\"keyword\">return</span> <span class=\"number\">0</span>;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">return</span> <span class=\"number\">1</span>;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<h1 id=\"普通筛法——埃拉托斯特尼-Eratosthenes-筛法\"><a href=\"#普通筛法——埃拉托斯特尼-Eratosthenes-筛法\" class=\"headerlink\" title=\"普通筛法——埃拉托斯特尼(Eratosthenes)筛法\"></a><strong>普通筛法——埃拉托斯特尼(Eratosthenes)筛法</strong></h1><blockquote>\n<p><strong>思路</strong>:</p>\n<ol>\n<li>我们的想法是，创建一个比范围上限大 1 的数组，我们只关注下标为 1 ~ N（要求的上限） 的数组元素与数组下标（一一对应）。</li>\n<li>将数组初始化为 1。然后用 for 循环，遍历范围为： $[2,\\sqrt{N}]$。如果数组元素为 1，则说明这个数组元素的下标所对应的数是素数。</li>\n<li>随后我们将这个下标（除 1 以外）的整数倍所对应的数组元素全部置为 0，也就是判断其为非素数。 这样，我们就知道了范围内（1 ~ 范围上限 N）所有数是素数（下标对应的数组元素值为 1）或不是素数（下标对应的数组元素值为 0）</li>\n<li>用百度百科对埃拉托斯特尼筛法简单描述：<strong>要得到自然数 n 以内的全部素数，必须把不大于 的所有素数的倍数剔除，剩下的就是素数。</strong></li>\n</ol>\n</blockquote>\n<figure class=\"highlight cpp\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">//                 判断素数的数组    范围上限N</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"type\">void</span> <span class=\"title\">Eratprime</span><span class=\"params\">(<span class=\"type\">int</span>* isprime, <span class=\"type\">int</span> upper_board)</span> </span>&#123;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"type\">int</span> i = <span class=\"number\">0</span>;</span><br><span class=\"line\">    <span class=\"type\">int</span> j = <span class=\"number\">0</span>;</span><br><span class=\"line\">    <span class=\"comment\">//初始化isprime</span></span><br><span class=\"line\">    <span class=\"keyword\">for</span> (i = <span class=\"number\">2</span>; i &lt;= upper_board; i++)</span><br><span class=\"line\">        isprime[i] = <span class=\"number\">1</span>;</span><br><span class=\"line\"></span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">for</span> (i = <span class=\"number\">2</span>; i &lt; (<span class=\"type\">int</span>)<span class=\"built_in\">sqrt</span>(upper_board); i++) &#123;</span><br><span class=\"line\">        <span class=\"keyword\">if</span> (isprime[i]) &#123;</span><br><span class=\"line\">            isprime[i] = <span class=\"number\">1</span>;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        <span class=\"keyword\">for</span> (j = <span class=\"number\">2</span>; i * j &lt;= upper_board; j++) &#123;<span class=\"comment\">//素数的n倍（n &gt;= 2）不是素数</span></span><br><span class=\"line\">            isprime[i * j] = <span class=\"number\">0</span>;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<h1 id=\"线性筛法——欧拉筛法\"><a href=\"#线性筛法——欧拉筛法\" class=\"headerlink\" title=\"线性筛法——欧拉筛法\"></a><strong>线性筛法——欧拉筛法</strong></h1><blockquote>\n<p><strong>思路</strong>: 我们再思考一下上面的埃拉托斯特尼筛法，会发现，在“剔除“非素数时，有些合数会重复赋值。这样就会增加复杂度，降低效率。 比如：范围上限 N &#x3D; 16 时</p>\n<ul>\n<li>2 是素数，剔除”2 的倍数“，它们是：4，6， 8，10， 12， 14， 16</li>\n<li>3 是素数，剔除”3 的倍数”，它们是，6，9，12，15<br>6，12 是重复的。如何减少重复呢？</li>\n</ul>\n</blockquote>\n<figure class=\"highlight gradle\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">void</span> PrimeList(<span class=\"keyword\">int</span>* Prime, bool* isPrime, <span class=\"keyword\">int</span> n) &#123;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">int</span> i = <span class=\"number\">0</span>;</span><br><span class=\"line\">    <span class=\"keyword\">int</span> j = <span class=\"number\">0</span>;</span><br><span class=\"line\">    <span class=\"keyword\">int</span> <span class=\"keyword\">count</span> = <span class=\"number\">0</span>;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">if</span> (isPrime != <span class=\"keyword\">NULL</span>) &#123;<span class=\"comment\">//确保isPrime不是空指针</span></span><br><span class=\"line\">        <span class=\"comment\">//将isPrime数组初始化为 1</span></span><br><span class=\"line\">        <span class=\"keyword\">for</span> (i = <span class=\"number\">2</span>; i &lt;= N; i++) &#123;</span><br><span class=\"line\">            isPrime[i] = <span class=\"keyword\">true</span>;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">if</span> (isPrime != <span class=\"keyword\">NULL</span> &amp;&amp; Prime != <span class=\"keyword\">NULL</span>) &#123;</span><br><span class=\"line\">        <span class=\"comment\">//从2遍历到范围上限N</span></span><br><span class=\"line\">        <span class=\"keyword\">for</span> (i = <span class=\"number\">2</span>; i &lt;= N; i++) &#123;</span><br><span class=\"line\">            <span class=\"keyword\">if</span> (isPrime[i])<span class=\"comment\">//如果下标（下标对应着1 ~ 范围上限N）对应的isPrime值没有被置为false，说明这个数是素数，将下标放入素数数组</span></span><br><span class=\"line\">                Prime[<span class=\"keyword\">count</span>++] = i;</span><br><span class=\"line\">            <span class=\"comment\">//循环控制表达式的意义：j小于等于素数数组的个数 或 素数数组中的每一个素数与 i 的积小于范围上限N</span></span><br><span class=\"line\">            <span class=\"keyword\">for</span> (j = <span class=\"number\">0</span>; (j &lt; <span class=\"keyword\">count</span>) &amp;&amp; (Prime[j] * (<span class=\"keyword\">long</span> <span class=\"keyword\">long</span>)i) &lt;= N; j++)<span class=\"comment\">//将i强制转换是因为vs上有warning，要求转换为宽类型防止算术溢出。数据上不产生影响</span></span><br><span class=\"line\">            &#123;</span><br><span class=\"line\">                isPrime[i * Prime[j]] = <span class=\"keyword\">false</span>;<span class=\"comment\">//每一个素数的 i 倍（i &gt;= 2）都不是素数，置为false</span></span><br><span class=\"line\"></span><br><span class=\"line\">                <span class=\"comment\">//这个是欧拉筛法的核心，它可以减少非素数置false的重复率</span></span><br><span class=\"line\">                <span class=\"comment\">//意义是将每一个合数（非素数）拆成 2（最小因数）与最大因数 的乘积</span></span><br><span class=\"line\">                <span class=\"keyword\">if</span> (i % Prime[j] == <span class=\"number\">0</span>)</span><br><span class=\"line\">                    <span class=\"keyword\">break</span>;</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n"},{"title":"2025-03-14-Google 检索技巧","date":"2025-03-13T16:00:00.000Z","_content":"\n> 参考博客\n> [如何像专家一样高效使用 Google 搜索](https://www.freecodecamp.org/chinese/news/how-to-google-like-a-pro-10-tips-for-effective-googling/)\n> [13 个高效使用 Google 搜索的技巧](https://juejin.cn/post/7054368795640463373)\n\n## 1. 使用引号精确搜索（`“ ”`）\n\n当你需要搜索特定的短语或句子时，使用双引号可以告诉 Google 只返回包含该确切内容的结果。例如：\n\n```\n搜索： \"learn JavaScript array\"\n结果： 只显示包含“learn JavaScript array”这一完整短语的内容。\n```\n\n## 2. 使用连字符排除内容（`-`）\n\n如果你希望排除某些不相关的搜索结果，可以在关键词后加上连字符。例如：\n\n```\n搜索： JavaScript -wikipedia\n结果： 排除维基百科中的相关内容。\n```\n\n## 3. 使用星号填充内容（`*`）\n\n当你只记得部分搜索内容时，可以用星号代替不确定的部分。例如：\n\n```\n搜索： Git 撤销 commit *\n结果： 显示包含“Git 撤销 commit”后跟任意单词的内容。\n```\n\n## 4. 搜索指定范围（`...`）\n\n使用“...”可以搜索指定数字范围的内容，比如年份、版本等。例如：\n\n```\n搜索： JavaScript in 2021...2022\n结果： 找到2021年到2022年之间关于JavaScript的相关内容。\n```\n\n## 5. 搜索指定站点内容（`site:`）\n\n如果你想在某个特定网站中搜索内容，可以在关键词后加上 `site:网站域名`。例如：\n\n```\n搜索： javascript Array site:w3schools.com\n结果： 在W3Schools网站中查找关于JavaScript数组的内容。\n```\n\n## 6. 搜索指定文件类型内容（`filetype:`）\n\n如果你需要查找特定文件类型的内容，比如电子书、文档等，可以使用 `filetype:` 后跟文件扩展名。例如：\n\n```\n搜索： React ebook filetype:pdf\n结果： 找到React相关的PDF电子书。\n```\n\n## 7. 查找多个关键字（`AND`）\n\n当你需要同时查找多个关键字时，可以使用 `AND` 连接它们。例如：\n\n```\n搜索： React AND CSS\n结果： 找到同时包含React和CSS的内容。\n```\n\n## 8. 查找其中一个关键字（`OR`）\n\n如果你想查找多个关键字中的任意一个，可以使用 `OR`。例如：\n\n```\n搜索： React OR Vue\n结果： 找到包含React或Vue的内容。\n```\n\n## 9. 查询关键字的定义（`define:`）\n\n如果你想知道某个单词的定义，可以在其前面加上 `define:`。例如：\n\n```\n搜索： define: JavaScript\n结果： 找到JavaScript的定义。\n```\n\n## 10. 搜索相关内容（`+`）\n\n当你想要搜索多个相关的关键词时，可以使用加号连接它们。例如：\n\n```\n搜索： CSS style+React\n结果： 找到同时包含CSS样式和React相关内容。\n```\n\n## 11. 查找相似网站（`related:`）\n\n如果你想找到与某个网站类似的其他网站，可以在其前面加上 `related:`。例如：\n\n```\n搜索： related: w3schools.com\n结果： 找到与W3Schools类似的编程学习网站。\n```\n\n## 12. 搜索指定站点内容（`site:`）\n\n与第 5 点类似，使用 `site:` 可以搜索指定站点中的内容。例如：\n\n```\n搜索： React site:github.com\n结果： 找到GitHub上关于React的内容。\n```\n\n## 13. 搜索指定时间范围（`before:`、`after:`）\n\n如果你需要查找某个时间范围内的内容，可以使用 `before:` 或 `after:`。例如：\n\n```\n搜索： after:2021 learn react\n结果： 找到2021年之后关于学习React的内容。\n```\n","source":"_posts/2025-03-14-Google检索技巧.md","raw":"---\ntitle: 2025-03-14-Google 检索技巧\ndate: 2025-03-14\ntags: 问题解决\n    \n---\n\n> 参考博客\n> [如何像专家一样高效使用 Google 搜索](https://www.freecodecamp.org/chinese/news/how-to-google-like-a-pro-10-tips-for-effective-googling/)\n> [13 个高效使用 Google 搜索的技巧](https://juejin.cn/post/7054368795640463373)\n\n## 1. 使用引号精确搜索（`“ ”`）\n\n当你需要搜索特定的短语或句子时，使用双引号可以告诉 Google 只返回包含该确切内容的结果。例如：\n\n```\n搜索： \"learn JavaScript array\"\n结果： 只显示包含“learn JavaScript array”这一完整短语的内容。\n```\n\n## 2. 使用连字符排除内容（`-`）\n\n如果你希望排除某些不相关的搜索结果，可以在关键词后加上连字符。例如：\n\n```\n搜索： JavaScript -wikipedia\n结果： 排除维基百科中的相关内容。\n```\n\n## 3. 使用星号填充内容（`*`）\n\n当你只记得部分搜索内容时，可以用星号代替不确定的部分。例如：\n\n```\n搜索： Git 撤销 commit *\n结果： 显示包含“Git 撤销 commit”后跟任意单词的内容。\n```\n\n## 4. 搜索指定范围（`...`）\n\n使用“...”可以搜索指定数字范围的内容，比如年份、版本等。例如：\n\n```\n搜索： JavaScript in 2021...2022\n结果： 找到2021年到2022年之间关于JavaScript的相关内容。\n```\n\n## 5. 搜索指定站点内容（`site:`）\n\n如果你想在某个特定网站中搜索内容，可以在关键词后加上 `site:网站域名`。例如：\n\n```\n搜索： javascript Array site:w3schools.com\n结果： 在W3Schools网站中查找关于JavaScript数组的内容。\n```\n\n## 6. 搜索指定文件类型内容（`filetype:`）\n\n如果你需要查找特定文件类型的内容，比如电子书、文档等，可以使用 `filetype:` 后跟文件扩展名。例如：\n\n```\n搜索： React ebook filetype:pdf\n结果： 找到React相关的PDF电子书。\n```\n\n## 7. 查找多个关键字（`AND`）\n\n当你需要同时查找多个关键字时，可以使用 `AND` 连接它们。例如：\n\n```\n搜索： React AND CSS\n结果： 找到同时包含React和CSS的内容。\n```\n\n## 8. 查找其中一个关键字（`OR`）\n\n如果你想查找多个关键字中的任意一个，可以使用 `OR`。例如：\n\n```\n搜索： React OR Vue\n结果： 找到包含React或Vue的内容。\n```\n\n## 9. 查询关键字的定义（`define:`）\n\n如果你想知道某个单词的定义，可以在其前面加上 `define:`。例如：\n\n```\n搜索： define: JavaScript\n结果： 找到JavaScript的定义。\n```\n\n## 10. 搜索相关内容（`+`）\n\n当你想要搜索多个相关的关键词时，可以使用加号连接它们。例如：\n\n```\n搜索： CSS style+React\n结果： 找到同时包含CSS样式和React相关内容。\n```\n\n## 11. 查找相似网站（`related:`）\n\n如果你想找到与某个网站类似的其他网站，可以在其前面加上 `related:`。例如：\n\n```\n搜索： related: w3schools.com\n结果： 找到与W3Schools类似的编程学习网站。\n```\n\n## 12. 搜索指定站点内容（`site:`）\n\n与第 5 点类似，使用 `site:` 可以搜索指定站点中的内容。例如：\n\n```\n搜索： React site:github.com\n结果： 找到GitHub上关于React的内容。\n```\n\n## 13. 搜索指定时间范围（`before:`、`after:`）\n\n如果你需要查找某个时间范围内的内容，可以使用 `before:` 或 `after:`。例如：\n\n```\n搜索： after:2021 learn react\n结果： 找到2021年之后关于学习React的内容。\n```\n","slug":"2025-03-14-Google检索技巧","published":1,"updated":"2025-09-26T12:16:03.766Z","_id":"cmg0saj3y000njm8n57u1fdqd","comments":1,"layout":"post","photos":[],"content":"<blockquote>\n<p>参考博客<br><a href=\"https://www.freecodecamp.org/chinese/news/how-to-google-like-a-pro-10-tips-for-effective-googling/\">如何像专家一样高效使用 Google 搜索</a><br><a href=\"https://juejin.cn/post/7054368795640463373\">13 个高效使用 Google 搜索的技巧</a></p>\n</blockquote>\n<h2 id=\"1-使用引号精确搜索（“-”）\"><a href=\"#1-使用引号精确搜索（“-”）\" class=\"headerlink\" title=\"1. 使用引号精确搜索（“ ”）\"></a>1. 使用引号精确搜索（<code>“ ”</code>）</h2><p>当你需要搜索特定的短语或句子时，使用双引号可以告诉 Google 只返回包含该确切内容的结果。例如：</p>\n<figure class=\"highlight ada\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">搜索： <span class=\"string\">&quot;learn JavaScript array&quot;</span></span><br><span class=\"line\">结果： 只显示包含“learn JavaScript <span class=\"keyword\">array</span>”这一完整短语的内容。</span><br></pre></td></tr></table></figure>\n\n<h2 id=\"2-使用连字符排除内容（-）\"><a href=\"#2-使用连字符排除内容（-）\" class=\"headerlink\" title=\"2. 使用连字符排除内容（-）\"></a>2. 使用连字符排除内容（<code>-</code>）</h2><p>如果你希望排除某些不相关的搜索结果，可以在关键词后加上连字符。例如：</p>\n<figure class=\"highlight mipsasm\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">搜索： <span class=\"keyword\">JavaScript </span>-wikipedia</span><br><span class=\"line\">结果： 排除维基百科中的相关内容。</span><br></pre></td></tr></table></figure>\n\n<h2 id=\"3-使用星号填充内容（-）\"><a href=\"#3-使用星号填充内容（-）\" class=\"headerlink\" title=\"3. 使用星号填充内容（*）\"></a>3. 使用星号填充内容（<code>*</code>）</h2><p>当你只记得部分搜索内容时，可以用星号代替不确定的部分。例如：</p>\n<figure class=\"highlight sql\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">搜索： Git 撤销 <span class=\"keyword\">commit</span> <span class=\"operator\">*</span></span><br><span class=\"line\">结果： 显示包含“Git 撤销 <span class=\"keyword\">commit</span>”后跟任意单词的内容。</span><br></pre></td></tr></table></figure>\n\n<h2 id=\"4-搜索指定范围（-）\"><a href=\"#4-搜索指定范围（-）\" class=\"headerlink\" title=\"4. 搜索指定范围（...）\"></a>4. 搜索指定范围（<code>...</code>）</h2><p>使用“…”可以搜索指定数字范围的内容，比如年份、版本等。例如：</p>\n<figure class=\"highlight jboss-cli\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">搜索： JavaScript in 2021.<span class=\"string\">..2022</span></span><br><span class=\"line\">结果： 找到2021年到2022年之间关于JavaScript的相关内容。</span><br></pre></td></tr></table></figure>\n\n<h2 id=\"5-搜索指定站点内容（site-）\"><a href=\"#5-搜索指定站点内容（site-）\" class=\"headerlink\" title=\"5. 搜索指定站点内容（site:）\"></a>5. 搜索指定站点内容（<code>site:</code>）</h2><p>如果你想在某个特定网站中搜索内容，可以在关键词后加上 <code>site:网站域名</code>。例如：</p>\n<figure class=\"highlight ada\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">搜索： javascript <span class=\"keyword\">Array</span> site:w3schools.com</span><br><span class=\"line\">结果： 在W3Schools网站中查找关于JavaScript数组的内容。</span><br></pre></td></tr></table></figure>\n\n<h2 id=\"6-搜索指定文件类型内容（filetype-）\"><a href=\"#6-搜索指定文件类型内容（filetype-）\" class=\"headerlink\" title=\"6. 搜索指定文件类型内容（filetype:）\"></a>6. 搜索指定文件类型内容（<code>filetype:</code>）</h2><p>如果你需要查找特定文件类型的内容，比如电子书、文档等，可以使用 <code>filetype:</code> 后跟文件扩展名。例如：</p>\n<figure class=\"highlight elm\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">搜索： <span class=\"type\">React</span> ebook file<span class=\"keyword\">type</span>:pdf</span><br><span class=\"line\">结果： 找到<span class=\"type\">React</span>相关的<span class=\"type\">PDF</span>电子书。</span><br></pre></td></tr></table></figure>\n\n<h2 id=\"7-查找多个关键字（AND）\"><a href=\"#7-查找多个关键字（AND）\" class=\"headerlink\" title=\"7. 查找多个关键字（AND）\"></a>7. 查找多个关键字（<code>AND</code>）</h2><p>当你需要同时查找多个关键字时，可以使用 <code>AND</code> 连接它们。例如：</p>\n<figure class=\"highlight armasm\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">搜索： React <span class=\"keyword\">AND</span> CSS</span><br><span class=\"line\">结果： 找到同时包含React和CSS的内容。</span><br></pre></td></tr></table></figure>\n\n<h2 id=\"8-查找其中一个关键字（OR）\"><a href=\"#8-查找其中一个关键字（OR）\" class=\"headerlink\" title=\"8. 查找其中一个关键字（OR）\"></a>8. 查找其中一个关键字（<code>OR</code>）</h2><p>如果你想查找多个关键字中的任意一个，可以使用 <code>OR</code>。例如：</p>\n<figure class=\"highlight mipsasm\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">搜索： React <span class=\"keyword\">OR </span>Vue</span><br><span class=\"line\">结果： 找到包含React或Vue的内容。</span><br></pre></td></tr></table></figure>\n\n<h2 id=\"9-查询关键字的定义（define-）\"><a href=\"#9-查询关键字的定义（define-）\" class=\"headerlink\" title=\"9. 查询关键字的定义（define:）\"></a>9. 查询关键字的定义（<code>define:</code>）</h2><p>如果你想知道某个单词的定义，可以在其前面加上 <code>define:</code>。例如：</p>\n<figure class=\"highlight puppet\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">搜索： <span class=\"keyword\">define</span>: <span class=\"section\">JavaScript</span></span><br><span class=\"line\">结果： 找到JavaScript的定义。</span><br></pre></td></tr></table></figure>\n\n<h2 id=\"10-搜索相关内容（-）\"><a href=\"#10-搜索相关内容（-）\" class=\"headerlink\" title=\"10. 搜索相关内容（+）\"></a>10. 搜索相关内容（<code>+</code>）</h2><p>当你想要搜索多个相关的关键词时，可以使用加号连接它们。例如：</p>\n<figure class=\"highlight maxima\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">搜索： CSS <span class=\"built_in\">style</span>+React</span><br><span class=\"line\">结果： 找到同时包含CSS样式和React相关内容。</span><br></pre></td></tr></table></figure>\n\n<h2 id=\"11-查找相似网站（related-）\"><a href=\"#11-查找相似网站（related-）\" class=\"headerlink\" title=\"11. 查找相似网站（related:）\"></a>11. 查找相似网站（<code>related:</code>）</h2><p>如果你想找到与某个网站类似的其他网站，可以在其前面加上 <code>related:</code>。例如：</p>\n<figure class=\"highlight nestedtext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"attribute\">搜索： related</span><span class=\"punctuation\">:</span> <span class=\"string\">w3schools.com</span></span><br><span class=\"line\">结果： 找到与W3Schools类似的编程学习网站。</span><br></pre></td></tr></table></figure>\n\n<h2 id=\"12-搜索指定站点内容（site-）\"><a href=\"#12-搜索指定站点内容（site-）\" class=\"headerlink\" title=\"12. 搜索指定站点内容（site:）\"></a>12. 搜索指定站点内容（<code>site:</code>）</h2><p>与第 5 点类似，使用 <code>site:</code> 可以搜索指定站点中的内容。例如：</p>\n<figure class=\"highlight stylus\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">搜索： React site:github<span class=\"selector-class\">.com</span></span><br><span class=\"line\">结果： 找到GitHub上关于React的内容。</span><br></pre></td></tr></table></figure>\n\n<h2 id=\"13-搜索指定时间范围（before-、after-）\"><a href=\"#13-搜索指定时间范围（before-、after-）\" class=\"headerlink\" title=\"13. 搜索指定时间范围（before:、after:）\"></a>13. 搜索指定时间范围（<code>before:</code>、<code>after:</code>）</h2><p>如果你需要查找某个时间范围内的内容，可以使用 <code>before:</code> 或 <code>after:</code>。例如：</p>\n<figure class=\"highlight applescript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">搜索： <span class=\"keyword\">after</span>:<span class=\"number\">2021</span> learn react</span><br><span class=\"line\">结果： 找到<span class=\"number\">2021</span>年之后关于学习React的内容。</span><br></pre></td></tr></table></figure>\n","excerpt":"","more":"<blockquote>\n<p>参考博客<br><a href=\"https://www.freecodecamp.org/chinese/news/how-to-google-like-a-pro-10-tips-for-effective-googling/\">如何像专家一样高效使用 Google 搜索</a><br><a href=\"https://juejin.cn/post/7054368795640463373\">13 个高效使用 Google 搜索的技巧</a></p>\n</blockquote>\n<h2 id=\"1-使用引号精确搜索（“-”）\"><a href=\"#1-使用引号精确搜索（“-”）\" class=\"headerlink\" title=\"1. 使用引号精确搜索（“ ”）\"></a>1. 使用引号精确搜索（<code>“ ”</code>）</h2><p>当你需要搜索特定的短语或句子时，使用双引号可以告诉 Google 只返回包含该确切内容的结果。例如：</p>\n<figure class=\"highlight ada\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">搜索： <span class=\"string\">&quot;learn JavaScript array&quot;</span></span><br><span class=\"line\">结果： 只显示包含“learn JavaScript <span class=\"keyword\">array</span>”这一完整短语的内容。</span><br></pre></td></tr></table></figure>\n\n<h2 id=\"2-使用连字符排除内容（-）\"><a href=\"#2-使用连字符排除内容（-）\" class=\"headerlink\" title=\"2. 使用连字符排除内容（-）\"></a>2. 使用连字符排除内容（<code>-</code>）</h2><p>如果你希望排除某些不相关的搜索结果，可以在关键词后加上连字符。例如：</p>\n<figure class=\"highlight mipsasm\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">搜索： <span class=\"keyword\">JavaScript </span>-wikipedia</span><br><span class=\"line\">结果： 排除维基百科中的相关内容。</span><br></pre></td></tr></table></figure>\n\n<h2 id=\"3-使用星号填充内容（-）\"><a href=\"#3-使用星号填充内容（-）\" class=\"headerlink\" title=\"3. 使用星号填充内容（*）\"></a>3. 使用星号填充内容（<code>*</code>）</h2><p>当你只记得部分搜索内容时，可以用星号代替不确定的部分。例如：</p>\n<figure class=\"highlight sql\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">搜索： Git 撤销 <span class=\"keyword\">commit</span> <span class=\"operator\">*</span></span><br><span class=\"line\">结果： 显示包含“Git 撤销 <span class=\"keyword\">commit</span>”后跟任意单词的内容。</span><br></pre></td></tr></table></figure>\n\n<h2 id=\"4-搜索指定范围（-）\"><a href=\"#4-搜索指定范围（-）\" class=\"headerlink\" title=\"4. 搜索指定范围（...）\"></a>4. 搜索指定范围（<code>...</code>）</h2><p>使用“…”可以搜索指定数字范围的内容，比如年份、版本等。例如：</p>\n<figure class=\"highlight jboss-cli\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">搜索： JavaScript in 2021.<span class=\"string\">..2022</span></span><br><span class=\"line\">结果： 找到2021年到2022年之间关于JavaScript的相关内容。</span><br></pre></td></tr></table></figure>\n\n<h2 id=\"5-搜索指定站点内容（site-）\"><a href=\"#5-搜索指定站点内容（site-）\" class=\"headerlink\" title=\"5. 搜索指定站点内容（site:）\"></a>5. 搜索指定站点内容（<code>site:</code>）</h2><p>如果你想在某个特定网站中搜索内容，可以在关键词后加上 <code>site:网站域名</code>。例如：</p>\n<figure class=\"highlight ada\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">搜索： javascript <span class=\"keyword\">Array</span> site:w3schools.com</span><br><span class=\"line\">结果： 在W3Schools网站中查找关于JavaScript数组的内容。</span><br></pre></td></tr></table></figure>\n\n<h2 id=\"6-搜索指定文件类型内容（filetype-）\"><a href=\"#6-搜索指定文件类型内容（filetype-）\" class=\"headerlink\" title=\"6. 搜索指定文件类型内容（filetype:）\"></a>6. 搜索指定文件类型内容（<code>filetype:</code>）</h2><p>如果你需要查找特定文件类型的内容，比如电子书、文档等，可以使用 <code>filetype:</code> 后跟文件扩展名。例如：</p>\n<figure class=\"highlight elm\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">搜索： <span class=\"type\">React</span> ebook file<span class=\"keyword\">type</span>:pdf</span><br><span class=\"line\">结果： 找到<span class=\"type\">React</span>相关的<span class=\"type\">PDF</span>电子书。</span><br></pre></td></tr></table></figure>\n\n<h2 id=\"7-查找多个关键字（AND）\"><a href=\"#7-查找多个关键字（AND）\" class=\"headerlink\" title=\"7. 查找多个关键字（AND）\"></a>7. 查找多个关键字（<code>AND</code>）</h2><p>当你需要同时查找多个关键字时，可以使用 <code>AND</code> 连接它们。例如：</p>\n<figure class=\"highlight armasm\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">搜索： React <span class=\"keyword\">AND</span> CSS</span><br><span class=\"line\">结果： 找到同时包含React和CSS的内容。</span><br></pre></td></tr></table></figure>\n\n<h2 id=\"8-查找其中一个关键字（OR）\"><a href=\"#8-查找其中一个关键字（OR）\" class=\"headerlink\" title=\"8. 查找其中一个关键字（OR）\"></a>8. 查找其中一个关键字（<code>OR</code>）</h2><p>如果你想查找多个关键字中的任意一个，可以使用 <code>OR</code>。例如：</p>\n<figure class=\"highlight mipsasm\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">搜索： React <span class=\"keyword\">OR </span>Vue</span><br><span class=\"line\">结果： 找到包含React或Vue的内容。</span><br></pre></td></tr></table></figure>\n\n<h2 id=\"9-查询关键字的定义（define-）\"><a href=\"#9-查询关键字的定义（define-）\" class=\"headerlink\" title=\"9. 查询关键字的定义（define:）\"></a>9. 查询关键字的定义（<code>define:</code>）</h2><p>如果你想知道某个单词的定义，可以在其前面加上 <code>define:</code>。例如：</p>\n<figure class=\"highlight puppet\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">搜索： <span class=\"keyword\">define</span>: <span class=\"section\">JavaScript</span></span><br><span class=\"line\">结果： 找到JavaScript的定义。</span><br></pre></td></tr></table></figure>\n\n<h2 id=\"10-搜索相关内容（-）\"><a href=\"#10-搜索相关内容（-）\" class=\"headerlink\" title=\"10. 搜索相关内容（+）\"></a>10. 搜索相关内容（<code>+</code>）</h2><p>当你想要搜索多个相关的关键词时，可以使用加号连接它们。例如：</p>\n<figure class=\"highlight maxima\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">搜索： CSS <span class=\"built_in\">style</span>+React</span><br><span class=\"line\">结果： 找到同时包含CSS样式和React相关内容。</span><br></pre></td></tr></table></figure>\n\n<h2 id=\"11-查找相似网站（related-）\"><a href=\"#11-查找相似网站（related-）\" class=\"headerlink\" title=\"11. 查找相似网站（related:）\"></a>11. 查找相似网站（<code>related:</code>）</h2><p>如果你想找到与某个网站类似的其他网站，可以在其前面加上 <code>related:</code>。例如：</p>\n<figure class=\"highlight nestedtext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"attribute\">搜索： related</span><span class=\"punctuation\">:</span> <span class=\"string\">w3schools.com</span></span><br><span class=\"line\">结果： 找到与W3Schools类似的编程学习网站。</span><br></pre></td></tr></table></figure>\n\n<h2 id=\"12-搜索指定站点内容（site-）\"><a href=\"#12-搜索指定站点内容（site-）\" class=\"headerlink\" title=\"12. 搜索指定站点内容（site:）\"></a>12. 搜索指定站点内容（<code>site:</code>）</h2><p>与第 5 点类似，使用 <code>site:</code> 可以搜索指定站点中的内容。例如：</p>\n<figure class=\"highlight stylus\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">搜索： React site:github<span class=\"selector-class\">.com</span></span><br><span class=\"line\">结果： 找到GitHub上关于React的内容。</span><br></pre></td></tr></table></figure>\n\n<h2 id=\"13-搜索指定时间范围（before-、after-）\"><a href=\"#13-搜索指定时间范围（before-、after-）\" class=\"headerlink\" title=\"13. 搜索指定时间范围（before:、after:）\"></a>13. 搜索指定时间范围（<code>before:</code>、<code>after:</code>）</h2><p>如果你需要查找某个时间范围内的内容，可以使用 <code>before:</code> 或 <code>after:</code>。例如：</p>\n<figure class=\"highlight applescript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">搜索： <span class=\"keyword\">after</span>:<span class=\"number\">2021</span> learn react</span><br><span class=\"line\">结果： 找到<span class=\"number\">2021</span>年之后关于学习React的内容。</span><br></pre></td></tr></table></figure>\n"},{"title":"2025-03-05-判断回文数","date":"2025-03-04T16:00:00.000Z","_content":"\n# 2025-03-05-判断回文数\n\n> 参考博客\n> [判断回文数算法](https://zhuanlan.zhihu.com/p/74799938)\n> [判断回文数(三种解法)—— Leetcode(9)_求回文数-CSDN 博客](https://blog.csdn.net/qwerty200696/article/details/79053770)\n\n[回文数](https://zhida.zhihu.com/search?content_id=104751474&content_type=Article&match_order=1&q=%E5%9B%9E%E6%96%87%E6%95%B0&zhida_source=entity)是指正序（从左到右）读和倒序（从右到左）读都是一样的整数。\n\n比如形如 121，1221，13531 的数字都是回文数，但 -121，10，25 等等都不是回文数。\n\n# 取反对比\n\n> 一种容易想到的方法是：将整个数取反后看和原来的数是否相同。\n\n```\nbool isPalindrome(int x) {  \n    if (x<0)  \n        return false;  \n    long long sum =0;  \n    long long origin = x;  \n    while(x)  \n    {  \n        int num = x %10;  \n        sum = sum*10 + num;  \n        x/=10;  \n    }  \n    if(sum == origin)  \n        return true;  \n    else  \n        return false;  \n}\n```\n\n# 左右翻转\n\n> 根据回文数的特点，我们只需要判断左边一半和翻转后的右边一半是否相等即可。\n\n```\nbool isPalindrome(int x) {\n    // 负数肯定不是，以及首尾不对称的非0数\n    if(x < 0 || (x % 10 == 0 && x != 0))\n        return false;\n\n    int rev = 0;\n    while ( x > rev){\n        rev = rev * 10 + x % 10; //将低位一半的数取反。\n        x = int (x / 10);\n    }\n    //有rev >= x， 奇数情况下需要除去10\n    return x == rev || x == int(rev/10); \n}\n```\n\n# 双指针\n\n> 在循环体中，不断地比较第 i 位和倒数第 i 位，直到遇到最中间的 1 个数字(输入为奇数个数字)或者遇到最中间的 2 个数字(输入为偶数个数字)时结束。\n\n```\nbool isPalindrome(int x) {  \n  if (x < 0) return false;  \n  int div = 1;  \n  while (x / div >= 10) {  \n    div *= 10;  \n  }          \n  while (x != 0) {  \n    int l = x / div;  \n    int r = x % 10;  \n    if (l != r) return false;  \n    x = (x % div) / 10;  //去掉两边的数\n    div /= 100;  \n  }  \n  return true;  \n}\n```\n\n> 补充:**一个证明,有偶数位的回文数能被 11 整除**\n>\n> 1. **考虑偶数位的回文数**：假设我们有一个有偶数位的回文数 $N $，设其位数为  $2k$ （其中 $k$是正整数）。我们可以将 $N $ 表示为：\n>\n> $$\n> N = a_1a_2 \\ldots a_ka_{k+1} \\ldots a_{2k}\n> $$\n>\n> 其中 $a_1 = a_{2k}， a_2 = a_{2k-1}，\\ldots， a_k = a_{k+1}$ 。\n>\n> 1. **将回文数表示为数学形式**：我们可以将  $N$  写成：\n>\n> $$\n> N = a_1 \\cdot 10^{2k-1} + a_2 \\cdot 10^{2k-2} + \\cdots + a_k \\cdot 10^k + a_k \\cdot 10^{k-1} + \\cdots + a_2 \\cdot 10 + a_1\n> $$\n>\n> 这可以重写为：\n>\n> $$\n> N = a_1 (10^{2k-1} + 1) + a_2 (10^{2k-2} + 10) + \\cdots + a_k (10^k + 10^{k-1})\n> $$\n>\n> 1. **提取公因数**：注意到每一项 $10^{2i-1} + 10^{2i-2}$   都可以提取公因数 $10^{i-1}$  ：\n>\n> $$\n> N = a_1 (10^{2k-1} + 1) + a_2 \\cdot 10 (10^{2k-3} + 1) + \\cdots + a_k \\cdot 10^{k-1} (10 + 1)\n> $$\n>\n> 这可以进一步简化为：\n>\n> $$\n> N = \\textcolor{blue}{[}a_1 (10^{2k-1} + 1) + a_2 \\cdot 10 (10^{2k-3} + 1)\\textcolor{blue}{]} + \\cdots + a_k \\cdot 10^{k-1} \\cdot 11\n> $$\n>\n> 1. **分离公因数 11**：由于 $10 + 1 = 11$  ，我们可以看到 $N$ 可以被11整除。因此，$N$ 有一个因子 11。\n> 2. **结论**：因为 $N$ 有因子 11，所以 $N$ 不是质数，除非 $N = 11 $。但是题目中已经排除了 11 的情况。\n>    因此，有偶数位的回文数（除了 11）必然不是质数。\n","source":"_posts/2025-03-05-判断回文数.md","raw":"---\ntitle: 2025-03-05-判断回文数\ndate: 2025-03-05\ntags: 算法练习\n---\n\n# 2025-03-05-判断回文数\n\n> 参考博客\n> [判断回文数算法](https://zhuanlan.zhihu.com/p/74799938)\n> [判断回文数(三种解法)—— Leetcode(9)_求回文数-CSDN 博客](https://blog.csdn.net/qwerty200696/article/details/79053770)\n\n[回文数](https://zhida.zhihu.com/search?content_id=104751474&content_type=Article&match_order=1&q=%E5%9B%9E%E6%96%87%E6%95%B0&zhida_source=entity)是指正序（从左到右）读和倒序（从右到左）读都是一样的整数。\n\n比如形如 121，1221，13531 的数字都是回文数，但 -121，10，25 等等都不是回文数。\n\n# 取反对比\n\n> 一种容易想到的方法是：将整个数取反后看和原来的数是否相同。\n\n```\nbool isPalindrome(int x) {  \n    if (x<0)  \n        return false;  \n    long long sum =0;  \n    long long origin = x;  \n    while(x)  \n    {  \n        int num = x %10;  \n        sum = sum*10 + num;  \n        x/=10;  \n    }  \n    if(sum == origin)  \n        return true;  \n    else  \n        return false;  \n}\n```\n\n# 左右翻转\n\n> 根据回文数的特点，我们只需要判断左边一半和翻转后的右边一半是否相等即可。\n\n```\nbool isPalindrome(int x) {\n    // 负数肯定不是，以及首尾不对称的非0数\n    if(x < 0 || (x % 10 == 0 && x != 0))\n        return false;\n\n    int rev = 0;\n    while ( x > rev){\n        rev = rev * 10 + x % 10; //将低位一半的数取反。\n        x = int (x / 10);\n    }\n    //有rev >= x， 奇数情况下需要除去10\n    return x == rev || x == int(rev/10); \n}\n```\n\n# 双指针\n\n> 在循环体中，不断地比较第 i 位和倒数第 i 位，直到遇到最中间的 1 个数字(输入为奇数个数字)或者遇到最中间的 2 个数字(输入为偶数个数字)时结束。\n\n```\nbool isPalindrome(int x) {  \n  if (x < 0) return false;  \n  int div = 1;  \n  while (x / div >= 10) {  \n    div *= 10;  \n  }          \n  while (x != 0) {  \n    int l = x / div;  \n    int r = x % 10;  \n    if (l != r) return false;  \n    x = (x % div) / 10;  //去掉两边的数\n    div /= 100;  \n  }  \n  return true;  \n}\n```\n\n> 补充:**一个证明,有偶数位的回文数能被 11 整除**\n>\n> 1. **考虑偶数位的回文数**：假设我们有一个有偶数位的回文数 $N $，设其位数为  $2k$ （其中 $k$是正整数）。我们可以将 $N $ 表示为：\n>\n> $$\n> N = a_1a_2 \\ldots a_ka_{k+1} \\ldots a_{2k}\n> $$\n>\n> 其中 $a_1 = a_{2k}， a_2 = a_{2k-1}，\\ldots， a_k = a_{k+1}$ 。\n>\n> 1. **将回文数表示为数学形式**：我们可以将  $N$  写成：\n>\n> $$\n> N = a_1 \\cdot 10^{2k-1} + a_2 \\cdot 10^{2k-2} + \\cdots + a_k \\cdot 10^k + a_k \\cdot 10^{k-1} + \\cdots + a_2 \\cdot 10 + a_1\n> $$\n>\n> 这可以重写为：\n>\n> $$\n> N = a_1 (10^{2k-1} + 1) + a_2 (10^{2k-2} + 10) + \\cdots + a_k (10^k + 10^{k-1})\n> $$\n>\n> 1. **提取公因数**：注意到每一项 $10^{2i-1} + 10^{2i-2}$   都可以提取公因数 $10^{i-1}$  ：\n>\n> $$\n> N = a_1 (10^{2k-1} + 1) + a_2 \\cdot 10 (10^{2k-3} + 1) + \\cdots + a_k \\cdot 10^{k-1} (10 + 1)\n> $$\n>\n> 这可以进一步简化为：\n>\n> $$\n> N = \\textcolor{blue}{[}a_1 (10^{2k-1} + 1) + a_2 \\cdot 10 (10^{2k-3} + 1)\\textcolor{blue}{]} + \\cdots + a_k \\cdot 10^{k-1} \\cdot 11\n> $$\n>\n> 1. **分离公因数 11**：由于 $10 + 1 = 11$  ，我们可以看到 $N$ 可以被11整除。因此，$N$ 有一个因子 11。\n> 2. **结论**：因为 $N$ 有因子 11，所以 $N$ 不是质数，除非 $N = 11 $。但是题目中已经排除了 11 的情况。\n>    因此，有偶数位的回文数（除了 11）必然不是质数。\n","slug":"2025-03-05-判断回文数","published":1,"updated":"2025-09-26T12:16:09.674Z","_id":"cmg0saj3z000qjm8n7dlh75o4","comments":1,"layout":"post","photos":[],"content":"<h1 id=\"2025-03-05-判断回文数\"><a href=\"#2025-03-05-判断回文数\" class=\"headerlink\" title=\"2025-03-05-判断回文数\"></a>2025-03-05-判断回文数</h1><blockquote>\n<p>参考博客<br><a href=\"https://zhuanlan.zhihu.com/p/74799938\">判断回文数算法</a><br><a href=\"https://blog.csdn.net/qwerty200696/article/details/79053770\">判断回文数(三种解法)—— Leetcode(9)_求回文数-CSDN 博客</a></p>\n</blockquote>\n<p><a href=\"https://zhida.zhihu.com/search?content_id=104751474&content_type=Article&match_order=1&q=%E5%9B%9E%E6%96%87%E6%95%B0&zhida_source=entity\">回文数</a>是指正序（从左到右）读和倒序（从右到左）读都是一样的整数。</p>\n<p>比如形如 121，1221，13531 的数字都是回文数，但 -121，10，25 等等都不是回文数。</p>\n<h1 id=\"取反对比\"><a href=\"#取反对比\" class=\"headerlink\" title=\"取反对比\"></a>取反对比</h1><blockquote>\n<p>一种容易想到的方法是：将整个数取反后看和原来的数是否相同。</p>\n</blockquote>\n<figure class=\"highlight axapta\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">bool isPalindrome(<span class=\"built_in\">int</span> x) &#123;  </span><br><span class=\"line\">    <span class=\"keyword\">if</span> (x&lt;<span class=\"number\">0</span>)  </span><br><span class=\"line\">        <span class=\"keyword\">return</span> <span class=\"literal\">false</span>;  </span><br><span class=\"line\">    <span class=\"built_in\">long</span> <span class=\"built_in\">long</span> <span class=\"keyword\">sum</span> =<span class=\"number\">0</span>;  </span><br><span class=\"line\">    <span class=\"built_in\">long</span> <span class=\"built_in\">long</span> origin = x;  </span><br><span class=\"line\">    <span class=\"keyword\">while</span>(x)  </span><br><span class=\"line\">    &#123;  </span><br><span class=\"line\">        <span class=\"built_in\">int</span> num = x %<span class=\"number\">10</span>;  </span><br><span class=\"line\">        <span class=\"keyword\">sum</span> = <span class=\"keyword\">sum</span>*<span class=\"number\">10</span> + num;  </span><br><span class=\"line\">        x/=<span class=\"number\">10</span>;  </span><br><span class=\"line\">    &#125;  </span><br><span class=\"line\">    <span class=\"keyword\">if</span>(<span class=\"keyword\">sum</span> == origin)  </span><br><span class=\"line\">        <span class=\"keyword\">return</span> <span class=\"literal\">true</span>;  </span><br><span class=\"line\">    <span class=\"keyword\">else</span>  </span><br><span class=\"line\">        <span class=\"keyword\">return</span> <span class=\"literal\">false</span>;  </span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<h1 id=\"左右翻转\"><a href=\"#左右翻转\" class=\"headerlink\" title=\"左右翻转\"></a>左右翻转</h1><blockquote>\n<p>根据回文数的特点，我们只需要判断左边一半和翻转后的右边一半是否相等即可。</p>\n</blockquote>\n<figure class=\"highlight gml\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"built_in\">bool</span> isPalindrome(int <span class=\"variable language_\">x</span>) &#123;</span><br><span class=\"line\">    <span class=\"comment\">// 负数肯定不是，以及首尾不对称的非0数</span></span><br><span class=\"line\">    <span class=\"keyword\">if</span>(<span class=\"variable language_\">x</span> &lt; <span class=\"number\">0</span> || (<span class=\"variable language_\">x</span> % <span class=\"number\">10</span> == <span class=\"number\">0</span> &amp;&amp; <span class=\"variable language_\">x</span> != <span class=\"number\">0</span>))</span><br><span class=\"line\">        <span class=\"keyword\">return</span> <span class=\"symbol\">false</span>;</span><br><span class=\"line\"></span><br><span class=\"line\">    int rev = <span class=\"number\">0</span>;</span><br><span class=\"line\">    <span class=\"keyword\">while</span> ( <span class=\"variable language_\">x</span> &gt; rev)&#123;</span><br><span class=\"line\">        rev = rev * <span class=\"number\">10</span> + <span class=\"variable language_\">x</span> % <span class=\"number\">10</span>; <span class=\"comment\">//将低位一半的数取反。</span></span><br><span class=\"line\">        <span class=\"variable language_\">x</span> = int (<span class=\"variable language_\">x</span> / <span class=\"number\">10</span>);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"comment\">//有rev &gt;= x， 奇数情况下需要除去10</span></span><br><span class=\"line\">    <span class=\"keyword\">return</span> <span class=\"variable language_\">x</span> == rev || <span class=\"variable language_\">x</span> == int(rev/<span class=\"number\">10</span>); </span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<h1 id=\"双指针\"><a href=\"#双指针\" class=\"headerlink\" title=\"双指针\"></a>双指针</h1><blockquote>\n<p>在循环体中，不断地比较第 i 位和倒数第 i 位，直到遇到最中间的 1 个数字(输入为奇数个数字)或者遇到最中间的 2 个数字(输入为偶数个数字)时结束。</p>\n</blockquote>\n<figure class=\"highlight gml\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"built_in\">bool</span> isPalindrome(int <span class=\"variable language_\">x</span>) &#123;  </span><br><span class=\"line\">  <span class=\"keyword\">if</span> (<span class=\"variable language_\">x</span> &lt; <span class=\"number\">0</span>) <span class=\"keyword\">return</span> <span class=\"symbol\">false</span>;  </span><br><span class=\"line\">  int <span class=\"keyword\">div</span> = <span class=\"number\">1</span>;  </span><br><span class=\"line\">  <span class=\"keyword\">while</span> (<span class=\"variable language_\">x</span> / <span class=\"keyword\">div</span> &gt;= <span class=\"number\">10</span>) &#123;  </span><br><span class=\"line\">    <span class=\"keyword\">div</span> *= <span class=\"number\">10</span>;  </span><br><span class=\"line\">  &#125;          </span><br><span class=\"line\">  <span class=\"keyword\">while</span> (<span class=\"variable language_\">x</span> != <span class=\"number\">0</span>) &#123;  </span><br><span class=\"line\">    int l = <span class=\"variable language_\">x</span> / <span class=\"keyword\">div</span>;  </span><br><span class=\"line\">    int r = <span class=\"variable language_\">x</span> % <span class=\"number\">10</span>;  </span><br><span class=\"line\">    <span class=\"keyword\">if</span> (l != r) <span class=\"keyword\">return</span> <span class=\"symbol\">false</span>;  </span><br><span class=\"line\">    <span class=\"variable language_\">x</span> = (<span class=\"variable language_\">x</span> % <span class=\"keyword\">div</span>) / <span class=\"number\">10</span>;  <span class=\"comment\">//去掉两边的数</span></span><br><span class=\"line\">    <span class=\"keyword\">div</span> /= <span class=\"number\">100</span>;  </span><br><span class=\"line\">  &#125;  </span><br><span class=\"line\">  <span class=\"keyword\">return</span> <span class=\"symbol\">true</span>;  </span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<blockquote>\n<p>补充:<strong>一个证明,有偶数位的回文数能被 11 整除</strong></p>\n<ol>\n<li><strong>考虑偶数位的回文数</strong>：假设我们有一个有偶数位的回文数 $N $，设其位数为  $2k$ （其中 $k$是正整数）。我们可以将 $N $ 表示为：</li>\n</ol>\n<p>$$<br>N &#x3D; a_1a_2 \\ldots a_ka_{k+1} \\ldots a_{2k}<br>$$</p>\n<p>其中 $a_1 &#x3D; a_{2k}， a_2 &#x3D; a_{2k-1}，\\ldots， a_k &#x3D; a_{k+1}$ 。</p>\n<ol>\n<li><strong>将回文数表示为数学形式</strong>：我们可以将  $N$  写成：</li>\n</ol>\n<p>$$<br>N &#x3D; a_1 \\cdot 10^{2k-1} + a_2 \\cdot 10^{2k-2} + \\cdots + a_k \\cdot 10^k + a_k \\cdot 10^{k-1} + \\cdots + a_2 \\cdot 10 + a_1<br>$$</p>\n<p>这可以重写为：</p>\n<p>$$<br>N &#x3D; a_1 (10^{2k-1} + 1) + a_2 (10^{2k-2} + 10) + \\cdots + a_k (10^k + 10^{k-1})<br>$$</p>\n<ol>\n<li><strong>提取公因数</strong>：注意到每一项 $10^{2i-1} + 10^{2i-2}$   都可以提取公因数 $10^{i-1}$  ：</li>\n</ol>\n<p>$$<br>N &#x3D; a_1 (10^{2k-1} + 1) + a_2 \\cdot 10 (10^{2k-3} + 1) + \\cdots + a_k \\cdot 10^{k-1} (10 + 1)<br>$$</p>\n<p>这可以进一步简化为：</p>\n<p>$$<br>N &#x3D; \\textcolor{blue}{[}a_1 (10^{2k-1} + 1) + a_2 \\cdot 10 (10^{2k-3} + 1)\\textcolor{blue}{]} + \\cdots + a_k \\cdot 10^{k-1} \\cdot 11<br>$$</p>\n<ol>\n<li><strong>分离公因数 11</strong>：由于 $10 + 1 &#x3D; 11$  ，我们可以看到 $N$ 可以被11整除。因此，$N$ 有一个因子 11。</li>\n<li><strong>结论</strong>：因为 $N$ 有因子 11，所以 $N$ 不是质数，除非 $N &#x3D; 11 $。但是题目中已经排除了 11 的情况。<br>因此，有偶数位的回文数（除了 11）必然不是质数。</li>\n</ol>\n</blockquote>\n","excerpt":"","more":"<h1 id=\"2025-03-05-判断回文数\"><a href=\"#2025-03-05-判断回文数\" class=\"headerlink\" title=\"2025-03-05-判断回文数\"></a>2025-03-05-判断回文数</h1><blockquote>\n<p>参考博客<br><a href=\"https://zhuanlan.zhihu.com/p/74799938\">判断回文数算法</a><br><a href=\"https://blog.csdn.net/qwerty200696/article/details/79053770\">判断回文数(三种解法)—— Leetcode(9)_求回文数-CSDN 博客</a></p>\n</blockquote>\n<p><a href=\"https://zhida.zhihu.com/search?content_id=104751474&content_type=Article&match_order=1&q=%E5%9B%9E%E6%96%87%E6%95%B0&zhida_source=entity\">回文数</a>是指正序（从左到右）读和倒序（从右到左）读都是一样的整数。</p>\n<p>比如形如 121，1221，13531 的数字都是回文数，但 -121，10，25 等等都不是回文数。</p>\n<h1 id=\"取反对比\"><a href=\"#取反对比\" class=\"headerlink\" title=\"取反对比\"></a>取反对比</h1><blockquote>\n<p>一种容易想到的方法是：将整个数取反后看和原来的数是否相同。</p>\n</blockquote>\n<figure class=\"highlight axapta\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">bool isPalindrome(<span class=\"built_in\">int</span> x) &#123;  </span><br><span class=\"line\">    <span class=\"keyword\">if</span> (x&lt;<span class=\"number\">0</span>)  </span><br><span class=\"line\">        <span class=\"keyword\">return</span> <span class=\"literal\">false</span>;  </span><br><span class=\"line\">    <span class=\"built_in\">long</span> <span class=\"built_in\">long</span> <span class=\"keyword\">sum</span> =<span class=\"number\">0</span>;  </span><br><span class=\"line\">    <span class=\"built_in\">long</span> <span class=\"built_in\">long</span> origin = x;  </span><br><span class=\"line\">    <span class=\"keyword\">while</span>(x)  </span><br><span class=\"line\">    &#123;  </span><br><span class=\"line\">        <span class=\"built_in\">int</span> num = x %<span class=\"number\">10</span>;  </span><br><span class=\"line\">        <span class=\"keyword\">sum</span> = <span class=\"keyword\">sum</span>*<span class=\"number\">10</span> + num;  </span><br><span class=\"line\">        x/=<span class=\"number\">10</span>;  </span><br><span class=\"line\">    &#125;  </span><br><span class=\"line\">    <span class=\"keyword\">if</span>(<span class=\"keyword\">sum</span> == origin)  </span><br><span class=\"line\">        <span class=\"keyword\">return</span> <span class=\"literal\">true</span>;  </span><br><span class=\"line\">    <span class=\"keyword\">else</span>  </span><br><span class=\"line\">        <span class=\"keyword\">return</span> <span class=\"literal\">false</span>;  </span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<h1 id=\"左右翻转\"><a href=\"#左右翻转\" class=\"headerlink\" title=\"左右翻转\"></a>左右翻转</h1><blockquote>\n<p>根据回文数的特点，我们只需要判断左边一半和翻转后的右边一半是否相等即可。</p>\n</blockquote>\n<figure class=\"highlight gml\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"built_in\">bool</span> isPalindrome(int <span class=\"variable language_\">x</span>) &#123;</span><br><span class=\"line\">    <span class=\"comment\">// 负数肯定不是，以及首尾不对称的非0数</span></span><br><span class=\"line\">    <span class=\"keyword\">if</span>(<span class=\"variable language_\">x</span> &lt; <span class=\"number\">0</span> || (<span class=\"variable language_\">x</span> % <span class=\"number\">10</span> == <span class=\"number\">0</span> &amp;&amp; <span class=\"variable language_\">x</span> != <span class=\"number\">0</span>))</span><br><span class=\"line\">        <span class=\"keyword\">return</span> <span class=\"symbol\">false</span>;</span><br><span class=\"line\"></span><br><span class=\"line\">    int rev = <span class=\"number\">0</span>;</span><br><span class=\"line\">    <span class=\"keyword\">while</span> ( <span class=\"variable language_\">x</span> &gt; rev)&#123;</span><br><span class=\"line\">        rev = rev * <span class=\"number\">10</span> + <span class=\"variable language_\">x</span> % <span class=\"number\">10</span>; <span class=\"comment\">//将低位一半的数取反。</span></span><br><span class=\"line\">        <span class=\"variable language_\">x</span> = int (<span class=\"variable language_\">x</span> / <span class=\"number\">10</span>);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"comment\">//有rev &gt;= x， 奇数情况下需要除去10</span></span><br><span class=\"line\">    <span class=\"keyword\">return</span> <span class=\"variable language_\">x</span> == rev || <span class=\"variable language_\">x</span> == int(rev/<span class=\"number\">10</span>); </span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<h1 id=\"双指针\"><a href=\"#双指针\" class=\"headerlink\" title=\"双指针\"></a>双指针</h1><blockquote>\n<p>在循环体中，不断地比较第 i 位和倒数第 i 位，直到遇到最中间的 1 个数字(输入为奇数个数字)或者遇到最中间的 2 个数字(输入为偶数个数字)时结束。</p>\n</blockquote>\n<figure class=\"highlight gml\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"built_in\">bool</span> isPalindrome(int <span class=\"variable language_\">x</span>) &#123;  </span><br><span class=\"line\">  <span class=\"keyword\">if</span> (<span class=\"variable language_\">x</span> &lt; <span class=\"number\">0</span>) <span class=\"keyword\">return</span> <span class=\"symbol\">false</span>;  </span><br><span class=\"line\">  int <span class=\"keyword\">div</span> = <span class=\"number\">1</span>;  </span><br><span class=\"line\">  <span class=\"keyword\">while</span> (<span class=\"variable language_\">x</span> / <span class=\"keyword\">div</span> &gt;= <span class=\"number\">10</span>) &#123;  </span><br><span class=\"line\">    <span class=\"keyword\">div</span> *= <span class=\"number\">10</span>;  </span><br><span class=\"line\">  &#125;          </span><br><span class=\"line\">  <span class=\"keyword\">while</span> (<span class=\"variable language_\">x</span> != <span class=\"number\">0</span>) &#123;  </span><br><span class=\"line\">    int l = <span class=\"variable language_\">x</span> / <span class=\"keyword\">div</span>;  </span><br><span class=\"line\">    int r = <span class=\"variable language_\">x</span> % <span class=\"number\">10</span>;  </span><br><span class=\"line\">    <span class=\"keyword\">if</span> (l != r) <span class=\"keyword\">return</span> <span class=\"symbol\">false</span>;  </span><br><span class=\"line\">    <span class=\"variable language_\">x</span> = (<span class=\"variable language_\">x</span> % <span class=\"keyword\">div</span>) / <span class=\"number\">10</span>;  <span class=\"comment\">//去掉两边的数</span></span><br><span class=\"line\">    <span class=\"keyword\">div</span> /= <span class=\"number\">100</span>;  </span><br><span class=\"line\">  &#125;  </span><br><span class=\"line\">  <span class=\"keyword\">return</span> <span class=\"symbol\">true</span>;  </span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<blockquote>\n<p>补充:<strong>一个证明,有偶数位的回文数能被 11 整除</strong></p>\n<ol>\n<li><strong>考虑偶数位的回文数</strong>：假设我们有一个有偶数位的回文数 $N $，设其位数为  $2k$ （其中 $k$是正整数）。我们可以将 $N $ 表示为：</li>\n</ol>\n<p>$$<br>N &#x3D; a_1a_2 \\ldots a_ka_{k+1} \\ldots a_{2k}<br>$$</p>\n<p>其中 $a_1 &#x3D; a_{2k}， a_2 &#x3D; a_{2k-1}，\\ldots， a_k &#x3D; a_{k+1}$ 。</p>\n<ol>\n<li><strong>将回文数表示为数学形式</strong>：我们可以将  $N$  写成：</li>\n</ol>\n<p>$$<br>N &#x3D; a_1 \\cdot 10^{2k-1} + a_2 \\cdot 10^{2k-2} + \\cdots + a_k \\cdot 10^k + a_k \\cdot 10^{k-1} + \\cdots + a_2 \\cdot 10 + a_1<br>$$</p>\n<p>这可以重写为：</p>\n<p>$$<br>N &#x3D; a_1 (10^{2k-1} + 1) + a_2 (10^{2k-2} + 10) + \\cdots + a_k (10^k + 10^{k-1})<br>$$</p>\n<ol>\n<li><strong>提取公因数</strong>：注意到每一项 $10^{2i-1} + 10^{2i-2}$   都可以提取公因数 $10^{i-1}$  ：</li>\n</ol>\n<p>$$<br>N &#x3D; a_1 (10^{2k-1} + 1) + a_2 \\cdot 10 (10^{2k-3} + 1) + \\cdots + a_k \\cdot 10^{k-1} (10 + 1)<br>$$</p>\n<p>这可以进一步简化为：</p>\n<p>$$<br>N &#x3D; \\textcolor{blue}{[}a_1 (10^{2k-1} + 1) + a_2 \\cdot 10 (10^{2k-3} + 1)\\textcolor{blue}{]} + \\cdots + a_k \\cdot 10^{k-1} \\cdot 11<br>$$</p>\n<ol>\n<li><strong>分离公因数 11</strong>：由于 $10 + 1 &#x3D; 11$  ，我们可以看到 $N$ 可以被11整除。因此，$N$ 有一个因子 11。</li>\n<li><strong>结论</strong>：因为 $N$ 有因子 11，所以 $N$ 不是质数，除非 $N &#x3D; 11 $。但是题目中已经排除了 11 的情况。<br>因此，有偶数位的回文数（除了 11）必然不是质数。</li>\n</ol>\n</blockquote>\n"},{"title":"2025-03-15-位运算","date":"2025-03-14T16:00:00.000Z","_content":"\n> 参考资料\n> [https://oi-wiki.org/math/bit/](https://oi-wiki.org/math/bit/)\n\n### 1. 位运算简介\n\n位运算是一种基于整数二进制表示的运算方式。由于计算机内部以二进制形式存储数据，位运算的速度非常快，通常比普通算术运算更高效。\n\n### 2. 基本位运算操作\n\n- **按位与（**`&`）：两个二进制位都为 1 时，结果为 1；否则为 0。\n- **按位或（**`|`）：两个二进制位中至少有一个为 1 时，结果为 1；否则为 0。\n- **按位异或（**`^`）：两个二进制位相同为 0，不同为 1。\n\n> 异或运算的逆运算是它本身，也就是说两次异或同一个数最后结果不变，即 $a\\oplus b\\oplus b=a$\n\n- **按位取反（**`~`）：将二进制位的 0 变为 1，1 变为 0。\n- **左移（**`<<`）：将二进制表示向左移动若干位，右侧补 0。\n- **右移（**`>>`）：将二进制表示向右移动若干位，左侧补符号位（有符号数）或补 0（无符号数）。\n\n### 3. 位运算的特殊性质\n\n- **异或运算的逆运算**：异或运算具有自反性，即 `a ^ b ^ b = a`。\n- **补码表示**：计算机中负数以补码形式存储，正数的补码是其本身，负数的补码是其绝对值的二进制表示取反后加 1。\n\n### 4. 位运算的应用\n\n位运算在编程中有多种高效应用，包括但不限于：\n\n- **高效运算**：例如，通过左移和右移实现乘除 2 的幂次方。\n- **集合操作**：利用位运算表示集合，常用于状态压缩动态规划（状压 DP）。\n- **特定问题的优化**：例如，快速求解汉明权重（二进制中 1 的个数）。\n\n### 5. 位运算的实用技巧\n\n#### 5.1 取绝对值\n\n```cpp\nint Abs(int n) {\n    return (n ^ (n >> 31)) - (n >> 31);\n}\n```\n\n通过位运算实现取绝对值，避免分支判断。\n\n#### 5.2 求最大/最小值\n\n```cpp\nint max(int a, int b) {\n    return (b & ((a - b) >> 31)) | (a & (~(a - b) >> 31));\n}\n```\n\n利用位运算实现高效的求最大值和最小值操作。\n\n#### 5.3 判断符号是否相同\n\n```cpp\nbool isSameSign(int x, int y) {\n    return (x ^ y) >= 0;\n}\n```\n\n通过异或运算判断两个数的符号是否相同。\n\n#### 5.4 操作二进制位\n\n- 获取某一位的值：\n\n    ```cpp\n    int getBit(int a, int b) { return (a >> b) & 1; }\n\n    ```\n\n- 设置某一位为0或1：\n\n    ```cpp\n    int unsetBit(int a, int b) { return a & ~(1 << b); }\n    int setBit(int a, int b) { return a | (1 << b); }\n    ```\n\n### 6. 汉明权重与二进制操作\n\n汉明权重是指一个二进制数中 1 的个数。可以通过循环或 `lowbit` 操作快速求解：\n\n```cpp\nint popcount(int x) {\n    int cnt = 0;\n    while (x) {\n        cnt++;\n        x -= x & -x;\n    }\n    return cnt;\n}\n```\n\n### 7. 内建函数\n\nGCC 提供了一些位运算相关的内建函数，例如：\n\n- `__builtin_popcount(x)`：计算二进制中 1 的个数。\n- `__builtin_clz(x)`：计算前导 0 的个数。\n- `__builtin_ctz(x)`：计算末尾 0 的个数。\n\n这些函数经过编译器优化，运行速度极快。\n\n### 8. 更多位数的处理\n\n对于更大的数据集，可以使用 `bitset` 等数据结构进行高效位操作。\n\n### 9.应用\n\n> 状态\n\n> 异或加密\n","source":"_posts/2025-03-15-位运算.md","raw":"---\ntitle: 2025-03-15-位运算\ndate: 2025-03-15\ntags: 算法练习\n---\n\n> 参考资料\n> [https://oi-wiki.org/math/bit/](https://oi-wiki.org/math/bit/)\n\n### 1. 位运算简介\n\n位运算是一种基于整数二进制表示的运算方式。由于计算机内部以二进制形式存储数据，位运算的速度非常快，通常比普通算术运算更高效。\n\n### 2. 基本位运算操作\n\n- **按位与（**`&`）：两个二进制位都为 1 时，结果为 1；否则为 0。\n- **按位或（**`|`）：两个二进制位中至少有一个为 1 时，结果为 1；否则为 0。\n- **按位异或（**`^`）：两个二进制位相同为 0，不同为 1。\n\n> 异或运算的逆运算是它本身，也就是说两次异或同一个数最后结果不变，即 $a\\oplus b\\oplus b=a$\n\n- **按位取反（**`~`）：将二进制位的 0 变为 1，1 变为 0。\n- **左移（**`<<`）：将二进制表示向左移动若干位，右侧补 0。\n- **右移（**`>>`）：将二进制表示向右移动若干位，左侧补符号位（有符号数）或补 0（无符号数）。\n\n### 3. 位运算的特殊性质\n\n- **异或运算的逆运算**：异或运算具有自反性，即 `a ^ b ^ b = a`。\n- **补码表示**：计算机中负数以补码形式存储，正数的补码是其本身，负数的补码是其绝对值的二进制表示取反后加 1。\n\n### 4. 位运算的应用\n\n位运算在编程中有多种高效应用，包括但不限于：\n\n- **高效运算**：例如，通过左移和右移实现乘除 2 的幂次方。\n- **集合操作**：利用位运算表示集合，常用于状态压缩动态规划（状压 DP）。\n- **特定问题的优化**：例如，快速求解汉明权重（二进制中 1 的个数）。\n\n### 5. 位运算的实用技巧\n\n#### 5.1 取绝对值\n\n```cpp\nint Abs(int n) {\n    return (n ^ (n >> 31)) - (n >> 31);\n}\n```\n\n通过位运算实现取绝对值，避免分支判断。\n\n#### 5.2 求最大/最小值\n\n```cpp\nint max(int a, int b) {\n    return (b & ((a - b) >> 31)) | (a & (~(a - b) >> 31));\n}\n```\n\n利用位运算实现高效的求最大值和最小值操作。\n\n#### 5.3 判断符号是否相同\n\n```cpp\nbool isSameSign(int x, int y) {\n    return (x ^ y) >= 0;\n}\n```\n\n通过异或运算判断两个数的符号是否相同。\n\n#### 5.4 操作二进制位\n\n- 获取某一位的值：\n\n    ```cpp\n    int getBit(int a, int b) { return (a >> b) & 1; }\n\n    ```\n\n- 设置某一位为0或1：\n\n    ```cpp\n    int unsetBit(int a, int b) { return a & ~(1 << b); }\n    int setBit(int a, int b) { return a | (1 << b); }\n    ```\n\n### 6. 汉明权重与二进制操作\n\n汉明权重是指一个二进制数中 1 的个数。可以通过循环或 `lowbit` 操作快速求解：\n\n```cpp\nint popcount(int x) {\n    int cnt = 0;\n    while (x) {\n        cnt++;\n        x -= x & -x;\n    }\n    return cnt;\n}\n```\n\n### 7. 内建函数\n\nGCC 提供了一些位运算相关的内建函数，例如：\n\n- `__builtin_popcount(x)`：计算二进制中 1 的个数。\n- `__builtin_clz(x)`：计算前导 0 的个数。\n- `__builtin_ctz(x)`：计算末尾 0 的个数。\n\n这些函数经过编译器优化，运行速度极快。\n\n### 8. 更多位数的处理\n\n对于更大的数据集，可以使用 `bitset` 等数据结构进行高效位操作。\n\n### 9.应用\n\n> 状态\n\n> 异或加密\n","slug":"2025-03-15-位运算","published":1,"updated":"2025-09-26T12:16:16.014Z","_id":"cmg0saj3z000sjm8nek8nbyjl","comments":1,"layout":"post","photos":[],"content":"<blockquote>\n<p>参考资料<br><a href=\"https://oi-wiki.org/math/bit/\">https://oi-wiki.org/math/bit/</a></p>\n</blockquote>\n<h3 id=\"1-位运算简介\"><a href=\"#1-位运算简介\" class=\"headerlink\" title=\"1. 位运算简介\"></a>1. 位运算简介</h3><p>位运算是一种基于整数二进制表示的运算方式。由于计算机内部以二进制形式存储数据，位运算的速度非常快，通常比普通算术运算更高效。</p>\n<h3 id=\"2-基本位运算操作\"><a href=\"#2-基本位运算操作\" class=\"headerlink\" title=\"2. 基本位运算操作\"></a>2. 基本位运算操作</h3><ul>\n<li><strong>按位与（</strong><code>&amp;</code>）：两个二进制位都为 1 时，结果为 1；否则为 0。</li>\n<li><strong>按位或（</strong><code>|</code>）：两个二进制位中至少有一个为 1 时，结果为 1；否则为 0。</li>\n<li><strong>按位异或（</strong><code>^</code>）：两个二进制位相同为 0，不同为 1。</li>\n</ul>\n<blockquote>\n<p>异或运算的逆运算是它本身，也就是说两次异或同一个数最后结果不变，即 $a\\oplus b\\oplus b&#x3D;a$</p>\n</blockquote>\n<ul>\n<li><strong>按位取反（</strong><code>~</code>）：将二进制位的 0 变为 1，1 变为 0。</li>\n<li><strong>左移（</strong><code>&lt;&lt;</code>）：将二进制表示向左移动若干位，右侧补 0。</li>\n<li><strong>右移（</strong><code>&gt;&gt;</code>）：将二进制表示向右移动若干位，左侧补符号位（有符号数）或补 0（无符号数）。</li>\n</ul>\n<h3 id=\"3-位运算的特殊性质\"><a href=\"#3-位运算的特殊性质\" class=\"headerlink\" title=\"3. 位运算的特殊性质\"></a>3. 位运算的特殊性质</h3><ul>\n<li><strong>异或运算的逆运算</strong>：异或运算具有自反性，即 <code>a ^ b ^ b = a</code>。</li>\n<li><strong>补码表示</strong>：计算机中负数以补码形式存储，正数的补码是其本身，负数的补码是其绝对值的二进制表示取反后加 1。</li>\n</ul>\n<h3 id=\"4-位运算的应用\"><a href=\"#4-位运算的应用\" class=\"headerlink\" title=\"4. 位运算的应用\"></a>4. 位运算的应用</h3><p>位运算在编程中有多种高效应用，包括但不限于：</p>\n<ul>\n<li><strong>高效运算</strong>：例如，通过左移和右移实现乘除 2 的幂次方。</li>\n<li><strong>集合操作</strong>：利用位运算表示集合，常用于状态压缩动态规划（状压 DP）。</li>\n<li><strong>特定问题的优化</strong>：例如，快速求解汉明权重（二进制中 1 的个数）。</li>\n</ul>\n<h3 id=\"5-位运算的实用技巧\"><a href=\"#5-位运算的实用技巧\" class=\"headerlink\" title=\"5. 位运算的实用技巧\"></a>5. 位运算的实用技巧</h3><h4 id=\"5-1-取绝对值\"><a href=\"#5-1-取绝对值\" class=\"headerlink\" title=\"5.1 取绝对值\"></a>5.1 取绝对值</h4><figure class=\"highlight cpp\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"type\">int</span> <span class=\"title\">Abs</span><span class=\"params\">(<span class=\"type\">int</span> n)</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> (n ^ (n &gt;&gt; <span class=\"number\">31</span>)) - (n &gt;&gt; <span class=\"number\">31</span>);</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>通过位运算实现取绝对值，避免分支判断。</p>\n<h4 id=\"5-2-求最大-最小值\"><a href=\"#5-2-求最大-最小值\" class=\"headerlink\" title=\"5.2 求最大&#x2F;最小值\"></a>5.2 求最大&#x2F;最小值</h4><figure class=\"highlight cpp\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"type\">int</span> <span class=\"title\">max</span><span class=\"params\">(<span class=\"type\">int</span> a, <span class=\"type\">int</span> b)</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> (b &amp; ((a - b) &gt;&gt; <span class=\"number\">31</span>)) | (a &amp; (~(a - b) &gt;&gt; <span class=\"number\">31</span>));</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>利用位运算实现高效的求最大值和最小值操作。</p>\n<h4 id=\"5-3-判断符号是否相同\"><a href=\"#5-3-判断符号是否相同\" class=\"headerlink\" title=\"5.3 判断符号是否相同\"></a>5.3 判断符号是否相同</h4><figure class=\"highlight cpp\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"type\">bool</span> <span class=\"title\">isSameSign</span><span class=\"params\">(<span class=\"type\">int</span> x, <span class=\"type\">int</span> y)</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> (x ^ y) &gt;= <span class=\"number\">0</span>;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>通过异或运算判断两个数的符号是否相同。</p>\n<h4 id=\"5-4-操作二进制位\"><a href=\"#5-4-操作二进制位\" class=\"headerlink\" title=\"5.4 操作二进制位\"></a>5.4 操作二进制位</h4><ul>\n<li><p>获取某一位的值：</p>\n  <figure class=\"highlight cpp\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"type\">int</span> <span class=\"title\">getBit</span><span class=\"params\">(<span class=\"type\">int</span> a, <span class=\"type\">int</span> b)</span> </span>&#123; <span class=\"keyword\">return</span> (a &gt;&gt; b) &amp; <span class=\"number\">1</span>; &#125;</span><br><span class=\"line\"></span><br></pre></td></tr></table></figure>\n</li>\n<li><p>设置某一位为0或1：</p>\n  <figure class=\"highlight cpp\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"type\">int</span> <span class=\"title\">unsetBit</span><span class=\"params\">(<span class=\"type\">int</span> a, <span class=\"type\">int</span> b)</span> </span>&#123; <span class=\"keyword\">return</span> a &amp; ~(<span class=\"number\">1</span> &lt;&lt; b); &#125;</span><br><span class=\"line\"><span class=\"function\"><span class=\"type\">int</span> <span class=\"title\">setBit</span><span class=\"params\">(<span class=\"type\">int</span> a, <span class=\"type\">int</span> b)</span> </span>&#123; <span class=\"keyword\">return</span> a | (<span class=\"number\">1</span> &lt;&lt; b); &#125;</span><br></pre></td></tr></table></figure></li>\n</ul>\n<h3 id=\"6-汉明权重与二进制操作\"><a href=\"#6-汉明权重与二进制操作\" class=\"headerlink\" title=\"6. 汉明权重与二进制操作\"></a>6. 汉明权重与二进制操作</h3><p>汉明权重是指一个二进制数中 1 的个数。可以通过循环或 <code>lowbit</code> 操作快速求解：</p>\n<figure class=\"highlight cpp\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"type\">int</span> <span class=\"title\">popcount</span><span class=\"params\">(<span class=\"type\">int</span> x)</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"type\">int</span> cnt = <span class=\"number\">0</span>;</span><br><span class=\"line\">    <span class=\"keyword\">while</span> (x) &#123;</span><br><span class=\"line\">        cnt++;</span><br><span class=\"line\">        x -= x &amp; -x;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> cnt;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<h3 id=\"7-内建函数\"><a href=\"#7-内建函数\" class=\"headerlink\" title=\"7. 内建函数\"></a>7. 内建函数</h3><p>GCC 提供了一些位运算相关的内建函数，例如：</p>\n<ul>\n<li><code>__builtin_popcount(x)</code>：计算二进制中 1 的个数。</li>\n<li><code>__builtin_clz(x)</code>：计算前导 0 的个数。</li>\n<li><code>__builtin_ctz(x)</code>：计算末尾 0 的个数。</li>\n</ul>\n<p>这些函数经过编译器优化，运行速度极快。</p>\n<h3 id=\"8-更多位数的处理\"><a href=\"#8-更多位数的处理\" class=\"headerlink\" title=\"8. 更多位数的处理\"></a>8. 更多位数的处理</h3><p>对于更大的数据集，可以使用 <code>bitset</code> 等数据结构进行高效位操作。</p>\n<h3 id=\"9-应用\"><a href=\"#9-应用\" class=\"headerlink\" title=\"9.应用\"></a>9.应用</h3><blockquote>\n<p>状态</p>\n</blockquote>\n<blockquote>\n<p>异或加密</p>\n</blockquote>\n","excerpt":"","more":"<blockquote>\n<p>参考资料<br><a href=\"https://oi-wiki.org/math/bit/\">https://oi-wiki.org/math/bit/</a></p>\n</blockquote>\n<h3 id=\"1-位运算简介\"><a href=\"#1-位运算简介\" class=\"headerlink\" title=\"1. 位运算简介\"></a>1. 位运算简介</h3><p>位运算是一种基于整数二进制表示的运算方式。由于计算机内部以二进制形式存储数据，位运算的速度非常快，通常比普通算术运算更高效。</p>\n<h3 id=\"2-基本位运算操作\"><a href=\"#2-基本位运算操作\" class=\"headerlink\" title=\"2. 基本位运算操作\"></a>2. 基本位运算操作</h3><ul>\n<li><strong>按位与（</strong><code>&amp;</code>）：两个二进制位都为 1 时，结果为 1；否则为 0。</li>\n<li><strong>按位或（</strong><code>|</code>）：两个二进制位中至少有一个为 1 时，结果为 1；否则为 0。</li>\n<li><strong>按位异或（</strong><code>^</code>）：两个二进制位相同为 0，不同为 1。</li>\n</ul>\n<blockquote>\n<p>异或运算的逆运算是它本身，也就是说两次异或同一个数最后结果不变，即 $a\\oplus b\\oplus b&#x3D;a$</p>\n</blockquote>\n<ul>\n<li><strong>按位取反（</strong><code>~</code>）：将二进制位的 0 变为 1，1 变为 0。</li>\n<li><strong>左移（</strong><code>&lt;&lt;</code>）：将二进制表示向左移动若干位，右侧补 0。</li>\n<li><strong>右移（</strong><code>&gt;&gt;</code>）：将二进制表示向右移动若干位，左侧补符号位（有符号数）或补 0（无符号数）。</li>\n</ul>\n<h3 id=\"3-位运算的特殊性质\"><a href=\"#3-位运算的特殊性质\" class=\"headerlink\" title=\"3. 位运算的特殊性质\"></a>3. 位运算的特殊性质</h3><ul>\n<li><strong>异或运算的逆运算</strong>：异或运算具有自反性，即 <code>a ^ b ^ b = a</code>。</li>\n<li><strong>补码表示</strong>：计算机中负数以补码形式存储，正数的补码是其本身，负数的补码是其绝对值的二进制表示取反后加 1。</li>\n</ul>\n<h3 id=\"4-位运算的应用\"><a href=\"#4-位运算的应用\" class=\"headerlink\" title=\"4. 位运算的应用\"></a>4. 位运算的应用</h3><p>位运算在编程中有多种高效应用，包括但不限于：</p>\n<ul>\n<li><strong>高效运算</strong>：例如，通过左移和右移实现乘除 2 的幂次方。</li>\n<li><strong>集合操作</strong>：利用位运算表示集合，常用于状态压缩动态规划（状压 DP）。</li>\n<li><strong>特定问题的优化</strong>：例如，快速求解汉明权重（二进制中 1 的个数）。</li>\n</ul>\n<h3 id=\"5-位运算的实用技巧\"><a href=\"#5-位运算的实用技巧\" class=\"headerlink\" title=\"5. 位运算的实用技巧\"></a>5. 位运算的实用技巧</h3><h4 id=\"5-1-取绝对值\"><a href=\"#5-1-取绝对值\" class=\"headerlink\" title=\"5.1 取绝对值\"></a>5.1 取绝对值</h4><figure class=\"highlight cpp\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"type\">int</span> <span class=\"title\">Abs</span><span class=\"params\">(<span class=\"type\">int</span> n)</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> (n ^ (n &gt;&gt; <span class=\"number\">31</span>)) - (n &gt;&gt; <span class=\"number\">31</span>);</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>通过位运算实现取绝对值，避免分支判断。</p>\n<h4 id=\"5-2-求最大-最小值\"><a href=\"#5-2-求最大-最小值\" class=\"headerlink\" title=\"5.2 求最大&#x2F;最小值\"></a>5.2 求最大&#x2F;最小值</h4><figure class=\"highlight cpp\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"type\">int</span> <span class=\"title\">max</span><span class=\"params\">(<span class=\"type\">int</span> a, <span class=\"type\">int</span> b)</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> (b &amp; ((a - b) &gt;&gt; <span class=\"number\">31</span>)) | (a &amp; (~(a - b) &gt;&gt; <span class=\"number\">31</span>));</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>利用位运算实现高效的求最大值和最小值操作。</p>\n<h4 id=\"5-3-判断符号是否相同\"><a href=\"#5-3-判断符号是否相同\" class=\"headerlink\" title=\"5.3 判断符号是否相同\"></a>5.3 判断符号是否相同</h4><figure class=\"highlight cpp\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"type\">bool</span> <span class=\"title\">isSameSign</span><span class=\"params\">(<span class=\"type\">int</span> x, <span class=\"type\">int</span> y)</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> (x ^ y) &gt;= <span class=\"number\">0</span>;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>通过异或运算判断两个数的符号是否相同。</p>\n<h4 id=\"5-4-操作二进制位\"><a href=\"#5-4-操作二进制位\" class=\"headerlink\" title=\"5.4 操作二进制位\"></a>5.4 操作二进制位</h4><ul>\n<li><p>获取某一位的值：</p>\n  <figure class=\"highlight cpp\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"type\">int</span> <span class=\"title\">getBit</span><span class=\"params\">(<span class=\"type\">int</span> a, <span class=\"type\">int</span> b)</span> </span>&#123; <span class=\"keyword\">return</span> (a &gt;&gt; b) &amp; <span class=\"number\">1</span>; &#125;</span><br><span class=\"line\"></span><br></pre></td></tr></table></figure>\n</li>\n<li><p>设置某一位为0或1：</p>\n  <figure class=\"highlight cpp\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"type\">int</span> <span class=\"title\">unsetBit</span><span class=\"params\">(<span class=\"type\">int</span> a, <span class=\"type\">int</span> b)</span> </span>&#123; <span class=\"keyword\">return</span> a &amp; ~(<span class=\"number\">1</span> &lt;&lt; b); &#125;</span><br><span class=\"line\"><span class=\"function\"><span class=\"type\">int</span> <span class=\"title\">setBit</span><span class=\"params\">(<span class=\"type\">int</span> a, <span class=\"type\">int</span> b)</span> </span>&#123; <span class=\"keyword\">return</span> a | (<span class=\"number\">1</span> &lt;&lt; b); &#125;</span><br></pre></td></tr></table></figure></li>\n</ul>\n<h3 id=\"6-汉明权重与二进制操作\"><a href=\"#6-汉明权重与二进制操作\" class=\"headerlink\" title=\"6. 汉明权重与二进制操作\"></a>6. 汉明权重与二进制操作</h3><p>汉明权重是指一个二进制数中 1 的个数。可以通过循环或 <code>lowbit</code> 操作快速求解：</p>\n<figure class=\"highlight cpp\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"type\">int</span> <span class=\"title\">popcount</span><span class=\"params\">(<span class=\"type\">int</span> x)</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"type\">int</span> cnt = <span class=\"number\">0</span>;</span><br><span class=\"line\">    <span class=\"keyword\">while</span> (x) &#123;</span><br><span class=\"line\">        cnt++;</span><br><span class=\"line\">        x -= x &amp; -x;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> cnt;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<h3 id=\"7-内建函数\"><a href=\"#7-内建函数\" class=\"headerlink\" title=\"7. 内建函数\"></a>7. 内建函数</h3><p>GCC 提供了一些位运算相关的内建函数，例如：</p>\n<ul>\n<li><code>__builtin_popcount(x)</code>：计算二进制中 1 的个数。</li>\n<li><code>__builtin_clz(x)</code>：计算前导 0 的个数。</li>\n<li><code>__builtin_ctz(x)</code>：计算末尾 0 的个数。</li>\n</ul>\n<p>这些函数经过编译器优化，运行速度极快。</p>\n<h3 id=\"8-更多位数的处理\"><a href=\"#8-更多位数的处理\" class=\"headerlink\" title=\"8. 更多位数的处理\"></a>8. 更多位数的处理</h3><p>对于更大的数据集，可以使用 <code>bitset</code> 等数据结构进行高效位操作。</p>\n<h3 id=\"9-应用\"><a href=\"#9-应用\" class=\"headerlink\" title=\"9.应用\"></a>9.应用</h3><blockquote>\n<p>状态</p>\n</blockquote>\n<blockquote>\n<p>异或加密</p>\n</blockquote>\n"},{"title":"2025-03-18-VitPose 基于 vit 的姿态评估模型","date":"2025-03-17T16:00:00.000Z","_content":"> 相关论文\n> [ViTPose: Simple Vision Transformer Baselines for Human Pose Estimation](https://arxiv.org/abs/2204.12484)\n\n# Motivation\n\n1. **研究问题**：这篇文章要解决的问题是如何利用简单的 ViT（Vision Transformer）进行人体姿态估计。尽管 ViT 在视觉识别任务中表现出色，但在姿态估计任务中的应用仍然有限。\n2. **研究难点**：该问题的研究难点包括：如何在不使用复杂结构设计的情况下实现高性能的姿态估计；如何提高模型的规模可扩展性；如何在训练过程中保持灵活性；以及如何在不同模型之间有效地转移知识。\n3. **相关工作**：该问题的研究相关工作有：PRTR、TokenPose、TransPose、HRFormer 等方法，这些方法通常采用 CNN 作为主干网络(传统的网络对于对于局部特征的提取能力很强大,但是全局特征信息提取能不很差)，然后使用复杂的变压器结构来细化特征和建模关键点之间的关系。然而，这些方法要么需要额外的 CNN 进行特征提取，要么需要对变压器结构进行精心设计以适应任务。\n\n# Method\n\n这篇论文提出了一个名为 ViTPose 的简单基线模型，用于解决人体姿态估计问题。具体来说，\n\n1. **模型结构**：ViTPose 采用简单的非分层视觉变压器作为主干网络，用于提取给定人体实例的特征图。主干网络通过预训练的掩码图像建模（Masked Image Modeling, MAE）任务进行初始化。然后，一个轻量级解码器处理提取的特征，通过上采样特征图和回归关键点热图来进行姿态估计。解码器由两个反卷积层和一个预测层组成。\n\n![17423110798271742311079755.png](https://tk-pichost-1325224430.cos.ap-chengdu.myqcloud.com/blog/17423110798271742311079755.png)\n\n1. **可扩展性**：通过堆叠不同数量的变压器层和增加或减少特征维度，可以轻松控制模型大小。例如，可以使用 ViT-B、ViT-L 或 ViT-H 来平衡推理速度和性能。\n2. **灵活性**：ViTPose 在训练范式方面非常灵活，可以适应不同的输入分辨率和特征分辨率。通过添加额外的解码器，可以灵活地适应多个姿态数据集，从而实现联合训练管道并显著提高性能。此外，即使在使用较小的未标记数据集进行预训练或冻结注意力模块进行微调时，ViTPose 仍能获得 SOTA 性能。\n3. **知识转移**：通过一个额外的可学习知识令牌，可以将大模型的知识转移到小模型中，从而提高小模型的性能。\n\n# Result\n\n1. **结构简单性和可扩展性**：使用简单解码器的 ViTPose 在 MS COCO 验证集上的表现与使用复杂解码器的 ResNet-50 和 ResNet-152 相当，表明普通视觉变压器具有强大的表示能力。随着模型大小的增加，ViTPose 的性能一致提高，展示了其良好的可扩展性。\n2. **预训练数据灵活性**：使用 MS COCO 和 AI Challenger 数据组合进行预训练的 ViTPose 在 MS COCO 验证集上的表现与使用 ImageNet-1K 数据预训练的模型相当，表明使用下游任务数据进行预训练具有更好的数据效率。\n3. **输入分辨率灵活性**：随着输入分辨率的增加，ViTPose 的性能也相应提高。使用正方形输入尺寸并未带来显著的性能提升，可能是因为 MS COCO 中人体的平均宽高比为 4:3，正方形输入尺寸不符合统计特性。\n4. **注意力类型灵活性**：使用全注意力机制的 ViTPose 在 MS COCO 验证集上获得了最佳的 77.4 AP，但存在较大的内存占用。通过使用窗口注意力并结合移位窗口和池化窗口机制，可以在不显著增加内存占用的前提下提高性能。\n5. **部分微调灵活性**：在部分微调设置下，冻结 MHSA 模块的 ViTPose 性能仅略有下降，而冻结 FFN 模块则导致显著的性能下降，表明 FFN 模块对任务特定建模更为重要。\n6. **多数据集训练**：使用多数据集训练的 ViTPose 在 MS COCO 验证集上的性能从 75.8 AP 提高到 77.1 AP，表明 ViTPose 可以很好地利用不同数据集中的多样性数据。\n7. **知识转移**：通过知识令牌蒸馏，ViTPose-B 模型的 AP 提高了 0.2，而输出蒸馏则提高了 0.5，两种蒸馏方法相互补充，共同使用时可达到 76.6 AP，验证了 ViTPose 模型的良好可迁移性。\n\n> [https://yuanbao.tencent.com/bot/app/share/deep-reading-tab/deepRead/4w6dL6ZYki6w](https://yuanbao.tencent.com/bot/app/share/deep-reading-tab/deepRead/4w6dL6ZYki6w)\n\n> [https://yuanbao.tencent.com/bot/app/share/deep-reading-tab/summary/Tzi4OLgzGSzl](https://yuanbao.tencent.com/bot/app/share/deep-reading-tab/summary/Tzi4OLgzGSzl)\n","source":"_posts/2025-03-18-VitPose基于vit的姿态评估模型.md","raw":"---\ntitle: 2025-03-18-VitPose 基于 vit 的姿态评估模型\ndate: 2025-03-18\ntags: \n    深度学习\n    论文阅读\n---\n> 相关论文\n> [ViTPose: Simple Vision Transformer Baselines for Human Pose Estimation](https://arxiv.org/abs/2204.12484)\n\n# Motivation\n\n1. **研究问题**：这篇文章要解决的问题是如何利用简单的 ViT（Vision Transformer）进行人体姿态估计。尽管 ViT 在视觉识别任务中表现出色，但在姿态估计任务中的应用仍然有限。\n2. **研究难点**：该问题的研究难点包括：如何在不使用复杂结构设计的情况下实现高性能的姿态估计；如何提高模型的规模可扩展性；如何在训练过程中保持灵活性；以及如何在不同模型之间有效地转移知识。\n3. **相关工作**：该问题的研究相关工作有：PRTR、TokenPose、TransPose、HRFormer 等方法，这些方法通常采用 CNN 作为主干网络(传统的网络对于对于局部特征的提取能力很强大,但是全局特征信息提取能不很差)，然后使用复杂的变压器结构来细化特征和建模关键点之间的关系。然而，这些方法要么需要额外的 CNN 进行特征提取，要么需要对变压器结构进行精心设计以适应任务。\n\n# Method\n\n这篇论文提出了一个名为 ViTPose 的简单基线模型，用于解决人体姿态估计问题。具体来说，\n\n1. **模型结构**：ViTPose 采用简单的非分层视觉变压器作为主干网络，用于提取给定人体实例的特征图。主干网络通过预训练的掩码图像建模（Masked Image Modeling, MAE）任务进行初始化。然后，一个轻量级解码器处理提取的特征，通过上采样特征图和回归关键点热图来进行姿态估计。解码器由两个反卷积层和一个预测层组成。\n\n![17423110798271742311079755.png](https://tk-pichost-1325224430.cos.ap-chengdu.myqcloud.com/blog/17423110798271742311079755.png)\n\n1. **可扩展性**：通过堆叠不同数量的变压器层和增加或减少特征维度，可以轻松控制模型大小。例如，可以使用 ViT-B、ViT-L 或 ViT-H 来平衡推理速度和性能。\n2. **灵活性**：ViTPose 在训练范式方面非常灵活，可以适应不同的输入分辨率和特征分辨率。通过添加额外的解码器，可以灵活地适应多个姿态数据集，从而实现联合训练管道并显著提高性能。此外，即使在使用较小的未标记数据集进行预训练或冻结注意力模块进行微调时，ViTPose 仍能获得 SOTA 性能。\n3. **知识转移**：通过一个额外的可学习知识令牌，可以将大模型的知识转移到小模型中，从而提高小模型的性能。\n\n# Result\n\n1. **结构简单性和可扩展性**：使用简单解码器的 ViTPose 在 MS COCO 验证集上的表现与使用复杂解码器的 ResNet-50 和 ResNet-152 相当，表明普通视觉变压器具有强大的表示能力。随着模型大小的增加，ViTPose 的性能一致提高，展示了其良好的可扩展性。\n2. **预训练数据灵活性**：使用 MS COCO 和 AI Challenger 数据组合进行预训练的 ViTPose 在 MS COCO 验证集上的表现与使用 ImageNet-1K 数据预训练的模型相当，表明使用下游任务数据进行预训练具有更好的数据效率。\n3. **输入分辨率灵活性**：随着输入分辨率的增加，ViTPose 的性能也相应提高。使用正方形输入尺寸并未带来显著的性能提升，可能是因为 MS COCO 中人体的平均宽高比为 4:3，正方形输入尺寸不符合统计特性。\n4. **注意力类型灵活性**：使用全注意力机制的 ViTPose 在 MS COCO 验证集上获得了最佳的 77.4 AP，但存在较大的内存占用。通过使用窗口注意力并结合移位窗口和池化窗口机制，可以在不显著增加内存占用的前提下提高性能。\n5. **部分微调灵活性**：在部分微调设置下，冻结 MHSA 模块的 ViTPose 性能仅略有下降，而冻结 FFN 模块则导致显著的性能下降，表明 FFN 模块对任务特定建模更为重要。\n6. **多数据集训练**：使用多数据集训练的 ViTPose 在 MS COCO 验证集上的性能从 75.8 AP 提高到 77.1 AP，表明 ViTPose 可以很好地利用不同数据集中的多样性数据。\n7. **知识转移**：通过知识令牌蒸馏，ViTPose-B 模型的 AP 提高了 0.2，而输出蒸馏则提高了 0.5，两种蒸馏方法相互补充，共同使用时可达到 76.6 AP，验证了 ViTPose 模型的良好可迁移性。\n\n> [https://yuanbao.tencent.com/bot/app/share/deep-reading-tab/deepRead/4w6dL6ZYki6w](https://yuanbao.tencent.com/bot/app/share/deep-reading-tab/deepRead/4w6dL6ZYki6w)\n\n> [https://yuanbao.tencent.com/bot/app/share/deep-reading-tab/summary/Tzi4OLgzGSzl](https://yuanbao.tencent.com/bot/app/share/deep-reading-tab/summary/Tzi4OLgzGSzl)\n","slug":"2025-03-18-VitPose基于vit的姿态评估模型","published":1,"updated":"2025-09-26T12:16:25.850Z","_id":"cmg0saj3z000vjm8n84wvhjg0","comments":1,"layout":"post","photos":[],"content":"<blockquote>\n<p>相关论文<br><a href=\"https://arxiv.org/abs/2204.12484\">ViTPose: Simple Vision Transformer Baselines for Human Pose Estimation</a></p>\n</blockquote>\n<h1 id=\"Motivation\"><a href=\"#Motivation\" class=\"headerlink\" title=\"Motivation\"></a>Motivation</h1><ol>\n<li><strong>研究问题</strong>：这篇文章要解决的问题是如何利用简单的 ViT（Vision Transformer）进行人体姿态估计。尽管 ViT 在视觉识别任务中表现出色，但在姿态估计任务中的应用仍然有限。</li>\n<li><strong>研究难点</strong>：该问题的研究难点包括：如何在不使用复杂结构设计的情况下实现高性能的姿态估计；如何提高模型的规模可扩展性；如何在训练过程中保持灵活性；以及如何在不同模型之间有效地转移知识。</li>\n<li><strong>相关工作</strong>：该问题的研究相关工作有：PRTR、TokenPose、TransPose、HRFormer 等方法，这些方法通常采用 CNN 作为主干网络(传统的网络对于对于局部特征的提取能力很强大,但是全局特征信息提取能不很差)，然后使用复杂的变压器结构来细化特征和建模关键点之间的关系。然而，这些方法要么需要额外的 CNN 进行特征提取，要么需要对变压器结构进行精心设计以适应任务。</li>\n</ol>\n<h1 id=\"Method\"><a href=\"#Method\" class=\"headerlink\" title=\"Method\"></a>Method</h1><p>这篇论文提出了一个名为 ViTPose 的简单基线模型，用于解决人体姿态估计问题。具体来说，</p>\n<ol>\n<li><strong>模型结构</strong>：ViTPose 采用简单的非分层视觉变压器作为主干网络，用于提取给定人体实例的特征图。主干网络通过预训练的掩码图像建模（Masked Image Modeling, MAE）任务进行初始化。然后，一个轻量级解码器处理提取的特征，通过上采样特征图和回归关键点热图来进行姿态估计。解码器由两个反卷积层和一个预测层组成。</li>\n</ol>\n<p><img src=\"https://tk-pichost-1325224430.cos.ap-chengdu.myqcloud.com/blog/17423110798271742311079755.png\" alt=\"17423110798271742311079755.png\"></p>\n<ol>\n<li><strong>可扩展性</strong>：通过堆叠不同数量的变压器层和增加或减少特征维度，可以轻松控制模型大小。例如，可以使用 ViT-B、ViT-L 或 ViT-H 来平衡推理速度和性能。</li>\n<li><strong>灵活性</strong>：ViTPose 在训练范式方面非常灵活，可以适应不同的输入分辨率和特征分辨率。通过添加额外的解码器，可以灵活地适应多个姿态数据集，从而实现联合训练管道并显著提高性能。此外，即使在使用较小的未标记数据集进行预训练或冻结注意力模块进行微调时，ViTPose 仍能获得 SOTA 性能。</li>\n<li><strong>知识转移</strong>：通过一个额外的可学习知识令牌，可以将大模型的知识转移到小模型中，从而提高小模型的性能。</li>\n</ol>\n<h1 id=\"Result\"><a href=\"#Result\" class=\"headerlink\" title=\"Result\"></a>Result</h1><ol>\n<li><strong>结构简单性和可扩展性</strong>：使用简单解码器的 ViTPose 在 MS COCO 验证集上的表现与使用复杂解码器的 ResNet-50 和 ResNet-152 相当，表明普通视觉变压器具有强大的表示能力。随着模型大小的增加，ViTPose 的性能一致提高，展示了其良好的可扩展性。</li>\n<li><strong>预训练数据灵活性</strong>：使用 MS COCO 和 AI Challenger 数据组合进行预训练的 ViTPose 在 MS COCO 验证集上的表现与使用 ImageNet-1K 数据预训练的模型相当，表明使用下游任务数据进行预训练具有更好的数据效率。</li>\n<li><strong>输入分辨率灵活性</strong>：随着输入分辨率的增加，ViTPose 的性能也相应提高。使用正方形输入尺寸并未带来显著的性能提升，可能是因为 MS COCO 中人体的平均宽高比为 4:3，正方形输入尺寸不符合统计特性。</li>\n<li><strong>注意力类型灵活性</strong>：使用全注意力机制的 ViTPose 在 MS COCO 验证集上获得了最佳的 77.4 AP，但存在较大的内存占用。通过使用窗口注意力并结合移位窗口和池化窗口机制，可以在不显著增加内存占用的前提下提高性能。</li>\n<li><strong>部分微调灵活性</strong>：在部分微调设置下，冻结 MHSA 模块的 ViTPose 性能仅略有下降，而冻结 FFN 模块则导致显著的性能下降，表明 FFN 模块对任务特定建模更为重要。</li>\n<li><strong>多数据集训练</strong>：使用多数据集训练的 ViTPose 在 MS COCO 验证集上的性能从 75.8 AP 提高到 77.1 AP，表明 ViTPose 可以很好地利用不同数据集中的多样性数据。</li>\n<li><strong>知识转移</strong>：通过知识令牌蒸馏，ViTPose-B 模型的 AP 提高了 0.2，而输出蒸馏则提高了 0.5，两种蒸馏方法相互补充，共同使用时可达到 76.6 AP，验证了 ViTPose 模型的良好可迁移性。</li>\n</ol>\n<blockquote>\n<p><a href=\"https://yuanbao.tencent.com/bot/app/share/deep-reading-tab/deepRead/4w6dL6ZYki6w\">https://yuanbao.tencent.com/bot/app/share/deep-reading-tab/deepRead/4w6dL6ZYki6w</a></p>\n</blockquote>\n<blockquote>\n<p><a href=\"https://yuanbao.tencent.com/bot/app/share/deep-reading-tab/summary/Tzi4OLgzGSzl\">https://yuanbao.tencent.com/bot/app/share/deep-reading-tab/summary/Tzi4OLgzGSzl</a></p>\n</blockquote>\n","excerpt":"","more":"<blockquote>\n<p>相关论文<br><a href=\"https://arxiv.org/abs/2204.12484\">ViTPose: Simple Vision Transformer Baselines for Human Pose Estimation</a></p>\n</blockquote>\n<h1 id=\"Motivation\"><a href=\"#Motivation\" class=\"headerlink\" title=\"Motivation\"></a>Motivation</h1><ol>\n<li><strong>研究问题</strong>：这篇文章要解决的问题是如何利用简单的 ViT（Vision Transformer）进行人体姿态估计。尽管 ViT 在视觉识别任务中表现出色，但在姿态估计任务中的应用仍然有限。</li>\n<li><strong>研究难点</strong>：该问题的研究难点包括：如何在不使用复杂结构设计的情况下实现高性能的姿态估计；如何提高模型的规模可扩展性；如何在训练过程中保持灵活性；以及如何在不同模型之间有效地转移知识。</li>\n<li><strong>相关工作</strong>：该问题的研究相关工作有：PRTR、TokenPose、TransPose、HRFormer 等方法，这些方法通常采用 CNN 作为主干网络(传统的网络对于对于局部特征的提取能力很强大,但是全局特征信息提取能不很差)，然后使用复杂的变压器结构来细化特征和建模关键点之间的关系。然而，这些方法要么需要额外的 CNN 进行特征提取，要么需要对变压器结构进行精心设计以适应任务。</li>\n</ol>\n<h1 id=\"Method\"><a href=\"#Method\" class=\"headerlink\" title=\"Method\"></a>Method</h1><p>这篇论文提出了一个名为 ViTPose 的简单基线模型，用于解决人体姿态估计问题。具体来说，</p>\n<ol>\n<li><strong>模型结构</strong>：ViTPose 采用简单的非分层视觉变压器作为主干网络，用于提取给定人体实例的特征图。主干网络通过预训练的掩码图像建模（Masked Image Modeling, MAE）任务进行初始化。然后，一个轻量级解码器处理提取的特征，通过上采样特征图和回归关键点热图来进行姿态估计。解码器由两个反卷积层和一个预测层组成。</li>\n</ol>\n<p><img src=\"https://tk-pichost-1325224430.cos.ap-chengdu.myqcloud.com/blog/17423110798271742311079755.png\" alt=\"17423110798271742311079755.png\"></p>\n<ol>\n<li><strong>可扩展性</strong>：通过堆叠不同数量的变压器层和增加或减少特征维度，可以轻松控制模型大小。例如，可以使用 ViT-B、ViT-L 或 ViT-H 来平衡推理速度和性能。</li>\n<li><strong>灵活性</strong>：ViTPose 在训练范式方面非常灵活，可以适应不同的输入分辨率和特征分辨率。通过添加额外的解码器，可以灵活地适应多个姿态数据集，从而实现联合训练管道并显著提高性能。此外，即使在使用较小的未标记数据集进行预训练或冻结注意力模块进行微调时，ViTPose 仍能获得 SOTA 性能。</li>\n<li><strong>知识转移</strong>：通过一个额外的可学习知识令牌，可以将大模型的知识转移到小模型中，从而提高小模型的性能。</li>\n</ol>\n<h1 id=\"Result\"><a href=\"#Result\" class=\"headerlink\" title=\"Result\"></a>Result</h1><ol>\n<li><strong>结构简单性和可扩展性</strong>：使用简单解码器的 ViTPose 在 MS COCO 验证集上的表现与使用复杂解码器的 ResNet-50 和 ResNet-152 相当，表明普通视觉变压器具有强大的表示能力。随着模型大小的增加，ViTPose 的性能一致提高，展示了其良好的可扩展性。</li>\n<li><strong>预训练数据灵活性</strong>：使用 MS COCO 和 AI Challenger 数据组合进行预训练的 ViTPose 在 MS COCO 验证集上的表现与使用 ImageNet-1K 数据预训练的模型相当，表明使用下游任务数据进行预训练具有更好的数据效率。</li>\n<li><strong>输入分辨率灵活性</strong>：随着输入分辨率的增加，ViTPose 的性能也相应提高。使用正方形输入尺寸并未带来显著的性能提升，可能是因为 MS COCO 中人体的平均宽高比为 4:3，正方形输入尺寸不符合统计特性。</li>\n<li><strong>注意力类型灵活性</strong>：使用全注意力机制的 ViTPose 在 MS COCO 验证集上获得了最佳的 77.4 AP，但存在较大的内存占用。通过使用窗口注意力并结合移位窗口和池化窗口机制，可以在不显著增加内存占用的前提下提高性能。</li>\n<li><strong>部分微调灵活性</strong>：在部分微调设置下，冻结 MHSA 模块的 ViTPose 性能仅略有下降，而冻结 FFN 模块则导致显著的性能下降，表明 FFN 模块对任务特定建模更为重要。</li>\n<li><strong>多数据集训练</strong>：使用多数据集训练的 ViTPose 在 MS COCO 验证集上的性能从 75.8 AP 提高到 77.1 AP，表明 ViTPose 可以很好地利用不同数据集中的多样性数据。</li>\n<li><strong>知识转移</strong>：通过知识令牌蒸馏，ViTPose-B 模型的 AP 提高了 0.2，而输出蒸馏则提高了 0.5，两种蒸馏方法相互补充，共同使用时可达到 76.6 AP，验证了 ViTPose 模型的良好可迁移性。</li>\n</ol>\n<blockquote>\n<p><a href=\"https://yuanbao.tencent.com/bot/app/share/deep-reading-tab/deepRead/4w6dL6ZYki6w\">https://yuanbao.tencent.com/bot/app/share/deep-reading-tab/deepRead/4w6dL6ZYki6w</a></p>\n</blockquote>\n<blockquote>\n<p><a href=\"https://yuanbao.tencent.com/bot/app/share/deep-reading-tab/summary/Tzi4OLgzGSzl\">https://yuanbao.tencent.com/bot/app/share/deep-reading-tab/summary/Tzi4OLgzGSzl</a></p>\n</blockquote>\n"},{"title":"2025-03-18-使用 word 文档导出功能压缩图片的技巧","date":"2025-03-19T16:00:00.000Z","_content":"\n> 参考资料\n> [如何压缩图片大小？3 种图片压缩方法推荐(评论区)](https://zhuanlan.zhihu.com/p/559553058)\n\n### 实现方法\n\n以下是具体的操作步骤：\n\n1. 打开 Microsoft Word。\n2. 点击“插入”菜单，选择“图片”，然后选择你想要提取的图片文件。\n3. 调整图片大小和位置，使其符合你的需求。\n4. 点击“文件”菜单，选择“另存为”，在另存为对话框中选择“Web 页面(*.htm; *.html)”作为文件类型。\n![17424798217031742479821327.png](https://tk-pichost-1325224430.cos.ap-chengdu.myqcloud.com/blog/17424798217031742479821327.png)\n\n5. 选择保存位置，为文件命名，然后点击“保存”。\n6. 关闭 Word 文档。\n7. 在保存位置找到与网页文件同名的文件夹，打开它。\n8. 在文件夹中找到“images”子文件夹，你的图片就在里面。\n\n> 实测约 3mb 的图片可以压缩至 100kb 左右\n","source":"_posts/2025-03-20-使用word文档导出功能压缩图片的技巧.md","raw":"---\ntitle: 2025-03-18-使用 word 文档导出功能压缩图片的技巧\ndate: 2025-03-20\ntags: \n    问题解决\n---\n\n> 参考资料\n> [如何压缩图片大小？3 种图片压缩方法推荐(评论区)](https://zhuanlan.zhihu.com/p/559553058)\n\n### 实现方法\n\n以下是具体的操作步骤：\n\n1. 打开 Microsoft Word。\n2. 点击“插入”菜单，选择“图片”，然后选择你想要提取的图片文件。\n3. 调整图片大小和位置，使其符合你的需求。\n4. 点击“文件”菜单，选择“另存为”，在另存为对话框中选择“Web 页面(*.htm; *.html)”作为文件类型。\n![17424798217031742479821327.png](https://tk-pichost-1325224430.cos.ap-chengdu.myqcloud.com/blog/17424798217031742479821327.png)\n\n5. 选择保存位置，为文件命名，然后点击“保存”。\n6. 关闭 Word 文档。\n7. 在保存位置找到与网页文件同名的文件夹，打开它。\n8. 在文件夹中找到“images”子文件夹，你的图片就在里面。\n\n> 实测约 3mb 的图片可以压缩至 100kb 左右\n","slug":"2025-03-20-使用word文档导出功能压缩图片的技巧","published":1,"updated":"2025-09-26T12:16:29.077Z","_id":"cmg0saj40000xjm8n8rxx6oup","comments":1,"layout":"post","photos":[],"content":"<blockquote>\n<p>参考资料<br><a href=\"https://zhuanlan.zhihu.com/p/559553058\">如何压缩图片大小？3 种图片压缩方法推荐(评论区)</a></p>\n</blockquote>\n<h3 id=\"实现方法\"><a href=\"#实现方法\" class=\"headerlink\" title=\"实现方法\"></a>实现方法</h3><p>以下是具体的操作步骤：</p>\n<ol>\n<li><p>打开 Microsoft Word。</p>\n</li>\n<li><p>点击“插入”菜单，选择“图片”，然后选择你想要提取的图片文件。</p>\n</li>\n<li><p>调整图片大小和位置，使其符合你的需求。</p>\n</li>\n<li><p>点击“文件”菜单，选择“另存为”，在另存为对话框中选择“Web 页面(*.htm; *.html)”作为文件类型。<br><img src=\"https://tk-pichost-1325224430.cos.ap-chengdu.myqcloud.com/blog/17424798217031742479821327.png\" alt=\"17424798217031742479821327.png\"></p>\n</li>\n<li><p>选择保存位置，为文件命名，然后点击“保存”。</p>\n</li>\n<li><p>关闭 Word 文档。</p>\n</li>\n<li><p>在保存位置找到与网页文件同名的文件夹，打开它。</p>\n</li>\n<li><p>在文件夹中找到“images”子文件夹，你的图片就在里面。</p>\n</li>\n</ol>\n<blockquote>\n<p>实测约 3mb 的图片可以压缩至 100kb 左右</p>\n</blockquote>\n","excerpt":"","more":"<blockquote>\n<p>参考资料<br><a href=\"https://zhuanlan.zhihu.com/p/559553058\">如何压缩图片大小？3 种图片压缩方法推荐(评论区)</a></p>\n</blockquote>\n<h3 id=\"实现方法\"><a href=\"#实现方法\" class=\"headerlink\" title=\"实现方法\"></a>实现方法</h3><p>以下是具体的操作步骤：</p>\n<ol>\n<li><p>打开 Microsoft Word。</p>\n</li>\n<li><p>点击“插入”菜单，选择“图片”，然后选择你想要提取的图片文件。</p>\n</li>\n<li><p>调整图片大小和位置，使其符合你的需求。</p>\n</li>\n<li><p>点击“文件”菜单，选择“另存为”，在另存为对话框中选择“Web 页面(*.htm; *.html)”作为文件类型。<br><img src=\"https://tk-pichost-1325224430.cos.ap-chengdu.myqcloud.com/blog/17424798217031742479821327.png\" alt=\"17424798217031742479821327.png\"></p>\n</li>\n<li><p>选择保存位置，为文件命名，然后点击“保存”。</p>\n</li>\n<li><p>关闭 Word 文档。</p>\n</li>\n<li><p>在保存位置找到与网页文件同名的文件夹，打开它。</p>\n</li>\n<li><p>在文件夹中找到“images”子文件夹，你的图片就在里面。</p>\n</li>\n</ol>\n<blockquote>\n<p>实测约 3mb 的图片可以压缩至 100kb 左右</p>\n</blockquote>\n"},{"title":"2025-03-16-水“镜”安澜——基于YOLO11的智能溺水检测系统软件 V1.0 设计说明文档","date":"2025-03-15T16:00:00.000Z","_content":"\n> 为了申请计算机软件著作权，我们考虑到时间充裕且预算有限，决定自行撰写之前开发的溺水检测系统的软件说明文档，而不是委托代理机构。我们将这份文档发布在我的博客上，供自己和有需要的大学同学参考，虽然可能使用频率不高。\n\n<p style=\"background-color:rgb(75, 86, 135); padding: 10px; border: 1px solid red;\">\n    <strong>推荐使用飞书云文档在线观看效果更佳<a href=\"https://xcnx25vdviba.feishu.cn/wiki/WzXcwXyHPiNKXUk4U5AcbGuRn0e\">飞书文档链接</a></strong> \n</p>\n\n\n# 一、引言\n\n## 1. 编写目的\n\n本文档旨在详细阐述水“镜”安澜——基于 YOLO11 的智能溺水检测系统软件 V1.0 设计说明文档软件 V1.0 的设计和实现过程，以作为申请计算机软件著作权的技术文档。本文档的目标读者包括软件评审人员、开发人员和系统维护人员。\n\n## 2. 项目背景\n\n溺水是导致意外死亡的主要原因之一，尤其在夏季和水上活动频繁的季节。根据项目书提供的数据，河道为溺水高发地，且溺亡率极高。这一严峻的现状凸显了开发有效溺水检测系统的必要性。\n\n本项目旨在开发一个基于计算机视觉的智能溺水检测系统，利用深度学习技术实现对水域环境中人员行为的实时监控和分析。项目背景源于对提升水域安全管理效率和降低溺水事故发生率的迫切需求，通过采用先进的人工智能技术，为水域安全管理提供智能化的解决方案。\n\n本项目创新性地结合光学摄像头技术，实现高效、全天候的溺水检测系统。通过光学摄像头利用 YOLO11 模型进行河道水面的实例分割和人物的目标检测。系统可以通过计算水面与人物掩模的重合度，判断目标人物溺水状态，若超出设定重合度范围，自动判断其可能溺水，并及时发出警报。项目初衷在于应对夏季高发的溺水事故，传统人工检测存在注意力疲劳、反应时间长、视线受限等局限。项目旨在利用图像处理算法和 YOLO11 模型，研发一套智能溺水检测系统，实现实时监控、精准识别和快速响应。相较于已有的溺水检测方案，如青犀防溺水 AI 算法、DEWS 系统等，本项目方案在硬件和环境适应性上更为灵活。目前项目只适用于河道等地区青少年失足落水的情况，我们计算后期添加人物姿态评估算法，将人物的溺水状态精确到对应的姿态，提高系统的适用范围和准确率。\n\n## 3. 定义\n\n<table>\n<tr>\n<td>专有名词<br/></td><td>解释<br/></td></tr>\n<tr>\n<td>YOLO (You Only Look Once)<br/></td><td>一种高效的实时目标检测算法<br/></td></tr>\n<tr>\n<td>CV (Computer Vision)<br/></td><td> 计算机视觉技术，用于使机器“看”和处理图像<br/></td></tr>\n<tr>\n<td>GPU (Graphics Processing Unit)<br/></td><td> 图形处理器，用于加速图像和视频处理任务<br/></td></tr>\n<tr>\n<td>CUDA(Compute Unified Device Architecture)<br/></td><td> NVIDIA推出的并行计算平台和编程模型<br/></td></tr>\n<tr>\n<td>FPS (Frames Per Second)<br/></td><td>每秒帧数，用于衡量视频处理和显示的性能<br/></td></tr>\n</table>\n\n## 4. 参考资料\n\n<table>\n<tr>\n<td>资料名称名称<br/></td><td>解释<br/></td></tr>\n<tr>\n<td>https://pytorch.org/docs/<br/></td><td>PyTorch官方文档<br/></td></tr>\n<tr>\n<td>https://github.com/ultralytics/ultralytics<br/></td><td>YOLOv11官方网址<br/></td></tr>\n<tr>\n<td>https://docs.opencv.org/<br/></td><td>OpenCV-Python官方文档<br/></td></tr>\n<tr>\n<td>https://ttsmp3.com/ai<br/></td><td>AI生成系统报警语音<br/></td></tr>\n<tr>\n<td>https://webcamtests.com/<br/></td><td>开发过程中用于测试网络摄像头的情况<br/></td></tr>\n<tr>\n<td>https://github.com/tkzzzzzz6/downing_detect<br/></td><td>我们项目的github网址<br/></td></tr>\n</table>\n\n# 二、总体设计\n\n## 需求概述\n\n我们的溺水检测项目旨在以高通 QCS6490 平台为边缘计算终端平台，通过结合人工智能技术和智能监控系统，实现高效、精准的溺水检测和预警。项目系统采用 YOLO11n 模型，高精度训练，提高 YOLO11 模型的精确度与鲁棒性。结合光学摄像头，能够在各种复杂环境和天气条件下提供全天候的高精度、低延迟、强适应的实时监控系统。我们的项目预计部署于泳池、海滩、湖泊以及河道等多种水域环境，以减少溺水事故的发生，目前项目只适用于河道等地区青少年失足落水的情况，我们计划后期添加人物姿态评估算法，将人物的溺水状态精确到对应的姿态，提高系统的适用范围和准确率。\n\n![17421133300801742113329444.png](https://tk-pichost-1325224430.cos.ap-chengdu.myqcloud.com/blog/17421133300801742113329444.png)\n\n系统的主要功能需求包括：\n\n### 实时视频流分析\n\n允许系统接收并处理来自网络摄像头或虚拟摄像头摄像头的实时视频流以及视频文本。系统能够对视频帧进行逐帧分析，以识别和评估水域中个体的行为。此功能是溺水检测系统的核心，因为它为后续的人员检测和行为分析提供了基础数据。\n\n![1742113187081Z9i6bqevRoBENmx5jrHcJXfAnsd.png](https://tk-pichost-1325224430.cos.ap-chengdu.myqcloud.com/blog/1742113187081Z9i6bqevRoBENmx5jrHcJXfAnsd.png)\n![1742113238130VeKpbk1TNocTNxxj7UCclMhtnae.png](https://tk-pichost-1325224430.cos.ap-chengdu.myqcloud.com/blog/1742113238130VeKpbk1TNocTNxxj7UCclMhtnae.png)\n\n### 人员检测与跟踪\n\n![17421133790801742113378366.png](https://tk-pichost-1325224430.cos.ap-chengdu.myqcloud.com/blog/17421133790801742113378366.png)\n\n![17421133980811742113397191.png](https://tk-pichost-1325224430.cos.ap-chengdu.myqcloud.com/blog/17421133980811742113397191.png)\n![17421134100811742113409980.png](https://tk-pichost-1325224430.cos.ap-chengdu.myqcloud.com/blog/17421134100811742113409980.png)\n![17421134220861742113421703.png](https://tk-pichost-1325224430.cos.ap-chengdu.myqcloud.com/blog/17421134220861742113421703.png)\n![17421134910811742113490340.png](https://tk-pichost-1325224430.cos.ap-chengdu.myqcloud.com/blog/17421134910811742113490340.png)\n![17421135220821742113521782.png](https://tk-pichost-1325224430.cos.ap-chengdu.myqcloud.com/blog/17421135220821742113521782.png)\n![17421135460841742113545806.png](https://tk-pichost-1325224430.cos.ap-chengdu.myqcloud.com/blog/17421135460841742113545806.png)\n\n> [!TIP]\n\n- 添加随机高斯模糊，以帮助模型更灵活地适应摄像机焦点。\n- 灰度处理,合并颜色通道，使模型更快，并且对主体颜色不敏感。\n- 将图像拆分为平铺，以提高小对象的准确性。检测小物体时(尤其是在航拍图像和显微镜等情况下)。\n- Mosaic 将训练集中的多张照片合并为拼贴\n- 旋转和翻转,并将所有图片的大小都重新设置为 640*640\n\n系统利用先进的计算机视觉和深度学习技术，采用实例分割技术自动识别并标记视频中的人形轮廓。通过跟踪算法，系统能够持续监测个体在视频帧中的位置变化，即使在个体移动或暂时离开摄像头视野的情况下也能保持跟踪。\n\n![17421136260801742113625210.png](https://tk-pichost-1325224430.cos.ap-chengdu.myqcloud.com/blog/17421136260801742113625210.png)\n\n### 溺水行为识别\n\n![17421136400801742113639626.png](https://tk-pichost-1325224430.cos.ap-chengdu.myqcloud.com/blog/17421136400801742113639626.png)\n\n现有的溺水检测系统几乎采用的都是 YOLOV3 以及 YOLOV5 模型作为溺水检测系统的检测模型，在检测和响应时间上相比于 YOLO11 检测模型存在滞后，无法实现实时监控和快速预警。延迟的报警可能导致救援人员无法及时赶到现场，增加溺水者的生命危险。\n\n升级到 YOLO11 后，我们的溺水检测系统在关键性能上有了显著提升。YOLO11 以其快速的实时目标检测和精准的姿态评估能力，使我们能够迅速识别出溺水行为。与 YOLOv9 相比，YOLO11 在保持模型参数精简的同时，通过改进的特征提取技术和 GPU 优化，提高了检测的准确性和速度。这使得我们的系统能够更有效地在第一时间内发现并响应溺水事件，从而挽救生命。\n\n基于 YOLOv11 模型，系统能够分析个体的行为模式，识别出可能的溺水行为。系统会分析个体的姿态、动作和行为变化，如挣扎、静止不动或异常姿势，以判断是否存在溺水风险。此外，YOLO11 的改进使其在较低计算资源下也能保持高性能，适合边缘设备或云端推理使用。\n\n### 警报系统\n\n一旦系统识别出潜在的溺水行为，警报系统将立即触发。警报可以通过多种方式发出，包括声音警报、视觉警报（如屏幕上的警告信息）或通过移动应用发送通知。该功能确保了救援人员可以迅速响应，采取必要的救助措施。\n\n![17421136650801742113664539.png](https://tk-pichost-1325224430.cos.ap-chengdu.myqcloud.com/blog/17421136650801742113664539.png)\n\n![17421136850791742113684813.png](https://tk-pichost-1325224430.cos.ap-chengdu.myqcloud.com/blog/17421136850791742113684813.png)\n\n### 视频记录与回放\n\n![17421137010841742113700957.png](https://tk-pichost-1325224430.cos.ap-chengdu.myqcloud.com/blog/17421137010841742113700957.png)\n\n系统具备记录视频的能力，允许用户回放和审查过去的监控视频。这一功能对于事故分析和责任认定至关重要。视频记录还可以用于系统性能评估和优化，以提高溺水检测的准确性和可靠性。\n\n## 软件结构\n\n系统采用模块化设计，主要包含以下模块：\n\n```\nDOWNING_DETECT/\n├── model/\n│   ├── best_detect.pt\n│   └── best_seg.pt\n│\n├── output/\n│   └── output_video.mp4\n│\n├── resource/\n│   ├── downing_warning.mp3\n│   └── 检测到溺水危险.mp3\n│\n├── src/\n│   ├── __init__.py\n│   ├── audio_manager.py\n│   ├── detection_utils.py\n│   ├── downing_detect_video.py\n│   ├── downing_detect_webcam.py\n│   ├── model_loader.py\n│   └── video_processor.py\n│\n├── LICENSE\n├── README.md\n├── main.py\n├── requirements.txt\n└── train.py\n```\n\n- `_pycache_/`: Python 的字节码缓存目录。\n- `model/`: 存放模型文件。\n- `output/`: 存放输出视频。\n- `resource/`: 存放音频资源文件。\n- `src/`: 源代码目录，包含项目的主要 Python 模块。\n- `LICENSE`: 项目许可证文件。\n- `README.md`: 项目说明文档。\n- `main.py`: 主程序入口。\n- `requirements.txt`: 项目依赖列表。\n- `train.py`: 模型训练脚本。\n\n# 三、程序描述\n\n## 功能\n\n![17421137290801742113728392.png](https://tk-pichost-1325224430.cos.ap-chengdu.myqcloud.com/blog/17421137290801742113728392.png)\n\n### 视频处理模块：负责视频流的读取、处理和输出\n\n该模块是系统的核心，负责处理视频流的各个方面。它包括视频捕获，即从文件或摄像头获取视频数据；视频输出，即保存和显示处理后的视频；模型推理，即加载和应用河流和人物检测模型；以及重叠计算，即计算人物与河流的重叠率，这对于识别溺水行为至关重要。视频处理模块确保视频数据能够被有效地读取、分析和输出。\n\n### 模型加载模块：负责加载和管理深度学习模型\n\n模型加载模块负责加载和管理深度学习模型，这些模型是实现目标检测和图像处理功能的关键。它包括加载人物检测模型和河流检测模型，确保这些模型在系统运行时能够被正确调用。该模块还负责模型的管理和优化，以提高检测的准确性和效率。\n\n### 检测工具模块：提供目标检测和图像处理功能\n\n检测工具模块提供了一系列功能，用于目标检测和图像处理。它包括绘制河流掩码、绘制人物边界框、计算重叠率、显示警告信息和显示信息消息。这些功能对于分析视频帧中的行为和识别溺水迹象至关重要。检测工具模块是实现溺水检测算法的核心部分。\n\n### 音频管理模块：处理警报声音的播放\n\n音频管理模块负责处理警报声音的播放。它包括资源管理，即初始化和清理音频资源，以及音频播放，即播放和停止警告音频。在检测到潜在溺水行为时，该模块能够及时发出警报，确保警报能够迅速传达给监控人员或公众。\n\n### 主程序控制模块：协调各模块工作，提供用户界面\n\n主程序控制模块是系统的协调中心，负责协调各模块的工作，并提供用户界面。它包括初始化 VideoProcessor 进行视频处理，管理用户交互，如选择检测模式（视频文件或虚拟摄像头），以及处理视频输出和警告管理。主程序控制模块确保系统的各个部分能够协同工作，为用户提供一个直观的操作界面。\n\n![17421137430791742113742777.png](https://tk-pichost-1325224430.cos.ap-chengdu.myqcloud.com/blog/17421137430791742113742777.png)\n\n## 性能\n\n### 支持实时视频处理（30FPS 以上）\n\n系统设计需满足实时视频处理的需求，即能够以每秒 30 帧（FPS）以上的速度处理视频流。这意味着系统能够快速分析视频内容，并在极短的时间内识别出潜在的溺水行为。高帧率处理能力对于捕捉快速变化的场景至关重要，确保系统不会错过任何关键瞬间。\n\n### 检测精度达到 90% 以上\n\n![17421137590811742113758699.png](https://tk-pichost-1325224430.cos.ap-chengdu.myqcloud.com/blog/17421137590811742113758699.png)\n\n![17421137700821742113769185.png](https://tk-pichost-1325224430.cos.ap-chengdu.myqcloud.com/blog/17421137700821742113769185.png)\n\n系统的检测精度是衡量其性能的关键指标之一。该系统的目标检测精度需达到 90% 以上，这意味着在所有检测到的目标中，至少有 90% 是正确的溺水行为识别。这一高精度要求确保了系统的可靠性，减少了误报和漏报的可能性，从而提高了溺水检测的准确性和可信度。\n\n### 推理时间小于 10ms 秒每张图片\n\n![17421137850811742113784474.png](https://tk-pichost-1325224430.cos.ap-chengdu.myqcloud.com/blog/17421137850811742113784474.png)\n\n![17421138030811742113802244.png](https://tk-pichost-1325224430.cos.ap-chengdu.myqcloud.com/blog/17421138030811742113802244.png)\n\n### 支持 1080P 视频处理\n\n系统支持 1080P（全高清）及低于该分辨率的视频处理。高分辨率视频提供了更清晰的图像细节，有助于提高目标检测的准确性。此外，支持高分辨率视频也使得系统能够适应不同的监控环境和设备，增加了系统的适用性和灵活性。\n\n## 输入项目\n\n### 视频文件\n\n系统能够处理多种格式的视频文件，包括但不限于 MP4、AVI 等常见格式。这些视频文件可以是预先录制的，也可以是实时生成的。系统支持从本地存储设备或网络位置读取视频文件，以供分析和处理。\n\n以下是我们溺水检测系统支持的视频格式类型:\n\n<table>\n<tr>\n<td>格式<br/></td><td>扩展名<br/></td><td>描述<br/></td></tr>\n<tr>\n<td>AVI<br/></td><td>.avi<br/></td><td>音频视频交错格式，支持多种编码方式<br/></td></tr>\n<tr>\n<td>MP4<br/></td><td>.mp4<br/></td><td>常用的压缩格式，兼容性强<br/></td></tr>\n<tr>\n<td>MKV<br/></td><td>.mkv<br/></td><td>开放格式，支持多种视频编码和字幕<br/></td></tr>\n<tr>\n<td>MOV<br/></td><td>.mov<br/></td><td>Apple 的 QuickTime 视频格式<br/></td></tr>\n<tr>\n<td>WMV<br/></td><td>.wmv<br/></td><td>Windows 媒体视频格式<br/></td></tr>\n<tr>\n<td>FLV<br/></td><td>.flv<br/></td><td>Flash 视频格式<br/></td></tr>\n<tr>\n<td>WEBM<br/></td><td>.webm<br/></td><td>针对网络优化的视频格式<br/></td></tr>\n<tr>\n<td>MPEG<br/></td><td>.mpeg<br/></td><td>一种视频压缩标准，广泛使用<br/></td></tr>\n<tr>\n<td>3GP<br/></td><td>.3gp<br/></td><td>移动设备视频格式<br/></td></tr>\n</table>\n\n### 摄像头检测\n\n#### 实时摄像头视频流\n\n系统设计支持从实时摄像头视频流中获取数据。这包括物理摄像头（如 CCTV 摄像头）以及虚拟网络摄像头。对于虚拟网络摄像头，系统可以利用网络技术访问同一局域网内的平板和手机摄像头。这种设计提供了更大的灵活性，允许在没有物理摄像头的情况下，使用移动设备的摄像头作为监控设备。\n\n![17421138440811742113843683.png](https://tk-pichost-1325224430.cos.ap-chengdu.myqcloud.com/blog/17421138440811742113843683.png)\n\n#### 虚拟网络摄像头\n\n虚拟网络摄像头的实现需要在移动设备上安装相应的 webcam 应用。安装完成后，只要设备在同一局域网下，系统就可以直接调用平板和手机的摄像头。通常情况下，手机摄像头能够提供更高分辨率的图像，但可能在某些应用场景中不如物理摄像头广泛适用。\n\n![17421138560851742113855777.png](https://tk-pichost-1325224430.cos.ap-chengdu.myqcloud.com/blog/17421138560851742113855777.png)\n![17421138681211742113868050.png](https://tk-pichost-1325224430.cos.ap-chengdu.myqcloud.com/blog/17421138681211742113868050.png)\n\n### 配置参数\n\n系统运行需要一系列配置参数，这些参数可以由用户根据具体需求进行设置。配置参数包括视频源选择、输出路径等。用户可以通过命令行界面（CLI）输入这些参数，以定制系统的运行行为。\n\n![17421138900811742113889567.png](https://tk-pichost-1325224430.cos.ap-chengdu.myqcloud.com/blog/17421138900811742113889567.png)\n\n## 输出项目\n\n### 处理后的视频文件。\n\n![17421139070811742113906220.png](https://tk-pichost-1325224430.cos.ap-chengdu.myqcloud.com/blog/17421139070811742113906220.png)\n\n系统在完成检测过程后，将自动将相应的检测结果保存到名为 `output` 的文件夹中，以便于集中存放和管理输出的视频文件，确保用户可以方便地访问和查看这些检测结果。\n\n### 实时警报信息\n\n![17421139200811742113919172.png](https://tk-pichost-1325224430.cos.ap-chengdu.myqcloud.com/blog/17421139200811742113919172.png)\n\n![17421139300831742113929519.png](https://tk-pichost-1325224430.cos.ap-chengdu.myqcloud.com/blog/17421139300831742113929519.png)\n\n### 检测状态日志。\n\n## 算法\n\n### 图像预处理：\n\n图像预处理是训练溺水检测系统的模型中的一个关键步骤，旨在提高模型对图像的适应性和准确性。在训练模型之间我们对数据集采用了以下数据预处理方法:\n\n- 随机高斯模糊：通过添加随机高斯模糊，系统能够模拟不同摄像机焦点条件下的图像，从而使模型更加灵活，能够适应各种不同的视觉环境。\n- 灰度处理：将彩色图像转换为灰度图像，合并颜色通道，减少计算复杂度，使模型运行更快，同时降低模型对主体颜色的敏感度，提高检测的鲁棒性。\n- 图像拆分平铺：为了提高对小物体检测的准确性，特别是在航拍图像和显微镜图像等情况下，系统将图像拆分为多个小块进行处理，以捕捉更多细节。\n- Mosaic 数据增强：通过将训练集中的多张照片合并为一张拼贴图像，系统能够增加训练数据的多样性，提高模型对未见场景的泛化能力。\n- 旋转和翻转：对图像进行随机旋转和翻转，以模拟不同的拍摄角度，增强模型对不同方向目标的识别能力。同时，将所有图片的大小统一重新设置为 640x640 像素，以适应模型的输入要求。\n\n### 目标检测、语义分割以及实例分割技术\n\n#### 目标检测\n\n目标检测就像是给视频中的每个物体贴上标签。想象一下，你在看一个视频，视频中有很多人和物体，目标检测技术要做的就是识别出视频中的每个人或物体，并在它们周围画一个框，同时告诉计算机：“看，这里有一个目标！” 这样，计算机就知道视频中有哪些物体，它们在哪里了。\n\n#### 实例分割\n\n实例分割则更进一步，它不仅要识别出视频中的每个人或物体，还要精确地知道每个目标的边界在哪里。这就像是用一支笔画出每个人的轮廓，确保没有两个人的轮廓重叠。这样，即使有多个人站在一起，计算机也能清楚地区分出谁是谁。\n\n#### 语义分割\n\n语义分割与实例分割有些相似，但它关注的是图像中的每个像素属于哪个类别，比如河流、草地或道路。它会给图像中的每个像素分配一个标签，告诉我们这个像素是属于河流还是其他什么。这就像是给一幅画中的每个部分上色，每种颜色代表一种不同的物体或区域。\n\n我们的系统主要训练了两个 YOLO11 模型分别完成对人物同时进行目标检测与实例分割的 detection 模型以及对河流进行语义分割的 seg 模型。\n\n### 溺水检测算法\n\n溺水检测算法是系统的核心，它结合了目标检测、实例分割和语义分割技术，以实现对溺水行为的准确识别。\n\n- 目标检测与实例分割：首先对人物进行目标检测与实例分割，以识别和定位图像中的人物。\n- 语义分割：对河流等水域进行语义分割，以区分水域和其他区域。\n- 重叠率计算：计算检测出的人物像素点与河流像素点的重叠率。如果人在目标检测的像素点中与河流的像素点的重叠率在 80% 以上，系统预测人有溺水的风险，并发出报警提示。如果人在实例分割的像素点与河流的像素点的重叠率在 75% 以上，系统检测到人溺水，并发出报警提示，同时进行语义播报，提示安保人员采取行动。\n\n## 程序逻辑\n\n![17421139540811742113953297.png](https://tk-pichost-1325224430.cos.ap-chengdu.myqcloud.com/blog/17421139540811742113953297.png)\n\n主要处理流程：\n\n### 视频输入\n\n系统接收的视频输入可以是本地存储的文件，如 MP4 或 AVI 格式，或是实时捕获的摄像头视频流。此外，系统设计有网络功能，能够在同一局域网内直接调用平板和手机的摄像头，这增加了系统的灵活性和适用性。对于网络摄像头，系统将通过网络协议（如 RTSP）接收视频数据。\n\n### 帧处理\n\n视频流在输入后被分解为单独的帧，这些帧随后被送入预处理模块。\n\n### 模型检测\n\n- 人物目标检测与实例分割模型：负责识别和定位视频中的每个人，为每个人绘制边界框，并输出位置信息。\n- 河流语义分割模型：进行像素级别的分割，精确区分个体轮廓，为行为分析提供详细数据。\n\n### 行为分析\n\n系统分析个体的行为，特别是与水域相关的活动。这包括：\n\n- 计算个体与河流等水域的像素点重叠率，判断个体是否处于溺水风险中。\n- 分析个体的姿态和动作，识别出挣扎、静止不动或异常姿势等可能的溺水迹象。\n\n### 警报触发\n\n基于行为分析的结果，系统决定是否触发警报。警报触发条件包括：\n\n- 个体与水域的重叠率超过 80%，系统预测存在溺水风险，发出警报提示。\n- 个体与水域的重叠率超过 75%，系统确认检测到溺水行为，发出警报，并进行语义播报提示安保人员。\n\n### 视频输出\n\n处理后的视频帧被重新组合成视频流，用于记录、回放或进一步分析。这不仅有助于事故后的审查，也可以用于系统性能的评估和优化。视频输出模块负责将处理后的视频保存到指定路径，并提供回放功能，以便用户可以查看和分析检测结果。\n\n## 接口\n\n### 视频输入接口\n\n视频输入接口负责接收和处理来自不同来源的视频数据。这个接口支持多种视频输入格式，包括但不限于 MP4、AVI 等，以适应不同的监控环境和设备。此外，该接口还支持实时视频流，能够从网络摄像头、物理摄像头或移动设备捕获视频。为了提高系统的灵活性和适应性，视频输入接口还应能够处理不同分辨率和帧率的视频数据。\n\n- 功能：\n  - 支持多种视频文件格式的读取。\n  - 能够从网络摄像头或移动设备捕获实时视频流。\n  - 处理不同分辨率和帧率的视频数据。\n\n### 模型调用接口\n\n模型调用接口是系统与深度学习模型交互的关键。它负责加载、管理和调用用于目标检测、实例分割和语义分割的模型。这个接口确保模型能够在需要时被快速且准确地调用，从而实现高效的视频分析和处理。\n\n- 功能：\n  - 加载预训练的深度学习模型。\n  - 提供模型调用的 API，以便在视频处理过程中进行目标检测和分割。\n  - 管理和优化模型的内存使用，确保系统的稳定运行。\n\n### 警报系统接口\n\n警报系统接口负责在检测到潜在溺水行为时触发警报。这个接口需要能够快速响应检测结果，并根据预设的阈值决定是否发出警报。警报可以通过声音、视觉信号或移动通知等多种方式发出，以确保信息能够及时传达给监控人员。\n\n- 功能：\n  - 根据溺水检测算法的输出决定是否触发警报。\n  - 支持多种警报方式，包括声音、视觉信号和移动通知。\n  - 确保警报的及时性和准确性。\n\n### 用户交互接口\n\n用户交互接口是系统与用户之间沟通的渠道。它提供了一个用户友好的界面，使用户能够轻松地配置系统参数、选择视频源、查看检测结果和接收警报。这个接口的设计应考虑到易用性和直观性，以降低用户的使用门槛。\n\n- 功能：\n  - 提供用户配置系统参数的界面，如检测灵敏度、警报阈值等。\n  - 允许用户选择视频输入源和查看处理后的视频。\n  - 显示实时警报信息和系统状态更新。\n  - 提供用户反馈和系统性能评估的途径。\n\n## 存储分配\n\n### 模型文件：`./model/`\n\n![17421139890831742113988930.png](https://tk-pichost-1325224430.cos.ap-chengdu.myqcloud.com/blog/17421139890831742113988930.png)\n\n### 输出文件：`./output/`\n\n![17421140070851742114007023.png](https://tk-pichost-1325224430.cos.ap-chengdu.myqcloud.com/blog/17421140070851742114007023.png)\n\n### 资源文件：`./resource/`\n\n![17421140180851742114017407.png](https://tk-pichost-1325224430.cos.ap-chengdu.myqcloud.com/blog/17421140180851742114017407.png)\n\n### 源代码：`./src/`\n\n![17421140290841742114028567.png](https://tk-pichost-1325224430.cos.ap-chengdu.myqcloud.com/blog/17421140290841742114028567.png)\n\n## 限制条件\n\n<table>\n<tr>\n<td>- Python 3.8+运行环境<br/></td></tr>\n<tr>\n<td>- CUDA支持（推荐）<br/></td></tr>\n<tr>\n<td>- 最小8GB内存<br/></td></tr>\n<tr>\n<td>- 支持OpenCV的操作系统<br/></td></tr>\n</table>\n\n## 测试要点\n\n### 视频处理性能测试\n\n视频处理性能测试旨在评估系统处理视频流的能力，包括实时性、帧率和视频质量。测试将模拟不同的视频输入条件，如不同的分辨率、帧率和编码格式，以确保系统能够在各种情况下稳定运行。\n\n- 目标：确保系统能够以至少 30FPS 的速度处理 1080P 视频，同时保持低延迟。\n- 方法：使用不同参数的视频文件进行播放，测量处理时间和输出视频的质量。\n\n### 检测准确率测试\n\n检测准确率测试用于验证目标检测和实例分割模型的准确性。这包括检测模型能否正确识别和定位视频中的人物，以及分割模型能否准确区分个体和背景。\n\n- 目标：达到 90% 以上的检测准确率。\n- 方法：通过与人工标注的测试集比较，计算模型的精确度、召回率和 F1 分数。\n\n### 警报系统响应测试\n\n警报系统响应测试确保在检测到溺水行为时，系统能够及时发出警报。这包括测试警报的触发逻辑和警报的传递速度。\n\n- 目标：警报响应时间小于 1 秒。\n- 方法：模拟溺水场景，测量从检测到警报发出的时间。\n\n### 内存占用测试\n\n内存占用测试评估系统运行时的内存使用情况，以确保系统在资源有限的环境中也能高效运行。\n\n- 目标：优化内存使用，避免内存泄漏。\n- 方法：监控系统运行过程中的内存使用情况，特别是在处理大量视频数据时。\n\n### 长时间运行稳定性测试\n\n长时间运行稳定性测试用于验证系统在连续运行条件下的稳定性和可靠性。这包括测试系统是否能够长时间稳定运行而不出现崩溃或性能下降。\n\n- 目标：确保系统能够连续运行至少 72 小时无故障。\n- 方法：让系统连续处理视频流，监控其性能和资源使用情况。\n\n## 安装步骤\n\n### 克隆仓库:\n\n```bash\ngit clone https://github.com/your-username/drowning-detection.git\ncd drowning-detection\n```\n\n### 创建并激活虚拟环境(推荐):\n\n```bash\npython -m venv venv\nsource venv/bin/activate  # 在Windows上使用 venv\\Scripts\\activate\n```\n\n### 安装依赖:\n\n```bash\npip install -r requirements.txt\n```\n\n这将安装项目所需的所有依赖项,并确保版本与开发环境一致。\n\n> 注意: 如果您在安装过程中遇到任何问题,特别是与 CUDA 或 GPU 支持相关的问题,请参考 PyTorch 官方文档以获取适合您系统的安装说明。\n\n## 使用说明\n\n### 确保您有适当的视频文件用于检测。\n\n### 修改 `main.py` 中的 `video_path` 变量,指向您的视频文件:\n\n```bash\nvideo_path = \"path/to/your/video.mp4\"\n```\n\n### 运行主程序:\n\n```bash\npython main.py\n```\n\n### 程序将开始处理视频,并在检测到潜在溺水危险时发出警告。\n\n### 按 'q' 键退出程序。\n\n# 四、项目总结\n\n在反思这个溺水检测项目时，我们意识到技术的进步不仅仅是为了创新，更是为了解决实际问题，保护人们的生命安全。我们的项目通过结合最新的人工智能技术和多种监控手段，旨在减少溺水事故，这是一个极具社会价值的目标。我们认识到，尽管技术提供了强大的工具，但真正的挑战在于如何将这些工具有效地应用于实际场景中，以及如何确保系统的稳定性和可靠性。未来，我们将继续优化算法，提高系统的响应速度和准确性，同时，我们也将探索如何降低成本，使这项技术能够更广泛地应用于各种水域，从而保护更多人的生命。\n\n在推广方面，我们认为教育和意识提升同样重要。如果可行的话，我们将与学校、社区和地方政府合作，提高公众对溺水风险的认识，并教育他们如何使用我们的系统。此外，我们也将通过各种媒体渠道，如社交媒体、公共讲座和行业会议，来展示我们的技术成果，以吸引更多的关注和支持。我们相信，通过技术的推广和公众意识的提高，我们可以共同构建一个更安全的水上环境。让人类拥有更美好的未来！\n","source":"_posts/2025-03-16-水“镜”安澜——基于YOLO11的智能溺水检测系统软件 V1.0 设计说明文档.md","raw":"---\ntitle: 2025-03-16-水“镜”安澜——基于YOLO11的智能溺水检测系统软件 V1.0 设计说明文档\ndate: 2025-03-16\ntags: 程序开发\n---\n\n> 为了申请计算机软件著作权，我们考虑到时间充裕且预算有限，决定自行撰写之前开发的溺水检测系统的软件说明文档，而不是委托代理机构。我们将这份文档发布在我的博客上，供自己和有需要的大学同学参考，虽然可能使用频率不高。\n\n<p style=\"background-color:rgb(75, 86, 135); padding: 10px; border: 1px solid red;\">\n    <strong>推荐使用飞书云文档在线观看效果更佳<a href=\"https://xcnx25vdviba.feishu.cn/wiki/WzXcwXyHPiNKXUk4U5AcbGuRn0e\">飞书文档链接</a></strong> \n</p>\n\n\n# 一、引言\n\n## 1. 编写目的\n\n本文档旨在详细阐述水“镜”安澜——基于 YOLO11 的智能溺水检测系统软件 V1.0 设计说明文档软件 V1.0 的设计和实现过程，以作为申请计算机软件著作权的技术文档。本文档的目标读者包括软件评审人员、开发人员和系统维护人员。\n\n## 2. 项目背景\n\n溺水是导致意外死亡的主要原因之一，尤其在夏季和水上活动频繁的季节。根据项目书提供的数据，河道为溺水高发地，且溺亡率极高。这一严峻的现状凸显了开发有效溺水检测系统的必要性。\n\n本项目旨在开发一个基于计算机视觉的智能溺水检测系统，利用深度学习技术实现对水域环境中人员行为的实时监控和分析。项目背景源于对提升水域安全管理效率和降低溺水事故发生率的迫切需求，通过采用先进的人工智能技术，为水域安全管理提供智能化的解决方案。\n\n本项目创新性地结合光学摄像头技术，实现高效、全天候的溺水检测系统。通过光学摄像头利用 YOLO11 模型进行河道水面的实例分割和人物的目标检测。系统可以通过计算水面与人物掩模的重合度，判断目标人物溺水状态，若超出设定重合度范围，自动判断其可能溺水，并及时发出警报。项目初衷在于应对夏季高发的溺水事故，传统人工检测存在注意力疲劳、反应时间长、视线受限等局限。项目旨在利用图像处理算法和 YOLO11 模型，研发一套智能溺水检测系统，实现实时监控、精准识别和快速响应。相较于已有的溺水检测方案，如青犀防溺水 AI 算法、DEWS 系统等，本项目方案在硬件和环境适应性上更为灵活。目前项目只适用于河道等地区青少年失足落水的情况，我们计算后期添加人物姿态评估算法，将人物的溺水状态精确到对应的姿态，提高系统的适用范围和准确率。\n\n## 3. 定义\n\n<table>\n<tr>\n<td>专有名词<br/></td><td>解释<br/></td></tr>\n<tr>\n<td>YOLO (You Only Look Once)<br/></td><td>一种高效的实时目标检测算法<br/></td></tr>\n<tr>\n<td>CV (Computer Vision)<br/></td><td> 计算机视觉技术，用于使机器“看”和处理图像<br/></td></tr>\n<tr>\n<td>GPU (Graphics Processing Unit)<br/></td><td> 图形处理器，用于加速图像和视频处理任务<br/></td></tr>\n<tr>\n<td>CUDA(Compute Unified Device Architecture)<br/></td><td> NVIDIA推出的并行计算平台和编程模型<br/></td></tr>\n<tr>\n<td>FPS (Frames Per Second)<br/></td><td>每秒帧数，用于衡量视频处理和显示的性能<br/></td></tr>\n</table>\n\n## 4. 参考资料\n\n<table>\n<tr>\n<td>资料名称名称<br/></td><td>解释<br/></td></tr>\n<tr>\n<td>https://pytorch.org/docs/<br/></td><td>PyTorch官方文档<br/></td></tr>\n<tr>\n<td>https://github.com/ultralytics/ultralytics<br/></td><td>YOLOv11官方网址<br/></td></tr>\n<tr>\n<td>https://docs.opencv.org/<br/></td><td>OpenCV-Python官方文档<br/></td></tr>\n<tr>\n<td>https://ttsmp3.com/ai<br/></td><td>AI生成系统报警语音<br/></td></tr>\n<tr>\n<td>https://webcamtests.com/<br/></td><td>开发过程中用于测试网络摄像头的情况<br/></td></tr>\n<tr>\n<td>https://github.com/tkzzzzzz6/downing_detect<br/></td><td>我们项目的github网址<br/></td></tr>\n</table>\n\n# 二、总体设计\n\n## 需求概述\n\n我们的溺水检测项目旨在以高通 QCS6490 平台为边缘计算终端平台，通过结合人工智能技术和智能监控系统，实现高效、精准的溺水检测和预警。项目系统采用 YOLO11n 模型，高精度训练，提高 YOLO11 模型的精确度与鲁棒性。结合光学摄像头，能够在各种复杂环境和天气条件下提供全天候的高精度、低延迟、强适应的实时监控系统。我们的项目预计部署于泳池、海滩、湖泊以及河道等多种水域环境，以减少溺水事故的发生，目前项目只适用于河道等地区青少年失足落水的情况，我们计划后期添加人物姿态评估算法，将人物的溺水状态精确到对应的姿态，提高系统的适用范围和准确率。\n\n![17421133300801742113329444.png](https://tk-pichost-1325224430.cos.ap-chengdu.myqcloud.com/blog/17421133300801742113329444.png)\n\n系统的主要功能需求包括：\n\n### 实时视频流分析\n\n允许系统接收并处理来自网络摄像头或虚拟摄像头摄像头的实时视频流以及视频文本。系统能够对视频帧进行逐帧分析，以识别和评估水域中个体的行为。此功能是溺水检测系统的核心，因为它为后续的人员检测和行为分析提供了基础数据。\n\n![1742113187081Z9i6bqevRoBENmx5jrHcJXfAnsd.png](https://tk-pichost-1325224430.cos.ap-chengdu.myqcloud.com/blog/1742113187081Z9i6bqevRoBENmx5jrHcJXfAnsd.png)\n![1742113238130VeKpbk1TNocTNxxj7UCclMhtnae.png](https://tk-pichost-1325224430.cos.ap-chengdu.myqcloud.com/blog/1742113238130VeKpbk1TNocTNxxj7UCclMhtnae.png)\n\n### 人员检测与跟踪\n\n![17421133790801742113378366.png](https://tk-pichost-1325224430.cos.ap-chengdu.myqcloud.com/blog/17421133790801742113378366.png)\n\n![17421133980811742113397191.png](https://tk-pichost-1325224430.cos.ap-chengdu.myqcloud.com/blog/17421133980811742113397191.png)\n![17421134100811742113409980.png](https://tk-pichost-1325224430.cos.ap-chengdu.myqcloud.com/blog/17421134100811742113409980.png)\n![17421134220861742113421703.png](https://tk-pichost-1325224430.cos.ap-chengdu.myqcloud.com/blog/17421134220861742113421703.png)\n![17421134910811742113490340.png](https://tk-pichost-1325224430.cos.ap-chengdu.myqcloud.com/blog/17421134910811742113490340.png)\n![17421135220821742113521782.png](https://tk-pichost-1325224430.cos.ap-chengdu.myqcloud.com/blog/17421135220821742113521782.png)\n![17421135460841742113545806.png](https://tk-pichost-1325224430.cos.ap-chengdu.myqcloud.com/blog/17421135460841742113545806.png)\n\n> [!TIP]\n\n- 添加随机高斯模糊，以帮助模型更灵活地适应摄像机焦点。\n- 灰度处理,合并颜色通道，使模型更快，并且对主体颜色不敏感。\n- 将图像拆分为平铺，以提高小对象的准确性。检测小物体时(尤其是在航拍图像和显微镜等情况下)。\n- Mosaic 将训练集中的多张照片合并为拼贴\n- 旋转和翻转,并将所有图片的大小都重新设置为 640*640\n\n系统利用先进的计算机视觉和深度学习技术，采用实例分割技术自动识别并标记视频中的人形轮廓。通过跟踪算法，系统能够持续监测个体在视频帧中的位置变化，即使在个体移动或暂时离开摄像头视野的情况下也能保持跟踪。\n\n![17421136260801742113625210.png](https://tk-pichost-1325224430.cos.ap-chengdu.myqcloud.com/blog/17421136260801742113625210.png)\n\n### 溺水行为识别\n\n![17421136400801742113639626.png](https://tk-pichost-1325224430.cos.ap-chengdu.myqcloud.com/blog/17421136400801742113639626.png)\n\n现有的溺水检测系统几乎采用的都是 YOLOV3 以及 YOLOV5 模型作为溺水检测系统的检测模型，在检测和响应时间上相比于 YOLO11 检测模型存在滞后，无法实现实时监控和快速预警。延迟的报警可能导致救援人员无法及时赶到现场，增加溺水者的生命危险。\n\n升级到 YOLO11 后，我们的溺水检测系统在关键性能上有了显著提升。YOLO11 以其快速的实时目标检测和精准的姿态评估能力，使我们能够迅速识别出溺水行为。与 YOLOv9 相比，YOLO11 在保持模型参数精简的同时，通过改进的特征提取技术和 GPU 优化，提高了检测的准确性和速度。这使得我们的系统能够更有效地在第一时间内发现并响应溺水事件，从而挽救生命。\n\n基于 YOLOv11 模型，系统能够分析个体的行为模式，识别出可能的溺水行为。系统会分析个体的姿态、动作和行为变化，如挣扎、静止不动或异常姿势，以判断是否存在溺水风险。此外，YOLO11 的改进使其在较低计算资源下也能保持高性能，适合边缘设备或云端推理使用。\n\n### 警报系统\n\n一旦系统识别出潜在的溺水行为，警报系统将立即触发。警报可以通过多种方式发出，包括声音警报、视觉警报（如屏幕上的警告信息）或通过移动应用发送通知。该功能确保了救援人员可以迅速响应，采取必要的救助措施。\n\n![17421136650801742113664539.png](https://tk-pichost-1325224430.cos.ap-chengdu.myqcloud.com/blog/17421136650801742113664539.png)\n\n![17421136850791742113684813.png](https://tk-pichost-1325224430.cos.ap-chengdu.myqcloud.com/blog/17421136850791742113684813.png)\n\n### 视频记录与回放\n\n![17421137010841742113700957.png](https://tk-pichost-1325224430.cos.ap-chengdu.myqcloud.com/blog/17421137010841742113700957.png)\n\n系统具备记录视频的能力，允许用户回放和审查过去的监控视频。这一功能对于事故分析和责任认定至关重要。视频记录还可以用于系统性能评估和优化，以提高溺水检测的准确性和可靠性。\n\n## 软件结构\n\n系统采用模块化设计，主要包含以下模块：\n\n```\nDOWNING_DETECT/\n├── model/\n│   ├── best_detect.pt\n│   └── best_seg.pt\n│\n├── output/\n│   └── output_video.mp4\n│\n├── resource/\n│   ├── downing_warning.mp3\n│   └── 检测到溺水危险.mp3\n│\n├── src/\n│   ├── __init__.py\n│   ├── audio_manager.py\n│   ├── detection_utils.py\n│   ├── downing_detect_video.py\n│   ├── downing_detect_webcam.py\n│   ├── model_loader.py\n│   └── video_processor.py\n│\n├── LICENSE\n├── README.md\n├── main.py\n├── requirements.txt\n└── train.py\n```\n\n- `_pycache_/`: Python 的字节码缓存目录。\n- `model/`: 存放模型文件。\n- `output/`: 存放输出视频。\n- `resource/`: 存放音频资源文件。\n- `src/`: 源代码目录，包含项目的主要 Python 模块。\n- `LICENSE`: 项目许可证文件。\n- `README.md`: 项目说明文档。\n- `main.py`: 主程序入口。\n- `requirements.txt`: 项目依赖列表。\n- `train.py`: 模型训练脚本。\n\n# 三、程序描述\n\n## 功能\n\n![17421137290801742113728392.png](https://tk-pichost-1325224430.cos.ap-chengdu.myqcloud.com/blog/17421137290801742113728392.png)\n\n### 视频处理模块：负责视频流的读取、处理和输出\n\n该模块是系统的核心，负责处理视频流的各个方面。它包括视频捕获，即从文件或摄像头获取视频数据；视频输出，即保存和显示处理后的视频；模型推理，即加载和应用河流和人物检测模型；以及重叠计算，即计算人物与河流的重叠率，这对于识别溺水行为至关重要。视频处理模块确保视频数据能够被有效地读取、分析和输出。\n\n### 模型加载模块：负责加载和管理深度学习模型\n\n模型加载模块负责加载和管理深度学习模型，这些模型是实现目标检测和图像处理功能的关键。它包括加载人物检测模型和河流检测模型，确保这些模型在系统运行时能够被正确调用。该模块还负责模型的管理和优化，以提高检测的准确性和效率。\n\n### 检测工具模块：提供目标检测和图像处理功能\n\n检测工具模块提供了一系列功能，用于目标检测和图像处理。它包括绘制河流掩码、绘制人物边界框、计算重叠率、显示警告信息和显示信息消息。这些功能对于分析视频帧中的行为和识别溺水迹象至关重要。检测工具模块是实现溺水检测算法的核心部分。\n\n### 音频管理模块：处理警报声音的播放\n\n音频管理模块负责处理警报声音的播放。它包括资源管理，即初始化和清理音频资源，以及音频播放，即播放和停止警告音频。在检测到潜在溺水行为时，该模块能够及时发出警报，确保警报能够迅速传达给监控人员或公众。\n\n### 主程序控制模块：协调各模块工作，提供用户界面\n\n主程序控制模块是系统的协调中心，负责协调各模块的工作，并提供用户界面。它包括初始化 VideoProcessor 进行视频处理，管理用户交互，如选择检测模式（视频文件或虚拟摄像头），以及处理视频输出和警告管理。主程序控制模块确保系统的各个部分能够协同工作，为用户提供一个直观的操作界面。\n\n![17421137430791742113742777.png](https://tk-pichost-1325224430.cos.ap-chengdu.myqcloud.com/blog/17421137430791742113742777.png)\n\n## 性能\n\n### 支持实时视频处理（30FPS 以上）\n\n系统设计需满足实时视频处理的需求，即能够以每秒 30 帧（FPS）以上的速度处理视频流。这意味着系统能够快速分析视频内容，并在极短的时间内识别出潜在的溺水行为。高帧率处理能力对于捕捉快速变化的场景至关重要，确保系统不会错过任何关键瞬间。\n\n### 检测精度达到 90% 以上\n\n![17421137590811742113758699.png](https://tk-pichost-1325224430.cos.ap-chengdu.myqcloud.com/blog/17421137590811742113758699.png)\n\n![17421137700821742113769185.png](https://tk-pichost-1325224430.cos.ap-chengdu.myqcloud.com/blog/17421137700821742113769185.png)\n\n系统的检测精度是衡量其性能的关键指标之一。该系统的目标检测精度需达到 90% 以上，这意味着在所有检测到的目标中，至少有 90% 是正确的溺水行为识别。这一高精度要求确保了系统的可靠性，减少了误报和漏报的可能性，从而提高了溺水检测的准确性和可信度。\n\n### 推理时间小于 10ms 秒每张图片\n\n![17421137850811742113784474.png](https://tk-pichost-1325224430.cos.ap-chengdu.myqcloud.com/blog/17421137850811742113784474.png)\n\n![17421138030811742113802244.png](https://tk-pichost-1325224430.cos.ap-chengdu.myqcloud.com/blog/17421138030811742113802244.png)\n\n### 支持 1080P 视频处理\n\n系统支持 1080P（全高清）及低于该分辨率的视频处理。高分辨率视频提供了更清晰的图像细节，有助于提高目标检测的准确性。此外，支持高分辨率视频也使得系统能够适应不同的监控环境和设备，增加了系统的适用性和灵活性。\n\n## 输入项目\n\n### 视频文件\n\n系统能够处理多种格式的视频文件，包括但不限于 MP4、AVI 等常见格式。这些视频文件可以是预先录制的，也可以是实时生成的。系统支持从本地存储设备或网络位置读取视频文件，以供分析和处理。\n\n以下是我们溺水检测系统支持的视频格式类型:\n\n<table>\n<tr>\n<td>格式<br/></td><td>扩展名<br/></td><td>描述<br/></td></tr>\n<tr>\n<td>AVI<br/></td><td>.avi<br/></td><td>音频视频交错格式，支持多种编码方式<br/></td></tr>\n<tr>\n<td>MP4<br/></td><td>.mp4<br/></td><td>常用的压缩格式，兼容性强<br/></td></tr>\n<tr>\n<td>MKV<br/></td><td>.mkv<br/></td><td>开放格式，支持多种视频编码和字幕<br/></td></tr>\n<tr>\n<td>MOV<br/></td><td>.mov<br/></td><td>Apple 的 QuickTime 视频格式<br/></td></tr>\n<tr>\n<td>WMV<br/></td><td>.wmv<br/></td><td>Windows 媒体视频格式<br/></td></tr>\n<tr>\n<td>FLV<br/></td><td>.flv<br/></td><td>Flash 视频格式<br/></td></tr>\n<tr>\n<td>WEBM<br/></td><td>.webm<br/></td><td>针对网络优化的视频格式<br/></td></tr>\n<tr>\n<td>MPEG<br/></td><td>.mpeg<br/></td><td>一种视频压缩标准，广泛使用<br/></td></tr>\n<tr>\n<td>3GP<br/></td><td>.3gp<br/></td><td>移动设备视频格式<br/></td></tr>\n</table>\n\n### 摄像头检测\n\n#### 实时摄像头视频流\n\n系统设计支持从实时摄像头视频流中获取数据。这包括物理摄像头（如 CCTV 摄像头）以及虚拟网络摄像头。对于虚拟网络摄像头，系统可以利用网络技术访问同一局域网内的平板和手机摄像头。这种设计提供了更大的灵活性，允许在没有物理摄像头的情况下，使用移动设备的摄像头作为监控设备。\n\n![17421138440811742113843683.png](https://tk-pichost-1325224430.cos.ap-chengdu.myqcloud.com/blog/17421138440811742113843683.png)\n\n#### 虚拟网络摄像头\n\n虚拟网络摄像头的实现需要在移动设备上安装相应的 webcam 应用。安装完成后，只要设备在同一局域网下，系统就可以直接调用平板和手机的摄像头。通常情况下，手机摄像头能够提供更高分辨率的图像，但可能在某些应用场景中不如物理摄像头广泛适用。\n\n![17421138560851742113855777.png](https://tk-pichost-1325224430.cos.ap-chengdu.myqcloud.com/blog/17421138560851742113855777.png)\n![17421138681211742113868050.png](https://tk-pichost-1325224430.cos.ap-chengdu.myqcloud.com/blog/17421138681211742113868050.png)\n\n### 配置参数\n\n系统运行需要一系列配置参数，这些参数可以由用户根据具体需求进行设置。配置参数包括视频源选择、输出路径等。用户可以通过命令行界面（CLI）输入这些参数，以定制系统的运行行为。\n\n![17421138900811742113889567.png](https://tk-pichost-1325224430.cos.ap-chengdu.myqcloud.com/blog/17421138900811742113889567.png)\n\n## 输出项目\n\n### 处理后的视频文件。\n\n![17421139070811742113906220.png](https://tk-pichost-1325224430.cos.ap-chengdu.myqcloud.com/blog/17421139070811742113906220.png)\n\n系统在完成检测过程后，将自动将相应的检测结果保存到名为 `output` 的文件夹中，以便于集中存放和管理输出的视频文件，确保用户可以方便地访问和查看这些检测结果。\n\n### 实时警报信息\n\n![17421139200811742113919172.png](https://tk-pichost-1325224430.cos.ap-chengdu.myqcloud.com/blog/17421139200811742113919172.png)\n\n![17421139300831742113929519.png](https://tk-pichost-1325224430.cos.ap-chengdu.myqcloud.com/blog/17421139300831742113929519.png)\n\n### 检测状态日志。\n\n## 算法\n\n### 图像预处理：\n\n图像预处理是训练溺水检测系统的模型中的一个关键步骤，旨在提高模型对图像的适应性和准确性。在训练模型之间我们对数据集采用了以下数据预处理方法:\n\n- 随机高斯模糊：通过添加随机高斯模糊，系统能够模拟不同摄像机焦点条件下的图像，从而使模型更加灵活，能够适应各种不同的视觉环境。\n- 灰度处理：将彩色图像转换为灰度图像，合并颜色通道，减少计算复杂度，使模型运行更快，同时降低模型对主体颜色的敏感度，提高检测的鲁棒性。\n- 图像拆分平铺：为了提高对小物体检测的准确性，特别是在航拍图像和显微镜图像等情况下，系统将图像拆分为多个小块进行处理，以捕捉更多细节。\n- Mosaic 数据增强：通过将训练集中的多张照片合并为一张拼贴图像，系统能够增加训练数据的多样性，提高模型对未见场景的泛化能力。\n- 旋转和翻转：对图像进行随机旋转和翻转，以模拟不同的拍摄角度，增强模型对不同方向目标的识别能力。同时，将所有图片的大小统一重新设置为 640x640 像素，以适应模型的输入要求。\n\n### 目标检测、语义分割以及实例分割技术\n\n#### 目标检测\n\n目标检测就像是给视频中的每个物体贴上标签。想象一下，你在看一个视频，视频中有很多人和物体，目标检测技术要做的就是识别出视频中的每个人或物体，并在它们周围画一个框，同时告诉计算机：“看，这里有一个目标！” 这样，计算机就知道视频中有哪些物体，它们在哪里了。\n\n#### 实例分割\n\n实例分割则更进一步，它不仅要识别出视频中的每个人或物体，还要精确地知道每个目标的边界在哪里。这就像是用一支笔画出每个人的轮廓，确保没有两个人的轮廓重叠。这样，即使有多个人站在一起，计算机也能清楚地区分出谁是谁。\n\n#### 语义分割\n\n语义分割与实例分割有些相似，但它关注的是图像中的每个像素属于哪个类别，比如河流、草地或道路。它会给图像中的每个像素分配一个标签，告诉我们这个像素是属于河流还是其他什么。这就像是给一幅画中的每个部分上色，每种颜色代表一种不同的物体或区域。\n\n我们的系统主要训练了两个 YOLO11 模型分别完成对人物同时进行目标检测与实例分割的 detection 模型以及对河流进行语义分割的 seg 模型。\n\n### 溺水检测算法\n\n溺水检测算法是系统的核心，它结合了目标检测、实例分割和语义分割技术，以实现对溺水行为的准确识别。\n\n- 目标检测与实例分割：首先对人物进行目标检测与实例分割，以识别和定位图像中的人物。\n- 语义分割：对河流等水域进行语义分割，以区分水域和其他区域。\n- 重叠率计算：计算检测出的人物像素点与河流像素点的重叠率。如果人在目标检测的像素点中与河流的像素点的重叠率在 80% 以上，系统预测人有溺水的风险，并发出报警提示。如果人在实例分割的像素点与河流的像素点的重叠率在 75% 以上，系统检测到人溺水，并发出报警提示，同时进行语义播报，提示安保人员采取行动。\n\n## 程序逻辑\n\n![17421139540811742113953297.png](https://tk-pichost-1325224430.cos.ap-chengdu.myqcloud.com/blog/17421139540811742113953297.png)\n\n主要处理流程：\n\n### 视频输入\n\n系统接收的视频输入可以是本地存储的文件，如 MP4 或 AVI 格式，或是实时捕获的摄像头视频流。此外，系统设计有网络功能，能够在同一局域网内直接调用平板和手机的摄像头，这增加了系统的灵活性和适用性。对于网络摄像头，系统将通过网络协议（如 RTSP）接收视频数据。\n\n### 帧处理\n\n视频流在输入后被分解为单独的帧，这些帧随后被送入预处理模块。\n\n### 模型检测\n\n- 人物目标检测与实例分割模型：负责识别和定位视频中的每个人，为每个人绘制边界框，并输出位置信息。\n- 河流语义分割模型：进行像素级别的分割，精确区分个体轮廓，为行为分析提供详细数据。\n\n### 行为分析\n\n系统分析个体的行为，特别是与水域相关的活动。这包括：\n\n- 计算个体与河流等水域的像素点重叠率，判断个体是否处于溺水风险中。\n- 分析个体的姿态和动作，识别出挣扎、静止不动或异常姿势等可能的溺水迹象。\n\n### 警报触发\n\n基于行为分析的结果，系统决定是否触发警报。警报触发条件包括：\n\n- 个体与水域的重叠率超过 80%，系统预测存在溺水风险，发出警报提示。\n- 个体与水域的重叠率超过 75%，系统确认检测到溺水行为，发出警报，并进行语义播报提示安保人员。\n\n### 视频输出\n\n处理后的视频帧被重新组合成视频流，用于记录、回放或进一步分析。这不仅有助于事故后的审查，也可以用于系统性能的评估和优化。视频输出模块负责将处理后的视频保存到指定路径，并提供回放功能，以便用户可以查看和分析检测结果。\n\n## 接口\n\n### 视频输入接口\n\n视频输入接口负责接收和处理来自不同来源的视频数据。这个接口支持多种视频输入格式，包括但不限于 MP4、AVI 等，以适应不同的监控环境和设备。此外，该接口还支持实时视频流，能够从网络摄像头、物理摄像头或移动设备捕获视频。为了提高系统的灵活性和适应性，视频输入接口还应能够处理不同分辨率和帧率的视频数据。\n\n- 功能：\n  - 支持多种视频文件格式的读取。\n  - 能够从网络摄像头或移动设备捕获实时视频流。\n  - 处理不同分辨率和帧率的视频数据。\n\n### 模型调用接口\n\n模型调用接口是系统与深度学习模型交互的关键。它负责加载、管理和调用用于目标检测、实例分割和语义分割的模型。这个接口确保模型能够在需要时被快速且准确地调用，从而实现高效的视频分析和处理。\n\n- 功能：\n  - 加载预训练的深度学习模型。\n  - 提供模型调用的 API，以便在视频处理过程中进行目标检测和分割。\n  - 管理和优化模型的内存使用，确保系统的稳定运行。\n\n### 警报系统接口\n\n警报系统接口负责在检测到潜在溺水行为时触发警报。这个接口需要能够快速响应检测结果，并根据预设的阈值决定是否发出警报。警报可以通过声音、视觉信号或移动通知等多种方式发出，以确保信息能够及时传达给监控人员。\n\n- 功能：\n  - 根据溺水检测算法的输出决定是否触发警报。\n  - 支持多种警报方式，包括声音、视觉信号和移动通知。\n  - 确保警报的及时性和准确性。\n\n### 用户交互接口\n\n用户交互接口是系统与用户之间沟通的渠道。它提供了一个用户友好的界面，使用户能够轻松地配置系统参数、选择视频源、查看检测结果和接收警报。这个接口的设计应考虑到易用性和直观性，以降低用户的使用门槛。\n\n- 功能：\n  - 提供用户配置系统参数的界面，如检测灵敏度、警报阈值等。\n  - 允许用户选择视频输入源和查看处理后的视频。\n  - 显示实时警报信息和系统状态更新。\n  - 提供用户反馈和系统性能评估的途径。\n\n## 存储分配\n\n### 模型文件：`./model/`\n\n![17421139890831742113988930.png](https://tk-pichost-1325224430.cos.ap-chengdu.myqcloud.com/blog/17421139890831742113988930.png)\n\n### 输出文件：`./output/`\n\n![17421140070851742114007023.png](https://tk-pichost-1325224430.cos.ap-chengdu.myqcloud.com/blog/17421140070851742114007023.png)\n\n### 资源文件：`./resource/`\n\n![17421140180851742114017407.png](https://tk-pichost-1325224430.cos.ap-chengdu.myqcloud.com/blog/17421140180851742114017407.png)\n\n### 源代码：`./src/`\n\n![17421140290841742114028567.png](https://tk-pichost-1325224430.cos.ap-chengdu.myqcloud.com/blog/17421140290841742114028567.png)\n\n## 限制条件\n\n<table>\n<tr>\n<td>- Python 3.8+运行环境<br/></td></tr>\n<tr>\n<td>- CUDA支持（推荐）<br/></td></tr>\n<tr>\n<td>- 最小8GB内存<br/></td></tr>\n<tr>\n<td>- 支持OpenCV的操作系统<br/></td></tr>\n</table>\n\n## 测试要点\n\n### 视频处理性能测试\n\n视频处理性能测试旨在评估系统处理视频流的能力，包括实时性、帧率和视频质量。测试将模拟不同的视频输入条件，如不同的分辨率、帧率和编码格式，以确保系统能够在各种情况下稳定运行。\n\n- 目标：确保系统能够以至少 30FPS 的速度处理 1080P 视频，同时保持低延迟。\n- 方法：使用不同参数的视频文件进行播放，测量处理时间和输出视频的质量。\n\n### 检测准确率测试\n\n检测准确率测试用于验证目标检测和实例分割模型的准确性。这包括检测模型能否正确识别和定位视频中的人物，以及分割模型能否准确区分个体和背景。\n\n- 目标：达到 90% 以上的检测准确率。\n- 方法：通过与人工标注的测试集比较，计算模型的精确度、召回率和 F1 分数。\n\n### 警报系统响应测试\n\n警报系统响应测试确保在检测到溺水行为时，系统能够及时发出警报。这包括测试警报的触发逻辑和警报的传递速度。\n\n- 目标：警报响应时间小于 1 秒。\n- 方法：模拟溺水场景，测量从检测到警报发出的时间。\n\n### 内存占用测试\n\n内存占用测试评估系统运行时的内存使用情况，以确保系统在资源有限的环境中也能高效运行。\n\n- 目标：优化内存使用，避免内存泄漏。\n- 方法：监控系统运行过程中的内存使用情况，特别是在处理大量视频数据时。\n\n### 长时间运行稳定性测试\n\n长时间运行稳定性测试用于验证系统在连续运行条件下的稳定性和可靠性。这包括测试系统是否能够长时间稳定运行而不出现崩溃或性能下降。\n\n- 目标：确保系统能够连续运行至少 72 小时无故障。\n- 方法：让系统连续处理视频流，监控其性能和资源使用情况。\n\n## 安装步骤\n\n### 克隆仓库:\n\n```bash\ngit clone https://github.com/your-username/drowning-detection.git\ncd drowning-detection\n```\n\n### 创建并激活虚拟环境(推荐):\n\n```bash\npython -m venv venv\nsource venv/bin/activate  # 在Windows上使用 venv\\Scripts\\activate\n```\n\n### 安装依赖:\n\n```bash\npip install -r requirements.txt\n```\n\n这将安装项目所需的所有依赖项,并确保版本与开发环境一致。\n\n> 注意: 如果您在安装过程中遇到任何问题,特别是与 CUDA 或 GPU 支持相关的问题,请参考 PyTorch 官方文档以获取适合您系统的安装说明。\n\n## 使用说明\n\n### 确保您有适当的视频文件用于检测。\n\n### 修改 `main.py` 中的 `video_path` 变量,指向您的视频文件:\n\n```bash\nvideo_path = \"path/to/your/video.mp4\"\n```\n\n### 运行主程序:\n\n```bash\npython main.py\n```\n\n### 程序将开始处理视频,并在检测到潜在溺水危险时发出警告。\n\n### 按 'q' 键退出程序。\n\n# 四、项目总结\n\n在反思这个溺水检测项目时，我们意识到技术的进步不仅仅是为了创新，更是为了解决实际问题，保护人们的生命安全。我们的项目通过结合最新的人工智能技术和多种监控手段，旨在减少溺水事故，这是一个极具社会价值的目标。我们认识到，尽管技术提供了强大的工具，但真正的挑战在于如何将这些工具有效地应用于实际场景中，以及如何确保系统的稳定性和可靠性。未来，我们将继续优化算法，提高系统的响应速度和准确性，同时，我们也将探索如何降低成本，使这项技术能够更广泛地应用于各种水域，从而保护更多人的生命。\n\n在推广方面，我们认为教育和意识提升同样重要。如果可行的话，我们将与学校、社区和地方政府合作，提高公众对溺水风险的认识，并教育他们如何使用我们的系统。此外，我们也将通过各种媒体渠道，如社交媒体、公共讲座和行业会议，来展示我们的技术成果，以吸引更多的关注和支持。我们相信，通过技术的推广和公众意识的提高，我们可以共同构建一个更安全的水上环境。让人类拥有更美好的未来！\n","slug":"2025-03-16-水“镜”安澜——基于YOLO11的智能溺水检测系统软件 V1.0 设计说明文档","published":1,"updated":"2025-09-26T12:16:18.855Z","_id":"cmg0saj40000zjm8n4fs7ddod","comments":1,"layout":"post","photos":[],"content":"<blockquote>\n<p>为了申请计算机软件著作权，我们考虑到时间充裕且预算有限，决定自行撰写之前开发的溺水检测系统的软件说明文档，而不是委托代理机构。我们将这份文档发布在我的博客上，供自己和有需要的大学同学参考，虽然可能使用频率不高。</p>\n</blockquote>\n<p style=\"background-color:rgb(75, 86, 135); padding: 10px; border: 1px solid red;\">\n    <strong>推荐使用飞书云文档在线观看效果更佳<a href=\"https://xcnx25vdviba.feishu.cn/wiki/WzXcwXyHPiNKXUk4U5AcbGuRn0e\">飞书文档链接</a></strong> \n</p>\n\n\n<h1 id=\"一、引言\"><a href=\"#一、引言\" class=\"headerlink\" title=\"一、引言\"></a>一、引言</h1><h2 id=\"1-编写目的\"><a href=\"#1-编写目的\" class=\"headerlink\" title=\"1. 编写目的\"></a>1. 编写目的</h2><p>本文档旨在详细阐述水“镜”安澜——基于 YOLO11 的智能溺水检测系统软件 V1.0 设计说明文档软件 V1.0 的设计和实现过程，以作为申请计算机软件著作权的技术文档。本文档的目标读者包括软件评审人员、开发人员和系统维护人员。</p>\n<h2 id=\"2-项目背景\"><a href=\"#2-项目背景\" class=\"headerlink\" title=\"2. 项目背景\"></a>2. 项目背景</h2><p>溺水是导致意外死亡的主要原因之一，尤其在夏季和水上活动频繁的季节。根据项目书提供的数据，河道为溺水高发地，且溺亡率极高。这一严峻的现状凸显了开发有效溺水检测系统的必要性。</p>\n<p>本项目旨在开发一个基于计算机视觉的智能溺水检测系统，利用深度学习技术实现对水域环境中人员行为的实时监控和分析。项目背景源于对提升水域安全管理效率和降低溺水事故发生率的迫切需求，通过采用先进的人工智能技术，为水域安全管理提供智能化的解决方案。</p>\n<p>本项目创新性地结合光学摄像头技术，实现高效、全天候的溺水检测系统。通过光学摄像头利用 YOLO11 模型进行河道水面的实例分割和人物的目标检测。系统可以通过计算水面与人物掩模的重合度，判断目标人物溺水状态，若超出设定重合度范围，自动判断其可能溺水，并及时发出警报。项目初衷在于应对夏季高发的溺水事故，传统人工检测存在注意力疲劳、反应时间长、视线受限等局限。项目旨在利用图像处理算法和 YOLO11 模型，研发一套智能溺水检测系统，实现实时监控、精准识别和快速响应。相较于已有的溺水检测方案，如青犀防溺水 AI 算法、DEWS 系统等，本项目方案在硬件和环境适应性上更为灵活。目前项目只适用于河道等地区青少年失足落水的情况，我们计算后期添加人物姿态评估算法，将人物的溺水状态精确到对应的姿态，提高系统的适用范围和准确率。</p>\n<h2 id=\"3-定义\"><a href=\"#3-定义\" class=\"headerlink\" title=\"3. 定义\"></a>3. 定义</h2><table>\n<tr>\n<td>专有名词<br/></td><td>解释<br/></td></tr>\n<tr>\n<td>YOLO (You Only Look Once)<br/></td><td>一种高效的实时目标检测算法<br/></td></tr>\n<tr>\n<td>CV (Computer Vision)<br/></td><td> 计算机视觉技术，用于使机器“看”和处理图像<br/></td></tr>\n<tr>\n<td>GPU (Graphics Processing Unit)<br/></td><td> 图形处理器，用于加速图像和视频处理任务<br/></td></tr>\n<tr>\n<td>CUDA(Compute Unified Device Architecture)<br/></td><td> NVIDIA推出的并行计算平台和编程模型<br/></td></tr>\n<tr>\n<td>FPS (Frames Per Second)<br/></td><td>每秒帧数，用于衡量视频处理和显示的性能<br/></td></tr>\n</table>\n\n<h2 id=\"4-参考资料\"><a href=\"#4-参考资料\" class=\"headerlink\" title=\"4. 参考资料\"></a>4. 参考资料</h2><table>\n<tr>\n<td>资料名称名称<br/></td><td>解释<br/></td></tr>\n<tr>\n<td>https://pytorch.org/docs/<br/></td><td>PyTorch官方文档<br/></td></tr>\n<tr>\n<td>https://github.com/ultralytics/ultralytics<br/></td><td>YOLOv11官方网址<br/></td></tr>\n<tr>\n<td>https://docs.opencv.org/<br/></td><td>OpenCV-Python官方文档<br/></td></tr>\n<tr>\n<td>https://ttsmp3.com/ai<br/></td><td>AI生成系统报警语音<br/></td></tr>\n<tr>\n<td>https://webcamtests.com/<br/></td><td>开发过程中用于测试网络摄像头的情况<br/></td></tr>\n<tr>\n<td>https://github.com/tkzzzzzz6/downing_detect<br/></td><td>我们项目的github网址<br/></td></tr>\n</table>\n\n<h1 id=\"二、总体设计\"><a href=\"#二、总体设计\" class=\"headerlink\" title=\"二、总体设计\"></a>二、总体设计</h1><h2 id=\"需求概述\"><a href=\"#需求概述\" class=\"headerlink\" title=\"需求概述\"></a>需求概述</h2><p>我们的溺水检测项目旨在以高通 QCS6490 平台为边缘计算终端平台，通过结合人工智能技术和智能监控系统，实现高效、精准的溺水检测和预警。项目系统采用 YOLO11n 模型，高精度训练，提高 YOLO11 模型的精确度与鲁棒性。结合光学摄像头，能够在各种复杂环境和天气条件下提供全天候的高精度、低延迟、强适应的实时监控系统。我们的项目预计部署于泳池、海滩、湖泊以及河道等多种水域环境，以减少溺水事故的发生，目前项目只适用于河道等地区青少年失足落水的情况，我们计划后期添加人物姿态评估算法，将人物的溺水状态精确到对应的姿态，提高系统的适用范围和准确率。</p>\n<p><img src=\"https://tk-pichost-1325224430.cos.ap-chengdu.myqcloud.com/blog/17421133300801742113329444.png\" alt=\"17421133300801742113329444.png\"></p>\n<p>系统的主要功能需求包括：</p>\n<h3 id=\"实时视频流分析\"><a href=\"#实时视频流分析\" class=\"headerlink\" title=\"实时视频流分析\"></a>实时视频流分析</h3><p>允许系统接收并处理来自网络摄像头或虚拟摄像头摄像头的实时视频流以及视频文本。系统能够对视频帧进行逐帧分析，以识别和评估水域中个体的行为。此功能是溺水检测系统的核心，因为它为后续的人员检测和行为分析提供了基础数据。</p>\n<p><img src=\"https://tk-pichost-1325224430.cos.ap-chengdu.myqcloud.com/blog/1742113187081Z9i6bqevRoBENmx5jrHcJXfAnsd.png\" alt=\"1742113187081Z9i6bqevRoBENmx5jrHcJXfAnsd.png\"><br><img src=\"https://tk-pichost-1325224430.cos.ap-chengdu.myqcloud.com/blog/1742113238130VeKpbk1TNocTNxxj7UCclMhtnae.png\" alt=\"1742113238130VeKpbk1TNocTNxxj7UCclMhtnae.png\"></p>\n<h3 id=\"人员检测与跟踪\"><a href=\"#人员检测与跟踪\" class=\"headerlink\" title=\"人员检测与跟踪\"></a>人员检测与跟踪</h3><p><img src=\"https://tk-pichost-1325224430.cos.ap-chengdu.myqcloud.com/blog/17421133790801742113378366.png\" alt=\"17421133790801742113378366.png\"></p>\n<p><img src=\"https://tk-pichost-1325224430.cos.ap-chengdu.myqcloud.com/blog/17421133980811742113397191.png\" alt=\"17421133980811742113397191.png\"><br><img src=\"https://tk-pichost-1325224430.cos.ap-chengdu.myqcloud.com/blog/17421134100811742113409980.png\" alt=\"17421134100811742113409980.png\"><br><img src=\"https://tk-pichost-1325224430.cos.ap-chengdu.myqcloud.com/blog/17421134220861742113421703.png\" alt=\"17421134220861742113421703.png\"><br><img src=\"https://tk-pichost-1325224430.cos.ap-chengdu.myqcloud.com/blog/17421134910811742113490340.png\" alt=\"17421134910811742113490340.png\"><br><img src=\"https://tk-pichost-1325224430.cos.ap-chengdu.myqcloud.com/blog/17421135220821742113521782.png\" alt=\"17421135220821742113521782.png\"><br><img src=\"https://tk-pichost-1325224430.cos.ap-chengdu.myqcloud.com/blog/17421135460841742113545806.png\" alt=\"17421135460841742113545806.png\"></p>\n<blockquote>\n<p>[!TIP]</p>\n</blockquote>\n<ul>\n<li>添加随机高斯模糊，以帮助模型更灵活地适应摄像机焦点。</li>\n<li>灰度处理,合并颜色通道，使模型更快，并且对主体颜色不敏感。</li>\n<li>将图像拆分为平铺，以提高小对象的准确性。检测小物体时(尤其是在航拍图像和显微镜等情况下)。</li>\n<li>Mosaic 将训练集中的多张照片合并为拼贴</li>\n<li>旋转和翻转,并将所有图片的大小都重新设置为 640*640</li>\n</ul>\n<p>系统利用先进的计算机视觉和深度学习技术，采用实例分割技术自动识别并标记视频中的人形轮廓。通过跟踪算法，系统能够持续监测个体在视频帧中的位置变化，即使在个体移动或暂时离开摄像头视野的情况下也能保持跟踪。</p>\n<p><img src=\"https://tk-pichost-1325224430.cos.ap-chengdu.myqcloud.com/blog/17421136260801742113625210.png\" alt=\"17421136260801742113625210.png\"></p>\n<h3 id=\"溺水行为识别\"><a href=\"#溺水行为识别\" class=\"headerlink\" title=\"溺水行为识别\"></a>溺水行为识别</h3><p><img src=\"https://tk-pichost-1325224430.cos.ap-chengdu.myqcloud.com/blog/17421136400801742113639626.png\" alt=\"17421136400801742113639626.png\"></p>\n<p>现有的溺水检测系统几乎采用的都是 YOLOV3 以及 YOLOV5 模型作为溺水检测系统的检测模型，在检测和响应时间上相比于 YOLO11 检测模型存在滞后，无法实现实时监控和快速预警。延迟的报警可能导致救援人员无法及时赶到现场，增加溺水者的生命危险。</p>\n<p>升级到 YOLO11 后，我们的溺水检测系统在关键性能上有了显著提升。YOLO11 以其快速的实时目标检测和精准的姿态评估能力，使我们能够迅速识别出溺水行为。与 YOLOv9 相比，YOLO11 在保持模型参数精简的同时，通过改进的特征提取技术和 GPU 优化，提高了检测的准确性和速度。这使得我们的系统能够更有效地在第一时间内发现并响应溺水事件，从而挽救生命。</p>\n<p>基于 YOLOv11 模型，系统能够分析个体的行为模式，识别出可能的溺水行为。系统会分析个体的姿态、动作和行为变化，如挣扎、静止不动或异常姿势，以判断是否存在溺水风险。此外，YOLO11 的改进使其在较低计算资源下也能保持高性能，适合边缘设备或云端推理使用。</p>\n<h3 id=\"警报系统\"><a href=\"#警报系统\" class=\"headerlink\" title=\"警报系统\"></a>警报系统</h3><p>一旦系统识别出潜在的溺水行为，警报系统将立即触发。警报可以通过多种方式发出，包括声音警报、视觉警报（如屏幕上的警告信息）或通过移动应用发送通知。该功能确保了救援人员可以迅速响应，采取必要的救助措施。</p>\n<p><img src=\"https://tk-pichost-1325224430.cos.ap-chengdu.myqcloud.com/blog/17421136650801742113664539.png\" alt=\"17421136650801742113664539.png\"></p>\n<p><img src=\"https://tk-pichost-1325224430.cos.ap-chengdu.myqcloud.com/blog/17421136850791742113684813.png\" alt=\"17421136850791742113684813.png\"></p>\n<h3 id=\"视频记录与回放\"><a href=\"#视频记录与回放\" class=\"headerlink\" title=\"视频记录与回放\"></a>视频记录与回放</h3><p><img src=\"https://tk-pichost-1325224430.cos.ap-chengdu.myqcloud.com/blog/17421137010841742113700957.png\" alt=\"17421137010841742113700957.png\"></p>\n<p>系统具备记录视频的能力，允许用户回放和审查过去的监控视频。这一功能对于事故分析和责任认定至关重要。视频记录还可以用于系统性能评估和优化，以提高溺水检测的准确性和可靠性。</p>\n<h2 id=\"软件结构\"><a href=\"#软件结构\" class=\"headerlink\" title=\"软件结构\"></a>软件结构</h2><p>系统采用模块化设计，主要包含以下模块：</p>\n<figure class=\"highlight stylus\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">DOWNING_DETECT/</span><br><span class=\"line\">├── model/</span><br><span class=\"line\">│   ├── best_detect<span class=\"selector-class\">.pt</span></span><br><span class=\"line\">│   └── best_seg<span class=\"selector-class\">.pt</span></span><br><span class=\"line\">│</span><br><span class=\"line\">├── output/</span><br><span class=\"line\">│   └── output_video<span class=\"selector-class\">.mp4</span></span><br><span class=\"line\">│</span><br><span class=\"line\">├── resource/</span><br><span class=\"line\">│   ├── downing_warning<span class=\"selector-class\">.mp3</span></span><br><span class=\"line\">│   └── 检测到溺水危险<span class=\"selector-class\">.mp3</span></span><br><span class=\"line\">│</span><br><span class=\"line\">├── <span class=\"attribute\">src</span>/</span><br><span class=\"line\">│   ├── __init__<span class=\"selector-class\">.py</span></span><br><span class=\"line\">│   ├── audio_manager<span class=\"selector-class\">.py</span></span><br><span class=\"line\">│   ├── detection_utils<span class=\"selector-class\">.py</span></span><br><span class=\"line\">│   ├── downing_detect_video<span class=\"selector-class\">.py</span></span><br><span class=\"line\">│   ├── downing_detect_webcam<span class=\"selector-class\">.py</span></span><br><span class=\"line\">│   ├── model_loader<span class=\"selector-class\">.py</span></span><br><span class=\"line\">│   └── video_processor<span class=\"selector-class\">.py</span></span><br><span class=\"line\">│</span><br><span class=\"line\">├── LICENSE</span><br><span class=\"line\">├── README<span class=\"selector-class\">.md</span></span><br><span class=\"line\">├── <span class=\"selector-tag\">main</span><span class=\"selector-class\">.py</span></span><br><span class=\"line\">├── requirements<span class=\"selector-class\">.txt</span></span><br><span class=\"line\">└── train.py</span><br></pre></td></tr></table></figure>\n\n<ul>\n<li><code>_pycache_/</code>: Python 的字节码缓存目录。</li>\n<li><code>model/</code>: 存放模型文件。</li>\n<li><code>output/</code>: 存放输出视频。</li>\n<li><code>resource/</code>: 存放音频资源文件。</li>\n<li><code>src/</code>: 源代码目录，包含项目的主要 Python 模块。</li>\n<li><code>LICENSE</code>: 项目许可证文件。</li>\n<li><code>README.md</code>: 项目说明文档。</li>\n<li><code>main.py</code>: 主程序入口。</li>\n<li><code>requirements.txt</code>: 项目依赖列表。</li>\n<li><code>train.py</code>: 模型训练脚本。</li>\n</ul>\n<h1 id=\"三、程序描述\"><a href=\"#三、程序描述\" class=\"headerlink\" title=\"三、程序描述\"></a>三、程序描述</h1><h2 id=\"功能\"><a href=\"#功能\" class=\"headerlink\" title=\"功能\"></a>功能</h2><p><img src=\"https://tk-pichost-1325224430.cos.ap-chengdu.myqcloud.com/blog/17421137290801742113728392.png\" alt=\"17421137290801742113728392.png\"></p>\n<h3 id=\"视频处理模块：负责视频流的读取、处理和输出\"><a href=\"#视频处理模块：负责视频流的读取、处理和输出\" class=\"headerlink\" title=\"视频处理模块：负责视频流的读取、处理和输出\"></a>视频处理模块：负责视频流的读取、处理和输出</h3><p>该模块是系统的核心，负责处理视频流的各个方面。它包括视频捕获，即从文件或摄像头获取视频数据；视频输出，即保存和显示处理后的视频；模型推理，即加载和应用河流和人物检测模型；以及重叠计算，即计算人物与河流的重叠率，这对于识别溺水行为至关重要。视频处理模块确保视频数据能够被有效地读取、分析和输出。</p>\n<h3 id=\"模型加载模块：负责加载和管理深度学习模型\"><a href=\"#模型加载模块：负责加载和管理深度学习模型\" class=\"headerlink\" title=\"模型加载模块：负责加载和管理深度学习模型\"></a>模型加载模块：负责加载和管理深度学习模型</h3><p>模型加载模块负责加载和管理深度学习模型，这些模型是实现目标检测和图像处理功能的关键。它包括加载人物检测模型和河流检测模型，确保这些模型在系统运行时能够被正确调用。该模块还负责模型的管理和优化，以提高检测的准确性和效率。</p>\n<h3 id=\"检测工具模块：提供目标检测和图像处理功能\"><a href=\"#检测工具模块：提供目标检测和图像处理功能\" class=\"headerlink\" title=\"检测工具模块：提供目标检测和图像处理功能\"></a>检测工具模块：提供目标检测和图像处理功能</h3><p>检测工具模块提供了一系列功能，用于目标检测和图像处理。它包括绘制河流掩码、绘制人物边界框、计算重叠率、显示警告信息和显示信息消息。这些功能对于分析视频帧中的行为和识别溺水迹象至关重要。检测工具模块是实现溺水检测算法的核心部分。</p>\n<h3 id=\"音频管理模块：处理警报声音的播放\"><a href=\"#音频管理模块：处理警报声音的播放\" class=\"headerlink\" title=\"音频管理模块：处理警报声音的播放\"></a>音频管理模块：处理警报声音的播放</h3><p>音频管理模块负责处理警报声音的播放。它包括资源管理，即初始化和清理音频资源，以及音频播放，即播放和停止警告音频。在检测到潜在溺水行为时，该模块能够及时发出警报，确保警报能够迅速传达给监控人员或公众。</p>\n<h3 id=\"主程序控制模块：协调各模块工作，提供用户界面\"><a href=\"#主程序控制模块：协调各模块工作，提供用户界面\" class=\"headerlink\" title=\"主程序控制模块：协调各模块工作，提供用户界面\"></a>主程序控制模块：协调各模块工作，提供用户界面</h3><p>主程序控制模块是系统的协调中心，负责协调各模块的工作，并提供用户界面。它包括初始化 VideoProcessor 进行视频处理，管理用户交互，如选择检测模式（视频文件或虚拟摄像头），以及处理视频输出和警告管理。主程序控制模块确保系统的各个部分能够协同工作，为用户提供一个直观的操作界面。</p>\n<p><img src=\"https://tk-pichost-1325224430.cos.ap-chengdu.myqcloud.com/blog/17421137430791742113742777.png\" alt=\"17421137430791742113742777.png\"></p>\n<h2 id=\"性能\"><a href=\"#性能\" class=\"headerlink\" title=\"性能\"></a>性能</h2><h3 id=\"支持实时视频处理（30FPS-以上）\"><a href=\"#支持实时视频处理（30FPS-以上）\" class=\"headerlink\" title=\"支持实时视频处理（30FPS 以上）\"></a>支持实时视频处理（30FPS 以上）</h3><p>系统设计需满足实时视频处理的需求，即能够以每秒 30 帧（FPS）以上的速度处理视频流。这意味着系统能够快速分析视频内容，并在极短的时间内识别出潜在的溺水行为。高帧率处理能力对于捕捉快速变化的场景至关重要，确保系统不会错过任何关键瞬间。</p>\n<h3 id=\"检测精度达到-90-以上\"><a href=\"#检测精度达到-90-以上\" class=\"headerlink\" title=\"检测精度达到 90% 以上\"></a>检测精度达到 90% 以上</h3><p><img src=\"https://tk-pichost-1325224430.cos.ap-chengdu.myqcloud.com/blog/17421137590811742113758699.png\" alt=\"17421137590811742113758699.png\"></p>\n<p><img src=\"https://tk-pichost-1325224430.cos.ap-chengdu.myqcloud.com/blog/17421137700821742113769185.png\" alt=\"17421137700821742113769185.png\"></p>\n<p>系统的检测精度是衡量其性能的关键指标之一。该系统的目标检测精度需达到 90% 以上，这意味着在所有检测到的目标中，至少有 90% 是正确的溺水行为识别。这一高精度要求确保了系统的可靠性，减少了误报和漏报的可能性，从而提高了溺水检测的准确性和可信度。</p>\n<h3 id=\"推理时间小于-10ms-秒每张图片\"><a href=\"#推理时间小于-10ms-秒每张图片\" class=\"headerlink\" title=\"推理时间小于 10ms 秒每张图片\"></a>推理时间小于 10ms 秒每张图片</h3><p><img src=\"https://tk-pichost-1325224430.cos.ap-chengdu.myqcloud.com/blog/17421137850811742113784474.png\" alt=\"17421137850811742113784474.png\"></p>\n<p><img src=\"https://tk-pichost-1325224430.cos.ap-chengdu.myqcloud.com/blog/17421138030811742113802244.png\" alt=\"17421138030811742113802244.png\"></p>\n<h3 id=\"支持-1080P-视频处理\"><a href=\"#支持-1080P-视频处理\" class=\"headerlink\" title=\"支持 1080P 视频处理\"></a>支持 1080P 视频处理</h3><p>系统支持 1080P（全高清）及低于该分辨率的视频处理。高分辨率视频提供了更清晰的图像细节，有助于提高目标检测的准确性。此外，支持高分辨率视频也使得系统能够适应不同的监控环境和设备，增加了系统的适用性和灵活性。</p>\n<h2 id=\"输入项目\"><a href=\"#输入项目\" class=\"headerlink\" title=\"输入项目\"></a>输入项目</h2><h3 id=\"视频文件\"><a href=\"#视频文件\" class=\"headerlink\" title=\"视频文件\"></a>视频文件</h3><p>系统能够处理多种格式的视频文件，包括但不限于 MP4、AVI 等常见格式。这些视频文件可以是预先录制的，也可以是实时生成的。系统支持从本地存储设备或网络位置读取视频文件，以供分析和处理。</p>\n<p>以下是我们溺水检测系统支持的视频格式类型:</p>\n<table>\n<tr>\n<td>格式<br/></td><td>扩展名<br/></td><td>描述<br/></td></tr>\n<tr>\n<td>AVI<br/></td><td>.avi<br/></td><td>音频视频交错格式，支持多种编码方式<br/></td></tr>\n<tr>\n<td>MP4<br/></td><td>.mp4<br/></td><td>常用的压缩格式，兼容性强<br/></td></tr>\n<tr>\n<td>MKV<br/></td><td>.mkv<br/></td><td>开放格式，支持多种视频编码和字幕<br/></td></tr>\n<tr>\n<td>MOV<br/></td><td>.mov<br/></td><td>Apple 的 QuickTime 视频格式<br/></td></tr>\n<tr>\n<td>WMV<br/></td><td>.wmv<br/></td><td>Windows 媒体视频格式<br/></td></tr>\n<tr>\n<td>FLV<br/></td><td>.flv<br/></td><td>Flash 视频格式<br/></td></tr>\n<tr>\n<td>WEBM<br/></td><td>.webm<br/></td><td>针对网络优化的视频格式<br/></td></tr>\n<tr>\n<td>MPEG<br/></td><td>.mpeg<br/></td><td>一种视频压缩标准，广泛使用<br/></td></tr>\n<tr>\n<td>3GP<br/></td><td>.3gp<br/></td><td>移动设备视频格式<br/></td></tr>\n</table>\n\n<h3 id=\"摄像头检测\"><a href=\"#摄像头检测\" class=\"headerlink\" title=\"摄像头检测\"></a>摄像头检测</h3><h4 id=\"实时摄像头视频流\"><a href=\"#实时摄像头视频流\" class=\"headerlink\" title=\"实时摄像头视频流\"></a>实时摄像头视频流</h4><p>系统设计支持从实时摄像头视频流中获取数据。这包括物理摄像头（如 CCTV 摄像头）以及虚拟网络摄像头。对于虚拟网络摄像头，系统可以利用网络技术访问同一局域网内的平板和手机摄像头。这种设计提供了更大的灵活性，允许在没有物理摄像头的情况下，使用移动设备的摄像头作为监控设备。</p>\n<p><img src=\"https://tk-pichost-1325224430.cos.ap-chengdu.myqcloud.com/blog/17421138440811742113843683.png\" alt=\"17421138440811742113843683.png\"></p>\n<h4 id=\"虚拟网络摄像头\"><a href=\"#虚拟网络摄像头\" class=\"headerlink\" title=\"虚拟网络摄像头\"></a>虚拟网络摄像头</h4><p>虚拟网络摄像头的实现需要在移动设备上安装相应的 webcam 应用。安装完成后，只要设备在同一局域网下，系统就可以直接调用平板和手机的摄像头。通常情况下，手机摄像头能够提供更高分辨率的图像，但可能在某些应用场景中不如物理摄像头广泛适用。</p>\n<p><img src=\"https://tk-pichost-1325224430.cos.ap-chengdu.myqcloud.com/blog/17421138560851742113855777.png\" alt=\"17421138560851742113855777.png\"><br><img src=\"https://tk-pichost-1325224430.cos.ap-chengdu.myqcloud.com/blog/17421138681211742113868050.png\" alt=\"17421138681211742113868050.png\"></p>\n<h3 id=\"配置参数\"><a href=\"#配置参数\" class=\"headerlink\" title=\"配置参数\"></a>配置参数</h3><p>系统运行需要一系列配置参数，这些参数可以由用户根据具体需求进行设置。配置参数包括视频源选择、输出路径等。用户可以通过命令行界面（CLI）输入这些参数，以定制系统的运行行为。</p>\n<p><img src=\"https://tk-pichost-1325224430.cos.ap-chengdu.myqcloud.com/blog/17421138900811742113889567.png\" alt=\"17421138900811742113889567.png\"></p>\n<h2 id=\"输出项目\"><a href=\"#输出项目\" class=\"headerlink\" title=\"输出项目\"></a>输出项目</h2><h3 id=\"处理后的视频文件。\"><a href=\"#处理后的视频文件。\" class=\"headerlink\" title=\"处理后的视频文件。\"></a>处理后的视频文件。</h3><p><img src=\"https://tk-pichost-1325224430.cos.ap-chengdu.myqcloud.com/blog/17421139070811742113906220.png\" alt=\"17421139070811742113906220.png\"></p>\n<p>系统在完成检测过程后，将自动将相应的检测结果保存到名为 <code>output</code> 的文件夹中，以便于集中存放和管理输出的视频文件，确保用户可以方便地访问和查看这些检测结果。</p>\n<h3 id=\"实时警报信息\"><a href=\"#实时警报信息\" class=\"headerlink\" title=\"实时警报信息\"></a>实时警报信息</h3><p><img src=\"https://tk-pichost-1325224430.cos.ap-chengdu.myqcloud.com/blog/17421139200811742113919172.png\" alt=\"17421139200811742113919172.png\"></p>\n<p><img src=\"https://tk-pichost-1325224430.cos.ap-chengdu.myqcloud.com/blog/17421139300831742113929519.png\" alt=\"17421139300831742113929519.png\"></p>\n<h3 id=\"检测状态日志。\"><a href=\"#检测状态日志。\" class=\"headerlink\" title=\"检测状态日志。\"></a>检测状态日志。</h3><h2 id=\"算法\"><a href=\"#算法\" class=\"headerlink\" title=\"算法\"></a>算法</h2><h3 id=\"图像预处理：\"><a href=\"#图像预处理：\" class=\"headerlink\" title=\"图像预处理：\"></a>图像预处理：</h3><p>图像预处理是训练溺水检测系统的模型中的一个关键步骤，旨在提高模型对图像的适应性和准确性。在训练模型之间我们对数据集采用了以下数据预处理方法:</p>\n<ul>\n<li>随机高斯模糊：通过添加随机高斯模糊，系统能够模拟不同摄像机焦点条件下的图像，从而使模型更加灵活，能够适应各种不同的视觉环境。</li>\n<li>灰度处理：将彩色图像转换为灰度图像，合并颜色通道，减少计算复杂度，使模型运行更快，同时降低模型对主体颜色的敏感度，提高检测的鲁棒性。</li>\n<li>图像拆分平铺：为了提高对小物体检测的准确性，特别是在航拍图像和显微镜图像等情况下，系统将图像拆分为多个小块进行处理，以捕捉更多细节。</li>\n<li>Mosaic 数据增强：通过将训练集中的多张照片合并为一张拼贴图像，系统能够增加训练数据的多样性，提高模型对未见场景的泛化能力。</li>\n<li>旋转和翻转：对图像进行随机旋转和翻转，以模拟不同的拍摄角度，增强模型对不同方向目标的识别能力。同时，将所有图片的大小统一重新设置为 640x640 像素，以适应模型的输入要求。</li>\n</ul>\n<h3 id=\"目标检测、语义分割以及实例分割技术\"><a href=\"#目标检测、语义分割以及实例分割技术\" class=\"headerlink\" title=\"目标检测、语义分割以及实例分割技术\"></a>目标检测、语义分割以及实例分割技术</h3><h4 id=\"目标检测\"><a href=\"#目标检测\" class=\"headerlink\" title=\"目标检测\"></a>目标检测</h4><p>目标检测就像是给视频中的每个物体贴上标签。想象一下，你在看一个视频，视频中有很多人和物体，目标检测技术要做的就是识别出视频中的每个人或物体，并在它们周围画一个框，同时告诉计算机：“看，这里有一个目标！” 这样，计算机就知道视频中有哪些物体，它们在哪里了。</p>\n<h4 id=\"实例分割\"><a href=\"#实例分割\" class=\"headerlink\" title=\"实例分割\"></a>实例分割</h4><p>实例分割则更进一步，它不仅要识别出视频中的每个人或物体，还要精确地知道每个目标的边界在哪里。这就像是用一支笔画出每个人的轮廓，确保没有两个人的轮廓重叠。这样，即使有多个人站在一起，计算机也能清楚地区分出谁是谁。</p>\n<h4 id=\"语义分割\"><a href=\"#语义分割\" class=\"headerlink\" title=\"语义分割\"></a>语义分割</h4><p>语义分割与实例分割有些相似，但它关注的是图像中的每个像素属于哪个类别，比如河流、草地或道路。它会给图像中的每个像素分配一个标签，告诉我们这个像素是属于河流还是其他什么。这就像是给一幅画中的每个部分上色，每种颜色代表一种不同的物体或区域。</p>\n<p>我们的系统主要训练了两个 YOLO11 模型分别完成对人物同时进行目标检测与实例分割的 detection 模型以及对河流进行语义分割的 seg 模型。</p>\n<h3 id=\"溺水检测算法\"><a href=\"#溺水检测算法\" class=\"headerlink\" title=\"溺水检测算法\"></a>溺水检测算法</h3><p>溺水检测算法是系统的核心，它结合了目标检测、实例分割和语义分割技术，以实现对溺水行为的准确识别。</p>\n<ul>\n<li>目标检测与实例分割：首先对人物进行目标检测与实例分割，以识别和定位图像中的人物。</li>\n<li>语义分割：对河流等水域进行语义分割，以区分水域和其他区域。</li>\n<li>重叠率计算：计算检测出的人物像素点与河流像素点的重叠率。如果人在目标检测的像素点中与河流的像素点的重叠率在 80% 以上，系统预测人有溺水的风险，并发出报警提示。如果人在实例分割的像素点与河流的像素点的重叠率在 75% 以上，系统检测到人溺水，并发出报警提示，同时进行语义播报，提示安保人员采取行动。</li>\n</ul>\n<h2 id=\"程序逻辑\"><a href=\"#程序逻辑\" class=\"headerlink\" title=\"程序逻辑\"></a>程序逻辑</h2><p><img src=\"https://tk-pichost-1325224430.cos.ap-chengdu.myqcloud.com/blog/17421139540811742113953297.png\" alt=\"17421139540811742113953297.png\"></p>\n<p>主要处理流程：</p>\n<h3 id=\"视频输入\"><a href=\"#视频输入\" class=\"headerlink\" title=\"视频输入\"></a>视频输入</h3><p>系统接收的视频输入可以是本地存储的文件，如 MP4 或 AVI 格式，或是实时捕获的摄像头视频流。此外，系统设计有网络功能，能够在同一局域网内直接调用平板和手机的摄像头，这增加了系统的灵活性和适用性。对于网络摄像头，系统将通过网络协议（如 RTSP）接收视频数据。</p>\n<h3 id=\"帧处理\"><a href=\"#帧处理\" class=\"headerlink\" title=\"帧处理\"></a>帧处理</h3><p>视频流在输入后被分解为单独的帧，这些帧随后被送入预处理模块。</p>\n<h3 id=\"模型检测\"><a href=\"#模型检测\" class=\"headerlink\" title=\"模型检测\"></a>模型检测</h3><ul>\n<li>人物目标检测与实例分割模型：负责识别和定位视频中的每个人，为每个人绘制边界框，并输出位置信息。</li>\n<li>河流语义分割模型：进行像素级别的分割，精确区分个体轮廓，为行为分析提供详细数据。</li>\n</ul>\n<h3 id=\"行为分析\"><a href=\"#行为分析\" class=\"headerlink\" title=\"行为分析\"></a>行为分析</h3><p>系统分析个体的行为，特别是与水域相关的活动。这包括：</p>\n<ul>\n<li>计算个体与河流等水域的像素点重叠率，判断个体是否处于溺水风险中。</li>\n<li>分析个体的姿态和动作，识别出挣扎、静止不动或异常姿势等可能的溺水迹象。</li>\n</ul>\n<h3 id=\"警报触发\"><a href=\"#警报触发\" class=\"headerlink\" title=\"警报触发\"></a>警报触发</h3><p>基于行为分析的结果，系统决定是否触发警报。警报触发条件包括：</p>\n<ul>\n<li>个体与水域的重叠率超过 80%，系统预测存在溺水风险，发出警报提示。</li>\n<li>个体与水域的重叠率超过 75%，系统确认检测到溺水行为，发出警报，并进行语义播报提示安保人员。</li>\n</ul>\n<h3 id=\"视频输出\"><a href=\"#视频输出\" class=\"headerlink\" title=\"视频输出\"></a>视频输出</h3><p>处理后的视频帧被重新组合成视频流，用于记录、回放或进一步分析。这不仅有助于事故后的审查，也可以用于系统性能的评估和优化。视频输出模块负责将处理后的视频保存到指定路径，并提供回放功能，以便用户可以查看和分析检测结果。</p>\n<h2 id=\"接口\"><a href=\"#接口\" class=\"headerlink\" title=\"接口\"></a>接口</h2><h3 id=\"视频输入接口\"><a href=\"#视频输入接口\" class=\"headerlink\" title=\"视频输入接口\"></a>视频输入接口</h3><p>视频输入接口负责接收和处理来自不同来源的视频数据。这个接口支持多种视频输入格式，包括但不限于 MP4、AVI 等，以适应不同的监控环境和设备。此外，该接口还支持实时视频流，能够从网络摄像头、物理摄像头或移动设备捕获视频。为了提高系统的灵活性和适应性，视频输入接口还应能够处理不同分辨率和帧率的视频数据。</p>\n<ul>\n<li>功能：<ul>\n<li>支持多种视频文件格式的读取。</li>\n<li>能够从网络摄像头或移动设备捕获实时视频流。</li>\n<li>处理不同分辨率和帧率的视频数据。</li>\n</ul>\n</li>\n</ul>\n<h3 id=\"模型调用接口\"><a href=\"#模型调用接口\" class=\"headerlink\" title=\"模型调用接口\"></a>模型调用接口</h3><p>模型调用接口是系统与深度学习模型交互的关键。它负责加载、管理和调用用于目标检测、实例分割和语义分割的模型。这个接口确保模型能够在需要时被快速且准确地调用，从而实现高效的视频分析和处理。</p>\n<ul>\n<li>功能：<ul>\n<li>加载预训练的深度学习模型。</li>\n<li>提供模型调用的 API，以便在视频处理过程中进行目标检测和分割。</li>\n<li>管理和优化模型的内存使用，确保系统的稳定运行。</li>\n</ul>\n</li>\n</ul>\n<h3 id=\"警报系统接口\"><a href=\"#警报系统接口\" class=\"headerlink\" title=\"警报系统接口\"></a>警报系统接口</h3><p>警报系统接口负责在检测到潜在溺水行为时触发警报。这个接口需要能够快速响应检测结果，并根据预设的阈值决定是否发出警报。警报可以通过声音、视觉信号或移动通知等多种方式发出，以确保信息能够及时传达给监控人员。</p>\n<ul>\n<li>功能：<ul>\n<li>根据溺水检测算法的输出决定是否触发警报。</li>\n<li>支持多种警报方式，包括声音、视觉信号和移动通知。</li>\n<li>确保警报的及时性和准确性。</li>\n</ul>\n</li>\n</ul>\n<h3 id=\"用户交互接口\"><a href=\"#用户交互接口\" class=\"headerlink\" title=\"用户交互接口\"></a>用户交互接口</h3><p>用户交互接口是系统与用户之间沟通的渠道。它提供了一个用户友好的界面，使用户能够轻松地配置系统参数、选择视频源、查看检测结果和接收警报。这个接口的设计应考虑到易用性和直观性，以降低用户的使用门槛。</p>\n<ul>\n<li>功能：<ul>\n<li>提供用户配置系统参数的界面，如检测灵敏度、警报阈值等。</li>\n<li>允许用户选择视频输入源和查看处理后的视频。</li>\n<li>显示实时警报信息和系统状态更新。</li>\n<li>提供用户反馈和系统性能评估的途径。</li>\n</ul>\n</li>\n</ul>\n<h2 id=\"存储分配\"><a href=\"#存储分配\" class=\"headerlink\" title=\"存储分配\"></a>存储分配</h2><h3 id=\"模型文件：-model\"><a href=\"#模型文件：-model\" class=\"headerlink\" title=\"模型文件：./model/\"></a>模型文件：<code>./model/</code></h3><p><img src=\"https://tk-pichost-1325224430.cos.ap-chengdu.myqcloud.com/blog/17421139890831742113988930.png\" alt=\"17421139890831742113988930.png\"></p>\n<h3 id=\"输出文件：-output\"><a href=\"#输出文件：-output\" class=\"headerlink\" title=\"输出文件：./output/\"></a>输出文件：<code>./output/</code></h3><p><img src=\"https://tk-pichost-1325224430.cos.ap-chengdu.myqcloud.com/blog/17421140070851742114007023.png\" alt=\"17421140070851742114007023.png\"></p>\n<h3 id=\"资源文件：-resource\"><a href=\"#资源文件：-resource\" class=\"headerlink\" title=\"资源文件：./resource/\"></a>资源文件：<code>./resource/</code></h3><p><img src=\"https://tk-pichost-1325224430.cos.ap-chengdu.myqcloud.com/blog/17421140180851742114017407.png\" alt=\"17421140180851742114017407.png\"></p>\n<h3 id=\"源代码：-src\"><a href=\"#源代码：-src\" class=\"headerlink\" title=\"源代码：./src/\"></a>源代码：<code>./src/</code></h3><p><img src=\"https://tk-pichost-1325224430.cos.ap-chengdu.myqcloud.com/blog/17421140290841742114028567.png\" alt=\"17421140290841742114028567.png\"></p>\n<h2 id=\"限制条件\"><a href=\"#限制条件\" class=\"headerlink\" title=\"限制条件\"></a>限制条件</h2><table>\n<tr>\n<td>- Python 3.8+运行环境<br/></td></tr>\n<tr>\n<td>- CUDA支持（推荐）<br/></td></tr>\n<tr>\n<td>- 最小8GB内存<br/></td></tr>\n<tr>\n<td>- 支持OpenCV的操作系统<br/></td></tr>\n</table>\n\n<h2 id=\"测试要点\"><a href=\"#测试要点\" class=\"headerlink\" title=\"测试要点\"></a>测试要点</h2><h3 id=\"视频处理性能测试\"><a href=\"#视频处理性能测试\" class=\"headerlink\" title=\"视频处理性能测试\"></a>视频处理性能测试</h3><p>视频处理性能测试旨在评估系统处理视频流的能力，包括实时性、帧率和视频质量。测试将模拟不同的视频输入条件，如不同的分辨率、帧率和编码格式，以确保系统能够在各种情况下稳定运行。</p>\n<ul>\n<li>目标：确保系统能够以至少 30FPS 的速度处理 1080P 视频，同时保持低延迟。</li>\n<li>方法：使用不同参数的视频文件进行播放，测量处理时间和输出视频的质量。</li>\n</ul>\n<h3 id=\"检测准确率测试\"><a href=\"#检测准确率测试\" class=\"headerlink\" title=\"检测准确率测试\"></a>检测准确率测试</h3><p>检测准确率测试用于验证目标检测和实例分割模型的准确性。这包括检测模型能否正确识别和定位视频中的人物，以及分割模型能否准确区分个体和背景。</p>\n<ul>\n<li>目标：达到 90% 以上的检测准确率。</li>\n<li>方法：通过与人工标注的测试集比较，计算模型的精确度、召回率和 F1 分数。</li>\n</ul>\n<h3 id=\"警报系统响应测试\"><a href=\"#警报系统响应测试\" class=\"headerlink\" title=\"警报系统响应测试\"></a>警报系统响应测试</h3><p>警报系统响应测试确保在检测到溺水行为时，系统能够及时发出警报。这包括测试警报的触发逻辑和警报的传递速度。</p>\n<ul>\n<li>目标：警报响应时间小于 1 秒。</li>\n<li>方法：模拟溺水场景，测量从检测到警报发出的时间。</li>\n</ul>\n<h3 id=\"内存占用测试\"><a href=\"#内存占用测试\" class=\"headerlink\" title=\"内存占用测试\"></a>内存占用测试</h3><p>内存占用测试评估系统运行时的内存使用情况，以确保系统在资源有限的环境中也能高效运行。</p>\n<ul>\n<li>目标：优化内存使用，避免内存泄漏。</li>\n<li>方法：监控系统运行过程中的内存使用情况，特别是在处理大量视频数据时。</li>\n</ul>\n<h3 id=\"长时间运行稳定性测试\"><a href=\"#长时间运行稳定性测试\" class=\"headerlink\" title=\"长时间运行稳定性测试\"></a>长时间运行稳定性测试</h3><p>长时间运行稳定性测试用于验证系统在连续运行条件下的稳定性和可靠性。这包括测试系统是否能够长时间稳定运行而不出现崩溃或性能下降。</p>\n<ul>\n<li>目标：确保系统能够连续运行至少 72 小时无故障。</li>\n<li>方法：让系统连续处理视频流，监控其性能和资源使用情况。</li>\n</ul>\n<h2 id=\"安装步骤\"><a href=\"#安装步骤\" class=\"headerlink\" title=\"安装步骤\"></a>安装步骤</h2><h3 id=\"克隆仓库\"><a href=\"#克隆仓库\" class=\"headerlink\" title=\"克隆仓库:\"></a>克隆仓库:</h3><figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">git <span class=\"built_in\">clone</span> https://github.com/your-username/drowning-detection.git</span><br><span class=\"line\"><span class=\"built_in\">cd</span> drowning-detection</span><br></pre></td></tr></table></figure>\n\n<h3 id=\"创建并激活虚拟环境-推荐\"><a href=\"#创建并激活虚拟环境-推荐\" class=\"headerlink\" title=\"创建并激活虚拟环境(推荐):\"></a>创建并激活虚拟环境(推荐):</h3><figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">python -m venv venv</span><br><span class=\"line\"><span class=\"built_in\">source</span> venv/bin/activate  <span class=\"comment\"># 在Windows上使用 venv\\Scripts\\activate</span></span><br></pre></td></tr></table></figure>\n\n<h3 id=\"安装依赖\"><a href=\"#安装依赖\" class=\"headerlink\" title=\"安装依赖:\"></a>安装依赖:</h3><figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">pip install -r requirements.txt</span><br></pre></td></tr></table></figure>\n\n<p>这将安装项目所需的所有依赖项,并确保版本与开发环境一致。</p>\n<blockquote>\n<p>注意: 如果您在安装过程中遇到任何问题,特别是与 CUDA 或 GPU 支持相关的问题,请参考 PyTorch 官方文档以获取适合您系统的安装说明。</p>\n</blockquote>\n<h2 id=\"使用说明\"><a href=\"#使用说明\" class=\"headerlink\" title=\"使用说明\"></a>使用说明</h2><h3 id=\"确保您有适当的视频文件用于检测。\"><a href=\"#确保您有适当的视频文件用于检测。\" class=\"headerlink\" title=\"确保您有适当的视频文件用于检测。\"></a>确保您有适当的视频文件用于检测。</h3><h3 id=\"修改-main-py-中的-video-path-变量-指向您的视频文件\"><a href=\"#修改-main-py-中的-video-path-变量-指向您的视频文件\" class=\"headerlink\" title=\"修改 main.py 中的 video_path 变量,指向您的视频文件:\"></a>修改 <code>main.py</code> 中的 <code>video_path</code> 变量,指向您的视频文件:</h3><figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">video_path = <span class=\"string\">&quot;path/to/your/video.mp4&quot;</span></span><br></pre></td></tr></table></figure>\n\n<h3 id=\"运行主程序\"><a href=\"#运行主程序\" class=\"headerlink\" title=\"运行主程序:\"></a>运行主程序:</h3><figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">python main.py</span><br></pre></td></tr></table></figure>\n\n<h3 id=\"程序将开始处理视频-并在检测到潜在溺水危险时发出警告。\"><a href=\"#程序将开始处理视频-并在检测到潜在溺水危险时发出警告。\" class=\"headerlink\" title=\"程序将开始处理视频,并在检测到潜在溺水危险时发出警告。\"></a>程序将开始处理视频,并在检测到潜在溺水危险时发出警告。</h3><h3 id=\"按-‘q’-键退出程序。\"><a href=\"#按-‘q’-键退出程序。\" class=\"headerlink\" title=\"按 ‘q’ 键退出程序。\"></a>按 ‘q’ 键退出程序。</h3><h1 id=\"四、项目总结\"><a href=\"#四、项目总结\" class=\"headerlink\" title=\"四、项目总结\"></a>四、项目总结</h1><p>在反思这个溺水检测项目时，我们意识到技术的进步不仅仅是为了创新，更是为了解决实际问题，保护人们的生命安全。我们的项目通过结合最新的人工智能技术和多种监控手段，旨在减少溺水事故，这是一个极具社会价值的目标。我们认识到，尽管技术提供了强大的工具，但真正的挑战在于如何将这些工具有效地应用于实际场景中，以及如何确保系统的稳定性和可靠性。未来，我们将继续优化算法，提高系统的响应速度和准确性，同时，我们也将探索如何降低成本，使这项技术能够更广泛地应用于各种水域，从而保护更多人的生命。</p>\n<p>在推广方面，我们认为教育和意识提升同样重要。如果可行的话，我们将与学校、社区和地方政府合作，提高公众对溺水风险的认识，并教育他们如何使用我们的系统。此外，我们也将通过各种媒体渠道，如社交媒体、公共讲座和行业会议，来展示我们的技术成果，以吸引更多的关注和支持。我们相信，通过技术的推广和公众意识的提高，我们可以共同构建一个更安全的水上环境。让人类拥有更美好的未来！</p>\n","excerpt":"","more":"<blockquote>\n<p>为了申请计算机软件著作权，我们考虑到时间充裕且预算有限，决定自行撰写之前开发的溺水检测系统的软件说明文档，而不是委托代理机构。我们将这份文档发布在我的博客上，供自己和有需要的大学同学参考，虽然可能使用频率不高。</p>\n</blockquote>\n<p style=\"background-color:rgb(75, 86, 135); padding: 10px; border: 1px solid red;\">\n    <strong>推荐使用飞书云文档在线观看效果更佳<a href=\"https://xcnx25vdviba.feishu.cn/wiki/WzXcwXyHPiNKXUk4U5AcbGuRn0e\">飞书文档链接</a></strong> \n</p>\n\n\n<h1 id=\"一、引言\"><a href=\"#一、引言\" class=\"headerlink\" title=\"一、引言\"></a>一、引言</h1><h2 id=\"1-编写目的\"><a href=\"#1-编写目的\" class=\"headerlink\" title=\"1. 编写目的\"></a>1. 编写目的</h2><p>本文档旨在详细阐述水“镜”安澜——基于 YOLO11 的智能溺水检测系统软件 V1.0 设计说明文档软件 V1.0 的设计和实现过程，以作为申请计算机软件著作权的技术文档。本文档的目标读者包括软件评审人员、开发人员和系统维护人员。</p>\n<h2 id=\"2-项目背景\"><a href=\"#2-项目背景\" class=\"headerlink\" title=\"2. 项目背景\"></a>2. 项目背景</h2><p>溺水是导致意外死亡的主要原因之一，尤其在夏季和水上活动频繁的季节。根据项目书提供的数据，河道为溺水高发地，且溺亡率极高。这一严峻的现状凸显了开发有效溺水检测系统的必要性。</p>\n<p>本项目旨在开发一个基于计算机视觉的智能溺水检测系统，利用深度学习技术实现对水域环境中人员行为的实时监控和分析。项目背景源于对提升水域安全管理效率和降低溺水事故发生率的迫切需求，通过采用先进的人工智能技术，为水域安全管理提供智能化的解决方案。</p>\n<p>本项目创新性地结合光学摄像头技术，实现高效、全天候的溺水检测系统。通过光学摄像头利用 YOLO11 模型进行河道水面的实例分割和人物的目标检测。系统可以通过计算水面与人物掩模的重合度，判断目标人物溺水状态，若超出设定重合度范围，自动判断其可能溺水，并及时发出警报。项目初衷在于应对夏季高发的溺水事故，传统人工检测存在注意力疲劳、反应时间长、视线受限等局限。项目旨在利用图像处理算法和 YOLO11 模型，研发一套智能溺水检测系统，实现实时监控、精准识别和快速响应。相较于已有的溺水检测方案，如青犀防溺水 AI 算法、DEWS 系统等，本项目方案在硬件和环境适应性上更为灵活。目前项目只适用于河道等地区青少年失足落水的情况，我们计算后期添加人物姿态评估算法，将人物的溺水状态精确到对应的姿态，提高系统的适用范围和准确率。</p>\n<h2 id=\"3-定义\"><a href=\"#3-定义\" class=\"headerlink\" title=\"3. 定义\"></a>3. 定义</h2><table>\n<tr>\n<td>专有名词<br/></td><td>解释<br/></td></tr>\n<tr>\n<td>YOLO (You Only Look Once)<br/></td><td>一种高效的实时目标检测算法<br/></td></tr>\n<tr>\n<td>CV (Computer Vision)<br/></td><td> 计算机视觉技术，用于使机器“看”和处理图像<br/></td></tr>\n<tr>\n<td>GPU (Graphics Processing Unit)<br/></td><td> 图形处理器，用于加速图像和视频处理任务<br/></td></tr>\n<tr>\n<td>CUDA(Compute Unified Device Architecture)<br/></td><td> NVIDIA推出的并行计算平台和编程模型<br/></td></tr>\n<tr>\n<td>FPS (Frames Per Second)<br/></td><td>每秒帧数，用于衡量视频处理和显示的性能<br/></td></tr>\n</table>\n\n<h2 id=\"4-参考资料\"><a href=\"#4-参考资料\" class=\"headerlink\" title=\"4. 参考资料\"></a>4. 参考资料</h2><table>\n<tr>\n<td>资料名称名称<br/></td><td>解释<br/></td></tr>\n<tr>\n<td>https://pytorch.org/docs/<br/></td><td>PyTorch官方文档<br/></td></tr>\n<tr>\n<td>https://github.com/ultralytics/ultralytics<br/></td><td>YOLOv11官方网址<br/></td></tr>\n<tr>\n<td>https://docs.opencv.org/<br/></td><td>OpenCV-Python官方文档<br/></td></tr>\n<tr>\n<td>https://ttsmp3.com/ai<br/></td><td>AI生成系统报警语音<br/></td></tr>\n<tr>\n<td>https://webcamtests.com/<br/></td><td>开发过程中用于测试网络摄像头的情况<br/></td></tr>\n<tr>\n<td>https://github.com/tkzzzzzz6/downing_detect<br/></td><td>我们项目的github网址<br/></td></tr>\n</table>\n\n<h1 id=\"二、总体设计\"><a href=\"#二、总体设计\" class=\"headerlink\" title=\"二、总体设计\"></a>二、总体设计</h1><h2 id=\"需求概述\"><a href=\"#需求概述\" class=\"headerlink\" title=\"需求概述\"></a>需求概述</h2><p>我们的溺水检测项目旨在以高通 QCS6490 平台为边缘计算终端平台，通过结合人工智能技术和智能监控系统，实现高效、精准的溺水检测和预警。项目系统采用 YOLO11n 模型，高精度训练，提高 YOLO11 模型的精确度与鲁棒性。结合光学摄像头，能够在各种复杂环境和天气条件下提供全天候的高精度、低延迟、强适应的实时监控系统。我们的项目预计部署于泳池、海滩、湖泊以及河道等多种水域环境，以减少溺水事故的发生，目前项目只适用于河道等地区青少年失足落水的情况，我们计划后期添加人物姿态评估算法，将人物的溺水状态精确到对应的姿态，提高系统的适用范围和准确率。</p>\n<p><img src=\"https://tk-pichost-1325224430.cos.ap-chengdu.myqcloud.com/blog/17421133300801742113329444.png\" alt=\"17421133300801742113329444.png\"></p>\n<p>系统的主要功能需求包括：</p>\n<h3 id=\"实时视频流分析\"><a href=\"#实时视频流分析\" class=\"headerlink\" title=\"实时视频流分析\"></a>实时视频流分析</h3><p>允许系统接收并处理来自网络摄像头或虚拟摄像头摄像头的实时视频流以及视频文本。系统能够对视频帧进行逐帧分析，以识别和评估水域中个体的行为。此功能是溺水检测系统的核心，因为它为后续的人员检测和行为分析提供了基础数据。</p>\n<p><img src=\"https://tk-pichost-1325224430.cos.ap-chengdu.myqcloud.com/blog/1742113187081Z9i6bqevRoBENmx5jrHcJXfAnsd.png\" alt=\"1742113187081Z9i6bqevRoBENmx5jrHcJXfAnsd.png\"><br><img src=\"https://tk-pichost-1325224430.cos.ap-chengdu.myqcloud.com/blog/1742113238130VeKpbk1TNocTNxxj7UCclMhtnae.png\" alt=\"1742113238130VeKpbk1TNocTNxxj7UCclMhtnae.png\"></p>\n<h3 id=\"人员检测与跟踪\"><a href=\"#人员检测与跟踪\" class=\"headerlink\" title=\"人员检测与跟踪\"></a>人员检测与跟踪</h3><p><img src=\"https://tk-pichost-1325224430.cos.ap-chengdu.myqcloud.com/blog/17421133790801742113378366.png\" alt=\"17421133790801742113378366.png\"></p>\n<p><img src=\"https://tk-pichost-1325224430.cos.ap-chengdu.myqcloud.com/blog/17421133980811742113397191.png\" alt=\"17421133980811742113397191.png\"><br><img src=\"https://tk-pichost-1325224430.cos.ap-chengdu.myqcloud.com/blog/17421134100811742113409980.png\" alt=\"17421134100811742113409980.png\"><br><img src=\"https://tk-pichost-1325224430.cos.ap-chengdu.myqcloud.com/blog/17421134220861742113421703.png\" alt=\"17421134220861742113421703.png\"><br><img src=\"https://tk-pichost-1325224430.cos.ap-chengdu.myqcloud.com/blog/17421134910811742113490340.png\" alt=\"17421134910811742113490340.png\"><br><img src=\"https://tk-pichost-1325224430.cos.ap-chengdu.myqcloud.com/blog/17421135220821742113521782.png\" alt=\"17421135220821742113521782.png\"><br><img src=\"https://tk-pichost-1325224430.cos.ap-chengdu.myqcloud.com/blog/17421135460841742113545806.png\" alt=\"17421135460841742113545806.png\"></p>\n<blockquote>\n<p>[!TIP]</p>\n</blockquote>\n<ul>\n<li>添加随机高斯模糊，以帮助模型更灵活地适应摄像机焦点。</li>\n<li>灰度处理,合并颜色通道，使模型更快，并且对主体颜色不敏感。</li>\n<li>将图像拆分为平铺，以提高小对象的准确性。检测小物体时(尤其是在航拍图像和显微镜等情况下)。</li>\n<li>Mosaic 将训练集中的多张照片合并为拼贴</li>\n<li>旋转和翻转,并将所有图片的大小都重新设置为 640*640</li>\n</ul>\n<p>系统利用先进的计算机视觉和深度学习技术，采用实例分割技术自动识别并标记视频中的人形轮廓。通过跟踪算法，系统能够持续监测个体在视频帧中的位置变化，即使在个体移动或暂时离开摄像头视野的情况下也能保持跟踪。</p>\n<p><img src=\"https://tk-pichost-1325224430.cos.ap-chengdu.myqcloud.com/blog/17421136260801742113625210.png\" alt=\"17421136260801742113625210.png\"></p>\n<h3 id=\"溺水行为识别\"><a href=\"#溺水行为识别\" class=\"headerlink\" title=\"溺水行为识别\"></a>溺水行为识别</h3><p><img src=\"https://tk-pichost-1325224430.cos.ap-chengdu.myqcloud.com/blog/17421136400801742113639626.png\" alt=\"17421136400801742113639626.png\"></p>\n<p>现有的溺水检测系统几乎采用的都是 YOLOV3 以及 YOLOV5 模型作为溺水检测系统的检测模型，在检测和响应时间上相比于 YOLO11 检测模型存在滞后，无法实现实时监控和快速预警。延迟的报警可能导致救援人员无法及时赶到现场，增加溺水者的生命危险。</p>\n<p>升级到 YOLO11 后，我们的溺水检测系统在关键性能上有了显著提升。YOLO11 以其快速的实时目标检测和精准的姿态评估能力，使我们能够迅速识别出溺水行为。与 YOLOv9 相比，YOLO11 在保持模型参数精简的同时，通过改进的特征提取技术和 GPU 优化，提高了检测的准确性和速度。这使得我们的系统能够更有效地在第一时间内发现并响应溺水事件，从而挽救生命。</p>\n<p>基于 YOLOv11 模型，系统能够分析个体的行为模式，识别出可能的溺水行为。系统会分析个体的姿态、动作和行为变化，如挣扎、静止不动或异常姿势，以判断是否存在溺水风险。此外，YOLO11 的改进使其在较低计算资源下也能保持高性能，适合边缘设备或云端推理使用。</p>\n<h3 id=\"警报系统\"><a href=\"#警报系统\" class=\"headerlink\" title=\"警报系统\"></a>警报系统</h3><p>一旦系统识别出潜在的溺水行为，警报系统将立即触发。警报可以通过多种方式发出，包括声音警报、视觉警报（如屏幕上的警告信息）或通过移动应用发送通知。该功能确保了救援人员可以迅速响应，采取必要的救助措施。</p>\n<p><img src=\"https://tk-pichost-1325224430.cos.ap-chengdu.myqcloud.com/blog/17421136650801742113664539.png\" alt=\"17421136650801742113664539.png\"></p>\n<p><img src=\"https://tk-pichost-1325224430.cos.ap-chengdu.myqcloud.com/blog/17421136850791742113684813.png\" alt=\"17421136850791742113684813.png\"></p>\n<h3 id=\"视频记录与回放\"><a href=\"#视频记录与回放\" class=\"headerlink\" title=\"视频记录与回放\"></a>视频记录与回放</h3><p><img src=\"https://tk-pichost-1325224430.cos.ap-chengdu.myqcloud.com/blog/17421137010841742113700957.png\" alt=\"17421137010841742113700957.png\"></p>\n<p>系统具备记录视频的能力，允许用户回放和审查过去的监控视频。这一功能对于事故分析和责任认定至关重要。视频记录还可以用于系统性能评估和优化，以提高溺水检测的准确性和可靠性。</p>\n<h2 id=\"软件结构\"><a href=\"#软件结构\" class=\"headerlink\" title=\"软件结构\"></a>软件结构</h2><p>系统采用模块化设计，主要包含以下模块：</p>\n<figure class=\"highlight stylus\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">DOWNING_DETECT/</span><br><span class=\"line\">├── model/</span><br><span class=\"line\">│   ├── best_detect<span class=\"selector-class\">.pt</span></span><br><span class=\"line\">│   └── best_seg<span class=\"selector-class\">.pt</span></span><br><span class=\"line\">│</span><br><span class=\"line\">├── output/</span><br><span class=\"line\">│   └── output_video<span class=\"selector-class\">.mp4</span></span><br><span class=\"line\">│</span><br><span class=\"line\">├── resource/</span><br><span class=\"line\">│   ├── downing_warning<span class=\"selector-class\">.mp3</span></span><br><span class=\"line\">│   └── 检测到溺水危险<span class=\"selector-class\">.mp3</span></span><br><span class=\"line\">│</span><br><span class=\"line\">├── <span class=\"attribute\">src</span>/</span><br><span class=\"line\">│   ├── __init__<span class=\"selector-class\">.py</span></span><br><span class=\"line\">│   ├── audio_manager<span class=\"selector-class\">.py</span></span><br><span class=\"line\">│   ├── detection_utils<span class=\"selector-class\">.py</span></span><br><span class=\"line\">│   ├── downing_detect_video<span class=\"selector-class\">.py</span></span><br><span class=\"line\">│   ├── downing_detect_webcam<span class=\"selector-class\">.py</span></span><br><span class=\"line\">│   ├── model_loader<span class=\"selector-class\">.py</span></span><br><span class=\"line\">│   └── video_processor<span class=\"selector-class\">.py</span></span><br><span class=\"line\">│</span><br><span class=\"line\">├── LICENSE</span><br><span class=\"line\">├── README<span class=\"selector-class\">.md</span></span><br><span class=\"line\">├── <span class=\"selector-tag\">main</span><span class=\"selector-class\">.py</span></span><br><span class=\"line\">├── requirements<span class=\"selector-class\">.txt</span></span><br><span class=\"line\">└── train.py</span><br></pre></td></tr></table></figure>\n\n<ul>\n<li><code>_pycache_/</code>: Python 的字节码缓存目录。</li>\n<li><code>model/</code>: 存放模型文件。</li>\n<li><code>output/</code>: 存放输出视频。</li>\n<li><code>resource/</code>: 存放音频资源文件。</li>\n<li><code>src/</code>: 源代码目录，包含项目的主要 Python 模块。</li>\n<li><code>LICENSE</code>: 项目许可证文件。</li>\n<li><code>README.md</code>: 项目说明文档。</li>\n<li><code>main.py</code>: 主程序入口。</li>\n<li><code>requirements.txt</code>: 项目依赖列表。</li>\n<li><code>train.py</code>: 模型训练脚本。</li>\n</ul>\n<h1 id=\"三、程序描述\"><a href=\"#三、程序描述\" class=\"headerlink\" title=\"三、程序描述\"></a>三、程序描述</h1><h2 id=\"功能\"><a href=\"#功能\" class=\"headerlink\" title=\"功能\"></a>功能</h2><p><img src=\"https://tk-pichost-1325224430.cos.ap-chengdu.myqcloud.com/blog/17421137290801742113728392.png\" alt=\"17421137290801742113728392.png\"></p>\n<h3 id=\"视频处理模块：负责视频流的读取、处理和输出\"><a href=\"#视频处理模块：负责视频流的读取、处理和输出\" class=\"headerlink\" title=\"视频处理模块：负责视频流的读取、处理和输出\"></a>视频处理模块：负责视频流的读取、处理和输出</h3><p>该模块是系统的核心，负责处理视频流的各个方面。它包括视频捕获，即从文件或摄像头获取视频数据；视频输出，即保存和显示处理后的视频；模型推理，即加载和应用河流和人物检测模型；以及重叠计算，即计算人物与河流的重叠率，这对于识别溺水行为至关重要。视频处理模块确保视频数据能够被有效地读取、分析和输出。</p>\n<h3 id=\"模型加载模块：负责加载和管理深度学习模型\"><a href=\"#模型加载模块：负责加载和管理深度学习模型\" class=\"headerlink\" title=\"模型加载模块：负责加载和管理深度学习模型\"></a>模型加载模块：负责加载和管理深度学习模型</h3><p>模型加载模块负责加载和管理深度学习模型，这些模型是实现目标检测和图像处理功能的关键。它包括加载人物检测模型和河流检测模型，确保这些模型在系统运行时能够被正确调用。该模块还负责模型的管理和优化，以提高检测的准确性和效率。</p>\n<h3 id=\"检测工具模块：提供目标检测和图像处理功能\"><a href=\"#检测工具模块：提供目标检测和图像处理功能\" class=\"headerlink\" title=\"检测工具模块：提供目标检测和图像处理功能\"></a>检测工具模块：提供目标检测和图像处理功能</h3><p>检测工具模块提供了一系列功能，用于目标检测和图像处理。它包括绘制河流掩码、绘制人物边界框、计算重叠率、显示警告信息和显示信息消息。这些功能对于分析视频帧中的行为和识别溺水迹象至关重要。检测工具模块是实现溺水检测算法的核心部分。</p>\n<h3 id=\"音频管理模块：处理警报声音的播放\"><a href=\"#音频管理模块：处理警报声音的播放\" class=\"headerlink\" title=\"音频管理模块：处理警报声音的播放\"></a>音频管理模块：处理警报声音的播放</h3><p>音频管理模块负责处理警报声音的播放。它包括资源管理，即初始化和清理音频资源，以及音频播放，即播放和停止警告音频。在检测到潜在溺水行为时，该模块能够及时发出警报，确保警报能够迅速传达给监控人员或公众。</p>\n<h3 id=\"主程序控制模块：协调各模块工作，提供用户界面\"><a href=\"#主程序控制模块：协调各模块工作，提供用户界面\" class=\"headerlink\" title=\"主程序控制模块：协调各模块工作，提供用户界面\"></a>主程序控制模块：协调各模块工作，提供用户界面</h3><p>主程序控制模块是系统的协调中心，负责协调各模块的工作，并提供用户界面。它包括初始化 VideoProcessor 进行视频处理，管理用户交互，如选择检测模式（视频文件或虚拟摄像头），以及处理视频输出和警告管理。主程序控制模块确保系统的各个部分能够协同工作，为用户提供一个直观的操作界面。</p>\n<p><img src=\"https://tk-pichost-1325224430.cos.ap-chengdu.myqcloud.com/blog/17421137430791742113742777.png\" alt=\"17421137430791742113742777.png\"></p>\n<h2 id=\"性能\"><a href=\"#性能\" class=\"headerlink\" title=\"性能\"></a>性能</h2><h3 id=\"支持实时视频处理（30FPS-以上）\"><a href=\"#支持实时视频处理（30FPS-以上）\" class=\"headerlink\" title=\"支持实时视频处理（30FPS 以上）\"></a>支持实时视频处理（30FPS 以上）</h3><p>系统设计需满足实时视频处理的需求，即能够以每秒 30 帧（FPS）以上的速度处理视频流。这意味着系统能够快速分析视频内容，并在极短的时间内识别出潜在的溺水行为。高帧率处理能力对于捕捉快速变化的场景至关重要，确保系统不会错过任何关键瞬间。</p>\n<h3 id=\"检测精度达到-90-以上\"><a href=\"#检测精度达到-90-以上\" class=\"headerlink\" title=\"检测精度达到 90% 以上\"></a>检测精度达到 90% 以上</h3><p><img src=\"https://tk-pichost-1325224430.cos.ap-chengdu.myqcloud.com/blog/17421137590811742113758699.png\" alt=\"17421137590811742113758699.png\"></p>\n<p><img src=\"https://tk-pichost-1325224430.cos.ap-chengdu.myqcloud.com/blog/17421137700821742113769185.png\" alt=\"17421137700821742113769185.png\"></p>\n<p>系统的检测精度是衡量其性能的关键指标之一。该系统的目标检测精度需达到 90% 以上，这意味着在所有检测到的目标中，至少有 90% 是正确的溺水行为识别。这一高精度要求确保了系统的可靠性，减少了误报和漏报的可能性，从而提高了溺水检测的准确性和可信度。</p>\n<h3 id=\"推理时间小于-10ms-秒每张图片\"><a href=\"#推理时间小于-10ms-秒每张图片\" class=\"headerlink\" title=\"推理时间小于 10ms 秒每张图片\"></a>推理时间小于 10ms 秒每张图片</h3><p><img src=\"https://tk-pichost-1325224430.cos.ap-chengdu.myqcloud.com/blog/17421137850811742113784474.png\" alt=\"17421137850811742113784474.png\"></p>\n<p><img src=\"https://tk-pichost-1325224430.cos.ap-chengdu.myqcloud.com/blog/17421138030811742113802244.png\" alt=\"17421138030811742113802244.png\"></p>\n<h3 id=\"支持-1080P-视频处理\"><a href=\"#支持-1080P-视频处理\" class=\"headerlink\" title=\"支持 1080P 视频处理\"></a>支持 1080P 视频处理</h3><p>系统支持 1080P（全高清）及低于该分辨率的视频处理。高分辨率视频提供了更清晰的图像细节，有助于提高目标检测的准确性。此外，支持高分辨率视频也使得系统能够适应不同的监控环境和设备，增加了系统的适用性和灵活性。</p>\n<h2 id=\"输入项目\"><a href=\"#输入项目\" class=\"headerlink\" title=\"输入项目\"></a>输入项目</h2><h3 id=\"视频文件\"><a href=\"#视频文件\" class=\"headerlink\" title=\"视频文件\"></a>视频文件</h3><p>系统能够处理多种格式的视频文件，包括但不限于 MP4、AVI 等常见格式。这些视频文件可以是预先录制的，也可以是实时生成的。系统支持从本地存储设备或网络位置读取视频文件，以供分析和处理。</p>\n<p>以下是我们溺水检测系统支持的视频格式类型:</p>\n<table>\n<tr>\n<td>格式<br/></td><td>扩展名<br/></td><td>描述<br/></td></tr>\n<tr>\n<td>AVI<br/></td><td>.avi<br/></td><td>音频视频交错格式，支持多种编码方式<br/></td></tr>\n<tr>\n<td>MP4<br/></td><td>.mp4<br/></td><td>常用的压缩格式，兼容性强<br/></td></tr>\n<tr>\n<td>MKV<br/></td><td>.mkv<br/></td><td>开放格式，支持多种视频编码和字幕<br/></td></tr>\n<tr>\n<td>MOV<br/></td><td>.mov<br/></td><td>Apple 的 QuickTime 视频格式<br/></td></tr>\n<tr>\n<td>WMV<br/></td><td>.wmv<br/></td><td>Windows 媒体视频格式<br/></td></tr>\n<tr>\n<td>FLV<br/></td><td>.flv<br/></td><td>Flash 视频格式<br/></td></tr>\n<tr>\n<td>WEBM<br/></td><td>.webm<br/></td><td>针对网络优化的视频格式<br/></td></tr>\n<tr>\n<td>MPEG<br/></td><td>.mpeg<br/></td><td>一种视频压缩标准，广泛使用<br/></td></tr>\n<tr>\n<td>3GP<br/></td><td>.3gp<br/></td><td>移动设备视频格式<br/></td></tr>\n</table>\n\n<h3 id=\"摄像头检测\"><a href=\"#摄像头检测\" class=\"headerlink\" title=\"摄像头检测\"></a>摄像头检测</h3><h4 id=\"实时摄像头视频流\"><a href=\"#实时摄像头视频流\" class=\"headerlink\" title=\"实时摄像头视频流\"></a>实时摄像头视频流</h4><p>系统设计支持从实时摄像头视频流中获取数据。这包括物理摄像头（如 CCTV 摄像头）以及虚拟网络摄像头。对于虚拟网络摄像头，系统可以利用网络技术访问同一局域网内的平板和手机摄像头。这种设计提供了更大的灵活性，允许在没有物理摄像头的情况下，使用移动设备的摄像头作为监控设备。</p>\n<p><img src=\"https://tk-pichost-1325224430.cos.ap-chengdu.myqcloud.com/blog/17421138440811742113843683.png\" alt=\"17421138440811742113843683.png\"></p>\n<h4 id=\"虚拟网络摄像头\"><a href=\"#虚拟网络摄像头\" class=\"headerlink\" title=\"虚拟网络摄像头\"></a>虚拟网络摄像头</h4><p>虚拟网络摄像头的实现需要在移动设备上安装相应的 webcam 应用。安装完成后，只要设备在同一局域网下，系统就可以直接调用平板和手机的摄像头。通常情况下，手机摄像头能够提供更高分辨率的图像，但可能在某些应用场景中不如物理摄像头广泛适用。</p>\n<p><img src=\"https://tk-pichost-1325224430.cos.ap-chengdu.myqcloud.com/blog/17421138560851742113855777.png\" alt=\"17421138560851742113855777.png\"><br><img src=\"https://tk-pichost-1325224430.cos.ap-chengdu.myqcloud.com/blog/17421138681211742113868050.png\" alt=\"17421138681211742113868050.png\"></p>\n<h3 id=\"配置参数\"><a href=\"#配置参数\" class=\"headerlink\" title=\"配置参数\"></a>配置参数</h3><p>系统运行需要一系列配置参数，这些参数可以由用户根据具体需求进行设置。配置参数包括视频源选择、输出路径等。用户可以通过命令行界面（CLI）输入这些参数，以定制系统的运行行为。</p>\n<p><img src=\"https://tk-pichost-1325224430.cos.ap-chengdu.myqcloud.com/blog/17421138900811742113889567.png\" alt=\"17421138900811742113889567.png\"></p>\n<h2 id=\"输出项目\"><a href=\"#输出项目\" class=\"headerlink\" title=\"输出项目\"></a>输出项目</h2><h3 id=\"处理后的视频文件。\"><a href=\"#处理后的视频文件。\" class=\"headerlink\" title=\"处理后的视频文件。\"></a>处理后的视频文件。</h3><p><img src=\"https://tk-pichost-1325224430.cos.ap-chengdu.myqcloud.com/blog/17421139070811742113906220.png\" alt=\"17421139070811742113906220.png\"></p>\n<p>系统在完成检测过程后，将自动将相应的检测结果保存到名为 <code>output</code> 的文件夹中，以便于集中存放和管理输出的视频文件，确保用户可以方便地访问和查看这些检测结果。</p>\n<h3 id=\"实时警报信息\"><a href=\"#实时警报信息\" class=\"headerlink\" title=\"实时警报信息\"></a>实时警报信息</h3><p><img src=\"https://tk-pichost-1325224430.cos.ap-chengdu.myqcloud.com/blog/17421139200811742113919172.png\" alt=\"17421139200811742113919172.png\"></p>\n<p><img src=\"https://tk-pichost-1325224430.cos.ap-chengdu.myqcloud.com/blog/17421139300831742113929519.png\" alt=\"17421139300831742113929519.png\"></p>\n<h3 id=\"检测状态日志。\"><a href=\"#检测状态日志。\" class=\"headerlink\" title=\"检测状态日志。\"></a>检测状态日志。</h3><h2 id=\"算法\"><a href=\"#算法\" class=\"headerlink\" title=\"算法\"></a>算法</h2><h3 id=\"图像预处理：\"><a href=\"#图像预处理：\" class=\"headerlink\" title=\"图像预处理：\"></a>图像预处理：</h3><p>图像预处理是训练溺水检测系统的模型中的一个关键步骤，旨在提高模型对图像的适应性和准确性。在训练模型之间我们对数据集采用了以下数据预处理方法:</p>\n<ul>\n<li>随机高斯模糊：通过添加随机高斯模糊，系统能够模拟不同摄像机焦点条件下的图像，从而使模型更加灵活，能够适应各种不同的视觉环境。</li>\n<li>灰度处理：将彩色图像转换为灰度图像，合并颜色通道，减少计算复杂度，使模型运行更快，同时降低模型对主体颜色的敏感度，提高检测的鲁棒性。</li>\n<li>图像拆分平铺：为了提高对小物体检测的准确性，特别是在航拍图像和显微镜图像等情况下，系统将图像拆分为多个小块进行处理，以捕捉更多细节。</li>\n<li>Mosaic 数据增强：通过将训练集中的多张照片合并为一张拼贴图像，系统能够增加训练数据的多样性，提高模型对未见场景的泛化能力。</li>\n<li>旋转和翻转：对图像进行随机旋转和翻转，以模拟不同的拍摄角度，增强模型对不同方向目标的识别能力。同时，将所有图片的大小统一重新设置为 640x640 像素，以适应模型的输入要求。</li>\n</ul>\n<h3 id=\"目标检测、语义分割以及实例分割技术\"><a href=\"#目标检测、语义分割以及实例分割技术\" class=\"headerlink\" title=\"目标检测、语义分割以及实例分割技术\"></a>目标检测、语义分割以及实例分割技术</h3><h4 id=\"目标检测\"><a href=\"#目标检测\" class=\"headerlink\" title=\"目标检测\"></a>目标检测</h4><p>目标检测就像是给视频中的每个物体贴上标签。想象一下，你在看一个视频，视频中有很多人和物体，目标检测技术要做的就是识别出视频中的每个人或物体，并在它们周围画一个框，同时告诉计算机：“看，这里有一个目标！” 这样，计算机就知道视频中有哪些物体，它们在哪里了。</p>\n<h4 id=\"实例分割\"><a href=\"#实例分割\" class=\"headerlink\" title=\"实例分割\"></a>实例分割</h4><p>实例分割则更进一步，它不仅要识别出视频中的每个人或物体，还要精确地知道每个目标的边界在哪里。这就像是用一支笔画出每个人的轮廓，确保没有两个人的轮廓重叠。这样，即使有多个人站在一起，计算机也能清楚地区分出谁是谁。</p>\n<h4 id=\"语义分割\"><a href=\"#语义分割\" class=\"headerlink\" title=\"语义分割\"></a>语义分割</h4><p>语义分割与实例分割有些相似，但它关注的是图像中的每个像素属于哪个类别，比如河流、草地或道路。它会给图像中的每个像素分配一个标签，告诉我们这个像素是属于河流还是其他什么。这就像是给一幅画中的每个部分上色，每种颜色代表一种不同的物体或区域。</p>\n<p>我们的系统主要训练了两个 YOLO11 模型分别完成对人物同时进行目标检测与实例分割的 detection 模型以及对河流进行语义分割的 seg 模型。</p>\n<h3 id=\"溺水检测算法\"><a href=\"#溺水检测算法\" class=\"headerlink\" title=\"溺水检测算法\"></a>溺水检测算法</h3><p>溺水检测算法是系统的核心，它结合了目标检测、实例分割和语义分割技术，以实现对溺水行为的准确识别。</p>\n<ul>\n<li>目标检测与实例分割：首先对人物进行目标检测与实例分割，以识别和定位图像中的人物。</li>\n<li>语义分割：对河流等水域进行语义分割，以区分水域和其他区域。</li>\n<li>重叠率计算：计算检测出的人物像素点与河流像素点的重叠率。如果人在目标检测的像素点中与河流的像素点的重叠率在 80% 以上，系统预测人有溺水的风险，并发出报警提示。如果人在实例分割的像素点与河流的像素点的重叠率在 75% 以上，系统检测到人溺水，并发出报警提示，同时进行语义播报，提示安保人员采取行动。</li>\n</ul>\n<h2 id=\"程序逻辑\"><a href=\"#程序逻辑\" class=\"headerlink\" title=\"程序逻辑\"></a>程序逻辑</h2><p><img src=\"https://tk-pichost-1325224430.cos.ap-chengdu.myqcloud.com/blog/17421139540811742113953297.png\" alt=\"17421139540811742113953297.png\"></p>\n<p>主要处理流程：</p>\n<h3 id=\"视频输入\"><a href=\"#视频输入\" class=\"headerlink\" title=\"视频输入\"></a>视频输入</h3><p>系统接收的视频输入可以是本地存储的文件，如 MP4 或 AVI 格式，或是实时捕获的摄像头视频流。此外，系统设计有网络功能，能够在同一局域网内直接调用平板和手机的摄像头，这增加了系统的灵活性和适用性。对于网络摄像头，系统将通过网络协议（如 RTSP）接收视频数据。</p>\n<h3 id=\"帧处理\"><a href=\"#帧处理\" class=\"headerlink\" title=\"帧处理\"></a>帧处理</h3><p>视频流在输入后被分解为单独的帧，这些帧随后被送入预处理模块。</p>\n<h3 id=\"模型检测\"><a href=\"#模型检测\" class=\"headerlink\" title=\"模型检测\"></a>模型检测</h3><ul>\n<li>人物目标检测与实例分割模型：负责识别和定位视频中的每个人，为每个人绘制边界框，并输出位置信息。</li>\n<li>河流语义分割模型：进行像素级别的分割，精确区分个体轮廓，为行为分析提供详细数据。</li>\n</ul>\n<h3 id=\"行为分析\"><a href=\"#行为分析\" class=\"headerlink\" title=\"行为分析\"></a>行为分析</h3><p>系统分析个体的行为，特别是与水域相关的活动。这包括：</p>\n<ul>\n<li>计算个体与河流等水域的像素点重叠率，判断个体是否处于溺水风险中。</li>\n<li>分析个体的姿态和动作，识别出挣扎、静止不动或异常姿势等可能的溺水迹象。</li>\n</ul>\n<h3 id=\"警报触发\"><a href=\"#警报触发\" class=\"headerlink\" title=\"警报触发\"></a>警报触发</h3><p>基于行为分析的结果，系统决定是否触发警报。警报触发条件包括：</p>\n<ul>\n<li>个体与水域的重叠率超过 80%，系统预测存在溺水风险，发出警报提示。</li>\n<li>个体与水域的重叠率超过 75%，系统确认检测到溺水行为，发出警报，并进行语义播报提示安保人员。</li>\n</ul>\n<h3 id=\"视频输出\"><a href=\"#视频输出\" class=\"headerlink\" title=\"视频输出\"></a>视频输出</h3><p>处理后的视频帧被重新组合成视频流，用于记录、回放或进一步分析。这不仅有助于事故后的审查，也可以用于系统性能的评估和优化。视频输出模块负责将处理后的视频保存到指定路径，并提供回放功能，以便用户可以查看和分析检测结果。</p>\n<h2 id=\"接口\"><a href=\"#接口\" class=\"headerlink\" title=\"接口\"></a>接口</h2><h3 id=\"视频输入接口\"><a href=\"#视频输入接口\" class=\"headerlink\" title=\"视频输入接口\"></a>视频输入接口</h3><p>视频输入接口负责接收和处理来自不同来源的视频数据。这个接口支持多种视频输入格式，包括但不限于 MP4、AVI 等，以适应不同的监控环境和设备。此外，该接口还支持实时视频流，能够从网络摄像头、物理摄像头或移动设备捕获视频。为了提高系统的灵活性和适应性，视频输入接口还应能够处理不同分辨率和帧率的视频数据。</p>\n<ul>\n<li>功能：<ul>\n<li>支持多种视频文件格式的读取。</li>\n<li>能够从网络摄像头或移动设备捕获实时视频流。</li>\n<li>处理不同分辨率和帧率的视频数据。</li>\n</ul>\n</li>\n</ul>\n<h3 id=\"模型调用接口\"><a href=\"#模型调用接口\" class=\"headerlink\" title=\"模型调用接口\"></a>模型调用接口</h3><p>模型调用接口是系统与深度学习模型交互的关键。它负责加载、管理和调用用于目标检测、实例分割和语义分割的模型。这个接口确保模型能够在需要时被快速且准确地调用，从而实现高效的视频分析和处理。</p>\n<ul>\n<li>功能：<ul>\n<li>加载预训练的深度学习模型。</li>\n<li>提供模型调用的 API，以便在视频处理过程中进行目标检测和分割。</li>\n<li>管理和优化模型的内存使用，确保系统的稳定运行。</li>\n</ul>\n</li>\n</ul>\n<h3 id=\"警报系统接口\"><a href=\"#警报系统接口\" class=\"headerlink\" title=\"警报系统接口\"></a>警报系统接口</h3><p>警报系统接口负责在检测到潜在溺水行为时触发警报。这个接口需要能够快速响应检测结果，并根据预设的阈值决定是否发出警报。警报可以通过声音、视觉信号或移动通知等多种方式发出，以确保信息能够及时传达给监控人员。</p>\n<ul>\n<li>功能：<ul>\n<li>根据溺水检测算法的输出决定是否触发警报。</li>\n<li>支持多种警报方式，包括声音、视觉信号和移动通知。</li>\n<li>确保警报的及时性和准确性。</li>\n</ul>\n</li>\n</ul>\n<h3 id=\"用户交互接口\"><a href=\"#用户交互接口\" class=\"headerlink\" title=\"用户交互接口\"></a>用户交互接口</h3><p>用户交互接口是系统与用户之间沟通的渠道。它提供了一个用户友好的界面，使用户能够轻松地配置系统参数、选择视频源、查看检测结果和接收警报。这个接口的设计应考虑到易用性和直观性，以降低用户的使用门槛。</p>\n<ul>\n<li>功能：<ul>\n<li>提供用户配置系统参数的界面，如检测灵敏度、警报阈值等。</li>\n<li>允许用户选择视频输入源和查看处理后的视频。</li>\n<li>显示实时警报信息和系统状态更新。</li>\n<li>提供用户反馈和系统性能评估的途径。</li>\n</ul>\n</li>\n</ul>\n<h2 id=\"存储分配\"><a href=\"#存储分配\" class=\"headerlink\" title=\"存储分配\"></a>存储分配</h2><h3 id=\"模型文件：-model\"><a href=\"#模型文件：-model\" class=\"headerlink\" title=\"模型文件：./model/\"></a>模型文件：<code>./model/</code></h3><p><img src=\"https://tk-pichost-1325224430.cos.ap-chengdu.myqcloud.com/blog/17421139890831742113988930.png\" alt=\"17421139890831742113988930.png\"></p>\n<h3 id=\"输出文件：-output\"><a href=\"#输出文件：-output\" class=\"headerlink\" title=\"输出文件：./output/\"></a>输出文件：<code>./output/</code></h3><p><img src=\"https://tk-pichost-1325224430.cos.ap-chengdu.myqcloud.com/blog/17421140070851742114007023.png\" alt=\"17421140070851742114007023.png\"></p>\n<h3 id=\"资源文件：-resource\"><a href=\"#资源文件：-resource\" class=\"headerlink\" title=\"资源文件：./resource/\"></a>资源文件：<code>./resource/</code></h3><p><img src=\"https://tk-pichost-1325224430.cos.ap-chengdu.myqcloud.com/blog/17421140180851742114017407.png\" alt=\"17421140180851742114017407.png\"></p>\n<h3 id=\"源代码：-src\"><a href=\"#源代码：-src\" class=\"headerlink\" title=\"源代码：./src/\"></a>源代码：<code>./src/</code></h3><p><img src=\"https://tk-pichost-1325224430.cos.ap-chengdu.myqcloud.com/blog/17421140290841742114028567.png\" alt=\"17421140290841742114028567.png\"></p>\n<h2 id=\"限制条件\"><a href=\"#限制条件\" class=\"headerlink\" title=\"限制条件\"></a>限制条件</h2><table>\n<tr>\n<td>- Python 3.8+运行环境<br/></td></tr>\n<tr>\n<td>- CUDA支持（推荐）<br/></td></tr>\n<tr>\n<td>- 最小8GB内存<br/></td></tr>\n<tr>\n<td>- 支持OpenCV的操作系统<br/></td></tr>\n</table>\n\n<h2 id=\"测试要点\"><a href=\"#测试要点\" class=\"headerlink\" title=\"测试要点\"></a>测试要点</h2><h3 id=\"视频处理性能测试\"><a href=\"#视频处理性能测试\" class=\"headerlink\" title=\"视频处理性能测试\"></a>视频处理性能测试</h3><p>视频处理性能测试旨在评估系统处理视频流的能力，包括实时性、帧率和视频质量。测试将模拟不同的视频输入条件，如不同的分辨率、帧率和编码格式，以确保系统能够在各种情况下稳定运行。</p>\n<ul>\n<li>目标：确保系统能够以至少 30FPS 的速度处理 1080P 视频，同时保持低延迟。</li>\n<li>方法：使用不同参数的视频文件进行播放，测量处理时间和输出视频的质量。</li>\n</ul>\n<h3 id=\"检测准确率测试\"><a href=\"#检测准确率测试\" class=\"headerlink\" title=\"检测准确率测试\"></a>检测准确率测试</h3><p>检测准确率测试用于验证目标检测和实例分割模型的准确性。这包括检测模型能否正确识别和定位视频中的人物，以及分割模型能否准确区分个体和背景。</p>\n<ul>\n<li>目标：达到 90% 以上的检测准确率。</li>\n<li>方法：通过与人工标注的测试集比较，计算模型的精确度、召回率和 F1 分数。</li>\n</ul>\n<h3 id=\"警报系统响应测试\"><a href=\"#警报系统响应测试\" class=\"headerlink\" title=\"警报系统响应测试\"></a>警报系统响应测试</h3><p>警报系统响应测试确保在检测到溺水行为时，系统能够及时发出警报。这包括测试警报的触发逻辑和警报的传递速度。</p>\n<ul>\n<li>目标：警报响应时间小于 1 秒。</li>\n<li>方法：模拟溺水场景，测量从检测到警报发出的时间。</li>\n</ul>\n<h3 id=\"内存占用测试\"><a href=\"#内存占用测试\" class=\"headerlink\" title=\"内存占用测试\"></a>内存占用测试</h3><p>内存占用测试评估系统运行时的内存使用情况，以确保系统在资源有限的环境中也能高效运行。</p>\n<ul>\n<li>目标：优化内存使用，避免内存泄漏。</li>\n<li>方法：监控系统运行过程中的内存使用情况，特别是在处理大量视频数据时。</li>\n</ul>\n<h3 id=\"长时间运行稳定性测试\"><a href=\"#长时间运行稳定性测试\" class=\"headerlink\" title=\"长时间运行稳定性测试\"></a>长时间运行稳定性测试</h3><p>长时间运行稳定性测试用于验证系统在连续运行条件下的稳定性和可靠性。这包括测试系统是否能够长时间稳定运行而不出现崩溃或性能下降。</p>\n<ul>\n<li>目标：确保系统能够连续运行至少 72 小时无故障。</li>\n<li>方法：让系统连续处理视频流，监控其性能和资源使用情况。</li>\n</ul>\n<h2 id=\"安装步骤\"><a href=\"#安装步骤\" class=\"headerlink\" title=\"安装步骤\"></a>安装步骤</h2><h3 id=\"克隆仓库\"><a href=\"#克隆仓库\" class=\"headerlink\" title=\"克隆仓库:\"></a>克隆仓库:</h3><figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">git <span class=\"built_in\">clone</span> https://github.com/your-username/drowning-detection.git</span><br><span class=\"line\"><span class=\"built_in\">cd</span> drowning-detection</span><br></pre></td></tr></table></figure>\n\n<h3 id=\"创建并激活虚拟环境-推荐\"><a href=\"#创建并激活虚拟环境-推荐\" class=\"headerlink\" title=\"创建并激活虚拟环境(推荐):\"></a>创建并激活虚拟环境(推荐):</h3><figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">python -m venv venv</span><br><span class=\"line\"><span class=\"built_in\">source</span> venv/bin/activate  <span class=\"comment\"># 在Windows上使用 venv\\Scripts\\activate</span></span><br></pre></td></tr></table></figure>\n\n<h3 id=\"安装依赖\"><a href=\"#安装依赖\" class=\"headerlink\" title=\"安装依赖:\"></a>安装依赖:</h3><figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">pip install -r requirements.txt</span><br></pre></td></tr></table></figure>\n\n<p>这将安装项目所需的所有依赖项,并确保版本与开发环境一致。</p>\n<blockquote>\n<p>注意: 如果您在安装过程中遇到任何问题,特别是与 CUDA 或 GPU 支持相关的问题,请参考 PyTorch 官方文档以获取适合您系统的安装说明。</p>\n</blockquote>\n<h2 id=\"使用说明\"><a href=\"#使用说明\" class=\"headerlink\" title=\"使用说明\"></a>使用说明</h2><h3 id=\"确保您有适当的视频文件用于检测。\"><a href=\"#确保您有适当的视频文件用于检测。\" class=\"headerlink\" title=\"确保您有适当的视频文件用于检测。\"></a>确保您有适当的视频文件用于检测。</h3><h3 id=\"修改-main-py-中的-video-path-变量-指向您的视频文件\"><a href=\"#修改-main-py-中的-video-path-变量-指向您的视频文件\" class=\"headerlink\" title=\"修改 main.py 中的 video_path 变量,指向您的视频文件:\"></a>修改 <code>main.py</code> 中的 <code>video_path</code> 变量,指向您的视频文件:</h3><figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">video_path = <span class=\"string\">&quot;path/to/your/video.mp4&quot;</span></span><br></pre></td></tr></table></figure>\n\n<h3 id=\"运行主程序\"><a href=\"#运行主程序\" class=\"headerlink\" title=\"运行主程序:\"></a>运行主程序:</h3><figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">python main.py</span><br></pre></td></tr></table></figure>\n\n<h3 id=\"程序将开始处理视频-并在检测到潜在溺水危险时发出警告。\"><a href=\"#程序将开始处理视频-并在检测到潜在溺水危险时发出警告。\" class=\"headerlink\" title=\"程序将开始处理视频,并在检测到潜在溺水危险时发出警告。\"></a>程序将开始处理视频,并在检测到潜在溺水危险时发出警告。</h3><h3 id=\"按-‘q’-键退出程序。\"><a href=\"#按-‘q’-键退出程序。\" class=\"headerlink\" title=\"按 ‘q’ 键退出程序。\"></a>按 ‘q’ 键退出程序。</h3><h1 id=\"四、项目总结\"><a href=\"#四、项目总结\" class=\"headerlink\" title=\"四、项目总结\"></a>四、项目总结</h1><p>在反思这个溺水检测项目时，我们意识到技术的进步不仅仅是为了创新，更是为了解决实际问题，保护人们的生命安全。我们的项目通过结合最新的人工智能技术和多种监控手段，旨在减少溺水事故，这是一个极具社会价值的目标。我们认识到，尽管技术提供了强大的工具，但真正的挑战在于如何将这些工具有效地应用于实际场景中，以及如何确保系统的稳定性和可靠性。未来，我们将继续优化算法，提高系统的响应速度和准确性，同时，我们也将探索如何降低成本，使这项技术能够更广泛地应用于各种水域，从而保护更多人的生命。</p>\n<p>在推广方面，我们认为教育和意识提升同样重要。如果可行的话，我们将与学校、社区和地方政府合作，提高公众对溺水风险的认识，并教育他们如何使用我们的系统。此外，我们也将通过各种媒体渠道，如社交媒体、公共讲座和行业会议，来展示我们的技术成果，以吸引更多的关注和支持。我们相信，通过技术的推广和公众意识的提高，我们可以共同构建一个更安全的水上环境。让人类拥有更美好的未来！</p>\n"},{"title":"2025-03-28-Tmux(多终端管理器)使用教程","date":"2025-03-27T16:00:00.000Z","_content":"\n> [Tmux Cheat Sheet & Quick Reference | Session, window, pane and more](https://tmuxcheatsheet.com/)\n>\n> [https://www.youtube.com/watch?v=nTqu6w2wc68&ab_channel=NetworkChuck](https://www.youtube.com/watch?v=nTqu6w2wc68&ab_channel=NetworkChuck)(教学视频)\n>\n> [Tmux 使用手册](https://louiszhai.github.io/2017/09/30/tmux/)\n>\n> [Tmux 快捷键 & 速查表 & 简明教程](https://gist.github.com/ryerh/14b7c24dfd623ef8edc7)\n\n启动新会话：\n\n```bash\ntmux [new -s 会话名 -n 窗口名]\n```\n\n恢复会话：\n\n```bash\ntmux at [-t 会话名]\n```\n\n列出所有会话：\n\n```bash\ntmux ls\n```\n\n关闭会话：\n\n```bash\ntmux kill-session -t 会话名\n```\n\n关闭所有会话：\n\n```bash\ntmux ls | grep : | cut -d. -f1 | awk '{print substr($1, 0, length($1)-1)}' | xargs kill\n```\n\n# **在 Tmux 中，按下 Tmux 前缀** **ctrl+b****，然后：**\n\n## **会话**\n\n```bash\n:new<回车>  启动新会话\ns           列出所有会话\n$           重命名当前会话\n```\n\n## **窗口 (标签页)**\n\n```bash\nc  创建新窗口\nw  列出所有窗口\nn  后一个窗口\np  前一个窗口\nf  查找窗口\n,  重命名当前窗口\n&  关闭当前窗口\n```\n\n## **调整窗口排序**\n\n```bash\nswap-window -s 3 -t 1  交换 3 号和 1 号窗口\nswap-window -t 1       交换当前和 1 号窗口\nmove-window -t 1       移动当前窗口到 1 号\n```\n\n## **窗格（分割窗口）**\n\n```bash\n%  垂直分割\n\"  水平分割\no  交换窗格\nx  关闭窗格\n⍽  左边这个符号代表空格键 - 切换布局\nq 显示每个窗格是第几个，当数字出现的时候按数字几就选中第几个窗格\n{ 与上一个窗格交换位置\n} 与下一个窗格交换位置\nz 切换窗格最大化/最小化\n```\n\n## **同步窗格**\n\n这么做可以切换到想要的窗口，输入 Tmux 前缀和一个冒号呼出命令提示行，然后输入：\n\n```bash\n:setw synchronize-panes\n```\n\n你可以指定开或关，否则重复执行命令会在两者间切换。 这个选项值针对某个窗口有效，不会影响别的会话和窗口。 完事儿之后再次执行命令来关闭。<u>帮助</u>\n\n## **调整窗格尺寸**\n\n如果你不喜欢默认布局，可以重调窗格的尺寸。虽然这很容易实现，但一般不需要这么干。这几个命令用来调整窗格：\n\n```bash\nPREFIX : resize-pane -D          当前窗格向下扩大 1 格\nPREFIX : resize-pane -U          当前窗格向上扩大 1 格\nPREFIX : resize-pane -L          当前窗格向左扩大 1 格\nPREFIX : resize-pane -R          当前窗格向右扩大 1 格\nPREFIX : resize-pane -D 20       当前窗格向下扩大 20 格\nPREFIX : resize-pane -t 2 -L 20  编号为 2 的窗格向左扩大 20 格\n```\n\n## **文本复制模式：**\n\n按下 `PREFIX-[` 进入文本复制模式。可以使用方向键在屏幕中移动光标。默认情况下，方向键是启用的。在配置文件中启用 Vim 键盘布局来切换窗口、调整窗格大小。Tmux 也支持 Vi 模式。要是想启用 Vi 模式，只需要把下面这一行添加到 .tmux.conf 中：\n\n```bash\nsetw -g mode-keys vi\n```\n\n启用这条配置后，就可以使用 h、j、k、l 来移动光标了。\n\n想要退出文本复制模式的话，按下回车键就可以了。然后按下 `PREFIX-]` 粘贴刚才复制的文本。\n\n一次移动一格效率低下，在 Vi 模式启用的情况下，可以辅助一些别的快捷键高效工作。\n\n例如，可以使用 w 键逐词移动，使用 b 键逐词回退。使用 f 键加上任意字符跳转到当前行第一次出现该字符的位置，使用 F 键达到相反的效果。\n\n```bash\nvi             emacs        功能\n^              M-m          反缩进\nEscape         C-g          清除选定内容\nEnter          M-w          复制选定内容\nj              Down         光标下移\nh              Left         光标左移\nl              Right        光标右移\nL                           光标移到尾行\nM              M-r          光标移到中间行\nH              M-R          光标移到首行\nk              Up           光标上移\nd              C-u          删除整行\nD              C-k          删除到行末\n$              C-e          移到行尾\n:              g            前往指定行\nC-d            M-Down       向下滚动半屏\nC-u            M-Up         向上滚动半屏\nC-f            Page down    下一页\nw              M-f          下一个词\np              C-y          粘贴\nC-b            Page up      上一页\nb              M-b          上一个词\nq              Escape       退出\nC-Down or J    C-Down       向下翻\nC-Up or K      C-Up         向下翻\nn              n            继续搜索\n?              C-r          向前搜索\n/              C-s          向后搜索\n0              C-a          移到行首\nSpace          C-Space      开始选中\n               C-t          字符调序\n```\n\n## **杂项：**\n\n```bash\nd  退出 tmux（tmux 仍在后台运行）\nt  窗口中央显示一个数字时钟\n?  列出所有快捷键\n:  命令提示符\n```\n\n## **配置选项：**\n\n```bash\n# 鼠标支持 - 设置为 on 来启用鼠标(与 2.1 之前的版本有区别，请自行查阅 man page)\n* set -g mouse on\n\n# 设置默认终端模式为 256color\nset -g default-terminal \"screen-256color\"\n\n# 启用活动警告\nsetw -g monitor-activity on\nset -g visual-activity on\n\n# 居中窗口列表\nset -g status-justify centre\n\n# 最大化/恢复窗格\nunbind Up bind Up new-window -d -n tmp \\; swap-pane -s tmp.1 \\; select-window -t tmp\nunbind Down\nbind Down last-window \\; swap-pane -s tmp.1 \\; kill-window -t tmp\n```\n\n## **参考配置文件（~/.tmux.conf）：**\n\n```bash\n# -----------------------------------------------------------------------------# Tmux 基本配置 - 要求 Tmux >= 2.3# 如果不想使用插件，只需要将此节的内容写入 ~/.tmux.conf 即可# -----------------------------------------------------------------------------# C-b 和 VIM 冲突，修改 Prefix 组合键为 Control-Z，按键距离近set -g prefix C-z\n\nset -g base-index         1     # 窗口编号从 1 开始计数\nset -g display-panes-time 10000 # PREFIX-Q 显示编号的驻留时长，单位 msset -g mouse              on    # 开启鼠标\nset -g pane-base-index    1     # 窗格编号从 1 开始计数\nset -g renumber-windows   on    # 关掉某个窗口后，编号重排\n\nsetw -g allow-rename      off   # 禁止活动进程修改窗口名\nsetw -g automatic-rename  off   # 禁止自动命名新窗口\nsetw -g mode-keys         vi    # 进入复制模式的时候使用 vi 键位（默认是 EMACS）# -----------------------------------------------------------------------------# 使用插件 - via tpm#   1. 执行 git clone https://github.com/tmux-plugins/tpm ~/.tmux/plugins/tpm#   2. 执行 bash ~/.tmux/plugins/tpm/bin/install_plugins# -----------------------------------------------------------------------------\n\nsetenv -g TMUX_PLUGIN_MANAGER_PATH '~/.tmux/plugins'# 推荐的插件（请去每个插件的仓库下读一读使用教程）\nset -g @plugin 'seebi/tmux-colors-solarized'\nset -g @plugin 'tmux-plugins/tmux-pain-control'\nset -g @plugin 'tmux-plugins/tmux-prefix-highlight'\nset -g @plugin 'tmux-plugins/tmux-resurrect'\nset -g @plugin 'tmux-plugins/tmux-sensible'\nset -g @plugin 'tmux-plugins/tmux-yank'\nset -g @plugin 'tmux-plugins/tpm'# tmux-resurrectset -g @resurrect-dir '~/.tmux/resurrect'# tmux-prefix-highlightset -g status-right '#{prefix_highlight} #H | %a %Y-%m-%d %H:%M'\nset -g @prefix_highlight_show_copy_mode 'on'\nset -g @prefix_highlight_copy_mode_attr 'fg=white,bg=blue'# 初始化 TPM 插件管理器 (放在配置文件的最后)\nrun '~/.tmux/plugins/tpm/tpm'# -----------------------------------------------------------------------------# 结束# -----------------------------------------------------------------------------\n```\n","source":"_posts/2025-03-28-Tmux(multi-shell manager)command summary.md","raw":"---\ntitle: 2025-03-28-Tmux(多终端管理器)使用教程\ndate: 2025-03-28\ntags: \n    问题解决\n---\n\n> [Tmux Cheat Sheet & Quick Reference | Session, window, pane and more](https://tmuxcheatsheet.com/)\n>\n> [https://www.youtube.com/watch?v=nTqu6w2wc68&ab_channel=NetworkChuck](https://www.youtube.com/watch?v=nTqu6w2wc68&ab_channel=NetworkChuck)(教学视频)\n>\n> [Tmux 使用手册](https://louiszhai.github.io/2017/09/30/tmux/)\n>\n> [Tmux 快捷键 & 速查表 & 简明教程](https://gist.github.com/ryerh/14b7c24dfd623ef8edc7)\n\n启动新会话：\n\n```bash\ntmux [new -s 会话名 -n 窗口名]\n```\n\n恢复会话：\n\n```bash\ntmux at [-t 会话名]\n```\n\n列出所有会话：\n\n```bash\ntmux ls\n```\n\n关闭会话：\n\n```bash\ntmux kill-session -t 会话名\n```\n\n关闭所有会话：\n\n```bash\ntmux ls | grep : | cut -d. -f1 | awk '{print substr($1, 0, length($1)-1)}' | xargs kill\n```\n\n# **在 Tmux 中，按下 Tmux 前缀** **ctrl+b****，然后：**\n\n## **会话**\n\n```bash\n:new<回车>  启动新会话\ns           列出所有会话\n$           重命名当前会话\n```\n\n## **窗口 (标签页)**\n\n```bash\nc  创建新窗口\nw  列出所有窗口\nn  后一个窗口\np  前一个窗口\nf  查找窗口\n,  重命名当前窗口\n&  关闭当前窗口\n```\n\n## **调整窗口排序**\n\n```bash\nswap-window -s 3 -t 1  交换 3 号和 1 号窗口\nswap-window -t 1       交换当前和 1 号窗口\nmove-window -t 1       移动当前窗口到 1 号\n```\n\n## **窗格（分割窗口）**\n\n```bash\n%  垂直分割\n\"  水平分割\no  交换窗格\nx  关闭窗格\n⍽  左边这个符号代表空格键 - 切换布局\nq 显示每个窗格是第几个，当数字出现的时候按数字几就选中第几个窗格\n{ 与上一个窗格交换位置\n} 与下一个窗格交换位置\nz 切换窗格最大化/最小化\n```\n\n## **同步窗格**\n\n这么做可以切换到想要的窗口，输入 Tmux 前缀和一个冒号呼出命令提示行，然后输入：\n\n```bash\n:setw synchronize-panes\n```\n\n你可以指定开或关，否则重复执行命令会在两者间切换。 这个选项值针对某个窗口有效，不会影响别的会话和窗口。 完事儿之后再次执行命令来关闭。<u>帮助</u>\n\n## **调整窗格尺寸**\n\n如果你不喜欢默认布局，可以重调窗格的尺寸。虽然这很容易实现，但一般不需要这么干。这几个命令用来调整窗格：\n\n```bash\nPREFIX : resize-pane -D          当前窗格向下扩大 1 格\nPREFIX : resize-pane -U          当前窗格向上扩大 1 格\nPREFIX : resize-pane -L          当前窗格向左扩大 1 格\nPREFIX : resize-pane -R          当前窗格向右扩大 1 格\nPREFIX : resize-pane -D 20       当前窗格向下扩大 20 格\nPREFIX : resize-pane -t 2 -L 20  编号为 2 的窗格向左扩大 20 格\n```\n\n## **文本复制模式：**\n\n按下 `PREFIX-[` 进入文本复制模式。可以使用方向键在屏幕中移动光标。默认情况下，方向键是启用的。在配置文件中启用 Vim 键盘布局来切换窗口、调整窗格大小。Tmux 也支持 Vi 模式。要是想启用 Vi 模式，只需要把下面这一行添加到 .tmux.conf 中：\n\n```bash\nsetw -g mode-keys vi\n```\n\n启用这条配置后，就可以使用 h、j、k、l 来移动光标了。\n\n想要退出文本复制模式的话，按下回车键就可以了。然后按下 `PREFIX-]` 粘贴刚才复制的文本。\n\n一次移动一格效率低下，在 Vi 模式启用的情况下，可以辅助一些别的快捷键高效工作。\n\n例如，可以使用 w 键逐词移动，使用 b 键逐词回退。使用 f 键加上任意字符跳转到当前行第一次出现该字符的位置，使用 F 键达到相反的效果。\n\n```bash\nvi             emacs        功能\n^              M-m          反缩进\nEscape         C-g          清除选定内容\nEnter          M-w          复制选定内容\nj              Down         光标下移\nh              Left         光标左移\nl              Right        光标右移\nL                           光标移到尾行\nM              M-r          光标移到中间行\nH              M-R          光标移到首行\nk              Up           光标上移\nd              C-u          删除整行\nD              C-k          删除到行末\n$              C-e          移到行尾\n:              g            前往指定行\nC-d            M-Down       向下滚动半屏\nC-u            M-Up         向上滚动半屏\nC-f            Page down    下一页\nw              M-f          下一个词\np              C-y          粘贴\nC-b            Page up      上一页\nb              M-b          上一个词\nq              Escape       退出\nC-Down or J    C-Down       向下翻\nC-Up or K      C-Up         向下翻\nn              n            继续搜索\n?              C-r          向前搜索\n/              C-s          向后搜索\n0              C-a          移到行首\nSpace          C-Space      开始选中\n               C-t          字符调序\n```\n\n## **杂项：**\n\n```bash\nd  退出 tmux（tmux 仍在后台运行）\nt  窗口中央显示一个数字时钟\n?  列出所有快捷键\n:  命令提示符\n```\n\n## **配置选项：**\n\n```bash\n# 鼠标支持 - 设置为 on 来启用鼠标(与 2.1 之前的版本有区别，请自行查阅 man page)\n* set -g mouse on\n\n# 设置默认终端模式为 256color\nset -g default-terminal \"screen-256color\"\n\n# 启用活动警告\nsetw -g monitor-activity on\nset -g visual-activity on\n\n# 居中窗口列表\nset -g status-justify centre\n\n# 最大化/恢复窗格\nunbind Up bind Up new-window -d -n tmp \\; swap-pane -s tmp.1 \\; select-window -t tmp\nunbind Down\nbind Down last-window \\; swap-pane -s tmp.1 \\; kill-window -t tmp\n```\n\n## **参考配置文件（~/.tmux.conf）：**\n\n```bash\n# -----------------------------------------------------------------------------# Tmux 基本配置 - 要求 Tmux >= 2.3# 如果不想使用插件，只需要将此节的内容写入 ~/.tmux.conf 即可# -----------------------------------------------------------------------------# C-b 和 VIM 冲突，修改 Prefix 组合键为 Control-Z，按键距离近set -g prefix C-z\n\nset -g base-index         1     # 窗口编号从 1 开始计数\nset -g display-panes-time 10000 # PREFIX-Q 显示编号的驻留时长，单位 msset -g mouse              on    # 开启鼠标\nset -g pane-base-index    1     # 窗格编号从 1 开始计数\nset -g renumber-windows   on    # 关掉某个窗口后，编号重排\n\nsetw -g allow-rename      off   # 禁止活动进程修改窗口名\nsetw -g automatic-rename  off   # 禁止自动命名新窗口\nsetw -g mode-keys         vi    # 进入复制模式的时候使用 vi 键位（默认是 EMACS）# -----------------------------------------------------------------------------# 使用插件 - via tpm#   1. 执行 git clone https://github.com/tmux-plugins/tpm ~/.tmux/plugins/tpm#   2. 执行 bash ~/.tmux/plugins/tpm/bin/install_plugins# -----------------------------------------------------------------------------\n\nsetenv -g TMUX_PLUGIN_MANAGER_PATH '~/.tmux/plugins'# 推荐的插件（请去每个插件的仓库下读一读使用教程）\nset -g @plugin 'seebi/tmux-colors-solarized'\nset -g @plugin 'tmux-plugins/tmux-pain-control'\nset -g @plugin 'tmux-plugins/tmux-prefix-highlight'\nset -g @plugin 'tmux-plugins/tmux-resurrect'\nset -g @plugin 'tmux-plugins/tmux-sensible'\nset -g @plugin 'tmux-plugins/tmux-yank'\nset -g @plugin 'tmux-plugins/tpm'# tmux-resurrectset -g @resurrect-dir '~/.tmux/resurrect'# tmux-prefix-highlightset -g status-right '#{prefix_highlight} #H | %a %Y-%m-%d %H:%M'\nset -g @prefix_highlight_show_copy_mode 'on'\nset -g @prefix_highlight_copy_mode_attr 'fg=white,bg=blue'# 初始化 TPM 插件管理器 (放在配置文件的最后)\nrun '~/.tmux/plugins/tpm/tpm'# -----------------------------------------------------------------------------# 结束# -----------------------------------------------------------------------------\n```\n","slug":"2025-03-28-Tmux(multi-shell manager)command summary","published":1,"updated":"2025-09-26T12:16:32.127Z","_id":"cmg0saj420011jm8nd3n6bjdx","comments":1,"layout":"post","photos":[],"content":"<blockquote>\n<p><a href=\"https://tmuxcheatsheet.com/\">Tmux Cheat Sheet &amp; Quick Reference | Session, window, pane and more</a></p>\n<p><a href=\"https://www.youtube.com/watch?v=nTqu6w2wc68&ab_channel=NetworkChuck\">https://www.youtube.com/watch?v=nTqu6w2wc68&ab_channel&#x3D;NetworkChuck</a>(教学视频)</p>\n<p><a href=\"https://louiszhai.github.io/2017/09/30/tmux/\">Tmux 使用手册</a></p>\n<p><a href=\"https://gist.github.com/ryerh/14b7c24dfd623ef8edc7\">Tmux 快捷键 &amp; 速查表 &amp; 简明教程</a></p>\n</blockquote>\n<p>启动新会话：</p>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">tmux [new -s 会话名 -n 窗口名]</span><br></pre></td></tr></table></figure>\n\n<p>恢复会话：</p>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">tmux at [-t 会话名]</span><br></pre></td></tr></table></figure>\n\n<p>列出所有会话：</p>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">tmux <span class=\"built_in\">ls</span></span><br></pre></td></tr></table></figure>\n\n<p>关闭会话：</p>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">tmux kill-session -t 会话名</span><br></pre></td></tr></table></figure>\n\n<p>关闭所有会话：</p>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">tmux <span class=\"built_in\">ls</span> | grep : | <span class=\"built_in\">cut</span> -d. -f1 | awk <span class=\"string\">&#x27;&#123;print substr($1, 0, length($1)-1)&#125;&#x27;</span> | xargs <span class=\"built_in\">kill</span></span><br></pre></td></tr></table></figure>\n\n<h1 id=\"在-Tmux-中，按下-Tmux-前缀-ctrl-b-，然后：\"><a href=\"#在-Tmux-中，按下-Tmux-前缀-ctrl-b-，然后：\" class=\"headerlink\" title=\"在 Tmux 中，按下 Tmux 前缀 ctrl+b****，然后：\"></a><strong>在 Tmux 中，按下 Tmux 前缀</strong> <strong>ctrl+b****，然后：</strong></h1><h2 id=\"会话\"><a href=\"#会话\" class=\"headerlink\" title=\"会话\"></a><strong>会话</strong></h2><figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">:new&lt;回车&gt;  启动新会话</span><br><span class=\"line\">s           列出所有会话</span><br><span class=\"line\">$           重命名当前会话</span><br></pre></td></tr></table></figure>\n\n<h2 id=\"窗口-标签页\"><a href=\"#窗口-标签页\" class=\"headerlink\" title=\"窗口 (标签页)\"></a><strong>窗口 (标签页)</strong></h2><figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">c  创建新窗口</span><br><span class=\"line\">w  列出所有窗口</span><br><span class=\"line\">n  后一个窗口</span><br><span class=\"line\">p  前一个窗口</span><br><span class=\"line\">f  查找窗口</span><br><span class=\"line\">,  重命名当前窗口</span><br><span class=\"line\">&amp;  关闭当前窗口</span><br></pre></td></tr></table></figure>\n\n<h2 id=\"调整窗口排序\"><a href=\"#调整窗口排序\" class=\"headerlink\" title=\"调整窗口排序\"></a><strong>调整窗口排序</strong></h2><figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">swap-window -s 3 -t 1  交换 3 号和 1 号窗口</span><br><span class=\"line\">swap-window -t 1       交换当前和 1 号窗口</span><br><span class=\"line\">move-window -t 1       移动当前窗口到 1 号</span><br></pre></td></tr></table></figure>\n\n<h2 id=\"窗格（分割窗口）\"><a href=\"#窗格（分割窗口）\" class=\"headerlink\" title=\"窗格（分割窗口）\"></a><strong>窗格（分割窗口）</strong></h2><figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">%  垂直分割</span><br><span class=\"line\"><span class=\"string\">&quot;  水平分割</span></span><br><span class=\"line\"><span class=\"string\">o  交换窗格</span></span><br><span class=\"line\"><span class=\"string\">x  关闭窗格</span></span><br><span class=\"line\"><span class=\"string\">⍽  左边这个符号代表空格键 - 切换布局</span></span><br><span class=\"line\"><span class=\"string\">q 显示每个窗格是第几个，当数字出现的时候按数字几就选中第几个窗格</span></span><br><span class=\"line\"><span class=\"string\">&#123; 与上一个窗格交换位置</span></span><br><span class=\"line\"><span class=\"string\">&#125; 与下一个窗格交换位置</span></span><br><span class=\"line\"><span class=\"string\">z 切换窗格最大化/最小化</span></span><br></pre></td></tr></table></figure>\n\n<h2 id=\"同步窗格\"><a href=\"#同步窗格\" class=\"headerlink\" title=\"同步窗格\"></a><strong>同步窗格</strong></h2><p>这么做可以切换到想要的窗口，输入 Tmux 前缀和一个冒号呼出命令提示行，然后输入：</p>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">:setw synchronize-panes</span><br></pre></td></tr></table></figure>\n\n<p>你可以指定开或关，否则重复执行命令会在两者间切换。 这个选项值针对某个窗口有效，不会影响别的会话和窗口。 完事儿之后再次执行命令来关闭。<u>帮助</u></p>\n<h2 id=\"调整窗格尺寸\"><a href=\"#调整窗格尺寸\" class=\"headerlink\" title=\"调整窗格尺寸\"></a><strong>调整窗格尺寸</strong></h2><p>如果你不喜欢默认布局，可以重调窗格的尺寸。虽然这很容易实现，但一般不需要这么干。这几个命令用来调整窗格：</p>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">PREFIX : resize-pane -D          当前窗格向下扩大 1 格</span><br><span class=\"line\">PREFIX : resize-pane -U          当前窗格向上扩大 1 格</span><br><span class=\"line\">PREFIX : resize-pane -L          当前窗格向左扩大 1 格</span><br><span class=\"line\">PREFIX : resize-pane -R          当前窗格向右扩大 1 格</span><br><span class=\"line\">PREFIX : resize-pane -D 20       当前窗格向下扩大 20 格</span><br><span class=\"line\">PREFIX : resize-pane -t 2 -L 20  编号为 2 的窗格向左扩大 20 格</span><br></pre></td></tr></table></figure>\n\n<h2 id=\"文本复制模式：\"><a href=\"#文本复制模式：\" class=\"headerlink\" title=\"文本复制模式：\"></a><strong>文本复制模式：</strong></h2><p>按下 <code>PREFIX-[</code> 进入文本复制模式。可以使用方向键在屏幕中移动光标。默认情况下，方向键是启用的。在配置文件中启用 Vim 键盘布局来切换窗口、调整窗格大小。Tmux 也支持 Vi 模式。要是想启用 Vi 模式，只需要把下面这一行添加到 .tmux.conf 中：</p>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">setw -g mode-keys vi</span><br></pre></td></tr></table></figure>\n\n<p>启用这条配置后，就可以使用 h、j、k、l 来移动光标了。</p>\n<p>想要退出文本复制模式的话，按下回车键就可以了。然后按下 <code>PREFIX-]</code> 粘贴刚才复制的文本。</p>\n<p>一次移动一格效率低下，在 Vi 模式启用的情况下，可以辅助一些别的快捷键高效工作。</p>\n<p>例如，可以使用 w 键逐词移动，使用 b 键逐词回退。使用 f 键加上任意字符跳转到当前行第一次出现该字符的位置，使用 F 键达到相反的效果。</p>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">vi             emacs        功能</span><br><span class=\"line\">^              M-m          反缩进</span><br><span class=\"line\">Escape         C-g          清除选定内容</span><br><span class=\"line\">Enter          M-w          复制选定内容</span><br><span class=\"line\">j              Down         光标下移</span><br><span class=\"line\">h              Left         光标左移</span><br><span class=\"line\">l              Right        光标右移</span><br><span class=\"line\">L                           光标移到尾行</span><br><span class=\"line\">M              M-r          光标移到中间行</span><br><span class=\"line\">H              M-R          光标移到首行</span><br><span class=\"line\">k              Up           光标上移</span><br><span class=\"line\">d              C-u          删除整行</span><br><span class=\"line\">D              C-k          删除到行末</span><br><span class=\"line\">$              C-e          移到行尾</span><br><span class=\"line\">:              g            前往指定行</span><br><span class=\"line\">C-d            M-Down       向下滚动半屏</span><br><span class=\"line\">C-u            M-Up         向上滚动半屏</span><br><span class=\"line\">C-f            Page down    下一页</span><br><span class=\"line\">w              M-f          下一个词</span><br><span class=\"line\">p              C-y          粘贴</span><br><span class=\"line\">C-b            Page up      上一页</span><br><span class=\"line\">b              M-b          上一个词</span><br><span class=\"line\">q              Escape       退出</span><br><span class=\"line\">C-Down or J    C-Down       向下翻</span><br><span class=\"line\">C-Up or K      C-Up         向下翻</span><br><span class=\"line\">n              n            继续搜索</span><br><span class=\"line\">?              C-r          向前搜索</span><br><span class=\"line\">/              C-s          向后搜索</span><br><span class=\"line\">0              C-a          移到行首</span><br><span class=\"line\">Space          C-Space      开始选中</span><br><span class=\"line\">               C-t          字符调序</span><br></pre></td></tr></table></figure>\n\n<h2 id=\"杂项：\"><a href=\"#杂项：\" class=\"headerlink\" title=\"杂项：\"></a><strong>杂项：</strong></h2><figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">d  退出 tmux（tmux 仍在后台运行）</span><br><span class=\"line\">t  窗口中央显示一个数字时钟</span><br><span class=\"line\">?  列出所有快捷键</span><br><span class=\"line\">:  命令提示符</span><br></pre></td></tr></table></figure>\n\n<h2 id=\"配置选项：\"><a href=\"#配置选项：\" class=\"headerlink\" title=\"配置选项：\"></a><strong>配置选项：</strong></h2><figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\"># 鼠标支持 - 设置为 on 来启用鼠标(与 2.1 之前的版本有区别，请自行查阅 man page)</span></span><br><span class=\"line\">* <span class=\"built_in\">set</span> -g mouse on</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\"># 设置默认终端模式为 256color</span></span><br><span class=\"line\"><span class=\"built_in\">set</span> -g default-terminal <span class=\"string\">&quot;screen-256color&quot;</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\"># 启用活动警告</span></span><br><span class=\"line\">setw -g monitor-activity on</span><br><span class=\"line\"><span class=\"built_in\">set</span> -g visual-activity on</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\"># 居中窗口列表</span></span><br><span class=\"line\"><span class=\"built_in\">set</span> -g status-justify centre</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\"># 最大化/恢复窗格</span></span><br><span class=\"line\">unbind Up <span class=\"built_in\">bind</span> Up new-window -d -n tmp \\; swap-pane -s tmp.1 \\; select-window -t tmp</span><br><span class=\"line\">unbind Down</span><br><span class=\"line\"><span class=\"built_in\">bind</span> Down last-window \\; swap-pane -s tmp.1 \\; kill-window -t tmp</span><br></pre></td></tr></table></figure>\n\n<h2 id=\"参考配置文件（-tmux-conf）：\"><a href=\"#参考配置文件（-tmux-conf）：\" class=\"headerlink\" title=\"参考配置文件（~&#x2F;.tmux.conf）：\"></a><strong>参考配置文件（~&#x2F;.tmux.conf）：</strong></h2><figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\"># -----------------------------------------------------------------------------# Tmux 基本配置 - 要求 Tmux &gt;= 2.3# 如果不想使用插件，只需要将此节的内容写入 ~/.tmux.conf 即可# -----------------------------------------------------------------------------# C-b 和 VIM 冲突，修改 Prefix 组合键为 Control-Z，按键距离近set -g prefix C-z</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"built_in\">set</span> -g base-index         1     <span class=\"comment\"># 窗口编号从 1 开始计数</span></span><br><span class=\"line\"><span class=\"built_in\">set</span> -g display-panes-time 10000 <span class=\"comment\"># PREFIX-Q 显示编号的驻留时长，单位 msset -g mouse              on    # 开启鼠标</span></span><br><span class=\"line\"><span class=\"built_in\">set</span> -g pane-base-index    1     <span class=\"comment\"># 窗格编号从 1 开始计数</span></span><br><span class=\"line\"><span class=\"built_in\">set</span> -g renumber-windows   on    <span class=\"comment\"># 关掉某个窗口后，编号重排</span></span><br><span class=\"line\"></span><br><span class=\"line\">setw -g allow-rename      off   <span class=\"comment\"># 禁止活动进程修改窗口名</span></span><br><span class=\"line\">setw -g automatic-rename  off   <span class=\"comment\"># 禁止自动命名新窗口</span></span><br><span class=\"line\">setw -g mode-keys         vi    <span class=\"comment\"># 进入复制模式的时候使用 vi 键位（默认是 EMACS）# -----------------------------------------------------------------------------# 使用插件 - via tpm#   1. 执行 git clone https://github.com/tmux-plugins/tpm ~/.tmux/plugins/tpm#   2. 执行 bash ~/.tmux/plugins/tpm/bin/install_plugins# -----------------------------------------------------------------------------</span></span><br><span class=\"line\"></span><br><span class=\"line\">setenv -g TMUX_PLUGIN_MANAGER_PATH <span class=\"string\">&#x27;~/.tmux/plugins&#x27;</span># 推荐的插件（请去每个插件的仓库下读一读使用教程）</span><br><span class=\"line\"><span class=\"built_in\">set</span> -g @plugin <span class=\"string\">&#x27;seebi/tmux-colors-solarized&#x27;</span></span><br><span class=\"line\"><span class=\"built_in\">set</span> -g @plugin <span class=\"string\">&#x27;tmux-plugins/tmux-pain-control&#x27;</span></span><br><span class=\"line\"><span class=\"built_in\">set</span> -g @plugin <span class=\"string\">&#x27;tmux-plugins/tmux-prefix-highlight&#x27;</span></span><br><span class=\"line\"><span class=\"built_in\">set</span> -g @plugin <span class=\"string\">&#x27;tmux-plugins/tmux-resurrect&#x27;</span></span><br><span class=\"line\"><span class=\"built_in\">set</span> -g @plugin <span class=\"string\">&#x27;tmux-plugins/tmux-sensible&#x27;</span></span><br><span class=\"line\"><span class=\"built_in\">set</span> -g @plugin <span class=\"string\">&#x27;tmux-plugins/tmux-yank&#x27;</span></span><br><span class=\"line\"><span class=\"built_in\">set</span> -g @plugin <span class=\"string\">&#x27;tmux-plugins/tpm&#x27;</span># tmux-resurrectset -g @resurrect-dir <span class=\"string\">&#x27;~/.tmux/resurrect&#x27;</span># tmux-prefix-highlightset -g status-right <span class=\"string\">&#x27;#&#123;prefix_highlight&#125; #H | %a %Y-%m-%d %H:%M&#x27;</span></span><br><span class=\"line\"><span class=\"built_in\">set</span> -g @prefix_highlight_show_copy_mode <span class=\"string\">&#x27;on&#x27;</span></span><br><span class=\"line\"><span class=\"built_in\">set</span> -g @prefix_highlight_copy_mode_attr <span class=\"string\">&#x27;fg=white,bg=blue&#x27;</span># 初始化 TPM 插件管理器 (放在配置文件的最后)</span><br><span class=\"line\">run <span class=\"string\">&#x27;~/.tmux/plugins/tpm/tpm&#x27;</span># -----------------------------------------------------------------------------# 结束# -----------------------------------------------------------------------------</span><br></pre></td></tr></table></figure>\n","excerpt":"","more":"<blockquote>\n<p><a href=\"https://tmuxcheatsheet.com/\">Tmux Cheat Sheet &amp; Quick Reference | Session, window, pane and more</a></p>\n<p><a href=\"https://www.youtube.com/watch?v=nTqu6w2wc68&ab_channel=NetworkChuck\">https://www.youtube.com/watch?v=nTqu6w2wc68&ab_channel&#x3D;NetworkChuck</a>(教学视频)</p>\n<p><a href=\"https://louiszhai.github.io/2017/09/30/tmux/\">Tmux 使用手册</a></p>\n<p><a href=\"https://gist.github.com/ryerh/14b7c24dfd623ef8edc7\">Tmux 快捷键 &amp; 速查表 &amp; 简明教程</a></p>\n</blockquote>\n<p>启动新会话：</p>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">tmux [new -s 会话名 -n 窗口名]</span><br></pre></td></tr></table></figure>\n\n<p>恢复会话：</p>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">tmux at [-t 会话名]</span><br></pre></td></tr></table></figure>\n\n<p>列出所有会话：</p>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">tmux <span class=\"built_in\">ls</span></span><br></pre></td></tr></table></figure>\n\n<p>关闭会话：</p>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">tmux kill-session -t 会话名</span><br></pre></td></tr></table></figure>\n\n<p>关闭所有会话：</p>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">tmux <span class=\"built_in\">ls</span> | grep : | <span class=\"built_in\">cut</span> -d. -f1 | awk <span class=\"string\">&#x27;&#123;print substr($1, 0, length($1)-1)&#125;&#x27;</span> | xargs <span class=\"built_in\">kill</span></span><br></pre></td></tr></table></figure>\n\n<h1 id=\"在-Tmux-中，按下-Tmux-前缀-ctrl-b-，然后：\"><a href=\"#在-Tmux-中，按下-Tmux-前缀-ctrl-b-，然后：\" class=\"headerlink\" title=\"在 Tmux 中，按下 Tmux 前缀 ctrl+b****，然后：\"></a><strong>在 Tmux 中，按下 Tmux 前缀</strong> <strong>ctrl+b****，然后：</strong></h1><h2 id=\"会话\"><a href=\"#会话\" class=\"headerlink\" title=\"会话\"></a><strong>会话</strong></h2><figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">:new&lt;回车&gt;  启动新会话</span><br><span class=\"line\">s           列出所有会话</span><br><span class=\"line\">$           重命名当前会话</span><br></pre></td></tr></table></figure>\n\n<h2 id=\"窗口-标签页\"><a href=\"#窗口-标签页\" class=\"headerlink\" title=\"窗口 (标签页)\"></a><strong>窗口 (标签页)</strong></h2><figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">c  创建新窗口</span><br><span class=\"line\">w  列出所有窗口</span><br><span class=\"line\">n  后一个窗口</span><br><span class=\"line\">p  前一个窗口</span><br><span class=\"line\">f  查找窗口</span><br><span class=\"line\">,  重命名当前窗口</span><br><span class=\"line\">&amp;  关闭当前窗口</span><br></pre></td></tr></table></figure>\n\n<h2 id=\"调整窗口排序\"><a href=\"#调整窗口排序\" class=\"headerlink\" title=\"调整窗口排序\"></a><strong>调整窗口排序</strong></h2><figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">swap-window -s 3 -t 1  交换 3 号和 1 号窗口</span><br><span class=\"line\">swap-window -t 1       交换当前和 1 号窗口</span><br><span class=\"line\">move-window -t 1       移动当前窗口到 1 号</span><br></pre></td></tr></table></figure>\n\n<h2 id=\"窗格（分割窗口）\"><a href=\"#窗格（分割窗口）\" class=\"headerlink\" title=\"窗格（分割窗口）\"></a><strong>窗格（分割窗口）</strong></h2><figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">%  垂直分割</span><br><span class=\"line\"><span class=\"string\">&quot;  水平分割</span></span><br><span class=\"line\"><span class=\"string\">o  交换窗格</span></span><br><span class=\"line\"><span class=\"string\">x  关闭窗格</span></span><br><span class=\"line\"><span class=\"string\">⍽  左边这个符号代表空格键 - 切换布局</span></span><br><span class=\"line\"><span class=\"string\">q 显示每个窗格是第几个，当数字出现的时候按数字几就选中第几个窗格</span></span><br><span class=\"line\"><span class=\"string\">&#123; 与上一个窗格交换位置</span></span><br><span class=\"line\"><span class=\"string\">&#125; 与下一个窗格交换位置</span></span><br><span class=\"line\"><span class=\"string\">z 切换窗格最大化/最小化</span></span><br></pre></td></tr></table></figure>\n\n<h2 id=\"同步窗格\"><a href=\"#同步窗格\" class=\"headerlink\" title=\"同步窗格\"></a><strong>同步窗格</strong></h2><p>这么做可以切换到想要的窗口，输入 Tmux 前缀和一个冒号呼出命令提示行，然后输入：</p>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">:setw synchronize-panes</span><br></pre></td></tr></table></figure>\n\n<p>你可以指定开或关，否则重复执行命令会在两者间切换。 这个选项值针对某个窗口有效，不会影响别的会话和窗口。 完事儿之后再次执行命令来关闭。<u>帮助</u></p>\n<h2 id=\"调整窗格尺寸\"><a href=\"#调整窗格尺寸\" class=\"headerlink\" title=\"调整窗格尺寸\"></a><strong>调整窗格尺寸</strong></h2><p>如果你不喜欢默认布局，可以重调窗格的尺寸。虽然这很容易实现，但一般不需要这么干。这几个命令用来调整窗格：</p>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">PREFIX : resize-pane -D          当前窗格向下扩大 1 格</span><br><span class=\"line\">PREFIX : resize-pane -U          当前窗格向上扩大 1 格</span><br><span class=\"line\">PREFIX : resize-pane -L          当前窗格向左扩大 1 格</span><br><span class=\"line\">PREFIX : resize-pane -R          当前窗格向右扩大 1 格</span><br><span class=\"line\">PREFIX : resize-pane -D 20       当前窗格向下扩大 20 格</span><br><span class=\"line\">PREFIX : resize-pane -t 2 -L 20  编号为 2 的窗格向左扩大 20 格</span><br></pre></td></tr></table></figure>\n\n<h2 id=\"文本复制模式：\"><a href=\"#文本复制模式：\" class=\"headerlink\" title=\"文本复制模式：\"></a><strong>文本复制模式：</strong></h2><p>按下 <code>PREFIX-[</code> 进入文本复制模式。可以使用方向键在屏幕中移动光标。默认情况下，方向键是启用的。在配置文件中启用 Vim 键盘布局来切换窗口、调整窗格大小。Tmux 也支持 Vi 模式。要是想启用 Vi 模式，只需要把下面这一行添加到 .tmux.conf 中：</p>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">setw -g mode-keys vi</span><br></pre></td></tr></table></figure>\n\n<p>启用这条配置后，就可以使用 h、j、k、l 来移动光标了。</p>\n<p>想要退出文本复制模式的话，按下回车键就可以了。然后按下 <code>PREFIX-]</code> 粘贴刚才复制的文本。</p>\n<p>一次移动一格效率低下，在 Vi 模式启用的情况下，可以辅助一些别的快捷键高效工作。</p>\n<p>例如，可以使用 w 键逐词移动，使用 b 键逐词回退。使用 f 键加上任意字符跳转到当前行第一次出现该字符的位置，使用 F 键达到相反的效果。</p>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">vi             emacs        功能</span><br><span class=\"line\">^              M-m          反缩进</span><br><span class=\"line\">Escape         C-g          清除选定内容</span><br><span class=\"line\">Enter          M-w          复制选定内容</span><br><span class=\"line\">j              Down         光标下移</span><br><span class=\"line\">h              Left         光标左移</span><br><span class=\"line\">l              Right        光标右移</span><br><span class=\"line\">L                           光标移到尾行</span><br><span class=\"line\">M              M-r          光标移到中间行</span><br><span class=\"line\">H              M-R          光标移到首行</span><br><span class=\"line\">k              Up           光标上移</span><br><span class=\"line\">d              C-u          删除整行</span><br><span class=\"line\">D              C-k          删除到行末</span><br><span class=\"line\">$              C-e          移到行尾</span><br><span class=\"line\">:              g            前往指定行</span><br><span class=\"line\">C-d            M-Down       向下滚动半屏</span><br><span class=\"line\">C-u            M-Up         向上滚动半屏</span><br><span class=\"line\">C-f            Page down    下一页</span><br><span class=\"line\">w              M-f          下一个词</span><br><span class=\"line\">p              C-y          粘贴</span><br><span class=\"line\">C-b            Page up      上一页</span><br><span class=\"line\">b              M-b          上一个词</span><br><span class=\"line\">q              Escape       退出</span><br><span class=\"line\">C-Down or J    C-Down       向下翻</span><br><span class=\"line\">C-Up or K      C-Up         向下翻</span><br><span class=\"line\">n              n            继续搜索</span><br><span class=\"line\">?              C-r          向前搜索</span><br><span class=\"line\">/              C-s          向后搜索</span><br><span class=\"line\">0              C-a          移到行首</span><br><span class=\"line\">Space          C-Space      开始选中</span><br><span class=\"line\">               C-t          字符调序</span><br></pre></td></tr></table></figure>\n\n<h2 id=\"杂项：\"><a href=\"#杂项：\" class=\"headerlink\" title=\"杂项：\"></a><strong>杂项：</strong></h2><figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">d  退出 tmux（tmux 仍在后台运行）</span><br><span class=\"line\">t  窗口中央显示一个数字时钟</span><br><span class=\"line\">?  列出所有快捷键</span><br><span class=\"line\">:  命令提示符</span><br></pre></td></tr></table></figure>\n\n<h2 id=\"配置选项：\"><a href=\"#配置选项：\" class=\"headerlink\" title=\"配置选项：\"></a><strong>配置选项：</strong></h2><figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\"># 鼠标支持 - 设置为 on 来启用鼠标(与 2.1 之前的版本有区别，请自行查阅 man page)</span></span><br><span class=\"line\">* <span class=\"built_in\">set</span> -g mouse on</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\"># 设置默认终端模式为 256color</span></span><br><span class=\"line\"><span class=\"built_in\">set</span> -g default-terminal <span class=\"string\">&quot;screen-256color&quot;</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\"># 启用活动警告</span></span><br><span class=\"line\">setw -g monitor-activity on</span><br><span class=\"line\"><span class=\"built_in\">set</span> -g visual-activity on</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\"># 居中窗口列表</span></span><br><span class=\"line\"><span class=\"built_in\">set</span> -g status-justify centre</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\"># 最大化/恢复窗格</span></span><br><span class=\"line\">unbind Up <span class=\"built_in\">bind</span> Up new-window -d -n tmp \\; swap-pane -s tmp.1 \\; select-window -t tmp</span><br><span class=\"line\">unbind Down</span><br><span class=\"line\"><span class=\"built_in\">bind</span> Down last-window \\; swap-pane -s tmp.1 \\; kill-window -t tmp</span><br></pre></td></tr></table></figure>\n\n<h2 id=\"参考配置文件（-tmux-conf）：\"><a href=\"#参考配置文件（-tmux-conf）：\" class=\"headerlink\" title=\"参考配置文件（~&#x2F;.tmux.conf）：\"></a><strong>参考配置文件（~&#x2F;.tmux.conf）：</strong></h2><figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\"># -----------------------------------------------------------------------------# Tmux 基本配置 - 要求 Tmux &gt;= 2.3# 如果不想使用插件，只需要将此节的内容写入 ~/.tmux.conf 即可# -----------------------------------------------------------------------------# C-b 和 VIM 冲突，修改 Prefix 组合键为 Control-Z，按键距离近set -g prefix C-z</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"built_in\">set</span> -g base-index         1     <span class=\"comment\"># 窗口编号从 1 开始计数</span></span><br><span class=\"line\"><span class=\"built_in\">set</span> -g display-panes-time 10000 <span class=\"comment\"># PREFIX-Q 显示编号的驻留时长，单位 msset -g mouse              on    # 开启鼠标</span></span><br><span class=\"line\"><span class=\"built_in\">set</span> -g pane-base-index    1     <span class=\"comment\"># 窗格编号从 1 开始计数</span></span><br><span class=\"line\"><span class=\"built_in\">set</span> -g renumber-windows   on    <span class=\"comment\"># 关掉某个窗口后，编号重排</span></span><br><span class=\"line\"></span><br><span class=\"line\">setw -g allow-rename      off   <span class=\"comment\"># 禁止活动进程修改窗口名</span></span><br><span class=\"line\">setw -g automatic-rename  off   <span class=\"comment\"># 禁止自动命名新窗口</span></span><br><span class=\"line\">setw -g mode-keys         vi    <span class=\"comment\"># 进入复制模式的时候使用 vi 键位（默认是 EMACS）# -----------------------------------------------------------------------------# 使用插件 - via tpm#   1. 执行 git clone https://github.com/tmux-plugins/tpm ~/.tmux/plugins/tpm#   2. 执行 bash ~/.tmux/plugins/tpm/bin/install_plugins# -----------------------------------------------------------------------------</span></span><br><span class=\"line\"></span><br><span class=\"line\">setenv -g TMUX_PLUGIN_MANAGER_PATH <span class=\"string\">&#x27;~/.tmux/plugins&#x27;</span># 推荐的插件（请去每个插件的仓库下读一读使用教程）</span><br><span class=\"line\"><span class=\"built_in\">set</span> -g @plugin <span class=\"string\">&#x27;seebi/tmux-colors-solarized&#x27;</span></span><br><span class=\"line\"><span class=\"built_in\">set</span> -g @plugin <span class=\"string\">&#x27;tmux-plugins/tmux-pain-control&#x27;</span></span><br><span class=\"line\"><span class=\"built_in\">set</span> -g @plugin <span class=\"string\">&#x27;tmux-plugins/tmux-prefix-highlight&#x27;</span></span><br><span class=\"line\"><span class=\"built_in\">set</span> -g @plugin <span class=\"string\">&#x27;tmux-plugins/tmux-resurrect&#x27;</span></span><br><span class=\"line\"><span class=\"built_in\">set</span> -g @plugin <span class=\"string\">&#x27;tmux-plugins/tmux-sensible&#x27;</span></span><br><span class=\"line\"><span class=\"built_in\">set</span> -g @plugin <span class=\"string\">&#x27;tmux-plugins/tmux-yank&#x27;</span></span><br><span class=\"line\"><span class=\"built_in\">set</span> -g @plugin <span class=\"string\">&#x27;tmux-plugins/tpm&#x27;</span># tmux-resurrectset -g @resurrect-dir <span class=\"string\">&#x27;~/.tmux/resurrect&#x27;</span># tmux-prefix-highlightset -g status-right <span class=\"string\">&#x27;#&#123;prefix_highlight&#125; #H | %a %Y-%m-%d %H:%M&#x27;</span></span><br><span class=\"line\"><span class=\"built_in\">set</span> -g @prefix_highlight_show_copy_mode <span class=\"string\">&#x27;on&#x27;</span></span><br><span class=\"line\"><span class=\"built_in\">set</span> -g @prefix_highlight_copy_mode_attr <span class=\"string\">&#x27;fg=white,bg=blue&#x27;</span># 初始化 TPM 插件管理器 (放在配置文件的最后)</span><br><span class=\"line\">run <span class=\"string\">&#x27;~/.tmux/plugins/tpm/tpm&#x27;</span># -----------------------------------------------------------------------------# 结束# -----------------------------------------------------------------------------</span><br></pre></td></tr></table></figure>\n"},{"title":"2025-04-15-二进制思想在计算机科学中的应用","date":"2025-04-14T16:00:00.000Z","_content":"# 1.1.二进制思想在计算机科学中的应用\n\n> 飞书文档链接\n> [1.1.二进制思想在计算机科学中的应用](https://xcnx25vdviba.feishu.cn/wiki/F8itwjr9MiktqGkjJk1cVkTSnlg?from=from_copylink)\n\n# 参考资料\n\n> - [二进制、八进制、十进制、十六进制使用场景_八进制应用在什么地方-CSDN 博客](https://blog.csdn.net/u010674101/article/details/142599519?spm=1001.2101.3001.6650.3&utm_medium=distribute.pc_relevant.none-task-blog-2%7Edefault%7EBlogCommendFromBaidu%7ERate-3-142599519-blog-131889184.235%5Ev43%5Epc_blog_bottom_relevance_base8&depth_1-utm_source=distribute.pc_relevant.none-task-blog-2%7Edefault%7EBlogCommendFromBaidu%7ERate-3-142599519-blog-131889184.235%5Ev43%5Epc_blog_bottom_relevance_base8&utm_relevant_index=6)\n> - [计算机中不同进制的使用说明_计算机不同进制数怎么使用-CSDN 博客](https://blog.csdn.net/xuehuadalao/article/details/107611093?spm=1001.2101.3001.6650.4&utm_medium=distribute.pc_relevant.none-task-blog-2%7Edefault%7EBlogCommendFromBaidu%7ERate-4-107611093-blog-131889184.235%5Ev43%5Epc_blog_bottom_relevance_base8&depth_1-utm_source=distribute.pc_relevant.none-task-blog-2%7Edefault%7EBlogCommendFromBaidu%7ERate-4-107611093-blog-131889184.235%5Ev43%5Epc_blog_bottom_relevance_base8&utm_relevant_index=9)\n> - [现代计算机爱上二进制----为什么要用二进制 - 活着的虫子 - 博客园](https://www.cnblogs.com/yilang/p/11067886.html)\n\n二进制是一种基数为 2 的数制，只使用两个数字——0 和 1。这两个数字被称为比特(bit)，是计算机中最小的数据单位。二进制是计算机科学的基础，用于表示所有数据类型。例如，文本通过 ASCII 编码转为二进制，图像和声音也以二进制存储。逻辑电路依赖二进制逻辑门（如 AND、OR、NOT）执行计算，处理器通过二进制指令执行操作。此外，二进制在数字通信、加密技术和错误检测中也至关重要。这些应用确保了现代计算系统的功能。\n\n## 二进制在计算机科学中的应用\n\n### 密码学与数据校验\n\n密码学的所有技术实现均基于二进制运算，二进制是计算机处理数据的基础单位，密码学通过二进制操作实现数据的加密、哈希、签名等核心功能。\n\n- 数据存储与传输所有明文、密文、密钥、哈希值等均以二进制形式存储和传输（如 ASCII 文本需先转为二进制再加密）。\n- 位操作（Bitwise Operations）密码算法依赖二进制位运算（如异或 XOR、移位、置换）实现加密混淆。\n\n> 示例：AES 加密中的“字节替换（SubBytes）”步骤，本质是二进制字节通过 S 盒（查找表）进行非线性变换。\n\n---\n\n#### 非对称加密的二进制数学基础\n\n- 大整数运算\n\n  - RSA、ECC 等算法依赖超大二进制整数的运算（如模幂运算、椭圆曲线点运算）。\n\n  > 示例：RSA 加密中，公钥加密过程本质是计算 $C = M^e \\mod n$，其中 $ M, e, n $ 均为二进制大整数。\n  >\n- 二进制优化\n\n  - 快速幂模运算通过二进制分解指数（如 $e = 2^k + 2^{k-1} + ... $）加速计算。\n    假设指数$e$是一个正整数，它可以表示为二进制形式。例如，假设 $e = 13$，其二进制表示为 $1101_2$。这意味着：\n\n  $$\n  e = 1 \\times 2^3 + 1 \\times 2^2 + 0 \\times 2^1 + 1 \\times 2^0\n  $$\n\n  因此，可以将$e$写成：\n\n  $$\n  e = 2^3 + 2^2 + 2^0\n  $$\n\n  然后分别计算 $2^3$、$2^2$以及 $2^0\n  $ 与求和即可\n\n---\n\n#### 密钥与随机数的二进制本质\n\n- 密钥生成\n\n  - 对称密钥（如 AES-256 的 256 位密钥）、非对称私钥（如 ECC 的 256 位随机数）均为二进制序列。\n  - 密钥安全性依赖二进制随机数的不可预测性（如量子随机数生成器）。\n- 密钥存储\n\n  - 密钥需以二进制形式安全存储（如硬件加密模块 HSM）。\n\n---\n\n#### 密码协议中的二进制交互\n\n- 网络协议\n\n  - HTTPS、SSH 等协议中，所有握手、加密、签名过程均通过二进制数据包实现。示例：TLS 协议中，客户端与服务端交换随机数（二进制串）生成会话密钥。\n- 编码与解码\n\n  - 加密后的二进制数据需通过 Base64、Hex 等编码转为可传输文本格式。\n\n---\n\n### 权限控制\n\n> - [基于二进制的权限管理与验证 - 勤奋的菜鸟 - 博客园](https://www.cnblogs.com/qfcndtt/archive/2012/08/03/2621713.html)\n> - [权限控制 | 使用二进制做权限控制功能](https://www.zhihu.com/column/p/30103832)\n\n#### 使用位运算的权限控制(bitmask)\n\n##### **Linux 权限的二进制表示**\n\nLinux 中每个文件/目录的权限分为 **所有者（User）、所属组（Group）、其他用户（Others）** 三个角色，每个角色对应 **读（r）、写（w）、执行（x）** 三种权限，分别用 **3 位二进制** 表示：\n\n```bash\nrwx r-x r-- → 二进制：111 101 100 → 八进制：754\n   ↑   ↑   ↑\n  用户 组  其他\n```\n\n• 每个权限位映射：\n\n• `r`（读）：二进制第 2 位（值 4）\n\n• `w`（写）：二进制第 1 位（值 2）\n\n• `x`（执行）：二进制第 0 位（值 1）\n\n• 权限组合：通过二进制位或运算（`|`）实现，例如：\n\n```\nrw- = 4（r） + 2（w） = 6 → 二进制 110\nrwx = 4 + 2 + 1 = 7 → 二进制 111\n```\n\n---\n\n##### **权限操作的核心逻辑**\n\n**权限验证**\n\nLinux 内核通过 **按位与运算（&）** 判断用户是否拥有某权限。例如，检查用户是否有执行权限：\n\n```c\n// 检查 st_mode 是否包含用户执行权限位\nif (st_mode & S_IXUSR) { /* 允许执行 */ }\n```\n\n• 权限位宏定义：\n\n```c\n#define S_IRUSR 0400  // 用户读权限（二进制：100 000 000）\n#define S_IWUSR 0200  // 用户写权限（二进制：010 000 000）\n#define S_IXUSR 0100  // 用户执行权限（二进制：001 000 000）\n```\n\n##### **权限修改**\n\n通过 **按位或（|）赋予权限** 和 **按位与非（& ~）移除权限** 实现动态调整：\n\n```bash\n// 添加用户写权限\nst_mode |= S_IWUSR;\n\n// 移除用户执行权限\nst_mode &= ~S_IXUSR;\n```\n\n---\n\n##### **用户视角的权限管理**\n\n- **chmod**** 命令的底层实现**\n\n• 符号模式：直接操作权限位\n\n```bash\nchmod u+x file    # 添加用户执行权限（位或运算）\nchmod g-w file    # 移除组写权限（位与非运算）\n```\n\n• 八进制模式：直接指定二进制掩码\n\n```bash\nchmod 755 file    # rwxr-xr-x → 二进制 111 101 101 → 八进制 755\n```\n\n- **权限继承与默认值**\n\n• umask 值：通过二进制掩码定义默认权限的补码\n\n```bash\numask 022         # 默认创建文件权限为 644（777 & ~022 = 755）\n```\n\n---\n\n##### **扩展应用：特殊权限位**\n\nLinux 还扩展了 **SUID、SGID、Sticky Bit** 等权限，仍基于二进制位掩码设计：\n\n• SUID（Set User ID）：二进制第 11 位（八进制 4000）\n\n```bash\nchmod u+s /usr/bin/passwd  # 设置SUID，允许普通用户以root权限修改密码\n```\n\n• Sticky Bit：二进制第 9 位（八进制 1000）\n\n```bash\nchmod +t /tmp              # 仅文件所有者可删除自己的文件\n```\n\n---\n\n1. **权限表示**：每个权限对应一个二进制位，组合成八进制数存储。\n2. **权限操作**：通过位运算（`|`、`&`、`~`）实现动态调整。\n3. **高效性**：位运算的原子性和低开销保障了权限验证的高效性。\n4. **可扩展性**：通过扩展位掩码（如 SUID）支持复杂权限需求。\n\n**这一设计充分体现了二进制在权限控制中的核心价值——简洁、高效、灵活。**\n\n##### 代码示例\n\n```\n#include <bits/stdc++.h>\n\nusing namespace std;\n\nconst int S_IXUSR = 0400;_ // 用户读权限（二进制：100 000 000）_\nconst int S_IWUSR = 0200;_ // 用户写权限（二进制：010 000 000）_\nconst int S_IXUSR = 0100;_ // 用户执行权限（二进制：001 000 000）_\n\nvoid check_permission(int st_mode)\n{\n_    // 检查 st_mode 是否包含用户执行权限位_\n    if (st_mode & S_IXUSR)\n    {\n_         /* 允许执行 */_\n    }\n}\n```\n\n#### 企业级框架的权限控制\n\n### 算法上的应用\n\n#### 原码反码补码\n\n在计算机中，带符号整数通常用 **补码** 表示，其转换流程为：\n\n1. 正数的补码 = 原码；\n2. 负数的补码 = （原码取反）+ 1。\n\n<table>\n<tr>\n<td>值<br/></td><td>原码（二进制）<br/></td><td>反码<br/></td><td>补码<br/></td></tr>\n<tr>\n<td>+5<br/></td><td>00000101<br/></td><td>—<br/></td><td>00000101<br/></td></tr>\n<tr>\n<td>–5<br/></td><td>10000101<br/></td><td>11111010<br/></td><td>11111011<br/></td></tr>\n</table>\n\n补码的好处是：加减运算都能统一为加法，省去了符号位处理的特殊逻辑，也天然支持异或、与或等位运算。\n\n#### 位运算\n\n- **取反（NOT）**：`~x` 将 x 的每一位二进制翻转。\n- **与（AND）**：`x & y`，常用于屏蔽某些位，比如 `x & 1` 可判断 x 的奇偶。\n- **或（OR）**：`x \\| y`，用于将某些位设为 1。\n- **异或（XOR）**：`x ^ y`，相同位结果为 0，不同位结果为 1。\n- **左移（<<）与右移（>>）**：将二进制整体左移或右移，等价于乘／除以 2 的幂。\n\n例如，下面函数高效判断一个整数是否是 2 的幂次方：\n\n```cpp\nbool isPowerOfTwo(int x) {\n    return x > 0 && (x & (x - 1)) == 0;\n}\n```\n\n```python\ndef is_power_of_two(x: int) -> bool:\n    return x > 0 and (x & (x - 1)) == 0\n```\n\n#### 快速幂\n\n> [快速幂 - OI Wiki](https://oi-wiki.org/math/binary-exponentiation/)\n\n> - 快速幂模运算通过二进制分解指数（如 $e = 2^k + 2^{k-1} + ... $）加速计算。\n>   假设指数$e$是一个正整数，它可以表示为二进制形式。例如，假设 $e = 13$，其二进制表示为 $1101_2$。这意味着：\n>\n> $$\n> e = 1 \\times 2^3 + 1 \\times 2^2 + 0 \\times 2^1 + 1 \\times 2^0\n> $$\n>\n> 因此，可以将$e$写成：\n>\n> $$\n> e = 2^3 + 2^2 + 2^0\n> $$\n>\n> 然后分别计算 $2^3$、$2^2$以及 $2^0\n> $ 与求和即可\n\n算法思想：\n\n1. 维护结果 `res=1`；\n2. 当最低位 $b_0=1$ 时，`res *= a`；\n3. 每次循环后，`a *= a`（平方），并将 $e$ 右移一位；\n4. 重复上述直到 $e=0$，最终 `res` 即为 $a^e$。\n\n```cpp\nlong long fast_pow(long long a, long long e) {\n    long long res = 1;\n    while (e > 0) {\n        if (e & 1)            // 若当前最低位为 1\n            res = res * a;\n        a = a * a;           // 平方\n        e >>= 1;             // 右移下一位\n    }\n    return res;\n}\n\nint main() {\n    std::cout << fast_pow(2, 13) << std::endl;  // 输出 8192\n    return 0;\n}\n```\n\n#### 异或运算\n\n- **交换变量**（无需临时变量）\n\n```cpp\na ^= b; b ^= a; a ^= b;\n```\n\n- **找出唯一出现一次的数**\n\n对于一个数组中只有一个元素出现一次，其余元素都出现两次，用异或可线性时间、常数空间找出它：\n\n```python\ndef single_number(nums):\n    ans = 0\n    for x in nums:\n        ans ^= x\n    return ans\n```\n\n- **按位翻转特定范围**\n\n将 `n` 的第 `i` 到 `j` 位全部翻转：\n\n```cpp\nint mask = ((1 << (j - i + 1)) - 1) << i;\nn ^= mask;\n```\n\n### 数据的表示、计算、存储和传输\n\n#### 数据压缩\n\n> - [https://colab.research.google.com/drive/1Mmi0GjoN2xCAIsyrTwYswP-FGUwMHEDQ?usp=sharing(colab](https://colab.research.google.com/drive/1Mmi0GjoN2xCAIsyrTwYswP-FGUwMHEDQ?usp=sharing(colab)) 链接)\n\n数据压缩可以分为有损压缩（Lossy）和无损压缩（Lossless）两类。\n\n- **无损压缩**在压缩和解压后能够完全恢复原始数据，常见算法有 DEFLATE（gzip、PNG）、LZMA（7z）等。\n\n1. **gzip（无损）示例**：\n\n```python\nimport gzip\n\ntext = b\"Data compression example. \" * 100\n# 压缩\ncompressed = gzip.compress(text)\nprint(\"原始大小：\", len(text), \"压缩后大小：\", len(compressed))\n# 解压\ndecompressed = gzip.decompress(compressed)\nassert decompressed == text\n```\n\n![1749358101852VcESbqoZboQwALx8jarc7TRmnme.png](https://gitee.com/tanke11223344/imagehost/raw/main/blog/1749358101852VcESbqoZboQwALx8jarc7TRmnme.png)\n\n以上示例使用 DEFLATE 算法，无损地将文本压缩并恢复\n\n- **有损压缩**则在压缩过程中丢弃“人眼/人耳不易察觉”的冗余信息，如 JPEG 图像、MP3 音频，其解压后无法恢复到完全原始状态。\n\n```python\nfrom PIL import Image\nimg = Image.open(\"input.png\")\nimg.save(\"output.jpg\", quality=50)  # quality<100 会丢失部分细节\n```\n\n![1749357984852CVRfb86YNohpkSxhCM9cQd6bnOd.png](https://gitee.com/tanke11223344/imagehost/raw/main/blog/1749357984852CVRfb86YNohpkSxhCM9cQd6bnOd.png)\n\n```bash\n# 对比文件体积\nls -lh input.jpg output.jpg\n```\n\n![1749358112853YAcabWie6oudnmxod0bcfX4PntU.png](https://gitee.com/tanke11223344/imagehost/raw/main/blog/1749358112853YAcabWie6oudnmxod0bcfX4PntU.png)\n\n通过调整 `quality` 参数，JPEG 有损压缩可在保留较好视觉效果的同时大幅减小文件体积。\n\n#### OneHot 编码\n\n> [https://colab.research.google.com/drive/1VpmC-vKrvaFusdNNuaavzvAk2YMhGWrW?usp=sharing(colab](https://colab.research.google.com/drive/1VpmC-vKrvaFusdNNuaavzvAk2YMhGWrW?usp=sharing(colab)) 链接)\n\nOne-Hot 编码是一种将分类变量转换为稀疏二进制向量的技术，每个类别对应一个维度，只有所属类别位置为 1，其它位置为 0。\n\n##### **Pandas 实现示例**：\n\n```python\nimport pandas as pd\ndf = pd.DataFrame({\"color\": [\"red\", \"blue\", \"green\", \"blue\"]})\none_hot = pd.get_dummies(df[\"color\"], prefix=\"color\")\nprint(one_hot)\n```\n\n```\ncolor_blue  color_green  color_red\n0       False        False       True\n1        True        False      False\n2       False         True      False\n3        True        False      False\n```\n\n此方法对小规模类别集非常高效，并集成于 Pandas。\n\n#### **Scikit-Learn 实现示例**：\n\n```python\nfrom sklearn.preprocessing import OneHotEncoder\nenc = OneHotEncoder(sparse=False)\nX = enc.fit_transform(df[[\"color\"]])\nprint(X)\n```\n\n```\n[[0. 0. 1.]\n [1. 0. 0.]\n [0. 1. 0.]\n [1. 0. 0.]]\n```\n\n`OneHotEncoder` 支持 `handle_unknown` 参数，用于处理训练外出现的新类别。\n\n---\n\n#### 深度学习中数据与模型的二进制存储方法\n\n深度学习框架通常使用专门的二进制格式保存模型参数和网络结构，以提高读写性能并节省存储空间。\n\n- **PyTorch**：使用 Python 序列化（Pickle）将模型权重保存在 `.pt` 或 `.pth` 文件，通常调用 `torch.save(model.state_dict(), 'model.pth')` 和 `model.load_state_dict(torch.load('model.pth'))`。\n- **TensorFlow**：采用 SavedModel 格式，目录中包含 `saved_model.pb`（Protobuf 二进制）与 `variables` 检查点文件，使用 `model.save('path')` 和 `tf.keras.models.load_model('path')` 进行读写。\n- **安全张量（safetensors）**：新兴格式，提供比 Pickle 更强的安全性与加载性能，示例：\n\n```python\nimport safetensors.torch as st\nst.save_file(model.state_dict(), \"model.safetensors\")\n```\n\n此外，ONNX（Open Neural Network Exchange）以 Protobuf 二进制保存跨框架模型结构与权重，易于在不同平台间互操作。\n\n#### CSS 等设计方面的颜色编码\n\n在前端设计中，颜色可通过多种编码表示，最常见的是 十六进制（Hex）、RGB(A) 与 **HSL(A)** 格式。\n\n- **Hex**：`#RRGGBB` 或简写 `#RGB`，例如 `#ff00aa`。\n- **RGB**：`rgb(255,0,170)`，可加透明度：`rgba(255,0,170,0.5)`。\n- **HSL**：`hsl(320,100%,50%)`，直观调节色相、饱和度、亮度。\n\n**CSS 示例**：\n\n```css\n.button {\n  background: #3498db;           /* Hex */\n  color: rgb(255, 255, 255);     /* RGB */\n  border-color: hsl(200, 70%, 50%); /* HSL */\n}\n```\n\n**JavaScript 转换示例**：\n\n```javascript\n// Hex to RGB\nfunction hexToRgb(hex) {\n  let m = hex.match(/^#?([A-F\\d]{2})([A-F\\d]{2})([A-F\\d]{2})$/i);\n  if (!m) return null;\n  return {\n    r: parseInt(m[1], 16),\n    g: parseInt(m[2], 16),\n    b: parseInt(m[3], 16)\n  };\n}\nconsole.log(hexToRgb(\"#ff00aa\")); // {r:255, g:0, b:170}\n```\n\n#### 计算机网络 ip 地址\n\n> [计算机网络（一）基本概念（IP,子网掩码,默认网关,DNS）](https://zhuanlan.zhihu.com/p/50091071)\n> [【计算机网络】IP 协议、IP 地址、网段划分、子网划分、子网掩码、CIDR_ip cidr-CSDN 博客](https://blog.csdn.net/m0_45406092/article/details/118526894)\n> [IP 地址、子网掩码、网关、DNS 之间的关系](https://zhuanlan.zhihu.com/p/537410069)\n\n![1749358083853UllubbF2foHWwFxXFVOcMncxnLh.png](https://gitee.com/tanke11223344/imagehost/raw/main/blog/1749358083853UllubbF2foHWwFxXFVOcMncxnLh.png)\n![1749358068852MhlQbzAfxoR7YQxGKqYcRIvEnQb.png](https://gitee.com/tanke11223344/imagehost/raw/main/blog/1749358068852MhlQbzAfxoR7YQxGKqYcRIvEnQb.png)\n\nIP 地址、子网掩码、默认网关与 DNS 协同完成局域网与互联网互联：\n\n- **IP 地址**：标识主机在子网中的唯一地址，如 `192.168.1.10/24`。\n- **子网掩码**：如 `255.255.255.0`（/24），用于划分网络号与主机号。\n- **默认网关**：同子网内路由器接口地址，负责跨网段转发，如 `192.168.1.1`。\n- **DNS**：域名解析服务器，将域名映射至 IP（如 `8.8.8.8`）。\n\n1. **ipaddress 计算示例**：\n\n> - [https://colab.research.google.com/drive/1rXH5_RbucvYiemz9kz4mfqlx1Uz3DWA2?usp=sharing(colab](https://colab.research.google.com/drive/1rXH5_RbucvYiemz9kz4mfqlx1Uz3DWA2?usp=sharing(colab)) 链接)\n\n```python\nimport ipaddress\n\nnet = ipaddress.ip_network(\"192.168.1.10/24\", strict=False)\nprint(\"网络地址:\", net.network_address)\nprint(\"广播地址:\", net.broadcast_address)\nprint(\"可用主机:\", list(net.hosts())[:3], \"…共\", net.num_addresses - 2)\n```\n\n![1749358051852DGQZbu2FIoQK8txaq98c7aD8nCe.png](https://gitee.com/tanke11223344/imagehost/raw/main/blog/1749358051852DGQZbu2FIoQK8txaq98c7aD8nCe.png)\n","source":"_posts/2025-04-15-二进制思想在计算机科学中的应用.md","raw":"---\ntitle:  2025-04-15-二进制思想在计算机科学中的应用\ndate: 2025-04-15\ntags: \n    课程学习\n---\n# 1.1.二进制思想在计算机科学中的应用\n\n> 飞书文档链接\n> [1.1.二进制思想在计算机科学中的应用](https://xcnx25vdviba.feishu.cn/wiki/F8itwjr9MiktqGkjJk1cVkTSnlg?from=from_copylink)\n\n# 参考资料\n\n> - [二进制、八进制、十进制、十六进制使用场景_八进制应用在什么地方-CSDN 博客](https://blog.csdn.net/u010674101/article/details/142599519?spm=1001.2101.3001.6650.3&utm_medium=distribute.pc_relevant.none-task-blog-2%7Edefault%7EBlogCommendFromBaidu%7ERate-3-142599519-blog-131889184.235%5Ev43%5Epc_blog_bottom_relevance_base8&depth_1-utm_source=distribute.pc_relevant.none-task-blog-2%7Edefault%7EBlogCommendFromBaidu%7ERate-3-142599519-blog-131889184.235%5Ev43%5Epc_blog_bottom_relevance_base8&utm_relevant_index=6)\n> - [计算机中不同进制的使用说明_计算机不同进制数怎么使用-CSDN 博客](https://blog.csdn.net/xuehuadalao/article/details/107611093?spm=1001.2101.3001.6650.4&utm_medium=distribute.pc_relevant.none-task-blog-2%7Edefault%7EBlogCommendFromBaidu%7ERate-4-107611093-blog-131889184.235%5Ev43%5Epc_blog_bottom_relevance_base8&depth_1-utm_source=distribute.pc_relevant.none-task-blog-2%7Edefault%7EBlogCommendFromBaidu%7ERate-4-107611093-blog-131889184.235%5Ev43%5Epc_blog_bottom_relevance_base8&utm_relevant_index=9)\n> - [现代计算机爱上二进制----为什么要用二进制 - 活着的虫子 - 博客园](https://www.cnblogs.com/yilang/p/11067886.html)\n\n二进制是一种基数为 2 的数制，只使用两个数字——0 和 1。这两个数字被称为比特(bit)，是计算机中最小的数据单位。二进制是计算机科学的基础，用于表示所有数据类型。例如，文本通过 ASCII 编码转为二进制，图像和声音也以二进制存储。逻辑电路依赖二进制逻辑门（如 AND、OR、NOT）执行计算，处理器通过二进制指令执行操作。此外，二进制在数字通信、加密技术和错误检测中也至关重要。这些应用确保了现代计算系统的功能。\n\n## 二进制在计算机科学中的应用\n\n### 密码学与数据校验\n\n密码学的所有技术实现均基于二进制运算，二进制是计算机处理数据的基础单位，密码学通过二进制操作实现数据的加密、哈希、签名等核心功能。\n\n- 数据存储与传输所有明文、密文、密钥、哈希值等均以二进制形式存储和传输（如 ASCII 文本需先转为二进制再加密）。\n- 位操作（Bitwise Operations）密码算法依赖二进制位运算（如异或 XOR、移位、置换）实现加密混淆。\n\n> 示例：AES 加密中的“字节替换（SubBytes）”步骤，本质是二进制字节通过 S 盒（查找表）进行非线性变换。\n\n---\n\n#### 非对称加密的二进制数学基础\n\n- 大整数运算\n\n  - RSA、ECC 等算法依赖超大二进制整数的运算（如模幂运算、椭圆曲线点运算）。\n\n  > 示例：RSA 加密中，公钥加密过程本质是计算 $C = M^e \\mod n$，其中 $ M, e, n $ 均为二进制大整数。\n  >\n- 二进制优化\n\n  - 快速幂模运算通过二进制分解指数（如 $e = 2^k + 2^{k-1} + ... $）加速计算。\n    假设指数$e$是一个正整数，它可以表示为二进制形式。例如，假设 $e = 13$，其二进制表示为 $1101_2$。这意味着：\n\n  $$\n  e = 1 \\times 2^3 + 1 \\times 2^2 + 0 \\times 2^1 + 1 \\times 2^0\n  $$\n\n  因此，可以将$e$写成：\n\n  $$\n  e = 2^3 + 2^2 + 2^0\n  $$\n\n  然后分别计算 $2^3$、$2^2$以及 $2^0\n  $ 与求和即可\n\n---\n\n#### 密钥与随机数的二进制本质\n\n- 密钥生成\n\n  - 对称密钥（如 AES-256 的 256 位密钥）、非对称私钥（如 ECC 的 256 位随机数）均为二进制序列。\n  - 密钥安全性依赖二进制随机数的不可预测性（如量子随机数生成器）。\n- 密钥存储\n\n  - 密钥需以二进制形式安全存储（如硬件加密模块 HSM）。\n\n---\n\n#### 密码协议中的二进制交互\n\n- 网络协议\n\n  - HTTPS、SSH 等协议中，所有握手、加密、签名过程均通过二进制数据包实现。示例：TLS 协议中，客户端与服务端交换随机数（二进制串）生成会话密钥。\n- 编码与解码\n\n  - 加密后的二进制数据需通过 Base64、Hex 等编码转为可传输文本格式。\n\n---\n\n### 权限控制\n\n> - [基于二进制的权限管理与验证 - 勤奋的菜鸟 - 博客园](https://www.cnblogs.com/qfcndtt/archive/2012/08/03/2621713.html)\n> - [权限控制 | 使用二进制做权限控制功能](https://www.zhihu.com/column/p/30103832)\n\n#### 使用位运算的权限控制(bitmask)\n\n##### **Linux 权限的二进制表示**\n\nLinux 中每个文件/目录的权限分为 **所有者（User）、所属组（Group）、其他用户（Others）** 三个角色，每个角色对应 **读（r）、写（w）、执行（x）** 三种权限，分别用 **3 位二进制** 表示：\n\n```bash\nrwx r-x r-- → 二进制：111 101 100 → 八进制：754\n   ↑   ↑   ↑\n  用户 组  其他\n```\n\n• 每个权限位映射：\n\n• `r`（读）：二进制第 2 位（值 4）\n\n• `w`（写）：二进制第 1 位（值 2）\n\n• `x`（执行）：二进制第 0 位（值 1）\n\n• 权限组合：通过二进制位或运算（`|`）实现，例如：\n\n```\nrw- = 4（r） + 2（w） = 6 → 二进制 110\nrwx = 4 + 2 + 1 = 7 → 二进制 111\n```\n\n---\n\n##### **权限操作的核心逻辑**\n\n**权限验证**\n\nLinux 内核通过 **按位与运算（&）** 判断用户是否拥有某权限。例如，检查用户是否有执行权限：\n\n```c\n// 检查 st_mode 是否包含用户执行权限位\nif (st_mode & S_IXUSR) { /* 允许执行 */ }\n```\n\n• 权限位宏定义：\n\n```c\n#define S_IRUSR 0400  // 用户读权限（二进制：100 000 000）\n#define S_IWUSR 0200  // 用户写权限（二进制：010 000 000）\n#define S_IXUSR 0100  // 用户执行权限（二进制：001 000 000）\n```\n\n##### **权限修改**\n\n通过 **按位或（|）赋予权限** 和 **按位与非（& ~）移除权限** 实现动态调整：\n\n```bash\n// 添加用户写权限\nst_mode |= S_IWUSR;\n\n// 移除用户执行权限\nst_mode &= ~S_IXUSR;\n```\n\n---\n\n##### **用户视角的权限管理**\n\n- **chmod**** 命令的底层实现**\n\n• 符号模式：直接操作权限位\n\n```bash\nchmod u+x file    # 添加用户执行权限（位或运算）\nchmod g-w file    # 移除组写权限（位与非运算）\n```\n\n• 八进制模式：直接指定二进制掩码\n\n```bash\nchmod 755 file    # rwxr-xr-x → 二进制 111 101 101 → 八进制 755\n```\n\n- **权限继承与默认值**\n\n• umask 值：通过二进制掩码定义默认权限的补码\n\n```bash\numask 022         # 默认创建文件权限为 644（777 & ~022 = 755）\n```\n\n---\n\n##### **扩展应用：特殊权限位**\n\nLinux 还扩展了 **SUID、SGID、Sticky Bit** 等权限，仍基于二进制位掩码设计：\n\n• SUID（Set User ID）：二进制第 11 位（八进制 4000）\n\n```bash\nchmod u+s /usr/bin/passwd  # 设置SUID，允许普通用户以root权限修改密码\n```\n\n• Sticky Bit：二进制第 9 位（八进制 1000）\n\n```bash\nchmod +t /tmp              # 仅文件所有者可删除自己的文件\n```\n\n---\n\n1. **权限表示**：每个权限对应一个二进制位，组合成八进制数存储。\n2. **权限操作**：通过位运算（`|`、`&`、`~`）实现动态调整。\n3. **高效性**：位运算的原子性和低开销保障了权限验证的高效性。\n4. **可扩展性**：通过扩展位掩码（如 SUID）支持复杂权限需求。\n\n**这一设计充分体现了二进制在权限控制中的核心价值——简洁、高效、灵活。**\n\n##### 代码示例\n\n```\n#include <bits/stdc++.h>\n\nusing namespace std;\n\nconst int S_IXUSR = 0400;_ // 用户读权限（二进制：100 000 000）_\nconst int S_IWUSR = 0200;_ // 用户写权限（二进制：010 000 000）_\nconst int S_IXUSR = 0100;_ // 用户执行权限（二进制：001 000 000）_\n\nvoid check_permission(int st_mode)\n{\n_    // 检查 st_mode 是否包含用户执行权限位_\n    if (st_mode & S_IXUSR)\n    {\n_         /* 允许执行 */_\n    }\n}\n```\n\n#### 企业级框架的权限控制\n\n### 算法上的应用\n\n#### 原码反码补码\n\n在计算机中，带符号整数通常用 **补码** 表示，其转换流程为：\n\n1. 正数的补码 = 原码；\n2. 负数的补码 = （原码取反）+ 1。\n\n<table>\n<tr>\n<td>值<br/></td><td>原码（二进制）<br/></td><td>反码<br/></td><td>补码<br/></td></tr>\n<tr>\n<td>+5<br/></td><td>00000101<br/></td><td>—<br/></td><td>00000101<br/></td></tr>\n<tr>\n<td>–5<br/></td><td>10000101<br/></td><td>11111010<br/></td><td>11111011<br/></td></tr>\n</table>\n\n补码的好处是：加减运算都能统一为加法，省去了符号位处理的特殊逻辑，也天然支持异或、与或等位运算。\n\n#### 位运算\n\n- **取反（NOT）**：`~x` 将 x 的每一位二进制翻转。\n- **与（AND）**：`x & y`，常用于屏蔽某些位，比如 `x & 1` 可判断 x 的奇偶。\n- **或（OR）**：`x \\| y`，用于将某些位设为 1。\n- **异或（XOR）**：`x ^ y`，相同位结果为 0，不同位结果为 1。\n- **左移（<<）与右移（>>）**：将二进制整体左移或右移，等价于乘／除以 2 的幂。\n\n例如，下面函数高效判断一个整数是否是 2 的幂次方：\n\n```cpp\nbool isPowerOfTwo(int x) {\n    return x > 0 && (x & (x - 1)) == 0;\n}\n```\n\n```python\ndef is_power_of_two(x: int) -> bool:\n    return x > 0 and (x & (x - 1)) == 0\n```\n\n#### 快速幂\n\n> [快速幂 - OI Wiki](https://oi-wiki.org/math/binary-exponentiation/)\n\n> - 快速幂模运算通过二进制分解指数（如 $e = 2^k + 2^{k-1} + ... $）加速计算。\n>   假设指数$e$是一个正整数，它可以表示为二进制形式。例如，假设 $e = 13$，其二进制表示为 $1101_2$。这意味着：\n>\n> $$\n> e = 1 \\times 2^3 + 1 \\times 2^2 + 0 \\times 2^1 + 1 \\times 2^0\n> $$\n>\n> 因此，可以将$e$写成：\n>\n> $$\n> e = 2^3 + 2^2 + 2^0\n> $$\n>\n> 然后分别计算 $2^3$、$2^2$以及 $2^0\n> $ 与求和即可\n\n算法思想：\n\n1. 维护结果 `res=1`；\n2. 当最低位 $b_0=1$ 时，`res *= a`；\n3. 每次循环后，`a *= a`（平方），并将 $e$ 右移一位；\n4. 重复上述直到 $e=0$，最终 `res` 即为 $a^e$。\n\n```cpp\nlong long fast_pow(long long a, long long e) {\n    long long res = 1;\n    while (e > 0) {\n        if (e & 1)            // 若当前最低位为 1\n            res = res * a;\n        a = a * a;           // 平方\n        e >>= 1;             // 右移下一位\n    }\n    return res;\n}\n\nint main() {\n    std::cout << fast_pow(2, 13) << std::endl;  // 输出 8192\n    return 0;\n}\n```\n\n#### 异或运算\n\n- **交换变量**（无需临时变量）\n\n```cpp\na ^= b; b ^= a; a ^= b;\n```\n\n- **找出唯一出现一次的数**\n\n对于一个数组中只有一个元素出现一次，其余元素都出现两次，用异或可线性时间、常数空间找出它：\n\n```python\ndef single_number(nums):\n    ans = 0\n    for x in nums:\n        ans ^= x\n    return ans\n```\n\n- **按位翻转特定范围**\n\n将 `n` 的第 `i` 到 `j` 位全部翻转：\n\n```cpp\nint mask = ((1 << (j - i + 1)) - 1) << i;\nn ^= mask;\n```\n\n### 数据的表示、计算、存储和传输\n\n#### 数据压缩\n\n> - [https://colab.research.google.com/drive/1Mmi0GjoN2xCAIsyrTwYswP-FGUwMHEDQ?usp=sharing(colab](https://colab.research.google.com/drive/1Mmi0GjoN2xCAIsyrTwYswP-FGUwMHEDQ?usp=sharing(colab)) 链接)\n\n数据压缩可以分为有损压缩（Lossy）和无损压缩（Lossless）两类。\n\n- **无损压缩**在压缩和解压后能够完全恢复原始数据，常见算法有 DEFLATE（gzip、PNG）、LZMA（7z）等。\n\n1. **gzip（无损）示例**：\n\n```python\nimport gzip\n\ntext = b\"Data compression example. \" * 100\n# 压缩\ncompressed = gzip.compress(text)\nprint(\"原始大小：\", len(text), \"压缩后大小：\", len(compressed))\n# 解压\ndecompressed = gzip.decompress(compressed)\nassert decompressed == text\n```\n\n![1749358101852VcESbqoZboQwALx8jarc7TRmnme.png](https://gitee.com/tanke11223344/imagehost/raw/main/blog/1749358101852VcESbqoZboQwALx8jarc7TRmnme.png)\n\n以上示例使用 DEFLATE 算法，无损地将文本压缩并恢复\n\n- **有损压缩**则在压缩过程中丢弃“人眼/人耳不易察觉”的冗余信息，如 JPEG 图像、MP3 音频，其解压后无法恢复到完全原始状态。\n\n```python\nfrom PIL import Image\nimg = Image.open(\"input.png\")\nimg.save(\"output.jpg\", quality=50)  # quality<100 会丢失部分细节\n```\n\n![1749357984852CVRfb86YNohpkSxhCM9cQd6bnOd.png](https://gitee.com/tanke11223344/imagehost/raw/main/blog/1749357984852CVRfb86YNohpkSxhCM9cQd6bnOd.png)\n\n```bash\n# 对比文件体积\nls -lh input.jpg output.jpg\n```\n\n![1749358112853YAcabWie6oudnmxod0bcfX4PntU.png](https://gitee.com/tanke11223344/imagehost/raw/main/blog/1749358112853YAcabWie6oudnmxod0bcfX4PntU.png)\n\n通过调整 `quality` 参数，JPEG 有损压缩可在保留较好视觉效果的同时大幅减小文件体积。\n\n#### OneHot 编码\n\n> [https://colab.research.google.com/drive/1VpmC-vKrvaFusdNNuaavzvAk2YMhGWrW?usp=sharing(colab](https://colab.research.google.com/drive/1VpmC-vKrvaFusdNNuaavzvAk2YMhGWrW?usp=sharing(colab)) 链接)\n\nOne-Hot 编码是一种将分类变量转换为稀疏二进制向量的技术，每个类别对应一个维度，只有所属类别位置为 1，其它位置为 0。\n\n##### **Pandas 实现示例**：\n\n```python\nimport pandas as pd\ndf = pd.DataFrame({\"color\": [\"red\", \"blue\", \"green\", \"blue\"]})\none_hot = pd.get_dummies(df[\"color\"], prefix=\"color\")\nprint(one_hot)\n```\n\n```\ncolor_blue  color_green  color_red\n0       False        False       True\n1        True        False      False\n2       False         True      False\n3        True        False      False\n```\n\n此方法对小规模类别集非常高效，并集成于 Pandas。\n\n#### **Scikit-Learn 实现示例**：\n\n```python\nfrom sklearn.preprocessing import OneHotEncoder\nenc = OneHotEncoder(sparse=False)\nX = enc.fit_transform(df[[\"color\"]])\nprint(X)\n```\n\n```\n[[0. 0. 1.]\n [1. 0. 0.]\n [0. 1. 0.]\n [1. 0. 0.]]\n```\n\n`OneHotEncoder` 支持 `handle_unknown` 参数，用于处理训练外出现的新类别。\n\n---\n\n#### 深度学习中数据与模型的二进制存储方法\n\n深度学习框架通常使用专门的二进制格式保存模型参数和网络结构，以提高读写性能并节省存储空间。\n\n- **PyTorch**：使用 Python 序列化（Pickle）将模型权重保存在 `.pt` 或 `.pth` 文件，通常调用 `torch.save(model.state_dict(), 'model.pth')` 和 `model.load_state_dict(torch.load('model.pth'))`。\n- **TensorFlow**：采用 SavedModel 格式，目录中包含 `saved_model.pb`（Protobuf 二进制）与 `variables` 检查点文件，使用 `model.save('path')` 和 `tf.keras.models.load_model('path')` 进行读写。\n- **安全张量（safetensors）**：新兴格式，提供比 Pickle 更强的安全性与加载性能，示例：\n\n```python\nimport safetensors.torch as st\nst.save_file(model.state_dict(), \"model.safetensors\")\n```\n\n此外，ONNX（Open Neural Network Exchange）以 Protobuf 二进制保存跨框架模型结构与权重，易于在不同平台间互操作。\n\n#### CSS 等设计方面的颜色编码\n\n在前端设计中，颜色可通过多种编码表示，最常见的是 十六进制（Hex）、RGB(A) 与 **HSL(A)** 格式。\n\n- **Hex**：`#RRGGBB` 或简写 `#RGB`，例如 `#ff00aa`。\n- **RGB**：`rgb(255,0,170)`，可加透明度：`rgba(255,0,170,0.5)`。\n- **HSL**：`hsl(320,100%,50%)`，直观调节色相、饱和度、亮度。\n\n**CSS 示例**：\n\n```css\n.button {\n  background: #3498db;           /* Hex */\n  color: rgb(255, 255, 255);     /* RGB */\n  border-color: hsl(200, 70%, 50%); /* HSL */\n}\n```\n\n**JavaScript 转换示例**：\n\n```javascript\n// Hex to RGB\nfunction hexToRgb(hex) {\n  let m = hex.match(/^#?([A-F\\d]{2})([A-F\\d]{2})([A-F\\d]{2})$/i);\n  if (!m) return null;\n  return {\n    r: parseInt(m[1], 16),\n    g: parseInt(m[2], 16),\n    b: parseInt(m[3], 16)\n  };\n}\nconsole.log(hexToRgb(\"#ff00aa\")); // {r:255, g:0, b:170}\n```\n\n#### 计算机网络 ip 地址\n\n> [计算机网络（一）基本概念（IP,子网掩码,默认网关,DNS）](https://zhuanlan.zhihu.com/p/50091071)\n> [【计算机网络】IP 协议、IP 地址、网段划分、子网划分、子网掩码、CIDR_ip cidr-CSDN 博客](https://blog.csdn.net/m0_45406092/article/details/118526894)\n> [IP 地址、子网掩码、网关、DNS 之间的关系](https://zhuanlan.zhihu.com/p/537410069)\n\n![1749358083853UllubbF2foHWwFxXFVOcMncxnLh.png](https://gitee.com/tanke11223344/imagehost/raw/main/blog/1749358083853UllubbF2foHWwFxXFVOcMncxnLh.png)\n![1749358068852MhlQbzAfxoR7YQxGKqYcRIvEnQb.png](https://gitee.com/tanke11223344/imagehost/raw/main/blog/1749358068852MhlQbzAfxoR7YQxGKqYcRIvEnQb.png)\n\nIP 地址、子网掩码、默认网关与 DNS 协同完成局域网与互联网互联：\n\n- **IP 地址**：标识主机在子网中的唯一地址，如 `192.168.1.10/24`。\n- **子网掩码**：如 `255.255.255.0`（/24），用于划分网络号与主机号。\n- **默认网关**：同子网内路由器接口地址，负责跨网段转发，如 `192.168.1.1`。\n- **DNS**：域名解析服务器，将域名映射至 IP（如 `8.8.8.8`）。\n\n1. **ipaddress 计算示例**：\n\n> - [https://colab.research.google.com/drive/1rXH5_RbucvYiemz9kz4mfqlx1Uz3DWA2?usp=sharing(colab](https://colab.research.google.com/drive/1rXH5_RbucvYiemz9kz4mfqlx1Uz3DWA2?usp=sharing(colab)) 链接)\n\n```python\nimport ipaddress\n\nnet = ipaddress.ip_network(\"192.168.1.10/24\", strict=False)\nprint(\"网络地址:\", net.network_address)\nprint(\"广播地址:\", net.broadcast_address)\nprint(\"可用主机:\", list(net.hosts())[:3], \"…共\", net.num_addresses - 2)\n```\n\n![1749358051852DGQZbu2FIoQK8txaq98c7aD8nCe.png](https://gitee.com/tanke11223344/imagehost/raw/main/blog/1749358051852DGQZbu2FIoQK8txaq98c7aD8nCe.png)\n","slug":"2025-04-15-二进制思想在计算机科学中的应用","published":1,"updated":"2025-09-26T12:16:49.430Z","_id":"cmg0saj420014jm8n4lste4xu","comments":1,"layout":"post","photos":[],"content":"<h1 id=\"1-1-二进制思想在计算机科学中的应用\"><a href=\"#1-1-二进制思想在计算机科学中的应用\" class=\"headerlink\" title=\"1.1.二进制思想在计算机科学中的应用\"></a>1.1.二进制思想在计算机科学中的应用</h1><blockquote>\n<p>飞书文档链接<br><a href=\"https://xcnx25vdviba.feishu.cn/wiki/F8itwjr9MiktqGkjJk1cVkTSnlg?from=from_copylink\">1.1.二进制思想在计算机科学中的应用</a></p>\n</blockquote>\n<h1 id=\"参考资料\"><a href=\"#参考资料\" class=\"headerlink\" title=\"参考资料\"></a>参考资料</h1><blockquote>\n<ul>\n<li><a href=\"https://blog.csdn.net/u010674101/article/details/142599519?spm=1001.2101.3001.6650.3&utm_medium=distribute.pc_relevant.none-task-blog-2~default~BlogCommendFromBaidu~Rate-3-142599519-blog-131889184.235%5Ev43%5Epc_blog_bottom_relevance_base8&depth_1-utm_source=distribute.pc_relevant.none-task-blog-2~default~BlogCommendFromBaidu~Rate-3-142599519-blog-131889184.235%5Ev43%5Epc_blog_bottom_relevance_base8&utm_relevant_index=6\">二进制、八进制、十进制、十六进制使用场景_八进制应用在什么地方-CSDN 博客</a></li>\n<li><a href=\"https://blog.csdn.net/xuehuadalao/article/details/107611093?spm=1001.2101.3001.6650.4&utm_medium=distribute.pc_relevant.none-task-blog-2~default~BlogCommendFromBaidu~Rate-4-107611093-blog-131889184.235%5Ev43%5Epc_blog_bottom_relevance_base8&depth_1-utm_source=distribute.pc_relevant.none-task-blog-2~default~BlogCommendFromBaidu~Rate-4-107611093-blog-131889184.235%5Ev43%5Epc_blog_bottom_relevance_base8&utm_relevant_index=9\">计算机中不同进制的使用说明_计算机不同进制数怎么使用-CSDN 博客</a></li>\n<li><a href=\"https://www.cnblogs.com/yilang/p/11067886.html\">现代计算机爱上二进制—-为什么要用二进制 - 活着的虫子 - 博客园</a></li>\n</ul>\n</blockquote>\n<p>二进制是一种基数为 2 的数制，只使用两个数字——0 和 1。这两个数字被称为比特(bit)，是计算机中最小的数据单位。二进制是计算机科学的基础，用于表示所有数据类型。例如，文本通过 ASCII 编码转为二进制，图像和声音也以二进制存储。逻辑电路依赖二进制逻辑门（如 AND、OR、NOT）执行计算，处理器通过二进制指令执行操作。此外，二进制在数字通信、加密技术和错误检测中也至关重要。这些应用确保了现代计算系统的功能。</p>\n<h2 id=\"二进制在计算机科学中的应用\"><a href=\"#二进制在计算机科学中的应用\" class=\"headerlink\" title=\"二进制在计算机科学中的应用\"></a>二进制在计算机科学中的应用</h2><h3 id=\"密码学与数据校验\"><a href=\"#密码学与数据校验\" class=\"headerlink\" title=\"密码学与数据校验\"></a>密码学与数据校验</h3><p>密码学的所有技术实现均基于二进制运算，二进制是计算机处理数据的基础单位，密码学通过二进制操作实现数据的加密、哈希、签名等核心功能。</p>\n<ul>\n<li>数据存储与传输所有明文、密文、密钥、哈希值等均以二进制形式存储和传输（如 ASCII 文本需先转为二进制再加密）。</li>\n<li>位操作（Bitwise Operations）密码算法依赖二进制位运算（如异或 XOR、移位、置换）实现加密混淆。</li>\n</ul>\n<blockquote>\n<p>示例：AES 加密中的“字节替换（SubBytes）”步骤，本质是二进制字节通过 S 盒（查找表）进行非线性变换。</p>\n</blockquote>\n<hr>\n<h4 id=\"非对称加密的二进制数学基础\"><a href=\"#非对称加密的二进制数学基础\" class=\"headerlink\" title=\"非对称加密的二进制数学基础\"></a>非对称加密的二进制数学基础</h4><ul>\n<li><p>大整数运算</p>\n<ul>\n<li>RSA、ECC 等算法依赖超大二进制整数的运算（如模幂运算、椭圆曲线点运算）。</li>\n</ul>\n<blockquote>\n<p>示例：RSA 加密中，公钥加密过程本质是计算 $C &#x3D; M^e \\mod n$，其中 $ M, e, n $ 均为二进制大整数。</p>\n</blockquote>\n</li>\n<li><p>二进制优化</p>\n<ul>\n<li>快速幂模运算通过二进制分解指数（如 $e &#x3D; 2^k + 2^{k-1} + … $）加速计算。<br>假设指数$e$是一个正整数，它可以表示为二进制形式。例如，假设 $e &#x3D; 13$，其二进制表示为 $1101_2$。这意味着：</li>\n</ul>\n<p>$$<br>e &#x3D; 1 \\times 2^3 + 1 \\times 2^2 + 0 \\times 2^1 + 1 \\times 2^0<br>$$</p>\n<p>因此，可以将$e$写成：</p>\n<p>$$<br>e &#x3D; 2^3 + 2^2 + 2^0<br>$$</p>\n<p>然后分别计算 $2^3$、$2^2$以及 $2^0<br>$ 与求和即可</p>\n</li>\n</ul>\n<hr>\n<h4 id=\"密钥与随机数的二进制本质\"><a href=\"#密钥与随机数的二进制本质\" class=\"headerlink\" title=\"密钥与随机数的二进制本质\"></a>密钥与随机数的二进制本质</h4><ul>\n<li><p>密钥生成</p>\n<ul>\n<li>对称密钥（如 AES-256 的 256 位密钥）、非对称私钥（如 ECC 的 256 位随机数）均为二进制序列。</li>\n<li>密钥安全性依赖二进制随机数的不可预测性（如量子随机数生成器）。</li>\n</ul>\n</li>\n<li><p>密钥存储</p>\n<ul>\n<li>密钥需以二进制形式安全存储（如硬件加密模块 HSM）。</li>\n</ul>\n</li>\n</ul>\n<hr>\n<h4 id=\"密码协议中的二进制交互\"><a href=\"#密码协议中的二进制交互\" class=\"headerlink\" title=\"密码协议中的二进制交互\"></a>密码协议中的二进制交互</h4><ul>\n<li><p>网络协议</p>\n<ul>\n<li>HTTPS、SSH 等协议中，所有握手、加密、签名过程均通过二进制数据包实现。示例：TLS 协议中，客户端与服务端交换随机数（二进制串）生成会话密钥。</li>\n</ul>\n</li>\n<li><p>编码与解码</p>\n<ul>\n<li>加密后的二进制数据需通过 Base64、Hex 等编码转为可传输文本格式。</li>\n</ul>\n</li>\n</ul>\n<hr>\n<h3 id=\"权限控制\"><a href=\"#权限控制\" class=\"headerlink\" title=\"权限控制\"></a>权限控制</h3><blockquote>\n<ul>\n<li><a href=\"https://www.cnblogs.com/qfcndtt/archive/2012/08/03/2621713.html\">基于二进制的权限管理与验证 - 勤奋的菜鸟 - 博客园</a></li>\n<li><a href=\"https://www.zhihu.com/column/p/30103832\">权限控制 | 使用二进制做权限控制功能</a></li>\n</ul>\n</blockquote>\n<h4 id=\"使用位运算的权限控制-bitmask\"><a href=\"#使用位运算的权限控制-bitmask\" class=\"headerlink\" title=\"使用位运算的权限控制(bitmask)\"></a>使用位运算的权限控制(bitmask)</h4><h5 id=\"Linux-权限的二进制表示\"><a href=\"#Linux-权限的二进制表示\" class=\"headerlink\" title=\"Linux 权限的二进制表示\"></a><strong>Linux 权限的二进制表示</strong></h5><p>Linux 中每个文件&#x2F;目录的权限分为 <strong>所有者（User）、所属组（Group）、其他用户（Others）</strong> 三个角色，每个角色对应 <strong>读（r）、写（w）、执行（x）</strong> 三种权限，分别用 <strong>3 位二进制</strong> 表示：</p>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">rwx r-x r-- → 二进制：111 101 100 → 八进制：754</span><br><span class=\"line\">   ↑   ↑   ↑</span><br><span class=\"line\">  用户 组  其他</span><br></pre></td></tr></table></figure>\n\n<p>• 每个权限位映射：</p>\n<p>• <code>r</code>（读）：二进制第 2 位（值 4）</p>\n<p>• <code>w</code>（写）：二进制第 1 位（值 2）</p>\n<p>• <code>x</code>（执行）：二进制第 0 位（值 1）</p>\n<p>• 权限组合：通过二进制位或运算（<code>|</code>）实现，例如：</p>\n<figure class=\"highlight apache\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"attribute\">rw</span>- = <span class=\"number\">4</span>（r） + <span class=\"number\">2</span>（w） = <span class=\"number\">6</span> → 二进制 <span class=\"number\">110</span></span><br><span class=\"line\"><span class=\"attribute\">rwx</span> = <span class=\"number\">4</span> + <span class=\"number\">2</span> + <span class=\"number\">1</span> = <span class=\"number\">7</span> → 二进制 <span class=\"number\">111</span></span><br></pre></td></tr></table></figure>\n\n<hr>\n<h5 id=\"权限操作的核心逻辑\"><a href=\"#权限操作的核心逻辑\" class=\"headerlink\" title=\"权限操作的核心逻辑\"></a><strong>权限操作的核心逻辑</strong></h5><p><strong>权限验证</strong></p>\n<p>Linux 内核通过 <strong>按位与运算（&amp;）</strong> 判断用户是否拥有某权限。例如，检查用户是否有执行权限：</p>\n<figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// 检查 st_mode 是否包含用户执行权限位</span></span><br><span class=\"line\"><span class=\"keyword\">if</span> (st_mode &amp; S_IXUSR) &#123; <span class=\"comment\">/* 允许执行 */</span> &#125;</span><br></pre></td></tr></table></figure>\n\n<p>• 权限位宏定义：</p>\n<figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">#<span class=\"keyword\">define</span> S_IRUSR 0400  <span class=\"comment\">// 用户读权限（二进制：100 000 000）</span></span></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"keyword\">define</span> S_IWUSR 0200  <span class=\"comment\">// 用户写权限（二进制：010 000 000）</span></span></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"keyword\">define</span> S_IXUSR 0100  <span class=\"comment\">// 用户执行权限（二进制：001 000 000）</span></span></span><br></pre></td></tr></table></figure>\n\n<h5 id=\"权限修改\"><a href=\"#权限修改\" class=\"headerlink\" title=\"权限修改\"></a><strong>权限修改</strong></h5><p>通过 <strong>按位或（|）赋予权限</strong> 和 <strong>按位与非（&amp; ~）移除权限</strong> 实现动态调整：</p>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">// 添加用户写权限</span><br><span class=\"line\">st_mode |= S_IWUSR;</span><br><span class=\"line\"></span><br><span class=\"line\">// 移除用户执行权限</span><br><span class=\"line\">st_mode &amp;= ~S_IXUSR;</span><br></pre></td></tr></table></figure>\n\n<hr>\n<h5 id=\"用户视角的权限管理\"><a href=\"#用户视角的权限管理\" class=\"headerlink\" title=\"用户视角的权限管理\"></a><strong>用户视角的权限管理</strong></h5><ul>\n<li><strong>chmod</strong>** 命令的底层实现**</li>\n</ul>\n<p>• 符号模式：直接操作权限位</p>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"built_in\">chmod</span> u+x file    <span class=\"comment\"># 添加用户执行权限（位或运算）</span></span><br><span class=\"line\"><span class=\"built_in\">chmod</span> g-w file    <span class=\"comment\"># 移除组写权限（位与非运算）</span></span><br></pre></td></tr></table></figure>\n\n<p>• 八进制模式：直接指定二进制掩码</p>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"built_in\">chmod</span> 755 file    <span class=\"comment\"># rwxr-xr-x → 二进制 111 101 101 → 八进制 755</span></span><br></pre></td></tr></table></figure>\n\n<ul>\n<li><strong>权限继承与默认值</strong></li>\n</ul>\n<p>• umask 值：通过二进制掩码定义默认权限的补码</p>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"built_in\">umask</span> 022         <span class=\"comment\"># 默认创建文件权限为 644（777 &amp; ~022 = 755）</span></span><br></pre></td></tr></table></figure>\n\n<hr>\n<h5 id=\"扩展应用：特殊权限位\"><a href=\"#扩展应用：特殊权限位\" class=\"headerlink\" title=\"扩展应用：特殊权限位\"></a><strong>扩展应用：特殊权限位</strong></h5><p>Linux 还扩展了 <strong>SUID、SGID、Sticky Bit</strong> 等权限，仍基于二进制位掩码设计：</p>\n<p>• SUID（Set User ID）：二进制第 11 位（八进制 4000）</p>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"built_in\">chmod</span> u+s /usr/bin/passwd  <span class=\"comment\"># 设置SUID，允许普通用户以root权限修改密码</span></span><br></pre></td></tr></table></figure>\n\n<p>• Sticky Bit：二进制第 9 位（八进制 1000）</p>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"built_in\">chmod</span> +t /tmp              <span class=\"comment\"># 仅文件所有者可删除自己的文件</span></span><br></pre></td></tr></table></figure>\n\n<hr>\n<ol>\n<li><strong>权限表示</strong>：每个权限对应一个二进制位，组合成八进制数存储。</li>\n<li><strong>权限操作</strong>：通过位运算（<code>|</code>、<code>&amp;</code>、<code>~</code>）实现动态调整。</li>\n<li><strong>高效性</strong>：位运算的原子性和低开销保障了权限验证的高效性。</li>\n<li><strong>可扩展性</strong>：通过扩展位掩码（如 SUID）支持复杂权限需求。</li>\n</ol>\n<p><strong>这一设计充分体现了二进制在权限控制中的核心价值——简洁、高效、灵活。</strong></p>\n<h5 id=\"代码示例\"><a href=\"#代码示例\" class=\"headerlink\" title=\"代码示例\"></a>代码示例</h5><figure class=\"highlight cpp\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">#<span class=\"keyword\">include</span> <span class=\"string\">&lt;bits/stdc++.h&gt;</span></span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">using</span> <span class=\"keyword\">namespace</span> std;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"type\">const</span> <span class=\"type\">int</span> S_IXUSR = <span class=\"number\">0400</span>;_ <span class=\"comment\">// 用户读权限（二进制：100 000 000）_</span></span><br><span class=\"line\"><span class=\"type\">const</span> <span class=\"type\">int</span> S_IWUSR = <span class=\"number\">0200</span>;_ <span class=\"comment\">// 用户写权限（二进制：010 000 000）_</span></span><br><span class=\"line\"><span class=\"type\">const</span> <span class=\"type\">int</span> S_IXUSR = <span class=\"number\">0100</span>;_ <span class=\"comment\">// 用户执行权限（二进制：001 000 000）_</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"type\">void</span> <span class=\"title\">check_permission</span><span class=\"params\">(<span class=\"type\">int</span> st_mode)</span></span></span><br><span class=\"line\"><span class=\"function\"></span>&#123;</span><br><span class=\"line\">_    <span class=\"comment\">// 检查 st_mode 是否包含用户执行权限位_</span></span><br><span class=\"line\">    <span class=\"keyword\">if</span> (st_mode &amp; S_IXUSR)</span><br><span class=\"line\">    &#123;</span><br><span class=\"line\">_         <span class=\"comment\">/* 允许执行 */</span>_</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<h4 id=\"企业级框架的权限控制\"><a href=\"#企业级框架的权限控制\" class=\"headerlink\" title=\"企业级框架的权限控制\"></a>企业级框架的权限控制</h4><h3 id=\"算法上的应用\"><a href=\"#算法上的应用\" class=\"headerlink\" title=\"算法上的应用\"></a>算法上的应用</h3><h4 id=\"原码反码补码\"><a href=\"#原码反码补码\" class=\"headerlink\" title=\"原码反码补码\"></a>原码反码补码</h4><p>在计算机中，带符号整数通常用 <strong>补码</strong> 表示，其转换流程为：</p>\n<ol>\n<li>正数的补码 &#x3D; 原码；</li>\n<li>负数的补码 &#x3D; （原码取反）+ 1。</li>\n</ol>\n<table>\n<tr>\n<td>值<br/></td><td>原码（二进制）<br/></td><td>反码<br/></td><td>补码<br/></td></tr>\n<tr>\n<td>+5<br/></td><td>00000101<br/></td><td>—<br/></td><td>00000101<br/></td></tr>\n<tr>\n<td>–5<br/></td><td>10000101<br/></td><td>11111010<br/></td><td>11111011<br/></td></tr>\n</table>\n\n<p>补码的好处是：加减运算都能统一为加法，省去了符号位处理的特殊逻辑，也天然支持异或、与或等位运算。</p>\n<h4 id=\"位运算\"><a href=\"#位运算\" class=\"headerlink\" title=\"位运算\"></a>位运算</h4><ul>\n<li><strong>取反（NOT）</strong>：<code>~x</code> 将 x 的每一位二进制翻转。</li>\n<li><strong>与（AND）</strong>：<code>x &amp; y</code>，常用于屏蔽某些位，比如 <code>x &amp; 1</code> 可判断 x 的奇偶。</li>\n<li><strong>或（OR）</strong>：<code>x \\| y</code>，用于将某些位设为 1。</li>\n<li><strong>异或（XOR）</strong>：<code>x ^ y</code>，相同位结果为 0，不同位结果为 1。</li>\n<li><strong>左移（&lt;&lt;）与右移（&gt;&gt;）</strong>：将二进制整体左移或右移，等价于乘／除以 2 的幂。</li>\n</ul>\n<p>例如，下面函数高效判断一个整数是否是 2 的幂次方：</p>\n<figure class=\"highlight cpp\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"type\">bool</span> <span class=\"title\">isPowerOfTwo</span><span class=\"params\">(<span class=\"type\">int</span> x)</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> x &gt; <span class=\"number\">0</span> &amp;&amp; (x &amp; (x - <span class=\"number\">1</span>)) == <span class=\"number\">0</span>;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<figure class=\"highlight python\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">def</span> <span class=\"title function_\">is_power_of_two</span>(<span class=\"params\">x: <span class=\"built_in\">int</span></span>) -&gt; <span class=\"built_in\">bool</span>:</span><br><span class=\"line\">    <span class=\"keyword\">return</span> x &gt; <span class=\"number\">0</span> <span class=\"keyword\">and</span> (x &amp; (x - <span class=\"number\">1</span>)) == <span class=\"number\">0</span></span><br></pre></td></tr></table></figure>\n\n<h4 id=\"快速幂\"><a href=\"#快速幂\" class=\"headerlink\" title=\"快速幂\"></a>快速幂</h4><blockquote>\n<p><a href=\"https://oi-wiki.org/math/binary-exponentiation/\">快速幂 - OI Wiki</a></p>\n</blockquote>\n<blockquote>\n<ul>\n<li>快速幂模运算通过二进制分解指数（如 $e &#x3D; 2^k + 2^{k-1} + … $）加速计算。<br>假设指数$e$是一个正整数，它可以表示为二进制形式。例如，假设 $e &#x3D; 13$，其二进制表示为 $1101_2$。这意味着：</li>\n</ul>\n<p>$$<br>e &#x3D; 1 \\times 2^3 + 1 \\times 2^2 + 0 \\times 2^1 + 1 \\times 2^0<br>$$</p>\n<p>因此，可以将$e$写成：</p>\n<p>$$<br>e &#x3D; 2^3 + 2^2 + 2^0<br>$$</p>\n<p>然后分别计算 $2^3$、$2^2$以及 $2^0<br>$ 与求和即可</p>\n</blockquote>\n<p>算法思想：</p>\n<ol>\n<li>维护结果 <code>res=1</code>；</li>\n<li>当最低位 $b_0&#x3D;1$ 时，<code>res *= a</code>；</li>\n<li>每次循环后，<code>a *= a</code>（平方），并将 $e$ 右移一位；</li>\n<li>重复上述直到 $e&#x3D;0$，最终 <code>res</code> 即为 $a^e$。</li>\n</ol>\n<figure class=\"highlight cpp\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"type\">long</span> <span class=\"type\">long</span> <span class=\"title\">fast_pow</span><span class=\"params\">(<span class=\"type\">long</span> <span class=\"type\">long</span> a, <span class=\"type\">long</span> <span class=\"type\">long</span> e)</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"type\">long</span> <span class=\"type\">long</span> res = <span class=\"number\">1</span>;</span><br><span class=\"line\">    <span class=\"keyword\">while</span> (e &gt; <span class=\"number\">0</span>) &#123;</span><br><span class=\"line\">        <span class=\"keyword\">if</span> (e &amp; <span class=\"number\">1</span>)            <span class=\"comment\">// 若当前最低位为 1</span></span><br><span class=\"line\">            res = res * a;</span><br><span class=\"line\">        a = a * a;           <span class=\"comment\">// 平方</span></span><br><span class=\"line\">        e &gt;&gt;= <span class=\"number\">1</span>;             <span class=\"comment\">// 右移下一位</span></span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> res;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"type\">int</span> <span class=\"title\">main</span><span class=\"params\">()</span> </span>&#123;</span><br><span class=\"line\">    std::cout &lt;&lt; <span class=\"built_in\">fast_pow</span>(<span class=\"number\">2</span>, <span class=\"number\">13</span>) &lt;&lt; std::endl;  <span class=\"comment\">// 输出 8192</span></span><br><span class=\"line\">    <span class=\"keyword\">return</span> <span class=\"number\">0</span>;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<h4 id=\"异或运算\"><a href=\"#异或运算\" class=\"headerlink\" title=\"异或运算\"></a>异或运算</h4><ul>\n<li><strong>交换变量</strong>（无需临时变量）</li>\n</ul>\n<figure class=\"highlight cpp\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">a ^= b; b ^= a; a ^= b;</span><br></pre></td></tr></table></figure>\n\n<ul>\n<li><strong>找出唯一出现一次的数</strong></li>\n</ul>\n<p>对于一个数组中只有一个元素出现一次，其余元素都出现两次，用异或可线性时间、常数空间找出它：</p>\n<figure class=\"highlight python\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">def</span> <span class=\"title function_\">single_number</span>(<span class=\"params\">nums</span>):</span><br><span class=\"line\">    ans = <span class=\"number\">0</span></span><br><span class=\"line\">    <span class=\"keyword\">for</span> x <span class=\"keyword\">in</span> nums:</span><br><span class=\"line\">        ans ^= x</span><br><span class=\"line\">    <span class=\"keyword\">return</span> ans</span><br></pre></td></tr></table></figure>\n\n<ul>\n<li><strong>按位翻转特定范围</strong></li>\n</ul>\n<p>将 <code>n</code> 的第 <code>i</code> 到 <code>j</code> 位全部翻转：</p>\n<figure class=\"highlight cpp\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"type\">int</span> mask = ((<span class=\"number\">1</span> &lt;&lt; (j - i + <span class=\"number\">1</span>)) - <span class=\"number\">1</span>) &lt;&lt; i;</span><br><span class=\"line\">n ^= mask;</span><br></pre></td></tr></table></figure>\n\n<h3 id=\"数据的表示、计算、存储和传输\"><a href=\"#数据的表示、计算、存储和传输\" class=\"headerlink\" title=\"数据的表示、计算、存储和传输\"></a>数据的表示、计算、存储和传输</h3><h4 id=\"数据压缩\"><a href=\"#数据压缩\" class=\"headerlink\" title=\"数据压缩\"></a>数据压缩</h4><blockquote>\n<ul>\n<li><a href=\"https://colab.research.google.com/drive/1Mmi0GjoN2xCAIsyrTwYswP-FGUwMHEDQ?usp=sharing(colab)\">https://colab.research.google.com/drive/1Mmi0GjoN2xCAIsyrTwYswP-FGUwMHEDQ?usp=sharing(colab</a> 链接)</li>\n</ul>\n</blockquote>\n<p>数据压缩可以分为有损压缩（Lossy）和无损压缩（Lossless）两类。</p>\n<ul>\n<li><strong>无损压缩</strong>在压缩和解压后能够完全恢复原始数据，常见算法有 DEFLATE（gzip、PNG）、LZMA（7z）等。</li>\n</ul>\n<ol>\n<li><strong>gzip（无损）示例</strong>：</li>\n</ol>\n<figure class=\"highlight python\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">import</span> gzip</span><br><span class=\"line\"></span><br><span class=\"line\">text = <span class=\"string\">b&quot;Data compression example. &quot;</span> * <span class=\"number\">100</span></span><br><span class=\"line\"><span class=\"comment\"># 压缩</span></span><br><span class=\"line\">compressed = gzip.compress(text)</span><br><span class=\"line\"><span class=\"built_in\">print</span>(<span class=\"string\">&quot;原始大小：&quot;</span>, <span class=\"built_in\">len</span>(text), <span class=\"string\">&quot;压缩后大小：&quot;</span>, <span class=\"built_in\">len</span>(compressed))</span><br><span class=\"line\"><span class=\"comment\"># 解压</span></span><br><span class=\"line\">decompressed = gzip.decompress(compressed)</span><br><span class=\"line\"><span class=\"keyword\">assert</span> decompressed == text</span><br></pre></td></tr></table></figure>\n\n<p><img src=\"https://gitee.com/tanke11223344/imagehost/raw/main/blog/1749358101852VcESbqoZboQwALx8jarc7TRmnme.png\" alt=\"1749358101852VcESbqoZboQwALx8jarc7TRmnme.png\"></p>\n<p>以上示例使用 DEFLATE 算法，无损地将文本压缩并恢复</p>\n<ul>\n<li><strong>有损压缩</strong>则在压缩过程中丢弃“人眼&#x2F;人耳不易察觉”的冗余信息，如 JPEG 图像、MP3 音频，其解压后无法恢复到完全原始状态。</li>\n</ul>\n<figure class=\"highlight python\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">from</span> PIL <span class=\"keyword\">import</span> Image</span><br><span class=\"line\">img = Image.<span class=\"built_in\">open</span>(<span class=\"string\">&quot;input.png&quot;</span>)</span><br><span class=\"line\">img.save(<span class=\"string\">&quot;output.jpg&quot;</span>, quality=<span class=\"number\">50</span>)  <span class=\"comment\"># quality&lt;100 会丢失部分细节</span></span><br></pre></td></tr></table></figure>\n\n<p><img src=\"https://gitee.com/tanke11223344/imagehost/raw/main/blog/1749357984852CVRfb86YNohpkSxhCM9cQd6bnOd.png\" alt=\"1749357984852CVRfb86YNohpkSxhCM9cQd6bnOd.png\"></p>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\"># 对比文件体积</span></span><br><span class=\"line\"><span class=\"built_in\">ls</span> -lh input.jpg output.jpg</span><br></pre></td></tr></table></figure>\n\n<p><img src=\"https://gitee.com/tanke11223344/imagehost/raw/main/blog/1749358112853YAcabWie6oudnmxod0bcfX4PntU.png\" alt=\"1749358112853YAcabWie6oudnmxod0bcfX4PntU.png\"></p>\n<p>通过调整 <code>quality</code> 参数，JPEG 有损压缩可在保留较好视觉效果的同时大幅减小文件体积。</p>\n<h4 id=\"OneHot-编码\"><a href=\"#OneHot-编码\" class=\"headerlink\" title=\"OneHot 编码\"></a>OneHot 编码</h4><blockquote>\n<p><a href=\"https://colab.research.google.com/drive/1VpmC-vKrvaFusdNNuaavzvAk2YMhGWrW?usp=sharing(colab)\">https://colab.research.google.com/drive/1VpmC-vKrvaFusdNNuaavzvAk2YMhGWrW?usp=sharing(colab</a> 链接)</p>\n</blockquote>\n<p>One-Hot 编码是一种将分类变量转换为稀疏二进制向量的技术，每个类别对应一个维度，只有所属类别位置为 1，其它位置为 0。</p>\n<h5 id=\"Pandas-实现示例：\"><a href=\"#Pandas-实现示例：\" class=\"headerlink\" title=\"Pandas 实现示例：\"></a><strong>Pandas 实现示例</strong>：</h5><figure class=\"highlight python\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">import</span> pandas <span class=\"keyword\">as</span> pd</span><br><span class=\"line\">df = pd.DataFrame(&#123;<span class=\"string\">&quot;color&quot;</span>: [<span class=\"string\">&quot;red&quot;</span>, <span class=\"string\">&quot;blue&quot;</span>, <span class=\"string\">&quot;green&quot;</span>, <span class=\"string\">&quot;blue&quot;</span>]&#125;)</span><br><span class=\"line\">one_hot = pd.get_dummies(df[<span class=\"string\">&quot;color&quot;</span>], prefix=<span class=\"string\">&quot;color&quot;</span>)</span><br><span class=\"line\"><span class=\"built_in\">print</span>(one_hot)</span><br></pre></td></tr></table></figure>\n\n<figure class=\"highlight mathematica\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"type\">color_blue</span>  <span class=\"type\">color_green</span>  <span class=\"type\">color_red</span></span><br><span class=\"line\"><span class=\"number\">0</span>       <span class=\"built_in\">False</span>        <span class=\"built_in\">False</span>       <span class=\"built_in\">True</span></span><br><span class=\"line\"><span class=\"number\">1</span>        <span class=\"built_in\">True</span>        <span class=\"built_in\">False</span>      <span class=\"built_in\">False</span></span><br><span class=\"line\"><span class=\"number\">2</span>       <span class=\"built_in\">False</span>         <span class=\"built_in\">True</span>      <span class=\"built_in\">False</span></span><br><span class=\"line\"><span class=\"number\">3</span>        <span class=\"built_in\">True</span>        <span class=\"built_in\">False</span>      <span class=\"built_in\">False</span></span><br></pre></td></tr></table></figure>\n\n<p>此方法对小规模类别集非常高效，并集成于 Pandas。</p>\n<h4 id=\"Scikit-Learn-实现示例：\"><a href=\"#Scikit-Learn-实现示例：\" class=\"headerlink\" title=\"Scikit-Learn 实现示例：\"></a><strong>Scikit-Learn 实现示例</strong>：</h4><figure class=\"highlight python\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">from</span> sklearn.preprocessing <span class=\"keyword\">import</span> OneHotEncoder</span><br><span class=\"line\">enc = OneHotEncoder(sparse=<span class=\"literal\">False</span>)</span><br><span class=\"line\">X = enc.fit_transform(df[[<span class=\"string\">&quot;color&quot;</span>]])</span><br><span class=\"line\"><span class=\"built_in\">print</span>(X)</span><br></pre></td></tr></table></figure>\n\n<figure class=\"highlight inform7\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">[<span class=\"comment\">[0. 0. 1.]</span></span></span><br><span class=\"line\"><span class=\"comment\"> <span class=\"comment\">[1. 0. 0.]</span></span></span><br><span class=\"line\"><span class=\"comment\"> <span class=\"comment\">[0. 1. 0.]</span></span></span><br><span class=\"line\"><span class=\"comment\"> <span class=\"comment\">[1. 0. 0.]</span>]</span></span><br></pre></td></tr></table></figure>\n\n<p><code>OneHotEncoder</code> 支持 <code>handle_unknown</code> 参数，用于处理训练外出现的新类别。</p>\n<hr>\n<h4 id=\"深度学习中数据与模型的二进制存储方法\"><a href=\"#深度学习中数据与模型的二进制存储方法\" class=\"headerlink\" title=\"深度学习中数据与模型的二进制存储方法\"></a>深度学习中数据与模型的二进制存储方法</h4><p>深度学习框架通常使用专门的二进制格式保存模型参数和网络结构，以提高读写性能并节省存储空间。</p>\n<ul>\n<li><strong>PyTorch</strong>：使用 Python 序列化（Pickle）将模型权重保存在 <code>.pt</code> 或 <code>.pth</code> 文件，通常调用 <code>torch.save(model.state_dict(), &#39;model.pth&#39;)</code> 和 <code>model.load_state_dict(torch.load(&#39;model.pth&#39;))</code>。</li>\n<li><strong>TensorFlow</strong>：采用 SavedModel 格式，目录中包含 <code>saved_model.pb</code>（Protobuf 二进制）与 <code>variables</code> 检查点文件，使用 <code>model.save(&#39;path&#39;)</code> 和 <code>tf.keras.models.load_model(&#39;path&#39;)</code> 进行读写。</li>\n<li><strong>安全张量（safetensors）</strong>：新兴格式，提供比 Pickle 更强的安全性与加载性能，示例：</li>\n</ul>\n<figure class=\"highlight python\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">import</span> safetensors.torch <span class=\"keyword\">as</span> st</span><br><span class=\"line\">st.save_file(model.state_dict(), <span class=\"string\">&quot;model.safetensors&quot;</span>)</span><br></pre></td></tr></table></figure>\n\n<p>此外，ONNX（Open Neural Network Exchange）以 Protobuf 二进制保存跨框架模型结构与权重，易于在不同平台间互操作。</p>\n<h4 id=\"CSS-等设计方面的颜色编码\"><a href=\"#CSS-等设计方面的颜色编码\" class=\"headerlink\" title=\"CSS 等设计方面的颜色编码\"></a>CSS 等设计方面的颜色编码</h4><p>在前端设计中，颜色可通过多种编码表示，最常见的是 十六进制（Hex）、RGB(A) 与 <strong>HSL(A)</strong> 格式。</p>\n<ul>\n<li><strong>Hex</strong>：<code>#RRGGBB</code> 或简写 <code>#RGB</code>，例如 <code>#ff00aa</code>。</li>\n<li><strong>RGB</strong>：<code>rgb(255,0,170)</code>，可加透明度：<code>rgba(255,0,170,0.5)</code>。</li>\n<li><strong>HSL</strong>：<code>hsl(320,100%,50%)</code>，直观调节色相、饱和度、亮度。</li>\n</ul>\n<p><strong>CSS 示例</strong>：</p>\n<figure class=\"highlight css\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"selector-class\">.button</span> &#123;</span><br><span class=\"line\">  <span class=\"attribute\">background</span>: <span class=\"number\">#3498db</span>;           <span class=\"comment\">/* Hex */</span></span><br><span class=\"line\">  <span class=\"attribute\">color</span>: <span class=\"built_in\">rgb</span>(<span class=\"number\">255</span>, <span class=\"number\">255</span>, <span class=\"number\">255</span>);     <span class=\"comment\">/* RGB */</span></span><br><span class=\"line\">  <span class=\"attribute\">border-color</span>: <span class=\"built_in\">hsl</span>(<span class=\"number\">200</span>, <span class=\"number\">70%</span>, <span class=\"number\">50%</span>); <span class=\"comment\">/* HSL */</span></span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p><strong>JavaScript 转换示例</strong>：</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// Hex to RGB</span></span><br><span class=\"line\"><span class=\"keyword\">function</span> <span class=\"title function_\">hexToRgb</span>(<span class=\"params\">hex</span>) &#123;</span><br><span class=\"line\">  <span class=\"keyword\">let</span> m = hex.<span class=\"title function_\">match</span>(<span class=\"regexp\">/^#?([A-F\\d]&#123;2&#125;)([A-F\\d]&#123;2&#125;)([A-F\\d]&#123;2&#125;)$/i</span>);</span><br><span class=\"line\">  <span class=\"keyword\">if</span> (!m) <span class=\"keyword\">return</span> <span class=\"literal\">null</span>;</span><br><span class=\"line\">  <span class=\"keyword\">return</span> &#123;</span><br><span class=\"line\">    <span class=\"attr\">r</span>: <span class=\"built_in\">parseInt</span>(m[<span class=\"number\">1</span>], <span class=\"number\">16</span>),</span><br><span class=\"line\">    <span class=\"attr\">g</span>: <span class=\"built_in\">parseInt</span>(m[<span class=\"number\">2</span>], <span class=\"number\">16</span>),</span><br><span class=\"line\">    <span class=\"attr\">b</span>: <span class=\"built_in\">parseInt</span>(m[<span class=\"number\">3</span>], <span class=\"number\">16</span>)</span><br><span class=\"line\">  &#125;;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"variable language_\">console</span>.<span class=\"title function_\">log</span>(<span class=\"title function_\">hexToRgb</span>(<span class=\"string\">&quot;#ff00aa&quot;</span>)); <span class=\"comment\">// &#123;r:255, g:0, b:170&#125;</span></span><br></pre></td></tr></table></figure>\n\n<h4 id=\"计算机网络-ip-地址\"><a href=\"#计算机网络-ip-地址\" class=\"headerlink\" title=\"计算机网络 ip 地址\"></a>计算机网络 ip 地址</h4><blockquote>\n<p><a href=\"https://zhuanlan.zhihu.com/p/50091071\">计算机网络（一）基本概念（IP,子网掩码,默认网关,DNS）</a><br><a href=\"https://blog.csdn.net/m0_45406092/article/details/118526894\">【计算机网络】IP 协议、IP 地址、网段划分、子网划分、子网掩码、CIDR_ip cidr-CSDN 博客</a><br><a href=\"https://zhuanlan.zhihu.com/p/537410069\">IP 地址、子网掩码、网关、DNS 之间的关系</a></p>\n</blockquote>\n<p><img src=\"https://gitee.com/tanke11223344/imagehost/raw/main/blog/1749358083853UllubbF2foHWwFxXFVOcMncxnLh.png\" alt=\"1749358083853UllubbF2foHWwFxXFVOcMncxnLh.png\"><br><img src=\"https://gitee.com/tanke11223344/imagehost/raw/main/blog/1749358068852MhlQbzAfxoR7YQxGKqYcRIvEnQb.png\" alt=\"1749358068852MhlQbzAfxoR7YQxGKqYcRIvEnQb.png\"></p>\n<p>IP 地址、子网掩码、默认网关与 DNS 协同完成局域网与互联网互联：</p>\n<ul>\n<li><strong>IP 地址</strong>：标识主机在子网中的唯一地址，如 <code>192.168.1.10/24</code>。</li>\n<li><strong>子网掩码</strong>：如 <code>255.255.255.0</code>（&#x2F;24），用于划分网络号与主机号。</li>\n<li><strong>默认网关</strong>：同子网内路由器接口地址，负责跨网段转发，如 <code>192.168.1.1</code>。</li>\n<li><strong>DNS</strong>：域名解析服务器，将域名映射至 IP（如 <code>8.8.8.8</code>）。</li>\n</ul>\n<ol>\n<li><strong>ipaddress 计算示例</strong>：</li>\n</ol>\n<blockquote>\n<ul>\n<li><a href=\"https://colab.research.google.com/drive/1rXH5_RbucvYiemz9kz4mfqlx1Uz3DWA2?usp=sharing(colab)\">https://colab.research.google.com/drive/1rXH5_RbucvYiemz9kz4mfqlx1Uz3DWA2?usp&#x3D;sharing(colab</a> 链接)</li>\n</ul>\n</blockquote>\n<figure class=\"highlight python\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">import</span> ipaddress</span><br><span class=\"line\"></span><br><span class=\"line\">net = ipaddress.ip_network(<span class=\"string\">&quot;192.168.1.10/24&quot;</span>, strict=<span class=\"literal\">False</span>)</span><br><span class=\"line\"><span class=\"built_in\">print</span>(<span class=\"string\">&quot;网络地址:&quot;</span>, net.network_address)</span><br><span class=\"line\"><span class=\"built_in\">print</span>(<span class=\"string\">&quot;广播地址:&quot;</span>, net.broadcast_address)</span><br><span class=\"line\"><span class=\"built_in\">print</span>(<span class=\"string\">&quot;可用主机:&quot;</span>, <span class=\"built_in\">list</span>(net.hosts())[:<span class=\"number\">3</span>], <span class=\"string\">&quot;…共&quot;</span>, net.num_addresses - <span class=\"number\">2</span>)</span><br></pre></td></tr></table></figure>\n\n<p><img src=\"https://gitee.com/tanke11223344/imagehost/raw/main/blog/1749358051852DGQZbu2FIoQK8txaq98c7aD8nCe.png\" alt=\"1749358051852DGQZbu2FIoQK8txaq98c7aD8nCe.png\"></p>\n","excerpt":"","more":"<h1 id=\"1-1-二进制思想在计算机科学中的应用\"><a href=\"#1-1-二进制思想在计算机科学中的应用\" class=\"headerlink\" title=\"1.1.二进制思想在计算机科学中的应用\"></a>1.1.二进制思想在计算机科学中的应用</h1><blockquote>\n<p>飞书文档链接<br><a href=\"https://xcnx25vdviba.feishu.cn/wiki/F8itwjr9MiktqGkjJk1cVkTSnlg?from=from_copylink\">1.1.二进制思想在计算机科学中的应用</a></p>\n</blockquote>\n<h1 id=\"参考资料\"><a href=\"#参考资料\" class=\"headerlink\" title=\"参考资料\"></a>参考资料</h1><blockquote>\n<ul>\n<li><a href=\"https://blog.csdn.net/u010674101/article/details/142599519?spm=1001.2101.3001.6650.3&utm_medium=distribute.pc_relevant.none-task-blog-2~default~BlogCommendFromBaidu~Rate-3-142599519-blog-131889184.235%5Ev43%5Epc_blog_bottom_relevance_base8&depth_1-utm_source=distribute.pc_relevant.none-task-blog-2~default~BlogCommendFromBaidu~Rate-3-142599519-blog-131889184.235%5Ev43%5Epc_blog_bottom_relevance_base8&utm_relevant_index=6\">二进制、八进制、十进制、十六进制使用场景_八进制应用在什么地方-CSDN 博客</a></li>\n<li><a href=\"https://blog.csdn.net/xuehuadalao/article/details/107611093?spm=1001.2101.3001.6650.4&utm_medium=distribute.pc_relevant.none-task-blog-2~default~BlogCommendFromBaidu~Rate-4-107611093-blog-131889184.235%5Ev43%5Epc_blog_bottom_relevance_base8&depth_1-utm_source=distribute.pc_relevant.none-task-blog-2~default~BlogCommendFromBaidu~Rate-4-107611093-blog-131889184.235%5Ev43%5Epc_blog_bottom_relevance_base8&utm_relevant_index=9\">计算机中不同进制的使用说明_计算机不同进制数怎么使用-CSDN 博客</a></li>\n<li><a href=\"https://www.cnblogs.com/yilang/p/11067886.html\">现代计算机爱上二进制—-为什么要用二进制 - 活着的虫子 - 博客园</a></li>\n</ul>\n</blockquote>\n<p>二进制是一种基数为 2 的数制，只使用两个数字——0 和 1。这两个数字被称为比特(bit)，是计算机中最小的数据单位。二进制是计算机科学的基础，用于表示所有数据类型。例如，文本通过 ASCII 编码转为二进制，图像和声音也以二进制存储。逻辑电路依赖二进制逻辑门（如 AND、OR、NOT）执行计算，处理器通过二进制指令执行操作。此外，二进制在数字通信、加密技术和错误检测中也至关重要。这些应用确保了现代计算系统的功能。</p>\n<h2 id=\"二进制在计算机科学中的应用\"><a href=\"#二进制在计算机科学中的应用\" class=\"headerlink\" title=\"二进制在计算机科学中的应用\"></a>二进制在计算机科学中的应用</h2><h3 id=\"密码学与数据校验\"><a href=\"#密码学与数据校验\" class=\"headerlink\" title=\"密码学与数据校验\"></a>密码学与数据校验</h3><p>密码学的所有技术实现均基于二进制运算，二进制是计算机处理数据的基础单位，密码学通过二进制操作实现数据的加密、哈希、签名等核心功能。</p>\n<ul>\n<li>数据存储与传输所有明文、密文、密钥、哈希值等均以二进制形式存储和传输（如 ASCII 文本需先转为二进制再加密）。</li>\n<li>位操作（Bitwise Operations）密码算法依赖二进制位运算（如异或 XOR、移位、置换）实现加密混淆。</li>\n</ul>\n<blockquote>\n<p>示例：AES 加密中的“字节替换（SubBytes）”步骤，本质是二进制字节通过 S 盒（查找表）进行非线性变换。</p>\n</blockquote>\n<hr>\n<h4 id=\"非对称加密的二进制数学基础\"><a href=\"#非对称加密的二进制数学基础\" class=\"headerlink\" title=\"非对称加密的二进制数学基础\"></a>非对称加密的二进制数学基础</h4><ul>\n<li><p>大整数运算</p>\n<ul>\n<li>RSA、ECC 等算法依赖超大二进制整数的运算（如模幂运算、椭圆曲线点运算）。</li>\n</ul>\n<blockquote>\n<p>示例：RSA 加密中，公钥加密过程本质是计算 $C &#x3D; M^e \\mod n$，其中 $ M, e, n $ 均为二进制大整数。</p>\n</blockquote>\n</li>\n<li><p>二进制优化</p>\n<ul>\n<li>快速幂模运算通过二进制分解指数（如 $e &#x3D; 2^k + 2^{k-1} + … $）加速计算。<br>假设指数$e$是一个正整数，它可以表示为二进制形式。例如，假设 $e &#x3D; 13$，其二进制表示为 $1101_2$。这意味着：</li>\n</ul>\n<p>$$<br>e &#x3D; 1 \\times 2^3 + 1 \\times 2^2 + 0 \\times 2^1 + 1 \\times 2^0<br>$$</p>\n<p>因此，可以将$e$写成：</p>\n<p>$$<br>e &#x3D; 2^3 + 2^2 + 2^0<br>$$</p>\n<p>然后分别计算 $2^3$、$2^2$以及 $2^0<br>$ 与求和即可</p>\n</li>\n</ul>\n<hr>\n<h4 id=\"密钥与随机数的二进制本质\"><a href=\"#密钥与随机数的二进制本质\" class=\"headerlink\" title=\"密钥与随机数的二进制本质\"></a>密钥与随机数的二进制本质</h4><ul>\n<li><p>密钥生成</p>\n<ul>\n<li>对称密钥（如 AES-256 的 256 位密钥）、非对称私钥（如 ECC 的 256 位随机数）均为二进制序列。</li>\n<li>密钥安全性依赖二进制随机数的不可预测性（如量子随机数生成器）。</li>\n</ul>\n</li>\n<li><p>密钥存储</p>\n<ul>\n<li>密钥需以二进制形式安全存储（如硬件加密模块 HSM）。</li>\n</ul>\n</li>\n</ul>\n<hr>\n<h4 id=\"密码协议中的二进制交互\"><a href=\"#密码协议中的二进制交互\" class=\"headerlink\" title=\"密码协议中的二进制交互\"></a>密码协议中的二进制交互</h4><ul>\n<li><p>网络协议</p>\n<ul>\n<li>HTTPS、SSH 等协议中，所有握手、加密、签名过程均通过二进制数据包实现。示例：TLS 协议中，客户端与服务端交换随机数（二进制串）生成会话密钥。</li>\n</ul>\n</li>\n<li><p>编码与解码</p>\n<ul>\n<li>加密后的二进制数据需通过 Base64、Hex 等编码转为可传输文本格式。</li>\n</ul>\n</li>\n</ul>\n<hr>\n<h3 id=\"权限控制\"><a href=\"#权限控制\" class=\"headerlink\" title=\"权限控制\"></a>权限控制</h3><blockquote>\n<ul>\n<li><a href=\"https://www.cnblogs.com/qfcndtt/archive/2012/08/03/2621713.html\">基于二进制的权限管理与验证 - 勤奋的菜鸟 - 博客园</a></li>\n<li><a href=\"https://www.zhihu.com/column/p/30103832\">权限控制 | 使用二进制做权限控制功能</a></li>\n</ul>\n</blockquote>\n<h4 id=\"使用位运算的权限控制-bitmask\"><a href=\"#使用位运算的权限控制-bitmask\" class=\"headerlink\" title=\"使用位运算的权限控制(bitmask)\"></a>使用位运算的权限控制(bitmask)</h4><h5 id=\"Linux-权限的二进制表示\"><a href=\"#Linux-权限的二进制表示\" class=\"headerlink\" title=\"Linux 权限的二进制表示\"></a><strong>Linux 权限的二进制表示</strong></h5><p>Linux 中每个文件&#x2F;目录的权限分为 <strong>所有者（User）、所属组（Group）、其他用户（Others）</strong> 三个角色，每个角色对应 <strong>读（r）、写（w）、执行（x）</strong> 三种权限，分别用 <strong>3 位二进制</strong> 表示：</p>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">rwx r-x r-- → 二进制：111 101 100 → 八进制：754</span><br><span class=\"line\">   ↑   ↑   ↑</span><br><span class=\"line\">  用户 组  其他</span><br></pre></td></tr></table></figure>\n\n<p>• 每个权限位映射：</p>\n<p>• <code>r</code>（读）：二进制第 2 位（值 4）</p>\n<p>• <code>w</code>（写）：二进制第 1 位（值 2）</p>\n<p>• <code>x</code>（执行）：二进制第 0 位（值 1）</p>\n<p>• 权限组合：通过二进制位或运算（<code>|</code>）实现，例如：</p>\n<figure class=\"highlight apache\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"attribute\">rw</span>- = <span class=\"number\">4</span>（r） + <span class=\"number\">2</span>（w） = <span class=\"number\">6</span> → 二进制 <span class=\"number\">110</span></span><br><span class=\"line\"><span class=\"attribute\">rwx</span> = <span class=\"number\">4</span> + <span class=\"number\">2</span> + <span class=\"number\">1</span> = <span class=\"number\">7</span> → 二进制 <span class=\"number\">111</span></span><br></pre></td></tr></table></figure>\n\n<hr>\n<h5 id=\"权限操作的核心逻辑\"><a href=\"#权限操作的核心逻辑\" class=\"headerlink\" title=\"权限操作的核心逻辑\"></a><strong>权限操作的核心逻辑</strong></h5><p><strong>权限验证</strong></p>\n<p>Linux 内核通过 <strong>按位与运算（&amp;）</strong> 判断用户是否拥有某权限。例如，检查用户是否有执行权限：</p>\n<figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// 检查 st_mode 是否包含用户执行权限位</span></span><br><span class=\"line\"><span class=\"keyword\">if</span> (st_mode &amp; S_IXUSR) &#123; <span class=\"comment\">/* 允许执行 */</span> &#125;</span><br></pre></td></tr></table></figure>\n\n<p>• 权限位宏定义：</p>\n<figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">#<span class=\"keyword\">define</span> S_IRUSR 0400  <span class=\"comment\">// 用户读权限（二进制：100 000 000）</span></span></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"keyword\">define</span> S_IWUSR 0200  <span class=\"comment\">// 用户写权限（二进制：010 000 000）</span></span></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"keyword\">define</span> S_IXUSR 0100  <span class=\"comment\">// 用户执行权限（二进制：001 000 000）</span></span></span><br></pre></td></tr></table></figure>\n\n<h5 id=\"权限修改\"><a href=\"#权限修改\" class=\"headerlink\" title=\"权限修改\"></a><strong>权限修改</strong></h5><p>通过 <strong>按位或（|）赋予权限</strong> 和 <strong>按位与非（&amp; ~）移除权限</strong> 实现动态调整：</p>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">// 添加用户写权限</span><br><span class=\"line\">st_mode |= S_IWUSR;</span><br><span class=\"line\"></span><br><span class=\"line\">// 移除用户执行权限</span><br><span class=\"line\">st_mode &amp;= ~S_IXUSR;</span><br></pre></td></tr></table></figure>\n\n<hr>\n<h5 id=\"用户视角的权限管理\"><a href=\"#用户视角的权限管理\" class=\"headerlink\" title=\"用户视角的权限管理\"></a><strong>用户视角的权限管理</strong></h5><ul>\n<li><strong>chmod</strong>** 命令的底层实现**</li>\n</ul>\n<p>• 符号模式：直接操作权限位</p>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"built_in\">chmod</span> u+x file    <span class=\"comment\"># 添加用户执行权限（位或运算）</span></span><br><span class=\"line\"><span class=\"built_in\">chmod</span> g-w file    <span class=\"comment\"># 移除组写权限（位与非运算）</span></span><br></pre></td></tr></table></figure>\n\n<p>• 八进制模式：直接指定二进制掩码</p>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"built_in\">chmod</span> 755 file    <span class=\"comment\"># rwxr-xr-x → 二进制 111 101 101 → 八进制 755</span></span><br></pre></td></tr></table></figure>\n\n<ul>\n<li><strong>权限继承与默认值</strong></li>\n</ul>\n<p>• umask 值：通过二进制掩码定义默认权限的补码</p>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"built_in\">umask</span> 022         <span class=\"comment\"># 默认创建文件权限为 644（777 &amp; ~022 = 755）</span></span><br></pre></td></tr></table></figure>\n\n<hr>\n<h5 id=\"扩展应用：特殊权限位\"><a href=\"#扩展应用：特殊权限位\" class=\"headerlink\" title=\"扩展应用：特殊权限位\"></a><strong>扩展应用：特殊权限位</strong></h5><p>Linux 还扩展了 <strong>SUID、SGID、Sticky Bit</strong> 等权限，仍基于二进制位掩码设计：</p>\n<p>• SUID（Set User ID）：二进制第 11 位（八进制 4000）</p>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"built_in\">chmod</span> u+s /usr/bin/passwd  <span class=\"comment\"># 设置SUID，允许普通用户以root权限修改密码</span></span><br></pre></td></tr></table></figure>\n\n<p>• Sticky Bit：二进制第 9 位（八进制 1000）</p>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"built_in\">chmod</span> +t /tmp              <span class=\"comment\"># 仅文件所有者可删除自己的文件</span></span><br></pre></td></tr></table></figure>\n\n<hr>\n<ol>\n<li><strong>权限表示</strong>：每个权限对应一个二进制位，组合成八进制数存储。</li>\n<li><strong>权限操作</strong>：通过位运算（<code>|</code>、<code>&amp;</code>、<code>~</code>）实现动态调整。</li>\n<li><strong>高效性</strong>：位运算的原子性和低开销保障了权限验证的高效性。</li>\n<li><strong>可扩展性</strong>：通过扩展位掩码（如 SUID）支持复杂权限需求。</li>\n</ol>\n<p><strong>这一设计充分体现了二进制在权限控制中的核心价值——简洁、高效、灵活。</strong></p>\n<h5 id=\"代码示例\"><a href=\"#代码示例\" class=\"headerlink\" title=\"代码示例\"></a>代码示例</h5><figure class=\"highlight cpp\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">#<span class=\"keyword\">include</span> <span class=\"string\">&lt;bits/stdc++.h&gt;</span></span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">using</span> <span class=\"keyword\">namespace</span> std;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"type\">const</span> <span class=\"type\">int</span> S_IXUSR = <span class=\"number\">0400</span>;_ <span class=\"comment\">// 用户读权限（二进制：100 000 000）_</span></span><br><span class=\"line\"><span class=\"type\">const</span> <span class=\"type\">int</span> S_IWUSR = <span class=\"number\">0200</span>;_ <span class=\"comment\">// 用户写权限（二进制：010 000 000）_</span></span><br><span class=\"line\"><span class=\"type\">const</span> <span class=\"type\">int</span> S_IXUSR = <span class=\"number\">0100</span>;_ <span class=\"comment\">// 用户执行权限（二进制：001 000 000）_</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"type\">void</span> <span class=\"title\">check_permission</span><span class=\"params\">(<span class=\"type\">int</span> st_mode)</span></span></span><br><span class=\"line\"><span class=\"function\"></span>&#123;</span><br><span class=\"line\">_    <span class=\"comment\">// 检查 st_mode 是否包含用户执行权限位_</span></span><br><span class=\"line\">    <span class=\"keyword\">if</span> (st_mode &amp; S_IXUSR)</span><br><span class=\"line\">    &#123;</span><br><span class=\"line\">_         <span class=\"comment\">/* 允许执行 */</span>_</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<h4 id=\"企业级框架的权限控制\"><a href=\"#企业级框架的权限控制\" class=\"headerlink\" title=\"企业级框架的权限控制\"></a>企业级框架的权限控制</h4><h3 id=\"算法上的应用\"><a href=\"#算法上的应用\" class=\"headerlink\" title=\"算法上的应用\"></a>算法上的应用</h3><h4 id=\"原码反码补码\"><a href=\"#原码反码补码\" class=\"headerlink\" title=\"原码反码补码\"></a>原码反码补码</h4><p>在计算机中，带符号整数通常用 <strong>补码</strong> 表示，其转换流程为：</p>\n<ol>\n<li>正数的补码 &#x3D; 原码；</li>\n<li>负数的补码 &#x3D; （原码取反）+ 1。</li>\n</ol>\n<table>\n<tr>\n<td>值<br/></td><td>原码（二进制）<br/></td><td>反码<br/></td><td>补码<br/></td></tr>\n<tr>\n<td>+5<br/></td><td>00000101<br/></td><td>—<br/></td><td>00000101<br/></td></tr>\n<tr>\n<td>–5<br/></td><td>10000101<br/></td><td>11111010<br/></td><td>11111011<br/></td></tr>\n</table>\n\n<p>补码的好处是：加减运算都能统一为加法，省去了符号位处理的特殊逻辑，也天然支持异或、与或等位运算。</p>\n<h4 id=\"位运算\"><a href=\"#位运算\" class=\"headerlink\" title=\"位运算\"></a>位运算</h4><ul>\n<li><strong>取反（NOT）</strong>：<code>~x</code> 将 x 的每一位二进制翻转。</li>\n<li><strong>与（AND）</strong>：<code>x &amp; y</code>，常用于屏蔽某些位，比如 <code>x &amp; 1</code> 可判断 x 的奇偶。</li>\n<li><strong>或（OR）</strong>：<code>x \\| y</code>，用于将某些位设为 1。</li>\n<li><strong>异或（XOR）</strong>：<code>x ^ y</code>，相同位结果为 0，不同位结果为 1。</li>\n<li><strong>左移（&lt;&lt;）与右移（&gt;&gt;）</strong>：将二进制整体左移或右移，等价于乘／除以 2 的幂。</li>\n</ul>\n<p>例如，下面函数高效判断一个整数是否是 2 的幂次方：</p>\n<figure class=\"highlight cpp\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"type\">bool</span> <span class=\"title\">isPowerOfTwo</span><span class=\"params\">(<span class=\"type\">int</span> x)</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> x &gt; <span class=\"number\">0</span> &amp;&amp; (x &amp; (x - <span class=\"number\">1</span>)) == <span class=\"number\">0</span>;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<figure class=\"highlight python\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">def</span> <span class=\"title function_\">is_power_of_two</span>(<span class=\"params\">x: <span class=\"built_in\">int</span></span>) -&gt; <span class=\"built_in\">bool</span>:</span><br><span class=\"line\">    <span class=\"keyword\">return</span> x &gt; <span class=\"number\">0</span> <span class=\"keyword\">and</span> (x &amp; (x - <span class=\"number\">1</span>)) == <span class=\"number\">0</span></span><br></pre></td></tr></table></figure>\n\n<h4 id=\"快速幂\"><a href=\"#快速幂\" class=\"headerlink\" title=\"快速幂\"></a>快速幂</h4><blockquote>\n<p><a href=\"https://oi-wiki.org/math/binary-exponentiation/\">快速幂 - OI Wiki</a></p>\n</blockquote>\n<blockquote>\n<ul>\n<li>快速幂模运算通过二进制分解指数（如 $e &#x3D; 2^k + 2^{k-1} + … $）加速计算。<br>假设指数$e$是一个正整数，它可以表示为二进制形式。例如，假设 $e &#x3D; 13$，其二进制表示为 $1101_2$。这意味着：</li>\n</ul>\n<p>$$<br>e &#x3D; 1 \\times 2^3 + 1 \\times 2^2 + 0 \\times 2^1 + 1 \\times 2^0<br>$$</p>\n<p>因此，可以将$e$写成：</p>\n<p>$$<br>e &#x3D; 2^3 + 2^2 + 2^0<br>$$</p>\n<p>然后分别计算 $2^3$、$2^2$以及 $2^0<br>$ 与求和即可</p>\n</blockquote>\n<p>算法思想：</p>\n<ol>\n<li>维护结果 <code>res=1</code>；</li>\n<li>当最低位 $b_0&#x3D;1$ 时，<code>res *= a</code>；</li>\n<li>每次循环后，<code>a *= a</code>（平方），并将 $e$ 右移一位；</li>\n<li>重复上述直到 $e&#x3D;0$，最终 <code>res</code> 即为 $a^e$。</li>\n</ol>\n<figure class=\"highlight cpp\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"type\">long</span> <span class=\"type\">long</span> <span class=\"title\">fast_pow</span><span class=\"params\">(<span class=\"type\">long</span> <span class=\"type\">long</span> a, <span class=\"type\">long</span> <span class=\"type\">long</span> e)</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"type\">long</span> <span class=\"type\">long</span> res = <span class=\"number\">1</span>;</span><br><span class=\"line\">    <span class=\"keyword\">while</span> (e &gt; <span class=\"number\">0</span>) &#123;</span><br><span class=\"line\">        <span class=\"keyword\">if</span> (e &amp; <span class=\"number\">1</span>)            <span class=\"comment\">// 若当前最低位为 1</span></span><br><span class=\"line\">            res = res * a;</span><br><span class=\"line\">        a = a * a;           <span class=\"comment\">// 平方</span></span><br><span class=\"line\">        e &gt;&gt;= <span class=\"number\">1</span>;             <span class=\"comment\">// 右移下一位</span></span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> res;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"type\">int</span> <span class=\"title\">main</span><span class=\"params\">()</span> </span>&#123;</span><br><span class=\"line\">    std::cout &lt;&lt; <span class=\"built_in\">fast_pow</span>(<span class=\"number\">2</span>, <span class=\"number\">13</span>) &lt;&lt; std::endl;  <span class=\"comment\">// 输出 8192</span></span><br><span class=\"line\">    <span class=\"keyword\">return</span> <span class=\"number\">0</span>;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<h4 id=\"异或运算\"><a href=\"#异或运算\" class=\"headerlink\" title=\"异或运算\"></a>异或运算</h4><ul>\n<li><strong>交换变量</strong>（无需临时变量）</li>\n</ul>\n<figure class=\"highlight cpp\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">a ^= b; b ^= a; a ^= b;</span><br></pre></td></tr></table></figure>\n\n<ul>\n<li><strong>找出唯一出现一次的数</strong></li>\n</ul>\n<p>对于一个数组中只有一个元素出现一次，其余元素都出现两次，用异或可线性时间、常数空间找出它：</p>\n<figure class=\"highlight python\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">def</span> <span class=\"title function_\">single_number</span>(<span class=\"params\">nums</span>):</span><br><span class=\"line\">    ans = <span class=\"number\">0</span></span><br><span class=\"line\">    <span class=\"keyword\">for</span> x <span class=\"keyword\">in</span> nums:</span><br><span class=\"line\">        ans ^= x</span><br><span class=\"line\">    <span class=\"keyword\">return</span> ans</span><br></pre></td></tr></table></figure>\n\n<ul>\n<li><strong>按位翻转特定范围</strong></li>\n</ul>\n<p>将 <code>n</code> 的第 <code>i</code> 到 <code>j</code> 位全部翻转：</p>\n<figure class=\"highlight cpp\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"type\">int</span> mask = ((<span class=\"number\">1</span> &lt;&lt; (j - i + <span class=\"number\">1</span>)) - <span class=\"number\">1</span>) &lt;&lt; i;</span><br><span class=\"line\">n ^= mask;</span><br></pre></td></tr></table></figure>\n\n<h3 id=\"数据的表示、计算、存储和传输\"><a href=\"#数据的表示、计算、存储和传输\" class=\"headerlink\" title=\"数据的表示、计算、存储和传输\"></a>数据的表示、计算、存储和传输</h3><h4 id=\"数据压缩\"><a href=\"#数据压缩\" class=\"headerlink\" title=\"数据压缩\"></a>数据压缩</h4><blockquote>\n<ul>\n<li><a href=\"https://colab.research.google.com/drive/1Mmi0GjoN2xCAIsyrTwYswP-FGUwMHEDQ?usp=sharing(colab)\">https://colab.research.google.com/drive/1Mmi0GjoN2xCAIsyrTwYswP-FGUwMHEDQ?usp=sharing(colab</a> 链接)</li>\n</ul>\n</blockquote>\n<p>数据压缩可以分为有损压缩（Lossy）和无损压缩（Lossless）两类。</p>\n<ul>\n<li><strong>无损压缩</strong>在压缩和解压后能够完全恢复原始数据，常见算法有 DEFLATE（gzip、PNG）、LZMA（7z）等。</li>\n</ul>\n<ol>\n<li><strong>gzip（无损）示例</strong>：</li>\n</ol>\n<figure class=\"highlight python\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">import</span> gzip</span><br><span class=\"line\"></span><br><span class=\"line\">text = <span class=\"string\">b&quot;Data compression example. &quot;</span> * <span class=\"number\">100</span></span><br><span class=\"line\"><span class=\"comment\"># 压缩</span></span><br><span class=\"line\">compressed = gzip.compress(text)</span><br><span class=\"line\"><span class=\"built_in\">print</span>(<span class=\"string\">&quot;原始大小：&quot;</span>, <span class=\"built_in\">len</span>(text), <span class=\"string\">&quot;压缩后大小：&quot;</span>, <span class=\"built_in\">len</span>(compressed))</span><br><span class=\"line\"><span class=\"comment\"># 解压</span></span><br><span class=\"line\">decompressed = gzip.decompress(compressed)</span><br><span class=\"line\"><span class=\"keyword\">assert</span> decompressed == text</span><br></pre></td></tr></table></figure>\n\n<p><img src=\"https://gitee.com/tanke11223344/imagehost/raw/main/blog/1749358101852VcESbqoZboQwALx8jarc7TRmnme.png\" alt=\"1749358101852VcESbqoZboQwALx8jarc7TRmnme.png\"></p>\n<p>以上示例使用 DEFLATE 算法，无损地将文本压缩并恢复</p>\n<ul>\n<li><strong>有损压缩</strong>则在压缩过程中丢弃“人眼&#x2F;人耳不易察觉”的冗余信息，如 JPEG 图像、MP3 音频，其解压后无法恢复到完全原始状态。</li>\n</ul>\n<figure class=\"highlight python\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">from</span> PIL <span class=\"keyword\">import</span> Image</span><br><span class=\"line\">img = Image.<span class=\"built_in\">open</span>(<span class=\"string\">&quot;input.png&quot;</span>)</span><br><span class=\"line\">img.save(<span class=\"string\">&quot;output.jpg&quot;</span>, quality=<span class=\"number\">50</span>)  <span class=\"comment\"># quality&lt;100 会丢失部分细节</span></span><br></pre></td></tr></table></figure>\n\n<p><img src=\"https://gitee.com/tanke11223344/imagehost/raw/main/blog/1749357984852CVRfb86YNohpkSxhCM9cQd6bnOd.png\" alt=\"1749357984852CVRfb86YNohpkSxhCM9cQd6bnOd.png\"></p>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\"># 对比文件体积</span></span><br><span class=\"line\"><span class=\"built_in\">ls</span> -lh input.jpg output.jpg</span><br></pre></td></tr></table></figure>\n\n<p><img src=\"https://gitee.com/tanke11223344/imagehost/raw/main/blog/1749358112853YAcabWie6oudnmxod0bcfX4PntU.png\" alt=\"1749358112853YAcabWie6oudnmxod0bcfX4PntU.png\"></p>\n<p>通过调整 <code>quality</code> 参数，JPEG 有损压缩可在保留较好视觉效果的同时大幅减小文件体积。</p>\n<h4 id=\"OneHot-编码\"><a href=\"#OneHot-编码\" class=\"headerlink\" title=\"OneHot 编码\"></a>OneHot 编码</h4><blockquote>\n<p><a href=\"https://colab.research.google.com/drive/1VpmC-vKrvaFusdNNuaavzvAk2YMhGWrW?usp=sharing(colab)\">https://colab.research.google.com/drive/1VpmC-vKrvaFusdNNuaavzvAk2YMhGWrW?usp=sharing(colab</a> 链接)</p>\n</blockquote>\n<p>One-Hot 编码是一种将分类变量转换为稀疏二进制向量的技术，每个类别对应一个维度，只有所属类别位置为 1，其它位置为 0。</p>\n<h5 id=\"Pandas-实现示例：\"><a href=\"#Pandas-实现示例：\" class=\"headerlink\" title=\"Pandas 实现示例：\"></a><strong>Pandas 实现示例</strong>：</h5><figure class=\"highlight python\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">import</span> pandas <span class=\"keyword\">as</span> pd</span><br><span class=\"line\">df = pd.DataFrame(&#123;<span class=\"string\">&quot;color&quot;</span>: [<span class=\"string\">&quot;red&quot;</span>, <span class=\"string\">&quot;blue&quot;</span>, <span class=\"string\">&quot;green&quot;</span>, <span class=\"string\">&quot;blue&quot;</span>]&#125;)</span><br><span class=\"line\">one_hot = pd.get_dummies(df[<span class=\"string\">&quot;color&quot;</span>], prefix=<span class=\"string\">&quot;color&quot;</span>)</span><br><span class=\"line\"><span class=\"built_in\">print</span>(one_hot)</span><br></pre></td></tr></table></figure>\n\n<figure class=\"highlight mathematica\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"type\">color_blue</span>  <span class=\"type\">color_green</span>  <span class=\"type\">color_red</span></span><br><span class=\"line\"><span class=\"number\">0</span>       <span class=\"built_in\">False</span>        <span class=\"built_in\">False</span>       <span class=\"built_in\">True</span></span><br><span class=\"line\"><span class=\"number\">1</span>        <span class=\"built_in\">True</span>        <span class=\"built_in\">False</span>      <span class=\"built_in\">False</span></span><br><span class=\"line\"><span class=\"number\">2</span>       <span class=\"built_in\">False</span>         <span class=\"built_in\">True</span>      <span class=\"built_in\">False</span></span><br><span class=\"line\"><span class=\"number\">3</span>        <span class=\"built_in\">True</span>        <span class=\"built_in\">False</span>      <span class=\"built_in\">False</span></span><br></pre></td></tr></table></figure>\n\n<p>此方法对小规模类别集非常高效，并集成于 Pandas。</p>\n<h4 id=\"Scikit-Learn-实现示例：\"><a href=\"#Scikit-Learn-实现示例：\" class=\"headerlink\" title=\"Scikit-Learn 实现示例：\"></a><strong>Scikit-Learn 实现示例</strong>：</h4><figure class=\"highlight python\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">from</span> sklearn.preprocessing <span class=\"keyword\">import</span> OneHotEncoder</span><br><span class=\"line\">enc = OneHotEncoder(sparse=<span class=\"literal\">False</span>)</span><br><span class=\"line\">X = enc.fit_transform(df[[<span class=\"string\">&quot;color&quot;</span>]])</span><br><span class=\"line\"><span class=\"built_in\">print</span>(X)</span><br></pre></td></tr></table></figure>\n\n<figure class=\"highlight inform7\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">[<span class=\"comment\">[0. 0. 1.]</span></span></span><br><span class=\"line\"><span class=\"comment\"> <span class=\"comment\">[1. 0. 0.]</span></span></span><br><span class=\"line\"><span class=\"comment\"> <span class=\"comment\">[0. 1. 0.]</span></span></span><br><span class=\"line\"><span class=\"comment\"> <span class=\"comment\">[1. 0. 0.]</span>]</span></span><br></pre></td></tr></table></figure>\n\n<p><code>OneHotEncoder</code> 支持 <code>handle_unknown</code> 参数，用于处理训练外出现的新类别。</p>\n<hr>\n<h4 id=\"深度学习中数据与模型的二进制存储方法\"><a href=\"#深度学习中数据与模型的二进制存储方法\" class=\"headerlink\" title=\"深度学习中数据与模型的二进制存储方法\"></a>深度学习中数据与模型的二进制存储方法</h4><p>深度学习框架通常使用专门的二进制格式保存模型参数和网络结构，以提高读写性能并节省存储空间。</p>\n<ul>\n<li><strong>PyTorch</strong>：使用 Python 序列化（Pickle）将模型权重保存在 <code>.pt</code> 或 <code>.pth</code> 文件，通常调用 <code>torch.save(model.state_dict(), &#39;model.pth&#39;)</code> 和 <code>model.load_state_dict(torch.load(&#39;model.pth&#39;))</code>。</li>\n<li><strong>TensorFlow</strong>：采用 SavedModel 格式，目录中包含 <code>saved_model.pb</code>（Protobuf 二进制）与 <code>variables</code> 检查点文件，使用 <code>model.save(&#39;path&#39;)</code> 和 <code>tf.keras.models.load_model(&#39;path&#39;)</code> 进行读写。</li>\n<li><strong>安全张量（safetensors）</strong>：新兴格式，提供比 Pickle 更强的安全性与加载性能，示例：</li>\n</ul>\n<figure class=\"highlight python\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">import</span> safetensors.torch <span class=\"keyword\">as</span> st</span><br><span class=\"line\">st.save_file(model.state_dict(), <span class=\"string\">&quot;model.safetensors&quot;</span>)</span><br></pre></td></tr></table></figure>\n\n<p>此外，ONNX（Open Neural Network Exchange）以 Protobuf 二进制保存跨框架模型结构与权重，易于在不同平台间互操作。</p>\n<h4 id=\"CSS-等设计方面的颜色编码\"><a href=\"#CSS-等设计方面的颜色编码\" class=\"headerlink\" title=\"CSS 等设计方面的颜色编码\"></a>CSS 等设计方面的颜色编码</h4><p>在前端设计中，颜色可通过多种编码表示，最常见的是 十六进制（Hex）、RGB(A) 与 <strong>HSL(A)</strong> 格式。</p>\n<ul>\n<li><strong>Hex</strong>：<code>#RRGGBB</code> 或简写 <code>#RGB</code>，例如 <code>#ff00aa</code>。</li>\n<li><strong>RGB</strong>：<code>rgb(255,0,170)</code>，可加透明度：<code>rgba(255,0,170,0.5)</code>。</li>\n<li><strong>HSL</strong>：<code>hsl(320,100%,50%)</code>，直观调节色相、饱和度、亮度。</li>\n</ul>\n<p><strong>CSS 示例</strong>：</p>\n<figure class=\"highlight css\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"selector-class\">.button</span> &#123;</span><br><span class=\"line\">  <span class=\"attribute\">background</span>: <span class=\"number\">#3498db</span>;           <span class=\"comment\">/* Hex */</span></span><br><span class=\"line\">  <span class=\"attribute\">color</span>: <span class=\"built_in\">rgb</span>(<span class=\"number\">255</span>, <span class=\"number\">255</span>, <span class=\"number\">255</span>);     <span class=\"comment\">/* RGB */</span></span><br><span class=\"line\">  <span class=\"attribute\">border-color</span>: <span class=\"built_in\">hsl</span>(<span class=\"number\">200</span>, <span class=\"number\">70%</span>, <span class=\"number\">50%</span>); <span class=\"comment\">/* HSL */</span></span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p><strong>JavaScript 转换示例</strong>：</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// Hex to RGB</span></span><br><span class=\"line\"><span class=\"keyword\">function</span> <span class=\"title function_\">hexToRgb</span>(<span class=\"params\">hex</span>) &#123;</span><br><span class=\"line\">  <span class=\"keyword\">let</span> m = hex.<span class=\"title function_\">match</span>(<span class=\"regexp\">/^#?([A-F\\d]&#123;2&#125;)([A-F\\d]&#123;2&#125;)([A-F\\d]&#123;2&#125;)$/i</span>);</span><br><span class=\"line\">  <span class=\"keyword\">if</span> (!m) <span class=\"keyword\">return</span> <span class=\"literal\">null</span>;</span><br><span class=\"line\">  <span class=\"keyword\">return</span> &#123;</span><br><span class=\"line\">    <span class=\"attr\">r</span>: <span class=\"built_in\">parseInt</span>(m[<span class=\"number\">1</span>], <span class=\"number\">16</span>),</span><br><span class=\"line\">    <span class=\"attr\">g</span>: <span class=\"built_in\">parseInt</span>(m[<span class=\"number\">2</span>], <span class=\"number\">16</span>),</span><br><span class=\"line\">    <span class=\"attr\">b</span>: <span class=\"built_in\">parseInt</span>(m[<span class=\"number\">3</span>], <span class=\"number\">16</span>)</span><br><span class=\"line\">  &#125;;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"variable language_\">console</span>.<span class=\"title function_\">log</span>(<span class=\"title function_\">hexToRgb</span>(<span class=\"string\">&quot;#ff00aa&quot;</span>)); <span class=\"comment\">// &#123;r:255, g:0, b:170&#125;</span></span><br></pre></td></tr></table></figure>\n\n<h4 id=\"计算机网络-ip-地址\"><a href=\"#计算机网络-ip-地址\" class=\"headerlink\" title=\"计算机网络 ip 地址\"></a>计算机网络 ip 地址</h4><blockquote>\n<p><a href=\"https://zhuanlan.zhihu.com/p/50091071\">计算机网络（一）基本概念（IP,子网掩码,默认网关,DNS）</a><br><a href=\"https://blog.csdn.net/m0_45406092/article/details/118526894\">【计算机网络】IP 协议、IP 地址、网段划分、子网划分、子网掩码、CIDR_ip cidr-CSDN 博客</a><br><a href=\"https://zhuanlan.zhihu.com/p/537410069\">IP 地址、子网掩码、网关、DNS 之间的关系</a></p>\n</blockquote>\n<p><img src=\"https://gitee.com/tanke11223344/imagehost/raw/main/blog/1749358083853UllubbF2foHWwFxXFVOcMncxnLh.png\" alt=\"1749358083853UllubbF2foHWwFxXFVOcMncxnLh.png\"><br><img src=\"https://gitee.com/tanke11223344/imagehost/raw/main/blog/1749358068852MhlQbzAfxoR7YQxGKqYcRIvEnQb.png\" alt=\"1749358068852MhlQbzAfxoR7YQxGKqYcRIvEnQb.png\"></p>\n<p>IP 地址、子网掩码、默认网关与 DNS 协同完成局域网与互联网互联：</p>\n<ul>\n<li><strong>IP 地址</strong>：标识主机在子网中的唯一地址，如 <code>192.168.1.10/24</code>。</li>\n<li><strong>子网掩码</strong>：如 <code>255.255.255.0</code>（&#x2F;24），用于划分网络号与主机号。</li>\n<li><strong>默认网关</strong>：同子网内路由器接口地址，负责跨网段转发，如 <code>192.168.1.1</code>。</li>\n<li><strong>DNS</strong>：域名解析服务器，将域名映射至 IP（如 <code>8.8.8.8</code>）。</li>\n</ul>\n<ol>\n<li><strong>ipaddress 计算示例</strong>：</li>\n</ol>\n<blockquote>\n<ul>\n<li><a href=\"https://colab.research.google.com/drive/1rXH5_RbucvYiemz9kz4mfqlx1Uz3DWA2?usp=sharing(colab)\">https://colab.research.google.com/drive/1rXH5_RbucvYiemz9kz4mfqlx1Uz3DWA2?usp&#x3D;sharing(colab</a> 链接)</li>\n</ul>\n</blockquote>\n<figure class=\"highlight python\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">import</span> ipaddress</span><br><span class=\"line\"></span><br><span class=\"line\">net = ipaddress.ip_network(<span class=\"string\">&quot;192.168.1.10/24&quot;</span>, strict=<span class=\"literal\">False</span>)</span><br><span class=\"line\"><span class=\"built_in\">print</span>(<span class=\"string\">&quot;网络地址:&quot;</span>, net.network_address)</span><br><span class=\"line\"><span class=\"built_in\">print</span>(<span class=\"string\">&quot;广播地址:&quot;</span>, net.broadcast_address)</span><br><span class=\"line\"><span class=\"built_in\">print</span>(<span class=\"string\">&quot;可用主机:&quot;</span>, <span class=\"built_in\">list</span>(net.hosts())[:<span class=\"number\">3</span>], <span class=\"string\">&quot;…共&quot;</span>, net.num_addresses - <span class=\"number\">2</span>)</span><br></pre></td></tr></table></figure>\n\n<p><img src=\"https://gitee.com/tanke11223344/imagehost/raw/main/blog/1749358051852DGQZbu2FIoQK8txaq98c7aD8nCe.png\" alt=\"1749358051852DGQZbu2FIoQK8txaq98c7aD8nCe.png\"></p>\n"},{"title":"2025-03-17-构造函数与析构函数","date":"2025-03-16T16:00:00.000Z","_content":"> 参考博客\n>\n> [C++ 构造函数的三种写法](https://zhuanlan.zhihu.com/p/168787937)\n\n> [C++ 类构造函数 &amp; 析构函数 | 菜鸟教程](https://www.runoob.com/cplusplus/cpp-constructor-destructor.html)\n\n在 CPP 中，类的构造函数是类的一种特殊的成员函数，它会在每次创建类的新对象时执行。\n\n构造函数的名称与类的名称是完全相同的，并且不会返回任何类型，也不会返回 void。构造函数可用于为某些成员变量设置初始值。\n\n# Motivation\n\n![17421968151641742196814832.png](https://tk-pichost-1325224430.cos.ap-chengdu.myqcloud.com/blog/17421968151641742196814832.png)\n\n# Concept\n\n![17421968291641742196828888.png](https://tk-pichost-1325224430.cos.ap-chengdu.myqcloud.com/blog/17421968291641742196828888.png)\n\n# Method\n\n- 函数重载：C++ 允许构造函数重载，即一个类可以有多个构造函数，每个构造函数的参数列表不同。这允许对象以不同的方式被初始化。\n- 成员初始化列表：在构造函数中，可以使用成员初始化列表来初始化类的成员变量。这种方式比在构造函数体内赋值更高效，因为它直接在对象创建时初始化成员变量。\n- 默认构造函数：如果用户没有定义任何构造函数，编译器会自动生成一个默认构造函数，它不执行任何操作。如果需要，用户也可以显式定义一个默认构造函数。\n- 构造函数的调用：当创建对象时，构造函数会被自动调用。如果对象是通过直接调用 `new` 操作符创建的，那么在分配内存后，构造函数会被调用以初始化对象。\n\n# 知识点\n\n## 构造函数\n\n```cpp\nclass ClassName {\npublic:\n    // 默认构造函数\n    ClassName() {\n        // 初始化代码\n    }\n\n    // 带参数的构造函数\n    ClassName(Type1 param1, Type2 param2) {\n        // 初始化代码，使用参数\n    }\n\n    // 成员初始化列表\n    ClassName(Type1 param1, Type2 param2) : member1(param1), member2(param2) {\n        // 其他初始化代码\n    }\n};\n```\n\n### 特点\n\n- 与类同名，没有返回类型。\n- 可以重载（Overload），以支持不同的初始化方式。\n- 默认情况下，编译器会生成默认构造函数，如果用户没有定义任何构造函数。\n\n## 析构函数\n\n类的析构函数是类的一种特殊的成员函数，它会在每次删除所创建的对象时执行,用于清理对象在销毁前需要释放的资源。\n\n析构函数的名称与类的名称是完全相同的，只是在前面加了个波浪号（~）作为前缀，它不会返回任何值，也不能带有任何参数。析构函数有助于在跳出程序（比如关闭文件、释放内存等）前释放资源。\n\n```cpp\nclass ClassName {\npublic:\n    // 析构函数\n    ~ClassName() {\n        // 清理代码\n    }\n};\n```\n\n### 特点\n\n- 与类同名，前面加波浪号（~），没有参数，没有返回类型。\n\n> 析构函数不能有参数,因为如果析构函数可以有参数，那么在对象销毁时，就必须提供这些参数，这在逻辑上是不合理的，因为对象正在被销毁，无法再提供额外的信息。\n\n- 不能重载。\n- 默认情况下，编译器会生成默认析构函数，如果用户没有定义任何析构函数。\n\n## 成员初始化列表\n\n成员初始化列表是一种在构造函数体内初始化类成员变量的方式。\n\n```cpp\nLine::Line( double len): length(len)\n{\n    cout << \"Object is being created, length = \" << len << endl;\n}\n```\n\n```cpp\nLine::Line( double len)\n{\n    length = len;\n    cout << \"Object is being created, length = \" << len << endl;\n}\n```\n\n```cpp\nC::C( double a, double b, double c): X(a), Y(b), Z(c)\n{\n  ....\n}\n```\n\n### 特点\n\n- 更高效的初始化方式，特别是在初始化常量成员或引用成员时。\n- 直接在构造函数调用前初始化成员变量。\n\n# 示例\n\n```cpp\n#include <iostream>\n#include <string>\n\nusing namespace std;\n\nclass MyComputer\n{\npublic:\n    ~MyComputer();_                                  // 这是析构函数声明_\n    MyComputer(string cpu, string gpu, int memory);_ // 这是构造函数声明_\n    string get_cpu();_                               // 获取CPU信息_\n    string get_gpu();_                               // 获取GPU信息_\n    int get_memory();_                               // 获取内存信息_\n\nprivate:\n    string cpu;\n    string gpu;\n    int memory;\n};\n\n_// 成员函数定义，包括构造函数_\nMyComputer::MyComputer(string cpu, string gpu, int memory) : cpu(cpu), gpu(gpu), memory(memory)\n{\n    cout << \"Computer is being created\" << endl;\n    cout << \"CPU: \" << cpu << endl;\n    cout << \"GPU: \" << gpu << endl;\n    cout << \"Memory: \" << memory << \"GB\" << endl;\n}\n\nMyComputer::~MyComputer()\n{\n    cout << \"Computer is being destroyed\" << endl;\n}\n\nstring MyComputer::get_cpu()\n{\n    return cpu;\n}\n\nstring MyComputer::get_gpu()\n{\n    return gpu;\n}\n\nint MyComputer::get_memory()\n{\n    return memory;\n}\n\nint main()\n{\n    MyComputer computer(\"Intel 13600kf\", \"NVIDIA RTX 4060Ti\", 16);\n    cout << \"CPU: \" << computer.get_cpu() << endl;\n    cout << \"GPU: \" << computer.get_gpu() << endl;\n    cout << \"Memory: \" << computer.get_memory() << \"GB\" << endl;\n\n    return 0;\n}\n```\n\n1. 定义一个类 `MyComputer`：\n\n   - 用于模拟计算机的属性，包括 CPU、GPU 和内存。\n   - 包含构造函数和析构函数，分别在对象创建和销毁时执行。\n2. 构造函数：\n\n   - 初始化计算机的属性（CPU、GPU 和内存）。\n   - 输出创建计算机时的属性信息。\n3. 析构函数：\n\n   - 在对象销毁时输出提示信息，表示计算机被销毁。\n4. 成员函数：\n\n   - 提供 `get_cpu()`、`get_gpu()` 和 `get_memory()` 函数，用于获取计算机的属性值。\n5. 主函数 `main()`：\n\n   - 创建一个 `MyComputer` 对象，传入 CPU、GPU 和内存参数。\n   - 调用成员函数获取并输出计算机的属性。\n   - 程序结束时，对象自动销毁，触发析构函数。\n\n# 思考\n\n说白了,构造函数就是对象在创建时执行的函数,析构函数就是在对应删除时执行的函数\n\n对于使用 new 和 delete 关键字构建的动态对应,在执行对应的代码的时候会自动调用对应的构造和析构函数\n","source":"_posts/2025-03-17-构造函数与析构函数.md","raw":"---\ntitle: 2025-03-17-构造函数与析构函数\ndate: 2025-03-17\ntags: 程序开发\n---\n> 参考博客\n>\n> [C++ 构造函数的三种写法](https://zhuanlan.zhihu.com/p/168787937)\n\n> [C++ 类构造函数 &amp; 析构函数 | 菜鸟教程](https://www.runoob.com/cplusplus/cpp-constructor-destructor.html)\n\n在 CPP 中，类的构造函数是类的一种特殊的成员函数，它会在每次创建类的新对象时执行。\n\n构造函数的名称与类的名称是完全相同的，并且不会返回任何类型，也不会返回 void。构造函数可用于为某些成员变量设置初始值。\n\n# Motivation\n\n![17421968151641742196814832.png](https://tk-pichost-1325224430.cos.ap-chengdu.myqcloud.com/blog/17421968151641742196814832.png)\n\n# Concept\n\n![17421968291641742196828888.png](https://tk-pichost-1325224430.cos.ap-chengdu.myqcloud.com/blog/17421968291641742196828888.png)\n\n# Method\n\n- 函数重载：C++ 允许构造函数重载，即一个类可以有多个构造函数，每个构造函数的参数列表不同。这允许对象以不同的方式被初始化。\n- 成员初始化列表：在构造函数中，可以使用成员初始化列表来初始化类的成员变量。这种方式比在构造函数体内赋值更高效，因为它直接在对象创建时初始化成员变量。\n- 默认构造函数：如果用户没有定义任何构造函数，编译器会自动生成一个默认构造函数，它不执行任何操作。如果需要，用户也可以显式定义一个默认构造函数。\n- 构造函数的调用：当创建对象时，构造函数会被自动调用。如果对象是通过直接调用 `new` 操作符创建的，那么在分配内存后，构造函数会被调用以初始化对象。\n\n# 知识点\n\n## 构造函数\n\n```cpp\nclass ClassName {\npublic:\n    // 默认构造函数\n    ClassName() {\n        // 初始化代码\n    }\n\n    // 带参数的构造函数\n    ClassName(Type1 param1, Type2 param2) {\n        // 初始化代码，使用参数\n    }\n\n    // 成员初始化列表\n    ClassName(Type1 param1, Type2 param2) : member1(param1), member2(param2) {\n        // 其他初始化代码\n    }\n};\n```\n\n### 特点\n\n- 与类同名，没有返回类型。\n- 可以重载（Overload），以支持不同的初始化方式。\n- 默认情况下，编译器会生成默认构造函数，如果用户没有定义任何构造函数。\n\n## 析构函数\n\n类的析构函数是类的一种特殊的成员函数，它会在每次删除所创建的对象时执行,用于清理对象在销毁前需要释放的资源。\n\n析构函数的名称与类的名称是完全相同的，只是在前面加了个波浪号（~）作为前缀，它不会返回任何值，也不能带有任何参数。析构函数有助于在跳出程序（比如关闭文件、释放内存等）前释放资源。\n\n```cpp\nclass ClassName {\npublic:\n    // 析构函数\n    ~ClassName() {\n        // 清理代码\n    }\n};\n```\n\n### 特点\n\n- 与类同名，前面加波浪号（~），没有参数，没有返回类型。\n\n> 析构函数不能有参数,因为如果析构函数可以有参数，那么在对象销毁时，就必须提供这些参数，这在逻辑上是不合理的，因为对象正在被销毁，无法再提供额外的信息。\n\n- 不能重载。\n- 默认情况下，编译器会生成默认析构函数，如果用户没有定义任何析构函数。\n\n## 成员初始化列表\n\n成员初始化列表是一种在构造函数体内初始化类成员变量的方式。\n\n```cpp\nLine::Line( double len): length(len)\n{\n    cout << \"Object is being created, length = \" << len << endl;\n}\n```\n\n```cpp\nLine::Line( double len)\n{\n    length = len;\n    cout << \"Object is being created, length = \" << len << endl;\n}\n```\n\n```cpp\nC::C( double a, double b, double c): X(a), Y(b), Z(c)\n{\n  ....\n}\n```\n\n### 特点\n\n- 更高效的初始化方式，特别是在初始化常量成员或引用成员时。\n- 直接在构造函数调用前初始化成员变量。\n\n# 示例\n\n```cpp\n#include <iostream>\n#include <string>\n\nusing namespace std;\n\nclass MyComputer\n{\npublic:\n    ~MyComputer();_                                  // 这是析构函数声明_\n    MyComputer(string cpu, string gpu, int memory);_ // 这是构造函数声明_\n    string get_cpu();_                               // 获取CPU信息_\n    string get_gpu();_                               // 获取GPU信息_\n    int get_memory();_                               // 获取内存信息_\n\nprivate:\n    string cpu;\n    string gpu;\n    int memory;\n};\n\n_// 成员函数定义，包括构造函数_\nMyComputer::MyComputer(string cpu, string gpu, int memory) : cpu(cpu), gpu(gpu), memory(memory)\n{\n    cout << \"Computer is being created\" << endl;\n    cout << \"CPU: \" << cpu << endl;\n    cout << \"GPU: \" << gpu << endl;\n    cout << \"Memory: \" << memory << \"GB\" << endl;\n}\n\nMyComputer::~MyComputer()\n{\n    cout << \"Computer is being destroyed\" << endl;\n}\n\nstring MyComputer::get_cpu()\n{\n    return cpu;\n}\n\nstring MyComputer::get_gpu()\n{\n    return gpu;\n}\n\nint MyComputer::get_memory()\n{\n    return memory;\n}\n\nint main()\n{\n    MyComputer computer(\"Intel 13600kf\", \"NVIDIA RTX 4060Ti\", 16);\n    cout << \"CPU: \" << computer.get_cpu() << endl;\n    cout << \"GPU: \" << computer.get_gpu() << endl;\n    cout << \"Memory: \" << computer.get_memory() << \"GB\" << endl;\n\n    return 0;\n}\n```\n\n1. 定义一个类 `MyComputer`：\n\n   - 用于模拟计算机的属性，包括 CPU、GPU 和内存。\n   - 包含构造函数和析构函数，分别在对象创建和销毁时执行。\n2. 构造函数：\n\n   - 初始化计算机的属性（CPU、GPU 和内存）。\n   - 输出创建计算机时的属性信息。\n3. 析构函数：\n\n   - 在对象销毁时输出提示信息，表示计算机被销毁。\n4. 成员函数：\n\n   - 提供 `get_cpu()`、`get_gpu()` 和 `get_memory()` 函数，用于获取计算机的属性值。\n5. 主函数 `main()`：\n\n   - 创建一个 `MyComputer` 对象，传入 CPU、GPU 和内存参数。\n   - 调用成员函数获取并输出计算机的属性。\n   - 程序结束时，对象自动销毁，触发析构函数。\n\n# 思考\n\n说白了,构造函数就是对象在创建时执行的函数,析构函数就是在对应删除时执行的函数\n\n对于使用 new 和 delete 关键字构建的动态对应,在执行对应的代码的时候会自动调用对应的构造和析构函数\n","slug":"2025-03-17-构造函数与析构函数","published":1,"updated":"2025-09-26T12:16:22.047Z","_id":"cmg0saj420016jm8nc7to1duv","comments":1,"layout":"post","photos":[],"content":"<blockquote>\n<p>参考博客</p>\n<p><a href=\"https://zhuanlan.zhihu.com/p/168787937\">C++ 构造函数的三种写法</a></p>\n</blockquote>\n<blockquote>\n<p><a href=\"https://www.runoob.com/cplusplus/cpp-constructor-destructor.html\">C++ 类构造函数 &amp; 析构函数 | 菜鸟教程</a></p>\n</blockquote>\n<p>在 CPP 中，类的构造函数是类的一种特殊的成员函数，它会在每次创建类的新对象时执行。</p>\n<p>构造函数的名称与类的名称是完全相同的，并且不会返回任何类型，也不会返回 void。构造函数可用于为某些成员变量设置初始值。</p>\n<h1 id=\"Motivation\"><a href=\"#Motivation\" class=\"headerlink\" title=\"Motivation\"></a>Motivation</h1><p><img src=\"https://tk-pichost-1325224430.cos.ap-chengdu.myqcloud.com/blog/17421968151641742196814832.png\" alt=\"17421968151641742196814832.png\"></p>\n<h1 id=\"Concept\"><a href=\"#Concept\" class=\"headerlink\" title=\"Concept\"></a>Concept</h1><p><img src=\"https://tk-pichost-1325224430.cos.ap-chengdu.myqcloud.com/blog/17421968291641742196828888.png\" alt=\"17421968291641742196828888.png\"></p>\n<h1 id=\"Method\"><a href=\"#Method\" class=\"headerlink\" title=\"Method\"></a>Method</h1><ul>\n<li>函数重载：C++ 允许构造函数重载，即一个类可以有多个构造函数，每个构造函数的参数列表不同。这允许对象以不同的方式被初始化。</li>\n<li>成员初始化列表：在构造函数中，可以使用成员初始化列表来初始化类的成员变量。这种方式比在构造函数体内赋值更高效，因为它直接在对象创建时初始化成员变量。</li>\n<li>默认构造函数：如果用户没有定义任何构造函数，编译器会自动生成一个默认构造函数，它不执行任何操作。如果需要，用户也可以显式定义一个默认构造函数。</li>\n<li>构造函数的调用：当创建对象时，构造函数会被自动调用。如果对象是通过直接调用 <code>new</code> 操作符创建的，那么在分配内存后，构造函数会被调用以初始化对象。</li>\n</ul>\n<h1 id=\"知识点\"><a href=\"#知识点\" class=\"headerlink\" title=\"知识点\"></a>知识点</h1><h2 id=\"构造函数\"><a href=\"#构造函数\" class=\"headerlink\" title=\"构造函数\"></a>构造函数</h2><figure class=\"highlight cpp\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">class</span> <span class=\"title class_\">ClassName</span> &#123;</span><br><span class=\"line\"><span class=\"keyword\">public</span>:</span><br><span class=\"line\">    <span class=\"comment\">// 默认构造函数</span></span><br><span class=\"line\">    <span class=\"built_in\">ClassName</span>() &#123;</span><br><span class=\"line\">        <span class=\"comment\">// 初始化代码</span></span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\">// 带参数的构造函数</span></span><br><span class=\"line\">    <span class=\"built_in\">ClassName</span>(Type1 param1, Type2 param2) &#123;</span><br><span class=\"line\">        <span class=\"comment\">// 初始化代码，使用参数</span></span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\">// 成员初始化列表</span></span><br><span class=\"line\">    <span class=\"built_in\">ClassName</span>(Type1 param1, Type2 param2) : <span class=\"built_in\">member1</span>(param1), <span class=\"built_in\">member2</span>(param2) &#123;</span><br><span class=\"line\">        <span class=\"comment\">// 其他初始化代码</span></span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;;</span><br></pre></td></tr></table></figure>\n\n<h3 id=\"特点\"><a href=\"#特点\" class=\"headerlink\" title=\"特点\"></a>特点</h3><ul>\n<li>与类同名，没有返回类型。</li>\n<li>可以重载（Overload），以支持不同的初始化方式。</li>\n<li>默认情况下，编译器会生成默认构造函数，如果用户没有定义任何构造函数。</li>\n</ul>\n<h2 id=\"析构函数\"><a href=\"#析构函数\" class=\"headerlink\" title=\"析构函数\"></a>析构函数</h2><p>类的析构函数是类的一种特殊的成员函数，它会在每次删除所创建的对象时执行,用于清理对象在销毁前需要释放的资源。</p>\n<p>析构函数的名称与类的名称是完全相同的，只是在前面加了个波浪号（~）作为前缀，它不会返回任何值，也不能带有任何参数。析构函数有助于在跳出程序（比如关闭文件、释放内存等）前释放资源。</p>\n<figure class=\"highlight cpp\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">class</span> <span class=\"title class_\">ClassName</span> &#123;</span><br><span class=\"line\"><span class=\"keyword\">public</span>:</span><br><span class=\"line\">    <span class=\"comment\">// 析构函数</span></span><br><span class=\"line\">    ~<span class=\"built_in\">ClassName</span>() &#123;</span><br><span class=\"line\">        <span class=\"comment\">// 清理代码</span></span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;;</span><br></pre></td></tr></table></figure>\n\n<h3 id=\"特点-1\"><a href=\"#特点-1\" class=\"headerlink\" title=\"特点\"></a>特点</h3><ul>\n<li>与类同名，前面加波浪号（~），没有参数，没有返回类型。</li>\n</ul>\n<blockquote>\n<p>析构函数不能有参数,因为如果析构函数可以有参数，那么在对象销毁时，就必须提供这些参数，这在逻辑上是不合理的，因为对象正在被销毁，无法再提供额外的信息。</p>\n</blockquote>\n<ul>\n<li>不能重载。</li>\n<li>默认情况下，编译器会生成默认析构函数，如果用户没有定义任何析构函数。</li>\n</ul>\n<h2 id=\"成员初始化列表\"><a href=\"#成员初始化列表\" class=\"headerlink\" title=\"成员初始化列表\"></a>成员初始化列表</h2><p>成员初始化列表是一种在构造函数体内初始化类成员变量的方式。</p>\n<figure class=\"highlight cpp\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">Line::<span class=\"built_in\">Line</span>( <span class=\"type\">double</span> len): <span class=\"built_in\">length</span>(len)</span><br><span class=\"line\">&#123;</span><br><span class=\"line\">    cout &lt;&lt; <span class=\"string\">&quot;Object is being created, length = &quot;</span> &lt;&lt; len &lt;&lt; endl;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<figure class=\"highlight cpp\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">Line::<span class=\"built_in\">Line</span>( <span class=\"type\">double</span> len)</span><br><span class=\"line\">&#123;</span><br><span class=\"line\">    length = len;</span><br><span class=\"line\">    cout &lt;&lt; <span class=\"string\">&quot;Object is being created, length = &quot;</span> &lt;&lt; len &lt;&lt; endl;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<figure class=\"highlight cpp\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">C::<span class=\"built_in\">C</span>( <span class=\"type\">double</span> a, <span class=\"type\">double</span> b, <span class=\"type\">double</span> c): <span class=\"built_in\">X</span>(a), <span class=\"built_in\">Y</span>(b), <span class=\"built_in\">Z</span>(c)</span><br><span class=\"line\">&#123;</span><br><span class=\"line\">  ....</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<h3 id=\"特点-2\"><a href=\"#特点-2\" class=\"headerlink\" title=\"特点\"></a>特点</h3><ul>\n<li>更高效的初始化方式，特别是在初始化常量成员或引用成员时。</li>\n<li>直接在构造函数调用前初始化成员变量。</li>\n</ul>\n<h1 id=\"示例\"><a href=\"#示例\" class=\"headerlink\" title=\"示例\"></a>示例</h1><figure class=\"highlight cpp\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br><span class=\"line\">47</span><br><span class=\"line\">48</span><br><span class=\"line\">49</span><br><span class=\"line\">50</span><br><span class=\"line\">51</span><br><span class=\"line\">52</span><br><span class=\"line\">53</span><br><span class=\"line\">54</span><br><span class=\"line\">55</span><br><span class=\"line\">56</span><br><span class=\"line\">57</span><br><span class=\"line\">58</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">#<span class=\"keyword\">include</span> <span class=\"string\">&lt;iostream&gt;</span></span></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"keyword\">include</span> <span class=\"string\">&lt;string&gt;</span></span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">using</span> <span class=\"keyword\">namespace</span> std;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">class</span> <span class=\"title class_\">MyComputer</span></span><br><span class=\"line\">&#123;</span><br><span class=\"line\"><span class=\"keyword\">public</span>:</span><br><span class=\"line\">    ~<span class=\"built_in\">MyComputer</span>();_                                  <span class=\"comment\">// 这是析构函数声明_</span></span><br><span class=\"line\">    <span class=\"built_in\">MyComputer</span>(string cpu, string gpu, <span class=\"type\">int</span> memory);_ <span class=\"comment\">// 这是构造函数声明_</span></span><br><span class=\"line\">    <span class=\"function\">string <span class=\"title\">get_cpu</span><span class=\"params\">()</span></span>;_                               <span class=\"comment\">// 获取CPU信息_</span></span><br><span class=\"line\">    <span class=\"function\">string <span class=\"title\">get_gpu</span><span class=\"params\">()</span></span>;_                               <span class=\"comment\">// 获取GPU信息_</span></span><br><span class=\"line\">    <span class=\"function\"><span class=\"type\">int</span> <span class=\"title\">get_memory</span><span class=\"params\">()</span></span>;_                               <span class=\"comment\">// 获取内存信息_</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">private</span>:</span><br><span class=\"line\">    string cpu;</span><br><span class=\"line\">    string gpu;</span><br><span class=\"line\">    <span class=\"type\">int</span> memory;</span><br><span class=\"line\">&#125;;</span><br><span class=\"line\"></span><br><span class=\"line\">_<span class=\"comment\">// 成员函数定义，包括构造函数_</span></span><br><span class=\"line\">MyComputer::<span class=\"built_in\">MyComputer</span>(string cpu, string gpu, <span class=\"type\">int</span> memory) : <span class=\"built_in\">cpu</span>(cpu), <span class=\"built_in\">gpu</span>(gpu), <span class=\"built_in\">memory</span>(memory)</span><br><span class=\"line\">&#123;</span><br><span class=\"line\">    cout &lt;&lt; <span class=\"string\">&quot;Computer is being created&quot;</span> &lt;&lt; endl;</span><br><span class=\"line\">    cout &lt;&lt; <span class=\"string\">&quot;CPU: &quot;</span> &lt;&lt; cpu &lt;&lt; endl;</span><br><span class=\"line\">    cout &lt;&lt; <span class=\"string\">&quot;GPU: &quot;</span> &lt;&lt; gpu &lt;&lt; endl;</span><br><span class=\"line\">    cout &lt;&lt; <span class=\"string\">&quot;Memory: &quot;</span> &lt;&lt; memory &lt;&lt; <span class=\"string\">&quot;GB&quot;</span> &lt;&lt; endl;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">MyComputer::~<span class=\"built_in\">MyComputer</span>()</span><br><span class=\"line\">&#123;</span><br><span class=\"line\">    cout &lt;&lt; <span class=\"string\">&quot;Computer is being destroyed&quot;</span> &lt;&lt; endl;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\">string <span class=\"title\">MyComputer::get_cpu</span><span class=\"params\">()</span></span></span><br><span class=\"line\"><span class=\"function\"></span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> cpu;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\">string <span class=\"title\">MyComputer::get_gpu</span><span class=\"params\">()</span></span></span><br><span class=\"line\"><span class=\"function\"></span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> gpu;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"type\">int</span> <span class=\"title\">MyComputer::get_memory</span><span class=\"params\">()</span></span></span><br><span class=\"line\"><span class=\"function\"></span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> memory;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"type\">int</span> <span class=\"title\">main</span><span class=\"params\">()</span></span></span><br><span class=\"line\"><span class=\"function\"></span>&#123;</span><br><span class=\"line\">    <span class=\"function\">MyComputer <span class=\"title\">computer</span><span class=\"params\">(<span class=\"string\">&quot;Intel 13600kf&quot;</span>, <span class=\"string\">&quot;NVIDIA RTX 4060Ti&quot;</span>, <span class=\"number\">16</span>)</span></span>;</span><br><span class=\"line\">    cout &lt;&lt; <span class=\"string\">&quot;CPU: &quot;</span> &lt;&lt; computer.<span class=\"built_in\">get_cpu</span>() &lt;&lt; endl;</span><br><span class=\"line\">    cout &lt;&lt; <span class=\"string\">&quot;GPU: &quot;</span> &lt;&lt; computer.<span class=\"built_in\">get_gpu</span>() &lt;&lt; endl;</span><br><span class=\"line\">    cout &lt;&lt; <span class=\"string\">&quot;Memory: &quot;</span> &lt;&lt; computer.<span class=\"built_in\">get_memory</span>() &lt;&lt; <span class=\"string\">&quot;GB&quot;</span> &lt;&lt; endl;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">return</span> <span class=\"number\">0</span>;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<ol>\n<li><p>定义一个类 <code>MyComputer</code>：</p>\n<ul>\n<li>用于模拟计算机的属性，包括 CPU、GPU 和内存。</li>\n<li>包含构造函数和析构函数，分别在对象创建和销毁时执行。</li>\n</ul>\n</li>\n<li><p>构造函数：</p>\n<ul>\n<li>初始化计算机的属性（CPU、GPU 和内存）。</li>\n<li>输出创建计算机时的属性信息。</li>\n</ul>\n</li>\n<li><p>析构函数：</p>\n<ul>\n<li>在对象销毁时输出提示信息，表示计算机被销毁。</li>\n</ul>\n</li>\n<li><p>成员函数：</p>\n<ul>\n<li>提供 <code>get_cpu()</code>、<code>get_gpu()</code> 和 <code>get_memory()</code> 函数，用于获取计算机的属性值。</li>\n</ul>\n</li>\n<li><p>主函数 <code>main()</code>：</p>\n<ul>\n<li>创建一个 <code>MyComputer</code> 对象，传入 CPU、GPU 和内存参数。</li>\n<li>调用成员函数获取并输出计算机的属性。</li>\n<li>程序结束时，对象自动销毁，触发析构函数。</li>\n</ul>\n</li>\n</ol>\n<h1 id=\"思考\"><a href=\"#思考\" class=\"headerlink\" title=\"思考\"></a>思考</h1><p>说白了,构造函数就是对象在创建时执行的函数,析构函数就是在对应删除时执行的函数</p>\n<p>对于使用 new 和 delete 关键字构建的动态对应,在执行对应的代码的时候会自动调用对应的构造和析构函数</p>\n","excerpt":"","more":"<blockquote>\n<p>参考博客</p>\n<p><a href=\"https://zhuanlan.zhihu.com/p/168787937\">C++ 构造函数的三种写法</a></p>\n</blockquote>\n<blockquote>\n<p><a href=\"https://www.runoob.com/cplusplus/cpp-constructor-destructor.html\">C++ 类构造函数 &amp; 析构函数 | 菜鸟教程</a></p>\n</blockquote>\n<p>在 CPP 中，类的构造函数是类的一种特殊的成员函数，它会在每次创建类的新对象时执行。</p>\n<p>构造函数的名称与类的名称是完全相同的，并且不会返回任何类型，也不会返回 void。构造函数可用于为某些成员变量设置初始值。</p>\n<h1 id=\"Motivation\"><a href=\"#Motivation\" class=\"headerlink\" title=\"Motivation\"></a>Motivation</h1><p><img src=\"https://tk-pichost-1325224430.cos.ap-chengdu.myqcloud.com/blog/17421968151641742196814832.png\" alt=\"17421968151641742196814832.png\"></p>\n<h1 id=\"Concept\"><a href=\"#Concept\" class=\"headerlink\" title=\"Concept\"></a>Concept</h1><p><img src=\"https://tk-pichost-1325224430.cos.ap-chengdu.myqcloud.com/blog/17421968291641742196828888.png\" alt=\"17421968291641742196828888.png\"></p>\n<h1 id=\"Method\"><a href=\"#Method\" class=\"headerlink\" title=\"Method\"></a>Method</h1><ul>\n<li>函数重载：C++ 允许构造函数重载，即一个类可以有多个构造函数，每个构造函数的参数列表不同。这允许对象以不同的方式被初始化。</li>\n<li>成员初始化列表：在构造函数中，可以使用成员初始化列表来初始化类的成员变量。这种方式比在构造函数体内赋值更高效，因为它直接在对象创建时初始化成员变量。</li>\n<li>默认构造函数：如果用户没有定义任何构造函数，编译器会自动生成一个默认构造函数，它不执行任何操作。如果需要，用户也可以显式定义一个默认构造函数。</li>\n<li>构造函数的调用：当创建对象时，构造函数会被自动调用。如果对象是通过直接调用 <code>new</code> 操作符创建的，那么在分配内存后，构造函数会被调用以初始化对象。</li>\n</ul>\n<h1 id=\"知识点\"><a href=\"#知识点\" class=\"headerlink\" title=\"知识点\"></a>知识点</h1><h2 id=\"构造函数\"><a href=\"#构造函数\" class=\"headerlink\" title=\"构造函数\"></a>构造函数</h2><figure class=\"highlight cpp\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">class</span> <span class=\"title class_\">ClassName</span> &#123;</span><br><span class=\"line\"><span class=\"keyword\">public</span>:</span><br><span class=\"line\">    <span class=\"comment\">// 默认构造函数</span></span><br><span class=\"line\">    <span class=\"built_in\">ClassName</span>() &#123;</span><br><span class=\"line\">        <span class=\"comment\">// 初始化代码</span></span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\">// 带参数的构造函数</span></span><br><span class=\"line\">    <span class=\"built_in\">ClassName</span>(Type1 param1, Type2 param2) &#123;</span><br><span class=\"line\">        <span class=\"comment\">// 初始化代码，使用参数</span></span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\">// 成员初始化列表</span></span><br><span class=\"line\">    <span class=\"built_in\">ClassName</span>(Type1 param1, Type2 param2) : <span class=\"built_in\">member1</span>(param1), <span class=\"built_in\">member2</span>(param2) &#123;</span><br><span class=\"line\">        <span class=\"comment\">// 其他初始化代码</span></span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;;</span><br></pre></td></tr></table></figure>\n\n<h3 id=\"特点\"><a href=\"#特点\" class=\"headerlink\" title=\"特点\"></a>特点</h3><ul>\n<li>与类同名，没有返回类型。</li>\n<li>可以重载（Overload），以支持不同的初始化方式。</li>\n<li>默认情况下，编译器会生成默认构造函数，如果用户没有定义任何构造函数。</li>\n</ul>\n<h2 id=\"析构函数\"><a href=\"#析构函数\" class=\"headerlink\" title=\"析构函数\"></a>析构函数</h2><p>类的析构函数是类的一种特殊的成员函数，它会在每次删除所创建的对象时执行,用于清理对象在销毁前需要释放的资源。</p>\n<p>析构函数的名称与类的名称是完全相同的，只是在前面加了个波浪号（~）作为前缀，它不会返回任何值，也不能带有任何参数。析构函数有助于在跳出程序（比如关闭文件、释放内存等）前释放资源。</p>\n<figure class=\"highlight cpp\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">class</span> <span class=\"title class_\">ClassName</span> &#123;</span><br><span class=\"line\"><span class=\"keyword\">public</span>:</span><br><span class=\"line\">    <span class=\"comment\">// 析构函数</span></span><br><span class=\"line\">    ~<span class=\"built_in\">ClassName</span>() &#123;</span><br><span class=\"line\">        <span class=\"comment\">// 清理代码</span></span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;;</span><br></pre></td></tr></table></figure>\n\n<h3 id=\"特点-1\"><a href=\"#特点-1\" class=\"headerlink\" title=\"特点\"></a>特点</h3><ul>\n<li>与类同名，前面加波浪号（~），没有参数，没有返回类型。</li>\n</ul>\n<blockquote>\n<p>析构函数不能有参数,因为如果析构函数可以有参数，那么在对象销毁时，就必须提供这些参数，这在逻辑上是不合理的，因为对象正在被销毁，无法再提供额外的信息。</p>\n</blockquote>\n<ul>\n<li>不能重载。</li>\n<li>默认情况下，编译器会生成默认析构函数，如果用户没有定义任何析构函数。</li>\n</ul>\n<h2 id=\"成员初始化列表\"><a href=\"#成员初始化列表\" class=\"headerlink\" title=\"成员初始化列表\"></a>成员初始化列表</h2><p>成员初始化列表是一种在构造函数体内初始化类成员变量的方式。</p>\n<figure class=\"highlight cpp\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">Line::<span class=\"built_in\">Line</span>( <span class=\"type\">double</span> len): <span class=\"built_in\">length</span>(len)</span><br><span class=\"line\">&#123;</span><br><span class=\"line\">    cout &lt;&lt; <span class=\"string\">&quot;Object is being created, length = &quot;</span> &lt;&lt; len &lt;&lt; endl;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<figure class=\"highlight cpp\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">Line::<span class=\"built_in\">Line</span>( <span class=\"type\">double</span> len)</span><br><span class=\"line\">&#123;</span><br><span class=\"line\">    length = len;</span><br><span class=\"line\">    cout &lt;&lt; <span class=\"string\">&quot;Object is being created, length = &quot;</span> &lt;&lt; len &lt;&lt; endl;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<figure class=\"highlight cpp\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">C::<span class=\"built_in\">C</span>( <span class=\"type\">double</span> a, <span class=\"type\">double</span> b, <span class=\"type\">double</span> c): <span class=\"built_in\">X</span>(a), <span class=\"built_in\">Y</span>(b), <span class=\"built_in\">Z</span>(c)</span><br><span class=\"line\">&#123;</span><br><span class=\"line\">  ....</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<h3 id=\"特点-2\"><a href=\"#特点-2\" class=\"headerlink\" title=\"特点\"></a>特点</h3><ul>\n<li>更高效的初始化方式，特别是在初始化常量成员或引用成员时。</li>\n<li>直接在构造函数调用前初始化成员变量。</li>\n</ul>\n<h1 id=\"示例\"><a href=\"#示例\" class=\"headerlink\" title=\"示例\"></a>示例</h1><figure class=\"highlight cpp\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br><span class=\"line\">47</span><br><span class=\"line\">48</span><br><span class=\"line\">49</span><br><span class=\"line\">50</span><br><span class=\"line\">51</span><br><span class=\"line\">52</span><br><span class=\"line\">53</span><br><span class=\"line\">54</span><br><span class=\"line\">55</span><br><span class=\"line\">56</span><br><span class=\"line\">57</span><br><span class=\"line\">58</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">#<span class=\"keyword\">include</span> <span class=\"string\">&lt;iostream&gt;</span></span></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"keyword\">include</span> <span class=\"string\">&lt;string&gt;</span></span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">using</span> <span class=\"keyword\">namespace</span> std;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">class</span> <span class=\"title class_\">MyComputer</span></span><br><span class=\"line\">&#123;</span><br><span class=\"line\"><span class=\"keyword\">public</span>:</span><br><span class=\"line\">    ~<span class=\"built_in\">MyComputer</span>();_                                  <span class=\"comment\">// 这是析构函数声明_</span></span><br><span class=\"line\">    <span class=\"built_in\">MyComputer</span>(string cpu, string gpu, <span class=\"type\">int</span> memory);_ <span class=\"comment\">// 这是构造函数声明_</span></span><br><span class=\"line\">    <span class=\"function\">string <span class=\"title\">get_cpu</span><span class=\"params\">()</span></span>;_                               <span class=\"comment\">// 获取CPU信息_</span></span><br><span class=\"line\">    <span class=\"function\">string <span class=\"title\">get_gpu</span><span class=\"params\">()</span></span>;_                               <span class=\"comment\">// 获取GPU信息_</span></span><br><span class=\"line\">    <span class=\"function\"><span class=\"type\">int</span> <span class=\"title\">get_memory</span><span class=\"params\">()</span></span>;_                               <span class=\"comment\">// 获取内存信息_</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">private</span>:</span><br><span class=\"line\">    string cpu;</span><br><span class=\"line\">    string gpu;</span><br><span class=\"line\">    <span class=\"type\">int</span> memory;</span><br><span class=\"line\">&#125;;</span><br><span class=\"line\"></span><br><span class=\"line\">_<span class=\"comment\">// 成员函数定义，包括构造函数_</span></span><br><span class=\"line\">MyComputer::<span class=\"built_in\">MyComputer</span>(string cpu, string gpu, <span class=\"type\">int</span> memory) : <span class=\"built_in\">cpu</span>(cpu), <span class=\"built_in\">gpu</span>(gpu), <span class=\"built_in\">memory</span>(memory)</span><br><span class=\"line\">&#123;</span><br><span class=\"line\">    cout &lt;&lt; <span class=\"string\">&quot;Computer is being created&quot;</span> &lt;&lt; endl;</span><br><span class=\"line\">    cout &lt;&lt; <span class=\"string\">&quot;CPU: &quot;</span> &lt;&lt; cpu &lt;&lt; endl;</span><br><span class=\"line\">    cout &lt;&lt; <span class=\"string\">&quot;GPU: &quot;</span> &lt;&lt; gpu &lt;&lt; endl;</span><br><span class=\"line\">    cout &lt;&lt; <span class=\"string\">&quot;Memory: &quot;</span> &lt;&lt; memory &lt;&lt; <span class=\"string\">&quot;GB&quot;</span> &lt;&lt; endl;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">MyComputer::~<span class=\"built_in\">MyComputer</span>()</span><br><span class=\"line\">&#123;</span><br><span class=\"line\">    cout &lt;&lt; <span class=\"string\">&quot;Computer is being destroyed&quot;</span> &lt;&lt; endl;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\">string <span class=\"title\">MyComputer::get_cpu</span><span class=\"params\">()</span></span></span><br><span class=\"line\"><span class=\"function\"></span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> cpu;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\">string <span class=\"title\">MyComputer::get_gpu</span><span class=\"params\">()</span></span></span><br><span class=\"line\"><span class=\"function\"></span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> gpu;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"type\">int</span> <span class=\"title\">MyComputer::get_memory</span><span class=\"params\">()</span></span></span><br><span class=\"line\"><span class=\"function\"></span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> memory;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"type\">int</span> <span class=\"title\">main</span><span class=\"params\">()</span></span></span><br><span class=\"line\"><span class=\"function\"></span>&#123;</span><br><span class=\"line\">    <span class=\"function\">MyComputer <span class=\"title\">computer</span><span class=\"params\">(<span class=\"string\">&quot;Intel 13600kf&quot;</span>, <span class=\"string\">&quot;NVIDIA RTX 4060Ti&quot;</span>, <span class=\"number\">16</span>)</span></span>;</span><br><span class=\"line\">    cout &lt;&lt; <span class=\"string\">&quot;CPU: &quot;</span> &lt;&lt; computer.<span class=\"built_in\">get_cpu</span>() &lt;&lt; endl;</span><br><span class=\"line\">    cout &lt;&lt; <span class=\"string\">&quot;GPU: &quot;</span> &lt;&lt; computer.<span class=\"built_in\">get_gpu</span>() &lt;&lt; endl;</span><br><span class=\"line\">    cout &lt;&lt; <span class=\"string\">&quot;Memory: &quot;</span> &lt;&lt; computer.<span class=\"built_in\">get_memory</span>() &lt;&lt; <span class=\"string\">&quot;GB&quot;</span> &lt;&lt; endl;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">return</span> <span class=\"number\">0</span>;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<ol>\n<li><p>定义一个类 <code>MyComputer</code>：</p>\n<ul>\n<li>用于模拟计算机的属性，包括 CPU、GPU 和内存。</li>\n<li>包含构造函数和析构函数，分别在对象创建和销毁时执行。</li>\n</ul>\n</li>\n<li><p>构造函数：</p>\n<ul>\n<li>初始化计算机的属性（CPU、GPU 和内存）。</li>\n<li>输出创建计算机时的属性信息。</li>\n</ul>\n</li>\n<li><p>析构函数：</p>\n<ul>\n<li>在对象销毁时输出提示信息，表示计算机被销毁。</li>\n</ul>\n</li>\n<li><p>成员函数：</p>\n<ul>\n<li>提供 <code>get_cpu()</code>、<code>get_gpu()</code> 和 <code>get_memory()</code> 函数，用于获取计算机的属性值。</li>\n</ul>\n</li>\n<li><p>主函数 <code>main()</code>：</p>\n<ul>\n<li>创建一个 <code>MyComputer</code> 对象，传入 CPU、GPU 和内存参数。</li>\n<li>调用成员函数获取并输出计算机的属性。</li>\n<li>程序结束时，对象自动销毁，触发析构函数。</li>\n</ul>\n</li>\n</ol>\n<h1 id=\"思考\"><a href=\"#思考\" class=\"headerlink\" title=\"思考\"></a>思考</h1><p>说白了,构造函数就是对象在创建时执行的函数,析构函数就是在对应删除时执行的函数</p>\n<p>对于使用 new 和 delete 关键字构建的动态对应,在执行对应的代码的时候会自动调用对应的构造和析构函数</p>\n"},{"title":"2025-04-22-X86 架构与 Arm 架构异同及应用","date":"2025-04-21T16:00:00.000Z","_content":"# X86 架构与 Arm 架构异同及应用\n\n# 参考资料\n\n> - [一文看懂 arm 架构和 x86 架构有什么区别_arm 架构和 x86 架构区别-CSDN 博客](https://blog.csdn.net/bleauchat/article/details/90114342)\n> - [CPU 架构解析：ARM 和 x86 大比拼-阿里云开发者社区](https://developer.aliyun.com/article/197450)\n> - [arm 和 x86 的差别和应用场景学习笔记_x86 arm-CSDN 博客](https://blog.csdn.net/xie__jin__cheng/article/details/139521805)\n> - [ARM 与 x86 架构对比：从编程视角解析](https://cloud.tencent.com/developer/article/2435910)\n> - [CPU 架构解析 ARM 和 X86 对比](https://developer.aliyun.com/article/197450)\n> - [X86 与 ARM 架构解析及适用场景](https://cloud.baidu.com/article/3053639)\n> - [CPU_X86 架构和 ARM 架构入门篇](https://cloud.tencent.com/developer/article/1862717)\n\n# X86 和 Arm 架构概述\n\n![1749359870854RkcXbu05koZn7HxFjc4ce6DDnLe.png](https://gitee.com/tanke11223344/imagehost/raw/main/blog/1749359870854RkcXbu05koZn7HxFjc4ce6DDnLe.png)\n\nX86 使用复杂指令集（CISC），能耗较高，适合桌面和服务器的高性能需求。Arm 使用精简指令集（RISC），能耗低，广泛应用于移动设备和嵌入式系统，近年在服务器市场也有增长。两者的相似点是均为处理器架构，差异在于指令集和能耗，应用场景分别聚焦高性能计算和能效优化。\n\nX86 使用复杂指令集计算机（CISC）架构，指令丰富，可单指令完成复杂操作，如数据移动和乘法，适合高性能需求，但能耗较高。Arm 使用精简指令集计算机（RISC）架构，指令简单，执行快，能耗低，适合移动设备和嵌入式系统。两者的相似点是均为处理器架构，核心目标是执行计算任务。\n\n应用上，X86 常见于桌面电脑、笔记本和服务器，如 Intel 和 AMD 处理器主导市场。Arm 广泛用于智能手机、平板和嵌入式设备，近年在服务器市场增长，如 AWS Graviton 和 Azure Arm 实例。\n\n## 重温 CPU\n\n[CPU-GPU-NPU 的区别及应用前景](https://xcnx25vdviba.feishu.cn/wiki/T0cAw3jICiAjwsk4PELcOeqlnQf)\n\n中央处理单元(CPU)主要由运算器、控制器、寄存器三部分组成，从字面意思看运算器就是起着运算的作用，控制器就是负责发出 CPU 每条指令所需要的信息，寄存器就是保存运算或者指令的一些临时文件，这样可以保证更高的速度。\n\n![1749359884852Upt5bc7HsoFuPBxbOJ8cODcFnbh.png](https://gitee.com/tanke11223344/imagehost/raw/main/blog/1749359884852Upt5bc7HsoFuPBxbOJ8cODcFnbh.png)\n![1749359896852DBeSbnX0doa7o0xG1ZOcHb7Xnxh.png](https://gitee.com/tanke11223344/imagehost/raw/main/blog/1749359896852DBeSbnX0doa7o0xG1ZOcHb7Xnxh.png)\n\nCPU 有着处理指令、执行操作、控制时间、处理数据四大作用，打个比喻来说，CPU 就像我们的大脑，帮我们完成各种各样的生理活动。如果没有 CPU，那么电脑将无法工作。\n\n![1749359907852HFXKbuFRko0HR0xk7XeckQ6Pnoh.png](https://gitee.com/tanke11223344/imagehost/raw/main/blog/1749359907852HFXKbuFRko0HR0xk7XeckQ6Pnoh.png)\n\n移动设备其实很复杂，这些 CPU 需要执行数以百万计的指示，才能使它向我们期待的方向运行，而 CPU 的速度和功率效率是至关重要的。速度影响用户体验，而效率影响电池寿命。最完美的移动设备是高性能和低功耗相结合。\n\n## **CISC 与 RISC 指令集**\n\n要了解 X86 和 ARM，就得先了解复杂指令集(CISC)和精简指令集(RISC) ,从 CPU 发明到现在，有非常多种架构，从我们熟悉的 X86、ARM，到不太熟悉的 MIPS、IA64，它们之间的差距都非常大。但是如果从最基本的逻辑角度来分类的话，它们可以被分为两大类，即所谓的“复杂指令集”与“精简指令集”系统，也就是经常看到的“CISC”与“RISC”。\n\n所谓指令集，是 CPU 中用来计算和控制计算机系统的一套指令的集合。指令的强弱是 CPU 的重要指标，指令集是提高微处理器效率的最有效工具之一。\n\nIntel 和 ARM 处理器的第一个区别是，前者使用复杂指令集(CISC)，而后者使用精简指令集(RISC)。属于这两种类中的各种架构之间最大的区别，在于它们的设计者考虑问题方式的不同。\n\n### RISC 与 CISC：指令集架构的核心差异\n\nRISC (精简指令集) 和 CISC (复杂指令集) 的主要区别在于它们追求的 **指令执行时长**，而非指令本身的复杂性。\n\n- **RISC:** 力求在 **单个机器周期** 内完成一条指令。\n- **CISC:** 一条指令可能需要多个机器周期完成。\n\n### 一个例子类比\n\n**让我们来拿“启动汽车”做类比：**\n\n- **CISC:** 一条指令完成所有步骤，如 `启动汽车`。处理器内部负责所有细节。\n- **RISC:** 需要多条简单指令，如：\n\n  1. `插入钥匙指令`\n  2. `点火指令`\n  3. `踩油门指令`\n\n#### **编程示例 (乘法操作 **`MUL A, B`**)：**\n\n- **CISC:**\n\n```assembly\nMUL A, B  ; 一条指令完成乘法\n```\n\n处理器内部操作：\n\n1. 从内存加载 `A` 到寄存器。\n2. 从内存加载 `B` 到寄存器。\n3. ALU 执行乘法。\n4. 将结果写回内存。\n\n- **RISC:**\n\n```assembly\nLOAD RA, A   ; 从内存读取数据 A\nLOAD RB, B   ; 从内存读取数据 B\nPROD RA, RB  ; 计算两者乘积\nSTORE A, RA  ; 将寄存器中的结果写回内存\n```\n\n**对比分析：**\n\n**总结：**\n\n- **CISC:** 以少量复杂指令完成任务，对程序员更友好，但硬件实现复杂，功耗相对较高。\n- **RISC:** 以大量简单指令完成任务，硬件实现简单，功耗较低，更利于编译器优化。\n\n现代 CPU 架构在发展中也相互借鉴，例如一些 CISC 架构的处理器内部也会将复杂指令分解为更小的微指令执行，以提高效率。\n\n> **题外:**\n> 因为当年选择 CISC 是因为程序员都在写汇编，如果用汇编的话 CISC 可以接近高级语言的那样直接调用一个复杂指令处理一个复杂步骤，而 RISC 就要把每个复杂步骤拆成一大堆简单指令来写，所以开发时间长。现在大家全都在用高级语言了，高度抽象，根本不需要关心汇编级别的代码，这些都由编译器自动高效优化了，比人工优化还厉害得多，所以 CISC 这个开发时间的优势也基本没了，最多就是对一些接触硬件底层的操作系统和驱动程序的开发者而言更加方便。\n> 现在的 Intel 和 amd 的 x64 架构，都是先通过一个翻译层把复杂指令拆解为精简指令，然后再进流水线的。真的复杂指令集都没法做流水线调度优化，从 intel 开始搞流水线后，真的用电路做复杂指令的时代就结束了。\n\n## X86 架构\n\n> [X86 架构解析及指令模拟流程 - Edver - 博客](https://www.cnblogs.com/edver/p/15460077.html)\n\nx86 服务器最大的特色在于可以兼容 Windows 操作系统，全部都采用了 Intel 的 CPU。而 Intel 的 x86 服务器也可以分为两代，最初采用的 80x86 系列在发布了产品 80486 后，Intel 对该系列产品进行了重新命名并注册，这也就是现在 Intel 的 Pentium 系列，当然，这个系列在中国还有个更响亮的名字，即奔腾系列。\n\n目前奔腾系列的 CPU 包括：Pentium、Pentium MMX、Pentium Pro、PII、PII Xeon(至强)、PIII、PIII Xeon、P4 Xeon、Celeron2(赛扬)等。\n\n## Arm 架构\n\nARM 架构是一个精简指令集(RISC)处理器架构，其广泛地使用在许多嵌入式系统设计。由于节能的特点，ARM 处理器非常适用于移动通讯领域，符合其主要设计目标为低耗电的特性。应用领域包含手机、PAD、导航系统、网络设备等都是 ARM 架构，目前世界上使用最广泛的 CPU 就是 ARM。\n\n![1749359919853BIXRbuBL5oTBnJxUCyGcVC9AnPg.png](https://gitee.com/tanke11223344/imagehost/raw/main/blog/1749359919853BIXRbuBL5oTBnJxUCyGcVC9AnPg.png)\n\n基于 arm 芯片的树莓派 5\n\n### big.LITTLE 架构\n\n异构计算 ARM 的 big.LITTLE 架构是一项 Intel 一时无法复制的创新。在 big.LITTLE 架构里，处理器可以是不同类型的。传统的双核或者四核处理器中包含同样的 2 个核或者 4 个核。一个双核 Atom 处理器中有两个一模一样的核，提供一样的性能，拥有相同的功耗。ARM 通过 big.LITTLE 向移动设备推出了异构计算。这意味着处理器中的核可以有不同的性能和功耗。当设备正常运行时，使用低功耗核，而当你运行一款复杂的游戏时，使用的是高性能的核。\n\n![1749359928852BvSabLGyBopLqexsogqcHyDonQd.png](https://gitee.com/tanke11223344/imagehost/raw/main/blog/1749359928852BvSabLGyBopLqexsogqcHyDonQd.png)\n\n这是什么做到的呢?设计处理器的时候，要考虑大量的技术设计的采用与否，这些技术设计决定了处理器的性能以及功耗。在一条指令被解码并准备执行时，Intel 和 ARM 的处理器都使用流水线，就是说解码的过程是并行的。\n\n为了更快地执行指令，这些流水线可以被设计成允许指令们不按照程序的顺序被执行(乱序执行)。一些巧妙的逻辑结构可以判断下一条指令是否依赖于当前的指令执行的结果。Intel 和 ARM 都提供乱序执行逻辑结构，可想而知，这种结构十分的复杂，复杂意味着更多的功耗。\n\n# X86 和 Arm 架构的比较及应用\n\nX86 和 Arm 都是广泛使用的 CPU 架构，但它们的设计目标和应用场景不同。X86 通常提供更高的单线程性能，适合需要强大计算能力的任务，如视频编辑和科学计算。而 Arm 以低功耗著称，延长了移动设备和 IoT 设备的电池寿命。\n\n<table>\n<tr>\n<td>**方面**<br/></td><td>**X86 (CISC)**<br/></td><td>**Arm (RISC)**<br/></td></tr>\n<tr>\n<td>**指令集类型**<br/></td><td>复杂指令集计算（CISC），指令复杂，每条可执行多个操作，编译器设计较简单，CPU 电路复杂。<br/></td><td>精简指令集计算（RISC），指令简单，每条执行单一操作，CPU 电路较简单，需更多编译器优化。<br/></td></tr>\n<tr>\n<td>**性能与功耗**<br/></td><td>高性能，单线程能力强，适合高强度计算，但功耗高（如 i7 热设计功耗 45W）。<br/></td><td>低功耗，延长电池寿命，单核性能较低，但多核高效（如最大热设计功耗 3W，约为 i7 的 1/15）。<br/></td></tr>\n<tr>\n<td>**应用领域**<br/></td><td>桌面 PC、笔记本、工作站、服务器，特别适合科学计算、游戏渲染、视频编辑。<br/></td><td>智能手机、平板电脑、穿戴设备、IoT、嵌入式系统，近年扩展至服务器和 AI 加速器。<br/></td></tr>\n<tr>\n<td>**软件生态**<br/></td><td>成熟，Windows 和遗留应用广泛支持，软件大多为 X86 编译。<br/></td><td>增长中，移动和 Linux 环境强，但运行 X86 软件需模拟或重编译，效率较低。<br/></td></tr>\n<tr>\n<td>**制造与授权**<br/></td><td>由 Intel 和 AMD 生产，架构专有，仅这两家公司制造 CPU。<br/></td><td>Arm Holdings 设计并授权（如高通、苹果），允许定制化，制造由多家公司完成。<br/></td></tr>\n<tr>\n<td>**扩展性与未来趋势**<br/></td><td>通过增加核心数和时钟频率提升性能，扩展性好，但功耗挑战大。<br/></td><td>依赖多核提升性能，扩展受功耗限制，服务器和 AI 领域增长，定制化优势明显。<br/></td></tr>\n<tr>\n<td>**64 位计算**<br/></td><td>x86-64（AMD 设计），IA64 为 Itanium，但 x86-64 更普及，无原生 32 位到 64 位转换。<br/></td><td>ARMv8（2011）支持 AArch32/AArch64，切换无缝，向下兼容。<br/></td></tr>\n<tr>\n<td>**异构计算**<br/></td><td>传统双核/四核，性能和功耗一致，无 big.LITTLE。<br/></td><td>big.LITTLE 架构，低功耗核和高性能核组合，适合动态负载（如游戏时高性能）。<br/></td></tr>\n</table>\n\n## 设计理念与应用领域\n\nx86 架构起源于 1978 年的 Intel 8086 处理器，采用复杂指令集（CISC），目标是提供丰富的指令以简化编程，强调高性能与通用性，广泛应用于桌面 PC、笔记本以及服务器市场。\n\nARM 架构最早于 1985 年推出，基于精简指令集（RISC）设计，强调指令简洁、高速流水线及低功耗，主要面向移动设备与嵌入式系统，如智能手机、平板、智能手表以及各类 IoT 设备。\n\n由于设计目标不同，x86 与 ARM 在微架构设计上也存在显著区别：x86 侧重加强单核性能与兼容性，ARM 则以减少指令周期、提高能效为核心。\n\n## 指令集与硬件架构\n\n### 寄存器与流水线\n\n在寄存器设计方面，x86 64 位处理器通常提供 16 个通用寄存器（RAX、RBX、RCX 等）以及多组寄存器别名（如 EAX、AX、AL）以支持兼容旧体系，与此对应还有段寄存器、浮点寄存器等多级寄存器层级，给予程序员更灵活的寻址与缓存管理能力，但也导致硬件设计更复杂。\n\n与此不同，ARM 通常提供 16 个通用寄存器（R0–R15，其中 R15 为程序计数器 PC），并辅以状态寄存器 CPSR（Current Program Status Register），指令与数据寄存器结构相对简单，减少寄存器寻址延迟，有利于流水线深度扩展与超标量处理设计，从而在多核并行时更易实现高能效比。\n\n### 寻址模式与内存模型\n\nx86 架构支持多种复杂寻址模式，包括基址寻址（Base + Displacement）、索引加变址（Base + Index + Displacement）、相对寻址等，能够灵活处理多维数组与复杂数据结构，但同时也增加了 CPU 内部译码与执行单元的负担。\n\n相比之下，ARM 的内存模型较为简化，通常只支持寄存器间接寻址（Register Indirect）、偏移寻址（Register ± Offset）或基址 + 索引的简化形式，这大幅降低了解析与译码难度，从而配合深度流水线实现更高的指令吞吐率，但也意味着在某些特定场景下编译器需额外展开循环以模拟复杂寻址。\n\n## 性能、功耗与工艺制程\n\n### 性能对比\n\nx86 架构历经数十年发展，采用先进的制造工艺（如 5nm、7nm、10nm 制程），并通过深度流水线、乱序执行、分支预测与多级缓存等技术最大化提升单核性能。高端桌面与服务器级 CPU（如 Intel Core、AMD Ryzen、Intel Xeon、AMD EPYC）频率可达 3GHz–5GHz，拥有多达数十核（部分数据中心处理器甚至超过 64 核），在高性能计算、科学计算及游戏渲染等场景中表现卓越。然而，这种高性能也伴随着较高功耗，一颗满载状态的桌面级 CPU 功耗往往超过 100W。\n\nARM 架构在移动与嵌入式领域更为常见，代表性处理器如 Qualcomm Snapdragon、Apple A 系列（M1/M2 属 ARM 架构衍生）、Samsung Exynos 等，多采用 5nm–7nm 制程，单核主频通常在 2GHz–3GHz 范围，但通过多核与集成 GPU、NPU 协同工作实现系统级性能优化。例如，Apple M1 采用 ARM v8-架构，凭借高度集成与高效能核心设计，在多线程和单线程性能上均接近甚至超过同级 x86 芯片，同时功耗显著低于常规移动处理器。在低负载场景下，ARM 还可动态调整频率与电压，从而达到更低功耗和更长续航时间。\n\n### 功耗与能效\n\nARM 之所以在移动与嵌入式场景占据主导地位，核心在于其低功耗特性。ARM 处理器简化的指令集与硬件结构使其在执行相同指令时所需晶体管数量更少，从而减少了静态功耗与动态功耗；结合大规模集成、片上系统（SoC）设计，将 CPU、GPU、DSP 甚至 NPU 等模块集成在同一芯片中，进一步降低了数据传输带来的能耗开销。典型移动 ARM SoC 满载功耗常在 5W–15W 之间，而台式 x86 CPU 则常常在 65W–125W 范围内。在边缘或手持设备应用中，ARM 架构的这类优势尤为关键，能够在满足性能需求的同时延长电池续航。\n\n### 工艺制程与制造成本\n\nx86 厂商（Intel、AMD）自研高端制程节点（如 Intel 7nm、5nm 等），但其工艺研发成本极高，且在多次制程节点转型中面临挑战，导致部分型号在新节点推出时出现延迟。\n\nARM 架构本身并不生产芯片，而是由多家代工厂（如 TSMC、Samsung Foundry）依据授权设计进行制造。由于 ARM 架构可灵活授权给多众芯片厂商，使其能够快速采用最新工艺并优化成本。例如，TSMC 的 5nm、3nm 制程已经被多家 ARM SoC 采用，从而在成本与性能方面形成优势。总体来看，x86 芯片由于需要兼顾复杂的 CISC 女性并持续保持向后兼容，因此制造难度与成本远高于简化的 ARM SoC。\n\n---\n\n## 操作系统与生态系统\n\n### 操作系统兼容性\n\nx86 架构自 Windows 95 起与微软操作系统（Windows 系列）紧密绑定，与 Intel/AMD 合作形成了 “Wintel 联盟”，在个人电脑市场形成近 30 年垄断，几乎所有桌面及服务器操作系统（Windows、Linux、Unix、BSD、macOS（Intel 时代）等）都优先支持 x86 芯片，确保了丰富的软件兼容性和庞大的用户群体。\n\n反观 ARM 架构，其早期主要面向嵌入式 Linux 系统，生态相对分散。直到 Google 推出 Android 操作系统后，ARM 平台在移动设备领域实现了操作系统统一，Android、iOS、KaiOS 等主流移动系统也均为 ARM 架构优化，大幅提升了 ARM 生态成熟度。近年来，Apple 通过自研 M1/M2 等芯片将 macOS 从 x86 迁移至 ARM，进一步推动了 ARM 在桌面/笔记本市场的生态建设。\n\n### 软件与工具链\n\nx86 平台拥有成熟的软件工具链，包括 Visual Studio、Intel oneAPI、GCC/Clang 等完善的编译优化器与调试工具；开发者可在 x86 上方便地使用各种 IDE、性能分析器、虚拟化软件等。同时，x86 的庞大市场体量为各类商业软件（如 Adobe 套件、Microsoft Office、Steam 游戏库）提供了全面支持。\n\nARM 生态在早期相对弱势，但随着 Linux 发行版（如 Debian ARM、Ubuntu ARM）、Android SDK、Apple Xcode 等工具链逐步完善，开发者可针对不同 ARM 设备进行交叉编译与仿真调试，也有大量社区维护的调试器、性能分析器和集成开发环境（IDE）可用，如 ARM Development Studio、Keil MDK、VS Code 插件等，这些工具帮助缩短了 ARM 平台开发曲线。\n\n---\n\n## 软件开发与编译方式\n\n### 编译器优化\n\n对于 x86 架构，编译器需针对复杂的 CISC 指令集进行优化，例如采用延迟分支（Delayed Branch）、指令融合（Instruction Fusion）、循环展开（Loop Unrolling）、寄存器重命名（Register Renaming）等技术，以充分利用多级流水线与乱序执行特性，从而达到高 IPC（每周期指令数）水平。\n\nARM 架构则因其指令集简化，流水线更深且执行周期更短，编译器主要侧重于指令调度、寄存器分配与内存对齐优化，确保在有限的芯片面积与寄存器资源下实现高能效性能。\n\n### 跨平台编程\n\n跨平台开发时，针对 x86/ARM 双平台需要分别编译生成对应二进制。对于 C/C++ 应用，常使用 GCC 或 Clang 编译器，分别传入 `-march=x86-64` 或 `-march=armv8-a` 等参数，并链接对应平台的库文件。高级语言如 Java、Python、.NET 等则通过解释器或虚拟机方式实现跨平台：Java 将源代码编译为字节码，依赖各自平台的 JVM；Python 可通过不同架构的解释器运行，但需要注意扩展模块与库需重编译至目标架构。\n\n一些跨平台框架（如 Qt、Electron）也提供封装层，在编译期自动处理架构差异，使得同一套代码能在 x86/ARM 上生成可执行文件。\n\n## 典型应用场景\n\n### x86 常见应用\n\n- **个人电脑与笔记本**：几乎所有台式机与笔记本均采用 x86 处理器，运行 Windows、Linux 等操作系统，适用于办公、游戏、内容创作等多样化场景。\n- **服务器与数据中心**：x86 服务器（如 Intel Xeon、AMD EPYC）在云端与企业级应用中占据绝对主导地位，面向大规模并行计算、高性能数据库、虚拟化、容器化等需求。其睿频与多核设计能支撑高并发网络与 I/O 任务。\n- **高性能计算（HPC）**：通过集群化 x86 芯片结合高速互联（InfiniBand、Omni-Path），支持科学计算、天气预报、基因测序与金融模拟等计算密集型任务。\n\n### ARM 常见应用\n\n- **移动设备**：智能手机、平板电脑几乎全部基于 ARM SoC 设计（如 Qualcomm Snapdragon、Apple A/M 系列、Samsung Exynos），因其能效比高而在续航与发热控制方面具备明显优势。\n- **嵌入式系统与 IoT**：从单片机级 SBC（如 Raspberry Pi、BeagleBone）到智能家居网关、工业控制器，ARM 架构以低功耗与成本优势成为首选；典型应用包括智能家居、工业自动化、物联网传感节点等。\n- **边缘计算与智能摄像头**：搭载 ARM NPU（如华为麒麟 NPU、Qualcomm Hexagon DSP）用于本地 AI 推理，实现实时人脸识别、语音识别、对象检测和智能分析，而无需将大量数据传输到云端，有效节省带宽与降低延迟。\n- **笔记本与轻薄本**：随着 Apple M1/M2 等 ARM 桌面/笔记本 SoC 推出，ARM 架构正逐步进入传统 x86 桌面市场，凭借出色的能效与高度集成逐渐获得开发者与消费者认可。\n\n## 生态系统与社区支持\n\n### x86 生态优势\n\n![1749359942853Gk10bs6vao2zRYxYABccwWMen9e.png](https://gitee.com/tanke11223344/imagehost/raw/main/blog/1749359942853Gk10bs6vao2zRYxYABccwWMen9e.png)\n\nx86 生态已经发展数十年，形成了“硬件 + 操作系统 + 软件工具链 + 应用软件”的完整体系，开发者可方便获取 Visual Studio、Intel oneAPI、AMD ROCm、GCC/Clang 等多种编译器和性能分析工具；在 Linux 生态中，主流发行版（如 Ubuntu、Debian、Fedora、CentOS）均优先支持 x86 平台，并持续优化各类服务器级组件如 Nginx、MySQL、PostgreSQL、Kubernetes 等。此外，x86 社区中堆栈资源丰富，从低层汇编到高层框架，开发者几乎不用担心兼容性问题。\n\n### ARM 生态发展\n\nARM 自身并不生产芯片，而是通过授权模式让多家芯片厂商（如 Qualcomm、Apple、Samsung、Broadcom、MediaTek 等）在同一架构基础上进行差异化创新，使得 ARM 平台在移动与嵌入式领域涌现大量 SoC 设计。随着 Android、iOS 以及各种 Linux 发行版（Debian ARM、Ubuntu ARM）在 ARM 平台上的成熟运行，ARM 生态渐趋完整。开发者可使用交叉编译工具链（如 ARM GCC、LLVM）、集成开发环境（如 VS Code + PlatformIO、Keil MDK、ARM Development Studio）来进行 ARM 平台应用开发，同时还有开源社区维护的性能调优与调试工具（如 perf、gdb-multiarch、OpenOCD）可供选择。\n\n# 总结\n\nx86 在高性能计算与软件兼容性方面具备成熟优势，适用于台式机、服务器与科研计算等对性能要求极高的场景；ARM 则凭借低功耗、强能效、灵活授权等特点，成为移动设备、嵌入式和边缘计算领域的不二之选。随着技术不断演进，ARM 架构也在高性能和服务器市场发力（如 Apple M1/M2、Arm Neoverse 平台），逐渐缩小与 x86 之间的性能差距。未来，x86 与 ARM 将在不同细分市场继续并行发展，开发者应根据应用需求选择合适架构，并灵活运用跨平台编译技术以兼顾性能与能效。\n","source":"_posts/2025-04-22-X86 架构与 Arm 架构异同及应用.md","raw":"---\ntitle:  2025-04-22-X86 架构与 Arm 架构异同及应用\ndate: 2025-04-22\ntags: \n    课程学习\n---\n# X86 架构与 Arm 架构异同及应用\n\n# 参考资料\n\n> - [一文看懂 arm 架构和 x86 架构有什么区别_arm 架构和 x86 架构区别-CSDN 博客](https://blog.csdn.net/bleauchat/article/details/90114342)\n> - [CPU 架构解析：ARM 和 x86 大比拼-阿里云开发者社区](https://developer.aliyun.com/article/197450)\n> - [arm 和 x86 的差别和应用场景学习笔记_x86 arm-CSDN 博客](https://blog.csdn.net/xie__jin__cheng/article/details/139521805)\n> - [ARM 与 x86 架构对比：从编程视角解析](https://cloud.tencent.com/developer/article/2435910)\n> - [CPU 架构解析 ARM 和 X86 对比](https://developer.aliyun.com/article/197450)\n> - [X86 与 ARM 架构解析及适用场景](https://cloud.baidu.com/article/3053639)\n> - [CPU_X86 架构和 ARM 架构入门篇](https://cloud.tencent.com/developer/article/1862717)\n\n# X86 和 Arm 架构概述\n\n![1749359870854RkcXbu05koZn7HxFjc4ce6DDnLe.png](https://gitee.com/tanke11223344/imagehost/raw/main/blog/1749359870854RkcXbu05koZn7HxFjc4ce6DDnLe.png)\n\nX86 使用复杂指令集（CISC），能耗较高，适合桌面和服务器的高性能需求。Arm 使用精简指令集（RISC），能耗低，广泛应用于移动设备和嵌入式系统，近年在服务器市场也有增长。两者的相似点是均为处理器架构，差异在于指令集和能耗，应用场景分别聚焦高性能计算和能效优化。\n\nX86 使用复杂指令集计算机（CISC）架构，指令丰富，可单指令完成复杂操作，如数据移动和乘法，适合高性能需求，但能耗较高。Arm 使用精简指令集计算机（RISC）架构，指令简单，执行快，能耗低，适合移动设备和嵌入式系统。两者的相似点是均为处理器架构，核心目标是执行计算任务。\n\n应用上，X86 常见于桌面电脑、笔记本和服务器，如 Intel 和 AMD 处理器主导市场。Arm 广泛用于智能手机、平板和嵌入式设备，近年在服务器市场增长，如 AWS Graviton 和 Azure Arm 实例。\n\n## 重温 CPU\n\n[CPU-GPU-NPU 的区别及应用前景](https://xcnx25vdviba.feishu.cn/wiki/T0cAw3jICiAjwsk4PELcOeqlnQf)\n\n中央处理单元(CPU)主要由运算器、控制器、寄存器三部分组成，从字面意思看运算器就是起着运算的作用，控制器就是负责发出 CPU 每条指令所需要的信息，寄存器就是保存运算或者指令的一些临时文件，这样可以保证更高的速度。\n\n![1749359884852Upt5bc7HsoFuPBxbOJ8cODcFnbh.png](https://gitee.com/tanke11223344/imagehost/raw/main/blog/1749359884852Upt5bc7HsoFuPBxbOJ8cODcFnbh.png)\n![1749359896852DBeSbnX0doa7o0xG1ZOcHb7Xnxh.png](https://gitee.com/tanke11223344/imagehost/raw/main/blog/1749359896852DBeSbnX0doa7o0xG1ZOcHb7Xnxh.png)\n\nCPU 有着处理指令、执行操作、控制时间、处理数据四大作用，打个比喻来说，CPU 就像我们的大脑，帮我们完成各种各样的生理活动。如果没有 CPU，那么电脑将无法工作。\n\n![1749359907852HFXKbuFRko0HR0xk7XeckQ6Pnoh.png](https://gitee.com/tanke11223344/imagehost/raw/main/blog/1749359907852HFXKbuFRko0HR0xk7XeckQ6Pnoh.png)\n\n移动设备其实很复杂，这些 CPU 需要执行数以百万计的指示，才能使它向我们期待的方向运行，而 CPU 的速度和功率效率是至关重要的。速度影响用户体验，而效率影响电池寿命。最完美的移动设备是高性能和低功耗相结合。\n\n## **CISC 与 RISC 指令集**\n\n要了解 X86 和 ARM，就得先了解复杂指令集(CISC)和精简指令集(RISC) ,从 CPU 发明到现在，有非常多种架构，从我们熟悉的 X86、ARM，到不太熟悉的 MIPS、IA64，它们之间的差距都非常大。但是如果从最基本的逻辑角度来分类的话，它们可以被分为两大类，即所谓的“复杂指令集”与“精简指令集”系统，也就是经常看到的“CISC”与“RISC”。\n\n所谓指令集，是 CPU 中用来计算和控制计算机系统的一套指令的集合。指令的强弱是 CPU 的重要指标，指令集是提高微处理器效率的最有效工具之一。\n\nIntel 和 ARM 处理器的第一个区别是，前者使用复杂指令集(CISC)，而后者使用精简指令集(RISC)。属于这两种类中的各种架构之间最大的区别，在于它们的设计者考虑问题方式的不同。\n\n### RISC 与 CISC：指令集架构的核心差异\n\nRISC (精简指令集) 和 CISC (复杂指令集) 的主要区别在于它们追求的 **指令执行时长**，而非指令本身的复杂性。\n\n- **RISC:** 力求在 **单个机器周期** 内完成一条指令。\n- **CISC:** 一条指令可能需要多个机器周期完成。\n\n### 一个例子类比\n\n**让我们来拿“启动汽车”做类比：**\n\n- **CISC:** 一条指令完成所有步骤，如 `启动汽车`。处理器内部负责所有细节。\n- **RISC:** 需要多条简单指令，如：\n\n  1. `插入钥匙指令`\n  2. `点火指令`\n  3. `踩油门指令`\n\n#### **编程示例 (乘法操作 **`MUL A, B`**)：**\n\n- **CISC:**\n\n```assembly\nMUL A, B  ; 一条指令完成乘法\n```\n\n处理器内部操作：\n\n1. 从内存加载 `A` 到寄存器。\n2. 从内存加载 `B` 到寄存器。\n3. ALU 执行乘法。\n4. 将结果写回内存。\n\n- **RISC:**\n\n```assembly\nLOAD RA, A   ; 从内存读取数据 A\nLOAD RB, B   ; 从内存读取数据 B\nPROD RA, RB  ; 计算两者乘积\nSTORE A, RA  ; 将寄存器中的结果写回内存\n```\n\n**对比分析：**\n\n**总结：**\n\n- **CISC:** 以少量复杂指令完成任务，对程序员更友好，但硬件实现复杂，功耗相对较高。\n- **RISC:** 以大量简单指令完成任务，硬件实现简单，功耗较低，更利于编译器优化。\n\n现代 CPU 架构在发展中也相互借鉴，例如一些 CISC 架构的处理器内部也会将复杂指令分解为更小的微指令执行，以提高效率。\n\n> **题外:**\n> 因为当年选择 CISC 是因为程序员都在写汇编，如果用汇编的话 CISC 可以接近高级语言的那样直接调用一个复杂指令处理一个复杂步骤，而 RISC 就要把每个复杂步骤拆成一大堆简单指令来写，所以开发时间长。现在大家全都在用高级语言了，高度抽象，根本不需要关心汇编级别的代码，这些都由编译器自动高效优化了，比人工优化还厉害得多，所以 CISC 这个开发时间的优势也基本没了，最多就是对一些接触硬件底层的操作系统和驱动程序的开发者而言更加方便。\n> 现在的 Intel 和 amd 的 x64 架构，都是先通过一个翻译层把复杂指令拆解为精简指令，然后再进流水线的。真的复杂指令集都没法做流水线调度优化，从 intel 开始搞流水线后，真的用电路做复杂指令的时代就结束了。\n\n## X86 架构\n\n> [X86 架构解析及指令模拟流程 - Edver - 博客](https://www.cnblogs.com/edver/p/15460077.html)\n\nx86 服务器最大的特色在于可以兼容 Windows 操作系统，全部都采用了 Intel 的 CPU。而 Intel 的 x86 服务器也可以分为两代，最初采用的 80x86 系列在发布了产品 80486 后，Intel 对该系列产品进行了重新命名并注册，这也就是现在 Intel 的 Pentium 系列，当然，这个系列在中国还有个更响亮的名字，即奔腾系列。\n\n目前奔腾系列的 CPU 包括：Pentium、Pentium MMX、Pentium Pro、PII、PII Xeon(至强)、PIII、PIII Xeon、P4 Xeon、Celeron2(赛扬)等。\n\n## Arm 架构\n\nARM 架构是一个精简指令集(RISC)处理器架构，其广泛地使用在许多嵌入式系统设计。由于节能的特点，ARM 处理器非常适用于移动通讯领域，符合其主要设计目标为低耗电的特性。应用领域包含手机、PAD、导航系统、网络设备等都是 ARM 架构，目前世界上使用最广泛的 CPU 就是 ARM。\n\n![1749359919853BIXRbuBL5oTBnJxUCyGcVC9AnPg.png](https://gitee.com/tanke11223344/imagehost/raw/main/blog/1749359919853BIXRbuBL5oTBnJxUCyGcVC9AnPg.png)\n\n基于 arm 芯片的树莓派 5\n\n### big.LITTLE 架构\n\n异构计算 ARM 的 big.LITTLE 架构是一项 Intel 一时无法复制的创新。在 big.LITTLE 架构里，处理器可以是不同类型的。传统的双核或者四核处理器中包含同样的 2 个核或者 4 个核。一个双核 Atom 处理器中有两个一模一样的核，提供一样的性能，拥有相同的功耗。ARM 通过 big.LITTLE 向移动设备推出了异构计算。这意味着处理器中的核可以有不同的性能和功耗。当设备正常运行时，使用低功耗核，而当你运行一款复杂的游戏时，使用的是高性能的核。\n\n![1749359928852BvSabLGyBopLqexsogqcHyDonQd.png](https://gitee.com/tanke11223344/imagehost/raw/main/blog/1749359928852BvSabLGyBopLqexsogqcHyDonQd.png)\n\n这是什么做到的呢?设计处理器的时候，要考虑大量的技术设计的采用与否，这些技术设计决定了处理器的性能以及功耗。在一条指令被解码并准备执行时，Intel 和 ARM 的处理器都使用流水线，就是说解码的过程是并行的。\n\n为了更快地执行指令，这些流水线可以被设计成允许指令们不按照程序的顺序被执行(乱序执行)。一些巧妙的逻辑结构可以判断下一条指令是否依赖于当前的指令执行的结果。Intel 和 ARM 都提供乱序执行逻辑结构，可想而知，这种结构十分的复杂，复杂意味着更多的功耗。\n\n# X86 和 Arm 架构的比较及应用\n\nX86 和 Arm 都是广泛使用的 CPU 架构，但它们的设计目标和应用场景不同。X86 通常提供更高的单线程性能，适合需要强大计算能力的任务，如视频编辑和科学计算。而 Arm 以低功耗著称，延长了移动设备和 IoT 设备的电池寿命。\n\n<table>\n<tr>\n<td>**方面**<br/></td><td>**X86 (CISC)**<br/></td><td>**Arm (RISC)**<br/></td></tr>\n<tr>\n<td>**指令集类型**<br/></td><td>复杂指令集计算（CISC），指令复杂，每条可执行多个操作，编译器设计较简单，CPU 电路复杂。<br/></td><td>精简指令集计算（RISC），指令简单，每条执行单一操作，CPU 电路较简单，需更多编译器优化。<br/></td></tr>\n<tr>\n<td>**性能与功耗**<br/></td><td>高性能，单线程能力强，适合高强度计算，但功耗高（如 i7 热设计功耗 45W）。<br/></td><td>低功耗，延长电池寿命，单核性能较低，但多核高效（如最大热设计功耗 3W，约为 i7 的 1/15）。<br/></td></tr>\n<tr>\n<td>**应用领域**<br/></td><td>桌面 PC、笔记本、工作站、服务器，特别适合科学计算、游戏渲染、视频编辑。<br/></td><td>智能手机、平板电脑、穿戴设备、IoT、嵌入式系统，近年扩展至服务器和 AI 加速器。<br/></td></tr>\n<tr>\n<td>**软件生态**<br/></td><td>成熟，Windows 和遗留应用广泛支持，软件大多为 X86 编译。<br/></td><td>增长中，移动和 Linux 环境强，但运行 X86 软件需模拟或重编译，效率较低。<br/></td></tr>\n<tr>\n<td>**制造与授权**<br/></td><td>由 Intel 和 AMD 生产，架构专有，仅这两家公司制造 CPU。<br/></td><td>Arm Holdings 设计并授权（如高通、苹果），允许定制化，制造由多家公司完成。<br/></td></tr>\n<tr>\n<td>**扩展性与未来趋势**<br/></td><td>通过增加核心数和时钟频率提升性能，扩展性好，但功耗挑战大。<br/></td><td>依赖多核提升性能，扩展受功耗限制，服务器和 AI 领域增长，定制化优势明显。<br/></td></tr>\n<tr>\n<td>**64 位计算**<br/></td><td>x86-64（AMD 设计），IA64 为 Itanium，但 x86-64 更普及，无原生 32 位到 64 位转换。<br/></td><td>ARMv8（2011）支持 AArch32/AArch64，切换无缝，向下兼容。<br/></td></tr>\n<tr>\n<td>**异构计算**<br/></td><td>传统双核/四核，性能和功耗一致，无 big.LITTLE。<br/></td><td>big.LITTLE 架构，低功耗核和高性能核组合，适合动态负载（如游戏时高性能）。<br/></td></tr>\n</table>\n\n## 设计理念与应用领域\n\nx86 架构起源于 1978 年的 Intel 8086 处理器，采用复杂指令集（CISC），目标是提供丰富的指令以简化编程，强调高性能与通用性，广泛应用于桌面 PC、笔记本以及服务器市场。\n\nARM 架构最早于 1985 年推出，基于精简指令集（RISC）设计，强调指令简洁、高速流水线及低功耗，主要面向移动设备与嵌入式系统，如智能手机、平板、智能手表以及各类 IoT 设备。\n\n由于设计目标不同，x86 与 ARM 在微架构设计上也存在显著区别：x86 侧重加强单核性能与兼容性，ARM 则以减少指令周期、提高能效为核心。\n\n## 指令集与硬件架构\n\n### 寄存器与流水线\n\n在寄存器设计方面，x86 64 位处理器通常提供 16 个通用寄存器（RAX、RBX、RCX 等）以及多组寄存器别名（如 EAX、AX、AL）以支持兼容旧体系，与此对应还有段寄存器、浮点寄存器等多级寄存器层级，给予程序员更灵活的寻址与缓存管理能力，但也导致硬件设计更复杂。\n\n与此不同，ARM 通常提供 16 个通用寄存器（R0–R15，其中 R15 为程序计数器 PC），并辅以状态寄存器 CPSR（Current Program Status Register），指令与数据寄存器结构相对简单，减少寄存器寻址延迟，有利于流水线深度扩展与超标量处理设计，从而在多核并行时更易实现高能效比。\n\n### 寻址模式与内存模型\n\nx86 架构支持多种复杂寻址模式，包括基址寻址（Base + Displacement）、索引加变址（Base + Index + Displacement）、相对寻址等，能够灵活处理多维数组与复杂数据结构，但同时也增加了 CPU 内部译码与执行单元的负担。\n\n相比之下，ARM 的内存模型较为简化，通常只支持寄存器间接寻址（Register Indirect）、偏移寻址（Register ± Offset）或基址 + 索引的简化形式，这大幅降低了解析与译码难度，从而配合深度流水线实现更高的指令吞吐率，但也意味着在某些特定场景下编译器需额外展开循环以模拟复杂寻址。\n\n## 性能、功耗与工艺制程\n\n### 性能对比\n\nx86 架构历经数十年发展，采用先进的制造工艺（如 5nm、7nm、10nm 制程），并通过深度流水线、乱序执行、分支预测与多级缓存等技术最大化提升单核性能。高端桌面与服务器级 CPU（如 Intel Core、AMD Ryzen、Intel Xeon、AMD EPYC）频率可达 3GHz–5GHz，拥有多达数十核（部分数据中心处理器甚至超过 64 核），在高性能计算、科学计算及游戏渲染等场景中表现卓越。然而，这种高性能也伴随着较高功耗，一颗满载状态的桌面级 CPU 功耗往往超过 100W。\n\nARM 架构在移动与嵌入式领域更为常见，代表性处理器如 Qualcomm Snapdragon、Apple A 系列（M1/M2 属 ARM 架构衍生）、Samsung Exynos 等，多采用 5nm–7nm 制程，单核主频通常在 2GHz–3GHz 范围，但通过多核与集成 GPU、NPU 协同工作实现系统级性能优化。例如，Apple M1 采用 ARM v8-架构，凭借高度集成与高效能核心设计，在多线程和单线程性能上均接近甚至超过同级 x86 芯片，同时功耗显著低于常规移动处理器。在低负载场景下，ARM 还可动态调整频率与电压，从而达到更低功耗和更长续航时间。\n\n### 功耗与能效\n\nARM 之所以在移动与嵌入式场景占据主导地位，核心在于其低功耗特性。ARM 处理器简化的指令集与硬件结构使其在执行相同指令时所需晶体管数量更少，从而减少了静态功耗与动态功耗；结合大规模集成、片上系统（SoC）设计，将 CPU、GPU、DSP 甚至 NPU 等模块集成在同一芯片中，进一步降低了数据传输带来的能耗开销。典型移动 ARM SoC 满载功耗常在 5W–15W 之间，而台式 x86 CPU 则常常在 65W–125W 范围内。在边缘或手持设备应用中，ARM 架构的这类优势尤为关键，能够在满足性能需求的同时延长电池续航。\n\n### 工艺制程与制造成本\n\nx86 厂商（Intel、AMD）自研高端制程节点（如 Intel 7nm、5nm 等），但其工艺研发成本极高，且在多次制程节点转型中面临挑战，导致部分型号在新节点推出时出现延迟。\n\nARM 架构本身并不生产芯片，而是由多家代工厂（如 TSMC、Samsung Foundry）依据授权设计进行制造。由于 ARM 架构可灵活授权给多众芯片厂商，使其能够快速采用最新工艺并优化成本。例如，TSMC 的 5nm、3nm 制程已经被多家 ARM SoC 采用，从而在成本与性能方面形成优势。总体来看，x86 芯片由于需要兼顾复杂的 CISC 女性并持续保持向后兼容，因此制造难度与成本远高于简化的 ARM SoC。\n\n---\n\n## 操作系统与生态系统\n\n### 操作系统兼容性\n\nx86 架构自 Windows 95 起与微软操作系统（Windows 系列）紧密绑定，与 Intel/AMD 合作形成了 “Wintel 联盟”，在个人电脑市场形成近 30 年垄断，几乎所有桌面及服务器操作系统（Windows、Linux、Unix、BSD、macOS（Intel 时代）等）都优先支持 x86 芯片，确保了丰富的软件兼容性和庞大的用户群体。\n\n反观 ARM 架构，其早期主要面向嵌入式 Linux 系统，生态相对分散。直到 Google 推出 Android 操作系统后，ARM 平台在移动设备领域实现了操作系统统一，Android、iOS、KaiOS 等主流移动系统也均为 ARM 架构优化，大幅提升了 ARM 生态成熟度。近年来，Apple 通过自研 M1/M2 等芯片将 macOS 从 x86 迁移至 ARM，进一步推动了 ARM 在桌面/笔记本市场的生态建设。\n\n### 软件与工具链\n\nx86 平台拥有成熟的软件工具链，包括 Visual Studio、Intel oneAPI、GCC/Clang 等完善的编译优化器与调试工具；开发者可在 x86 上方便地使用各种 IDE、性能分析器、虚拟化软件等。同时，x86 的庞大市场体量为各类商业软件（如 Adobe 套件、Microsoft Office、Steam 游戏库）提供了全面支持。\n\nARM 生态在早期相对弱势，但随着 Linux 发行版（如 Debian ARM、Ubuntu ARM）、Android SDK、Apple Xcode 等工具链逐步完善，开发者可针对不同 ARM 设备进行交叉编译与仿真调试，也有大量社区维护的调试器、性能分析器和集成开发环境（IDE）可用，如 ARM Development Studio、Keil MDK、VS Code 插件等，这些工具帮助缩短了 ARM 平台开发曲线。\n\n---\n\n## 软件开发与编译方式\n\n### 编译器优化\n\n对于 x86 架构，编译器需针对复杂的 CISC 指令集进行优化，例如采用延迟分支（Delayed Branch）、指令融合（Instruction Fusion）、循环展开（Loop Unrolling）、寄存器重命名（Register Renaming）等技术，以充分利用多级流水线与乱序执行特性，从而达到高 IPC（每周期指令数）水平。\n\nARM 架构则因其指令集简化，流水线更深且执行周期更短，编译器主要侧重于指令调度、寄存器分配与内存对齐优化，确保在有限的芯片面积与寄存器资源下实现高能效性能。\n\n### 跨平台编程\n\n跨平台开发时，针对 x86/ARM 双平台需要分别编译生成对应二进制。对于 C/C++ 应用，常使用 GCC 或 Clang 编译器，分别传入 `-march=x86-64` 或 `-march=armv8-a` 等参数，并链接对应平台的库文件。高级语言如 Java、Python、.NET 等则通过解释器或虚拟机方式实现跨平台：Java 将源代码编译为字节码，依赖各自平台的 JVM；Python 可通过不同架构的解释器运行，但需要注意扩展模块与库需重编译至目标架构。\n\n一些跨平台框架（如 Qt、Electron）也提供封装层，在编译期自动处理架构差异，使得同一套代码能在 x86/ARM 上生成可执行文件。\n\n## 典型应用场景\n\n### x86 常见应用\n\n- **个人电脑与笔记本**：几乎所有台式机与笔记本均采用 x86 处理器，运行 Windows、Linux 等操作系统，适用于办公、游戏、内容创作等多样化场景。\n- **服务器与数据中心**：x86 服务器（如 Intel Xeon、AMD EPYC）在云端与企业级应用中占据绝对主导地位，面向大规模并行计算、高性能数据库、虚拟化、容器化等需求。其睿频与多核设计能支撑高并发网络与 I/O 任务。\n- **高性能计算（HPC）**：通过集群化 x86 芯片结合高速互联（InfiniBand、Omni-Path），支持科学计算、天气预报、基因测序与金融模拟等计算密集型任务。\n\n### ARM 常见应用\n\n- **移动设备**：智能手机、平板电脑几乎全部基于 ARM SoC 设计（如 Qualcomm Snapdragon、Apple A/M 系列、Samsung Exynos），因其能效比高而在续航与发热控制方面具备明显优势。\n- **嵌入式系统与 IoT**：从单片机级 SBC（如 Raspberry Pi、BeagleBone）到智能家居网关、工业控制器，ARM 架构以低功耗与成本优势成为首选；典型应用包括智能家居、工业自动化、物联网传感节点等。\n- **边缘计算与智能摄像头**：搭载 ARM NPU（如华为麒麟 NPU、Qualcomm Hexagon DSP）用于本地 AI 推理，实现实时人脸识别、语音识别、对象检测和智能分析，而无需将大量数据传输到云端，有效节省带宽与降低延迟。\n- **笔记本与轻薄本**：随着 Apple M1/M2 等 ARM 桌面/笔记本 SoC 推出，ARM 架构正逐步进入传统 x86 桌面市场，凭借出色的能效与高度集成逐渐获得开发者与消费者认可。\n\n## 生态系统与社区支持\n\n### x86 生态优势\n\n![1749359942853Gk10bs6vao2zRYxYABccwWMen9e.png](https://gitee.com/tanke11223344/imagehost/raw/main/blog/1749359942853Gk10bs6vao2zRYxYABccwWMen9e.png)\n\nx86 生态已经发展数十年，形成了“硬件 + 操作系统 + 软件工具链 + 应用软件”的完整体系，开发者可方便获取 Visual Studio、Intel oneAPI、AMD ROCm、GCC/Clang 等多种编译器和性能分析工具；在 Linux 生态中，主流发行版（如 Ubuntu、Debian、Fedora、CentOS）均优先支持 x86 平台，并持续优化各类服务器级组件如 Nginx、MySQL、PostgreSQL、Kubernetes 等。此外，x86 社区中堆栈资源丰富，从低层汇编到高层框架，开发者几乎不用担心兼容性问题。\n\n### ARM 生态发展\n\nARM 自身并不生产芯片，而是通过授权模式让多家芯片厂商（如 Qualcomm、Apple、Samsung、Broadcom、MediaTek 等）在同一架构基础上进行差异化创新，使得 ARM 平台在移动与嵌入式领域涌现大量 SoC 设计。随着 Android、iOS 以及各种 Linux 发行版（Debian ARM、Ubuntu ARM）在 ARM 平台上的成熟运行，ARM 生态渐趋完整。开发者可使用交叉编译工具链（如 ARM GCC、LLVM）、集成开发环境（如 VS Code + PlatformIO、Keil MDK、ARM Development Studio）来进行 ARM 平台应用开发，同时还有开源社区维护的性能调优与调试工具（如 perf、gdb-multiarch、OpenOCD）可供选择。\n\n# 总结\n\nx86 在高性能计算与软件兼容性方面具备成熟优势，适用于台式机、服务器与科研计算等对性能要求极高的场景；ARM 则凭借低功耗、强能效、灵活授权等特点，成为移动设备、嵌入式和边缘计算领域的不二之选。随着技术不断演进，ARM 架构也在高性能和服务器市场发力（如 Apple M1/M2、Arm Neoverse 平台），逐渐缩小与 x86 之间的性能差距。未来，x86 与 ARM 将在不同细分市场继续并行发展，开发者应根据应用需求选择合适架构，并灵活运用跨平台编译技术以兼顾性能与能效。\n","slug":"2025-04-22-X86 架构与 Arm 架构异同及应用","published":1,"updated":"2025-09-26T12:17:01.068Z","_id":"cmg0saj430019jm8ndzcfhqh2","comments":1,"layout":"post","photos":[],"content":"<h1 id=\"X86-架构与-Arm-架构异同及应用\"><a href=\"#X86-架构与-Arm-架构异同及应用\" class=\"headerlink\" title=\"X86 架构与 Arm 架构异同及应用\"></a>X86 架构与 Arm 架构异同及应用</h1><h1 id=\"参考资料\"><a href=\"#参考资料\" class=\"headerlink\" title=\"参考资料\"></a>参考资料</h1><blockquote>\n<ul>\n<li><a href=\"https://blog.csdn.net/bleauchat/article/details/90114342\">一文看懂 arm 架构和 x86 架构有什么区别_arm 架构和 x86 架构区别-CSDN 博客</a></li>\n<li><a href=\"https://developer.aliyun.com/article/197450\">CPU 架构解析：ARM 和 x86 大比拼-阿里云开发者社区</a></li>\n<li><a href=\"https://blog.csdn.net/xie__jin__cheng/article/details/139521805\">arm 和 x86 的差别和应用场景学习笔记_x86 arm-CSDN 博客</a></li>\n<li><a href=\"https://cloud.tencent.com/developer/article/2435910\">ARM 与 x86 架构对比：从编程视角解析</a></li>\n<li><a href=\"https://developer.aliyun.com/article/197450\">CPU 架构解析 ARM 和 X86 对比</a></li>\n<li><a href=\"https://cloud.baidu.com/article/3053639\">X86 与 ARM 架构解析及适用场景</a></li>\n<li><a href=\"https://cloud.tencent.com/developer/article/1862717\">CPU_X86 架构和 ARM 架构入门篇</a></li>\n</ul>\n</blockquote>\n<h1 id=\"X86-和-Arm-架构概述\"><a href=\"#X86-和-Arm-架构概述\" class=\"headerlink\" title=\"X86 和 Arm 架构概述\"></a>X86 和 Arm 架构概述</h1><p><img src=\"https://gitee.com/tanke11223344/imagehost/raw/main/blog/1749359870854RkcXbu05koZn7HxFjc4ce6DDnLe.png\" alt=\"1749359870854RkcXbu05koZn7HxFjc4ce6DDnLe.png\"></p>\n<p>X86 使用复杂指令集（CISC），能耗较高，适合桌面和服务器的高性能需求。Arm 使用精简指令集（RISC），能耗低，广泛应用于移动设备和嵌入式系统，近年在服务器市场也有增长。两者的相似点是均为处理器架构，差异在于指令集和能耗，应用场景分别聚焦高性能计算和能效优化。</p>\n<p>X86 使用复杂指令集计算机（CISC）架构，指令丰富，可单指令完成复杂操作，如数据移动和乘法，适合高性能需求，但能耗较高。Arm 使用精简指令集计算机（RISC）架构，指令简单，执行快，能耗低，适合移动设备和嵌入式系统。两者的相似点是均为处理器架构，核心目标是执行计算任务。</p>\n<p>应用上，X86 常见于桌面电脑、笔记本和服务器，如 Intel 和 AMD 处理器主导市场。Arm 广泛用于智能手机、平板和嵌入式设备，近年在服务器市场增长，如 AWS Graviton 和 Azure Arm 实例。</p>\n<h2 id=\"重温-CPU\"><a href=\"#重温-CPU\" class=\"headerlink\" title=\"重温 CPU\"></a>重温 CPU</h2><p><a href=\"https://xcnx25vdviba.feishu.cn/wiki/T0cAw3jICiAjwsk4PELcOeqlnQf\">CPU-GPU-NPU 的区别及应用前景</a></p>\n<p>中央处理单元(CPU)主要由运算器、控制器、寄存器三部分组成，从字面意思看运算器就是起着运算的作用，控制器就是负责发出 CPU 每条指令所需要的信息，寄存器就是保存运算或者指令的一些临时文件，这样可以保证更高的速度。</p>\n<p><img src=\"https://gitee.com/tanke11223344/imagehost/raw/main/blog/1749359884852Upt5bc7HsoFuPBxbOJ8cODcFnbh.png\" alt=\"1749359884852Upt5bc7HsoFuPBxbOJ8cODcFnbh.png\"><br><img src=\"https://gitee.com/tanke11223344/imagehost/raw/main/blog/1749359896852DBeSbnX0doa7o0xG1ZOcHb7Xnxh.png\" alt=\"1749359896852DBeSbnX0doa7o0xG1ZOcHb7Xnxh.png\"></p>\n<p>CPU 有着处理指令、执行操作、控制时间、处理数据四大作用，打个比喻来说，CPU 就像我们的大脑，帮我们完成各种各样的生理活动。如果没有 CPU，那么电脑将无法工作。</p>\n<p><img src=\"https://gitee.com/tanke11223344/imagehost/raw/main/blog/1749359907852HFXKbuFRko0HR0xk7XeckQ6Pnoh.png\" alt=\"1749359907852HFXKbuFRko0HR0xk7XeckQ6Pnoh.png\"></p>\n<p>移动设备其实很复杂，这些 CPU 需要执行数以百万计的指示，才能使它向我们期待的方向运行，而 CPU 的速度和功率效率是至关重要的。速度影响用户体验，而效率影响电池寿命。最完美的移动设备是高性能和低功耗相结合。</p>\n<h2 id=\"CISC-与-RISC-指令集\"><a href=\"#CISC-与-RISC-指令集\" class=\"headerlink\" title=\"CISC 与 RISC 指令集\"></a><strong>CISC 与 RISC 指令集</strong></h2><p>要了解 X86 和 ARM，就得先了解复杂指令集(CISC)和精简指令集(RISC) ,从 CPU 发明到现在，有非常多种架构，从我们熟悉的 X86、ARM，到不太熟悉的 MIPS、IA64，它们之间的差距都非常大。但是如果从最基本的逻辑角度来分类的话，它们可以被分为两大类，即所谓的“复杂指令集”与“精简指令集”系统，也就是经常看到的“CISC”与“RISC”。</p>\n<p>所谓指令集，是 CPU 中用来计算和控制计算机系统的一套指令的集合。指令的强弱是 CPU 的重要指标，指令集是提高微处理器效率的最有效工具之一。</p>\n<p>Intel 和 ARM 处理器的第一个区别是，前者使用复杂指令集(CISC)，而后者使用精简指令集(RISC)。属于这两种类中的各种架构之间最大的区别，在于它们的设计者考虑问题方式的不同。</p>\n<h3 id=\"RISC-与-CISC：指令集架构的核心差异\"><a href=\"#RISC-与-CISC：指令集架构的核心差异\" class=\"headerlink\" title=\"RISC 与 CISC：指令集架构的核心差异\"></a>RISC 与 CISC：指令集架构的核心差异</h3><p>RISC (精简指令集) 和 CISC (复杂指令集) 的主要区别在于它们追求的 <strong>指令执行时长</strong>，而非指令本身的复杂性。</p>\n<ul>\n<li><strong>RISC:</strong> 力求在 <strong>单个机器周期</strong> 内完成一条指令。</li>\n<li><strong>CISC:</strong> 一条指令可能需要多个机器周期完成。</li>\n</ul>\n<h3 id=\"一个例子类比\"><a href=\"#一个例子类比\" class=\"headerlink\" title=\"一个例子类比\"></a>一个例子类比</h3><p><strong>让我们来拿“启动汽车”做类比：</strong></p>\n<ul>\n<li><p><strong>CISC:</strong> 一条指令完成所有步骤，如 <code>启动汽车</code>。处理器内部负责所有细节。</p>\n</li>\n<li><p><strong>RISC:</strong> 需要多条简单指令，如：</p>\n<ol>\n<li><code>插入钥匙指令</code></li>\n<li><code>点火指令</code></li>\n<li><code>踩油门指令</code></li>\n</ol>\n</li>\n</ul>\n<h4 id=\"编程示例-乘法操作-MUL-A-B-：\"><a href=\"#编程示例-乘法操作-MUL-A-B-：\" class=\"headerlink\" title=\"编程示例 (乘法操作 MUL A, B)：\"></a><strong>编程示例 (乘法操作 <strong><code>MUL A, B</code></strong>)：</strong></h4><ul>\n<li><strong>CISC:</strong></li>\n</ul>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">MUL A, B  ; 一条指令完成乘法</span><br></pre></td></tr></table></figure>\n\n<p>处理器内部操作：</p>\n<ol>\n<li>从内存加载 <code>A</code> 到寄存器。</li>\n<li>从内存加载 <code>B</code> 到寄存器。</li>\n<li>ALU 执行乘法。</li>\n<li>将结果写回内存。</li>\n</ol>\n<ul>\n<li><strong>RISC:</strong></li>\n</ul>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">LOAD RA, A   ; 从内存读取数据 A</span><br><span class=\"line\">LOAD RB, B   ; 从内存读取数据 B</span><br><span class=\"line\">PROD RA, RB  ; 计算两者乘积</span><br><span class=\"line\">STORE A, RA  ; 将寄存器中的结果写回内存</span><br></pre></td></tr></table></figure>\n\n<p><strong>对比分析：</strong></p>\n<p><strong>总结：</strong></p>\n<ul>\n<li><strong>CISC:</strong> 以少量复杂指令完成任务，对程序员更友好，但硬件实现复杂，功耗相对较高。</li>\n<li><strong>RISC:</strong> 以大量简单指令完成任务，硬件实现简单，功耗较低，更利于编译器优化。</li>\n</ul>\n<p>现代 CPU 架构在发展中也相互借鉴，例如一些 CISC 架构的处理器内部也会将复杂指令分解为更小的微指令执行，以提高效率。</p>\n<blockquote>\n<p><strong>题外:</strong><br>因为当年选择 CISC 是因为程序员都在写汇编，如果用汇编的话 CISC 可以接近高级语言的那样直接调用一个复杂指令处理一个复杂步骤，而 RISC 就要把每个复杂步骤拆成一大堆简单指令来写，所以开发时间长。现在大家全都在用高级语言了，高度抽象，根本不需要关心汇编级别的代码，这些都由编译器自动高效优化了，比人工优化还厉害得多，所以 CISC 这个开发时间的优势也基本没了，最多就是对一些接触硬件底层的操作系统和驱动程序的开发者而言更加方便。<br>现在的 Intel 和 amd 的 x64 架构，都是先通过一个翻译层把复杂指令拆解为精简指令，然后再进流水线的。真的复杂指令集都没法做流水线调度优化，从 intel 开始搞流水线后，真的用电路做复杂指令的时代就结束了。</p>\n</blockquote>\n<h2 id=\"X86-架构\"><a href=\"#X86-架构\" class=\"headerlink\" title=\"X86 架构\"></a>X86 架构</h2><blockquote>\n<p><a href=\"https://www.cnblogs.com/edver/p/15460077.html\">X86 架构解析及指令模拟流程 - Edver - 博客</a></p>\n</blockquote>\n<p>x86 服务器最大的特色在于可以兼容 Windows 操作系统，全部都采用了 Intel 的 CPU。而 Intel 的 x86 服务器也可以分为两代，最初采用的 80x86 系列在发布了产品 80486 后，Intel 对该系列产品进行了重新命名并注册，这也就是现在 Intel 的 Pentium 系列，当然，这个系列在中国还有个更响亮的名字，即奔腾系列。</p>\n<p>目前奔腾系列的 CPU 包括：Pentium、Pentium MMX、Pentium Pro、PII、PII Xeon(至强)、PIII、PIII Xeon、P4 Xeon、Celeron2(赛扬)等。</p>\n<h2 id=\"Arm-架构\"><a href=\"#Arm-架构\" class=\"headerlink\" title=\"Arm 架构\"></a>Arm 架构</h2><p>ARM 架构是一个精简指令集(RISC)处理器架构，其广泛地使用在许多嵌入式系统设计。由于节能的特点，ARM 处理器非常适用于移动通讯领域，符合其主要设计目标为低耗电的特性。应用领域包含手机、PAD、导航系统、网络设备等都是 ARM 架构，目前世界上使用最广泛的 CPU 就是 ARM。</p>\n<p><img src=\"https://gitee.com/tanke11223344/imagehost/raw/main/blog/1749359919853BIXRbuBL5oTBnJxUCyGcVC9AnPg.png\" alt=\"1749359919853BIXRbuBL5oTBnJxUCyGcVC9AnPg.png\"></p>\n<p>基于 arm 芯片的树莓派 5</p>\n<h3 id=\"big-LITTLE-架构\"><a href=\"#big-LITTLE-架构\" class=\"headerlink\" title=\"big.LITTLE 架构\"></a>big.LITTLE 架构</h3><p>异构计算 ARM 的 big.LITTLE 架构是一项 Intel 一时无法复制的创新。在 big.LITTLE 架构里，处理器可以是不同类型的。传统的双核或者四核处理器中包含同样的 2 个核或者 4 个核。一个双核 Atom 处理器中有两个一模一样的核，提供一样的性能，拥有相同的功耗。ARM 通过 big.LITTLE 向移动设备推出了异构计算。这意味着处理器中的核可以有不同的性能和功耗。当设备正常运行时，使用低功耗核，而当你运行一款复杂的游戏时，使用的是高性能的核。</p>\n<p><img src=\"https://gitee.com/tanke11223344/imagehost/raw/main/blog/1749359928852BvSabLGyBopLqexsogqcHyDonQd.png\" alt=\"1749359928852BvSabLGyBopLqexsogqcHyDonQd.png\"></p>\n<p>这是什么做到的呢?设计处理器的时候，要考虑大量的技术设计的采用与否，这些技术设计决定了处理器的性能以及功耗。在一条指令被解码并准备执行时，Intel 和 ARM 的处理器都使用流水线，就是说解码的过程是并行的。</p>\n<p>为了更快地执行指令，这些流水线可以被设计成允许指令们不按照程序的顺序被执行(乱序执行)。一些巧妙的逻辑结构可以判断下一条指令是否依赖于当前的指令执行的结果。Intel 和 ARM 都提供乱序执行逻辑结构，可想而知，这种结构十分的复杂，复杂意味着更多的功耗。</p>\n<h1 id=\"X86-和-Arm-架构的比较及应用\"><a href=\"#X86-和-Arm-架构的比较及应用\" class=\"headerlink\" title=\"X86 和 Arm 架构的比较及应用\"></a>X86 和 Arm 架构的比较及应用</h1><p>X86 和 Arm 都是广泛使用的 CPU 架构，但它们的设计目标和应用场景不同。X86 通常提供更高的单线程性能，适合需要强大计算能力的任务，如视频编辑和科学计算。而 Arm 以低功耗著称，延长了移动设备和 IoT 设备的电池寿命。</p>\n<table>\n<tr>\n<td>**方面**<br/></td><td>**X86 (CISC)**<br/></td><td>**Arm (RISC)**<br/></td></tr>\n<tr>\n<td>**指令集类型**<br/></td><td>复杂指令集计算（CISC），指令复杂，每条可执行多个操作，编译器设计较简单，CPU 电路复杂。<br/></td><td>精简指令集计算（RISC），指令简单，每条执行单一操作，CPU 电路较简单，需更多编译器优化。<br/></td></tr>\n<tr>\n<td>**性能与功耗**<br/></td><td>高性能，单线程能力强，适合高强度计算，但功耗高（如 i7 热设计功耗 45W）。<br/></td><td>低功耗，延长电池寿命，单核性能较低，但多核高效（如最大热设计功耗 3W，约为 i7 的 1/15）。<br/></td></tr>\n<tr>\n<td>**应用领域**<br/></td><td>桌面 PC、笔记本、工作站、服务器，特别适合科学计算、游戏渲染、视频编辑。<br/></td><td>智能手机、平板电脑、穿戴设备、IoT、嵌入式系统，近年扩展至服务器和 AI 加速器。<br/></td></tr>\n<tr>\n<td>**软件生态**<br/></td><td>成熟，Windows 和遗留应用广泛支持，软件大多为 X86 编译。<br/></td><td>增长中，移动和 Linux 环境强，但运行 X86 软件需模拟或重编译，效率较低。<br/></td></tr>\n<tr>\n<td>**制造与授权**<br/></td><td>由 Intel 和 AMD 生产，架构专有，仅这两家公司制造 CPU。<br/></td><td>Arm Holdings 设计并授权（如高通、苹果），允许定制化，制造由多家公司完成。<br/></td></tr>\n<tr>\n<td>**扩展性与未来趋势**<br/></td><td>通过增加核心数和时钟频率提升性能，扩展性好，但功耗挑战大。<br/></td><td>依赖多核提升性能，扩展受功耗限制，服务器和 AI 领域增长，定制化优势明显。<br/></td></tr>\n<tr>\n<td>**64 位计算**<br/></td><td>x86-64（AMD 设计），IA64 为 Itanium，但 x86-64 更普及，无原生 32 位到 64 位转换。<br/></td><td>ARMv8（2011）支持 AArch32/AArch64，切换无缝，向下兼容。<br/></td></tr>\n<tr>\n<td>**异构计算**<br/></td><td>传统双核/四核，性能和功耗一致，无 big.LITTLE。<br/></td><td>big.LITTLE 架构，低功耗核和高性能核组合，适合动态负载（如游戏时高性能）。<br/></td></tr>\n</table>\n\n<h2 id=\"设计理念与应用领域\"><a href=\"#设计理念与应用领域\" class=\"headerlink\" title=\"设计理念与应用领域\"></a>设计理念与应用领域</h2><p>x86 架构起源于 1978 年的 Intel 8086 处理器，采用复杂指令集（CISC），目标是提供丰富的指令以简化编程，强调高性能与通用性，广泛应用于桌面 PC、笔记本以及服务器市场。</p>\n<p>ARM 架构最早于 1985 年推出，基于精简指令集（RISC）设计，强调指令简洁、高速流水线及低功耗，主要面向移动设备与嵌入式系统，如智能手机、平板、智能手表以及各类 IoT 设备。</p>\n<p>由于设计目标不同，x86 与 ARM 在微架构设计上也存在显著区别：x86 侧重加强单核性能与兼容性，ARM 则以减少指令周期、提高能效为核心。</p>\n<h2 id=\"指令集与硬件架构\"><a href=\"#指令集与硬件架构\" class=\"headerlink\" title=\"指令集与硬件架构\"></a>指令集与硬件架构</h2><h3 id=\"寄存器与流水线\"><a href=\"#寄存器与流水线\" class=\"headerlink\" title=\"寄存器与流水线\"></a>寄存器与流水线</h3><p>在寄存器设计方面，x86 64 位处理器通常提供 16 个通用寄存器（RAX、RBX、RCX 等）以及多组寄存器别名（如 EAX、AX、AL）以支持兼容旧体系，与此对应还有段寄存器、浮点寄存器等多级寄存器层级，给予程序员更灵活的寻址与缓存管理能力，但也导致硬件设计更复杂。</p>\n<p>与此不同，ARM 通常提供 16 个通用寄存器（R0–R15，其中 R15 为程序计数器 PC），并辅以状态寄存器 CPSR（Current Program Status Register），指令与数据寄存器结构相对简单，减少寄存器寻址延迟，有利于流水线深度扩展与超标量处理设计，从而在多核并行时更易实现高能效比。</p>\n<h3 id=\"寻址模式与内存模型\"><a href=\"#寻址模式与内存模型\" class=\"headerlink\" title=\"寻址模式与内存模型\"></a>寻址模式与内存模型</h3><p>x86 架构支持多种复杂寻址模式，包括基址寻址（Base + Displacement）、索引加变址（Base + Index + Displacement）、相对寻址等，能够灵活处理多维数组与复杂数据结构，但同时也增加了 CPU 内部译码与执行单元的负担。</p>\n<p>相比之下，ARM 的内存模型较为简化，通常只支持寄存器间接寻址（Register Indirect）、偏移寻址（Register ± Offset）或基址 + 索引的简化形式，这大幅降低了解析与译码难度，从而配合深度流水线实现更高的指令吞吐率，但也意味着在某些特定场景下编译器需额外展开循环以模拟复杂寻址。</p>\n<h2 id=\"性能、功耗与工艺制程\"><a href=\"#性能、功耗与工艺制程\" class=\"headerlink\" title=\"性能、功耗与工艺制程\"></a>性能、功耗与工艺制程</h2><h3 id=\"性能对比\"><a href=\"#性能对比\" class=\"headerlink\" title=\"性能对比\"></a>性能对比</h3><p>x86 架构历经数十年发展，采用先进的制造工艺（如 5nm、7nm、10nm 制程），并通过深度流水线、乱序执行、分支预测与多级缓存等技术最大化提升单核性能。高端桌面与服务器级 CPU（如 Intel Core、AMD Ryzen、Intel Xeon、AMD EPYC）频率可达 3GHz–5GHz，拥有多达数十核（部分数据中心处理器甚至超过 64 核），在高性能计算、科学计算及游戏渲染等场景中表现卓越。然而，这种高性能也伴随着较高功耗，一颗满载状态的桌面级 CPU 功耗往往超过 100W。</p>\n<p>ARM 架构在移动与嵌入式领域更为常见，代表性处理器如 Qualcomm Snapdragon、Apple A 系列（M1&#x2F;M2 属 ARM 架构衍生）、Samsung Exynos 等，多采用 5nm–7nm 制程，单核主频通常在 2GHz–3GHz 范围，但通过多核与集成 GPU、NPU 协同工作实现系统级性能优化。例如，Apple M1 采用 ARM v8-架构，凭借高度集成与高效能核心设计，在多线程和单线程性能上均接近甚至超过同级 x86 芯片，同时功耗显著低于常规移动处理器。在低负载场景下，ARM 还可动态调整频率与电压，从而达到更低功耗和更长续航时间。</p>\n<h3 id=\"功耗与能效\"><a href=\"#功耗与能效\" class=\"headerlink\" title=\"功耗与能效\"></a>功耗与能效</h3><p>ARM 之所以在移动与嵌入式场景占据主导地位，核心在于其低功耗特性。ARM 处理器简化的指令集与硬件结构使其在执行相同指令时所需晶体管数量更少，从而减少了静态功耗与动态功耗；结合大规模集成、片上系统（SoC）设计，将 CPU、GPU、DSP 甚至 NPU 等模块集成在同一芯片中，进一步降低了数据传输带来的能耗开销。典型移动 ARM SoC 满载功耗常在 5W–15W 之间，而台式 x86 CPU 则常常在 65W–125W 范围内。在边缘或手持设备应用中，ARM 架构的这类优势尤为关键，能够在满足性能需求的同时延长电池续航。</p>\n<h3 id=\"工艺制程与制造成本\"><a href=\"#工艺制程与制造成本\" class=\"headerlink\" title=\"工艺制程与制造成本\"></a>工艺制程与制造成本</h3><p>x86 厂商（Intel、AMD）自研高端制程节点（如 Intel 7nm、5nm 等），但其工艺研发成本极高，且在多次制程节点转型中面临挑战，导致部分型号在新节点推出时出现延迟。</p>\n<p>ARM 架构本身并不生产芯片，而是由多家代工厂（如 TSMC、Samsung Foundry）依据授权设计进行制造。由于 ARM 架构可灵活授权给多众芯片厂商，使其能够快速采用最新工艺并优化成本。例如，TSMC 的 5nm、3nm 制程已经被多家 ARM SoC 采用，从而在成本与性能方面形成优势。总体来看，x86 芯片由于需要兼顾复杂的 CISC 女性并持续保持向后兼容，因此制造难度与成本远高于简化的 ARM SoC。</p>\n<hr>\n<h2 id=\"操作系统与生态系统\"><a href=\"#操作系统与生态系统\" class=\"headerlink\" title=\"操作系统与生态系统\"></a>操作系统与生态系统</h2><h3 id=\"操作系统兼容性\"><a href=\"#操作系统兼容性\" class=\"headerlink\" title=\"操作系统兼容性\"></a>操作系统兼容性</h3><p>x86 架构自 Windows 95 起与微软操作系统（Windows 系列）紧密绑定，与 Intel&#x2F;AMD 合作形成了 “Wintel 联盟”，在个人电脑市场形成近 30 年垄断，几乎所有桌面及服务器操作系统（Windows、Linux、Unix、BSD、macOS（Intel 时代）等）都优先支持 x86 芯片，确保了丰富的软件兼容性和庞大的用户群体。</p>\n<p>反观 ARM 架构，其早期主要面向嵌入式 Linux 系统，生态相对分散。直到 Google 推出 Android 操作系统后，ARM 平台在移动设备领域实现了操作系统统一，Android、iOS、KaiOS 等主流移动系统也均为 ARM 架构优化，大幅提升了 ARM 生态成熟度。近年来，Apple 通过自研 M1&#x2F;M2 等芯片将 macOS 从 x86 迁移至 ARM，进一步推动了 ARM 在桌面&#x2F;笔记本市场的生态建设。</p>\n<h3 id=\"软件与工具链\"><a href=\"#软件与工具链\" class=\"headerlink\" title=\"软件与工具链\"></a>软件与工具链</h3><p>x86 平台拥有成熟的软件工具链，包括 Visual Studio、Intel oneAPI、GCC&#x2F;Clang 等完善的编译优化器与调试工具；开发者可在 x86 上方便地使用各种 IDE、性能分析器、虚拟化软件等。同时，x86 的庞大市场体量为各类商业软件（如 Adobe 套件、Microsoft Office、Steam 游戏库）提供了全面支持。</p>\n<p>ARM 生态在早期相对弱势，但随着 Linux 发行版（如 Debian ARM、Ubuntu ARM）、Android SDK、Apple Xcode 等工具链逐步完善，开发者可针对不同 ARM 设备进行交叉编译与仿真调试，也有大量社区维护的调试器、性能分析器和集成开发环境（IDE）可用，如 ARM Development Studio、Keil MDK、VS Code 插件等，这些工具帮助缩短了 ARM 平台开发曲线。</p>\n<hr>\n<h2 id=\"软件开发与编译方式\"><a href=\"#软件开发与编译方式\" class=\"headerlink\" title=\"软件开发与编译方式\"></a>软件开发与编译方式</h2><h3 id=\"编译器优化\"><a href=\"#编译器优化\" class=\"headerlink\" title=\"编译器优化\"></a>编译器优化</h3><p>对于 x86 架构，编译器需针对复杂的 CISC 指令集进行优化，例如采用延迟分支（Delayed Branch）、指令融合（Instruction Fusion）、循环展开（Loop Unrolling）、寄存器重命名（Register Renaming）等技术，以充分利用多级流水线与乱序执行特性，从而达到高 IPC（每周期指令数）水平。</p>\n<p>ARM 架构则因其指令集简化，流水线更深且执行周期更短，编译器主要侧重于指令调度、寄存器分配与内存对齐优化，确保在有限的芯片面积与寄存器资源下实现高能效性能。</p>\n<h3 id=\"跨平台编程\"><a href=\"#跨平台编程\" class=\"headerlink\" title=\"跨平台编程\"></a>跨平台编程</h3><p>跨平台开发时，针对 x86&#x2F;ARM 双平台需要分别编译生成对应二进制。对于 C&#x2F;C++ 应用，常使用 GCC 或 Clang 编译器，分别传入 <code>-march=x86-64</code> 或 <code>-march=armv8-a</code> 等参数，并链接对应平台的库文件。高级语言如 Java、Python、.NET 等则通过解释器或虚拟机方式实现跨平台：Java 将源代码编译为字节码，依赖各自平台的 JVM；Python 可通过不同架构的解释器运行，但需要注意扩展模块与库需重编译至目标架构。</p>\n<p>一些跨平台框架（如 Qt、Electron）也提供封装层，在编译期自动处理架构差异，使得同一套代码能在 x86&#x2F;ARM 上生成可执行文件。</p>\n<h2 id=\"典型应用场景\"><a href=\"#典型应用场景\" class=\"headerlink\" title=\"典型应用场景\"></a>典型应用场景</h2><h3 id=\"x86-常见应用\"><a href=\"#x86-常见应用\" class=\"headerlink\" title=\"x86 常见应用\"></a>x86 常见应用</h3><ul>\n<li><strong>个人电脑与笔记本</strong>：几乎所有台式机与笔记本均采用 x86 处理器，运行 Windows、Linux 等操作系统，适用于办公、游戏、内容创作等多样化场景。</li>\n<li><strong>服务器与数据中心</strong>：x86 服务器（如 Intel Xeon、AMD EPYC）在云端与企业级应用中占据绝对主导地位，面向大规模并行计算、高性能数据库、虚拟化、容器化等需求。其睿频与多核设计能支撑高并发网络与 I&#x2F;O 任务。</li>\n<li><strong>高性能计算（HPC）</strong>：通过集群化 x86 芯片结合高速互联（InfiniBand、Omni-Path），支持科学计算、天气预报、基因测序与金融模拟等计算密集型任务。</li>\n</ul>\n<h3 id=\"ARM-常见应用\"><a href=\"#ARM-常见应用\" class=\"headerlink\" title=\"ARM 常见应用\"></a>ARM 常见应用</h3><ul>\n<li><strong>移动设备</strong>：智能手机、平板电脑几乎全部基于 ARM SoC 设计（如 Qualcomm Snapdragon、Apple A&#x2F;M 系列、Samsung Exynos），因其能效比高而在续航与发热控制方面具备明显优势。</li>\n<li><strong>嵌入式系统与 IoT</strong>：从单片机级 SBC（如 Raspberry Pi、BeagleBone）到智能家居网关、工业控制器，ARM 架构以低功耗与成本优势成为首选；典型应用包括智能家居、工业自动化、物联网传感节点等。</li>\n<li><strong>边缘计算与智能摄像头</strong>：搭载 ARM NPU（如华为麒麟 NPU、Qualcomm Hexagon DSP）用于本地 AI 推理，实现实时人脸识别、语音识别、对象检测和智能分析，而无需将大量数据传输到云端，有效节省带宽与降低延迟。</li>\n<li><strong>笔记本与轻薄本</strong>：随着 Apple M1&#x2F;M2 等 ARM 桌面&#x2F;笔记本 SoC 推出，ARM 架构正逐步进入传统 x86 桌面市场，凭借出色的能效与高度集成逐渐获得开发者与消费者认可。</li>\n</ul>\n<h2 id=\"生态系统与社区支持\"><a href=\"#生态系统与社区支持\" class=\"headerlink\" title=\"生态系统与社区支持\"></a>生态系统与社区支持</h2><h3 id=\"x86-生态优势\"><a href=\"#x86-生态优势\" class=\"headerlink\" title=\"x86 生态优势\"></a>x86 生态优势</h3><p><img src=\"https://gitee.com/tanke11223344/imagehost/raw/main/blog/1749359942853Gk10bs6vao2zRYxYABccwWMen9e.png\" alt=\"1749359942853Gk10bs6vao2zRYxYABccwWMen9e.png\"></p>\n<p>x86 生态已经发展数十年，形成了“硬件 + 操作系统 + 软件工具链 + 应用软件”的完整体系，开发者可方便获取 Visual Studio、Intel oneAPI、AMD ROCm、GCC&#x2F;Clang 等多种编译器和性能分析工具；在 Linux 生态中，主流发行版（如 Ubuntu、Debian、Fedora、CentOS）均优先支持 x86 平台，并持续优化各类服务器级组件如 Nginx、MySQL、PostgreSQL、Kubernetes 等。此外，x86 社区中堆栈资源丰富，从低层汇编到高层框架，开发者几乎不用担心兼容性问题。</p>\n<h3 id=\"ARM-生态发展\"><a href=\"#ARM-生态发展\" class=\"headerlink\" title=\"ARM 生态发展\"></a>ARM 生态发展</h3><p>ARM 自身并不生产芯片，而是通过授权模式让多家芯片厂商（如 Qualcomm、Apple、Samsung、Broadcom、MediaTek 等）在同一架构基础上进行差异化创新，使得 ARM 平台在移动与嵌入式领域涌现大量 SoC 设计。随着 Android、iOS 以及各种 Linux 发行版（Debian ARM、Ubuntu ARM）在 ARM 平台上的成熟运行，ARM 生态渐趋完整。开发者可使用交叉编译工具链（如 ARM GCC、LLVM）、集成开发环境（如 VS Code + PlatformIO、Keil MDK、ARM Development Studio）来进行 ARM 平台应用开发，同时还有开源社区维护的性能调优与调试工具（如 perf、gdb-multiarch、OpenOCD）可供选择。</p>\n<h1 id=\"总结\"><a href=\"#总结\" class=\"headerlink\" title=\"总结\"></a>总结</h1><p>x86 在高性能计算与软件兼容性方面具备成熟优势，适用于台式机、服务器与科研计算等对性能要求极高的场景；ARM 则凭借低功耗、强能效、灵活授权等特点，成为移动设备、嵌入式和边缘计算领域的不二之选。随着技术不断演进，ARM 架构也在高性能和服务器市场发力（如 Apple M1&#x2F;M2、Arm Neoverse 平台），逐渐缩小与 x86 之间的性能差距。未来，x86 与 ARM 将在不同细分市场继续并行发展，开发者应根据应用需求选择合适架构，并灵活运用跨平台编译技术以兼顾性能与能效。</p>\n","excerpt":"","more":"<h1 id=\"X86-架构与-Arm-架构异同及应用\"><a href=\"#X86-架构与-Arm-架构异同及应用\" class=\"headerlink\" title=\"X86 架构与 Arm 架构异同及应用\"></a>X86 架构与 Arm 架构异同及应用</h1><h1 id=\"参考资料\"><a href=\"#参考资料\" class=\"headerlink\" title=\"参考资料\"></a>参考资料</h1><blockquote>\n<ul>\n<li><a href=\"https://blog.csdn.net/bleauchat/article/details/90114342\">一文看懂 arm 架构和 x86 架构有什么区别_arm 架构和 x86 架构区别-CSDN 博客</a></li>\n<li><a href=\"https://developer.aliyun.com/article/197450\">CPU 架构解析：ARM 和 x86 大比拼-阿里云开发者社区</a></li>\n<li><a href=\"https://blog.csdn.net/xie__jin__cheng/article/details/139521805\">arm 和 x86 的差别和应用场景学习笔记_x86 arm-CSDN 博客</a></li>\n<li><a href=\"https://cloud.tencent.com/developer/article/2435910\">ARM 与 x86 架构对比：从编程视角解析</a></li>\n<li><a href=\"https://developer.aliyun.com/article/197450\">CPU 架构解析 ARM 和 X86 对比</a></li>\n<li><a href=\"https://cloud.baidu.com/article/3053639\">X86 与 ARM 架构解析及适用场景</a></li>\n<li><a href=\"https://cloud.tencent.com/developer/article/1862717\">CPU_X86 架构和 ARM 架构入门篇</a></li>\n</ul>\n</blockquote>\n<h1 id=\"X86-和-Arm-架构概述\"><a href=\"#X86-和-Arm-架构概述\" class=\"headerlink\" title=\"X86 和 Arm 架构概述\"></a>X86 和 Arm 架构概述</h1><p><img src=\"https://gitee.com/tanke11223344/imagehost/raw/main/blog/1749359870854RkcXbu05koZn7HxFjc4ce6DDnLe.png\" alt=\"1749359870854RkcXbu05koZn7HxFjc4ce6DDnLe.png\"></p>\n<p>X86 使用复杂指令集（CISC），能耗较高，适合桌面和服务器的高性能需求。Arm 使用精简指令集（RISC），能耗低，广泛应用于移动设备和嵌入式系统，近年在服务器市场也有增长。两者的相似点是均为处理器架构，差异在于指令集和能耗，应用场景分别聚焦高性能计算和能效优化。</p>\n<p>X86 使用复杂指令集计算机（CISC）架构，指令丰富，可单指令完成复杂操作，如数据移动和乘法，适合高性能需求，但能耗较高。Arm 使用精简指令集计算机（RISC）架构，指令简单，执行快，能耗低，适合移动设备和嵌入式系统。两者的相似点是均为处理器架构，核心目标是执行计算任务。</p>\n<p>应用上，X86 常见于桌面电脑、笔记本和服务器，如 Intel 和 AMD 处理器主导市场。Arm 广泛用于智能手机、平板和嵌入式设备，近年在服务器市场增长，如 AWS Graviton 和 Azure Arm 实例。</p>\n<h2 id=\"重温-CPU\"><a href=\"#重温-CPU\" class=\"headerlink\" title=\"重温 CPU\"></a>重温 CPU</h2><p><a href=\"https://xcnx25vdviba.feishu.cn/wiki/T0cAw3jICiAjwsk4PELcOeqlnQf\">CPU-GPU-NPU 的区别及应用前景</a></p>\n<p>中央处理单元(CPU)主要由运算器、控制器、寄存器三部分组成，从字面意思看运算器就是起着运算的作用，控制器就是负责发出 CPU 每条指令所需要的信息，寄存器就是保存运算或者指令的一些临时文件，这样可以保证更高的速度。</p>\n<p><img src=\"https://gitee.com/tanke11223344/imagehost/raw/main/blog/1749359884852Upt5bc7HsoFuPBxbOJ8cODcFnbh.png\" alt=\"1749359884852Upt5bc7HsoFuPBxbOJ8cODcFnbh.png\"><br><img src=\"https://gitee.com/tanke11223344/imagehost/raw/main/blog/1749359896852DBeSbnX0doa7o0xG1ZOcHb7Xnxh.png\" alt=\"1749359896852DBeSbnX0doa7o0xG1ZOcHb7Xnxh.png\"></p>\n<p>CPU 有着处理指令、执行操作、控制时间、处理数据四大作用，打个比喻来说，CPU 就像我们的大脑，帮我们完成各种各样的生理活动。如果没有 CPU，那么电脑将无法工作。</p>\n<p><img src=\"https://gitee.com/tanke11223344/imagehost/raw/main/blog/1749359907852HFXKbuFRko0HR0xk7XeckQ6Pnoh.png\" alt=\"1749359907852HFXKbuFRko0HR0xk7XeckQ6Pnoh.png\"></p>\n<p>移动设备其实很复杂，这些 CPU 需要执行数以百万计的指示，才能使它向我们期待的方向运行，而 CPU 的速度和功率效率是至关重要的。速度影响用户体验，而效率影响电池寿命。最完美的移动设备是高性能和低功耗相结合。</p>\n<h2 id=\"CISC-与-RISC-指令集\"><a href=\"#CISC-与-RISC-指令集\" class=\"headerlink\" title=\"CISC 与 RISC 指令集\"></a><strong>CISC 与 RISC 指令集</strong></h2><p>要了解 X86 和 ARM，就得先了解复杂指令集(CISC)和精简指令集(RISC) ,从 CPU 发明到现在，有非常多种架构，从我们熟悉的 X86、ARM，到不太熟悉的 MIPS、IA64，它们之间的差距都非常大。但是如果从最基本的逻辑角度来分类的话，它们可以被分为两大类，即所谓的“复杂指令集”与“精简指令集”系统，也就是经常看到的“CISC”与“RISC”。</p>\n<p>所谓指令集，是 CPU 中用来计算和控制计算机系统的一套指令的集合。指令的强弱是 CPU 的重要指标，指令集是提高微处理器效率的最有效工具之一。</p>\n<p>Intel 和 ARM 处理器的第一个区别是，前者使用复杂指令集(CISC)，而后者使用精简指令集(RISC)。属于这两种类中的各种架构之间最大的区别，在于它们的设计者考虑问题方式的不同。</p>\n<h3 id=\"RISC-与-CISC：指令集架构的核心差异\"><a href=\"#RISC-与-CISC：指令集架构的核心差异\" class=\"headerlink\" title=\"RISC 与 CISC：指令集架构的核心差异\"></a>RISC 与 CISC：指令集架构的核心差异</h3><p>RISC (精简指令集) 和 CISC (复杂指令集) 的主要区别在于它们追求的 <strong>指令执行时长</strong>，而非指令本身的复杂性。</p>\n<ul>\n<li><strong>RISC:</strong> 力求在 <strong>单个机器周期</strong> 内完成一条指令。</li>\n<li><strong>CISC:</strong> 一条指令可能需要多个机器周期完成。</li>\n</ul>\n<h3 id=\"一个例子类比\"><a href=\"#一个例子类比\" class=\"headerlink\" title=\"一个例子类比\"></a>一个例子类比</h3><p><strong>让我们来拿“启动汽车”做类比：</strong></p>\n<ul>\n<li><p><strong>CISC:</strong> 一条指令完成所有步骤，如 <code>启动汽车</code>。处理器内部负责所有细节。</p>\n</li>\n<li><p><strong>RISC:</strong> 需要多条简单指令，如：</p>\n<ol>\n<li><code>插入钥匙指令</code></li>\n<li><code>点火指令</code></li>\n<li><code>踩油门指令</code></li>\n</ol>\n</li>\n</ul>\n<h4 id=\"编程示例-乘法操作-MUL-A-B-：\"><a href=\"#编程示例-乘法操作-MUL-A-B-：\" class=\"headerlink\" title=\"编程示例 (乘法操作 MUL A, B)：\"></a><strong>编程示例 (乘法操作 <strong><code>MUL A, B</code></strong>)：</strong></h4><ul>\n<li><strong>CISC:</strong></li>\n</ul>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">MUL A, B  ; 一条指令完成乘法</span><br></pre></td></tr></table></figure>\n\n<p>处理器内部操作：</p>\n<ol>\n<li>从内存加载 <code>A</code> 到寄存器。</li>\n<li>从内存加载 <code>B</code> 到寄存器。</li>\n<li>ALU 执行乘法。</li>\n<li>将结果写回内存。</li>\n</ol>\n<ul>\n<li><strong>RISC:</strong></li>\n</ul>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">LOAD RA, A   ; 从内存读取数据 A</span><br><span class=\"line\">LOAD RB, B   ; 从内存读取数据 B</span><br><span class=\"line\">PROD RA, RB  ; 计算两者乘积</span><br><span class=\"line\">STORE A, RA  ; 将寄存器中的结果写回内存</span><br></pre></td></tr></table></figure>\n\n<p><strong>对比分析：</strong></p>\n<p><strong>总结：</strong></p>\n<ul>\n<li><strong>CISC:</strong> 以少量复杂指令完成任务，对程序员更友好，但硬件实现复杂，功耗相对较高。</li>\n<li><strong>RISC:</strong> 以大量简单指令完成任务，硬件实现简单，功耗较低，更利于编译器优化。</li>\n</ul>\n<p>现代 CPU 架构在发展中也相互借鉴，例如一些 CISC 架构的处理器内部也会将复杂指令分解为更小的微指令执行，以提高效率。</p>\n<blockquote>\n<p><strong>题外:</strong><br>因为当年选择 CISC 是因为程序员都在写汇编，如果用汇编的话 CISC 可以接近高级语言的那样直接调用一个复杂指令处理一个复杂步骤，而 RISC 就要把每个复杂步骤拆成一大堆简单指令来写，所以开发时间长。现在大家全都在用高级语言了，高度抽象，根本不需要关心汇编级别的代码，这些都由编译器自动高效优化了，比人工优化还厉害得多，所以 CISC 这个开发时间的优势也基本没了，最多就是对一些接触硬件底层的操作系统和驱动程序的开发者而言更加方便。<br>现在的 Intel 和 amd 的 x64 架构，都是先通过一个翻译层把复杂指令拆解为精简指令，然后再进流水线的。真的复杂指令集都没法做流水线调度优化，从 intel 开始搞流水线后，真的用电路做复杂指令的时代就结束了。</p>\n</blockquote>\n<h2 id=\"X86-架构\"><a href=\"#X86-架构\" class=\"headerlink\" title=\"X86 架构\"></a>X86 架构</h2><blockquote>\n<p><a href=\"https://www.cnblogs.com/edver/p/15460077.html\">X86 架构解析及指令模拟流程 - Edver - 博客</a></p>\n</blockquote>\n<p>x86 服务器最大的特色在于可以兼容 Windows 操作系统，全部都采用了 Intel 的 CPU。而 Intel 的 x86 服务器也可以分为两代，最初采用的 80x86 系列在发布了产品 80486 后，Intel 对该系列产品进行了重新命名并注册，这也就是现在 Intel 的 Pentium 系列，当然，这个系列在中国还有个更响亮的名字，即奔腾系列。</p>\n<p>目前奔腾系列的 CPU 包括：Pentium、Pentium MMX、Pentium Pro、PII、PII Xeon(至强)、PIII、PIII Xeon、P4 Xeon、Celeron2(赛扬)等。</p>\n<h2 id=\"Arm-架构\"><a href=\"#Arm-架构\" class=\"headerlink\" title=\"Arm 架构\"></a>Arm 架构</h2><p>ARM 架构是一个精简指令集(RISC)处理器架构，其广泛地使用在许多嵌入式系统设计。由于节能的特点，ARM 处理器非常适用于移动通讯领域，符合其主要设计目标为低耗电的特性。应用领域包含手机、PAD、导航系统、网络设备等都是 ARM 架构，目前世界上使用最广泛的 CPU 就是 ARM。</p>\n<p><img src=\"https://gitee.com/tanke11223344/imagehost/raw/main/blog/1749359919853BIXRbuBL5oTBnJxUCyGcVC9AnPg.png\" alt=\"1749359919853BIXRbuBL5oTBnJxUCyGcVC9AnPg.png\"></p>\n<p>基于 arm 芯片的树莓派 5</p>\n<h3 id=\"big-LITTLE-架构\"><a href=\"#big-LITTLE-架构\" class=\"headerlink\" title=\"big.LITTLE 架构\"></a>big.LITTLE 架构</h3><p>异构计算 ARM 的 big.LITTLE 架构是一项 Intel 一时无法复制的创新。在 big.LITTLE 架构里，处理器可以是不同类型的。传统的双核或者四核处理器中包含同样的 2 个核或者 4 个核。一个双核 Atom 处理器中有两个一模一样的核，提供一样的性能，拥有相同的功耗。ARM 通过 big.LITTLE 向移动设备推出了异构计算。这意味着处理器中的核可以有不同的性能和功耗。当设备正常运行时，使用低功耗核，而当你运行一款复杂的游戏时，使用的是高性能的核。</p>\n<p><img src=\"https://gitee.com/tanke11223344/imagehost/raw/main/blog/1749359928852BvSabLGyBopLqexsogqcHyDonQd.png\" alt=\"1749359928852BvSabLGyBopLqexsogqcHyDonQd.png\"></p>\n<p>这是什么做到的呢?设计处理器的时候，要考虑大量的技术设计的采用与否，这些技术设计决定了处理器的性能以及功耗。在一条指令被解码并准备执行时，Intel 和 ARM 的处理器都使用流水线，就是说解码的过程是并行的。</p>\n<p>为了更快地执行指令，这些流水线可以被设计成允许指令们不按照程序的顺序被执行(乱序执行)。一些巧妙的逻辑结构可以判断下一条指令是否依赖于当前的指令执行的结果。Intel 和 ARM 都提供乱序执行逻辑结构，可想而知，这种结构十分的复杂，复杂意味着更多的功耗。</p>\n<h1 id=\"X86-和-Arm-架构的比较及应用\"><a href=\"#X86-和-Arm-架构的比较及应用\" class=\"headerlink\" title=\"X86 和 Arm 架构的比较及应用\"></a>X86 和 Arm 架构的比较及应用</h1><p>X86 和 Arm 都是广泛使用的 CPU 架构，但它们的设计目标和应用场景不同。X86 通常提供更高的单线程性能，适合需要强大计算能力的任务，如视频编辑和科学计算。而 Arm 以低功耗著称，延长了移动设备和 IoT 设备的电池寿命。</p>\n<table>\n<tr>\n<td>**方面**<br/></td><td>**X86 (CISC)**<br/></td><td>**Arm (RISC)**<br/></td></tr>\n<tr>\n<td>**指令集类型**<br/></td><td>复杂指令集计算（CISC），指令复杂，每条可执行多个操作，编译器设计较简单，CPU 电路复杂。<br/></td><td>精简指令集计算（RISC），指令简单，每条执行单一操作，CPU 电路较简单，需更多编译器优化。<br/></td></tr>\n<tr>\n<td>**性能与功耗**<br/></td><td>高性能，单线程能力强，适合高强度计算，但功耗高（如 i7 热设计功耗 45W）。<br/></td><td>低功耗，延长电池寿命，单核性能较低，但多核高效（如最大热设计功耗 3W，约为 i7 的 1/15）。<br/></td></tr>\n<tr>\n<td>**应用领域**<br/></td><td>桌面 PC、笔记本、工作站、服务器，特别适合科学计算、游戏渲染、视频编辑。<br/></td><td>智能手机、平板电脑、穿戴设备、IoT、嵌入式系统，近年扩展至服务器和 AI 加速器。<br/></td></tr>\n<tr>\n<td>**软件生态**<br/></td><td>成熟，Windows 和遗留应用广泛支持，软件大多为 X86 编译。<br/></td><td>增长中，移动和 Linux 环境强，但运行 X86 软件需模拟或重编译，效率较低。<br/></td></tr>\n<tr>\n<td>**制造与授权**<br/></td><td>由 Intel 和 AMD 生产，架构专有，仅这两家公司制造 CPU。<br/></td><td>Arm Holdings 设计并授权（如高通、苹果），允许定制化，制造由多家公司完成。<br/></td></tr>\n<tr>\n<td>**扩展性与未来趋势**<br/></td><td>通过增加核心数和时钟频率提升性能，扩展性好，但功耗挑战大。<br/></td><td>依赖多核提升性能，扩展受功耗限制，服务器和 AI 领域增长，定制化优势明显。<br/></td></tr>\n<tr>\n<td>**64 位计算**<br/></td><td>x86-64（AMD 设计），IA64 为 Itanium，但 x86-64 更普及，无原生 32 位到 64 位转换。<br/></td><td>ARMv8（2011）支持 AArch32/AArch64，切换无缝，向下兼容。<br/></td></tr>\n<tr>\n<td>**异构计算**<br/></td><td>传统双核/四核，性能和功耗一致，无 big.LITTLE。<br/></td><td>big.LITTLE 架构，低功耗核和高性能核组合，适合动态负载（如游戏时高性能）。<br/></td></tr>\n</table>\n\n<h2 id=\"设计理念与应用领域\"><a href=\"#设计理念与应用领域\" class=\"headerlink\" title=\"设计理念与应用领域\"></a>设计理念与应用领域</h2><p>x86 架构起源于 1978 年的 Intel 8086 处理器，采用复杂指令集（CISC），目标是提供丰富的指令以简化编程，强调高性能与通用性，广泛应用于桌面 PC、笔记本以及服务器市场。</p>\n<p>ARM 架构最早于 1985 年推出，基于精简指令集（RISC）设计，强调指令简洁、高速流水线及低功耗，主要面向移动设备与嵌入式系统，如智能手机、平板、智能手表以及各类 IoT 设备。</p>\n<p>由于设计目标不同，x86 与 ARM 在微架构设计上也存在显著区别：x86 侧重加强单核性能与兼容性，ARM 则以减少指令周期、提高能效为核心。</p>\n<h2 id=\"指令集与硬件架构\"><a href=\"#指令集与硬件架构\" class=\"headerlink\" title=\"指令集与硬件架构\"></a>指令集与硬件架构</h2><h3 id=\"寄存器与流水线\"><a href=\"#寄存器与流水线\" class=\"headerlink\" title=\"寄存器与流水线\"></a>寄存器与流水线</h3><p>在寄存器设计方面，x86 64 位处理器通常提供 16 个通用寄存器（RAX、RBX、RCX 等）以及多组寄存器别名（如 EAX、AX、AL）以支持兼容旧体系，与此对应还有段寄存器、浮点寄存器等多级寄存器层级，给予程序员更灵活的寻址与缓存管理能力，但也导致硬件设计更复杂。</p>\n<p>与此不同，ARM 通常提供 16 个通用寄存器（R0–R15，其中 R15 为程序计数器 PC），并辅以状态寄存器 CPSR（Current Program Status Register），指令与数据寄存器结构相对简单，减少寄存器寻址延迟，有利于流水线深度扩展与超标量处理设计，从而在多核并行时更易实现高能效比。</p>\n<h3 id=\"寻址模式与内存模型\"><a href=\"#寻址模式与内存模型\" class=\"headerlink\" title=\"寻址模式与内存模型\"></a>寻址模式与内存模型</h3><p>x86 架构支持多种复杂寻址模式，包括基址寻址（Base + Displacement）、索引加变址（Base + Index + Displacement）、相对寻址等，能够灵活处理多维数组与复杂数据结构，但同时也增加了 CPU 内部译码与执行单元的负担。</p>\n<p>相比之下，ARM 的内存模型较为简化，通常只支持寄存器间接寻址（Register Indirect）、偏移寻址（Register ± Offset）或基址 + 索引的简化形式，这大幅降低了解析与译码难度，从而配合深度流水线实现更高的指令吞吐率，但也意味着在某些特定场景下编译器需额外展开循环以模拟复杂寻址。</p>\n<h2 id=\"性能、功耗与工艺制程\"><a href=\"#性能、功耗与工艺制程\" class=\"headerlink\" title=\"性能、功耗与工艺制程\"></a>性能、功耗与工艺制程</h2><h3 id=\"性能对比\"><a href=\"#性能对比\" class=\"headerlink\" title=\"性能对比\"></a>性能对比</h3><p>x86 架构历经数十年发展，采用先进的制造工艺（如 5nm、7nm、10nm 制程），并通过深度流水线、乱序执行、分支预测与多级缓存等技术最大化提升单核性能。高端桌面与服务器级 CPU（如 Intel Core、AMD Ryzen、Intel Xeon、AMD EPYC）频率可达 3GHz–5GHz，拥有多达数十核（部分数据中心处理器甚至超过 64 核），在高性能计算、科学计算及游戏渲染等场景中表现卓越。然而，这种高性能也伴随着较高功耗，一颗满载状态的桌面级 CPU 功耗往往超过 100W。</p>\n<p>ARM 架构在移动与嵌入式领域更为常见，代表性处理器如 Qualcomm Snapdragon、Apple A 系列（M1&#x2F;M2 属 ARM 架构衍生）、Samsung Exynos 等，多采用 5nm–7nm 制程，单核主频通常在 2GHz–3GHz 范围，但通过多核与集成 GPU、NPU 协同工作实现系统级性能优化。例如，Apple M1 采用 ARM v8-架构，凭借高度集成与高效能核心设计，在多线程和单线程性能上均接近甚至超过同级 x86 芯片，同时功耗显著低于常规移动处理器。在低负载场景下，ARM 还可动态调整频率与电压，从而达到更低功耗和更长续航时间。</p>\n<h3 id=\"功耗与能效\"><a href=\"#功耗与能效\" class=\"headerlink\" title=\"功耗与能效\"></a>功耗与能效</h3><p>ARM 之所以在移动与嵌入式场景占据主导地位，核心在于其低功耗特性。ARM 处理器简化的指令集与硬件结构使其在执行相同指令时所需晶体管数量更少，从而减少了静态功耗与动态功耗；结合大规模集成、片上系统（SoC）设计，将 CPU、GPU、DSP 甚至 NPU 等模块集成在同一芯片中，进一步降低了数据传输带来的能耗开销。典型移动 ARM SoC 满载功耗常在 5W–15W 之间，而台式 x86 CPU 则常常在 65W–125W 范围内。在边缘或手持设备应用中，ARM 架构的这类优势尤为关键，能够在满足性能需求的同时延长电池续航。</p>\n<h3 id=\"工艺制程与制造成本\"><a href=\"#工艺制程与制造成本\" class=\"headerlink\" title=\"工艺制程与制造成本\"></a>工艺制程与制造成本</h3><p>x86 厂商（Intel、AMD）自研高端制程节点（如 Intel 7nm、5nm 等），但其工艺研发成本极高，且在多次制程节点转型中面临挑战，导致部分型号在新节点推出时出现延迟。</p>\n<p>ARM 架构本身并不生产芯片，而是由多家代工厂（如 TSMC、Samsung Foundry）依据授权设计进行制造。由于 ARM 架构可灵活授权给多众芯片厂商，使其能够快速采用最新工艺并优化成本。例如，TSMC 的 5nm、3nm 制程已经被多家 ARM SoC 采用，从而在成本与性能方面形成优势。总体来看，x86 芯片由于需要兼顾复杂的 CISC 女性并持续保持向后兼容，因此制造难度与成本远高于简化的 ARM SoC。</p>\n<hr>\n<h2 id=\"操作系统与生态系统\"><a href=\"#操作系统与生态系统\" class=\"headerlink\" title=\"操作系统与生态系统\"></a>操作系统与生态系统</h2><h3 id=\"操作系统兼容性\"><a href=\"#操作系统兼容性\" class=\"headerlink\" title=\"操作系统兼容性\"></a>操作系统兼容性</h3><p>x86 架构自 Windows 95 起与微软操作系统（Windows 系列）紧密绑定，与 Intel&#x2F;AMD 合作形成了 “Wintel 联盟”，在个人电脑市场形成近 30 年垄断，几乎所有桌面及服务器操作系统（Windows、Linux、Unix、BSD、macOS（Intel 时代）等）都优先支持 x86 芯片，确保了丰富的软件兼容性和庞大的用户群体。</p>\n<p>反观 ARM 架构，其早期主要面向嵌入式 Linux 系统，生态相对分散。直到 Google 推出 Android 操作系统后，ARM 平台在移动设备领域实现了操作系统统一，Android、iOS、KaiOS 等主流移动系统也均为 ARM 架构优化，大幅提升了 ARM 生态成熟度。近年来，Apple 通过自研 M1&#x2F;M2 等芯片将 macOS 从 x86 迁移至 ARM，进一步推动了 ARM 在桌面&#x2F;笔记本市场的生态建设。</p>\n<h3 id=\"软件与工具链\"><a href=\"#软件与工具链\" class=\"headerlink\" title=\"软件与工具链\"></a>软件与工具链</h3><p>x86 平台拥有成熟的软件工具链，包括 Visual Studio、Intel oneAPI、GCC&#x2F;Clang 等完善的编译优化器与调试工具；开发者可在 x86 上方便地使用各种 IDE、性能分析器、虚拟化软件等。同时，x86 的庞大市场体量为各类商业软件（如 Adobe 套件、Microsoft Office、Steam 游戏库）提供了全面支持。</p>\n<p>ARM 生态在早期相对弱势，但随着 Linux 发行版（如 Debian ARM、Ubuntu ARM）、Android SDK、Apple Xcode 等工具链逐步完善，开发者可针对不同 ARM 设备进行交叉编译与仿真调试，也有大量社区维护的调试器、性能分析器和集成开发环境（IDE）可用，如 ARM Development Studio、Keil MDK、VS Code 插件等，这些工具帮助缩短了 ARM 平台开发曲线。</p>\n<hr>\n<h2 id=\"软件开发与编译方式\"><a href=\"#软件开发与编译方式\" class=\"headerlink\" title=\"软件开发与编译方式\"></a>软件开发与编译方式</h2><h3 id=\"编译器优化\"><a href=\"#编译器优化\" class=\"headerlink\" title=\"编译器优化\"></a>编译器优化</h3><p>对于 x86 架构，编译器需针对复杂的 CISC 指令集进行优化，例如采用延迟分支（Delayed Branch）、指令融合（Instruction Fusion）、循环展开（Loop Unrolling）、寄存器重命名（Register Renaming）等技术，以充分利用多级流水线与乱序执行特性，从而达到高 IPC（每周期指令数）水平。</p>\n<p>ARM 架构则因其指令集简化，流水线更深且执行周期更短，编译器主要侧重于指令调度、寄存器分配与内存对齐优化，确保在有限的芯片面积与寄存器资源下实现高能效性能。</p>\n<h3 id=\"跨平台编程\"><a href=\"#跨平台编程\" class=\"headerlink\" title=\"跨平台编程\"></a>跨平台编程</h3><p>跨平台开发时，针对 x86&#x2F;ARM 双平台需要分别编译生成对应二进制。对于 C&#x2F;C++ 应用，常使用 GCC 或 Clang 编译器，分别传入 <code>-march=x86-64</code> 或 <code>-march=armv8-a</code> 等参数，并链接对应平台的库文件。高级语言如 Java、Python、.NET 等则通过解释器或虚拟机方式实现跨平台：Java 将源代码编译为字节码，依赖各自平台的 JVM；Python 可通过不同架构的解释器运行，但需要注意扩展模块与库需重编译至目标架构。</p>\n<p>一些跨平台框架（如 Qt、Electron）也提供封装层，在编译期自动处理架构差异，使得同一套代码能在 x86&#x2F;ARM 上生成可执行文件。</p>\n<h2 id=\"典型应用场景\"><a href=\"#典型应用场景\" class=\"headerlink\" title=\"典型应用场景\"></a>典型应用场景</h2><h3 id=\"x86-常见应用\"><a href=\"#x86-常见应用\" class=\"headerlink\" title=\"x86 常见应用\"></a>x86 常见应用</h3><ul>\n<li><strong>个人电脑与笔记本</strong>：几乎所有台式机与笔记本均采用 x86 处理器，运行 Windows、Linux 等操作系统，适用于办公、游戏、内容创作等多样化场景。</li>\n<li><strong>服务器与数据中心</strong>：x86 服务器（如 Intel Xeon、AMD EPYC）在云端与企业级应用中占据绝对主导地位，面向大规模并行计算、高性能数据库、虚拟化、容器化等需求。其睿频与多核设计能支撑高并发网络与 I&#x2F;O 任务。</li>\n<li><strong>高性能计算（HPC）</strong>：通过集群化 x86 芯片结合高速互联（InfiniBand、Omni-Path），支持科学计算、天气预报、基因测序与金融模拟等计算密集型任务。</li>\n</ul>\n<h3 id=\"ARM-常见应用\"><a href=\"#ARM-常见应用\" class=\"headerlink\" title=\"ARM 常见应用\"></a>ARM 常见应用</h3><ul>\n<li><strong>移动设备</strong>：智能手机、平板电脑几乎全部基于 ARM SoC 设计（如 Qualcomm Snapdragon、Apple A&#x2F;M 系列、Samsung Exynos），因其能效比高而在续航与发热控制方面具备明显优势。</li>\n<li><strong>嵌入式系统与 IoT</strong>：从单片机级 SBC（如 Raspberry Pi、BeagleBone）到智能家居网关、工业控制器，ARM 架构以低功耗与成本优势成为首选；典型应用包括智能家居、工业自动化、物联网传感节点等。</li>\n<li><strong>边缘计算与智能摄像头</strong>：搭载 ARM NPU（如华为麒麟 NPU、Qualcomm Hexagon DSP）用于本地 AI 推理，实现实时人脸识别、语音识别、对象检测和智能分析，而无需将大量数据传输到云端，有效节省带宽与降低延迟。</li>\n<li><strong>笔记本与轻薄本</strong>：随着 Apple M1&#x2F;M2 等 ARM 桌面&#x2F;笔记本 SoC 推出，ARM 架构正逐步进入传统 x86 桌面市场，凭借出色的能效与高度集成逐渐获得开发者与消费者认可。</li>\n</ul>\n<h2 id=\"生态系统与社区支持\"><a href=\"#生态系统与社区支持\" class=\"headerlink\" title=\"生态系统与社区支持\"></a>生态系统与社区支持</h2><h3 id=\"x86-生态优势\"><a href=\"#x86-生态优势\" class=\"headerlink\" title=\"x86 生态优势\"></a>x86 生态优势</h3><p><img src=\"https://gitee.com/tanke11223344/imagehost/raw/main/blog/1749359942853Gk10bs6vao2zRYxYABccwWMen9e.png\" alt=\"1749359942853Gk10bs6vao2zRYxYABccwWMen9e.png\"></p>\n<p>x86 生态已经发展数十年，形成了“硬件 + 操作系统 + 软件工具链 + 应用软件”的完整体系，开发者可方便获取 Visual Studio、Intel oneAPI、AMD ROCm、GCC&#x2F;Clang 等多种编译器和性能分析工具；在 Linux 生态中，主流发行版（如 Ubuntu、Debian、Fedora、CentOS）均优先支持 x86 平台，并持续优化各类服务器级组件如 Nginx、MySQL、PostgreSQL、Kubernetes 等。此外，x86 社区中堆栈资源丰富，从低层汇编到高层框架，开发者几乎不用担心兼容性问题。</p>\n<h3 id=\"ARM-生态发展\"><a href=\"#ARM-生态发展\" class=\"headerlink\" title=\"ARM 生态发展\"></a>ARM 生态发展</h3><p>ARM 自身并不生产芯片，而是通过授权模式让多家芯片厂商（如 Qualcomm、Apple、Samsung、Broadcom、MediaTek 等）在同一架构基础上进行差异化创新，使得 ARM 平台在移动与嵌入式领域涌现大量 SoC 设计。随着 Android、iOS 以及各种 Linux 发行版（Debian ARM、Ubuntu ARM）在 ARM 平台上的成熟运行，ARM 生态渐趋完整。开发者可使用交叉编译工具链（如 ARM GCC、LLVM）、集成开发环境（如 VS Code + PlatformIO、Keil MDK、ARM Development Studio）来进行 ARM 平台应用开发，同时还有开源社区维护的性能调优与调试工具（如 perf、gdb-multiarch、OpenOCD）可供选择。</p>\n<h1 id=\"总结\"><a href=\"#总结\" class=\"headerlink\" title=\"总结\"></a>总结</h1><p>x86 在高性能计算与软件兼容性方面具备成熟优势，适用于台式机、服务器与科研计算等对性能要求极高的场景；ARM 则凭借低功耗、强能效、灵活授权等特点，成为移动设备、嵌入式和边缘计算领域的不二之选。随着技术不断演进，ARM 架构也在高性能和服务器市场发力（如 Apple M1&#x2F;M2、Arm Neoverse 平台），逐渐缩小与 x86 之间的性能差距。未来，x86 与 ARM 将在不同细分市场继续并行发展，开发者应根据应用需求选择合适架构，并灵活运用跨平台编译技术以兼顾性能与能效。</p>\n"},{"title":"2025-03-12-Bunny 轻量级多模态语言模型家族","date":"2025-03-11T16:00:00.000Z","_content":"> 论文链接\n> [https://arxiv.org/abs/2402.11530](https://arxiv.org/abs/2402.11530)\n\n# 全文总结\n\n一种名为 Bunny 的轻量级多模态语言模型家族，旨在通过优化训练数据来提高模型的性能，从而在计算资源有限的情况下实现高效的多模态学习。\n\n## 研究背景\n\n1. **背景介绍:** 多模态大型语言模型（MLLMs）在视觉理解和推理任务中表现出色，但其部署受到训练和推理阶段的高计算成本和内存消耗的限制。为了克服这一问题，研究者们尝试使用较小的预训练视觉和语言模型，但这通常会导致性能下降。\n2. **研究内容:** 通过优化训练数据来补偿模型规模的减小，从而在保持高性能的同时实现模型的小型化。\n3. **文献综述:** 多种轻量级 MLLM 的尝试，如 LLaVA-Phi、Imp 和 Vary-toy 等，这些工作通过使用小型语言模型和视觉编码器来实现模型的小型化。此外，还有研究探索了模型架构和训练策略的优化。\n\n## 研究方法\n\n这篇论文提出了 Bunny，一种轻量级的多模态模型家族，用于解决多模态学习中的计算成本问题。具体来说，\n\n![1741790887815EqNRbHjCOoXqZixhNGjcc7yXneh.png](https://tk-pichost-1325224430.cos.ap-chengdu.myqcloud.com/blog/1741790887815EqNRbHjCOoXqZixhNGjcc7yXneh.png)\n\n1. **训练数据构建:** 为了提高训练数据的有效性，作者从 LAION-2B 数据集中构建了高质量的预训练数据集 Bunny-pretrain-LAION-2M，并收集了视觉指令调整数据集 Bunny-695K。通过数据集精简技术，从广泛的源中选择更信息量的数据。\n2. **训练策略:** 采用两阶段训练策略：第一阶段进行预训练，对齐视觉嵌入和文本嵌入；第二阶段进行微调，应用视觉指令调整以充分利用 MLLM 的能力。在微调阶段，使用 LoRA 来训练 LLM 骨干，而视觉编码器和跨模态投影器则完全调整。\n\n> LoRA:基于大模型的内在低秩特性，增加旁路矩阵来模拟全参数微调，LoRA 通过简单有效的方案来达成轻量微调的目的。它的应用自不必提，可以将现在的各种大模型通过轻量微调变成各个不同领域的专业模型。\n> ![1741964606068RLo3b1D3moX6OCxShJrc5FiAnee.png](https://tk-pichost-1325224430.cos.ap-chengdu.myqcloud.com/blog/1741964606068RLo3b1D3moX6OCxShJrc5FiAnee.png)\n>\n> 1. 使用预训练的 LLM 权重初始化 A 和 B 矩阵。\n> 2. 将 LLM 应用于特定任务的训练数据集。\n> 3. 在训练过程中，只有 A 矩阵会针对训练数据集（输入资料（X））进行微调。\n> 4. 训练完成后，获得了针对特定任务适应的 LLM，也就是 H（输出）。\n>\n> - 举个例子，如果把预训练的大型语言模型比作一座已经建好的复杂大厦，LoRA 就像是给大厦的某些房间（对应模型的特定层）添加一些简易的可拆卸隔断（低秩矩阵模块）来改变房间布局（适应新任务），而不是对整座大厦的结构和所有房间进行大规模改造 ，这样既节省了时间和材料（计算资源和时间），又能达到灵活调整的目的 。\n\n## 实验设计\n\n1. **数据集:** 在多个基准测试上评估 Bunny 的性能，包括 MME 感知、MME 认知、MMBench、SEED-Bench-1、MMMU、VQA-v2、GQA、ScienceQAIMG 和 POPE 等。\n2. **对比模型:** 将 Bunny 与现有的最先进的多模态大型语言模型进行比较，包括 GPT-4V、BLIP-2、InstructBLIP、Shikra、SVIT、LVIS-INSTRUCT4V、ShareGPT4V、VILA1.5、Mini-Gemini-HD、LLaVA、MiniGPT-v2、mPLUG-Owl2、SPHINX-Intern2、YiVL、DeepSeek-VL、MM1、Idefics2、LLaVA-NeXT、MobileVLM、TinyLLaVA、Mipha、MiniCPM、Imp 等。\n3. **实验设置:** 在微调阶段使用 LoRA 进行训练，并对数据策略、训练周期、视觉编码器的冻结与调整等进行消融研究。\n\n## 结果与分析\n\n1. **性能比较:** Bunny-4B 和 Bunny-8B 在大多数基准测试中优于同尺寸的其他 MLLMs，显示出卓越的多模态理解和推理能力。特别是 Bunny-8B 在 MMEP 上取得了 1644.1 的高分，远超第二名 LLaVA-NeXT-Llama-3-8B（1603.7）。\n2. **消融研究:** LoRA 在微调阶段的表现优于完全调整 LLM，表明较小的模型更容易发生灾难性遗忘，而 LoRA 有助于缓解这一问题。增加数据多样性和调整视觉编码器也能提高性能。\n\n## 结论\n\n这篇论文提出了 Bunny，一种轻量级但强大的多模态模型家族。通过优化训练数据来补偿模型规模的减小，Bunny 在多个基准测试中表现出色，甚至超越了大型 MLLMs。这项工作为进一步研究和开发提供了一个干净、灵活的开源工具。\n\n这篇论文展示了通过数据优化来实现小型化 MLLM 的有效性，具有重要的理论和实际意义。\n\n![1741790898815C6ElbuABdopLlnx0596c9FYznG0.png](https://tk-pichost-1325224430.cos.ap-chengdu.myqcloud.com/blog/1741790898815C6ElbuABdopLlnx0596c9FYznG0.png)\n","source":"_posts/2025-03-12-Bunny轻量级多模态语言模型家族.md","raw":"---\ntitle: 2025-03-12-Bunny 轻量级多模态语言模型家族\ndate: 2025-03-12\ntags: \n    深度学习\n    论文阅读\n---\n> 论文链接\n> [https://arxiv.org/abs/2402.11530](https://arxiv.org/abs/2402.11530)\n\n# 全文总结\n\n一种名为 Bunny 的轻量级多模态语言模型家族，旨在通过优化训练数据来提高模型的性能，从而在计算资源有限的情况下实现高效的多模态学习。\n\n## 研究背景\n\n1. **背景介绍:** 多模态大型语言模型（MLLMs）在视觉理解和推理任务中表现出色，但其部署受到训练和推理阶段的高计算成本和内存消耗的限制。为了克服这一问题，研究者们尝试使用较小的预训练视觉和语言模型，但这通常会导致性能下降。\n2. **研究内容:** 通过优化训练数据来补偿模型规模的减小，从而在保持高性能的同时实现模型的小型化。\n3. **文献综述:** 多种轻量级 MLLM 的尝试，如 LLaVA-Phi、Imp 和 Vary-toy 等，这些工作通过使用小型语言模型和视觉编码器来实现模型的小型化。此外，还有研究探索了模型架构和训练策略的优化。\n\n## 研究方法\n\n这篇论文提出了 Bunny，一种轻量级的多模态模型家族，用于解决多模态学习中的计算成本问题。具体来说，\n\n![1741790887815EqNRbHjCOoXqZixhNGjcc7yXneh.png](https://tk-pichost-1325224430.cos.ap-chengdu.myqcloud.com/blog/1741790887815EqNRbHjCOoXqZixhNGjcc7yXneh.png)\n\n1. **训练数据构建:** 为了提高训练数据的有效性，作者从 LAION-2B 数据集中构建了高质量的预训练数据集 Bunny-pretrain-LAION-2M，并收集了视觉指令调整数据集 Bunny-695K。通过数据集精简技术，从广泛的源中选择更信息量的数据。\n2. **训练策略:** 采用两阶段训练策略：第一阶段进行预训练，对齐视觉嵌入和文本嵌入；第二阶段进行微调，应用视觉指令调整以充分利用 MLLM 的能力。在微调阶段，使用 LoRA 来训练 LLM 骨干，而视觉编码器和跨模态投影器则完全调整。\n\n> LoRA:基于大模型的内在低秩特性，增加旁路矩阵来模拟全参数微调，LoRA 通过简单有效的方案来达成轻量微调的目的。它的应用自不必提，可以将现在的各种大模型通过轻量微调变成各个不同领域的专业模型。\n> ![1741964606068RLo3b1D3moX6OCxShJrc5FiAnee.png](https://tk-pichost-1325224430.cos.ap-chengdu.myqcloud.com/blog/1741964606068RLo3b1D3moX6OCxShJrc5FiAnee.png)\n>\n> 1. 使用预训练的 LLM 权重初始化 A 和 B 矩阵。\n> 2. 将 LLM 应用于特定任务的训练数据集。\n> 3. 在训练过程中，只有 A 矩阵会针对训练数据集（输入资料（X））进行微调。\n> 4. 训练完成后，获得了针对特定任务适应的 LLM，也就是 H（输出）。\n>\n> - 举个例子，如果把预训练的大型语言模型比作一座已经建好的复杂大厦，LoRA 就像是给大厦的某些房间（对应模型的特定层）添加一些简易的可拆卸隔断（低秩矩阵模块）来改变房间布局（适应新任务），而不是对整座大厦的结构和所有房间进行大规模改造 ，这样既节省了时间和材料（计算资源和时间），又能达到灵活调整的目的 。\n\n## 实验设计\n\n1. **数据集:** 在多个基准测试上评估 Bunny 的性能，包括 MME 感知、MME 认知、MMBench、SEED-Bench-1、MMMU、VQA-v2、GQA、ScienceQAIMG 和 POPE 等。\n2. **对比模型:** 将 Bunny 与现有的最先进的多模态大型语言模型进行比较，包括 GPT-4V、BLIP-2、InstructBLIP、Shikra、SVIT、LVIS-INSTRUCT4V、ShareGPT4V、VILA1.5、Mini-Gemini-HD、LLaVA、MiniGPT-v2、mPLUG-Owl2、SPHINX-Intern2、YiVL、DeepSeek-VL、MM1、Idefics2、LLaVA-NeXT、MobileVLM、TinyLLaVA、Mipha、MiniCPM、Imp 等。\n3. **实验设置:** 在微调阶段使用 LoRA 进行训练，并对数据策略、训练周期、视觉编码器的冻结与调整等进行消融研究。\n\n## 结果与分析\n\n1. **性能比较:** Bunny-4B 和 Bunny-8B 在大多数基准测试中优于同尺寸的其他 MLLMs，显示出卓越的多模态理解和推理能力。特别是 Bunny-8B 在 MMEP 上取得了 1644.1 的高分，远超第二名 LLaVA-NeXT-Llama-3-8B（1603.7）。\n2. **消融研究:** LoRA 在微调阶段的表现优于完全调整 LLM，表明较小的模型更容易发生灾难性遗忘，而 LoRA 有助于缓解这一问题。增加数据多样性和调整视觉编码器也能提高性能。\n\n## 结论\n\n这篇论文提出了 Bunny，一种轻量级但强大的多模态模型家族。通过优化训练数据来补偿模型规模的减小，Bunny 在多个基准测试中表现出色，甚至超越了大型 MLLMs。这项工作为进一步研究和开发提供了一个干净、灵活的开源工具。\n\n这篇论文展示了通过数据优化来实现小型化 MLLM 的有效性，具有重要的理论和实际意义。\n\n![1741790898815C6ElbuABdopLlnx0596c9FYznG0.png](https://tk-pichost-1325224430.cos.ap-chengdu.myqcloud.com/blog/1741790898815C6ElbuABdopLlnx0596c9FYznG0.png)\n","slug":"2025-03-12-Bunny轻量级多模态语言模型家族","published":1,"updated":"2025-09-26T12:16:06.623Z","_id":"cmg0saj43001bjm8nbr3g7rjx","comments":1,"layout":"post","photos":[],"content":"<blockquote>\n<p>论文链接<br><a href=\"https://arxiv.org/abs/2402.11530\">https://arxiv.org/abs/2402.11530</a></p>\n</blockquote>\n<h1 id=\"全文总结\"><a href=\"#全文总结\" class=\"headerlink\" title=\"全文总结\"></a>全文总结</h1><p>一种名为 Bunny 的轻量级多模态语言模型家族，旨在通过优化训练数据来提高模型的性能，从而在计算资源有限的情况下实现高效的多模态学习。</p>\n<h2 id=\"研究背景\"><a href=\"#研究背景\" class=\"headerlink\" title=\"研究背景\"></a>研究背景</h2><ol>\n<li><strong>背景介绍:</strong> 多模态大型语言模型（MLLMs）在视觉理解和推理任务中表现出色，但其部署受到训练和推理阶段的高计算成本和内存消耗的限制。为了克服这一问题，研究者们尝试使用较小的预训练视觉和语言模型，但这通常会导致性能下降。</li>\n<li><strong>研究内容:</strong> 通过优化训练数据来补偿模型规模的减小，从而在保持高性能的同时实现模型的小型化。</li>\n<li><strong>文献综述:</strong> 多种轻量级 MLLM 的尝试，如 LLaVA-Phi、Imp 和 Vary-toy 等，这些工作通过使用小型语言模型和视觉编码器来实现模型的小型化。此外，还有研究探索了模型架构和训练策略的优化。</li>\n</ol>\n<h2 id=\"研究方法\"><a href=\"#研究方法\" class=\"headerlink\" title=\"研究方法\"></a>研究方法</h2><p>这篇论文提出了 Bunny，一种轻量级的多模态模型家族，用于解决多模态学习中的计算成本问题。具体来说，</p>\n<p><img src=\"https://tk-pichost-1325224430.cos.ap-chengdu.myqcloud.com/blog/1741790887815EqNRbHjCOoXqZixhNGjcc7yXneh.png\" alt=\"1741790887815EqNRbHjCOoXqZixhNGjcc7yXneh.png\"></p>\n<ol>\n<li><strong>训练数据构建:</strong> 为了提高训练数据的有效性，作者从 LAION-2B 数据集中构建了高质量的预训练数据集 Bunny-pretrain-LAION-2M，并收集了视觉指令调整数据集 Bunny-695K。通过数据集精简技术，从广泛的源中选择更信息量的数据。</li>\n<li><strong>训练策略:</strong> 采用两阶段训练策略：第一阶段进行预训练，对齐视觉嵌入和文本嵌入；第二阶段进行微调，应用视觉指令调整以充分利用 MLLM 的能力。在微调阶段，使用 LoRA 来训练 LLM 骨干，而视觉编码器和跨模态投影器则完全调整。</li>\n</ol>\n<blockquote>\n<p>LoRA:基于大模型的内在低秩特性，增加旁路矩阵来模拟全参数微调，LoRA 通过简单有效的方案来达成轻量微调的目的。它的应用自不必提，可以将现在的各种大模型通过轻量微调变成各个不同领域的专业模型。<br><img src=\"https://tk-pichost-1325224430.cos.ap-chengdu.myqcloud.com/blog/1741964606068RLo3b1D3moX6OCxShJrc5FiAnee.png\" alt=\"1741964606068RLo3b1D3moX6OCxShJrc5FiAnee.png\"></p>\n<ol>\n<li>使用预训练的 LLM 权重初始化 A 和 B 矩阵。</li>\n<li>将 LLM 应用于特定任务的训练数据集。</li>\n<li>在训练过程中，只有 A 矩阵会针对训练数据集（输入资料（X））进行微调。</li>\n<li>训练完成后，获得了针对特定任务适应的 LLM，也就是 H（输出）。</li>\n</ol>\n<ul>\n<li>举个例子，如果把预训练的大型语言模型比作一座已经建好的复杂大厦，LoRA 就像是给大厦的某些房间（对应模型的特定层）添加一些简易的可拆卸隔断（低秩矩阵模块）来改变房间布局（适应新任务），而不是对整座大厦的结构和所有房间进行大规模改造 ，这样既节省了时间和材料（计算资源和时间），又能达到灵活调整的目的 。</li>\n</ul>\n</blockquote>\n<h2 id=\"实验设计\"><a href=\"#实验设计\" class=\"headerlink\" title=\"实验设计\"></a>实验设计</h2><ol>\n<li><strong>数据集:</strong> 在多个基准测试上评估 Bunny 的性能，包括 MME 感知、MME 认知、MMBench、SEED-Bench-1、MMMU、VQA-v2、GQA、ScienceQAIMG 和 POPE 等。</li>\n<li><strong>对比模型:</strong> 将 Bunny 与现有的最先进的多模态大型语言模型进行比较，包括 GPT-4V、BLIP-2、InstructBLIP、Shikra、SVIT、LVIS-INSTRUCT4V、ShareGPT4V、VILA1.5、Mini-Gemini-HD、LLaVA、MiniGPT-v2、mPLUG-Owl2、SPHINX-Intern2、YiVL、DeepSeek-VL、MM1、Idefics2、LLaVA-NeXT、MobileVLM、TinyLLaVA、Mipha、MiniCPM、Imp 等。</li>\n<li><strong>实验设置:</strong> 在微调阶段使用 LoRA 进行训练，并对数据策略、训练周期、视觉编码器的冻结与调整等进行消融研究。</li>\n</ol>\n<h2 id=\"结果与分析\"><a href=\"#结果与分析\" class=\"headerlink\" title=\"结果与分析\"></a>结果与分析</h2><ol>\n<li><strong>性能比较:</strong> Bunny-4B 和 Bunny-8B 在大多数基准测试中优于同尺寸的其他 MLLMs，显示出卓越的多模态理解和推理能力。特别是 Bunny-8B 在 MMEP 上取得了 1644.1 的高分，远超第二名 LLaVA-NeXT-Llama-3-8B（1603.7）。</li>\n<li><strong>消融研究:</strong> LoRA 在微调阶段的表现优于完全调整 LLM，表明较小的模型更容易发生灾难性遗忘，而 LoRA 有助于缓解这一问题。增加数据多样性和调整视觉编码器也能提高性能。</li>\n</ol>\n<h2 id=\"结论\"><a href=\"#结论\" class=\"headerlink\" title=\"结论\"></a>结论</h2><p>这篇论文提出了 Bunny，一种轻量级但强大的多模态模型家族。通过优化训练数据来补偿模型规模的减小，Bunny 在多个基准测试中表现出色，甚至超越了大型 MLLMs。这项工作为进一步研究和开发提供了一个干净、灵活的开源工具。</p>\n<p>这篇论文展示了通过数据优化来实现小型化 MLLM 的有效性，具有重要的理论和实际意义。</p>\n<p><img src=\"https://tk-pichost-1325224430.cos.ap-chengdu.myqcloud.com/blog/1741790898815C6ElbuABdopLlnx0596c9FYznG0.png\" alt=\"1741790898815C6ElbuABdopLlnx0596c9FYznG0.png\"></p>\n","excerpt":"","more":"<blockquote>\n<p>论文链接<br><a href=\"https://arxiv.org/abs/2402.11530\">https://arxiv.org/abs/2402.11530</a></p>\n</blockquote>\n<h1 id=\"全文总结\"><a href=\"#全文总结\" class=\"headerlink\" title=\"全文总结\"></a>全文总结</h1><p>一种名为 Bunny 的轻量级多模态语言模型家族，旨在通过优化训练数据来提高模型的性能，从而在计算资源有限的情况下实现高效的多模态学习。</p>\n<h2 id=\"研究背景\"><a href=\"#研究背景\" class=\"headerlink\" title=\"研究背景\"></a>研究背景</h2><ol>\n<li><strong>背景介绍:</strong> 多模态大型语言模型（MLLMs）在视觉理解和推理任务中表现出色，但其部署受到训练和推理阶段的高计算成本和内存消耗的限制。为了克服这一问题，研究者们尝试使用较小的预训练视觉和语言模型，但这通常会导致性能下降。</li>\n<li><strong>研究内容:</strong> 通过优化训练数据来补偿模型规模的减小，从而在保持高性能的同时实现模型的小型化。</li>\n<li><strong>文献综述:</strong> 多种轻量级 MLLM 的尝试，如 LLaVA-Phi、Imp 和 Vary-toy 等，这些工作通过使用小型语言模型和视觉编码器来实现模型的小型化。此外，还有研究探索了模型架构和训练策略的优化。</li>\n</ol>\n<h2 id=\"研究方法\"><a href=\"#研究方法\" class=\"headerlink\" title=\"研究方法\"></a>研究方法</h2><p>这篇论文提出了 Bunny，一种轻量级的多模态模型家族，用于解决多模态学习中的计算成本问题。具体来说，</p>\n<p><img src=\"https://tk-pichost-1325224430.cos.ap-chengdu.myqcloud.com/blog/1741790887815EqNRbHjCOoXqZixhNGjcc7yXneh.png\" alt=\"1741790887815EqNRbHjCOoXqZixhNGjcc7yXneh.png\"></p>\n<ol>\n<li><strong>训练数据构建:</strong> 为了提高训练数据的有效性，作者从 LAION-2B 数据集中构建了高质量的预训练数据集 Bunny-pretrain-LAION-2M，并收集了视觉指令调整数据集 Bunny-695K。通过数据集精简技术，从广泛的源中选择更信息量的数据。</li>\n<li><strong>训练策略:</strong> 采用两阶段训练策略：第一阶段进行预训练，对齐视觉嵌入和文本嵌入；第二阶段进行微调，应用视觉指令调整以充分利用 MLLM 的能力。在微调阶段，使用 LoRA 来训练 LLM 骨干，而视觉编码器和跨模态投影器则完全调整。</li>\n</ol>\n<blockquote>\n<p>LoRA:基于大模型的内在低秩特性，增加旁路矩阵来模拟全参数微调，LoRA 通过简单有效的方案来达成轻量微调的目的。它的应用自不必提，可以将现在的各种大模型通过轻量微调变成各个不同领域的专业模型。<br><img src=\"https://tk-pichost-1325224430.cos.ap-chengdu.myqcloud.com/blog/1741964606068RLo3b1D3moX6OCxShJrc5FiAnee.png\" alt=\"1741964606068RLo3b1D3moX6OCxShJrc5FiAnee.png\"></p>\n<ol>\n<li>使用预训练的 LLM 权重初始化 A 和 B 矩阵。</li>\n<li>将 LLM 应用于特定任务的训练数据集。</li>\n<li>在训练过程中，只有 A 矩阵会针对训练数据集（输入资料（X））进行微调。</li>\n<li>训练完成后，获得了针对特定任务适应的 LLM，也就是 H（输出）。</li>\n</ol>\n<ul>\n<li>举个例子，如果把预训练的大型语言模型比作一座已经建好的复杂大厦，LoRA 就像是给大厦的某些房间（对应模型的特定层）添加一些简易的可拆卸隔断（低秩矩阵模块）来改变房间布局（适应新任务），而不是对整座大厦的结构和所有房间进行大规模改造 ，这样既节省了时间和材料（计算资源和时间），又能达到灵活调整的目的 。</li>\n</ul>\n</blockquote>\n<h2 id=\"实验设计\"><a href=\"#实验设计\" class=\"headerlink\" title=\"实验设计\"></a>实验设计</h2><ol>\n<li><strong>数据集:</strong> 在多个基准测试上评估 Bunny 的性能，包括 MME 感知、MME 认知、MMBench、SEED-Bench-1、MMMU、VQA-v2、GQA、ScienceQAIMG 和 POPE 等。</li>\n<li><strong>对比模型:</strong> 将 Bunny 与现有的最先进的多模态大型语言模型进行比较，包括 GPT-4V、BLIP-2、InstructBLIP、Shikra、SVIT、LVIS-INSTRUCT4V、ShareGPT4V、VILA1.5、Mini-Gemini-HD、LLaVA、MiniGPT-v2、mPLUG-Owl2、SPHINX-Intern2、YiVL、DeepSeek-VL、MM1、Idefics2、LLaVA-NeXT、MobileVLM、TinyLLaVA、Mipha、MiniCPM、Imp 等。</li>\n<li><strong>实验设置:</strong> 在微调阶段使用 LoRA 进行训练，并对数据策略、训练周期、视觉编码器的冻结与调整等进行消融研究。</li>\n</ol>\n<h2 id=\"结果与分析\"><a href=\"#结果与分析\" class=\"headerlink\" title=\"结果与分析\"></a>结果与分析</h2><ol>\n<li><strong>性能比较:</strong> Bunny-4B 和 Bunny-8B 在大多数基准测试中优于同尺寸的其他 MLLMs，显示出卓越的多模态理解和推理能力。特别是 Bunny-8B 在 MMEP 上取得了 1644.1 的高分，远超第二名 LLaVA-NeXT-Llama-3-8B（1603.7）。</li>\n<li><strong>消融研究:</strong> LoRA 在微调阶段的表现优于完全调整 LLM，表明较小的模型更容易发生灾难性遗忘，而 LoRA 有助于缓解这一问题。增加数据多样性和调整视觉编码器也能提高性能。</li>\n</ol>\n<h2 id=\"结论\"><a href=\"#结论\" class=\"headerlink\" title=\"结论\"></a>结论</h2><p>这篇论文提出了 Bunny，一种轻量级但强大的多模态模型家族。通过优化训练数据来补偿模型规模的减小，Bunny 在多个基准测试中表现出色，甚至超越了大型 MLLMs。这项工作为进一步研究和开发提供了一个干净、灵活的开源工具。</p>\n<p>这篇论文展示了通过数据优化来实现小型化 MLLM 的有效性，具有重要的理论和实际意义。</p>\n<p><img src=\"https://tk-pichost-1325224430.cos.ap-chengdu.myqcloud.com/blog/1741790898815C6ElbuABdopLlnx0596c9FYznG0.png\" alt=\"1741790898815C6ElbuABdopLlnx0596c9FYznG0.png\"></p>\n"},{"title":"2025-04-23-基于上下位机结构的系统实例分析","date":"2025-04-22T16:00:00.000Z","_content":"# 基于上下位机结构的系统实例分析\n\n# 参考资料\n\n> - [上位机开发介绍](https://blog.csdn.net/BadAyase/article/details/102680588)\n> - [上位机那些事儿 - 常哥说编程 - 博客园](https://www.cnblogs.com/xiketang/p/15305637.html)\n> - [介绍上位机和下位机](https://blog.51cto.com/u_15712566/5457487)\n> - [上位机与下位机有什么区别？它们的关系是什么？](https://www.sohu.com/a/748967956_120070959)\n> - [论上位机与下位机的工作原理及应用区别](https://www.ebyte.com/news/3065.html)\n> - [什么是上位机_上位机软件介绍](https://m.elecfans.com/article/286528.html)\n> - [如何给下位机编写一个简单的上位机？](https://ee.ofweek.com/2021-01/ART-11000-2814-30482117.html)\n> - [上位机那些事儿 - 常哥说编程](https://www.cnblogs.com/xiketang/p/15305637.html)\n\n# 引言\n\n在现代工业自动化、物联网和智能控制领域，上下位机结构是一种核心的分层控制架构。上位机（Upper Computer）通常是功能强大的计算机，如个人电脑、工业 PC 或服务器，负责监控、数据处理、用户交互和决策制定。下位机（Lower Computer）是直接与物理设备（如传感器、执行器）连接的控制器，如可编程逻辑控制器（PLC）、单片机或嵌入式系统，负责执行具体任务和数据采集。这种结构通过通信协议（如 Modbus、TCP/IP）实现高效协作，广泛应用于工业、物联网和嵌入式系统等领域。\n\n![1749360238852HJiCbmVvbojFg4xx4DbcUta2nYf.png](https://gitee.com/tanke11223344/imagehost/raw/main/blog/1749360238852HJiCbmVvbojFg4xx4DbcUta2nYf.png)\n\n基于上下位机结构的软件示例\n\n# 上下位机结构概述\n\n上下位机系统，也称为主从（Master-Slave）系统，是一种分层控制架构。它由一个处于控制地位的“上位机”（Master）和一个或多个受其控制的“下位机”（Slave）组成。\n\n- **上位机（Master）：** 通常是功能更强大、资源更丰富的计算机或控制单元。它负责发送指令、监控下位机的状态以及进行数据处理和分析。上位机往往具备人机交互界面，方便用户进行操作和管理。\n\n> 典型设备：电脑、平板、手机、面板、触摸屏\n\n- **下位机（Slave）：** 通常是资源相对有限的嵌入式系统、单片机或执行特定任务的设备。它们接收并执行来自上位机的指令，并将执行结果或采集的数据反馈给上位机。\n\n> 典型设备：PLC、stm32、51、FPGA、ARM 等各类可编程芯片。\n\n![1749360247852LxqkbwQ33oiuqlxEitFc8ub4ndc.png](https://gitee.com/tanke11223344/imagehost/raw/main/blog/1749360247852LxqkbwQ33oiuqlxEitFc8ub4ndc.png)\n\n典型的工业控制系统分为现场设备层和现场控制层，分别负责与物理设备交互和实时控制。在它们之上还有过程监控层、生产管理层（MES）、企业决策层（ERP），这三个层次统称为“上位机”系统。\n\n如果系统没有完整的上位机层，也无妨，因为上位机仅用于监控和管理，并非直接负责执行 。广义上，“上位机”指所有基于 PC 的监控管理系统（如 SCADA、MES、ERP）；狭义上，多指 SCADA 本身，用于实时监控和数据采集。\n\n## 通信协议与通信 API\n\n### 通信协议（通信方式）\n\n上位机和下位机之间的通信协议有很多，只要能完成通信的协议都可以用在上位机与下位机之间。\n\n比如：\n\n通信协议：RS232/RS485 串行通信、USB、蓝牙、网络 UDP/TCP\n\n这个通信协议也是实现上位机与下位机之间数据交换的基本通道。\n\n![1749360261852Nz3rbIyZno5yunxpGgVcvX9HnXd.png](https://gitee.com/tanke11223344/imagehost/raw/main/blog/1749360261852Nz3rbIyZno5yunxpGgVcvX9HnXd.png)\n![1749360271853AkrsbvBSxoFHdFxOkKjcvwFqnug.png](https://gitee.com/tanke11223344/imagehost/raw/main/blog/1749360271853AkrsbvBSxoFHdFxOkKjcvwFqnug.png)\n\n### 通信 API\n\n在通信协议的基础上，具体发送什么数据即发送什么指令，还需要规定各个功能所对应的指令（上位机发给下位机的指令）。\n\n每个功能所对应的指令叫做 API（Application Programming Interface）, 在实际工作中常称这个 api 为“私有通信协议”。\n\n举例一条获取温度的 api：\n\n```bash\n[包头 + 获取温度对应的命令编码（编号）+ 校验位 + 包尾]\n```\n\napi 的命令格式，是自定义的一种固定的数据组合格式。不受任何通信方式和通信平台的限制。这就意味着，只要通信协议（通信方式）可以建立，上位机软件可以是任意开发语言和任意开发平台，下位机也可以使用任意类型的单片机。\n\n上位机主要是对接 PLC、仪表、运动控制卡、视觉等，通信方式包括通信协议、OPC、API 或 SDK，如下图所示：\n\n![1749360284853ZrjUbb7O6oWXLyxl0ezcsZsvnbc.png](https://gitee.com/tanke11223344/imagehost/raw/main/blog/1749360284853ZrjUbb7O6oWXLyxl0ezcsZsvnbc.png)\n\n## 定义与功能\n\n上位机和下位机在控制系统中分工明确，功能互补：\n\n上位机作为系统的“大脑”，处理复杂任务并与用户交互；下位机作为“执行者”，确保实时性和精确性。两者通过串口（RS232/RS485）、以太网或无线协议通信，形成高效的控制体系。\n\n## 工作原理\n\n![1749360295853Wqq4bMNQAot40JxAMsfch8w5ntd.png](https://gitee.com/tanke11223344/imagehost/raw/main/blog/1749360295853Wqq4bMNQAot40JxAMsfch8w5ntd.png)\n\n上位机发送的指令会首先传递给下位机，下位机收到后将其解析为相应的时序信号，从而直接驱动具体的设备运行。下位机会不断采集设备的状态数据（通常为模拟量），并将这些数据转换为数字信号，上报给上位机进行监控与处理 。\n\n上下位机均需进行编程开发，且各自拥有针对性的开发环境与工具，下位机常见于 PLC、单片机或智能模块等，而上位机通常为基于 PC 的监控管理系统 。\n\n在系统架构层面，上位机相当于“控制者”和“服务提供者”，负责发出控制指令并处理反馈；下位机则扮演“被控制者”和“服务执行者”，直接与现场设备交互，实现具体控制逻辑。两者之间的通信方式多样，通常由下位机来决定其所支持的专有协议，以保证数据传输的可靠性与实时性，例如常见的 RS232、RS485、MODBUS、PROFIBUS 等 。\n\n下位机在出厂时一般会附带详细的通信手册，其中定义了该设备专用的协议格式与帧结构，开发人员在进行上位机编程时只需调用相应的 API 或驱动库即可快速实现通信对接。因此，主机与从机的关系不仅体现在控制与被控上，更体现在两者通信协议的配合与适配上，以确保工业现场系统的稳定运行与高效协同。\n\n# 开发工具\n\n上位机开发通常使用 C/C++（Qt、MFC）、C#（.NET 平下的 WinForms/WPF）、VB。其中就目前的情况来看，Qt 和 WinForms 应该是目前应用相对比较广的。VB 和 MFC 比较老旧，做的界面也比较有年代感。其中，新版本的 Qt 还支持用 Python 来编写。而 WPF 算是后起之秀，也逐渐替代 WinForms，其制作的上位机界面较新式。其他，一些组态软件是专门做上位机软件的，像组态王、力控，相当于是二次开发，门槛较低一些，操作也比较简单，但是拓展性差。\n\n# 系统实例分析\n\n## **工业自动化控制系统**\n\n在工厂的自动化生产线上，上位机通常是工控机（Industrial PC）或 PLC（可编程逻辑控制器），负责监控和协调整个生产过程。下位机则是各种执行机构，如机械臂、传感器、电机驱动器等。\n\n- **例子：** 假设一条饮料灌装生产线。上位机通过人机界面接收生产指令（例如，灌装多少瓶、什么类型的饮料等）。然后，上位机向下位机的各个模块发送指令：\n  - 发送指令给**传送带控制下位机**，启动传送带。\n  - 发送指令给**灌装机下位机**，控制饮料的精确灌装。\n  - 发送指令给**封盖机下位机**，完成瓶盖的封装。\n  - 发送指令给**贴标机下位机**，进行标签的粘贴。\n  - 各个下位机在完成任务后，将状态信息（例如，是否完成、是否有异常等）反馈给上位机。\n\n## **智能家居系统**\n\n在智能家居系统中，上位机通常是中央控制主机、智能手机 App 或语音助手，负责接收用户的指令和管理各个智能设备。下位机则是各种智能家居设备，如智能灯泡、智能插座、智能门锁、环境传感器等。\n\n- **例子：** 用户通过手机 App（上位机）发送指令打开客厅的灯。\n  - 手机 App 将“打开客厅灯”的指令发送给**中央控制主机（上位机）**。\n  - 中央控制主机通过无线协议（例如，Zigbee、Wi-Fi）将指令发送给**客厅的智能灯泡（下位机）**。\n  - 智能灯泡接收到指令后，执行亮灯操作，并可能将状态信息（例如，当前亮度、颜色等）反馈给中央控制主机，最终显示在手机 App 上。\n\n## **机器人控制系统**\n\n在机器人控制系统中，上位机通常是负责路径规划、任务决策的高性能处理器或工作站。下位机则是机器人的各个关节驱动器、传感器、末端执行器等。\n\n- **例子：** 一个巡逻机器人需要按照预设的路线进行巡逻，并在发现异常情况时进行上报。\n  - 上位机（例如，嵌入式主板或工控机）负责存储巡逻路线、分析传感器数据以识别异常、并进行通信。\n  - 下位机（例如，电机驱动器、摄像头、红外传感器等）负责执行电机的运动指令、采集图像和环境数据。\n  - 上位机根据预设路线，向下位机的电机驱动器发送运动指令。同时，上位机接收来自摄像头和红外传感器的数据，进行分析。如果发现异常情况（例如，检测到移动物体），上位机会将警报信息发送给远程监控系统（可以看作更高级别的上位机）。\n\n## **医疗设备**\n\n在一些复杂的医疗设备中，也采用上下位机结构。例如，医学影像设备或监护系统。\n\n- **例子：** 一台 CT 扫描仪。\n  - 上位机（操作控制台的计算机）负责接收医生的扫描参数设置、控制扫描过程、进行图像重建和显示。\n  - 下位机（扫描床控制器、X 射线发生器控制器、数据采集系统等）负责按照上位机的指令精确地移动病人、发射 X 射线、采集数据。\n\n# 上下位机系统的优缺点\n\n**优点：**\n\n- **结构清晰，易于理解：** 分层结构使得系统逻辑清晰，方便开发和维护。\n- **资源优化利用：** 上位机负责复杂的计算和管理，下位机专注于特定任务，可以根据需求选择合适的硬件资源。\n- **可靠性高：** 下位机通常功能单一，故障率相对较低。即使某个下位机出现故障，通常不会影响整个系统的运行。\n- **良好的实时性：** 下位机可以针对实时性要求较高的任务进行优化设计。\n\n**缺点：**\n\n- **依赖性强：** 下位机的运行完全依赖于上位机的指令，一旦上位机发生故障，整个系统可能会瘫痪。\n- **通信负担：** 上位机需要与多个下位机进行通信，当系统规模较大时，通信量可能会成为瓶颈。\n- **实时性要求高的场景中，上位机的响应速度可能影响下位机的性能。**\n\n上下位机结构在工业自动化中仍占主导，但物联网技术的兴起可能部分取代传统 SCADA 系统。例如，工业物联网（IIoT）通过更智能的连接生态提供更高的灵活性，但在实时性和可靠性方面，传统上下位机结构仍具优势。争议在于，是否应完全转向物联网架构，还是继续优化现有结构以适应新需求。\n\n# 结论\n\n- 上位机是指可以直接发出操控命令的计算机\n- 下位机是直接控制设备获取设备状况的计算机\n- 工控机，工作站，触摸屏作为上位机， 通信控制 PLC，单片机等作为下位机\n","source":"_posts/2025-04-23-基于上下位机结构的系统实例分析.md","raw":"---\ntitle:  2025-04-23-基于上下位机结构的系统实例分析\ndate: 2025-04-23\ntags: \n    课程学习\n---\n# 基于上下位机结构的系统实例分析\n\n# 参考资料\n\n> - [上位机开发介绍](https://blog.csdn.net/BadAyase/article/details/102680588)\n> - [上位机那些事儿 - 常哥说编程 - 博客园](https://www.cnblogs.com/xiketang/p/15305637.html)\n> - [介绍上位机和下位机](https://blog.51cto.com/u_15712566/5457487)\n> - [上位机与下位机有什么区别？它们的关系是什么？](https://www.sohu.com/a/748967956_120070959)\n> - [论上位机与下位机的工作原理及应用区别](https://www.ebyte.com/news/3065.html)\n> - [什么是上位机_上位机软件介绍](https://m.elecfans.com/article/286528.html)\n> - [如何给下位机编写一个简单的上位机？](https://ee.ofweek.com/2021-01/ART-11000-2814-30482117.html)\n> - [上位机那些事儿 - 常哥说编程](https://www.cnblogs.com/xiketang/p/15305637.html)\n\n# 引言\n\n在现代工业自动化、物联网和智能控制领域，上下位机结构是一种核心的分层控制架构。上位机（Upper Computer）通常是功能强大的计算机，如个人电脑、工业 PC 或服务器，负责监控、数据处理、用户交互和决策制定。下位机（Lower Computer）是直接与物理设备（如传感器、执行器）连接的控制器，如可编程逻辑控制器（PLC）、单片机或嵌入式系统，负责执行具体任务和数据采集。这种结构通过通信协议（如 Modbus、TCP/IP）实现高效协作，广泛应用于工业、物联网和嵌入式系统等领域。\n\n![1749360238852HJiCbmVvbojFg4xx4DbcUta2nYf.png](https://gitee.com/tanke11223344/imagehost/raw/main/blog/1749360238852HJiCbmVvbojFg4xx4DbcUta2nYf.png)\n\n基于上下位机结构的软件示例\n\n# 上下位机结构概述\n\n上下位机系统，也称为主从（Master-Slave）系统，是一种分层控制架构。它由一个处于控制地位的“上位机”（Master）和一个或多个受其控制的“下位机”（Slave）组成。\n\n- **上位机（Master）：** 通常是功能更强大、资源更丰富的计算机或控制单元。它负责发送指令、监控下位机的状态以及进行数据处理和分析。上位机往往具备人机交互界面，方便用户进行操作和管理。\n\n> 典型设备：电脑、平板、手机、面板、触摸屏\n\n- **下位机（Slave）：** 通常是资源相对有限的嵌入式系统、单片机或执行特定任务的设备。它们接收并执行来自上位机的指令，并将执行结果或采集的数据反馈给上位机。\n\n> 典型设备：PLC、stm32、51、FPGA、ARM 等各类可编程芯片。\n\n![1749360247852LxqkbwQ33oiuqlxEitFc8ub4ndc.png](https://gitee.com/tanke11223344/imagehost/raw/main/blog/1749360247852LxqkbwQ33oiuqlxEitFc8ub4ndc.png)\n\n典型的工业控制系统分为现场设备层和现场控制层，分别负责与物理设备交互和实时控制。在它们之上还有过程监控层、生产管理层（MES）、企业决策层（ERP），这三个层次统称为“上位机”系统。\n\n如果系统没有完整的上位机层，也无妨，因为上位机仅用于监控和管理，并非直接负责执行 。广义上，“上位机”指所有基于 PC 的监控管理系统（如 SCADA、MES、ERP）；狭义上，多指 SCADA 本身，用于实时监控和数据采集。\n\n## 通信协议与通信 API\n\n### 通信协议（通信方式）\n\n上位机和下位机之间的通信协议有很多，只要能完成通信的协议都可以用在上位机与下位机之间。\n\n比如：\n\n通信协议：RS232/RS485 串行通信、USB、蓝牙、网络 UDP/TCP\n\n这个通信协议也是实现上位机与下位机之间数据交换的基本通道。\n\n![1749360261852Nz3rbIyZno5yunxpGgVcvX9HnXd.png](https://gitee.com/tanke11223344/imagehost/raw/main/blog/1749360261852Nz3rbIyZno5yunxpGgVcvX9HnXd.png)\n![1749360271853AkrsbvBSxoFHdFxOkKjcvwFqnug.png](https://gitee.com/tanke11223344/imagehost/raw/main/blog/1749360271853AkrsbvBSxoFHdFxOkKjcvwFqnug.png)\n\n### 通信 API\n\n在通信协议的基础上，具体发送什么数据即发送什么指令，还需要规定各个功能所对应的指令（上位机发给下位机的指令）。\n\n每个功能所对应的指令叫做 API（Application Programming Interface）, 在实际工作中常称这个 api 为“私有通信协议”。\n\n举例一条获取温度的 api：\n\n```bash\n[包头 + 获取温度对应的命令编码（编号）+ 校验位 + 包尾]\n```\n\napi 的命令格式，是自定义的一种固定的数据组合格式。不受任何通信方式和通信平台的限制。这就意味着，只要通信协议（通信方式）可以建立，上位机软件可以是任意开发语言和任意开发平台，下位机也可以使用任意类型的单片机。\n\n上位机主要是对接 PLC、仪表、运动控制卡、视觉等，通信方式包括通信协议、OPC、API 或 SDK，如下图所示：\n\n![1749360284853ZrjUbb7O6oWXLyxl0ezcsZsvnbc.png](https://gitee.com/tanke11223344/imagehost/raw/main/blog/1749360284853ZrjUbb7O6oWXLyxl0ezcsZsvnbc.png)\n\n## 定义与功能\n\n上位机和下位机在控制系统中分工明确，功能互补：\n\n上位机作为系统的“大脑”，处理复杂任务并与用户交互；下位机作为“执行者”，确保实时性和精确性。两者通过串口（RS232/RS485）、以太网或无线协议通信，形成高效的控制体系。\n\n## 工作原理\n\n![1749360295853Wqq4bMNQAot40JxAMsfch8w5ntd.png](https://gitee.com/tanke11223344/imagehost/raw/main/blog/1749360295853Wqq4bMNQAot40JxAMsfch8w5ntd.png)\n\n上位机发送的指令会首先传递给下位机，下位机收到后将其解析为相应的时序信号，从而直接驱动具体的设备运行。下位机会不断采集设备的状态数据（通常为模拟量），并将这些数据转换为数字信号，上报给上位机进行监控与处理 。\n\n上下位机均需进行编程开发，且各自拥有针对性的开发环境与工具，下位机常见于 PLC、单片机或智能模块等，而上位机通常为基于 PC 的监控管理系统 。\n\n在系统架构层面，上位机相当于“控制者”和“服务提供者”，负责发出控制指令并处理反馈；下位机则扮演“被控制者”和“服务执行者”，直接与现场设备交互，实现具体控制逻辑。两者之间的通信方式多样，通常由下位机来决定其所支持的专有协议，以保证数据传输的可靠性与实时性，例如常见的 RS232、RS485、MODBUS、PROFIBUS 等 。\n\n下位机在出厂时一般会附带详细的通信手册，其中定义了该设备专用的协议格式与帧结构，开发人员在进行上位机编程时只需调用相应的 API 或驱动库即可快速实现通信对接。因此，主机与从机的关系不仅体现在控制与被控上，更体现在两者通信协议的配合与适配上，以确保工业现场系统的稳定运行与高效协同。\n\n# 开发工具\n\n上位机开发通常使用 C/C++（Qt、MFC）、C#（.NET 平下的 WinForms/WPF）、VB。其中就目前的情况来看，Qt 和 WinForms 应该是目前应用相对比较广的。VB 和 MFC 比较老旧，做的界面也比较有年代感。其中，新版本的 Qt 还支持用 Python 来编写。而 WPF 算是后起之秀，也逐渐替代 WinForms，其制作的上位机界面较新式。其他，一些组态软件是专门做上位机软件的，像组态王、力控，相当于是二次开发，门槛较低一些，操作也比较简单，但是拓展性差。\n\n# 系统实例分析\n\n## **工业自动化控制系统**\n\n在工厂的自动化生产线上，上位机通常是工控机（Industrial PC）或 PLC（可编程逻辑控制器），负责监控和协调整个生产过程。下位机则是各种执行机构，如机械臂、传感器、电机驱动器等。\n\n- **例子：** 假设一条饮料灌装生产线。上位机通过人机界面接收生产指令（例如，灌装多少瓶、什么类型的饮料等）。然后，上位机向下位机的各个模块发送指令：\n  - 发送指令给**传送带控制下位机**，启动传送带。\n  - 发送指令给**灌装机下位机**，控制饮料的精确灌装。\n  - 发送指令给**封盖机下位机**，完成瓶盖的封装。\n  - 发送指令给**贴标机下位机**，进行标签的粘贴。\n  - 各个下位机在完成任务后，将状态信息（例如，是否完成、是否有异常等）反馈给上位机。\n\n## **智能家居系统**\n\n在智能家居系统中，上位机通常是中央控制主机、智能手机 App 或语音助手，负责接收用户的指令和管理各个智能设备。下位机则是各种智能家居设备，如智能灯泡、智能插座、智能门锁、环境传感器等。\n\n- **例子：** 用户通过手机 App（上位机）发送指令打开客厅的灯。\n  - 手机 App 将“打开客厅灯”的指令发送给**中央控制主机（上位机）**。\n  - 中央控制主机通过无线协议（例如，Zigbee、Wi-Fi）将指令发送给**客厅的智能灯泡（下位机）**。\n  - 智能灯泡接收到指令后，执行亮灯操作，并可能将状态信息（例如，当前亮度、颜色等）反馈给中央控制主机，最终显示在手机 App 上。\n\n## **机器人控制系统**\n\n在机器人控制系统中，上位机通常是负责路径规划、任务决策的高性能处理器或工作站。下位机则是机器人的各个关节驱动器、传感器、末端执行器等。\n\n- **例子：** 一个巡逻机器人需要按照预设的路线进行巡逻，并在发现异常情况时进行上报。\n  - 上位机（例如，嵌入式主板或工控机）负责存储巡逻路线、分析传感器数据以识别异常、并进行通信。\n  - 下位机（例如，电机驱动器、摄像头、红外传感器等）负责执行电机的运动指令、采集图像和环境数据。\n  - 上位机根据预设路线，向下位机的电机驱动器发送运动指令。同时，上位机接收来自摄像头和红外传感器的数据，进行分析。如果发现异常情况（例如，检测到移动物体），上位机会将警报信息发送给远程监控系统（可以看作更高级别的上位机）。\n\n## **医疗设备**\n\n在一些复杂的医疗设备中，也采用上下位机结构。例如，医学影像设备或监护系统。\n\n- **例子：** 一台 CT 扫描仪。\n  - 上位机（操作控制台的计算机）负责接收医生的扫描参数设置、控制扫描过程、进行图像重建和显示。\n  - 下位机（扫描床控制器、X 射线发生器控制器、数据采集系统等）负责按照上位机的指令精确地移动病人、发射 X 射线、采集数据。\n\n# 上下位机系统的优缺点\n\n**优点：**\n\n- **结构清晰，易于理解：** 分层结构使得系统逻辑清晰，方便开发和维护。\n- **资源优化利用：** 上位机负责复杂的计算和管理，下位机专注于特定任务，可以根据需求选择合适的硬件资源。\n- **可靠性高：** 下位机通常功能单一，故障率相对较低。即使某个下位机出现故障，通常不会影响整个系统的运行。\n- **良好的实时性：** 下位机可以针对实时性要求较高的任务进行优化设计。\n\n**缺点：**\n\n- **依赖性强：** 下位机的运行完全依赖于上位机的指令，一旦上位机发生故障，整个系统可能会瘫痪。\n- **通信负担：** 上位机需要与多个下位机进行通信，当系统规模较大时，通信量可能会成为瓶颈。\n- **实时性要求高的场景中，上位机的响应速度可能影响下位机的性能。**\n\n上下位机结构在工业自动化中仍占主导，但物联网技术的兴起可能部分取代传统 SCADA 系统。例如，工业物联网（IIoT）通过更智能的连接生态提供更高的灵活性，但在实时性和可靠性方面，传统上下位机结构仍具优势。争议在于，是否应完全转向物联网架构，还是继续优化现有结构以适应新需求。\n\n# 结论\n\n- 上位机是指可以直接发出操控命令的计算机\n- 下位机是直接控制设备获取设备状况的计算机\n- 工控机，工作站，触摸屏作为上位机， 通信控制 PLC，单片机等作为下位机\n","slug":"2025-04-23-基于上下位机结构的系统实例分析","published":1,"updated":"2025-09-26T12:17:04.622Z","_id":"cmg0saj44001ejm8nfy59a396","comments":1,"layout":"post","photos":[],"content":"<h1 id=\"基于上下位机结构的系统实例分析\"><a href=\"#基于上下位机结构的系统实例分析\" class=\"headerlink\" title=\"基于上下位机结构的系统实例分析\"></a>基于上下位机结构的系统实例分析</h1><h1 id=\"参考资料\"><a href=\"#参考资料\" class=\"headerlink\" title=\"参考资料\"></a>参考资料</h1><blockquote>\n<ul>\n<li><a href=\"https://blog.csdn.net/BadAyase/article/details/102680588\">上位机开发介绍</a></li>\n<li><a href=\"https://www.cnblogs.com/xiketang/p/15305637.html\">上位机那些事儿 - 常哥说编程 - 博客园</a></li>\n<li><a href=\"https://blog.51cto.com/u_15712566/5457487\">介绍上位机和下位机</a></li>\n<li><a href=\"https://www.sohu.com/a/748967956_120070959\">上位机与下位机有什么区别？它们的关系是什么？</a></li>\n<li><a href=\"https://www.ebyte.com/news/3065.html\">论上位机与下位机的工作原理及应用区别</a></li>\n<li><a href=\"https://m.elecfans.com/article/286528.html\">什么是上位机_上位机软件介绍</a></li>\n<li><a href=\"https://ee.ofweek.com/2021-01/ART-11000-2814-30482117.html\">如何给下位机编写一个简单的上位机？</a></li>\n<li><a href=\"https://www.cnblogs.com/xiketang/p/15305637.html\">上位机那些事儿 - 常哥说编程</a></li>\n</ul>\n</blockquote>\n<h1 id=\"引言\"><a href=\"#引言\" class=\"headerlink\" title=\"引言\"></a>引言</h1><p>在现代工业自动化、物联网和智能控制领域，上下位机结构是一种核心的分层控制架构。上位机（Upper Computer）通常是功能强大的计算机，如个人电脑、工业 PC 或服务器，负责监控、数据处理、用户交互和决策制定。下位机（Lower Computer）是直接与物理设备（如传感器、执行器）连接的控制器，如可编程逻辑控制器（PLC）、单片机或嵌入式系统，负责执行具体任务和数据采集。这种结构通过通信协议（如 Modbus、TCP&#x2F;IP）实现高效协作，广泛应用于工业、物联网和嵌入式系统等领域。</p>\n<p><img src=\"https://gitee.com/tanke11223344/imagehost/raw/main/blog/1749360238852HJiCbmVvbojFg4xx4DbcUta2nYf.png\" alt=\"1749360238852HJiCbmVvbojFg4xx4DbcUta2nYf.png\"></p>\n<p>基于上下位机结构的软件示例</p>\n<h1 id=\"上下位机结构概述\"><a href=\"#上下位机结构概述\" class=\"headerlink\" title=\"上下位机结构概述\"></a>上下位机结构概述</h1><p>上下位机系统，也称为主从（Master-Slave）系统，是一种分层控制架构。它由一个处于控制地位的“上位机”（Master）和一个或多个受其控制的“下位机”（Slave）组成。</p>\n<ul>\n<li><strong>上位机（Master）：</strong> 通常是功能更强大、资源更丰富的计算机或控制单元。它负责发送指令、监控下位机的状态以及进行数据处理和分析。上位机往往具备人机交互界面，方便用户进行操作和管理。</li>\n</ul>\n<blockquote>\n<p>典型设备：电脑、平板、手机、面板、触摸屏</p>\n</blockquote>\n<ul>\n<li><strong>下位机（Slave）：</strong> 通常是资源相对有限的嵌入式系统、单片机或执行特定任务的设备。它们接收并执行来自上位机的指令，并将执行结果或采集的数据反馈给上位机。</li>\n</ul>\n<blockquote>\n<p>典型设备：PLC、stm32、51、FPGA、ARM 等各类可编程芯片。</p>\n</blockquote>\n<p><img src=\"https://gitee.com/tanke11223344/imagehost/raw/main/blog/1749360247852LxqkbwQ33oiuqlxEitFc8ub4ndc.png\" alt=\"1749360247852LxqkbwQ33oiuqlxEitFc8ub4ndc.png\"></p>\n<p>典型的工业控制系统分为现场设备层和现场控制层，分别负责与物理设备交互和实时控制。在它们之上还有过程监控层、生产管理层（MES）、企业决策层（ERP），这三个层次统称为“上位机”系统。</p>\n<p>如果系统没有完整的上位机层，也无妨，因为上位机仅用于监控和管理，并非直接负责执行 。广义上，“上位机”指所有基于 PC 的监控管理系统（如 SCADA、MES、ERP）；狭义上，多指 SCADA 本身，用于实时监控和数据采集。</p>\n<h2 id=\"通信协议与通信-API\"><a href=\"#通信协议与通信-API\" class=\"headerlink\" title=\"通信协议与通信 API\"></a>通信协议与通信 API</h2><h3 id=\"通信协议（通信方式）\"><a href=\"#通信协议（通信方式）\" class=\"headerlink\" title=\"通信协议（通信方式）\"></a>通信协议（通信方式）</h3><p>上位机和下位机之间的通信协议有很多，只要能完成通信的协议都可以用在上位机与下位机之间。</p>\n<p>比如：</p>\n<p>通信协议：RS232&#x2F;RS485 串行通信、USB、蓝牙、网络 UDP&#x2F;TCP</p>\n<p>这个通信协议也是实现上位机与下位机之间数据交换的基本通道。</p>\n<p><img src=\"https://gitee.com/tanke11223344/imagehost/raw/main/blog/1749360261852Nz3rbIyZno5yunxpGgVcvX9HnXd.png\" alt=\"1749360261852Nz3rbIyZno5yunxpGgVcvX9HnXd.png\"><br><img src=\"https://gitee.com/tanke11223344/imagehost/raw/main/blog/1749360271853AkrsbvBSxoFHdFxOkKjcvwFqnug.png\" alt=\"1749360271853AkrsbvBSxoFHdFxOkKjcvwFqnug.png\"></p>\n<h3 id=\"通信-API\"><a href=\"#通信-API\" class=\"headerlink\" title=\"通信 API\"></a>通信 API</h3><p>在通信协议的基础上，具体发送什么数据即发送什么指令，还需要规定各个功能所对应的指令（上位机发给下位机的指令）。</p>\n<p>每个功能所对应的指令叫做 API（Application Programming Interface）, 在实际工作中常称这个 api 为“私有通信协议”。</p>\n<p>举例一条获取温度的 api：</p>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">[包头 + 获取温度对应的命令编码（编号）+ 校验位 + 包尾]</span><br></pre></td></tr></table></figure>\n\n<p>api 的命令格式，是自定义的一种固定的数据组合格式。不受任何通信方式和通信平台的限制。这就意味着，只要通信协议（通信方式）可以建立，上位机软件可以是任意开发语言和任意开发平台，下位机也可以使用任意类型的单片机。</p>\n<p>上位机主要是对接 PLC、仪表、运动控制卡、视觉等，通信方式包括通信协议、OPC、API 或 SDK，如下图所示：</p>\n<p><img src=\"https://gitee.com/tanke11223344/imagehost/raw/main/blog/1749360284853ZrjUbb7O6oWXLyxl0ezcsZsvnbc.png\" alt=\"1749360284853ZrjUbb7O6oWXLyxl0ezcsZsvnbc.png\"></p>\n<h2 id=\"定义与功能\"><a href=\"#定义与功能\" class=\"headerlink\" title=\"定义与功能\"></a>定义与功能</h2><p>上位机和下位机在控制系统中分工明确，功能互补：</p>\n<p>上位机作为系统的“大脑”，处理复杂任务并与用户交互；下位机作为“执行者”，确保实时性和精确性。两者通过串口（RS232&#x2F;RS485）、以太网或无线协议通信，形成高效的控制体系。</p>\n<h2 id=\"工作原理\"><a href=\"#工作原理\" class=\"headerlink\" title=\"工作原理\"></a>工作原理</h2><p><img src=\"https://gitee.com/tanke11223344/imagehost/raw/main/blog/1749360295853Wqq4bMNQAot40JxAMsfch8w5ntd.png\" alt=\"1749360295853Wqq4bMNQAot40JxAMsfch8w5ntd.png\"></p>\n<p>上位机发送的指令会首先传递给下位机，下位机收到后将其解析为相应的时序信号，从而直接驱动具体的设备运行。下位机会不断采集设备的状态数据（通常为模拟量），并将这些数据转换为数字信号，上报给上位机进行监控与处理 。</p>\n<p>上下位机均需进行编程开发，且各自拥有针对性的开发环境与工具，下位机常见于 PLC、单片机或智能模块等，而上位机通常为基于 PC 的监控管理系统 。</p>\n<p>在系统架构层面，上位机相当于“控制者”和“服务提供者”，负责发出控制指令并处理反馈；下位机则扮演“被控制者”和“服务执行者”，直接与现场设备交互，实现具体控制逻辑。两者之间的通信方式多样，通常由下位机来决定其所支持的专有协议，以保证数据传输的可靠性与实时性，例如常见的 RS232、RS485、MODBUS、PROFIBUS 等 。</p>\n<p>下位机在出厂时一般会附带详细的通信手册，其中定义了该设备专用的协议格式与帧结构，开发人员在进行上位机编程时只需调用相应的 API 或驱动库即可快速实现通信对接。因此，主机与从机的关系不仅体现在控制与被控上，更体现在两者通信协议的配合与适配上，以确保工业现场系统的稳定运行与高效协同。</p>\n<h1 id=\"开发工具\"><a href=\"#开发工具\" class=\"headerlink\" title=\"开发工具\"></a>开发工具</h1><p>上位机开发通常使用 C&#x2F;C++（Qt、MFC）、C#（.NET 平下的 WinForms&#x2F;WPF）、VB。其中就目前的情况来看，Qt 和 WinForms 应该是目前应用相对比较广的。VB 和 MFC 比较老旧，做的界面也比较有年代感。其中，新版本的 Qt 还支持用 Python 来编写。而 WPF 算是后起之秀，也逐渐替代 WinForms，其制作的上位机界面较新式。其他，一些组态软件是专门做上位机软件的，像组态王、力控，相当于是二次开发，门槛较低一些，操作也比较简单，但是拓展性差。</p>\n<h1 id=\"系统实例分析\"><a href=\"#系统实例分析\" class=\"headerlink\" title=\"系统实例分析\"></a>系统实例分析</h1><h2 id=\"工业自动化控制系统\"><a href=\"#工业自动化控制系统\" class=\"headerlink\" title=\"工业自动化控制系统\"></a><strong>工业自动化控制系统</strong></h2><p>在工厂的自动化生产线上，上位机通常是工控机（Industrial PC）或 PLC（可编程逻辑控制器），负责监控和协调整个生产过程。下位机则是各种执行机构，如机械臂、传感器、电机驱动器等。</p>\n<ul>\n<li><strong>例子：</strong> 假设一条饮料灌装生产线。上位机通过人机界面接收生产指令（例如，灌装多少瓶、什么类型的饮料等）。然后，上位机向下位机的各个模块发送指令：<ul>\n<li>发送指令给<strong>传送带控制下位机</strong>，启动传送带。</li>\n<li>发送指令给<strong>灌装机下位机</strong>，控制饮料的精确灌装。</li>\n<li>发送指令给<strong>封盖机下位机</strong>，完成瓶盖的封装。</li>\n<li>发送指令给<strong>贴标机下位机</strong>，进行标签的粘贴。</li>\n<li>各个下位机在完成任务后，将状态信息（例如，是否完成、是否有异常等）反馈给上位机。</li>\n</ul>\n</li>\n</ul>\n<h2 id=\"智能家居系统\"><a href=\"#智能家居系统\" class=\"headerlink\" title=\"智能家居系统\"></a><strong>智能家居系统</strong></h2><p>在智能家居系统中，上位机通常是中央控制主机、智能手机 App 或语音助手，负责接收用户的指令和管理各个智能设备。下位机则是各种智能家居设备，如智能灯泡、智能插座、智能门锁、环境传感器等。</p>\n<ul>\n<li><strong>例子：</strong> 用户通过手机 App（上位机）发送指令打开客厅的灯。<ul>\n<li>手机 App 将“打开客厅灯”的指令发送给<strong>中央控制主机（上位机）</strong>。</li>\n<li>中央控制主机通过无线协议（例如，Zigbee、Wi-Fi）将指令发送给<strong>客厅的智能灯泡（下位机）</strong>。</li>\n<li>智能灯泡接收到指令后，执行亮灯操作，并可能将状态信息（例如，当前亮度、颜色等）反馈给中央控制主机，最终显示在手机 App 上。</li>\n</ul>\n</li>\n</ul>\n<h2 id=\"机器人控制系统\"><a href=\"#机器人控制系统\" class=\"headerlink\" title=\"机器人控制系统\"></a><strong>机器人控制系统</strong></h2><p>在机器人控制系统中，上位机通常是负责路径规划、任务决策的高性能处理器或工作站。下位机则是机器人的各个关节驱动器、传感器、末端执行器等。</p>\n<ul>\n<li><strong>例子：</strong> 一个巡逻机器人需要按照预设的路线进行巡逻，并在发现异常情况时进行上报。<ul>\n<li>上位机（例如，嵌入式主板或工控机）负责存储巡逻路线、分析传感器数据以识别异常、并进行通信。</li>\n<li>下位机（例如，电机驱动器、摄像头、红外传感器等）负责执行电机的运动指令、采集图像和环境数据。</li>\n<li>上位机根据预设路线，向下位机的电机驱动器发送运动指令。同时，上位机接收来自摄像头和红外传感器的数据，进行分析。如果发现异常情况（例如，检测到移动物体），上位机会将警报信息发送给远程监控系统（可以看作更高级别的上位机）。</li>\n</ul>\n</li>\n</ul>\n<h2 id=\"医疗设备\"><a href=\"#医疗设备\" class=\"headerlink\" title=\"医疗设备\"></a><strong>医疗设备</strong></h2><p>在一些复杂的医疗设备中，也采用上下位机结构。例如，医学影像设备或监护系统。</p>\n<ul>\n<li><strong>例子：</strong> 一台 CT 扫描仪。<ul>\n<li>上位机（操作控制台的计算机）负责接收医生的扫描参数设置、控制扫描过程、进行图像重建和显示。</li>\n<li>下位机（扫描床控制器、X 射线发生器控制器、数据采集系统等）负责按照上位机的指令精确地移动病人、发射 X 射线、采集数据。</li>\n</ul>\n</li>\n</ul>\n<h1 id=\"上下位机系统的优缺点\"><a href=\"#上下位机系统的优缺点\" class=\"headerlink\" title=\"上下位机系统的优缺点\"></a>上下位机系统的优缺点</h1><p><strong>优点：</strong></p>\n<ul>\n<li><strong>结构清晰，易于理解：</strong> 分层结构使得系统逻辑清晰，方便开发和维护。</li>\n<li><strong>资源优化利用：</strong> 上位机负责复杂的计算和管理，下位机专注于特定任务，可以根据需求选择合适的硬件资源。</li>\n<li><strong>可靠性高：</strong> 下位机通常功能单一，故障率相对较低。即使某个下位机出现故障，通常不会影响整个系统的运行。</li>\n<li><strong>良好的实时性：</strong> 下位机可以针对实时性要求较高的任务进行优化设计。</li>\n</ul>\n<p><strong>缺点：</strong></p>\n<ul>\n<li><strong>依赖性强：</strong> 下位机的运行完全依赖于上位机的指令，一旦上位机发生故障，整个系统可能会瘫痪。</li>\n<li><strong>通信负担：</strong> 上位机需要与多个下位机进行通信，当系统规模较大时，通信量可能会成为瓶颈。</li>\n<li><strong>实时性要求高的场景中，上位机的响应速度可能影响下位机的性能。</strong></li>\n</ul>\n<p>上下位机结构在工业自动化中仍占主导，但物联网技术的兴起可能部分取代传统 SCADA 系统。例如，工业物联网（IIoT）通过更智能的连接生态提供更高的灵活性，但在实时性和可靠性方面，传统上下位机结构仍具优势。争议在于，是否应完全转向物联网架构，还是继续优化现有结构以适应新需求。</p>\n<h1 id=\"结论\"><a href=\"#结论\" class=\"headerlink\" title=\"结论\"></a>结论</h1><ul>\n<li>上位机是指可以直接发出操控命令的计算机</li>\n<li>下位机是直接控制设备获取设备状况的计算机</li>\n<li>工控机，工作站，触摸屏作为上位机， 通信控制 PLC，单片机等作为下位机</li>\n</ul>\n","excerpt":"","more":"<h1 id=\"基于上下位机结构的系统实例分析\"><a href=\"#基于上下位机结构的系统实例分析\" class=\"headerlink\" title=\"基于上下位机结构的系统实例分析\"></a>基于上下位机结构的系统实例分析</h1><h1 id=\"参考资料\"><a href=\"#参考资料\" class=\"headerlink\" title=\"参考资料\"></a>参考资料</h1><blockquote>\n<ul>\n<li><a href=\"https://blog.csdn.net/BadAyase/article/details/102680588\">上位机开发介绍</a></li>\n<li><a href=\"https://www.cnblogs.com/xiketang/p/15305637.html\">上位机那些事儿 - 常哥说编程 - 博客园</a></li>\n<li><a href=\"https://blog.51cto.com/u_15712566/5457487\">介绍上位机和下位机</a></li>\n<li><a href=\"https://www.sohu.com/a/748967956_120070959\">上位机与下位机有什么区别？它们的关系是什么？</a></li>\n<li><a href=\"https://www.ebyte.com/news/3065.html\">论上位机与下位机的工作原理及应用区别</a></li>\n<li><a href=\"https://m.elecfans.com/article/286528.html\">什么是上位机_上位机软件介绍</a></li>\n<li><a href=\"https://ee.ofweek.com/2021-01/ART-11000-2814-30482117.html\">如何给下位机编写一个简单的上位机？</a></li>\n<li><a href=\"https://www.cnblogs.com/xiketang/p/15305637.html\">上位机那些事儿 - 常哥说编程</a></li>\n</ul>\n</blockquote>\n<h1 id=\"引言\"><a href=\"#引言\" class=\"headerlink\" title=\"引言\"></a>引言</h1><p>在现代工业自动化、物联网和智能控制领域，上下位机结构是一种核心的分层控制架构。上位机（Upper Computer）通常是功能强大的计算机，如个人电脑、工业 PC 或服务器，负责监控、数据处理、用户交互和决策制定。下位机（Lower Computer）是直接与物理设备（如传感器、执行器）连接的控制器，如可编程逻辑控制器（PLC）、单片机或嵌入式系统，负责执行具体任务和数据采集。这种结构通过通信协议（如 Modbus、TCP&#x2F;IP）实现高效协作，广泛应用于工业、物联网和嵌入式系统等领域。</p>\n<p><img src=\"https://gitee.com/tanke11223344/imagehost/raw/main/blog/1749360238852HJiCbmVvbojFg4xx4DbcUta2nYf.png\" alt=\"1749360238852HJiCbmVvbojFg4xx4DbcUta2nYf.png\"></p>\n<p>基于上下位机结构的软件示例</p>\n<h1 id=\"上下位机结构概述\"><a href=\"#上下位机结构概述\" class=\"headerlink\" title=\"上下位机结构概述\"></a>上下位机结构概述</h1><p>上下位机系统，也称为主从（Master-Slave）系统，是一种分层控制架构。它由一个处于控制地位的“上位机”（Master）和一个或多个受其控制的“下位机”（Slave）组成。</p>\n<ul>\n<li><strong>上位机（Master）：</strong> 通常是功能更强大、资源更丰富的计算机或控制单元。它负责发送指令、监控下位机的状态以及进行数据处理和分析。上位机往往具备人机交互界面，方便用户进行操作和管理。</li>\n</ul>\n<blockquote>\n<p>典型设备：电脑、平板、手机、面板、触摸屏</p>\n</blockquote>\n<ul>\n<li><strong>下位机（Slave）：</strong> 通常是资源相对有限的嵌入式系统、单片机或执行特定任务的设备。它们接收并执行来自上位机的指令，并将执行结果或采集的数据反馈给上位机。</li>\n</ul>\n<blockquote>\n<p>典型设备：PLC、stm32、51、FPGA、ARM 等各类可编程芯片。</p>\n</blockquote>\n<p><img src=\"https://gitee.com/tanke11223344/imagehost/raw/main/blog/1749360247852LxqkbwQ33oiuqlxEitFc8ub4ndc.png\" alt=\"1749360247852LxqkbwQ33oiuqlxEitFc8ub4ndc.png\"></p>\n<p>典型的工业控制系统分为现场设备层和现场控制层，分别负责与物理设备交互和实时控制。在它们之上还有过程监控层、生产管理层（MES）、企业决策层（ERP），这三个层次统称为“上位机”系统。</p>\n<p>如果系统没有完整的上位机层，也无妨，因为上位机仅用于监控和管理，并非直接负责执行 。广义上，“上位机”指所有基于 PC 的监控管理系统（如 SCADA、MES、ERP）；狭义上，多指 SCADA 本身，用于实时监控和数据采集。</p>\n<h2 id=\"通信协议与通信-API\"><a href=\"#通信协议与通信-API\" class=\"headerlink\" title=\"通信协议与通信 API\"></a>通信协议与通信 API</h2><h3 id=\"通信协议（通信方式）\"><a href=\"#通信协议（通信方式）\" class=\"headerlink\" title=\"通信协议（通信方式）\"></a>通信协议（通信方式）</h3><p>上位机和下位机之间的通信协议有很多，只要能完成通信的协议都可以用在上位机与下位机之间。</p>\n<p>比如：</p>\n<p>通信协议：RS232&#x2F;RS485 串行通信、USB、蓝牙、网络 UDP&#x2F;TCP</p>\n<p>这个通信协议也是实现上位机与下位机之间数据交换的基本通道。</p>\n<p><img src=\"https://gitee.com/tanke11223344/imagehost/raw/main/blog/1749360261852Nz3rbIyZno5yunxpGgVcvX9HnXd.png\" alt=\"1749360261852Nz3rbIyZno5yunxpGgVcvX9HnXd.png\"><br><img src=\"https://gitee.com/tanke11223344/imagehost/raw/main/blog/1749360271853AkrsbvBSxoFHdFxOkKjcvwFqnug.png\" alt=\"1749360271853AkrsbvBSxoFHdFxOkKjcvwFqnug.png\"></p>\n<h3 id=\"通信-API\"><a href=\"#通信-API\" class=\"headerlink\" title=\"通信 API\"></a>通信 API</h3><p>在通信协议的基础上，具体发送什么数据即发送什么指令，还需要规定各个功能所对应的指令（上位机发给下位机的指令）。</p>\n<p>每个功能所对应的指令叫做 API（Application Programming Interface）, 在实际工作中常称这个 api 为“私有通信协议”。</p>\n<p>举例一条获取温度的 api：</p>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">[包头 + 获取温度对应的命令编码（编号）+ 校验位 + 包尾]</span><br></pre></td></tr></table></figure>\n\n<p>api 的命令格式，是自定义的一种固定的数据组合格式。不受任何通信方式和通信平台的限制。这就意味着，只要通信协议（通信方式）可以建立，上位机软件可以是任意开发语言和任意开发平台，下位机也可以使用任意类型的单片机。</p>\n<p>上位机主要是对接 PLC、仪表、运动控制卡、视觉等，通信方式包括通信协议、OPC、API 或 SDK，如下图所示：</p>\n<p><img src=\"https://gitee.com/tanke11223344/imagehost/raw/main/blog/1749360284853ZrjUbb7O6oWXLyxl0ezcsZsvnbc.png\" alt=\"1749360284853ZrjUbb7O6oWXLyxl0ezcsZsvnbc.png\"></p>\n<h2 id=\"定义与功能\"><a href=\"#定义与功能\" class=\"headerlink\" title=\"定义与功能\"></a>定义与功能</h2><p>上位机和下位机在控制系统中分工明确，功能互补：</p>\n<p>上位机作为系统的“大脑”，处理复杂任务并与用户交互；下位机作为“执行者”，确保实时性和精确性。两者通过串口（RS232&#x2F;RS485）、以太网或无线协议通信，形成高效的控制体系。</p>\n<h2 id=\"工作原理\"><a href=\"#工作原理\" class=\"headerlink\" title=\"工作原理\"></a>工作原理</h2><p><img src=\"https://gitee.com/tanke11223344/imagehost/raw/main/blog/1749360295853Wqq4bMNQAot40JxAMsfch8w5ntd.png\" alt=\"1749360295853Wqq4bMNQAot40JxAMsfch8w5ntd.png\"></p>\n<p>上位机发送的指令会首先传递给下位机，下位机收到后将其解析为相应的时序信号，从而直接驱动具体的设备运行。下位机会不断采集设备的状态数据（通常为模拟量），并将这些数据转换为数字信号，上报给上位机进行监控与处理 。</p>\n<p>上下位机均需进行编程开发，且各自拥有针对性的开发环境与工具，下位机常见于 PLC、单片机或智能模块等，而上位机通常为基于 PC 的监控管理系统 。</p>\n<p>在系统架构层面，上位机相当于“控制者”和“服务提供者”，负责发出控制指令并处理反馈；下位机则扮演“被控制者”和“服务执行者”，直接与现场设备交互，实现具体控制逻辑。两者之间的通信方式多样，通常由下位机来决定其所支持的专有协议，以保证数据传输的可靠性与实时性，例如常见的 RS232、RS485、MODBUS、PROFIBUS 等 。</p>\n<p>下位机在出厂时一般会附带详细的通信手册，其中定义了该设备专用的协议格式与帧结构，开发人员在进行上位机编程时只需调用相应的 API 或驱动库即可快速实现通信对接。因此，主机与从机的关系不仅体现在控制与被控上，更体现在两者通信协议的配合与适配上，以确保工业现场系统的稳定运行与高效协同。</p>\n<h1 id=\"开发工具\"><a href=\"#开发工具\" class=\"headerlink\" title=\"开发工具\"></a>开发工具</h1><p>上位机开发通常使用 C&#x2F;C++（Qt、MFC）、C#（.NET 平下的 WinForms&#x2F;WPF）、VB。其中就目前的情况来看，Qt 和 WinForms 应该是目前应用相对比较广的。VB 和 MFC 比较老旧，做的界面也比较有年代感。其中，新版本的 Qt 还支持用 Python 来编写。而 WPF 算是后起之秀，也逐渐替代 WinForms，其制作的上位机界面较新式。其他，一些组态软件是专门做上位机软件的，像组态王、力控，相当于是二次开发，门槛较低一些，操作也比较简单，但是拓展性差。</p>\n<h1 id=\"系统实例分析\"><a href=\"#系统实例分析\" class=\"headerlink\" title=\"系统实例分析\"></a>系统实例分析</h1><h2 id=\"工业自动化控制系统\"><a href=\"#工业自动化控制系统\" class=\"headerlink\" title=\"工业自动化控制系统\"></a><strong>工业自动化控制系统</strong></h2><p>在工厂的自动化生产线上，上位机通常是工控机（Industrial PC）或 PLC（可编程逻辑控制器），负责监控和协调整个生产过程。下位机则是各种执行机构，如机械臂、传感器、电机驱动器等。</p>\n<ul>\n<li><strong>例子：</strong> 假设一条饮料灌装生产线。上位机通过人机界面接收生产指令（例如，灌装多少瓶、什么类型的饮料等）。然后，上位机向下位机的各个模块发送指令：<ul>\n<li>发送指令给<strong>传送带控制下位机</strong>，启动传送带。</li>\n<li>发送指令给<strong>灌装机下位机</strong>，控制饮料的精确灌装。</li>\n<li>发送指令给<strong>封盖机下位机</strong>，完成瓶盖的封装。</li>\n<li>发送指令给<strong>贴标机下位机</strong>，进行标签的粘贴。</li>\n<li>各个下位机在完成任务后，将状态信息（例如，是否完成、是否有异常等）反馈给上位机。</li>\n</ul>\n</li>\n</ul>\n<h2 id=\"智能家居系统\"><a href=\"#智能家居系统\" class=\"headerlink\" title=\"智能家居系统\"></a><strong>智能家居系统</strong></h2><p>在智能家居系统中，上位机通常是中央控制主机、智能手机 App 或语音助手，负责接收用户的指令和管理各个智能设备。下位机则是各种智能家居设备，如智能灯泡、智能插座、智能门锁、环境传感器等。</p>\n<ul>\n<li><strong>例子：</strong> 用户通过手机 App（上位机）发送指令打开客厅的灯。<ul>\n<li>手机 App 将“打开客厅灯”的指令发送给<strong>中央控制主机（上位机）</strong>。</li>\n<li>中央控制主机通过无线协议（例如，Zigbee、Wi-Fi）将指令发送给<strong>客厅的智能灯泡（下位机）</strong>。</li>\n<li>智能灯泡接收到指令后，执行亮灯操作，并可能将状态信息（例如，当前亮度、颜色等）反馈给中央控制主机，最终显示在手机 App 上。</li>\n</ul>\n</li>\n</ul>\n<h2 id=\"机器人控制系统\"><a href=\"#机器人控制系统\" class=\"headerlink\" title=\"机器人控制系统\"></a><strong>机器人控制系统</strong></h2><p>在机器人控制系统中，上位机通常是负责路径规划、任务决策的高性能处理器或工作站。下位机则是机器人的各个关节驱动器、传感器、末端执行器等。</p>\n<ul>\n<li><strong>例子：</strong> 一个巡逻机器人需要按照预设的路线进行巡逻，并在发现异常情况时进行上报。<ul>\n<li>上位机（例如，嵌入式主板或工控机）负责存储巡逻路线、分析传感器数据以识别异常、并进行通信。</li>\n<li>下位机（例如，电机驱动器、摄像头、红外传感器等）负责执行电机的运动指令、采集图像和环境数据。</li>\n<li>上位机根据预设路线，向下位机的电机驱动器发送运动指令。同时，上位机接收来自摄像头和红外传感器的数据，进行分析。如果发现异常情况（例如，检测到移动物体），上位机会将警报信息发送给远程监控系统（可以看作更高级别的上位机）。</li>\n</ul>\n</li>\n</ul>\n<h2 id=\"医疗设备\"><a href=\"#医疗设备\" class=\"headerlink\" title=\"医疗设备\"></a><strong>医疗设备</strong></h2><p>在一些复杂的医疗设备中，也采用上下位机结构。例如，医学影像设备或监护系统。</p>\n<ul>\n<li><strong>例子：</strong> 一台 CT 扫描仪。<ul>\n<li>上位机（操作控制台的计算机）负责接收医生的扫描参数设置、控制扫描过程、进行图像重建和显示。</li>\n<li>下位机（扫描床控制器、X 射线发生器控制器、数据采集系统等）负责按照上位机的指令精确地移动病人、发射 X 射线、采集数据。</li>\n</ul>\n</li>\n</ul>\n<h1 id=\"上下位机系统的优缺点\"><a href=\"#上下位机系统的优缺点\" class=\"headerlink\" title=\"上下位机系统的优缺点\"></a>上下位机系统的优缺点</h1><p><strong>优点：</strong></p>\n<ul>\n<li><strong>结构清晰，易于理解：</strong> 分层结构使得系统逻辑清晰，方便开发和维护。</li>\n<li><strong>资源优化利用：</strong> 上位机负责复杂的计算和管理，下位机专注于特定任务，可以根据需求选择合适的硬件资源。</li>\n<li><strong>可靠性高：</strong> 下位机通常功能单一，故障率相对较低。即使某个下位机出现故障，通常不会影响整个系统的运行。</li>\n<li><strong>良好的实时性：</strong> 下位机可以针对实时性要求较高的任务进行优化设计。</li>\n</ul>\n<p><strong>缺点：</strong></p>\n<ul>\n<li><strong>依赖性强：</strong> 下位机的运行完全依赖于上位机的指令，一旦上位机发生故障，整个系统可能会瘫痪。</li>\n<li><strong>通信负担：</strong> 上位机需要与多个下位机进行通信，当系统规模较大时，通信量可能会成为瓶颈。</li>\n<li><strong>实时性要求高的场景中，上位机的响应速度可能影响下位机的性能。</strong></li>\n</ul>\n<p>上下位机结构在工业自动化中仍占主导，但物联网技术的兴起可能部分取代传统 SCADA 系统。例如，工业物联网（IIoT）通过更智能的连接生态提供更高的灵活性，但在实时性和可靠性方面，传统上下位机结构仍具优势。争议在于，是否应完全转向物联网架构，还是继续优化现有结构以适应新需求。</p>\n<h1 id=\"结论\"><a href=\"#结论\" class=\"headerlink\" title=\"结论\"></a>结论</h1><ul>\n<li>上位机是指可以直接发出操控命令的计算机</li>\n<li>下位机是直接控制设备获取设备状况的计算机</li>\n<li>工控机，工作站，触摸屏作为上位机， 通信控制 PLC，单片机等作为下位机</li>\n</ul>\n"},{"title":"2025-04-02-JAVA 作业_图书管理系统_week4","date":"2025-04-01T16:00:00.000Z","_content":"\n> [29_【项目】老马书城集合版-项目介绍_哔哩哔哩_bilibili](https://www.bilibili.com/video/BV1sk4y1M7ru?vd_source=0ca07f837bf8ee7607324d7927199dcc&p=29&spm_id_from=333.788.videopod.episodes)(参考视频)\n\n> [LibraryManagementSystem](https://github.com/rongchenlin/LibraryManagementSystem)\n\n> [【图书管理系统】(超详细附源码用 java 实现)_图书管理系统源码-CSDN 博客](https://blog.csdn.net/m0_64670207/article/details/136854580)\n\n# 图书馆管理系统项目说明\n\n## 项目概述\n\n我选择的是选题三图书馆：模拟一天的借阅过程,应该这个选题更加贴近现实开发,用于模拟图书馆日常的借阅管理流程。系统实现了图书馆基本的图书管理、读者管理、借阅管理等功能。\n\n系统的架构设计如下：系统通过定义一个 Borrowable 接口，规范了可借阅物品的标准操作，包括借阅和归还等基本功能。LibraryItem 作为抽象类，实现了 Borrowable 接口，为所有可借阅物品提供了基础结构，包含标题、ID 等通用属性。具体类 Book 继承自 LibraryItem，扩展了图书特有的属性（如作者、ISBN）和行为。Reader 类负责管理读者信息，并跟踪读者的借阅记录。Library 类作为系统的核心管理类，负责处理图书和读者的注册，管理借阅和归还流程，并维护图书馆的开放状态。通过这种设计，系统实现了对图书馆资源和读者行为的高效管理。\n\n为了理清思路，我先了画出类图，梳理各个类之间的关系。在编码阶段，我遇到了不少问题。例如，在使用 HashMap 管理图书时，我错误地将 ISBN 作为字符串拼接，导致查询时出现空指针异常。我按照教程编写了 borrowBook() 方法，但运行时发现同一本书可以被多次借出。经过仔细检查，我意识到问题出在没有为 Book 类添加 isAvailable 标志位。在修正了这一问题后，我特意编写了多个测试用例，验证了各种边界情况，确保了借阅逻辑的正确性。\n\n## 系统架构\n\n系统采用面向对象的设计方法，主要包含以下核心组件：\n\n## 主要功能\n\n## 技术特点\n\n1. 面向对象设计\n\n   - 使用继承（LibraryItem -> Book）\n   - 使用接口（Borrowable）\n   - 封装（private 属性 + getter/setter）\n   - 多态（LibraryItem 的实现）\n2. Java 语言特性\n\n   - 使用 `abstract` 类\n   - 使用 `interface`\n   - 使用 `@Override` 注解\n   - 使用 `static` 和 `final` 修饰符\n3. 集合框架应用\n\n   - 使用 `HashMap` 管理图书和读者\n   - 使用 `ArrayList` 存储借阅记录\n\n## 运行说明\n\n1. 编译方法\n\n```bash\ncd src\njavac *.java\n```\n\n1. 运行方法\n\n```bash\njava Main\n```\n\n## 项目结构\n\n```\nsrc/\n├── Borrowable.java     // 可借阅接口\n├── LibraryItem.java    // 图书馆物品抽象类\n├── Book.java           // 图书类\n├── Reader.java         // 读者类\n├── Library.java        // 图书馆管理类\n└── Main.java           // 主程序入口\n```\n\n## 注意事项\n\n1. 系统使用 ISBN 作为图书的唯一标识\n2. 读者 ID 格式为\"R\"+ 序号\n3. 图书 ID 格式为\"B\"+ 序号\n4. 图书馆闭馆时无法进行借还操作\n\n## 运行结果\n\n![1743590162843CbQ4bP8FJoMZDCxRi9FcBNlonBh.png](https://tk-pichost-1325224430.cos.ap-chengdu.myqcloud.com/blog/1743590162843CbQ4bP8FJoMZDCxRi9FcBNlonBh.png)\n![1743590155844Lv5BbqXAFoDN2Wxo7MscZZCmngd.png](https://tk-pichost-1325224430.cos.ap-chengdu.myqcloud.com/blog/1743590155844Lv5BbqXAFoDN2Wxo7MscZZCmngd.png)\n![1743590165844WgHtbCCmRohtZwxwI1XcLqjYnvf.png](https://tk-pichost-1325224430.cos.ap-chengdu.myqcloud.com/blog/1743590165844WgHtbCCmRohtZwxwI1XcLqjYnvf.png)\n\n## Main 代码\n\n> [https://github.com/tkzzzzzz6/My_Java_homework](https://github.com/tkzzzzzz6/My_Java_homework)(完整代码链接)\n\n```\npublic class Main {\n    public static void main(String[] args) {\n        _printHeader_(\"图书馆管理系统启动\");\n\n        // 创建图书馆\n        Library library = new Library(\"我的图书馆\");\n        \n        _printHeader_(\"初始化图书馆藏书\");\n        // 添加图书\n        Book book1 = new Book(\"Java编程思想\", \"B001\", \"Bruce Eckel\", \"9787111213826\");\n        Book book2 = new Book(\"软件工程\", \"B002\", \"Erich Gamma\", \"9787111346365\");\n        Book book3 = new Book(\"算法导论\", \"B003\", \"Thomas H. Cormen\", \"9787111187776\");\n        Book book4 = new Book(\"计算机网络\", \"B004\", \"谢希仁\", \"9787302424645\");\n        Book book6 = new Book(\"深度学习\", \"B006\", \"Abraham Silberschatz\", \"9787111187776\");\n        Book comic1 = new Book(\"欢迎来到实力至上主义教室\", \"C007\", \"衣笠彰梧\", \"9784861994950\");\n        Book comic2 = new Book(\"进击的巨人\", \"C004\", \"谏山创\", \"9787115270532\");\n\n        // 添加图书到图书馆\n        library.addItem(book1);\n        library.addItem(book2);\n        library.addItem(book3);\n        library.addItem(book4);\n        library.addItem(book6);\n        library.addItem(comic1);\n        library.addItem(comic2);\n\n        System._out_.println(\"\\n当前图书馆藏书总量：\" + library.getTotalItems() + \" 本\");\n\n        _printHeader_(\"注册读者信息\");\n        // 创建读者\n        Reader reader1 = new Reader(\"R001\", \"张三\");\n        Reader reader2 = new Reader(\"R002\", \"李四\");\n        Reader reader3 = new Reader(\"R003\", \"王五\");\n\n        // 添加读者到图书馆\n        library.addReader(reader1);\n        library.addReader(reader2);\n        library.addReader(reader3);\n        System._out_.println(\"\\n当前注册读者总数：\" + library.getTotalReaders() + \" 人\");\n\n        // 开馆\n        _printHeader_(\"图书馆开始营业\");\n        library.openLibrary();\n\n        // 测试借阅\n        _printHeader_(\"借阅测试\");\n        System._out_.println(\"场景1: \" + reader1.getName() + \" 借阅《\" + book1.getTitle() + \"》\");\n        if (library.borrowItem(\"B001\", \"R001\")) {\n            _printSuccess_(\"借阅成功\");\n        } else {\n            _printError_(\"借阅失败\");\n        }\n\n        System._out_.println(\"\\n场景2: \" + reader2.getName() + \" 尝试借阅已借出的《\" + book1.getTitle() + \"》\");\n        if (library.borrowItem(\"B001\", \"R002\")) {\n            _printSuccess_(\"借阅成功\");\n        } else {\n            _printError_(\"借阅失败：图书已被借出\");\n        }\n\n        System._out_.println(\"\\n场景3: \" + reader2.getName() + \" 借阅《\" + book2.getTitle() + \"》\");\n        if (library.borrowItem(\"B002\", \"R002\")) {\n            _printSuccess_(\"借阅成功\");\n        } else {\n            _printError_(\"借阅失败\");\n        }\n\n        // 测试归还\n        _printHeader_(\"归还测试\");\n        System._out_.println(\"场景1: \" + reader1.getName() + \" 归还《\" + book1.getTitle() + \"》\");\n        if (library.returnItem(\"B001\", \"R001\")) {\n            _printSuccess_(\"归还成功\");\n        } else {\n            _printError_(\"归还失败\");\n        }\n\n        System._out_.println(\"\\n场景2: \" + reader2.getName() + \" 归还《\" + comic1.getTitle() + \"》\");\n        if (library.returnItem(\"C007\", \"R002\")) {\n            _printSuccess_(\"归还成功\");\n        } else {\n            _printError_(\"归还失败\");\n        }\n\n        // 显示可用图书\n        _printHeader_(\"当前可借阅图书列表\");\n        library.printAvailableBooks();\n\n        // 闭馆\n        _printHeader_(\"图书馆闭馆\");\n        library.closeLibrary();\n        \n        _printHeader_(\"系统运行结束\");\n    }\n\n    // 美化输出的辅助方法\n    private static void printHeader(String message) {\n        System._out_.println(\"\\n\" + \"=\".repeat(50));\n        System._out_.println(\">>> \" + message);\n        System._out_.println(\"=\".repeat(50));\n    }\n\n    private static void printSuccess(String message) {\n        System._out_.println(\"[成功] \" + message);\n    }\n\n    private static void printError(String message) {\n        System._out_.println(\"[失败] \" + message);\n    }\n}\n```\n","source":"_posts/2025-04-02-JAVA作业_图书管理系统_week4.md","raw":"---\ntitle: 2025-04-02-JAVA 作业_图书管理系统_week4\ndate: 2025-04-02\ntags: \n    程序开发\n---\n\n> [29_【项目】老马书城集合版-项目介绍_哔哩哔哩_bilibili](https://www.bilibili.com/video/BV1sk4y1M7ru?vd_source=0ca07f837bf8ee7607324d7927199dcc&p=29&spm_id_from=333.788.videopod.episodes)(参考视频)\n\n> [LibraryManagementSystem](https://github.com/rongchenlin/LibraryManagementSystem)\n\n> [【图书管理系统】(超详细附源码用 java 实现)_图书管理系统源码-CSDN 博客](https://blog.csdn.net/m0_64670207/article/details/136854580)\n\n# 图书馆管理系统项目说明\n\n## 项目概述\n\n我选择的是选题三图书馆：模拟一天的借阅过程,应该这个选题更加贴近现实开发,用于模拟图书馆日常的借阅管理流程。系统实现了图书馆基本的图书管理、读者管理、借阅管理等功能。\n\n系统的架构设计如下：系统通过定义一个 Borrowable 接口，规范了可借阅物品的标准操作，包括借阅和归还等基本功能。LibraryItem 作为抽象类，实现了 Borrowable 接口，为所有可借阅物品提供了基础结构，包含标题、ID 等通用属性。具体类 Book 继承自 LibraryItem，扩展了图书特有的属性（如作者、ISBN）和行为。Reader 类负责管理读者信息，并跟踪读者的借阅记录。Library 类作为系统的核心管理类，负责处理图书和读者的注册，管理借阅和归还流程，并维护图书馆的开放状态。通过这种设计，系统实现了对图书馆资源和读者行为的高效管理。\n\n为了理清思路，我先了画出类图，梳理各个类之间的关系。在编码阶段，我遇到了不少问题。例如，在使用 HashMap 管理图书时，我错误地将 ISBN 作为字符串拼接，导致查询时出现空指针异常。我按照教程编写了 borrowBook() 方法，但运行时发现同一本书可以被多次借出。经过仔细检查，我意识到问题出在没有为 Book 类添加 isAvailable 标志位。在修正了这一问题后，我特意编写了多个测试用例，验证了各种边界情况，确保了借阅逻辑的正确性。\n\n## 系统架构\n\n系统采用面向对象的设计方法，主要包含以下核心组件：\n\n## 主要功能\n\n## 技术特点\n\n1. 面向对象设计\n\n   - 使用继承（LibraryItem -> Book）\n   - 使用接口（Borrowable）\n   - 封装（private 属性 + getter/setter）\n   - 多态（LibraryItem 的实现）\n2. Java 语言特性\n\n   - 使用 `abstract` 类\n   - 使用 `interface`\n   - 使用 `@Override` 注解\n   - 使用 `static` 和 `final` 修饰符\n3. 集合框架应用\n\n   - 使用 `HashMap` 管理图书和读者\n   - 使用 `ArrayList` 存储借阅记录\n\n## 运行说明\n\n1. 编译方法\n\n```bash\ncd src\njavac *.java\n```\n\n1. 运行方法\n\n```bash\njava Main\n```\n\n## 项目结构\n\n```\nsrc/\n├── Borrowable.java     // 可借阅接口\n├── LibraryItem.java    // 图书馆物品抽象类\n├── Book.java           // 图书类\n├── Reader.java         // 读者类\n├── Library.java        // 图书馆管理类\n└── Main.java           // 主程序入口\n```\n\n## 注意事项\n\n1. 系统使用 ISBN 作为图书的唯一标识\n2. 读者 ID 格式为\"R\"+ 序号\n3. 图书 ID 格式为\"B\"+ 序号\n4. 图书馆闭馆时无法进行借还操作\n\n## 运行结果\n\n![1743590162843CbQ4bP8FJoMZDCxRi9FcBNlonBh.png](https://tk-pichost-1325224430.cos.ap-chengdu.myqcloud.com/blog/1743590162843CbQ4bP8FJoMZDCxRi9FcBNlonBh.png)\n![1743590155844Lv5BbqXAFoDN2Wxo7MscZZCmngd.png](https://tk-pichost-1325224430.cos.ap-chengdu.myqcloud.com/blog/1743590155844Lv5BbqXAFoDN2Wxo7MscZZCmngd.png)\n![1743590165844WgHtbCCmRohtZwxwI1XcLqjYnvf.png](https://tk-pichost-1325224430.cos.ap-chengdu.myqcloud.com/blog/1743590165844WgHtbCCmRohtZwxwI1XcLqjYnvf.png)\n\n## Main 代码\n\n> [https://github.com/tkzzzzzz6/My_Java_homework](https://github.com/tkzzzzzz6/My_Java_homework)(完整代码链接)\n\n```\npublic class Main {\n    public static void main(String[] args) {\n        _printHeader_(\"图书馆管理系统启动\");\n\n        // 创建图书馆\n        Library library = new Library(\"我的图书馆\");\n        \n        _printHeader_(\"初始化图书馆藏书\");\n        // 添加图书\n        Book book1 = new Book(\"Java编程思想\", \"B001\", \"Bruce Eckel\", \"9787111213826\");\n        Book book2 = new Book(\"软件工程\", \"B002\", \"Erich Gamma\", \"9787111346365\");\n        Book book3 = new Book(\"算法导论\", \"B003\", \"Thomas H. Cormen\", \"9787111187776\");\n        Book book4 = new Book(\"计算机网络\", \"B004\", \"谢希仁\", \"9787302424645\");\n        Book book6 = new Book(\"深度学习\", \"B006\", \"Abraham Silberschatz\", \"9787111187776\");\n        Book comic1 = new Book(\"欢迎来到实力至上主义教室\", \"C007\", \"衣笠彰梧\", \"9784861994950\");\n        Book comic2 = new Book(\"进击的巨人\", \"C004\", \"谏山创\", \"9787115270532\");\n\n        // 添加图书到图书馆\n        library.addItem(book1);\n        library.addItem(book2);\n        library.addItem(book3);\n        library.addItem(book4);\n        library.addItem(book6);\n        library.addItem(comic1);\n        library.addItem(comic2);\n\n        System._out_.println(\"\\n当前图书馆藏书总量：\" + library.getTotalItems() + \" 本\");\n\n        _printHeader_(\"注册读者信息\");\n        // 创建读者\n        Reader reader1 = new Reader(\"R001\", \"张三\");\n        Reader reader2 = new Reader(\"R002\", \"李四\");\n        Reader reader3 = new Reader(\"R003\", \"王五\");\n\n        // 添加读者到图书馆\n        library.addReader(reader1);\n        library.addReader(reader2);\n        library.addReader(reader3);\n        System._out_.println(\"\\n当前注册读者总数：\" + library.getTotalReaders() + \" 人\");\n\n        // 开馆\n        _printHeader_(\"图书馆开始营业\");\n        library.openLibrary();\n\n        // 测试借阅\n        _printHeader_(\"借阅测试\");\n        System._out_.println(\"场景1: \" + reader1.getName() + \" 借阅《\" + book1.getTitle() + \"》\");\n        if (library.borrowItem(\"B001\", \"R001\")) {\n            _printSuccess_(\"借阅成功\");\n        } else {\n            _printError_(\"借阅失败\");\n        }\n\n        System._out_.println(\"\\n场景2: \" + reader2.getName() + \" 尝试借阅已借出的《\" + book1.getTitle() + \"》\");\n        if (library.borrowItem(\"B001\", \"R002\")) {\n            _printSuccess_(\"借阅成功\");\n        } else {\n            _printError_(\"借阅失败：图书已被借出\");\n        }\n\n        System._out_.println(\"\\n场景3: \" + reader2.getName() + \" 借阅《\" + book2.getTitle() + \"》\");\n        if (library.borrowItem(\"B002\", \"R002\")) {\n            _printSuccess_(\"借阅成功\");\n        } else {\n            _printError_(\"借阅失败\");\n        }\n\n        // 测试归还\n        _printHeader_(\"归还测试\");\n        System._out_.println(\"场景1: \" + reader1.getName() + \" 归还《\" + book1.getTitle() + \"》\");\n        if (library.returnItem(\"B001\", \"R001\")) {\n            _printSuccess_(\"归还成功\");\n        } else {\n            _printError_(\"归还失败\");\n        }\n\n        System._out_.println(\"\\n场景2: \" + reader2.getName() + \" 归还《\" + comic1.getTitle() + \"》\");\n        if (library.returnItem(\"C007\", \"R002\")) {\n            _printSuccess_(\"归还成功\");\n        } else {\n            _printError_(\"归还失败\");\n        }\n\n        // 显示可用图书\n        _printHeader_(\"当前可借阅图书列表\");\n        library.printAvailableBooks();\n\n        // 闭馆\n        _printHeader_(\"图书馆闭馆\");\n        library.closeLibrary();\n        \n        _printHeader_(\"系统运行结束\");\n    }\n\n    // 美化输出的辅助方法\n    private static void printHeader(String message) {\n        System._out_.println(\"\\n\" + \"=\".repeat(50));\n        System._out_.println(\">>> \" + message);\n        System._out_.println(\"=\".repeat(50));\n    }\n\n    private static void printSuccess(String message) {\n        System._out_.println(\"[成功] \" + message);\n    }\n\n    private static void printError(String message) {\n        System._out_.println(\"[失败] \" + message);\n    }\n}\n```\n","slug":"2025-04-02-JAVA作业_图书管理系统_week4","published":1,"updated":"2025-09-26T12:16:36.515Z","_id":"cmg0saj44001gjm8n0mtug5o9","comments":1,"layout":"post","photos":[],"content":"<blockquote>\n<p><a href=\"https://www.bilibili.com/video/BV1sk4y1M7ru?vd_source=0ca07f837bf8ee7607324d7927199dcc&p=29&spm_id_from=333.788.videopod.episodes\">29_【项目】老马书城集合版-项目介绍_哔哩哔哩_bilibili</a>(参考视频)</p>\n</blockquote>\n<blockquote>\n<p><a href=\"https://github.com/rongchenlin/LibraryManagementSystem\">LibraryManagementSystem</a></p>\n</blockquote>\n<blockquote>\n<p><a href=\"https://blog.csdn.net/m0_64670207/article/details/136854580\">【图书管理系统】(超详细附源码用 java 实现)_图书管理系统源码-CSDN 博客</a></p>\n</blockquote>\n<h1 id=\"图书馆管理系统项目说明\"><a href=\"#图书馆管理系统项目说明\" class=\"headerlink\" title=\"图书馆管理系统项目说明\"></a>图书馆管理系统项目说明</h1><h2 id=\"项目概述\"><a href=\"#项目概述\" class=\"headerlink\" title=\"项目概述\"></a>项目概述</h2><p>我选择的是选题三图书馆：模拟一天的借阅过程,应该这个选题更加贴近现实开发,用于模拟图书馆日常的借阅管理流程。系统实现了图书馆基本的图书管理、读者管理、借阅管理等功能。</p>\n<p>系统的架构设计如下：系统通过定义一个 Borrowable 接口，规范了可借阅物品的标准操作，包括借阅和归还等基本功能。LibraryItem 作为抽象类，实现了 Borrowable 接口，为所有可借阅物品提供了基础结构，包含标题、ID 等通用属性。具体类 Book 继承自 LibraryItem，扩展了图书特有的属性（如作者、ISBN）和行为。Reader 类负责管理读者信息，并跟踪读者的借阅记录。Library 类作为系统的核心管理类，负责处理图书和读者的注册，管理借阅和归还流程，并维护图书馆的开放状态。通过这种设计，系统实现了对图书馆资源和读者行为的高效管理。</p>\n<p>为了理清思路，我先了画出类图，梳理各个类之间的关系。在编码阶段，我遇到了不少问题。例如，在使用 HashMap 管理图书时，我错误地将 ISBN 作为字符串拼接，导致查询时出现空指针异常。我按照教程编写了 borrowBook() 方法，但运行时发现同一本书可以被多次借出。经过仔细检查，我意识到问题出在没有为 Book 类添加 isAvailable 标志位。在修正了这一问题后，我特意编写了多个测试用例，验证了各种边界情况，确保了借阅逻辑的正确性。</p>\n<h2 id=\"系统架构\"><a href=\"#系统架构\" class=\"headerlink\" title=\"系统架构\"></a>系统架构</h2><p>系统采用面向对象的设计方法，主要包含以下核心组件：</p>\n<h2 id=\"主要功能\"><a href=\"#主要功能\" class=\"headerlink\" title=\"主要功能\"></a>主要功能</h2><h2 id=\"技术特点\"><a href=\"#技术特点\" class=\"headerlink\" title=\"技术特点\"></a>技术特点</h2><ol>\n<li><p>面向对象设计</p>\n<ul>\n<li>使用继承（LibraryItem -&gt; Book）</li>\n<li>使用接口（Borrowable）</li>\n<li>封装（private 属性 + getter&#x2F;setter）</li>\n<li>多态（LibraryItem 的实现）</li>\n</ul>\n</li>\n<li><p>Java 语言特性</p>\n<ul>\n<li>使用 <code>abstract</code> 类</li>\n<li>使用 <code>interface</code></li>\n<li>使用 <code>@Override</code> 注解</li>\n<li>使用 <code>static</code> 和 <code>final</code> 修饰符</li>\n</ul>\n</li>\n<li><p>集合框架应用</p>\n<ul>\n<li>使用 <code>HashMap</code> 管理图书和读者</li>\n<li>使用 <code>ArrayList</code> 存储借阅记录</li>\n</ul>\n</li>\n</ol>\n<h2 id=\"运行说明\"><a href=\"#运行说明\" class=\"headerlink\" title=\"运行说明\"></a>运行说明</h2><ol>\n<li>编译方法</li>\n</ol>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"built_in\">cd</span> src</span><br><span class=\"line\">javac *.java</span><br></pre></td></tr></table></figure>\n\n<ol>\n<li>运行方法</li>\n</ol>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">java Main</span><br></pre></td></tr></table></figure>\n\n<h2 id=\"项目结构\"><a href=\"#项目结构\" class=\"headerlink\" title=\"项目结构\"></a>项目结构</h2><figure class=\"highlight stylus\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"attribute\">src</span>/</span><br><span class=\"line\">├── Borrowable<span class=\"selector-class\">.java</span>     <span class=\"comment\">// 可借阅接口</span></span><br><span class=\"line\">├── LibraryItem<span class=\"selector-class\">.java</span>    <span class=\"comment\">// 图书馆物品抽象类</span></span><br><span class=\"line\">├── Book<span class=\"selector-class\">.java</span>           <span class=\"comment\">// 图书类</span></span><br><span class=\"line\">├── Reader<span class=\"selector-class\">.java</span>         <span class=\"comment\">// 读者类</span></span><br><span class=\"line\">├── Library<span class=\"selector-class\">.java</span>        <span class=\"comment\">// 图书馆管理类</span></span><br><span class=\"line\">└── Main<span class=\"selector-class\">.java</span>           <span class=\"comment\">// 主程序入口</span></span><br></pre></td></tr></table></figure>\n\n<h2 id=\"注意事项\"><a href=\"#注意事项\" class=\"headerlink\" title=\"注意事项\"></a>注意事项</h2><ol>\n<li>系统使用 ISBN 作为图书的唯一标识</li>\n<li>读者 ID 格式为”R”+ 序号</li>\n<li>图书 ID 格式为”B”+ 序号</li>\n<li>图书馆闭馆时无法进行借还操作</li>\n</ol>\n<h2 id=\"运行结果\"><a href=\"#运行结果\" class=\"headerlink\" title=\"运行结果\"></a>运行结果</h2><p><img src=\"https://tk-pichost-1325224430.cos.ap-chengdu.myqcloud.com/blog/1743590162843CbQ4bP8FJoMZDCxRi9FcBNlonBh.png\" alt=\"1743590162843CbQ4bP8FJoMZDCxRi9FcBNlonBh.png\"><br><img src=\"https://tk-pichost-1325224430.cos.ap-chengdu.myqcloud.com/blog/1743590155844Lv5BbqXAFoDN2Wxo7MscZZCmngd.png\" alt=\"1743590155844Lv5BbqXAFoDN2Wxo7MscZZCmngd.png\"><br><img src=\"https://tk-pichost-1325224430.cos.ap-chengdu.myqcloud.com/blog/1743590165844WgHtbCCmRohtZwxwI1XcLqjYnvf.png\" alt=\"1743590165844WgHtbCCmRohtZwxwI1XcLqjYnvf.png\"></p>\n<h2 id=\"Main-代码\"><a href=\"#Main-代码\" class=\"headerlink\" title=\"Main 代码\"></a>Main 代码</h2><blockquote>\n<p><a href=\"https://github.com/tkzzzzzz6/My_Java_homework\">https://github.com/tkzzzzzz6/My_Java_homework</a>(完整代码链接)</p>\n</blockquote>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br><span class=\"line\">47</span><br><span class=\"line\">48</span><br><span class=\"line\">49</span><br><span class=\"line\">50</span><br><span class=\"line\">51</span><br><span class=\"line\">52</span><br><span class=\"line\">53</span><br><span class=\"line\">54</span><br><span class=\"line\">55</span><br><span class=\"line\">56</span><br><span class=\"line\">57</span><br><span class=\"line\">58</span><br><span class=\"line\">59</span><br><span class=\"line\">60</span><br><span class=\"line\">61</span><br><span class=\"line\">62</span><br><span class=\"line\">63</span><br><span class=\"line\">64</span><br><span class=\"line\">65</span><br><span class=\"line\">66</span><br><span class=\"line\">67</span><br><span class=\"line\">68</span><br><span class=\"line\">69</span><br><span class=\"line\">70</span><br><span class=\"line\">71</span><br><span class=\"line\">72</span><br><span class=\"line\">73</span><br><span class=\"line\">74</span><br><span class=\"line\">75</span><br><span class=\"line\">76</span><br><span class=\"line\">77</span><br><span class=\"line\">78</span><br><span class=\"line\">79</span><br><span class=\"line\">80</span><br><span class=\"line\">81</span><br><span class=\"line\">82</span><br><span class=\"line\">83</span><br><span class=\"line\">84</span><br><span class=\"line\">85</span><br><span class=\"line\">86</span><br><span class=\"line\">87</span><br><span class=\"line\">88</span><br><span class=\"line\">89</span><br><span class=\"line\">90</span><br><span class=\"line\">91</span><br><span class=\"line\">92</span><br><span class=\"line\">93</span><br><span class=\"line\">94</span><br><span class=\"line\">95</span><br><span class=\"line\">96</span><br><span class=\"line\">97</span><br><span class=\"line\">98</span><br><span class=\"line\">99</span><br><span class=\"line\">100</span><br><span class=\"line\">101</span><br><span class=\"line\">102</span><br><span class=\"line\">103</span><br><span class=\"line\">104</span><br><span class=\"line\">105</span><br><span class=\"line\">106</span><br><span class=\"line\">107</span><br><span class=\"line\">108</span><br><span class=\"line\">109</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"keyword\">class</span> <span class=\"title class_\">Main</span> &#123;</span><br><span class=\"line\">    <span class=\"keyword\">public</span> <span class=\"keyword\">static</span> <span class=\"keyword\">void</span> <span class=\"title function_\">main</span><span class=\"params\">(String[] args)</span> &#123;</span><br><span class=\"line\">        _printHeader_(<span class=\"string\">&quot;图书馆管理系统启动&quot;</span>);</span><br><span class=\"line\"></span><br><span class=\"line\">        <span class=\"comment\">// 创建图书馆</span></span><br><span class=\"line\">        <span class=\"type\">Library</span> <span class=\"variable\">library</span> <span class=\"operator\">=</span> <span class=\"keyword\">new</span> <span class=\"title class_\">Library</span>(<span class=\"string\">&quot;我的图书馆&quot;</span>);</span><br><span class=\"line\">        </span><br><span class=\"line\">        _printHeader_(<span class=\"string\">&quot;初始化图书馆藏书&quot;</span>);</span><br><span class=\"line\">        <span class=\"comment\">// 添加图书</span></span><br><span class=\"line\">        <span class=\"type\">Book</span> <span class=\"variable\">book1</span> <span class=\"operator\">=</span> <span class=\"keyword\">new</span> <span class=\"title class_\">Book</span>(<span class=\"string\">&quot;Java编程思想&quot;</span>, <span class=\"string\">&quot;B001&quot;</span>, <span class=\"string\">&quot;Bruce Eckel&quot;</span>, <span class=\"string\">&quot;9787111213826&quot;</span>);</span><br><span class=\"line\">        <span class=\"type\">Book</span> <span class=\"variable\">book2</span> <span class=\"operator\">=</span> <span class=\"keyword\">new</span> <span class=\"title class_\">Book</span>(<span class=\"string\">&quot;软件工程&quot;</span>, <span class=\"string\">&quot;B002&quot;</span>, <span class=\"string\">&quot;Erich Gamma&quot;</span>, <span class=\"string\">&quot;9787111346365&quot;</span>);</span><br><span class=\"line\">        <span class=\"type\">Book</span> <span class=\"variable\">book3</span> <span class=\"operator\">=</span> <span class=\"keyword\">new</span> <span class=\"title class_\">Book</span>(<span class=\"string\">&quot;算法导论&quot;</span>, <span class=\"string\">&quot;B003&quot;</span>, <span class=\"string\">&quot;Thomas H. Cormen&quot;</span>, <span class=\"string\">&quot;9787111187776&quot;</span>);</span><br><span class=\"line\">        <span class=\"type\">Book</span> <span class=\"variable\">book4</span> <span class=\"operator\">=</span> <span class=\"keyword\">new</span> <span class=\"title class_\">Book</span>(<span class=\"string\">&quot;计算机网络&quot;</span>, <span class=\"string\">&quot;B004&quot;</span>, <span class=\"string\">&quot;谢希仁&quot;</span>, <span class=\"string\">&quot;9787302424645&quot;</span>);</span><br><span class=\"line\">        <span class=\"type\">Book</span> <span class=\"variable\">book6</span> <span class=\"operator\">=</span> <span class=\"keyword\">new</span> <span class=\"title class_\">Book</span>(<span class=\"string\">&quot;深度学习&quot;</span>, <span class=\"string\">&quot;B006&quot;</span>, <span class=\"string\">&quot;Abraham Silberschatz&quot;</span>, <span class=\"string\">&quot;9787111187776&quot;</span>);</span><br><span class=\"line\">        <span class=\"type\">Book</span> <span class=\"variable\">comic1</span> <span class=\"operator\">=</span> <span class=\"keyword\">new</span> <span class=\"title class_\">Book</span>(<span class=\"string\">&quot;欢迎来到实力至上主义教室&quot;</span>, <span class=\"string\">&quot;C007&quot;</span>, <span class=\"string\">&quot;衣笠彰梧&quot;</span>, <span class=\"string\">&quot;9784861994950&quot;</span>);</span><br><span class=\"line\">        <span class=\"type\">Book</span> <span class=\"variable\">comic2</span> <span class=\"operator\">=</span> <span class=\"keyword\">new</span> <span class=\"title class_\">Book</span>(<span class=\"string\">&quot;进击的巨人&quot;</span>, <span class=\"string\">&quot;C004&quot;</span>, <span class=\"string\">&quot;谏山创&quot;</span>, <span class=\"string\">&quot;9787115270532&quot;</span>);</span><br><span class=\"line\"></span><br><span class=\"line\">        <span class=\"comment\">// 添加图书到图书馆</span></span><br><span class=\"line\">        library.addItem(book1);</span><br><span class=\"line\">        library.addItem(book2);</span><br><span class=\"line\">        library.addItem(book3);</span><br><span class=\"line\">        library.addItem(book4);</span><br><span class=\"line\">        library.addItem(book6);</span><br><span class=\"line\">        library.addItem(comic1);</span><br><span class=\"line\">        library.addItem(comic2);</span><br><span class=\"line\"></span><br><span class=\"line\">        System._out_.println(<span class=\"string\">&quot;\\n当前图书馆藏书总量：&quot;</span> + library.getTotalItems() + <span class=\"string\">&quot; 本&quot;</span>);</span><br><span class=\"line\"></span><br><span class=\"line\">        _printHeader_(<span class=\"string\">&quot;注册读者信息&quot;</span>);</span><br><span class=\"line\">        <span class=\"comment\">// 创建读者</span></span><br><span class=\"line\">        <span class=\"type\">Reader</span> <span class=\"variable\">reader1</span> <span class=\"operator\">=</span> <span class=\"keyword\">new</span> <span class=\"title class_\">Reader</span>(<span class=\"string\">&quot;R001&quot;</span>, <span class=\"string\">&quot;张三&quot;</span>);</span><br><span class=\"line\">        <span class=\"type\">Reader</span> <span class=\"variable\">reader2</span> <span class=\"operator\">=</span> <span class=\"keyword\">new</span> <span class=\"title class_\">Reader</span>(<span class=\"string\">&quot;R002&quot;</span>, <span class=\"string\">&quot;李四&quot;</span>);</span><br><span class=\"line\">        <span class=\"type\">Reader</span> <span class=\"variable\">reader3</span> <span class=\"operator\">=</span> <span class=\"keyword\">new</span> <span class=\"title class_\">Reader</span>(<span class=\"string\">&quot;R003&quot;</span>, <span class=\"string\">&quot;王五&quot;</span>);</span><br><span class=\"line\"></span><br><span class=\"line\">        <span class=\"comment\">// 添加读者到图书馆</span></span><br><span class=\"line\">        library.addReader(reader1);</span><br><span class=\"line\">        library.addReader(reader2);</span><br><span class=\"line\">        library.addReader(reader3);</span><br><span class=\"line\">        System._out_.println(<span class=\"string\">&quot;\\n当前注册读者总数：&quot;</span> + library.getTotalReaders() + <span class=\"string\">&quot; 人&quot;</span>);</span><br><span class=\"line\"></span><br><span class=\"line\">        <span class=\"comment\">// 开馆</span></span><br><span class=\"line\">        _printHeader_(<span class=\"string\">&quot;图书馆开始营业&quot;</span>);</span><br><span class=\"line\">        library.openLibrary();</span><br><span class=\"line\"></span><br><span class=\"line\">        <span class=\"comment\">// 测试借阅</span></span><br><span class=\"line\">        _printHeader_(<span class=\"string\">&quot;借阅测试&quot;</span>);</span><br><span class=\"line\">        System._out_.println(<span class=\"string\">&quot;场景1: &quot;</span> + reader1.getName() + <span class=\"string\">&quot; 借阅《&quot;</span> + book1.getTitle() + <span class=\"string\">&quot;》&quot;</span>);</span><br><span class=\"line\">        <span class=\"keyword\">if</span> (library.borrowItem(<span class=\"string\">&quot;B001&quot;</span>, <span class=\"string\">&quot;R001&quot;</span>)) &#123;</span><br><span class=\"line\">            _printSuccess_(<span class=\"string\">&quot;借阅成功&quot;</span>);</span><br><span class=\"line\">        &#125; <span class=\"keyword\">else</span> &#123;</span><br><span class=\"line\">            _printError_(<span class=\"string\">&quot;借阅失败&quot;</span>);</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">        System._out_.println(<span class=\"string\">&quot;\\n场景2: &quot;</span> + reader2.getName() + <span class=\"string\">&quot; 尝试借阅已借出的《&quot;</span> + book1.getTitle() + <span class=\"string\">&quot;》&quot;</span>);</span><br><span class=\"line\">        <span class=\"keyword\">if</span> (library.borrowItem(<span class=\"string\">&quot;B001&quot;</span>, <span class=\"string\">&quot;R002&quot;</span>)) &#123;</span><br><span class=\"line\">            _printSuccess_(<span class=\"string\">&quot;借阅成功&quot;</span>);</span><br><span class=\"line\">        &#125; <span class=\"keyword\">else</span> &#123;</span><br><span class=\"line\">            _printError_(<span class=\"string\">&quot;借阅失败：图书已被借出&quot;</span>);</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">        System._out_.println(<span class=\"string\">&quot;\\n场景3: &quot;</span> + reader2.getName() + <span class=\"string\">&quot; 借阅《&quot;</span> + book2.getTitle() + <span class=\"string\">&quot;》&quot;</span>);</span><br><span class=\"line\">        <span class=\"keyword\">if</span> (library.borrowItem(<span class=\"string\">&quot;B002&quot;</span>, <span class=\"string\">&quot;R002&quot;</span>)) &#123;</span><br><span class=\"line\">            _printSuccess_(<span class=\"string\">&quot;借阅成功&quot;</span>);</span><br><span class=\"line\">        &#125; <span class=\"keyword\">else</span> &#123;</span><br><span class=\"line\">            _printError_(<span class=\"string\">&quot;借阅失败&quot;</span>);</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">        <span class=\"comment\">// 测试归还</span></span><br><span class=\"line\">        _printHeader_(<span class=\"string\">&quot;归还测试&quot;</span>);</span><br><span class=\"line\">        System._out_.println(<span class=\"string\">&quot;场景1: &quot;</span> + reader1.getName() + <span class=\"string\">&quot; 归还《&quot;</span> + book1.getTitle() + <span class=\"string\">&quot;》&quot;</span>);</span><br><span class=\"line\">        <span class=\"keyword\">if</span> (library.returnItem(<span class=\"string\">&quot;B001&quot;</span>, <span class=\"string\">&quot;R001&quot;</span>)) &#123;</span><br><span class=\"line\">            _printSuccess_(<span class=\"string\">&quot;归还成功&quot;</span>);</span><br><span class=\"line\">        &#125; <span class=\"keyword\">else</span> &#123;</span><br><span class=\"line\">            _printError_(<span class=\"string\">&quot;归还失败&quot;</span>);</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">        System._out_.println(<span class=\"string\">&quot;\\n场景2: &quot;</span> + reader2.getName() + <span class=\"string\">&quot; 归还《&quot;</span> + comic1.getTitle() + <span class=\"string\">&quot;》&quot;</span>);</span><br><span class=\"line\">        <span class=\"keyword\">if</span> (library.returnItem(<span class=\"string\">&quot;C007&quot;</span>, <span class=\"string\">&quot;R002&quot;</span>)) &#123;</span><br><span class=\"line\">            _printSuccess_(<span class=\"string\">&quot;归还成功&quot;</span>);</span><br><span class=\"line\">        &#125; <span class=\"keyword\">else</span> &#123;</span><br><span class=\"line\">            _printError_(<span class=\"string\">&quot;归还失败&quot;</span>);</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">        <span class=\"comment\">// 显示可用图书</span></span><br><span class=\"line\">        _printHeader_(<span class=\"string\">&quot;当前可借阅图书列表&quot;</span>);</span><br><span class=\"line\">        library.printAvailableBooks();</span><br><span class=\"line\"></span><br><span class=\"line\">        <span class=\"comment\">// 闭馆</span></span><br><span class=\"line\">        _printHeader_(<span class=\"string\">&quot;图书馆闭馆&quot;</span>);</span><br><span class=\"line\">        library.closeLibrary();</span><br><span class=\"line\">        </span><br><span class=\"line\">        _printHeader_(<span class=\"string\">&quot;系统运行结束&quot;</span>);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\">// 美化输出的辅助方法</span></span><br><span class=\"line\">    <span class=\"keyword\">private</span> <span class=\"keyword\">static</span> <span class=\"keyword\">void</span> <span class=\"title function_\">printHeader</span><span class=\"params\">(String message)</span> &#123;</span><br><span class=\"line\">        System._out_.println(<span class=\"string\">&quot;\\n&quot;</span> + <span class=\"string\">&quot;=&quot;</span>.repeat(<span class=\"number\">50</span>));</span><br><span class=\"line\">        System._out_.println(<span class=\"string\">&quot;&gt;&gt;&gt; &quot;</span> + message);</span><br><span class=\"line\">        System._out_.println(<span class=\"string\">&quot;=&quot;</span>.repeat(<span class=\"number\">50</span>));</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">private</span> <span class=\"keyword\">static</span> <span class=\"keyword\">void</span> <span class=\"title function_\">printSuccess</span><span class=\"params\">(String message)</span> &#123;</span><br><span class=\"line\">        System._out_.println(<span class=\"string\">&quot;[成功] &quot;</span> + message);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">private</span> <span class=\"keyword\">static</span> <span class=\"keyword\">void</span> <span class=\"title function_\">printError</span><span class=\"params\">(String message)</span> &#123;</span><br><span class=\"line\">        System._out_.println(<span class=\"string\">&quot;[失败] &quot;</span> + message);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n","excerpt":"","more":"<blockquote>\n<p><a href=\"https://www.bilibili.com/video/BV1sk4y1M7ru?vd_source=0ca07f837bf8ee7607324d7927199dcc&p=29&spm_id_from=333.788.videopod.episodes\">29_【项目】老马书城集合版-项目介绍_哔哩哔哩_bilibili</a>(参考视频)</p>\n</blockquote>\n<blockquote>\n<p><a href=\"https://github.com/rongchenlin/LibraryManagementSystem\">LibraryManagementSystem</a></p>\n</blockquote>\n<blockquote>\n<p><a href=\"https://blog.csdn.net/m0_64670207/article/details/136854580\">【图书管理系统】(超详细附源码用 java 实现)_图书管理系统源码-CSDN 博客</a></p>\n</blockquote>\n<h1 id=\"图书馆管理系统项目说明\"><a href=\"#图书馆管理系统项目说明\" class=\"headerlink\" title=\"图书馆管理系统项目说明\"></a>图书馆管理系统项目说明</h1><h2 id=\"项目概述\"><a href=\"#项目概述\" class=\"headerlink\" title=\"项目概述\"></a>项目概述</h2><p>我选择的是选题三图书馆：模拟一天的借阅过程,应该这个选题更加贴近现实开发,用于模拟图书馆日常的借阅管理流程。系统实现了图书馆基本的图书管理、读者管理、借阅管理等功能。</p>\n<p>系统的架构设计如下：系统通过定义一个 Borrowable 接口，规范了可借阅物品的标准操作，包括借阅和归还等基本功能。LibraryItem 作为抽象类，实现了 Borrowable 接口，为所有可借阅物品提供了基础结构，包含标题、ID 等通用属性。具体类 Book 继承自 LibraryItem，扩展了图书特有的属性（如作者、ISBN）和行为。Reader 类负责管理读者信息，并跟踪读者的借阅记录。Library 类作为系统的核心管理类，负责处理图书和读者的注册，管理借阅和归还流程，并维护图书馆的开放状态。通过这种设计，系统实现了对图书馆资源和读者行为的高效管理。</p>\n<p>为了理清思路，我先了画出类图，梳理各个类之间的关系。在编码阶段，我遇到了不少问题。例如，在使用 HashMap 管理图书时，我错误地将 ISBN 作为字符串拼接，导致查询时出现空指针异常。我按照教程编写了 borrowBook() 方法，但运行时发现同一本书可以被多次借出。经过仔细检查，我意识到问题出在没有为 Book 类添加 isAvailable 标志位。在修正了这一问题后，我特意编写了多个测试用例，验证了各种边界情况，确保了借阅逻辑的正确性。</p>\n<h2 id=\"系统架构\"><a href=\"#系统架构\" class=\"headerlink\" title=\"系统架构\"></a>系统架构</h2><p>系统采用面向对象的设计方法，主要包含以下核心组件：</p>\n<h2 id=\"主要功能\"><a href=\"#主要功能\" class=\"headerlink\" title=\"主要功能\"></a>主要功能</h2><h2 id=\"技术特点\"><a href=\"#技术特点\" class=\"headerlink\" title=\"技术特点\"></a>技术特点</h2><ol>\n<li><p>面向对象设计</p>\n<ul>\n<li>使用继承（LibraryItem -&gt; Book）</li>\n<li>使用接口（Borrowable）</li>\n<li>封装（private 属性 + getter&#x2F;setter）</li>\n<li>多态（LibraryItem 的实现）</li>\n</ul>\n</li>\n<li><p>Java 语言特性</p>\n<ul>\n<li>使用 <code>abstract</code> 类</li>\n<li>使用 <code>interface</code></li>\n<li>使用 <code>@Override</code> 注解</li>\n<li>使用 <code>static</code> 和 <code>final</code> 修饰符</li>\n</ul>\n</li>\n<li><p>集合框架应用</p>\n<ul>\n<li>使用 <code>HashMap</code> 管理图书和读者</li>\n<li>使用 <code>ArrayList</code> 存储借阅记录</li>\n</ul>\n</li>\n</ol>\n<h2 id=\"运行说明\"><a href=\"#运行说明\" class=\"headerlink\" title=\"运行说明\"></a>运行说明</h2><ol>\n<li>编译方法</li>\n</ol>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"built_in\">cd</span> src</span><br><span class=\"line\">javac *.java</span><br></pre></td></tr></table></figure>\n\n<ol>\n<li>运行方法</li>\n</ol>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">java Main</span><br></pre></td></tr></table></figure>\n\n<h2 id=\"项目结构\"><a href=\"#项目结构\" class=\"headerlink\" title=\"项目结构\"></a>项目结构</h2><figure class=\"highlight stylus\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"attribute\">src</span>/</span><br><span class=\"line\">├── Borrowable<span class=\"selector-class\">.java</span>     <span class=\"comment\">// 可借阅接口</span></span><br><span class=\"line\">├── LibraryItem<span class=\"selector-class\">.java</span>    <span class=\"comment\">// 图书馆物品抽象类</span></span><br><span class=\"line\">├── Book<span class=\"selector-class\">.java</span>           <span class=\"comment\">// 图书类</span></span><br><span class=\"line\">├── Reader<span class=\"selector-class\">.java</span>         <span class=\"comment\">// 读者类</span></span><br><span class=\"line\">├── Library<span class=\"selector-class\">.java</span>        <span class=\"comment\">// 图书馆管理类</span></span><br><span class=\"line\">└── Main<span class=\"selector-class\">.java</span>           <span class=\"comment\">// 主程序入口</span></span><br></pre></td></tr></table></figure>\n\n<h2 id=\"注意事项\"><a href=\"#注意事项\" class=\"headerlink\" title=\"注意事项\"></a>注意事项</h2><ol>\n<li>系统使用 ISBN 作为图书的唯一标识</li>\n<li>读者 ID 格式为”R”+ 序号</li>\n<li>图书 ID 格式为”B”+ 序号</li>\n<li>图书馆闭馆时无法进行借还操作</li>\n</ol>\n<h2 id=\"运行结果\"><a href=\"#运行结果\" class=\"headerlink\" title=\"运行结果\"></a>运行结果</h2><p><img src=\"https://tk-pichost-1325224430.cos.ap-chengdu.myqcloud.com/blog/1743590162843CbQ4bP8FJoMZDCxRi9FcBNlonBh.png\" alt=\"1743590162843CbQ4bP8FJoMZDCxRi9FcBNlonBh.png\"><br><img src=\"https://tk-pichost-1325224430.cos.ap-chengdu.myqcloud.com/blog/1743590155844Lv5BbqXAFoDN2Wxo7MscZZCmngd.png\" alt=\"1743590155844Lv5BbqXAFoDN2Wxo7MscZZCmngd.png\"><br><img src=\"https://tk-pichost-1325224430.cos.ap-chengdu.myqcloud.com/blog/1743590165844WgHtbCCmRohtZwxwI1XcLqjYnvf.png\" alt=\"1743590165844WgHtbCCmRohtZwxwI1XcLqjYnvf.png\"></p>\n<h2 id=\"Main-代码\"><a href=\"#Main-代码\" class=\"headerlink\" title=\"Main 代码\"></a>Main 代码</h2><blockquote>\n<p><a href=\"https://github.com/tkzzzzzz6/My_Java_homework\">https://github.com/tkzzzzzz6/My_Java_homework</a>(完整代码链接)</p>\n</blockquote>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br><span class=\"line\">47</span><br><span class=\"line\">48</span><br><span class=\"line\">49</span><br><span class=\"line\">50</span><br><span class=\"line\">51</span><br><span class=\"line\">52</span><br><span class=\"line\">53</span><br><span class=\"line\">54</span><br><span class=\"line\">55</span><br><span class=\"line\">56</span><br><span class=\"line\">57</span><br><span class=\"line\">58</span><br><span class=\"line\">59</span><br><span class=\"line\">60</span><br><span class=\"line\">61</span><br><span class=\"line\">62</span><br><span class=\"line\">63</span><br><span class=\"line\">64</span><br><span class=\"line\">65</span><br><span class=\"line\">66</span><br><span class=\"line\">67</span><br><span class=\"line\">68</span><br><span class=\"line\">69</span><br><span class=\"line\">70</span><br><span class=\"line\">71</span><br><span class=\"line\">72</span><br><span class=\"line\">73</span><br><span class=\"line\">74</span><br><span class=\"line\">75</span><br><span class=\"line\">76</span><br><span class=\"line\">77</span><br><span class=\"line\">78</span><br><span class=\"line\">79</span><br><span class=\"line\">80</span><br><span class=\"line\">81</span><br><span class=\"line\">82</span><br><span class=\"line\">83</span><br><span class=\"line\">84</span><br><span class=\"line\">85</span><br><span class=\"line\">86</span><br><span class=\"line\">87</span><br><span class=\"line\">88</span><br><span class=\"line\">89</span><br><span class=\"line\">90</span><br><span class=\"line\">91</span><br><span class=\"line\">92</span><br><span class=\"line\">93</span><br><span class=\"line\">94</span><br><span class=\"line\">95</span><br><span class=\"line\">96</span><br><span class=\"line\">97</span><br><span class=\"line\">98</span><br><span class=\"line\">99</span><br><span class=\"line\">100</span><br><span class=\"line\">101</span><br><span class=\"line\">102</span><br><span class=\"line\">103</span><br><span class=\"line\">104</span><br><span class=\"line\">105</span><br><span class=\"line\">106</span><br><span class=\"line\">107</span><br><span class=\"line\">108</span><br><span class=\"line\">109</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"keyword\">class</span> <span class=\"title class_\">Main</span> &#123;</span><br><span class=\"line\">    <span class=\"keyword\">public</span> <span class=\"keyword\">static</span> <span class=\"keyword\">void</span> <span class=\"title function_\">main</span><span class=\"params\">(String[] args)</span> &#123;</span><br><span class=\"line\">        _printHeader_(<span class=\"string\">&quot;图书馆管理系统启动&quot;</span>);</span><br><span class=\"line\"></span><br><span class=\"line\">        <span class=\"comment\">// 创建图书馆</span></span><br><span class=\"line\">        <span class=\"type\">Library</span> <span class=\"variable\">library</span> <span class=\"operator\">=</span> <span class=\"keyword\">new</span> <span class=\"title class_\">Library</span>(<span class=\"string\">&quot;我的图书馆&quot;</span>);</span><br><span class=\"line\">        </span><br><span class=\"line\">        _printHeader_(<span class=\"string\">&quot;初始化图书馆藏书&quot;</span>);</span><br><span class=\"line\">        <span class=\"comment\">// 添加图书</span></span><br><span class=\"line\">        <span class=\"type\">Book</span> <span class=\"variable\">book1</span> <span class=\"operator\">=</span> <span class=\"keyword\">new</span> <span class=\"title class_\">Book</span>(<span class=\"string\">&quot;Java编程思想&quot;</span>, <span class=\"string\">&quot;B001&quot;</span>, <span class=\"string\">&quot;Bruce Eckel&quot;</span>, <span class=\"string\">&quot;9787111213826&quot;</span>);</span><br><span class=\"line\">        <span class=\"type\">Book</span> <span class=\"variable\">book2</span> <span class=\"operator\">=</span> <span class=\"keyword\">new</span> <span class=\"title class_\">Book</span>(<span class=\"string\">&quot;软件工程&quot;</span>, <span class=\"string\">&quot;B002&quot;</span>, <span class=\"string\">&quot;Erich Gamma&quot;</span>, <span class=\"string\">&quot;9787111346365&quot;</span>);</span><br><span class=\"line\">        <span class=\"type\">Book</span> <span class=\"variable\">book3</span> <span class=\"operator\">=</span> <span class=\"keyword\">new</span> <span class=\"title class_\">Book</span>(<span class=\"string\">&quot;算法导论&quot;</span>, <span class=\"string\">&quot;B003&quot;</span>, <span class=\"string\">&quot;Thomas H. Cormen&quot;</span>, <span class=\"string\">&quot;9787111187776&quot;</span>);</span><br><span class=\"line\">        <span class=\"type\">Book</span> <span class=\"variable\">book4</span> <span class=\"operator\">=</span> <span class=\"keyword\">new</span> <span class=\"title class_\">Book</span>(<span class=\"string\">&quot;计算机网络&quot;</span>, <span class=\"string\">&quot;B004&quot;</span>, <span class=\"string\">&quot;谢希仁&quot;</span>, <span class=\"string\">&quot;9787302424645&quot;</span>);</span><br><span class=\"line\">        <span class=\"type\">Book</span> <span class=\"variable\">book6</span> <span class=\"operator\">=</span> <span class=\"keyword\">new</span> <span class=\"title class_\">Book</span>(<span class=\"string\">&quot;深度学习&quot;</span>, <span class=\"string\">&quot;B006&quot;</span>, <span class=\"string\">&quot;Abraham Silberschatz&quot;</span>, <span class=\"string\">&quot;9787111187776&quot;</span>);</span><br><span class=\"line\">        <span class=\"type\">Book</span> <span class=\"variable\">comic1</span> <span class=\"operator\">=</span> <span class=\"keyword\">new</span> <span class=\"title class_\">Book</span>(<span class=\"string\">&quot;欢迎来到实力至上主义教室&quot;</span>, <span class=\"string\">&quot;C007&quot;</span>, <span class=\"string\">&quot;衣笠彰梧&quot;</span>, <span class=\"string\">&quot;9784861994950&quot;</span>);</span><br><span class=\"line\">        <span class=\"type\">Book</span> <span class=\"variable\">comic2</span> <span class=\"operator\">=</span> <span class=\"keyword\">new</span> <span class=\"title class_\">Book</span>(<span class=\"string\">&quot;进击的巨人&quot;</span>, <span class=\"string\">&quot;C004&quot;</span>, <span class=\"string\">&quot;谏山创&quot;</span>, <span class=\"string\">&quot;9787115270532&quot;</span>);</span><br><span class=\"line\"></span><br><span class=\"line\">        <span class=\"comment\">// 添加图书到图书馆</span></span><br><span class=\"line\">        library.addItem(book1);</span><br><span class=\"line\">        library.addItem(book2);</span><br><span class=\"line\">        library.addItem(book3);</span><br><span class=\"line\">        library.addItem(book4);</span><br><span class=\"line\">        library.addItem(book6);</span><br><span class=\"line\">        library.addItem(comic1);</span><br><span class=\"line\">        library.addItem(comic2);</span><br><span class=\"line\"></span><br><span class=\"line\">        System._out_.println(<span class=\"string\">&quot;\\n当前图书馆藏书总量：&quot;</span> + library.getTotalItems() + <span class=\"string\">&quot; 本&quot;</span>);</span><br><span class=\"line\"></span><br><span class=\"line\">        _printHeader_(<span class=\"string\">&quot;注册读者信息&quot;</span>);</span><br><span class=\"line\">        <span class=\"comment\">// 创建读者</span></span><br><span class=\"line\">        <span class=\"type\">Reader</span> <span class=\"variable\">reader1</span> <span class=\"operator\">=</span> <span class=\"keyword\">new</span> <span class=\"title class_\">Reader</span>(<span class=\"string\">&quot;R001&quot;</span>, <span class=\"string\">&quot;张三&quot;</span>);</span><br><span class=\"line\">        <span class=\"type\">Reader</span> <span class=\"variable\">reader2</span> <span class=\"operator\">=</span> <span class=\"keyword\">new</span> <span class=\"title class_\">Reader</span>(<span class=\"string\">&quot;R002&quot;</span>, <span class=\"string\">&quot;李四&quot;</span>);</span><br><span class=\"line\">        <span class=\"type\">Reader</span> <span class=\"variable\">reader3</span> <span class=\"operator\">=</span> <span class=\"keyword\">new</span> <span class=\"title class_\">Reader</span>(<span class=\"string\">&quot;R003&quot;</span>, <span class=\"string\">&quot;王五&quot;</span>);</span><br><span class=\"line\"></span><br><span class=\"line\">        <span class=\"comment\">// 添加读者到图书馆</span></span><br><span class=\"line\">        library.addReader(reader1);</span><br><span class=\"line\">        library.addReader(reader2);</span><br><span class=\"line\">        library.addReader(reader3);</span><br><span class=\"line\">        System._out_.println(<span class=\"string\">&quot;\\n当前注册读者总数：&quot;</span> + library.getTotalReaders() + <span class=\"string\">&quot; 人&quot;</span>);</span><br><span class=\"line\"></span><br><span class=\"line\">        <span class=\"comment\">// 开馆</span></span><br><span class=\"line\">        _printHeader_(<span class=\"string\">&quot;图书馆开始营业&quot;</span>);</span><br><span class=\"line\">        library.openLibrary();</span><br><span class=\"line\"></span><br><span class=\"line\">        <span class=\"comment\">// 测试借阅</span></span><br><span class=\"line\">        _printHeader_(<span class=\"string\">&quot;借阅测试&quot;</span>);</span><br><span class=\"line\">        System._out_.println(<span class=\"string\">&quot;场景1: &quot;</span> + reader1.getName() + <span class=\"string\">&quot; 借阅《&quot;</span> + book1.getTitle() + <span class=\"string\">&quot;》&quot;</span>);</span><br><span class=\"line\">        <span class=\"keyword\">if</span> (library.borrowItem(<span class=\"string\">&quot;B001&quot;</span>, <span class=\"string\">&quot;R001&quot;</span>)) &#123;</span><br><span class=\"line\">            _printSuccess_(<span class=\"string\">&quot;借阅成功&quot;</span>);</span><br><span class=\"line\">        &#125; <span class=\"keyword\">else</span> &#123;</span><br><span class=\"line\">            _printError_(<span class=\"string\">&quot;借阅失败&quot;</span>);</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">        System._out_.println(<span class=\"string\">&quot;\\n场景2: &quot;</span> + reader2.getName() + <span class=\"string\">&quot; 尝试借阅已借出的《&quot;</span> + book1.getTitle() + <span class=\"string\">&quot;》&quot;</span>);</span><br><span class=\"line\">        <span class=\"keyword\">if</span> (library.borrowItem(<span class=\"string\">&quot;B001&quot;</span>, <span class=\"string\">&quot;R002&quot;</span>)) &#123;</span><br><span class=\"line\">            _printSuccess_(<span class=\"string\">&quot;借阅成功&quot;</span>);</span><br><span class=\"line\">        &#125; <span class=\"keyword\">else</span> &#123;</span><br><span class=\"line\">            _printError_(<span class=\"string\">&quot;借阅失败：图书已被借出&quot;</span>);</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">        System._out_.println(<span class=\"string\">&quot;\\n场景3: &quot;</span> + reader2.getName() + <span class=\"string\">&quot; 借阅《&quot;</span> + book2.getTitle() + <span class=\"string\">&quot;》&quot;</span>);</span><br><span class=\"line\">        <span class=\"keyword\">if</span> (library.borrowItem(<span class=\"string\">&quot;B002&quot;</span>, <span class=\"string\">&quot;R002&quot;</span>)) &#123;</span><br><span class=\"line\">            _printSuccess_(<span class=\"string\">&quot;借阅成功&quot;</span>);</span><br><span class=\"line\">        &#125; <span class=\"keyword\">else</span> &#123;</span><br><span class=\"line\">            _printError_(<span class=\"string\">&quot;借阅失败&quot;</span>);</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">        <span class=\"comment\">// 测试归还</span></span><br><span class=\"line\">        _printHeader_(<span class=\"string\">&quot;归还测试&quot;</span>);</span><br><span class=\"line\">        System._out_.println(<span class=\"string\">&quot;场景1: &quot;</span> + reader1.getName() + <span class=\"string\">&quot; 归还《&quot;</span> + book1.getTitle() + <span class=\"string\">&quot;》&quot;</span>);</span><br><span class=\"line\">        <span class=\"keyword\">if</span> (library.returnItem(<span class=\"string\">&quot;B001&quot;</span>, <span class=\"string\">&quot;R001&quot;</span>)) &#123;</span><br><span class=\"line\">            _printSuccess_(<span class=\"string\">&quot;归还成功&quot;</span>);</span><br><span class=\"line\">        &#125; <span class=\"keyword\">else</span> &#123;</span><br><span class=\"line\">            _printError_(<span class=\"string\">&quot;归还失败&quot;</span>);</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">        System._out_.println(<span class=\"string\">&quot;\\n场景2: &quot;</span> + reader2.getName() + <span class=\"string\">&quot; 归还《&quot;</span> + comic1.getTitle() + <span class=\"string\">&quot;》&quot;</span>);</span><br><span class=\"line\">        <span class=\"keyword\">if</span> (library.returnItem(<span class=\"string\">&quot;C007&quot;</span>, <span class=\"string\">&quot;R002&quot;</span>)) &#123;</span><br><span class=\"line\">            _printSuccess_(<span class=\"string\">&quot;归还成功&quot;</span>);</span><br><span class=\"line\">        &#125; <span class=\"keyword\">else</span> &#123;</span><br><span class=\"line\">            _printError_(<span class=\"string\">&quot;归还失败&quot;</span>);</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">        <span class=\"comment\">// 显示可用图书</span></span><br><span class=\"line\">        _printHeader_(<span class=\"string\">&quot;当前可借阅图书列表&quot;</span>);</span><br><span class=\"line\">        library.printAvailableBooks();</span><br><span class=\"line\"></span><br><span class=\"line\">        <span class=\"comment\">// 闭馆</span></span><br><span class=\"line\">        _printHeader_(<span class=\"string\">&quot;图书馆闭馆&quot;</span>);</span><br><span class=\"line\">        library.closeLibrary();</span><br><span class=\"line\">        </span><br><span class=\"line\">        _printHeader_(<span class=\"string\">&quot;系统运行结束&quot;</span>);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\">// 美化输出的辅助方法</span></span><br><span class=\"line\">    <span class=\"keyword\">private</span> <span class=\"keyword\">static</span> <span class=\"keyword\">void</span> <span class=\"title function_\">printHeader</span><span class=\"params\">(String message)</span> &#123;</span><br><span class=\"line\">        System._out_.println(<span class=\"string\">&quot;\\n&quot;</span> + <span class=\"string\">&quot;=&quot;</span>.repeat(<span class=\"number\">50</span>));</span><br><span class=\"line\">        System._out_.println(<span class=\"string\">&quot;&gt;&gt;&gt; &quot;</span> + message);</span><br><span class=\"line\">        System._out_.println(<span class=\"string\">&quot;=&quot;</span>.repeat(<span class=\"number\">50</span>));</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">private</span> <span class=\"keyword\">static</span> <span class=\"keyword\">void</span> <span class=\"title function_\">printSuccess</span><span class=\"params\">(String message)</span> &#123;</span><br><span class=\"line\">        System._out_.println(<span class=\"string\">&quot;[成功] &quot;</span> + message);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">private</span> <span class=\"keyword\">static</span> <span class=\"keyword\">void</span> <span class=\"title function_\">printError</span><span class=\"params\">(String message)</span> &#123;</span><br><span class=\"line\">        System._out_.println(<span class=\"string\">&quot;[失败] &quot;</span> + message);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n"},{"title":"2025-04-10 汇编实验1：利用DEBUG熟悉常用指令的使用","date":"2025-04-09T16:00:00.000Z","_content":"\n# 2025-04-10 汇编实验1：利用DEBUG熟悉常用指令的使用\n\n## 实验目的\n\n熟悉DEBUG中的常用调试命令（如R、D、E、T、A、G、P等），通过实验加深对各种寻址方式的理解；能够熟练使用DEBUG中的命令对指令进行反汇编，观察并了解机器代码。\n\n## 实验题\n\n### 任务一：设置寄存器和存储单元\n\n通过DEBUG命令对寄存器和存储单元进行设置，使其满足以下条件：\n\n| 寄存器/存储地址 | 值     |\n|----------------|---------|\n| (DS)           | 2000H   |\n| (BX)           | 0100H   |\n| (SI)           | 0002H   |\n| (BP)           | 0200H   |\n| (SS)           | 2300H   |\n| (20100)        | 12H     |\n| (20101)        | 34H     |\n| (20102)        | 56H     |\n| (20103)        | 78H     |\n| (21200)        | 2AH     |\n| (21201)        | 4CH     |\n| (21202)        | B7H     |\n| (21203)        | 65H     |\n| (23204)        | 88H     |\n| (23205)        | 99H     |\n\n### 任务二：执行指令并观察结果\n\n分别输入下列指令，并单步执行(T)，观察执行结果并截图。说明每条指令执行完成后AX寄存器的内容。\n\n#### (1) MOV AX, 1200H\n\n**源操作数为立即寻址方式**\n- (AX) = 1200H\n\n**t = 0**\n- AX = 1200H\n- BX = 0100H\n- CX = 0009H\n- DX = 0000H\n- SP = 0000H\n- BP = 0200H\n- SI = 0002H\n- DI = 0000H\n- DS = 2000H\n- ES = 0760H\n- SS = 2300H\n- CS = 0770H\n- IP = 0003H\n- 标志位：NU UP EI PL NZ NA PO NC\n\n![17444568124471744456812290.png](https://tk-pichost-1325224430.cos.ap-chengdu.myqcloud.com/blog/17444568124471744456812290.png)\n\n#### (2) MOV AX, BX\n\n**源操作数为寄存器寻址方式**\n- (BX) = 0100H\n\n![17444568464441744456846383.png](https://tk-pichost-1325224430.cos.ap-chengdu.myqcloud.com/blog/17444568464441744456846383.png)\n![17444568554431744456855020.png](https://tk-pichost-1325224430.cos.ap-chengdu.myqcloud.com/blog/17444568554431744456855020.png)\n\n#### (3) MOV AX, [1200H]\n\n**源操作数为直接寻址方式**\n- ([1200H]) = (21200H) = 4C2AH\n\n#### (4) MOV AX, [BX]\n\n**源操作数为寄存器间接寻址方式**\n- ([BX]) = (20100H) = 1234H\n\n![17444568624421744456862198.png](https://tk-pichost-1325224430.cos.ap-chengdu.myqcloud.com/blog/17444568624421744456862198.png)\n![17444568884441744456887465.png](https://tk-pichost-1325224430.cos.ap-chengdu.myqcloud.com/blog/17444568884441744456887465.png)\n\n#### (5) MOV AX, 1100[BX]\n\n**源操作数为基址变址加偏移地址寻址方式**\n- (1100[BX]) = (21202H) = 65B7H\n\n![17444569014431744456901288.png](https://tk-pichost-1325224430.cos.ap-chengdu.myqcloud.com/blog/17444569014431744456901288.png)\n\n#### (6) MOV AX, [BX][SI]\n\n**源操作数为基址变址加偏移地址寻址方式**\n- ([BX][SI]) = (20102H) = 56H78H\n\nAX = 7856H\nBX = 0100H\nCX = 0009H\nDX = 0000H\nSP = 0000H\nBP = 0200H\nSI = 0002H\nDI = 0000H\nDS = 2000H\nES = 0760H\nSS = 2300H\nCS = 0770H\nIP = 0010H\n标志位：NU UP EI PL NZ NA PO NC\n\n#### (7) MOV AX, 1100[BX][SI]\n\n**源操作数为基址变址加偏移地址寻址方式**\n- (1100[BX][SI]) = (21202H) = 65B7H\n\n![17444569444441744456943836.png](https://tk-pichost-1325224430.cos.ap-chengdu.myqcloud.com/blog/17444569444441744456943836.png)\n![17444569624431744456961758.png](https://tk-pichost-1325224430.cos.ap-chengdu.myqcloud.com/blog/17444569624431744456961758.png)\n\n#### (8) MOV AX, [BP+SI+04]\n\n**源操作数为基址变址加偏移地址寻址方式**\n- ([BP+SI+04]) = (20104H) = 0000H\n\n![17444569764471744456975814.png](https://tk-pichost-1325224430.cos.ap-chengdu.myqcloud.com/blog/17444569764471744456975814.png)\n\n## 实验报告\n\n### 总结操作步骤及各种寻址方式，记录调试结果。\n\n### 任务一运行结果\n\n使用`r+`命令给寄存器赋值：\n- ![17444569874441744456987333.png](https://tk-pichost-1325224430.cos.ap-chengdu.myqcloud.com/blog/17444569874441744456987333.png)\n\n使用`f`命令给20100到20103赋值：\n- ![17444570054451744457004736.png](https://tk-pichost-1325224430.cos.ap-chengdu.myqcloud.com/blog/17444570054451744457004736.png)\n\n使用`f`命令给21200到21203赋值：\n- ![17444570193821744457017476.png](https://tk-pichost-1325224430.cos.ap-chengdu.myqcloud.com/blog/17444570193821744457017476.png)\n\n使用`f`命令给23204到23205赋值：\n- ![未提供具体图片链接，请自行补充]\n\n### 任务二\n\n使用`a`命令给代码段添加汇编代码，并使用`u`命令反汇编代码以检查其正确性。\n- ![17444570314451744457031389.png](https://tk-pichost-1325224430.cos.ap-chengdu.myqcloud.com/blog/17444570314451744457031389.png)\n\n使用`t`命令单步运行指令：\n- ![17444570454481744457044523.png](https://tk-pichost-1325224430.cos.ap-chengdu.myqcloud.com/blog/17444570454481744457044523.png)","source":"_posts/2025-04-10-汇编语言实验1_debug命令.md","raw":"---\ntitle: 2025-04-10 汇编实验1：利用DEBUG熟悉常用指令的使用\ndate: 2025-04-10\ntags: \n    课程学习\n---\n\n# 2025-04-10 汇编实验1：利用DEBUG熟悉常用指令的使用\n\n## 实验目的\n\n熟悉DEBUG中的常用调试命令（如R、D、E、T、A、G、P等），通过实验加深对各种寻址方式的理解；能够熟练使用DEBUG中的命令对指令进行反汇编，观察并了解机器代码。\n\n## 实验题\n\n### 任务一：设置寄存器和存储单元\n\n通过DEBUG命令对寄存器和存储单元进行设置，使其满足以下条件：\n\n| 寄存器/存储地址 | 值     |\n|----------------|---------|\n| (DS)           | 2000H   |\n| (BX)           | 0100H   |\n| (SI)           | 0002H   |\n| (BP)           | 0200H   |\n| (SS)           | 2300H   |\n| (20100)        | 12H     |\n| (20101)        | 34H     |\n| (20102)        | 56H     |\n| (20103)        | 78H     |\n| (21200)        | 2AH     |\n| (21201)        | 4CH     |\n| (21202)        | B7H     |\n| (21203)        | 65H     |\n| (23204)        | 88H     |\n| (23205)        | 99H     |\n\n### 任务二：执行指令并观察结果\n\n分别输入下列指令，并单步执行(T)，观察执行结果并截图。说明每条指令执行完成后AX寄存器的内容。\n\n#### (1) MOV AX, 1200H\n\n**源操作数为立即寻址方式**\n- (AX) = 1200H\n\n**t = 0**\n- AX = 1200H\n- BX = 0100H\n- CX = 0009H\n- DX = 0000H\n- SP = 0000H\n- BP = 0200H\n- SI = 0002H\n- DI = 0000H\n- DS = 2000H\n- ES = 0760H\n- SS = 2300H\n- CS = 0770H\n- IP = 0003H\n- 标志位：NU UP EI PL NZ NA PO NC\n\n![17444568124471744456812290.png](https://tk-pichost-1325224430.cos.ap-chengdu.myqcloud.com/blog/17444568124471744456812290.png)\n\n#### (2) MOV AX, BX\n\n**源操作数为寄存器寻址方式**\n- (BX) = 0100H\n\n![17444568464441744456846383.png](https://tk-pichost-1325224430.cos.ap-chengdu.myqcloud.com/blog/17444568464441744456846383.png)\n![17444568554431744456855020.png](https://tk-pichost-1325224430.cos.ap-chengdu.myqcloud.com/blog/17444568554431744456855020.png)\n\n#### (3) MOV AX, [1200H]\n\n**源操作数为直接寻址方式**\n- ([1200H]) = (21200H) = 4C2AH\n\n#### (4) MOV AX, [BX]\n\n**源操作数为寄存器间接寻址方式**\n- ([BX]) = (20100H) = 1234H\n\n![17444568624421744456862198.png](https://tk-pichost-1325224430.cos.ap-chengdu.myqcloud.com/blog/17444568624421744456862198.png)\n![17444568884441744456887465.png](https://tk-pichost-1325224430.cos.ap-chengdu.myqcloud.com/blog/17444568884441744456887465.png)\n\n#### (5) MOV AX, 1100[BX]\n\n**源操作数为基址变址加偏移地址寻址方式**\n- (1100[BX]) = (21202H) = 65B7H\n\n![17444569014431744456901288.png](https://tk-pichost-1325224430.cos.ap-chengdu.myqcloud.com/blog/17444569014431744456901288.png)\n\n#### (6) MOV AX, [BX][SI]\n\n**源操作数为基址变址加偏移地址寻址方式**\n- ([BX][SI]) = (20102H) = 56H78H\n\nAX = 7856H\nBX = 0100H\nCX = 0009H\nDX = 0000H\nSP = 0000H\nBP = 0200H\nSI = 0002H\nDI = 0000H\nDS = 2000H\nES = 0760H\nSS = 2300H\nCS = 0770H\nIP = 0010H\n标志位：NU UP EI PL NZ NA PO NC\n\n#### (7) MOV AX, 1100[BX][SI]\n\n**源操作数为基址变址加偏移地址寻址方式**\n- (1100[BX][SI]) = (21202H) = 65B7H\n\n![17444569444441744456943836.png](https://tk-pichost-1325224430.cos.ap-chengdu.myqcloud.com/blog/17444569444441744456943836.png)\n![17444569624431744456961758.png](https://tk-pichost-1325224430.cos.ap-chengdu.myqcloud.com/blog/17444569624431744456961758.png)\n\n#### (8) MOV AX, [BP+SI+04]\n\n**源操作数为基址变址加偏移地址寻址方式**\n- ([BP+SI+04]) = (20104H) = 0000H\n\n![17444569764471744456975814.png](https://tk-pichost-1325224430.cos.ap-chengdu.myqcloud.com/blog/17444569764471744456975814.png)\n\n## 实验报告\n\n### 总结操作步骤及各种寻址方式，记录调试结果。\n\n### 任务一运行结果\n\n使用`r+`命令给寄存器赋值：\n- ![17444569874441744456987333.png](https://tk-pichost-1325224430.cos.ap-chengdu.myqcloud.com/blog/17444569874441744456987333.png)\n\n使用`f`命令给20100到20103赋值：\n- ![17444570054451744457004736.png](https://tk-pichost-1325224430.cos.ap-chengdu.myqcloud.com/blog/17444570054451744457004736.png)\n\n使用`f`命令给21200到21203赋值：\n- ![17444570193821744457017476.png](https://tk-pichost-1325224430.cos.ap-chengdu.myqcloud.com/blog/17444570193821744457017476.png)\n\n使用`f`命令给23204到23205赋值：\n- ![未提供具体图片链接，请自行补充]\n\n### 任务二\n\n使用`a`命令给代码段添加汇编代码，并使用`u`命令反汇编代码以检查其正确性。\n- ![17444570314451744457031389.png](https://tk-pichost-1325224430.cos.ap-chengdu.myqcloud.com/blog/17444570314451744457031389.png)\n\n使用`t`命令单步运行指令：\n- ![17444570454481744457044523.png](https://tk-pichost-1325224430.cos.ap-chengdu.myqcloud.com/blog/17444570454481744457044523.png)","slug":"2025-04-10-汇编语言实验1_debug命令","published":1,"updated":"2025-09-26T12:16:40.701Z","_id":"cmg0saj44001jjm8n3jyof06c","comments":1,"layout":"post","photos":[],"content":"<h1 id=\"2025-04-10-汇编实验1：利用DEBUG熟悉常用指令的使用\"><a href=\"#2025-04-10-汇编实验1：利用DEBUG熟悉常用指令的使用\" class=\"headerlink\" title=\"2025-04-10 汇编实验1：利用DEBUG熟悉常用指令的使用\"></a>2025-04-10 汇编实验1：利用DEBUG熟悉常用指令的使用</h1><h2 id=\"实验目的\"><a href=\"#实验目的\" class=\"headerlink\" title=\"实验目的\"></a>实验目的</h2><p>熟悉DEBUG中的常用调试命令（如R、D、E、T、A、G、P等），通过实验加深对各种寻址方式的理解；能够熟练使用DEBUG中的命令对指令进行反汇编，观察并了解机器代码。</p>\n<h2 id=\"实验题\"><a href=\"#实验题\" class=\"headerlink\" title=\"实验题\"></a>实验题</h2><h3 id=\"任务一：设置寄存器和存储单元\"><a href=\"#任务一：设置寄存器和存储单元\" class=\"headerlink\" title=\"任务一：设置寄存器和存储单元\"></a>任务一：设置寄存器和存储单元</h3><p>通过DEBUG命令对寄存器和存储单元进行设置，使其满足以下条件：</p>\n<table>\n<thead>\n<tr>\n<th>寄存器&#x2F;存储地址</th>\n<th>值</th>\n</tr>\n</thead>\n<tbody><tr>\n<td>(DS)</td>\n<td>2000H</td>\n</tr>\n<tr>\n<td>(BX)</td>\n<td>0100H</td>\n</tr>\n<tr>\n<td>(SI)</td>\n<td>0002H</td>\n</tr>\n<tr>\n<td>(BP)</td>\n<td>0200H</td>\n</tr>\n<tr>\n<td>(SS)</td>\n<td>2300H</td>\n</tr>\n<tr>\n<td>(20100)</td>\n<td>12H</td>\n</tr>\n<tr>\n<td>(20101)</td>\n<td>34H</td>\n</tr>\n<tr>\n<td>(20102)</td>\n<td>56H</td>\n</tr>\n<tr>\n<td>(20103)</td>\n<td>78H</td>\n</tr>\n<tr>\n<td>(21200)</td>\n<td>2AH</td>\n</tr>\n<tr>\n<td>(21201)</td>\n<td>4CH</td>\n</tr>\n<tr>\n<td>(21202)</td>\n<td>B7H</td>\n</tr>\n<tr>\n<td>(21203)</td>\n<td>65H</td>\n</tr>\n<tr>\n<td>(23204)</td>\n<td>88H</td>\n</tr>\n<tr>\n<td>(23205)</td>\n<td>99H</td>\n</tr>\n</tbody></table>\n<h3 id=\"任务二：执行指令并观察结果\"><a href=\"#任务二：执行指令并观察结果\" class=\"headerlink\" title=\"任务二：执行指令并观察结果\"></a>任务二：执行指令并观察结果</h3><p>分别输入下列指令，并单步执行(T)，观察执行结果并截图。说明每条指令执行完成后AX寄存器的内容。</p>\n<h4 id=\"1-MOV-AX-1200H\"><a href=\"#1-MOV-AX-1200H\" class=\"headerlink\" title=\"(1) MOV AX, 1200H\"></a>(1) MOV AX, 1200H</h4><p><strong>源操作数为立即寻址方式</strong></p>\n<ul>\n<li>(AX) &#x3D; 1200H</li>\n</ul>\n<p><strong>t &#x3D; 0</strong></p>\n<ul>\n<li>AX &#x3D; 1200H</li>\n<li>BX &#x3D; 0100H</li>\n<li>CX &#x3D; 0009H</li>\n<li>DX &#x3D; 0000H</li>\n<li>SP &#x3D; 0000H</li>\n<li>BP &#x3D; 0200H</li>\n<li>SI &#x3D; 0002H</li>\n<li>DI &#x3D; 0000H</li>\n<li>DS &#x3D; 2000H</li>\n<li>ES &#x3D; 0760H</li>\n<li>SS &#x3D; 2300H</li>\n<li>CS &#x3D; 0770H</li>\n<li>IP &#x3D; 0003H</li>\n<li>标志位：NU UP EI PL NZ NA PO NC</li>\n</ul>\n<p><img src=\"https://tk-pichost-1325224430.cos.ap-chengdu.myqcloud.com/blog/17444568124471744456812290.png\" alt=\"17444568124471744456812290.png\"></p>\n<h4 id=\"2-MOV-AX-BX\"><a href=\"#2-MOV-AX-BX\" class=\"headerlink\" title=\"(2) MOV AX, BX\"></a>(2) MOV AX, BX</h4><p><strong>源操作数为寄存器寻址方式</strong></p>\n<ul>\n<li>(BX) &#x3D; 0100H</li>\n</ul>\n<p><img src=\"https://tk-pichost-1325224430.cos.ap-chengdu.myqcloud.com/blog/17444568464441744456846383.png\" alt=\"17444568464441744456846383.png\"><br><img src=\"https://tk-pichost-1325224430.cos.ap-chengdu.myqcloud.com/blog/17444568554431744456855020.png\" alt=\"17444568554431744456855020.png\"></p>\n<h4 id=\"3-MOV-AX-1200H\"><a href=\"#3-MOV-AX-1200H\" class=\"headerlink\" title=\"(3) MOV AX, [1200H]\"></a>(3) MOV AX, [1200H]</h4><p><strong>源操作数为直接寻址方式</strong></p>\n<ul>\n<li>([1200H]) &#x3D; (21200H) &#x3D; 4C2AH</li>\n</ul>\n<h4 id=\"4-MOV-AX-BX\"><a href=\"#4-MOV-AX-BX\" class=\"headerlink\" title=\"(4) MOV AX, [BX]\"></a>(4) MOV AX, [BX]</h4><p><strong>源操作数为寄存器间接寻址方式</strong></p>\n<ul>\n<li>([BX]) &#x3D; (20100H) &#x3D; 1234H</li>\n</ul>\n<p><img src=\"https://tk-pichost-1325224430.cos.ap-chengdu.myqcloud.com/blog/17444568624421744456862198.png\" alt=\"17444568624421744456862198.png\"><br><img src=\"https://tk-pichost-1325224430.cos.ap-chengdu.myqcloud.com/blog/17444568884441744456887465.png\" alt=\"17444568884441744456887465.png\"></p>\n<h4 id=\"5-MOV-AX-1100-BX\"><a href=\"#5-MOV-AX-1100-BX\" class=\"headerlink\" title=\"(5) MOV AX, 1100[BX]\"></a>(5) MOV AX, 1100[BX]</h4><p><strong>源操作数为基址变址加偏移地址寻址方式</strong></p>\n<ul>\n<li>(1100[BX]) &#x3D; (21202H) &#x3D; 65B7H</li>\n</ul>\n<p><img src=\"https://tk-pichost-1325224430.cos.ap-chengdu.myqcloud.com/blog/17444569014431744456901288.png\" alt=\"17444569014431744456901288.png\"></p>\n<h4 id=\"6-MOV-AX-BX-SI\"><a href=\"#6-MOV-AX-BX-SI\" class=\"headerlink\" title=\"(6) MOV AX, [BX][SI]\"></a>(6) MOV AX, [BX][SI]</h4><p><strong>源操作数为基址变址加偏移地址寻址方式</strong></p>\n<ul>\n<li>([BX][SI]) &#x3D; (20102H) &#x3D; 56H78H</li>\n</ul>\n<p>AX &#x3D; 7856H<br>BX &#x3D; 0100H<br>CX &#x3D; 0009H<br>DX &#x3D; 0000H<br>SP &#x3D; 0000H<br>BP &#x3D; 0200H<br>SI &#x3D; 0002H<br>DI &#x3D; 0000H<br>DS &#x3D; 2000H<br>ES &#x3D; 0760H<br>SS &#x3D; 2300H<br>CS &#x3D; 0770H<br>IP &#x3D; 0010H<br>标志位：NU UP EI PL NZ NA PO NC</p>\n<h4 id=\"7-MOV-AX-1100-BX-SI\"><a href=\"#7-MOV-AX-1100-BX-SI\" class=\"headerlink\" title=\"(7) MOV AX, 1100[BX][SI]\"></a>(7) MOV AX, 1100[BX][SI]</h4><p><strong>源操作数为基址变址加偏移地址寻址方式</strong></p>\n<ul>\n<li>(1100[BX][SI]) &#x3D; (21202H) &#x3D; 65B7H</li>\n</ul>\n<p><img src=\"https://tk-pichost-1325224430.cos.ap-chengdu.myqcloud.com/blog/17444569444441744456943836.png\" alt=\"17444569444441744456943836.png\"><br><img src=\"https://tk-pichost-1325224430.cos.ap-chengdu.myqcloud.com/blog/17444569624431744456961758.png\" alt=\"17444569624431744456961758.png\"></p>\n<h4 id=\"8-MOV-AX-BP-SI-04\"><a href=\"#8-MOV-AX-BP-SI-04\" class=\"headerlink\" title=\"(8) MOV AX, [BP+SI+04]\"></a>(8) MOV AX, [BP+SI+04]</h4><p><strong>源操作数为基址变址加偏移地址寻址方式</strong></p>\n<ul>\n<li>([BP+SI+04]) &#x3D; (20104H) &#x3D; 0000H</li>\n</ul>\n<p><img src=\"https://tk-pichost-1325224430.cos.ap-chengdu.myqcloud.com/blog/17444569764471744456975814.png\" alt=\"17444569764471744456975814.png\"></p>\n<h2 id=\"实验报告\"><a href=\"#实验报告\" class=\"headerlink\" title=\"实验报告\"></a>实验报告</h2><h3 id=\"总结操作步骤及各种寻址方式，记录调试结果。\"><a href=\"#总结操作步骤及各种寻址方式，记录调试结果。\" class=\"headerlink\" title=\"总结操作步骤及各种寻址方式，记录调试结果。\"></a>总结操作步骤及各种寻址方式，记录调试结果。</h3><h3 id=\"任务一运行结果\"><a href=\"#任务一运行结果\" class=\"headerlink\" title=\"任务一运行结果\"></a>任务一运行结果</h3><p>使用<code>r+</code>命令给寄存器赋值：</p>\n<ul>\n<li><img src=\"https://tk-pichost-1325224430.cos.ap-chengdu.myqcloud.com/blog/17444569874441744456987333.png\" alt=\"17444569874441744456987333.png\"></li>\n</ul>\n<p>使用<code>f</code>命令给20100到20103赋值：</p>\n<ul>\n<li><img src=\"https://tk-pichost-1325224430.cos.ap-chengdu.myqcloud.com/blog/17444570054451744457004736.png\" alt=\"17444570054451744457004736.png\"></li>\n</ul>\n<p>使用<code>f</code>命令给21200到21203赋值：</p>\n<ul>\n<li><img src=\"https://tk-pichost-1325224430.cos.ap-chengdu.myqcloud.com/blog/17444570193821744457017476.png\" alt=\"17444570193821744457017476.png\"></li>\n</ul>\n<p>使用<code>f</code>命令给23204到23205赋值：</p>\n<ul>\n<li>![未提供具体图片链接，请自行补充]</li>\n</ul>\n<h3 id=\"任务二\"><a href=\"#任务二\" class=\"headerlink\" title=\"任务二\"></a>任务二</h3><p>使用<code>a</code>命令给代码段添加汇编代码，并使用<code>u</code>命令反汇编代码以检查其正确性。</p>\n<ul>\n<li><img src=\"https://tk-pichost-1325224430.cos.ap-chengdu.myqcloud.com/blog/17444570314451744457031389.png\" alt=\"17444570314451744457031389.png\"></li>\n</ul>\n<p>使用<code>t</code>命令单步运行指令：</p>\n<ul>\n<li><img src=\"https://tk-pichost-1325224430.cos.ap-chengdu.myqcloud.com/blog/17444570454481744457044523.png\" alt=\"17444570454481744457044523.png\"></li>\n</ul>\n","excerpt":"","more":"<h1 id=\"2025-04-10-汇编实验1：利用DEBUG熟悉常用指令的使用\"><a href=\"#2025-04-10-汇编实验1：利用DEBUG熟悉常用指令的使用\" class=\"headerlink\" title=\"2025-04-10 汇编实验1：利用DEBUG熟悉常用指令的使用\"></a>2025-04-10 汇编实验1：利用DEBUG熟悉常用指令的使用</h1><h2 id=\"实验目的\"><a href=\"#实验目的\" class=\"headerlink\" title=\"实验目的\"></a>实验目的</h2><p>熟悉DEBUG中的常用调试命令（如R、D、E、T、A、G、P等），通过实验加深对各种寻址方式的理解；能够熟练使用DEBUG中的命令对指令进行反汇编，观察并了解机器代码。</p>\n<h2 id=\"实验题\"><a href=\"#实验题\" class=\"headerlink\" title=\"实验题\"></a>实验题</h2><h3 id=\"任务一：设置寄存器和存储单元\"><a href=\"#任务一：设置寄存器和存储单元\" class=\"headerlink\" title=\"任务一：设置寄存器和存储单元\"></a>任务一：设置寄存器和存储单元</h3><p>通过DEBUG命令对寄存器和存储单元进行设置，使其满足以下条件：</p>\n<table>\n<thead>\n<tr>\n<th>寄存器&#x2F;存储地址</th>\n<th>值</th>\n</tr>\n</thead>\n<tbody><tr>\n<td>(DS)</td>\n<td>2000H</td>\n</tr>\n<tr>\n<td>(BX)</td>\n<td>0100H</td>\n</tr>\n<tr>\n<td>(SI)</td>\n<td>0002H</td>\n</tr>\n<tr>\n<td>(BP)</td>\n<td>0200H</td>\n</tr>\n<tr>\n<td>(SS)</td>\n<td>2300H</td>\n</tr>\n<tr>\n<td>(20100)</td>\n<td>12H</td>\n</tr>\n<tr>\n<td>(20101)</td>\n<td>34H</td>\n</tr>\n<tr>\n<td>(20102)</td>\n<td>56H</td>\n</tr>\n<tr>\n<td>(20103)</td>\n<td>78H</td>\n</tr>\n<tr>\n<td>(21200)</td>\n<td>2AH</td>\n</tr>\n<tr>\n<td>(21201)</td>\n<td>4CH</td>\n</tr>\n<tr>\n<td>(21202)</td>\n<td>B7H</td>\n</tr>\n<tr>\n<td>(21203)</td>\n<td>65H</td>\n</tr>\n<tr>\n<td>(23204)</td>\n<td>88H</td>\n</tr>\n<tr>\n<td>(23205)</td>\n<td>99H</td>\n</tr>\n</tbody></table>\n<h3 id=\"任务二：执行指令并观察结果\"><a href=\"#任务二：执行指令并观察结果\" class=\"headerlink\" title=\"任务二：执行指令并观察结果\"></a>任务二：执行指令并观察结果</h3><p>分别输入下列指令，并单步执行(T)，观察执行结果并截图。说明每条指令执行完成后AX寄存器的内容。</p>\n<h4 id=\"1-MOV-AX-1200H\"><a href=\"#1-MOV-AX-1200H\" class=\"headerlink\" title=\"(1) MOV AX, 1200H\"></a>(1) MOV AX, 1200H</h4><p><strong>源操作数为立即寻址方式</strong></p>\n<ul>\n<li>(AX) &#x3D; 1200H</li>\n</ul>\n<p><strong>t &#x3D; 0</strong></p>\n<ul>\n<li>AX &#x3D; 1200H</li>\n<li>BX &#x3D; 0100H</li>\n<li>CX &#x3D; 0009H</li>\n<li>DX &#x3D; 0000H</li>\n<li>SP &#x3D; 0000H</li>\n<li>BP &#x3D; 0200H</li>\n<li>SI &#x3D; 0002H</li>\n<li>DI &#x3D; 0000H</li>\n<li>DS &#x3D; 2000H</li>\n<li>ES &#x3D; 0760H</li>\n<li>SS &#x3D; 2300H</li>\n<li>CS &#x3D; 0770H</li>\n<li>IP &#x3D; 0003H</li>\n<li>标志位：NU UP EI PL NZ NA PO NC</li>\n</ul>\n<p><img src=\"https://tk-pichost-1325224430.cos.ap-chengdu.myqcloud.com/blog/17444568124471744456812290.png\" alt=\"17444568124471744456812290.png\"></p>\n<h4 id=\"2-MOV-AX-BX\"><a href=\"#2-MOV-AX-BX\" class=\"headerlink\" title=\"(2) MOV AX, BX\"></a>(2) MOV AX, BX</h4><p><strong>源操作数为寄存器寻址方式</strong></p>\n<ul>\n<li>(BX) &#x3D; 0100H</li>\n</ul>\n<p><img src=\"https://tk-pichost-1325224430.cos.ap-chengdu.myqcloud.com/blog/17444568464441744456846383.png\" alt=\"17444568464441744456846383.png\"><br><img src=\"https://tk-pichost-1325224430.cos.ap-chengdu.myqcloud.com/blog/17444568554431744456855020.png\" alt=\"17444568554431744456855020.png\"></p>\n<h4 id=\"3-MOV-AX-1200H\"><a href=\"#3-MOV-AX-1200H\" class=\"headerlink\" title=\"(3) MOV AX, [1200H]\"></a>(3) MOV AX, [1200H]</h4><p><strong>源操作数为直接寻址方式</strong></p>\n<ul>\n<li>([1200H]) &#x3D; (21200H) &#x3D; 4C2AH</li>\n</ul>\n<h4 id=\"4-MOV-AX-BX\"><a href=\"#4-MOV-AX-BX\" class=\"headerlink\" title=\"(4) MOV AX, [BX]\"></a>(4) MOV AX, [BX]</h4><p><strong>源操作数为寄存器间接寻址方式</strong></p>\n<ul>\n<li>([BX]) &#x3D; (20100H) &#x3D; 1234H</li>\n</ul>\n<p><img src=\"https://tk-pichost-1325224430.cos.ap-chengdu.myqcloud.com/blog/17444568624421744456862198.png\" alt=\"17444568624421744456862198.png\"><br><img src=\"https://tk-pichost-1325224430.cos.ap-chengdu.myqcloud.com/blog/17444568884441744456887465.png\" alt=\"17444568884441744456887465.png\"></p>\n<h4 id=\"5-MOV-AX-1100-BX\"><a href=\"#5-MOV-AX-1100-BX\" class=\"headerlink\" title=\"(5) MOV AX, 1100[BX]\"></a>(5) MOV AX, 1100[BX]</h4><p><strong>源操作数为基址变址加偏移地址寻址方式</strong></p>\n<ul>\n<li>(1100[BX]) &#x3D; (21202H) &#x3D; 65B7H</li>\n</ul>\n<p><img src=\"https://tk-pichost-1325224430.cos.ap-chengdu.myqcloud.com/blog/17444569014431744456901288.png\" alt=\"17444569014431744456901288.png\"></p>\n<h4 id=\"6-MOV-AX-BX-SI\"><a href=\"#6-MOV-AX-BX-SI\" class=\"headerlink\" title=\"(6) MOV AX, [BX][SI]\"></a>(6) MOV AX, [BX][SI]</h4><p><strong>源操作数为基址变址加偏移地址寻址方式</strong></p>\n<ul>\n<li>([BX][SI]) &#x3D; (20102H) &#x3D; 56H78H</li>\n</ul>\n<p>AX &#x3D; 7856H<br>BX &#x3D; 0100H<br>CX &#x3D; 0009H<br>DX &#x3D; 0000H<br>SP &#x3D; 0000H<br>BP &#x3D; 0200H<br>SI &#x3D; 0002H<br>DI &#x3D; 0000H<br>DS &#x3D; 2000H<br>ES &#x3D; 0760H<br>SS &#x3D; 2300H<br>CS &#x3D; 0770H<br>IP &#x3D; 0010H<br>标志位：NU UP EI PL NZ NA PO NC</p>\n<h4 id=\"7-MOV-AX-1100-BX-SI\"><a href=\"#7-MOV-AX-1100-BX-SI\" class=\"headerlink\" title=\"(7) MOV AX, 1100[BX][SI]\"></a>(7) MOV AX, 1100[BX][SI]</h4><p><strong>源操作数为基址变址加偏移地址寻址方式</strong></p>\n<ul>\n<li>(1100[BX][SI]) &#x3D; (21202H) &#x3D; 65B7H</li>\n</ul>\n<p><img src=\"https://tk-pichost-1325224430.cos.ap-chengdu.myqcloud.com/blog/17444569444441744456943836.png\" alt=\"17444569444441744456943836.png\"><br><img src=\"https://tk-pichost-1325224430.cos.ap-chengdu.myqcloud.com/blog/17444569624431744456961758.png\" alt=\"17444569624431744456961758.png\"></p>\n<h4 id=\"8-MOV-AX-BP-SI-04\"><a href=\"#8-MOV-AX-BP-SI-04\" class=\"headerlink\" title=\"(8) MOV AX, [BP+SI+04]\"></a>(8) MOV AX, [BP+SI+04]</h4><p><strong>源操作数为基址变址加偏移地址寻址方式</strong></p>\n<ul>\n<li>([BP+SI+04]) &#x3D; (20104H) &#x3D; 0000H</li>\n</ul>\n<p><img src=\"https://tk-pichost-1325224430.cos.ap-chengdu.myqcloud.com/blog/17444569764471744456975814.png\" alt=\"17444569764471744456975814.png\"></p>\n<h2 id=\"实验报告\"><a href=\"#实验报告\" class=\"headerlink\" title=\"实验报告\"></a>实验报告</h2><h3 id=\"总结操作步骤及各种寻址方式，记录调试结果。\"><a href=\"#总结操作步骤及各种寻址方式，记录调试结果。\" class=\"headerlink\" title=\"总结操作步骤及各种寻址方式，记录调试结果。\"></a>总结操作步骤及各种寻址方式，记录调试结果。</h3><h3 id=\"任务一运行结果\"><a href=\"#任务一运行结果\" class=\"headerlink\" title=\"任务一运行结果\"></a>任务一运行结果</h3><p>使用<code>r+</code>命令给寄存器赋值：</p>\n<ul>\n<li><img src=\"https://tk-pichost-1325224430.cos.ap-chengdu.myqcloud.com/blog/17444569874441744456987333.png\" alt=\"17444569874441744456987333.png\"></li>\n</ul>\n<p>使用<code>f</code>命令给20100到20103赋值：</p>\n<ul>\n<li><img src=\"https://tk-pichost-1325224430.cos.ap-chengdu.myqcloud.com/blog/17444570054451744457004736.png\" alt=\"17444570054451744457004736.png\"></li>\n</ul>\n<p>使用<code>f</code>命令给21200到21203赋值：</p>\n<ul>\n<li><img src=\"https://tk-pichost-1325224430.cos.ap-chengdu.myqcloud.com/blog/17444570193821744457017476.png\" alt=\"17444570193821744457017476.png\"></li>\n</ul>\n<p>使用<code>f</code>命令给23204到23205赋值：</p>\n<ul>\n<li>![未提供具体图片链接，请自行补充]</li>\n</ul>\n<h3 id=\"任务二\"><a href=\"#任务二\" class=\"headerlink\" title=\"任务二\"></a>任务二</h3><p>使用<code>a</code>命令给代码段添加汇编代码，并使用<code>u</code>命令反汇编代码以检查其正确性。</p>\n<ul>\n<li><img src=\"https://tk-pichost-1325224430.cos.ap-chengdu.myqcloud.com/blog/17444570314451744457031389.png\" alt=\"17444570314451744457031389.png\"></li>\n</ul>\n<p>使用<code>t</code>命令单步运行指令：</p>\n<ul>\n<li><img src=\"https://tk-pichost-1325224430.cos.ap-chengdu.myqcloud.com/blog/17444570454481744457044523.png\" alt=\"17444570454481744457044523.png\"></li>\n</ul>\n"},{"title":"2025-04-28-堆、栈及其应用分析","date":"2025-04-27T16:00:00.000Z","_content":"# 堆、栈及其应用分析\n\n# 参考资料\n\n> - [栈结构解析及其应用 - 乌漆 WhiteMoon - 博客园](https://www.cnblogs.com/linfangnan/p/12450061.html)\n> - [堆栈信息分析 - moonandstar08 - 博客园](https://www.cnblogs.com/moonandstar08/p/4934597.html)\n> - [什么是堆?什么是栈?他们之间有什么区别和联系? - tolin - 博客园](https://www.cnblogs.com/tolin/p/14982094.html)\n\n# 堆 (Heap) 与 栈 (Stack) 概述\n\n- **栈（Stack）**\n- **数据结构视角**：一种受限的线性结构，只能在同一端（栈顶）进行插入（Push）和删除（Pop），遵循 “后进先出”（LIFO）原则。\n- **内存视角**：栈区由操作系统自动分配与回收，用于存储函数调用时的局部变量、函数参数、返回地址等信息。栈空间连续，访问和分配速度极快，但容量有限（通常几 MB），每个线程都有独立栈空间。\n- **堆（Heap）**\n\n  - **数据结构视角**：一种近似完全二叉树的优先队列结构（最大堆或最小堆），常用于按优先级提取元素。\n  - **内存视角**：堆区用于动态分配内存，程序运行时可调用 `new`/`malloc`（C++）或由运行时自动分配（Python）来获取；释放时需 `delete`/`free` 或由垃圾回收负责。堆空间大但分配、释放开销较大，可能产生内存碎片。\n\n## 数据结构视角\n\n**栈**：一种线性受限结构，只允许在栈顶进行插入（Push）和删除（Pop），遵循“后进先出”（LIFO）原则。常用操作包括 `push`（进栈）、`pop`（出栈）、`top`（取栈顶）等，这些操作时间复杂度通常为 O(1)。栈可用数组（顺序栈）或链表（链式栈）实现，适用于函数调用、递归计算、撤销操作等场景。\n\n> - [栈 - OI Wiki](https://oi-wiki.org/ds/stack/)\n\n### 使用数组模拟栈\n\n```cpp\nint st[N];\n// 这里使用 st[0] (即 *st) 代表栈中元素数量，同时也是栈顶下标\n\n// 压栈 ：\nst[++*st] = var1;\n// 取栈顶 ：\nint u = st[*st];\n// 弹栈 ：注意越界问题, *st == 0 时不能继续弹出\nif (*st) --*st;\n// 清空栈\n*st = 0;\n```\n\n### C++ STL 中的栈\n\nC++ 中的 STL 也提供了一个容器 `std::stack`，使用前需要引入 `stack` 头文件。\n\nSTL 中的 `stack` 容器提供了一众成员函数以供调用，其中较为常用的有：\n\n- 元素访问\n\n  - `st.top()` 返回栈顶\n- 修改\n\n  - `st.push()` 插入传入的参数到栈顶\n  - `st.pop()` 弹出栈顶\n- 容量\n\n  - `st.empty()` 返回是否为空\n  - `st.size()` 返回元素数量\n\n此外，`std::stack` 还提供了一些运算符。较为常用的是使用赋值运算符 `=` 为 `stack` 赋值，示例：\n\n```cpp\n// 新建两个栈 st1 和 st2\nstd::stack<int> st1, st2;\n\n// 为 st1 装入 1\nst1.push(1);\n\n// 将 st1 赋值给 st2\nst2 = st1;\n\n// 输出 st2 的栈顶元素\ncout << st2.top() << endl;\n// 输出: 1\n```\n\n### 使用 Python 中的 list 模拟栈\n\n```python\nst = [5, 1, 4]\n\n# 使用 append() 向栈顶添加元素\nst.append(2)\nst.append(3)\n# >>> st\n# [5, 1, 4, 2, 3]\n\n# 使用 pop 取出栈顶元素\nst.pop()\n# >>> st\n# [5, 1, 4, 2]\n\n# 使用 clear 清空栈\nst.clear()\n```\n\n**堆**（优先队列）: 一种树形结构，即满足堆序性的完全二叉树。每个节点的值都不大于（或不小于）其父节点的值，根节点是最大值（大顶堆）或最小值（小顶堆）。常见操作包括：上浮（shift_up）、下沉（shift_down）、插入（push）和弹出（pop）堆顶元素，以及查询堆顶（top）。堆常用作优先队列，在任务调度、Dijkstra 最短路径、Top-K 计算等场景中非常常见。\n\n> - [堆简介 - OI Wiki](https://oi-wiki.org/ds/heap/)\n\n堆是一棵树，其每个节点都有一个键值，且每个节点的键值都大于等于/小于等于其父亲的键值。\n\n每个节点的键值都大于等于其父亲键值的堆叫做小根堆，否则叫做大根堆。STL 中的 priority_queue 其实就是一个大根堆。\n\n（小根）堆主要支持的操作有：插入一个数、查询最小值、删除最小值、合并两个堆、减小一个元素的值。\n\n一些功能强大的堆（可并堆）还能（高效地）支持 merge 等操作。\n\n一些功能更强大的堆还支持可持久化，也就是对任意历史版本进行查询或者操作，产生新的版本。\n\n### **C++ 堆/优先队列**：默认大顶堆（`priority_queue`）：\n\n```cpp\nstd::priority_queue<int> pq;\npq.push(5);\npq.push(3);\nint top = pq.top(); // 5 (最大值)\npq.pop();\n```\n\n### **Python 堆**（`heapq` 最小堆）：\n\n```python\nimport heapq\nheap = []\nheapq.heappush(heap, 3)\nheapq.heappush(heap, 5)\ntop = heapq.heappop(heap)  # 3 (最小值)\n```\n\n- 如果需要大顶堆，可插入负值或使用第三方实现。\n\n### 堆排序\n\n> [Brute Force Heapsort](https://algorithm-visualizer.org/brute-force/heapsort)\n\n堆排序是一种高效的、基于比较的排序算法。它利用了堆这种数据结构的特性。基本思想是：\n\n1. **建堆 (Heapify)**：将待排序的序列构建成一个大顶堆（或小顶堆）。此时，堆顶元素就是整个序列的最大值（或最小值）。\n2. **排序 (Sort)**：\n\n   - 将堆顶元素与序列末尾的元素交换。\n   - 此时，序列末尾的元素即为最大（或最小）值，已经处于正确排序位置。\n   - 将剩余的 n-1 个元素重新调整为一个堆。\n   - 重复此过程，直到所有元素都排序完毕。\n\n堆排序的平均时间复杂度和最坏时间复杂度都是 O(nlogn)。\n\n#### C++ 实现堆排序\n\n在 C++ 中，可以利用标准库 `<algorithm>` 中提供的堆操作函数来方便地实现堆排序。\n\n- `std::make_heap(first, last)`: 将指定范围 `[first, last)` 内的元素重新排列，使其成为一个大顶堆。\n- `std::sort_heap(first, last)`: 将一个已经建好的堆 `[first, last)` 进行排序。它会重复地将堆顶元素（最大值）移动到序列的末尾，并重新调整剩余部分为堆。\n\nC++\n\n```cpp\n#include <iostream>\n#include <vector>\n#include <algorithm> // 包含 make_heap, sort_heap\n\nvoid print_vector(const std::vector<int>& vec) {\n    for (int val : vec) {\n        std::cout << val << \" \";\n    }\n    std::cout << std::endl;\n}\n\nint main() {\n    std::vector<int> v = {3, 5, 1, 8, 4, 7, 2};\n    std::cout << \"Original vector: \";\n    print_vector(v);\n\n    // 1. 将 vector 转换成大顶堆\n    std::make_heap(v.begin(), v.end());\n    std::cout << \"After make_heap (top is max): \" << v.front() << std::endl;\n  \n    // 2. 对堆进行排序 (结果为升序)\n    std::sort_heap(v.begin(), v.end());\n  \n    std::cout << \"Sorted vector: \";\n    print_vector(v); // 输出: 1 2 3 4 5 7 8\n\n    return 0;\n}\n```\n\n#### Python 实现堆排序\n\nPython 的 `heapq` 模块本身不直接提供一个完整的 `heapsort` 函数，但我们可以很容易地利用其 `heappush` 和 `heappop` 来实现。因为 `heapq` 是最小堆，所以 `heappop` 总是弹出最小值，天然适合用于升序排序。\n\n```python\nimport heapq\n\ndef heapsort_asc(iterable):\n    \"\"\"\n    使用 heapq 实现升序排序\n    \"\"\"\n    h = []\n    # 将所有元素压入堆中\n    for value in iterable:\n        heapq.heappush(h, value)\n    # 依次弹出堆中最小的元素，构成有序列表\n    return [heapq.heappop(h) for _ in range(len(h))]\n\ndata = [3, 5, 1, 8, 4, 7, 2]\nprint(f\"Original list: {data}\")\n\nsorted_data = heapsort_asc(data)\nprint(f\"Sorted list (ascending): {sorted_data}\") # 输出: [1, 2, 3, 4, 5, 7, 8]\n\n# 原地堆排序 (In-place Heap Sort)\n# 这更接近于堆排序的经典实现\ndef heapsort_inplace(arr):\n    n = len(arr)\n    # 1. 构建大顶堆 (从最后一个非叶子节点开始)\n    # 注意：heapq 是最小堆，所以这里通过对负数操作来模拟大顶堆\n    # 或者我们手动实现大顶堆的 sift_down\n    # 为了简单，我们还是用 heapq 来理解，但传统实现更高效\n    h = []\n    for x in arr:\n        heapq.heappush(h, x)\n    arr[:] = [heapq.heappop(h) for _ in range(n)]\n    return arr\n\ndata_inplace = [3, 5, 1, 8, 4, 7, 2]\nheapsort_inplace(data_inplace)\nprint(f\"In-place sorted list: {data_inplace}\")\n```\n\n栈和堆（优先队列）各有特点：\n\n- **数据组织**：栈是线性的、受限的结构，只能从一端操作；堆是树形结构，可快速获取最大或最小元素。\n- **访问效率**：栈操作简单开销小；堆插入/删除需维护堆序（O(log n)）。\n- **应用场景**：栈适合管理临时状态（如函数调用栈、表达式求值、撤销操作）；堆（优先队列）适合按优先级处理元素，如操作系统任务调度、网络请求优先级、算法中的最佳-优先搜索等。\n\n## 内存分配视角\n\n在程序运行时，内存通常分为**代码区**、**数据区**、**堆区**和**栈区**。其中：\n\n- **栈区**：由系统自动管理，随函数调用而增长，每次函数调用时分配空间给局部变量、函数参数和返回地址。函数返回时，这些空间自动回收。栈分配速度快、开销低，但空间有限（常见几 MB），且每个线程都有独立的栈空间。如果栈空间不足，会导致栈溢出错误。\n- **堆区**：用于动态内存分配，程序员（或运行时）在运行时使用 `new`/`malloc` 等申请内存，由程序员 `delete`/`free` 释放（在 Python/Java 等语言由垃圾回收自动释放）。堆的可用空间远大于栈，存放**动态对象**。堆内存碎片化的风险更高：频繁的分配和释放可能将大块连续内存切割成许多小碎片，降低利用率。\n- **静态/全局区**：编译时分配，程序运行前即确定，存放全局变量、静态变量和常量，在程序整个生命周期存在。\n\n**分配方式**：栈的分配和回收速度极快，操作由 CPU 指令自动完成；堆的分配开销较大，一般需要额外的内存管理算法（如自由链表或分代收集），在 C++ 中需要程序员手动释放。Python 中所有对象都分配在堆上，解释器通过引用计数和垃圾回收来管理。\n\n**访问效率**：由于栈内存连续、分配固定，因此访问和分配速度更高。堆内存由多个块组成，需额外指针管理，因而略慢于栈访问。此外，栈是线程私有的（线程安全），而堆是所有线程共享的（需注意并发安全）。\n\n- **C++ 栈 vs 堆 分配**：\n\n```cpp\nvoid func() {\n    int a = 10;            // 分配在栈上\n    int *p = new int(20);  // 分配在堆上\n    // ...\n    delete p;              // 手动释放堆内存\n} // 函数返回时，a 的栈空间自动释放，若忘了 delete，则 p 指向的内存泄露\n```\n\n- **Python 对象分配**：\n\n```python\ndef func():\n    a = 10             # 10 是整数对象，存储在堆中；a 是栈帧内的局部引用\n    b = [1, 2, 3]      # 列表对象在堆上分配\n    # 变量 a, b 是存放在函数调用栈帧中的引用，当函数结束，这些引用消失\n```\n\n- Python 不需要显示释放内存，垃圾回收自动回收无用对象。\n\n## 典型应用场景\n\n### 函数调用与返回\n\n当程序调用一个函数时，当前上下文（包括当前函数的局部变量、返回地址、CPU 寄存器等）会被“压栈（push）”到栈上；函数执行完成后，栈顶信息被“弹栈（pop）”，程序自动返回调用点并恢复先前状态。这种机制正是栈的典型应用。\n\n#### C++ 示例\n\n```cpp\n#include <iostream>\n// 一个示例函数，用于演示栈帧形成\nint factorial(int n) {\n    if (n <= 1) {\n        return 1;\n    }\n    // 调用 factorial(n-1) 前，会把当前的 n、返回地址等信息压入栈\n    return n * factorial(n - 1);\n}\nint main() {\n    int x = 5;\n    std::cout << \"factorial(\" << x << \") = \" << factorial(x) << std::endl;\n    return 0;\n}\n```\n\n- 每次调用 `factorial` 时，当前函数的局部变量（如 `n`）和返回地址会压入栈；函数结束时，栈帧被弹出，返回到上一级调用点。\n\n#### Python 示例\n\n```python\ndef factorial(n):\n    if n <= 1:\n        return 1\n    # 递归调用时，Python 会将当前函数帧压入调用栈\n    return n * factorial(n - 1)\nif \nname\n == \"\n__main__\n\":\n    x = 5\n    print(f\"factorial({x}) =\", factorial(x))\n```\n\n- Python 解释器内部也维护一个“调用栈”，每个函数调用都会在栈中创建一个帧（Frame），存放局部变量和执行状态。\n\n---\n\n### 内存管理（局部变量与函数参数）\n\n#### 说明\n\n- **栈分配**：编译器在编译期或运行期自动为每个函数分配固定的栈空间，用于存储局部变量和函数参数。函数结束时，这些空间会自动释放，无需程序员手动管理。\n- **堆分配**：程序员可在运行时动态向操作系统请求内存，使用 `new`/`malloc`（C++）或创建对象（Python）。这些内存由程序员负责释放（或由垃圾回收器回收）。\n\n#### C++ 示例：栈 vs 堆\n\n```cpp\n#include <iostream>\nvoid stackExample() {\n    int a = 10;             // 分配在栈上\n    int b[100];             // 数组也分配在栈上\n    std::cout << \"a = \" << a << std::endl;\n    std::cout << \"b[0] = \" << b[0] << std::endl;\n} // 函数结束时，a 和 b 的栈空间自动释放\nvoid heapExample() {\n    int *p = new int(20);   // 在堆上分配一个 int\n    int *arr = new int[100];// 在堆上分配一个大小为 100 的数组\n    std::cout << \"*p = \" << *p << std::endl;\n    std::cout << \"arr[0] = \" << arr[0] << std::endl;\n    delete p;               // 释放堆内存\n    delete[] arr;           // 释放数组\n}\nint main() {\n    stackExample();\n    heapExample();\n    return 0;\n}\n```\n\n- `stackExample`：变量 `a` 和数组 `b` 分配在栈上，由系统自动分配与回收。\n- `heapExample`：使用 `new` 在堆上分配内存，需要手动调用 `delete`/`delete[]` 来释放，否则会发生内存泄漏。\n\n#### Python 示例：对象分配在堆上\n\n```python\ndef memory_example():\n    a = 10            # 整数对象 10 存储在堆上，a 是栈帧中的一个引用\n    lst = [1, 2, 3]   # 列表对象存储在堆上，lst 引用保存在栈帧\n    print(a, lst)\nif \nname\n == \"\n__main__\n\":\n    memory_example()\n    # Python 通过引用计数和垃圾回收自动释放不再使用的对象\n```\n\n- 在 Python 中，所有对象都分配在堆上，局部变量仅是对这些对象的引用，保存在栈帧中。函数退出时，局部引用消失，引用计数可能降为 0，垃圾回收器会回收对象。\n\n---\n\n### 表达式求值（逆波兰表达式）\n\n#### 说明\n\n逆波兰表达式（后缀表达式）无需括号即可明确运算顺序，评估过程中需要一个栈来保存操作数、临时结果。\n\n- 遇到操作数时，压栈\n- 遇到运算符时，从栈中弹出相应数量的操作数进行计算，并将结果压回栈\n- 最后栈顶即为运算结果\n\n#### C++ 示例（仅支持 `+ - * /` 四则运算）\n\n```cpp\n#include <iostream>\n#include <stack>\n#include <sstream>\n#include <string>\n#include <vector>\n// 将字符串拆分为逆波兰表达式的 tokens\nstd::vector<std::string> tokenize(const std::string &expr) {\n    std::vector<std::string> tokens;\n    std::istringstream iss(expr);\n    std::string token;\n    while (iss >> token) {\n        tokens.push_back(token);\n    }\n    return tokens;\n}\nint evalRPN(const std::vector<std::string> &tokens) {\n    std::stack<int> st;\n    for (const auto &tk : tokens) {\n        if (tk == \"+\" || tk == \"-\" || tk == \"\n_\" || tk == \"/\") {\n            int b = st.top(); st.pop();\n            int a = st.top(); st.pop();\n            int res = 0;\n            if (tk == \"+\") res = a + b;\n            else if (tk == \"-\") res = a - b;\n_*            else if (tk == \"*\n\") res = a * b;\n            else if (tk == \"/\") res = a / b;\n            st.push(res);\n        } else {\n            st.push(std::stoi(tk));\n        }\n    }\n    return st.top();\n}\nint main() {\n    std::string expr = \"3 4 + 2 * 7 /\";\n    // 对应中缀: ((3 + 4) * 2) / 7 = 2\n    auto tokens = tokenize(expr);\n    std::cout << \"Result: \" << evalRPN(tokens) << std::endl;\n    return 0;\n}\n```\n\n- 将逆波兰表达式拆为 token 数组，遍历时用 `std::stack<int>` 存放操作数。每遇运算符，弹出两个操作数，计算后将结果压回栈。\n\n#### Python 示例\n\n```python\ndef eval_rpn(tokens):\n    stack = []\n    for tk in tokens:\n        if tk in {\"+\", \"-\", \"\n_\", \"/\"}:\n            b = stack.pop()\n            a = stack.pop()\n            if tk == \"+\":\n                stack.append(a + b)\n            elif tk == \"-\":\n                stack.append(a - b)\n_*            elif tk == \"*\n\":\n                stack.append(a * b)\n            else:\n                # 对于除法，需要注意 Python 的整除与 C++ 不同\n                stack.append(int(a / b))  # 向零取整\n        else:\n            stack.append(int(tk))\n    return stack.pop()\nif \nname\n == \"\n__main__\n\":\n    expr = \"3 4 + 2 * 7 /\".split()\n    print(\"Result:\", eval_rpn(expr))  # 2\n```\n\n- Python 用列表 `stack` 模拟栈，操作与 C++ 版本一致。\n\n---\n\n### 撤销（Undo）操作\n\n许多应用需要实现“撤销”功能，此时可将用户操作或状态快照依次压入栈，用户点击“撤销”时，再次从栈顶弹出即可恢复到上一次状态。\n\n#### Python 示例：文本编辑器简易撤销栈\n\n```python\nclass TextEditor:\n    def \n__init__\n(self):\n        self.text = \"\"\n        self.undo_stack = []  # 存放历史状态\n    def write(self, s):\n        # 在写新内容前，将当前状态压栈\n        self.undo_stack.append(self.text)\n        self.text += s\n    def undo(self):\n        if self.undo_stack:\n            self.text = self.undo_stack.pop()\n        else:\n            print(\"Nothing to undo\")\n    def show(self):\n        print(f\"Current Text: '{self.text}'\")\nif \nname\n == \"\n__main__\n\":\n    editor = TextEditor()\n    editor.write(\"Hello\")\n    editor.show()        # Hello\n    editor.write(\", World!\")\n    editor.show()        # Hello, World!\n    editor.undo()\n    editor.show()        # Hello\n    editor.undo()\n    editor.show()        # (空字符串)\n```\n\n- 每次写入之前，将 `self.text` 的旧值压入 `undo_stack`。调用 `undo()` 时，将栈顶字符串弹出并恢复。\n\n---\n\n### 浏览器后退功能\n\n浏览器维护一个“历史页面访问栈”：\n\n- 用户访问新页面时，将当前页面地址压入“后退栈”，同时清空“前进栈”\n- 点击“后退”时，将当前页面压入“前进栈”，并从“后退栈”弹出最近访问的页面\n- 点击“前进”时，则反向操作\n\n#### Python 示例：简易浏览器历史\n\n```python\nclass BrowserHistory:\n    def __init__(self, homepage: str):\n        self.back_stack = []     # 后退栈\n        self.forward_stack = []  # 前进栈\n        self.current = homepage  # 当前页面\n    def visit(self, url: str):\n        self.back_stack.append(self.current)\n        self.current = url\n        self.forward_stack.clear()  # 新访问清空前进历史\n    def back(self):\n        if self.back_stack:\n            self.forward_stack.append(self.current)\n            self.current = self.back_stack.pop()\n        else:\n            print(\"No pages to go back to\")\n    def forward(self):\n        if self.forward_stack:\n            self.back_stack.append(self.current)\n            self.current = self.forward_stack.pop()\n        else:\n            print(\"No pages to go forward to\")\n    def show(self):\n        print(f\"Back: {self.back_stack}, Current: {self.current}, Forward: {self.forward_stack}\")\nif name == \"__main__\":\n    browser = BrowserHistory(\"homepage.com\")\n    browser.show()\n    browser.visit(\"news.com\")\n    browser.show()\n    browser.visit(\"sports.com\")\n    browser.show()\n    browser.back()\n    browser.show()\n    browser.back()\n    browser.show()\n    browser.forward()\n    browser.show()\n```\n\n- 通过两个栈 (`back_stack` 和 `forward_stack`) 维护历史访问记录，实现后退和前进功能。\n\n---\n\n### 语法分析与括号匹配\n\n在编译器或解释器的语法分析阶段，需要检查表达式或语句是否合法。最常见的是**括号匹配**问题：扫描字符串时，遇到左括号（`(`、`[`、`{`）时压栈，遇到右括号时检查栈顶是否是对应的左括号，若不匹配则报错；最后栈为空则匹配成功。\n\n#### C++ 示例：括号匹配\n\n```cpp\n#include <iostream>\n#include <stack>\n#include <string>\n#include <unordered_map>\nbool isValid(const std::string &s) {\n    std::stack<char> st;\n    std::unordered_map<char, char> pairs = {\n        {')', '('}, {']', '['}, {'}', '{'}\n    };\n    for (char c : s) {\n        if (c == '(' || c == '[' || c == '{') {\n            st.push(c);\n        } else if (c == ')' || c == ']' || c == '}') {\n            if (st.empty() || st.top() != pairs[c]) {\n                return false;\n            }\n            st.pop();\n        }\n        // 忽略其他字符\n    }\n    return st.empty();\n}\nint main() {\n    std::string s1 = \"([{}])\";\n    std::string s2 = \"([}{])\";\n    std::cout << s1 << \" is \" << (isValid(s1) ? \"valid\\n\" : \"invalid\\n\");\n    std::cout << s2 << \" is \" << (isValid(s2) ? \"valid\\n\" : \"invalid\\n\");\n    return 0;\n}\n```\n\n- 使用 `std::stack<char>` 存储左括号，遇到右括号时检查对应关系。\n\n#### Python 示例\n\n```python\ndef is_valid(s: str) -> bool:\n    stack = []\n    pairs = {')': '(', ']': '[', '}': '{'}\n    for c in s:\n        if c in '([{':\n            stack.append(c)\n        elif c in ')]}':\n            if not stack or stack[-1] != pairs[c]:\n                return False\n            stack.pop()\n        # 忽略其他字符\n    return not stack\nif name == \"__main__\":\n    print(is_valid(\"([{}])\"))  # True\n    print(is_valid(\"([}{])\"))  # False\n```\n\n- 逻辑同上，用列表模拟栈。\n\n---\n\n### 进程/线程调度与上下文切换\n\n操作系统在进行**线程切换**或**进程切换**时，需要保存当前执行状态（寄存器上下文、程序计数器等）到线程/进程的**栈帧**中，待下次重新调度时再从栈中恢复。\n\n- 线程栈：每个线程分配固定大小的栈空间，保存其调用链和临时变量。上下文切换时，CPU 会自动“压栈”通用寄存器和程序计数器，然后加载下一个线程的寄存器和 PC 值；切回原线程时，再次“弹栈”恢复上下文。\n\n#### C++ 伪示例（伪代码，仅用于说明概念）\n\n```cpp\nstruct CPUContext {\n    uint64_t rip;     // 指令指针（程序计数器）\n    uint64_t rsp;     // 栈指针\n    uint64_t regs[16];// 其他通用寄存器\n    // ...\n};\nvoid context_switch(CPUContext *cur, CPUContext \n_next) {\n    // 保存当前上下文到 cur\n    asm volatile (\n        \"mov %%rsp, %0\\n\\t\"\n        \"mov %%rax, %1\\n\\t\"\n        // … 其他寄存器\n_*        : \"=m\"(cur->rsp), \"=m\"(cur->regs[0]) /*\n … \n_/\n        :\n        :\n    );\n    // 加载下一个上下文\n    asm volatile (\n        \"mov %0, %%rsp\\n\\t\"\n        \"mov %1, %%rax\\n\\t\"\n        // … 其他寄存器\n        :\n_*        : \"m\"(next->rsp), \"m\"(next->regs[0]) /*\n … */\n    );\n    // 跳转到下一个线程的指令地址\n    asm volatile (\"jmp *%0\" :: \"m\"(next->rip));\n}\n```\n\n- 该示例仅示意 OS 如何将寄存器状态压栈/存储到 `CPUContext` 结构，模拟上下文切换。真实内核会更复杂，并在内核栈上完成这些操作。\n\n---\n\n### 实时系统任务调度与中断处理\n\n在实时系统（RTOS）中，每个任务通常分配一个固定大小的栈，用于保存用户态执行时的局部变量和调用帧。\n\n- **任务调度**：RTOS 按优先级或时间片轮转调度任务，切换时需保存/恢复任务上下文（寄存器、程序计数器等）到各自任务的栈帧。\n- **中断处理**：发生中断时，CPU 自动将部分寄存器（如程序计数器、标志寄存器）压入当前栈中，跳转到中断处理程序，并使用中断程序自身的栈（通常也是内核栈）执行，处理完毕后从栈中弹出恢复现场。\n\n#### C 示例（伪代码，基于 ARM Cortex-M 中断栈）\n\n```c\n// 假设 Cortex-M 架构，中断发生时硬件会自动压入 R0-R3、R12、LR、PC、xPSR\nvoid SysTick_Handler(void) {\n    // 此时硬件已将通用寄存器和 xPSR 压入当前任务的栈中，使用 PSP/MSP 寄存器区分\n    // 处理中断逻辑\n    // ...\n    // 退出中断时，硬件自动从栈中弹回寄存器并恢复现场\n}\n// 任务创建时，手动构造该任务的初始栈帧\nuint32_t *create_task_stack(void (*task_func)(void), uint32_t *stack_top) {\n    // 栈顶需预留硬件自动压栈的空间（8 寄存器）\n    *(--stack_top) = INITIAL_xPSR;  // xPSR\n    *(--stack_top) = (uint32_t)task_func; // PC\n    *(--stack_top) = 0xFFFFFFFD;    // LR (使用 PSP 指向任务栈)\n    // R12, R3, R2, R1, R0\n    for (int i = 0; i < 5; i++) {\n        *(--stack_top) = 0;\n    }\n    // 接下来是软件自动压入的寄存器（R4–R11）\n    for (int i = 0; i < 8; i++) {\n        *(--stack_top) = 0;\n    }\n    return stack_top; // 返回任务上下文初始化后的栈顶指针\n}\n```\n\n- 在 ARM Cortex-M 系列中，中断或异常发生时，硬件会自动将 R0–R3、R12、LR、PC、xPSR 压栈；退出时硬件弹栈恢复。这段伪代码展示了如何手动为一个新任务构造“假”的中断栈帧，使其从任务函数 `task_func` 开始执行。\n\n---\n\n## 堆与栈在内存中的分布及冲突\n\n### 内存布局示意\n\nC 语言的内存模型分为 5 个区：栈区、堆区、静态区、常量区、代码区。每个区存储的内容如下：\n\n1. 栈区：存放函数的参数值、局部变量等，由编译器自动分配和释放，通常在函数执行完后就释放了，其操作方式类似于数据结构中的栈。栈内存分配运算内置于 CPU 的指令集，效率很高，但是分配的内存量有限，比如 iOS 中栈区的大小是 2M。\n2. 堆区：就是通过 new、malloc、realloc 分配的内存块，编译器不会负责它们的释放工作，需要用程序区释放。分配方式类似于数据结构中的链表。“内存泄漏”通常说的就是堆区。\n3. 静态区：全局变量和静态变量的存储是放在一块的，初始化的全局变量和静态变量在一块区域，未初始化的全局变量和未初始化的静态变量在相邻的另一块区域。程序结束后，由系统释放。\n4. 常量区：常量存储在这里，不允许修改。\n5. 代码区：顾名思义，存放代码。\n\n![1749360547853MFckbxyUqonaQtxbuPsc8E3unsc.png](https://gitee.com/tanke11223344/imagehost/raw/main/blog/1749360547853MFckbxyUqonaQtxbuPsc8E3unsc.png)\n![1749360556085D4ivbYK77oSejXxL204cgPNvneb.png](https://gitee.com/tanke11223344/imagehost/raw/main/blog/1749360556085D4ivbYK77oSejXxL204cgPNvneb.png)\n\n- **堆区**（Heap）从低地址向高地址方向增长。当程序调用 `new`/`malloc` 分配内存时，分配器会在堆中寻找足够大的空闲块。\n- **栈区**（Stack）从高地址向低地址方向增长。当函数调用时，系统在栈顶“向下”分配栈帧；函数返回时，“向上”回收。\n- 两者通常由中间的空闲区隔开，若向对方增长的空间过大，可能出现**堆与栈冲突**（Stack–Heap Collision）。\n\n### 栈堆冲突（Stack–Heap Collision）\n\n当程序对堆申请大量连续内存（如 `new`/`malloc`）而栈调用层次过深（或线程栈空间不足）时：\n\n- **堆过度增长**：不断调用动态分配函数，导致堆区不断向高地址扩展\n- **栈过度生长**：深度递归或大量局部变量导致栈区向低地址扩展\n  若二者相向增长，最终会相互覆盖（即“冲突”），造成已分配的堆内存或栈空间被意外覆盖，导致程序崩溃或不可预知的错误。\n\n#### 示意场景\n\n```cpp\n#include <iostream>\n#include <vector>\nvoid recurse(int depth) {\n    // 每次调用消耗一定的栈空间\n    char buffer[1024];  // 1KB 的局部数组\n    if (depth > 0) {\n        recurse(depth - 1);\n    }\n}\nint main() {\n    // 不断分配堆内存\n    std::vector<int*> allocations;\n    try {\n        while (true) {\n            allocations.push_back(new int[10000]); // 每次分配 ~40KB\n        }\n    } catch (std::bad_alloc &e) {\n        std::cerr << \"Heap exhausted: \" << e.what() << std::endl;\n    }\n    // 同时进行深度递归\n    recurse(100000); // 这会导致栈溢出\n    return 0;\n}\n```\n\n- 在上述伪示例中，如果同时执行大量 `new int[10000]`（堆分配）与深度递归 `recurse(100000)`（栈分配），就可能发生堆与栈冲突。实际运行时，程序要么先出现堆分配失败（抛出 `bad_alloc`），要么先出现栈溢出 (Stack Overflow)。\n\n#### 如何避免\n\n1. **控制递归深度**，或使用迭代替代深度递归，从而减少栈空间消耗。\n2. **限制堆分配总量**，在堆分配时及时释放不再使用的内存，避免过度占用。\n3. **增加可用内存**：在嵌入式或受限环境下，根据需求调整栈大小（编译器或链接器选项）和堆区大小。\n4. **监控与检测工具**：使用工具（如 Valgrind、AddressSanitizer）检测内存越界和栈溢出问题。\n\n---\n\n## 堆与栈在不同应用场景中的现实案例\n\n### 嵌入式开发\n\n- **堆与栈在 RTOS 中的角色**\n  - **栈**：每个任务分配固定大小的任务栈，用于存储任务函数的调用帧和局部变量。RTOS 切换任务时，会保存/恢复任务的寄存器上下文到各自的任务栈中。\n  - **堆**：嵌入式往往内存紧张，避免动态分配；如果使用堆则要小心碎片化。许多 RTOS（如 FreeRTOS）提供“内存池”或“堆区域”管理接口，开发者可根据需求预先分配一段大内存作为堆，通过 `pvPortMalloc`/`vPortFree` 操作。\n\n```c\n// FreeRTOS 示例：创建一个任务，并为其指定栈大小\nvoid vTaskFunction(void *pvParameters) {\n    int local_var = 42;  // 存储在任务栈中\n    for (;;) {\n        // Task logic...\n    }\n}\nint main(void) {\n    // 在创建任务时，指定 256 字 作为任务栈大小\n    xTaskCreate(vTaskFunction, \"Task1\", 256, NULL, 1, NULL);\n    vTaskStartScheduler(); // 启动调度器，开始抢占式多任务\n    return 0;\n}\n```\n\n- **场景说明**：在嵌入式系统中，为了保证实时性和预测性，往往禁止或限制堆分配，更多地使用**静态分配**或**内存池**，仅在启动阶段少量使用堆。\n\n---\n\n### Web 后端\n\n- **函数调用与请求栈**\n\n  - 在 Web 服务中，每个 HTTP 请求都可能触发一条线程（或使用协程/异步框架），该请求对应的调用堆栈存放在栈内存中。若请求处理链条过深（大量中间件或控制器嵌套），有可能导致栈溢出。\n- **缓存管理**\n\n  - **堆**：Java 或 C++ 编写的后端应用中的缓存（如 LRU Cache）通常使用堆结构来维护元素优先级或过期时间。例如，使用 `std::priority_queue` 或 Python 的 `heapq` 实现定时淘汰策略。\n\n#### C++ 示例：基于堆的简单 LRU 缓存（按过期时间）\n\n```cpp\n#include <iostream>\n#include <queue>\n#include <unordered_map>\n#include <chrono>\n#include <thread>\nstruct CacheItem {\n    int key;\n    std::string value;\n    std::chrono::steady_clock::time_point expire_time;\n};\nstruct CompareExpire {\n    bool operator()(const CacheItem &a, const CacheItem &b) {\n        return a.expire_time > b.expire_time; // 过期时间早的优先级高\n    }\n};\nclass LRUCache {\npublic:\n    LRUCache(size_t capacity): capacity_(capacity) {}\n    void put(int key, const std::string &value, int ttl_seconds) {\n        auto now = std::chrono::steady_clock::now();\n        CacheItem item{key, value, now + std::chrono::seconds(ttl_seconds)};\n        if (cache_map_.size() >= capacity_) {\n            // 移除过期或最久未使用元素\n            evict();\n        }\n        cache_map_[key] = item;\n        min_heap_.push(item);\n    }\n    std::string get(int key) {\n        auto it = cache_map_.find(key);\n        if (it == cache_map_.end()) return \"\"; // 未命中\n        // 更新过期时间或移动到最新位置可自行实现\n        return it->second.value;\n    }\nprivate:\n    void evict() {\n        auto now = std::chrono::steady_clock::now();\n        while (!min_heap_.empty()) {\n            auto &top = min_heap_.top();\n            if (top.expire_time <= now) {\n                // 已过期，删除\n                cache_map_.erase(top.key);\n                min_heap_.pop();\n            } else {\n                // 如果堆顶未过期，但 cache_map_ 超过容量，可自行实现额外的 LRU 逻辑\n                break;\n            }\n        }\n        // 这里简化：如果仍然超出容量，可额外删除最老元素\n    }\n    size_t capacity_;\n    std::unordered_map<int, CacheItem> cache_map_;\n    std::priority_queue<CacheItem, std::vector<CacheItem>, CompareExpire> min_heap_;\n};\nint main() {\n    LRUCache cache(3);\n    cache.put(1, \"A\", 2);\n    cache.put(2, \"B\", 5);\n    cache.put(3, \"C\", 10);\n    std::this_thread::sleep_for(std::chrono::seconds(3));\n    std::cout << \"Get key 1: \" << cache.get(1) << std::endl; // 可能已过期，返回 \"\"\n    return 0;\n}\n```\n\n- 使用 `std::priority_queue`（最小堆）按过期时间排序，当容量满时弹出最早过期项或其他淘汰策略。\n\n---\n\n### 游戏开发\n\n> - [游戏架构设计:内存管理 - KillerAery - 博客园](https://www.cnblogs.com/KillerAery/p/10765893.html)\n> - [【Unity3D】Unity3D 技术栈 - little_fat_sheep - 博客园](https://www.cnblogs.com/zhyan8/p/17238161.html)\n\n- **内存池（Memory Pool）**\n  - 游戏中对象（如子弹、特效、NPC）创建频繁，反复调用 `new/delete` 会导致堆碎片和性能损耗。常用的做法是在启动时预先向堆申请一大块连续内存，将其切分为固定大小的“内存池块”，通过栈或链表管理空闲块。分配时从池中取出一个空闲块，释放时将其归还池中，而无需操作系统的堆管理。\n\n#### C++ 示例：简单对象池（以 `GameObject` 为例）\n\n```cpp\n#include <iostream>\n#include <vector>\n// 假设游戏对象\nclass GameObject {\npublic:\n    GameObject() : x(0), y(0) {}\n    void reset() { x = y = 0; }\n    void set_position(int px, int py) { x = px; y = py; }\n    void print() const { std::cout << \"GameObject at (\" << x << \", \" << y << \")\\n\"; }\nprivate:\n    int x, y;\n};\nclass ObjectPool {\npublic:\n    ObjectPool(size_t poolSize) {\n        pool_.reserve(poolSize);\n        for (size_t i = 0; i < poolSize; ++i) {\n            pool_.push_back(new GameObject());\n            free_stack_.push(pool_.back());\n        }\n    }\n    ~ObjectPool() {\n        for (auto obj : pool_) delete obj;\n    }\n    GameObject* acquire() {\n        if (free_stack_.empty()) return nullptr;\n        GameObject* obj = free_stack_.top();\n        free_stack_.pop();\n        return obj;\n    }\n    void release(GameObject* obj) {\n        obj->reset();\n        free_stack_.push(obj);\n    }\nprivate:\n    std::vector<GameObject*> pool_;\n    std::stack<GameObject*> free_stack_;\n};\nint main() {\n    ObjectPool pool(5);\n    GameObject *obj1 = pool.acquire();\n    obj1->set_position(10, 20);\n    obj1->print(); // GameObject at (10, 20)\n    pool.release(obj1);\n    GameObject *obj2 = pool.acquire();\n    obj2->print(); // GameObject at (0, 0) （重置后）\n    return 0;\n}\n```\n\n- `ObjectPool` 在构造时一次性向堆申请若干 `GameObject`，将它们全部存在 `pool_` 容器中，再把指针压入 `free_stack_`（栈）。获取时从 `free_stack_` 弹栈；释放时将对象 `reset()` 并压回栈。避免了频繁的 `new/delete`。\n\n---\n\n### 操作系统原理\n\n- **线程栈**\n\n  - 操作系统为每个线程分配固定大小的内存作为线程栈，用于保存函数调用帧、局部变量和中断上下文。栈空间不足会导致**栈溢出（Stack Overflow）**，可能使程序崩溃。\n- **堆碎片与分配器**\n\n  - 应用在堆上频繁分配/释放不同大小的块，会导致碎片化（外部碎片）。操作系统或 C 运行时使用**分配算法**（如伙伴系统、空闲链表、slab 分配器）来减少碎片。例如 Linux 内核使用伙伴算法（Buddy Allocator）为内核分配物理页；用户态 C 库（glibc）使用 ptmalloc2，实现复杂的 bin 快表和 mmap 分配，从而提升多线程环境下的分配效率并尽量减少碎片。\n\n# 总结\n\n总体而言，**栈**与**堆**在数据结构和内存管理层面都是基础而关键的概念。数据结构层面，栈提供简单高效的 LIFO 存取，堆（优先队列）提供基于优先级的动态调度；内存管理层面，栈由系统自动分配释放，速度快但空间有限；堆则按需动态分配，由程序或运行时负责回收，灵活但需要注意碎片和内存泄漏。理解两者的差异及应用场景（如嵌入式的静态分配、后端的请求栈和缓存管理、游戏的内存池、操作系统的线程栈管理等）可以帮助程序员写出更健壮、高效的代码。\n\n- **栈**：自动分配与释放；访问速度快；适用于函数调用、状态机、撤销等场景；容量有限且线程私有。\n- **堆**：动态分配与释放；灵活但开销较大；可能发生碎片；适用于缓存管理、对象池、动态数据结构等场景。\n- 理解两者在内存布局上的位置及增长方式，有助于避免栈溢出和堆栈冲突，提高程序安全性与性能。\n","source":"_posts/2025-04-28-堆、栈及其应用分析.md","raw":"---\ntitle:  2025-04-28-堆、栈及其应用分析\ndate: 2025-04-28\ntags: \n    课程学习\n---\n# 堆、栈及其应用分析\n\n# 参考资料\n\n> - [栈结构解析及其应用 - 乌漆 WhiteMoon - 博客园](https://www.cnblogs.com/linfangnan/p/12450061.html)\n> - [堆栈信息分析 - moonandstar08 - 博客园](https://www.cnblogs.com/moonandstar08/p/4934597.html)\n> - [什么是堆?什么是栈?他们之间有什么区别和联系? - tolin - 博客园](https://www.cnblogs.com/tolin/p/14982094.html)\n\n# 堆 (Heap) 与 栈 (Stack) 概述\n\n- **栈（Stack）**\n- **数据结构视角**：一种受限的线性结构，只能在同一端（栈顶）进行插入（Push）和删除（Pop），遵循 “后进先出”（LIFO）原则。\n- **内存视角**：栈区由操作系统自动分配与回收，用于存储函数调用时的局部变量、函数参数、返回地址等信息。栈空间连续，访问和分配速度极快，但容量有限（通常几 MB），每个线程都有独立栈空间。\n- **堆（Heap）**\n\n  - **数据结构视角**：一种近似完全二叉树的优先队列结构（最大堆或最小堆），常用于按优先级提取元素。\n  - **内存视角**：堆区用于动态分配内存，程序运行时可调用 `new`/`malloc`（C++）或由运行时自动分配（Python）来获取；释放时需 `delete`/`free` 或由垃圾回收负责。堆空间大但分配、释放开销较大，可能产生内存碎片。\n\n## 数据结构视角\n\n**栈**：一种线性受限结构，只允许在栈顶进行插入（Push）和删除（Pop），遵循“后进先出”（LIFO）原则。常用操作包括 `push`（进栈）、`pop`（出栈）、`top`（取栈顶）等，这些操作时间复杂度通常为 O(1)。栈可用数组（顺序栈）或链表（链式栈）实现，适用于函数调用、递归计算、撤销操作等场景。\n\n> - [栈 - OI Wiki](https://oi-wiki.org/ds/stack/)\n\n### 使用数组模拟栈\n\n```cpp\nint st[N];\n// 这里使用 st[0] (即 *st) 代表栈中元素数量，同时也是栈顶下标\n\n// 压栈 ：\nst[++*st] = var1;\n// 取栈顶 ：\nint u = st[*st];\n// 弹栈 ：注意越界问题, *st == 0 时不能继续弹出\nif (*st) --*st;\n// 清空栈\n*st = 0;\n```\n\n### C++ STL 中的栈\n\nC++ 中的 STL 也提供了一个容器 `std::stack`，使用前需要引入 `stack` 头文件。\n\nSTL 中的 `stack` 容器提供了一众成员函数以供调用，其中较为常用的有：\n\n- 元素访问\n\n  - `st.top()` 返回栈顶\n- 修改\n\n  - `st.push()` 插入传入的参数到栈顶\n  - `st.pop()` 弹出栈顶\n- 容量\n\n  - `st.empty()` 返回是否为空\n  - `st.size()` 返回元素数量\n\n此外，`std::stack` 还提供了一些运算符。较为常用的是使用赋值运算符 `=` 为 `stack` 赋值，示例：\n\n```cpp\n// 新建两个栈 st1 和 st2\nstd::stack<int> st1, st2;\n\n// 为 st1 装入 1\nst1.push(1);\n\n// 将 st1 赋值给 st2\nst2 = st1;\n\n// 输出 st2 的栈顶元素\ncout << st2.top() << endl;\n// 输出: 1\n```\n\n### 使用 Python 中的 list 模拟栈\n\n```python\nst = [5, 1, 4]\n\n# 使用 append() 向栈顶添加元素\nst.append(2)\nst.append(3)\n# >>> st\n# [5, 1, 4, 2, 3]\n\n# 使用 pop 取出栈顶元素\nst.pop()\n# >>> st\n# [5, 1, 4, 2]\n\n# 使用 clear 清空栈\nst.clear()\n```\n\n**堆**（优先队列）: 一种树形结构，即满足堆序性的完全二叉树。每个节点的值都不大于（或不小于）其父节点的值，根节点是最大值（大顶堆）或最小值（小顶堆）。常见操作包括：上浮（shift_up）、下沉（shift_down）、插入（push）和弹出（pop）堆顶元素，以及查询堆顶（top）。堆常用作优先队列，在任务调度、Dijkstra 最短路径、Top-K 计算等场景中非常常见。\n\n> - [堆简介 - OI Wiki](https://oi-wiki.org/ds/heap/)\n\n堆是一棵树，其每个节点都有一个键值，且每个节点的键值都大于等于/小于等于其父亲的键值。\n\n每个节点的键值都大于等于其父亲键值的堆叫做小根堆，否则叫做大根堆。STL 中的 priority_queue 其实就是一个大根堆。\n\n（小根）堆主要支持的操作有：插入一个数、查询最小值、删除最小值、合并两个堆、减小一个元素的值。\n\n一些功能强大的堆（可并堆）还能（高效地）支持 merge 等操作。\n\n一些功能更强大的堆还支持可持久化，也就是对任意历史版本进行查询或者操作，产生新的版本。\n\n### **C++ 堆/优先队列**：默认大顶堆（`priority_queue`）：\n\n```cpp\nstd::priority_queue<int> pq;\npq.push(5);\npq.push(3);\nint top = pq.top(); // 5 (最大值)\npq.pop();\n```\n\n### **Python 堆**（`heapq` 最小堆）：\n\n```python\nimport heapq\nheap = []\nheapq.heappush(heap, 3)\nheapq.heappush(heap, 5)\ntop = heapq.heappop(heap)  # 3 (最小值)\n```\n\n- 如果需要大顶堆，可插入负值或使用第三方实现。\n\n### 堆排序\n\n> [Brute Force Heapsort](https://algorithm-visualizer.org/brute-force/heapsort)\n\n堆排序是一种高效的、基于比较的排序算法。它利用了堆这种数据结构的特性。基本思想是：\n\n1. **建堆 (Heapify)**：将待排序的序列构建成一个大顶堆（或小顶堆）。此时，堆顶元素就是整个序列的最大值（或最小值）。\n2. **排序 (Sort)**：\n\n   - 将堆顶元素与序列末尾的元素交换。\n   - 此时，序列末尾的元素即为最大（或最小）值，已经处于正确排序位置。\n   - 将剩余的 n-1 个元素重新调整为一个堆。\n   - 重复此过程，直到所有元素都排序完毕。\n\n堆排序的平均时间复杂度和最坏时间复杂度都是 O(nlogn)。\n\n#### C++ 实现堆排序\n\n在 C++ 中，可以利用标准库 `<algorithm>` 中提供的堆操作函数来方便地实现堆排序。\n\n- `std::make_heap(first, last)`: 将指定范围 `[first, last)` 内的元素重新排列，使其成为一个大顶堆。\n- `std::sort_heap(first, last)`: 将一个已经建好的堆 `[first, last)` 进行排序。它会重复地将堆顶元素（最大值）移动到序列的末尾，并重新调整剩余部分为堆。\n\nC++\n\n```cpp\n#include <iostream>\n#include <vector>\n#include <algorithm> // 包含 make_heap, sort_heap\n\nvoid print_vector(const std::vector<int>& vec) {\n    for (int val : vec) {\n        std::cout << val << \" \";\n    }\n    std::cout << std::endl;\n}\n\nint main() {\n    std::vector<int> v = {3, 5, 1, 8, 4, 7, 2};\n    std::cout << \"Original vector: \";\n    print_vector(v);\n\n    // 1. 将 vector 转换成大顶堆\n    std::make_heap(v.begin(), v.end());\n    std::cout << \"After make_heap (top is max): \" << v.front() << std::endl;\n  \n    // 2. 对堆进行排序 (结果为升序)\n    std::sort_heap(v.begin(), v.end());\n  \n    std::cout << \"Sorted vector: \";\n    print_vector(v); // 输出: 1 2 3 4 5 7 8\n\n    return 0;\n}\n```\n\n#### Python 实现堆排序\n\nPython 的 `heapq` 模块本身不直接提供一个完整的 `heapsort` 函数，但我们可以很容易地利用其 `heappush` 和 `heappop` 来实现。因为 `heapq` 是最小堆，所以 `heappop` 总是弹出最小值，天然适合用于升序排序。\n\n```python\nimport heapq\n\ndef heapsort_asc(iterable):\n    \"\"\"\n    使用 heapq 实现升序排序\n    \"\"\"\n    h = []\n    # 将所有元素压入堆中\n    for value in iterable:\n        heapq.heappush(h, value)\n    # 依次弹出堆中最小的元素，构成有序列表\n    return [heapq.heappop(h) for _ in range(len(h))]\n\ndata = [3, 5, 1, 8, 4, 7, 2]\nprint(f\"Original list: {data}\")\n\nsorted_data = heapsort_asc(data)\nprint(f\"Sorted list (ascending): {sorted_data}\") # 输出: [1, 2, 3, 4, 5, 7, 8]\n\n# 原地堆排序 (In-place Heap Sort)\n# 这更接近于堆排序的经典实现\ndef heapsort_inplace(arr):\n    n = len(arr)\n    # 1. 构建大顶堆 (从最后一个非叶子节点开始)\n    # 注意：heapq 是最小堆，所以这里通过对负数操作来模拟大顶堆\n    # 或者我们手动实现大顶堆的 sift_down\n    # 为了简单，我们还是用 heapq 来理解，但传统实现更高效\n    h = []\n    for x in arr:\n        heapq.heappush(h, x)\n    arr[:] = [heapq.heappop(h) for _ in range(n)]\n    return arr\n\ndata_inplace = [3, 5, 1, 8, 4, 7, 2]\nheapsort_inplace(data_inplace)\nprint(f\"In-place sorted list: {data_inplace}\")\n```\n\n栈和堆（优先队列）各有特点：\n\n- **数据组织**：栈是线性的、受限的结构，只能从一端操作；堆是树形结构，可快速获取最大或最小元素。\n- **访问效率**：栈操作简单开销小；堆插入/删除需维护堆序（O(log n)）。\n- **应用场景**：栈适合管理临时状态（如函数调用栈、表达式求值、撤销操作）；堆（优先队列）适合按优先级处理元素，如操作系统任务调度、网络请求优先级、算法中的最佳-优先搜索等。\n\n## 内存分配视角\n\n在程序运行时，内存通常分为**代码区**、**数据区**、**堆区**和**栈区**。其中：\n\n- **栈区**：由系统自动管理，随函数调用而增长，每次函数调用时分配空间给局部变量、函数参数和返回地址。函数返回时，这些空间自动回收。栈分配速度快、开销低，但空间有限（常见几 MB），且每个线程都有独立的栈空间。如果栈空间不足，会导致栈溢出错误。\n- **堆区**：用于动态内存分配，程序员（或运行时）在运行时使用 `new`/`malloc` 等申请内存，由程序员 `delete`/`free` 释放（在 Python/Java 等语言由垃圾回收自动释放）。堆的可用空间远大于栈，存放**动态对象**。堆内存碎片化的风险更高：频繁的分配和释放可能将大块连续内存切割成许多小碎片，降低利用率。\n- **静态/全局区**：编译时分配，程序运行前即确定，存放全局变量、静态变量和常量，在程序整个生命周期存在。\n\n**分配方式**：栈的分配和回收速度极快，操作由 CPU 指令自动完成；堆的分配开销较大，一般需要额外的内存管理算法（如自由链表或分代收集），在 C++ 中需要程序员手动释放。Python 中所有对象都分配在堆上，解释器通过引用计数和垃圾回收来管理。\n\n**访问效率**：由于栈内存连续、分配固定，因此访问和分配速度更高。堆内存由多个块组成，需额外指针管理，因而略慢于栈访问。此外，栈是线程私有的（线程安全），而堆是所有线程共享的（需注意并发安全）。\n\n- **C++ 栈 vs 堆 分配**：\n\n```cpp\nvoid func() {\n    int a = 10;            // 分配在栈上\n    int *p = new int(20);  // 分配在堆上\n    // ...\n    delete p;              // 手动释放堆内存\n} // 函数返回时，a 的栈空间自动释放，若忘了 delete，则 p 指向的内存泄露\n```\n\n- **Python 对象分配**：\n\n```python\ndef func():\n    a = 10             # 10 是整数对象，存储在堆中；a 是栈帧内的局部引用\n    b = [1, 2, 3]      # 列表对象在堆上分配\n    # 变量 a, b 是存放在函数调用栈帧中的引用，当函数结束，这些引用消失\n```\n\n- Python 不需要显示释放内存，垃圾回收自动回收无用对象。\n\n## 典型应用场景\n\n### 函数调用与返回\n\n当程序调用一个函数时，当前上下文（包括当前函数的局部变量、返回地址、CPU 寄存器等）会被“压栈（push）”到栈上；函数执行完成后，栈顶信息被“弹栈（pop）”，程序自动返回调用点并恢复先前状态。这种机制正是栈的典型应用。\n\n#### C++ 示例\n\n```cpp\n#include <iostream>\n// 一个示例函数，用于演示栈帧形成\nint factorial(int n) {\n    if (n <= 1) {\n        return 1;\n    }\n    // 调用 factorial(n-1) 前，会把当前的 n、返回地址等信息压入栈\n    return n * factorial(n - 1);\n}\nint main() {\n    int x = 5;\n    std::cout << \"factorial(\" << x << \") = \" << factorial(x) << std::endl;\n    return 0;\n}\n```\n\n- 每次调用 `factorial` 时，当前函数的局部变量（如 `n`）和返回地址会压入栈；函数结束时，栈帧被弹出，返回到上一级调用点。\n\n#### Python 示例\n\n```python\ndef factorial(n):\n    if n <= 1:\n        return 1\n    # 递归调用时，Python 会将当前函数帧压入调用栈\n    return n * factorial(n - 1)\nif \nname\n == \"\n__main__\n\":\n    x = 5\n    print(f\"factorial({x}) =\", factorial(x))\n```\n\n- Python 解释器内部也维护一个“调用栈”，每个函数调用都会在栈中创建一个帧（Frame），存放局部变量和执行状态。\n\n---\n\n### 内存管理（局部变量与函数参数）\n\n#### 说明\n\n- **栈分配**：编译器在编译期或运行期自动为每个函数分配固定的栈空间，用于存储局部变量和函数参数。函数结束时，这些空间会自动释放，无需程序员手动管理。\n- **堆分配**：程序员可在运行时动态向操作系统请求内存，使用 `new`/`malloc`（C++）或创建对象（Python）。这些内存由程序员负责释放（或由垃圾回收器回收）。\n\n#### C++ 示例：栈 vs 堆\n\n```cpp\n#include <iostream>\nvoid stackExample() {\n    int a = 10;             // 分配在栈上\n    int b[100];             // 数组也分配在栈上\n    std::cout << \"a = \" << a << std::endl;\n    std::cout << \"b[0] = \" << b[0] << std::endl;\n} // 函数结束时，a 和 b 的栈空间自动释放\nvoid heapExample() {\n    int *p = new int(20);   // 在堆上分配一个 int\n    int *arr = new int[100];// 在堆上分配一个大小为 100 的数组\n    std::cout << \"*p = \" << *p << std::endl;\n    std::cout << \"arr[0] = \" << arr[0] << std::endl;\n    delete p;               // 释放堆内存\n    delete[] arr;           // 释放数组\n}\nint main() {\n    stackExample();\n    heapExample();\n    return 0;\n}\n```\n\n- `stackExample`：变量 `a` 和数组 `b` 分配在栈上，由系统自动分配与回收。\n- `heapExample`：使用 `new` 在堆上分配内存，需要手动调用 `delete`/`delete[]` 来释放，否则会发生内存泄漏。\n\n#### Python 示例：对象分配在堆上\n\n```python\ndef memory_example():\n    a = 10            # 整数对象 10 存储在堆上，a 是栈帧中的一个引用\n    lst = [1, 2, 3]   # 列表对象存储在堆上，lst 引用保存在栈帧\n    print(a, lst)\nif \nname\n == \"\n__main__\n\":\n    memory_example()\n    # Python 通过引用计数和垃圾回收自动释放不再使用的对象\n```\n\n- 在 Python 中，所有对象都分配在堆上，局部变量仅是对这些对象的引用，保存在栈帧中。函数退出时，局部引用消失，引用计数可能降为 0，垃圾回收器会回收对象。\n\n---\n\n### 表达式求值（逆波兰表达式）\n\n#### 说明\n\n逆波兰表达式（后缀表达式）无需括号即可明确运算顺序，评估过程中需要一个栈来保存操作数、临时结果。\n\n- 遇到操作数时，压栈\n- 遇到运算符时，从栈中弹出相应数量的操作数进行计算，并将结果压回栈\n- 最后栈顶即为运算结果\n\n#### C++ 示例（仅支持 `+ - * /` 四则运算）\n\n```cpp\n#include <iostream>\n#include <stack>\n#include <sstream>\n#include <string>\n#include <vector>\n// 将字符串拆分为逆波兰表达式的 tokens\nstd::vector<std::string> tokenize(const std::string &expr) {\n    std::vector<std::string> tokens;\n    std::istringstream iss(expr);\n    std::string token;\n    while (iss >> token) {\n        tokens.push_back(token);\n    }\n    return tokens;\n}\nint evalRPN(const std::vector<std::string> &tokens) {\n    std::stack<int> st;\n    for (const auto &tk : tokens) {\n        if (tk == \"+\" || tk == \"-\" || tk == \"\n_\" || tk == \"/\") {\n            int b = st.top(); st.pop();\n            int a = st.top(); st.pop();\n            int res = 0;\n            if (tk == \"+\") res = a + b;\n            else if (tk == \"-\") res = a - b;\n_*            else if (tk == \"*\n\") res = a * b;\n            else if (tk == \"/\") res = a / b;\n            st.push(res);\n        } else {\n            st.push(std::stoi(tk));\n        }\n    }\n    return st.top();\n}\nint main() {\n    std::string expr = \"3 4 + 2 * 7 /\";\n    // 对应中缀: ((3 + 4) * 2) / 7 = 2\n    auto tokens = tokenize(expr);\n    std::cout << \"Result: \" << evalRPN(tokens) << std::endl;\n    return 0;\n}\n```\n\n- 将逆波兰表达式拆为 token 数组，遍历时用 `std::stack<int>` 存放操作数。每遇运算符，弹出两个操作数，计算后将结果压回栈。\n\n#### Python 示例\n\n```python\ndef eval_rpn(tokens):\n    stack = []\n    for tk in tokens:\n        if tk in {\"+\", \"-\", \"\n_\", \"/\"}:\n            b = stack.pop()\n            a = stack.pop()\n            if tk == \"+\":\n                stack.append(a + b)\n            elif tk == \"-\":\n                stack.append(a - b)\n_*            elif tk == \"*\n\":\n                stack.append(a * b)\n            else:\n                # 对于除法，需要注意 Python 的整除与 C++ 不同\n                stack.append(int(a / b))  # 向零取整\n        else:\n            stack.append(int(tk))\n    return stack.pop()\nif \nname\n == \"\n__main__\n\":\n    expr = \"3 4 + 2 * 7 /\".split()\n    print(\"Result:\", eval_rpn(expr))  # 2\n```\n\n- Python 用列表 `stack` 模拟栈，操作与 C++ 版本一致。\n\n---\n\n### 撤销（Undo）操作\n\n许多应用需要实现“撤销”功能，此时可将用户操作或状态快照依次压入栈，用户点击“撤销”时，再次从栈顶弹出即可恢复到上一次状态。\n\n#### Python 示例：文本编辑器简易撤销栈\n\n```python\nclass TextEditor:\n    def \n__init__\n(self):\n        self.text = \"\"\n        self.undo_stack = []  # 存放历史状态\n    def write(self, s):\n        # 在写新内容前，将当前状态压栈\n        self.undo_stack.append(self.text)\n        self.text += s\n    def undo(self):\n        if self.undo_stack:\n            self.text = self.undo_stack.pop()\n        else:\n            print(\"Nothing to undo\")\n    def show(self):\n        print(f\"Current Text: '{self.text}'\")\nif \nname\n == \"\n__main__\n\":\n    editor = TextEditor()\n    editor.write(\"Hello\")\n    editor.show()        # Hello\n    editor.write(\", World!\")\n    editor.show()        # Hello, World!\n    editor.undo()\n    editor.show()        # Hello\n    editor.undo()\n    editor.show()        # (空字符串)\n```\n\n- 每次写入之前，将 `self.text` 的旧值压入 `undo_stack`。调用 `undo()` 时，将栈顶字符串弹出并恢复。\n\n---\n\n### 浏览器后退功能\n\n浏览器维护一个“历史页面访问栈”：\n\n- 用户访问新页面时，将当前页面地址压入“后退栈”，同时清空“前进栈”\n- 点击“后退”时，将当前页面压入“前进栈”，并从“后退栈”弹出最近访问的页面\n- 点击“前进”时，则反向操作\n\n#### Python 示例：简易浏览器历史\n\n```python\nclass BrowserHistory:\n    def __init__(self, homepage: str):\n        self.back_stack = []     # 后退栈\n        self.forward_stack = []  # 前进栈\n        self.current = homepage  # 当前页面\n    def visit(self, url: str):\n        self.back_stack.append(self.current)\n        self.current = url\n        self.forward_stack.clear()  # 新访问清空前进历史\n    def back(self):\n        if self.back_stack:\n            self.forward_stack.append(self.current)\n            self.current = self.back_stack.pop()\n        else:\n            print(\"No pages to go back to\")\n    def forward(self):\n        if self.forward_stack:\n            self.back_stack.append(self.current)\n            self.current = self.forward_stack.pop()\n        else:\n            print(\"No pages to go forward to\")\n    def show(self):\n        print(f\"Back: {self.back_stack}, Current: {self.current}, Forward: {self.forward_stack}\")\nif name == \"__main__\":\n    browser = BrowserHistory(\"homepage.com\")\n    browser.show()\n    browser.visit(\"news.com\")\n    browser.show()\n    browser.visit(\"sports.com\")\n    browser.show()\n    browser.back()\n    browser.show()\n    browser.back()\n    browser.show()\n    browser.forward()\n    browser.show()\n```\n\n- 通过两个栈 (`back_stack` 和 `forward_stack`) 维护历史访问记录，实现后退和前进功能。\n\n---\n\n### 语法分析与括号匹配\n\n在编译器或解释器的语法分析阶段，需要检查表达式或语句是否合法。最常见的是**括号匹配**问题：扫描字符串时，遇到左括号（`(`、`[`、`{`）时压栈，遇到右括号时检查栈顶是否是对应的左括号，若不匹配则报错；最后栈为空则匹配成功。\n\n#### C++ 示例：括号匹配\n\n```cpp\n#include <iostream>\n#include <stack>\n#include <string>\n#include <unordered_map>\nbool isValid(const std::string &s) {\n    std::stack<char> st;\n    std::unordered_map<char, char> pairs = {\n        {')', '('}, {']', '['}, {'}', '{'}\n    };\n    for (char c : s) {\n        if (c == '(' || c == '[' || c == '{') {\n            st.push(c);\n        } else if (c == ')' || c == ']' || c == '}') {\n            if (st.empty() || st.top() != pairs[c]) {\n                return false;\n            }\n            st.pop();\n        }\n        // 忽略其他字符\n    }\n    return st.empty();\n}\nint main() {\n    std::string s1 = \"([{}])\";\n    std::string s2 = \"([}{])\";\n    std::cout << s1 << \" is \" << (isValid(s1) ? \"valid\\n\" : \"invalid\\n\");\n    std::cout << s2 << \" is \" << (isValid(s2) ? \"valid\\n\" : \"invalid\\n\");\n    return 0;\n}\n```\n\n- 使用 `std::stack<char>` 存储左括号，遇到右括号时检查对应关系。\n\n#### Python 示例\n\n```python\ndef is_valid(s: str) -> bool:\n    stack = []\n    pairs = {')': '(', ']': '[', '}': '{'}\n    for c in s:\n        if c in '([{':\n            stack.append(c)\n        elif c in ')]}':\n            if not stack or stack[-1] != pairs[c]:\n                return False\n            stack.pop()\n        # 忽略其他字符\n    return not stack\nif name == \"__main__\":\n    print(is_valid(\"([{}])\"))  # True\n    print(is_valid(\"([}{])\"))  # False\n```\n\n- 逻辑同上，用列表模拟栈。\n\n---\n\n### 进程/线程调度与上下文切换\n\n操作系统在进行**线程切换**或**进程切换**时，需要保存当前执行状态（寄存器上下文、程序计数器等）到线程/进程的**栈帧**中，待下次重新调度时再从栈中恢复。\n\n- 线程栈：每个线程分配固定大小的栈空间，保存其调用链和临时变量。上下文切换时，CPU 会自动“压栈”通用寄存器和程序计数器，然后加载下一个线程的寄存器和 PC 值；切回原线程时，再次“弹栈”恢复上下文。\n\n#### C++ 伪示例（伪代码，仅用于说明概念）\n\n```cpp\nstruct CPUContext {\n    uint64_t rip;     // 指令指针（程序计数器）\n    uint64_t rsp;     // 栈指针\n    uint64_t regs[16];// 其他通用寄存器\n    // ...\n};\nvoid context_switch(CPUContext *cur, CPUContext \n_next) {\n    // 保存当前上下文到 cur\n    asm volatile (\n        \"mov %%rsp, %0\\n\\t\"\n        \"mov %%rax, %1\\n\\t\"\n        // … 其他寄存器\n_*        : \"=m\"(cur->rsp), \"=m\"(cur->regs[0]) /*\n … \n_/\n        :\n        :\n    );\n    // 加载下一个上下文\n    asm volatile (\n        \"mov %0, %%rsp\\n\\t\"\n        \"mov %1, %%rax\\n\\t\"\n        // … 其他寄存器\n        :\n_*        : \"m\"(next->rsp), \"m\"(next->regs[0]) /*\n … */\n    );\n    // 跳转到下一个线程的指令地址\n    asm volatile (\"jmp *%0\" :: \"m\"(next->rip));\n}\n```\n\n- 该示例仅示意 OS 如何将寄存器状态压栈/存储到 `CPUContext` 结构，模拟上下文切换。真实内核会更复杂，并在内核栈上完成这些操作。\n\n---\n\n### 实时系统任务调度与中断处理\n\n在实时系统（RTOS）中，每个任务通常分配一个固定大小的栈，用于保存用户态执行时的局部变量和调用帧。\n\n- **任务调度**：RTOS 按优先级或时间片轮转调度任务，切换时需保存/恢复任务上下文（寄存器、程序计数器等）到各自任务的栈帧。\n- **中断处理**：发生中断时，CPU 自动将部分寄存器（如程序计数器、标志寄存器）压入当前栈中，跳转到中断处理程序，并使用中断程序自身的栈（通常也是内核栈）执行，处理完毕后从栈中弹出恢复现场。\n\n#### C 示例（伪代码，基于 ARM Cortex-M 中断栈）\n\n```c\n// 假设 Cortex-M 架构，中断发生时硬件会自动压入 R0-R3、R12、LR、PC、xPSR\nvoid SysTick_Handler(void) {\n    // 此时硬件已将通用寄存器和 xPSR 压入当前任务的栈中，使用 PSP/MSP 寄存器区分\n    // 处理中断逻辑\n    // ...\n    // 退出中断时，硬件自动从栈中弹回寄存器并恢复现场\n}\n// 任务创建时，手动构造该任务的初始栈帧\nuint32_t *create_task_stack(void (*task_func)(void), uint32_t *stack_top) {\n    // 栈顶需预留硬件自动压栈的空间（8 寄存器）\n    *(--stack_top) = INITIAL_xPSR;  // xPSR\n    *(--stack_top) = (uint32_t)task_func; // PC\n    *(--stack_top) = 0xFFFFFFFD;    // LR (使用 PSP 指向任务栈)\n    // R12, R3, R2, R1, R0\n    for (int i = 0; i < 5; i++) {\n        *(--stack_top) = 0;\n    }\n    // 接下来是软件自动压入的寄存器（R4–R11）\n    for (int i = 0; i < 8; i++) {\n        *(--stack_top) = 0;\n    }\n    return stack_top; // 返回任务上下文初始化后的栈顶指针\n}\n```\n\n- 在 ARM Cortex-M 系列中，中断或异常发生时，硬件会自动将 R0–R3、R12、LR、PC、xPSR 压栈；退出时硬件弹栈恢复。这段伪代码展示了如何手动为一个新任务构造“假”的中断栈帧，使其从任务函数 `task_func` 开始执行。\n\n---\n\n## 堆与栈在内存中的分布及冲突\n\n### 内存布局示意\n\nC 语言的内存模型分为 5 个区：栈区、堆区、静态区、常量区、代码区。每个区存储的内容如下：\n\n1. 栈区：存放函数的参数值、局部变量等，由编译器自动分配和释放，通常在函数执行完后就释放了，其操作方式类似于数据结构中的栈。栈内存分配运算内置于 CPU 的指令集，效率很高，但是分配的内存量有限，比如 iOS 中栈区的大小是 2M。\n2. 堆区：就是通过 new、malloc、realloc 分配的内存块，编译器不会负责它们的释放工作，需要用程序区释放。分配方式类似于数据结构中的链表。“内存泄漏”通常说的就是堆区。\n3. 静态区：全局变量和静态变量的存储是放在一块的，初始化的全局变量和静态变量在一块区域，未初始化的全局变量和未初始化的静态变量在相邻的另一块区域。程序结束后，由系统释放。\n4. 常量区：常量存储在这里，不允许修改。\n5. 代码区：顾名思义，存放代码。\n\n![1749360547853MFckbxyUqonaQtxbuPsc8E3unsc.png](https://gitee.com/tanke11223344/imagehost/raw/main/blog/1749360547853MFckbxyUqonaQtxbuPsc8E3unsc.png)\n![1749360556085D4ivbYK77oSejXxL204cgPNvneb.png](https://gitee.com/tanke11223344/imagehost/raw/main/blog/1749360556085D4ivbYK77oSejXxL204cgPNvneb.png)\n\n- **堆区**（Heap）从低地址向高地址方向增长。当程序调用 `new`/`malloc` 分配内存时，分配器会在堆中寻找足够大的空闲块。\n- **栈区**（Stack）从高地址向低地址方向增长。当函数调用时，系统在栈顶“向下”分配栈帧；函数返回时，“向上”回收。\n- 两者通常由中间的空闲区隔开，若向对方增长的空间过大，可能出现**堆与栈冲突**（Stack–Heap Collision）。\n\n### 栈堆冲突（Stack–Heap Collision）\n\n当程序对堆申请大量连续内存（如 `new`/`malloc`）而栈调用层次过深（或线程栈空间不足）时：\n\n- **堆过度增长**：不断调用动态分配函数，导致堆区不断向高地址扩展\n- **栈过度生长**：深度递归或大量局部变量导致栈区向低地址扩展\n  若二者相向增长，最终会相互覆盖（即“冲突”），造成已分配的堆内存或栈空间被意外覆盖，导致程序崩溃或不可预知的错误。\n\n#### 示意场景\n\n```cpp\n#include <iostream>\n#include <vector>\nvoid recurse(int depth) {\n    // 每次调用消耗一定的栈空间\n    char buffer[1024];  // 1KB 的局部数组\n    if (depth > 0) {\n        recurse(depth - 1);\n    }\n}\nint main() {\n    // 不断分配堆内存\n    std::vector<int*> allocations;\n    try {\n        while (true) {\n            allocations.push_back(new int[10000]); // 每次分配 ~40KB\n        }\n    } catch (std::bad_alloc &e) {\n        std::cerr << \"Heap exhausted: \" << e.what() << std::endl;\n    }\n    // 同时进行深度递归\n    recurse(100000); // 这会导致栈溢出\n    return 0;\n}\n```\n\n- 在上述伪示例中，如果同时执行大量 `new int[10000]`（堆分配）与深度递归 `recurse(100000)`（栈分配），就可能发生堆与栈冲突。实际运行时，程序要么先出现堆分配失败（抛出 `bad_alloc`），要么先出现栈溢出 (Stack Overflow)。\n\n#### 如何避免\n\n1. **控制递归深度**，或使用迭代替代深度递归，从而减少栈空间消耗。\n2. **限制堆分配总量**，在堆分配时及时释放不再使用的内存，避免过度占用。\n3. **增加可用内存**：在嵌入式或受限环境下，根据需求调整栈大小（编译器或链接器选项）和堆区大小。\n4. **监控与检测工具**：使用工具（如 Valgrind、AddressSanitizer）检测内存越界和栈溢出问题。\n\n---\n\n## 堆与栈在不同应用场景中的现实案例\n\n### 嵌入式开发\n\n- **堆与栈在 RTOS 中的角色**\n  - **栈**：每个任务分配固定大小的任务栈，用于存储任务函数的调用帧和局部变量。RTOS 切换任务时，会保存/恢复任务的寄存器上下文到各自的任务栈中。\n  - **堆**：嵌入式往往内存紧张，避免动态分配；如果使用堆则要小心碎片化。许多 RTOS（如 FreeRTOS）提供“内存池”或“堆区域”管理接口，开发者可根据需求预先分配一段大内存作为堆，通过 `pvPortMalloc`/`vPortFree` 操作。\n\n```c\n// FreeRTOS 示例：创建一个任务，并为其指定栈大小\nvoid vTaskFunction(void *pvParameters) {\n    int local_var = 42;  // 存储在任务栈中\n    for (;;) {\n        // Task logic...\n    }\n}\nint main(void) {\n    // 在创建任务时，指定 256 字 作为任务栈大小\n    xTaskCreate(vTaskFunction, \"Task1\", 256, NULL, 1, NULL);\n    vTaskStartScheduler(); // 启动调度器，开始抢占式多任务\n    return 0;\n}\n```\n\n- **场景说明**：在嵌入式系统中，为了保证实时性和预测性，往往禁止或限制堆分配，更多地使用**静态分配**或**内存池**，仅在启动阶段少量使用堆。\n\n---\n\n### Web 后端\n\n- **函数调用与请求栈**\n\n  - 在 Web 服务中，每个 HTTP 请求都可能触发一条线程（或使用协程/异步框架），该请求对应的调用堆栈存放在栈内存中。若请求处理链条过深（大量中间件或控制器嵌套），有可能导致栈溢出。\n- **缓存管理**\n\n  - **堆**：Java 或 C++ 编写的后端应用中的缓存（如 LRU Cache）通常使用堆结构来维护元素优先级或过期时间。例如，使用 `std::priority_queue` 或 Python 的 `heapq` 实现定时淘汰策略。\n\n#### C++ 示例：基于堆的简单 LRU 缓存（按过期时间）\n\n```cpp\n#include <iostream>\n#include <queue>\n#include <unordered_map>\n#include <chrono>\n#include <thread>\nstruct CacheItem {\n    int key;\n    std::string value;\n    std::chrono::steady_clock::time_point expire_time;\n};\nstruct CompareExpire {\n    bool operator()(const CacheItem &a, const CacheItem &b) {\n        return a.expire_time > b.expire_time; // 过期时间早的优先级高\n    }\n};\nclass LRUCache {\npublic:\n    LRUCache(size_t capacity): capacity_(capacity) {}\n    void put(int key, const std::string &value, int ttl_seconds) {\n        auto now = std::chrono::steady_clock::now();\n        CacheItem item{key, value, now + std::chrono::seconds(ttl_seconds)};\n        if (cache_map_.size() >= capacity_) {\n            // 移除过期或最久未使用元素\n            evict();\n        }\n        cache_map_[key] = item;\n        min_heap_.push(item);\n    }\n    std::string get(int key) {\n        auto it = cache_map_.find(key);\n        if (it == cache_map_.end()) return \"\"; // 未命中\n        // 更新过期时间或移动到最新位置可自行实现\n        return it->second.value;\n    }\nprivate:\n    void evict() {\n        auto now = std::chrono::steady_clock::now();\n        while (!min_heap_.empty()) {\n            auto &top = min_heap_.top();\n            if (top.expire_time <= now) {\n                // 已过期，删除\n                cache_map_.erase(top.key);\n                min_heap_.pop();\n            } else {\n                // 如果堆顶未过期，但 cache_map_ 超过容量，可自行实现额外的 LRU 逻辑\n                break;\n            }\n        }\n        // 这里简化：如果仍然超出容量，可额外删除最老元素\n    }\n    size_t capacity_;\n    std::unordered_map<int, CacheItem> cache_map_;\n    std::priority_queue<CacheItem, std::vector<CacheItem>, CompareExpire> min_heap_;\n};\nint main() {\n    LRUCache cache(3);\n    cache.put(1, \"A\", 2);\n    cache.put(2, \"B\", 5);\n    cache.put(3, \"C\", 10);\n    std::this_thread::sleep_for(std::chrono::seconds(3));\n    std::cout << \"Get key 1: \" << cache.get(1) << std::endl; // 可能已过期，返回 \"\"\n    return 0;\n}\n```\n\n- 使用 `std::priority_queue`（最小堆）按过期时间排序，当容量满时弹出最早过期项或其他淘汰策略。\n\n---\n\n### 游戏开发\n\n> - [游戏架构设计:内存管理 - KillerAery - 博客园](https://www.cnblogs.com/KillerAery/p/10765893.html)\n> - [【Unity3D】Unity3D 技术栈 - little_fat_sheep - 博客园](https://www.cnblogs.com/zhyan8/p/17238161.html)\n\n- **内存池（Memory Pool）**\n  - 游戏中对象（如子弹、特效、NPC）创建频繁，反复调用 `new/delete` 会导致堆碎片和性能损耗。常用的做法是在启动时预先向堆申请一大块连续内存，将其切分为固定大小的“内存池块”，通过栈或链表管理空闲块。分配时从池中取出一个空闲块，释放时将其归还池中，而无需操作系统的堆管理。\n\n#### C++ 示例：简单对象池（以 `GameObject` 为例）\n\n```cpp\n#include <iostream>\n#include <vector>\n// 假设游戏对象\nclass GameObject {\npublic:\n    GameObject() : x(0), y(0) {}\n    void reset() { x = y = 0; }\n    void set_position(int px, int py) { x = px; y = py; }\n    void print() const { std::cout << \"GameObject at (\" << x << \", \" << y << \")\\n\"; }\nprivate:\n    int x, y;\n};\nclass ObjectPool {\npublic:\n    ObjectPool(size_t poolSize) {\n        pool_.reserve(poolSize);\n        for (size_t i = 0; i < poolSize; ++i) {\n            pool_.push_back(new GameObject());\n            free_stack_.push(pool_.back());\n        }\n    }\n    ~ObjectPool() {\n        for (auto obj : pool_) delete obj;\n    }\n    GameObject* acquire() {\n        if (free_stack_.empty()) return nullptr;\n        GameObject* obj = free_stack_.top();\n        free_stack_.pop();\n        return obj;\n    }\n    void release(GameObject* obj) {\n        obj->reset();\n        free_stack_.push(obj);\n    }\nprivate:\n    std::vector<GameObject*> pool_;\n    std::stack<GameObject*> free_stack_;\n};\nint main() {\n    ObjectPool pool(5);\n    GameObject *obj1 = pool.acquire();\n    obj1->set_position(10, 20);\n    obj1->print(); // GameObject at (10, 20)\n    pool.release(obj1);\n    GameObject *obj2 = pool.acquire();\n    obj2->print(); // GameObject at (0, 0) （重置后）\n    return 0;\n}\n```\n\n- `ObjectPool` 在构造时一次性向堆申请若干 `GameObject`，将它们全部存在 `pool_` 容器中，再把指针压入 `free_stack_`（栈）。获取时从 `free_stack_` 弹栈；释放时将对象 `reset()` 并压回栈。避免了频繁的 `new/delete`。\n\n---\n\n### 操作系统原理\n\n- **线程栈**\n\n  - 操作系统为每个线程分配固定大小的内存作为线程栈，用于保存函数调用帧、局部变量和中断上下文。栈空间不足会导致**栈溢出（Stack Overflow）**，可能使程序崩溃。\n- **堆碎片与分配器**\n\n  - 应用在堆上频繁分配/释放不同大小的块，会导致碎片化（外部碎片）。操作系统或 C 运行时使用**分配算法**（如伙伴系统、空闲链表、slab 分配器）来减少碎片。例如 Linux 内核使用伙伴算法（Buddy Allocator）为内核分配物理页；用户态 C 库（glibc）使用 ptmalloc2，实现复杂的 bin 快表和 mmap 分配，从而提升多线程环境下的分配效率并尽量减少碎片。\n\n# 总结\n\n总体而言，**栈**与**堆**在数据结构和内存管理层面都是基础而关键的概念。数据结构层面，栈提供简单高效的 LIFO 存取，堆（优先队列）提供基于优先级的动态调度；内存管理层面，栈由系统自动分配释放，速度快但空间有限；堆则按需动态分配，由程序或运行时负责回收，灵活但需要注意碎片和内存泄漏。理解两者的差异及应用场景（如嵌入式的静态分配、后端的请求栈和缓存管理、游戏的内存池、操作系统的线程栈管理等）可以帮助程序员写出更健壮、高效的代码。\n\n- **栈**：自动分配与释放；访问速度快；适用于函数调用、状态机、撤销等场景；容量有限且线程私有。\n- **堆**：动态分配与释放；灵活但开销较大；可能发生碎片；适用于缓存管理、对象池、动态数据结构等场景。\n- 理解两者在内存布局上的位置及增长方式，有助于避免栈溢出和堆栈冲突，提高程序安全性与性能。\n","slug":"2025-04-28-堆、栈及其应用分析","published":1,"updated":"2025-09-26T12:17:09.607Z","_id":"cmg0saj45001ljm8n7c6v7gmg","comments":1,"layout":"post","photos":[],"content":"<h1 id=\"堆、栈及其应用分析\"><a href=\"#堆、栈及其应用分析\" class=\"headerlink\" title=\"堆、栈及其应用分析\"></a>堆、栈及其应用分析</h1><h1 id=\"参考资料\"><a href=\"#参考资料\" class=\"headerlink\" title=\"参考资料\"></a>参考资料</h1><blockquote>\n<ul>\n<li><a href=\"https://www.cnblogs.com/linfangnan/p/12450061.html\">栈结构解析及其应用 - 乌漆 WhiteMoon - 博客园</a></li>\n<li><a href=\"https://www.cnblogs.com/moonandstar08/p/4934597.html\">堆栈信息分析 - moonandstar08 - 博客园</a></li>\n<li><a href=\"https://www.cnblogs.com/tolin/p/14982094.html\">什么是堆?什么是栈?他们之间有什么区别和联系? - tolin - 博客园</a></li>\n</ul>\n</blockquote>\n<h1 id=\"堆-Heap-与-栈-Stack-概述\"><a href=\"#堆-Heap-与-栈-Stack-概述\" class=\"headerlink\" title=\"堆 (Heap) 与 栈 (Stack) 概述\"></a>堆 (Heap) 与 栈 (Stack) 概述</h1><ul>\n<li><p><strong>栈（Stack）</strong></p>\n</li>\n<li><p><strong>数据结构视角</strong>：一种受限的线性结构，只能在同一端（栈顶）进行插入（Push）和删除（Pop），遵循 “后进先出”（LIFO）原则。</p>\n</li>\n<li><p><strong>内存视角</strong>：栈区由操作系统自动分配与回收，用于存储函数调用时的局部变量、函数参数、返回地址等信息。栈空间连续，访问和分配速度极快，但容量有限（通常几 MB），每个线程都有独立栈空间。</p>\n</li>\n<li><p><strong>堆（Heap）</strong></p>\n<ul>\n<li><strong>数据结构视角</strong>：一种近似完全二叉树的优先队列结构（最大堆或最小堆），常用于按优先级提取元素。</li>\n<li><strong>内存视角</strong>：堆区用于动态分配内存，程序运行时可调用 <code>new</code>&#x2F;<code>malloc</code>（C++）或由运行时自动分配（Python）来获取；释放时需 <code>delete</code>&#x2F;<code>free</code> 或由垃圾回收负责。堆空间大但分配、释放开销较大，可能产生内存碎片。</li>\n</ul>\n</li>\n</ul>\n<h2 id=\"数据结构视角\"><a href=\"#数据结构视角\" class=\"headerlink\" title=\"数据结构视角\"></a>数据结构视角</h2><p><strong>栈</strong>：一种线性受限结构，只允许在栈顶进行插入（Push）和删除（Pop），遵循“后进先出”（LIFO）原则。常用操作包括 <code>push</code>（进栈）、<code>pop</code>（出栈）、<code>top</code>（取栈顶）等，这些操作时间复杂度通常为 O(1)。栈可用数组（顺序栈）或链表（链式栈）实现，适用于函数调用、递归计算、撤销操作等场景。</p>\n<blockquote>\n<ul>\n<li><a href=\"https://oi-wiki.org/ds/stack/\">栈 - OI Wiki</a></li>\n</ul>\n</blockquote>\n<h3 id=\"使用数组模拟栈\"><a href=\"#使用数组模拟栈\" class=\"headerlink\" title=\"使用数组模拟栈\"></a>使用数组模拟栈</h3><figure class=\"highlight cpp\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"type\">int</span> st[N];</span><br><span class=\"line\"><span class=\"comment\">// 这里使用 st[0] (即 *st) 代表栈中元素数量，同时也是栈顶下标</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// 压栈 ：</span></span><br><span class=\"line\">st[++*st] = var1;</span><br><span class=\"line\"><span class=\"comment\">// 取栈顶 ：</span></span><br><span class=\"line\"><span class=\"type\">int</span> u = st[*st];</span><br><span class=\"line\"><span class=\"comment\">// 弹栈 ：注意越界问题, *st == 0 时不能继续弹出</span></span><br><span class=\"line\"><span class=\"keyword\">if</span> (*st) --*st;</span><br><span class=\"line\"><span class=\"comment\">// 清空栈</span></span><br><span class=\"line\">*st = <span class=\"number\">0</span>;</span><br></pre></td></tr></table></figure>\n\n<h3 id=\"C-STL-中的栈\"><a href=\"#C-STL-中的栈\" class=\"headerlink\" title=\"C++ STL 中的栈\"></a>C++ STL 中的栈</h3><p>C++ 中的 STL 也提供了一个容器 <code>std::stack</code>，使用前需要引入 <code>stack</code> 头文件。</p>\n<p>STL 中的 <code>stack</code> 容器提供了一众成员函数以供调用，其中较为常用的有：</p>\n<ul>\n<li><p>元素访问</p>\n<ul>\n<li><code>st.top()</code> 返回栈顶</li>\n</ul>\n</li>\n<li><p>修改</p>\n<ul>\n<li><code>st.push()</code> 插入传入的参数到栈顶</li>\n<li><code>st.pop()</code> 弹出栈顶</li>\n</ul>\n</li>\n<li><p>容量</p>\n<ul>\n<li><code>st.empty()</code> 返回是否为空</li>\n<li><code>st.size()</code> 返回元素数量</li>\n</ul>\n</li>\n</ul>\n<p>此外，<code>std::stack</code> 还提供了一些运算符。较为常用的是使用赋值运算符 <code>=</code> 为 <code>stack</code> 赋值，示例：</p>\n<figure class=\"highlight cpp\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// 新建两个栈 st1 和 st2</span></span><br><span class=\"line\">std::stack&lt;<span class=\"type\">int</span>&gt; st1, st2;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// 为 st1 装入 1</span></span><br><span class=\"line\">st<span class=\"number\">1.</span><span class=\"built_in\">push</span>(<span class=\"number\">1</span>);</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// 将 st1 赋值给 st2</span></span><br><span class=\"line\">st2 = st1;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// 输出 st2 的栈顶元素</span></span><br><span class=\"line\">cout &lt;&lt; st<span class=\"number\">2.</span><span class=\"built_in\">top</span>() &lt;&lt; endl;</span><br><span class=\"line\"><span class=\"comment\">// 输出: 1</span></span><br></pre></td></tr></table></figure>\n\n<h3 id=\"使用-Python-中的-list-模拟栈\"><a href=\"#使用-Python-中的-list-模拟栈\" class=\"headerlink\" title=\"使用 Python 中的 list 模拟栈\"></a>使用 Python 中的 list 模拟栈</h3><figure class=\"highlight python\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">st = [<span class=\"number\">5</span>, <span class=\"number\">1</span>, <span class=\"number\">4</span>]</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\"># 使用 append() 向栈顶添加元素</span></span><br><span class=\"line\">st.append(<span class=\"number\">2</span>)</span><br><span class=\"line\">st.append(<span class=\"number\">3</span>)</span><br><span class=\"line\"><span class=\"comment\"># &gt;&gt;&gt; st</span></span><br><span class=\"line\"><span class=\"comment\"># [5, 1, 4, 2, 3]</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\"># 使用 pop 取出栈顶元素</span></span><br><span class=\"line\">st.pop()</span><br><span class=\"line\"><span class=\"comment\"># &gt;&gt;&gt; st</span></span><br><span class=\"line\"><span class=\"comment\"># [5, 1, 4, 2]</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\"># 使用 clear 清空栈</span></span><br><span class=\"line\">st.clear()</span><br></pre></td></tr></table></figure>\n\n<p><strong>堆</strong>（优先队列）: 一种树形结构，即满足堆序性的完全二叉树。每个节点的值都不大于（或不小于）其父节点的值，根节点是最大值（大顶堆）或最小值（小顶堆）。常见操作包括：上浮（shift_up）、下沉（shift_down）、插入（push）和弹出（pop）堆顶元素，以及查询堆顶（top）。堆常用作优先队列，在任务调度、Dijkstra 最短路径、Top-K 计算等场景中非常常见。</p>\n<blockquote>\n<ul>\n<li><a href=\"https://oi-wiki.org/ds/heap/\">堆简介 - OI Wiki</a></li>\n</ul>\n</blockquote>\n<p>堆是一棵树，其每个节点都有一个键值，且每个节点的键值都大于等于&#x2F;小于等于其父亲的键值。</p>\n<p>每个节点的键值都大于等于其父亲键值的堆叫做小根堆，否则叫做大根堆。STL 中的 priority_queue 其实就是一个大根堆。</p>\n<p>（小根）堆主要支持的操作有：插入一个数、查询最小值、删除最小值、合并两个堆、减小一个元素的值。</p>\n<p>一些功能强大的堆（可并堆）还能（高效地）支持 merge 等操作。</p>\n<p>一些功能更强大的堆还支持可持久化，也就是对任意历史版本进行查询或者操作，产生新的版本。</p>\n<h3 id=\"C-堆-优先队列：默认大顶堆（priority-queue）：\"><a href=\"#C-堆-优先队列：默认大顶堆（priority-queue）：\" class=\"headerlink\" title=\"C++ 堆&#x2F;优先队列：默认大顶堆（priority_queue）：\"></a><strong>C++ 堆&#x2F;优先队列</strong>：默认大顶堆（<code>priority_queue</code>）：</h3><figure class=\"highlight cpp\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">std::priority_queue&lt;<span class=\"type\">int</span>&gt; pq;</span><br><span class=\"line\">pq.<span class=\"built_in\">push</span>(<span class=\"number\">5</span>);</span><br><span class=\"line\">pq.<span class=\"built_in\">push</span>(<span class=\"number\">3</span>);</span><br><span class=\"line\"><span class=\"type\">int</span> top = pq.<span class=\"built_in\">top</span>(); <span class=\"comment\">// 5 (最大值)</span></span><br><span class=\"line\">pq.<span class=\"built_in\">pop</span>();</span><br></pre></td></tr></table></figure>\n\n<h3 id=\"Python-堆（heapq-最小堆）：\"><a href=\"#Python-堆（heapq-最小堆）：\" class=\"headerlink\" title=\"Python 堆（heapq 最小堆）：\"></a><strong>Python 堆</strong>（<code>heapq</code> 最小堆）：</h3><figure class=\"highlight python\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">import</span> heapq</span><br><span class=\"line\">heap = []</span><br><span class=\"line\">heapq.heappush(heap, <span class=\"number\">3</span>)</span><br><span class=\"line\">heapq.heappush(heap, <span class=\"number\">5</span>)</span><br><span class=\"line\">top = heapq.heappop(heap)  <span class=\"comment\"># 3 (最小值)</span></span><br></pre></td></tr></table></figure>\n\n<ul>\n<li>如果需要大顶堆，可插入负值或使用第三方实现。</li>\n</ul>\n<h3 id=\"堆排序\"><a href=\"#堆排序\" class=\"headerlink\" title=\"堆排序\"></a>堆排序</h3><blockquote>\n<p><a href=\"https://algorithm-visualizer.org/brute-force/heapsort\">Brute Force Heapsort</a></p>\n</blockquote>\n<p>堆排序是一种高效的、基于比较的排序算法。它利用了堆这种数据结构的特性。基本思想是：</p>\n<ol>\n<li><p>**建堆 (Heapify)**：将待排序的序列构建成一个大顶堆（或小顶堆）。此时，堆顶元素就是整个序列的最大值（或最小值）。</p>\n</li>\n<li><p>**排序 (Sort)**：</p>\n<ul>\n<li>将堆顶元素与序列末尾的元素交换。</li>\n<li>此时，序列末尾的元素即为最大（或最小）值，已经处于正确排序位置。</li>\n<li>将剩余的 n-1 个元素重新调整为一个堆。</li>\n<li>重复此过程，直到所有元素都排序完毕。</li>\n</ul>\n</li>\n</ol>\n<p>堆排序的平均时间复杂度和最坏时间复杂度都是 O(nlogn)。</p>\n<h4 id=\"C-实现堆排序\"><a href=\"#C-实现堆排序\" class=\"headerlink\" title=\"C++ 实现堆排序\"></a>C++ 实现堆排序</h4><p>在 C++ 中，可以利用标准库 <code>&lt;algorithm&gt;</code> 中提供的堆操作函数来方便地实现堆排序。</p>\n<ul>\n<li><code>std::make_heap(first, last)</code>: 将指定范围 <code>[first, last)</code> 内的元素重新排列，使其成为一个大顶堆。</li>\n<li><code>std::sort_heap(first, last)</code>: 将一个已经建好的堆 <code>[first, last)</code> 进行排序。它会重复地将堆顶元素（最大值）移动到序列的末尾，并重新调整剩余部分为堆。</li>\n</ul>\n<p>C++</p>\n<figure class=\"highlight cpp\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">#<span class=\"keyword\">include</span> <span class=\"string\">&lt;iostream&gt;</span></span></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"keyword\">include</span> <span class=\"string\">&lt;vector&gt;</span></span></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"keyword\">include</span> <span class=\"string\">&lt;algorithm&gt;</span> <span class=\"comment\">// 包含 make_heap, sort_heap</span></span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"type\">void</span> <span class=\"title\">print_vector</span><span class=\"params\">(<span class=\"type\">const</span> std::vector&lt;<span class=\"type\">int</span>&gt;&amp; vec)</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">for</span> (<span class=\"type\">int</span> val : vec) &#123;</span><br><span class=\"line\">        std::cout &lt;&lt; val &lt;&lt; <span class=\"string\">&quot; &quot;</span>;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    std::cout &lt;&lt; std::endl;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"type\">int</span> <span class=\"title\">main</span><span class=\"params\">()</span> </span>&#123;</span><br><span class=\"line\">    std::vector&lt;<span class=\"type\">int</span>&gt; v = &#123;<span class=\"number\">3</span>, <span class=\"number\">5</span>, <span class=\"number\">1</span>, <span class=\"number\">8</span>, <span class=\"number\">4</span>, <span class=\"number\">7</span>, <span class=\"number\">2</span>&#125;;</span><br><span class=\"line\">    std::cout &lt;&lt; <span class=\"string\">&quot;Original vector: &quot;</span>;</span><br><span class=\"line\">    <span class=\"built_in\">print_vector</span>(v);</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\">// 1. 将 vector 转换成大顶堆</span></span><br><span class=\"line\">    std::<span class=\"built_in\">make_heap</span>(v.<span class=\"built_in\">begin</span>(), v.<span class=\"built_in\">end</span>());</span><br><span class=\"line\">    std::cout &lt;&lt; <span class=\"string\">&quot;After make_heap (top is max): &quot;</span> &lt;&lt; v.<span class=\"built_in\">front</span>() &lt;&lt; std::endl;</span><br><span class=\"line\">  </span><br><span class=\"line\">    <span class=\"comment\">// 2. 对堆进行排序 (结果为升序)</span></span><br><span class=\"line\">    std::<span class=\"built_in\">sort_heap</span>(v.<span class=\"built_in\">begin</span>(), v.<span class=\"built_in\">end</span>());</span><br><span class=\"line\">  </span><br><span class=\"line\">    std::cout &lt;&lt; <span class=\"string\">&quot;Sorted vector: &quot;</span>;</span><br><span class=\"line\">    <span class=\"built_in\">print_vector</span>(v); <span class=\"comment\">// 输出: 1 2 3 4 5 7 8</span></span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">return</span> <span class=\"number\">0</span>;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<h4 id=\"Python-实现堆排序\"><a href=\"#Python-实现堆排序\" class=\"headerlink\" title=\"Python 实现堆排序\"></a>Python 实现堆排序</h4><p>Python 的 <code>heapq</code> 模块本身不直接提供一个完整的 <code>heapsort</code> 函数，但我们可以很容易地利用其 <code>heappush</code> 和 <code>heappop</code> 来实现。因为 <code>heapq</code> 是最小堆，所以 <code>heappop</code> 总是弹出最小值，天然适合用于升序排序。</p>\n<figure class=\"highlight python\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">import</span> heapq</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">def</span> <span class=\"title function_\">heapsort_asc</span>(<span class=\"params\">iterable</span>):</span><br><span class=\"line\">    <span class=\"string\">&quot;&quot;&quot;</span></span><br><span class=\"line\"><span class=\"string\">    使用 heapq 实现升序排序</span></span><br><span class=\"line\"><span class=\"string\">    &quot;&quot;&quot;</span></span><br><span class=\"line\">    h = []</span><br><span class=\"line\">    <span class=\"comment\"># 将所有元素压入堆中</span></span><br><span class=\"line\">    <span class=\"keyword\">for</span> value <span class=\"keyword\">in</span> iterable:</span><br><span class=\"line\">        heapq.heappush(h, value)</span><br><span class=\"line\">    <span class=\"comment\"># 依次弹出堆中最小的元素，构成有序列表</span></span><br><span class=\"line\">    <span class=\"keyword\">return</span> [heapq.heappop(h) <span class=\"keyword\">for</span> _ <span class=\"keyword\">in</span> <span class=\"built_in\">range</span>(<span class=\"built_in\">len</span>(h))]</span><br><span class=\"line\"></span><br><span class=\"line\">data = [<span class=\"number\">3</span>, <span class=\"number\">5</span>, <span class=\"number\">1</span>, <span class=\"number\">8</span>, <span class=\"number\">4</span>, <span class=\"number\">7</span>, <span class=\"number\">2</span>]</span><br><span class=\"line\"><span class=\"built_in\">print</span>(<span class=\"string\">f&quot;Original list: <span class=\"subst\">&#123;data&#125;</span>&quot;</span>)</span><br><span class=\"line\"></span><br><span class=\"line\">sorted_data = heapsort_asc(data)</span><br><span class=\"line\"><span class=\"built_in\">print</span>(<span class=\"string\">f&quot;Sorted list (ascending): <span class=\"subst\">&#123;sorted_data&#125;</span>&quot;</span>) <span class=\"comment\"># 输出: [1, 2, 3, 4, 5, 7, 8]</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\"># 原地堆排序 (In-place Heap Sort)</span></span><br><span class=\"line\"><span class=\"comment\"># 这更接近于堆排序的经典实现</span></span><br><span class=\"line\"><span class=\"keyword\">def</span> <span class=\"title function_\">heapsort_inplace</span>(<span class=\"params\">arr</span>):</span><br><span class=\"line\">    n = <span class=\"built_in\">len</span>(arr)</span><br><span class=\"line\">    <span class=\"comment\"># 1. 构建大顶堆 (从最后一个非叶子节点开始)</span></span><br><span class=\"line\">    <span class=\"comment\"># 注意：heapq 是最小堆，所以这里通过对负数操作来模拟大顶堆</span></span><br><span class=\"line\">    <span class=\"comment\"># 或者我们手动实现大顶堆的 sift_down</span></span><br><span class=\"line\">    <span class=\"comment\"># 为了简单，我们还是用 heapq 来理解，但传统实现更高效</span></span><br><span class=\"line\">    h = []</span><br><span class=\"line\">    <span class=\"keyword\">for</span> x <span class=\"keyword\">in</span> arr:</span><br><span class=\"line\">        heapq.heappush(h, x)</span><br><span class=\"line\">    arr[:] = [heapq.heappop(h) <span class=\"keyword\">for</span> _ <span class=\"keyword\">in</span> <span class=\"built_in\">range</span>(n)]</span><br><span class=\"line\">    <span class=\"keyword\">return</span> arr</span><br><span class=\"line\"></span><br><span class=\"line\">data_inplace = [<span class=\"number\">3</span>, <span class=\"number\">5</span>, <span class=\"number\">1</span>, <span class=\"number\">8</span>, <span class=\"number\">4</span>, <span class=\"number\">7</span>, <span class=\"number\">2</span>]</span><br><span class=\"line\">heapsort_inplace(data_inplace)</span><br><span class=\"line\"><span class=\"built_in\">print</span>(<span class=\"string\">f&quot;In-place sorted list: <span class=\"subst\">&#123;data_inplace&#125;</span>&quot;</span>)</span><br></pre></td></tr></table></figure>\n\n<p>栈和堆（优先队列）各有特点：</p>\n<ul>\n<li><strong>数据组织</strong>：栈是线性的、受限的结构，只能从一端操作；堆是树形结构，可快速获取最大或最小元素。</li>\n<li><strong>访问效率</strong>：栈操作简单开销小；堆插入&#x2F;删除需维护堆序（O(log n)）。</li>\n<li><strong>应用场景</strong>：栈适合管理临时状态（如函数调用栈、表达式求值、撤销操作）；堆（优先队列）适合按优先级处理元素，如操作系统任务调度、网络请求优先级、算法中的最佳-优先搜索等。</li>\n</ul>\n<h2 id=\"内存分配视角\"><a href=\"#内存分配视角\" class=\"headerlink\" title=\"内存分配视角\"></a>内存分配视角</h2><p>在程序运行时，内存通常分为<strong>代码区</strong>、<strong>数据区</strong>、<strong>堆区</strong>和<strong>栈区</strong>。其中：</p>\n<ul>\n<li><strong>栈区</strong>：由系统自动管理，随函数调用而增长，每次函数调用时分配空间给局部变量、函数参数和返回地址。函数返回时，这些空间自动回收。栈分配速度快、开销低，但空间有限（常见几 MB），且每个线程都有独立的栈空间。如果栈空间不足，会导致栈溢出错误。</li>\n<li><strong>堆区</strong>：用于动态内存分配，程序员（或运行时）在运行时使用 <code>new</code>&#x2F;<code>malloc</code> 等申请内存，由程序员 <code>delete</code>&#x2F;<code>free</code> 释放（在 Python&#x2F;Java 等语言由垃圾回收自动释放）。堆的可用空间远大于栈，存放<strong>动态对象</strong>。堆内存碎片化的风险更高：频繁的分配和释放可能将大块连续内存切割成许多小碎片，降低利用率。</li>\n<li><strong>静态&#x2F;全局区</strong>：编译时分配，程序运行前即确定，存放全局变量、静态变量和常量，在程序整个生命周期存在。</li>\n</ul>\n<p><strong>分配方式</strong>：栈的分配和回收速度极快，操作由 CPU 指令自动完成；堆的分配开销较大，一般需要额外的内存管理算法（如自由链表或分代收集），在 C++ 中需要程序员手动释放。Python 中所有对象都分配在堆上，解释器通过引用计数和垃圾回收来管理。</p>\n<p><strong>访问效率</strong>：由于栈内存连续、分配固定，因此访问和分配速度更高。堆内存由多个块组成，需额外指针管理，因而略慢于栈访问。此外，栈是线程私有的（线程安全），而堆是所有线程共享的（需注意并发安全）。</p>\n<ul>\n<li><strong>C++ 栈 vs 堆 分配</strong>：</li>\n</ul>\n<figure class=\"highlight cpp\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"type\">void</span> <span class=\"title\">func</span><span class=\"params\">()</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"type\">int</span> a = <span class=\"number\">10</span>;            <span class=\"comment\">// 分配在栈上</span></span><br><span class=\"line\">    <span class=\"type\">int</span> *p = <span class=\"keyword\">new</span> <span class=\"built_in\">int</span>(<span class=\"number\">20</span>);  <span class=\"comment\">// 分配在堆上</span></span><br><span class=\"line\">    <span class=\"comment\">// ...</span></span><br><span class=\"line\">    <span class=\"keyword\">delete</span> p;              <span class=\"comment\">// 手动释放堆内存</span></span><br><span class=\"line\">&#125; <span class=\"comment\">// 函数返回时，a 的栈空间自动释放，若忘了 delete，则 p 指向的内存泄露</span></span><br></pre></td></tr></table></figure>\n\n<ul>\n<li><strong>Python 对象分配</strong>：</li>\n</ul>\n<figure class=\"highlight python\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">def</span> <span class=\"title function_\">func</span>():</span><br><span class=\"line\">    a = <span class=\"number\">10</span>             <span class=\"comment\"># 10 是整数对象，存储在堆中；a 是栈帧内的局部引用</span></span><br><span class=\"line\">    b = [<span class=\"number\">1</span>, <span class=\"number\">2</span>, <span class=\"number\">3</span>]      <span class=\"comment\"># 列表对象在堆上分配</span></span><br><span class=\"line\">    <span class=\"comment\"># 变量 a, b 是存放在函数调用栈帧中的引用，当函数结束，这些引用消失</span></span><br></pre></td></tr></table></figure>\n\n<ul>\n<li>Python 不需要显示释放内存，垃圾回收自动回收无用对象。</li>\n</ul>\n<h2 id=\"典型应用场景\"><a href=\"#典型应用场景\" class=\"headerlink\" title=\"典型应用场景\"></a>典型应用场景</h2><h3 id=\"函数调用与返回\"><a href=\"#函数调用与返回\" class=\"headerlink\" title=\"函数调用与返回\"></a>函数调用与返回</h3><p>当程序调用一个函数时，当前上下文（包括当前函数的局部变量、返回地址、CPU 寄存器等）会被“压栈（push）”到栈上；函数执行完成后，栈顶信息被“弹栈（pop）”，程序自动返回调用点并恢复先前状态。这种机制正是栈的典型应用。</p>\n<h4 id=\"C-示例\"><a href=\"#C-示例\" class=\"headerlink\" title=\"C++ 示例\"></a>C++ 示例</h4><figure class=\"highlight cpp\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">#<span class=\"keyword\">include</span> <span class=\"string\">&lt;iostream&gt;</span></span></span><br><span class=\"line\"><span class=\"comment\">// 一个示例函数，用于演示栈帧形成</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"type\">int</span> <span class=\"title\">factorial</span><span class=\"params\">(<span class=\"type\">int</span> n)</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (n &lt;= <span class=\"number\">1</span>) &#123;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> <span class=\"number\">1</span>;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"comment\">// 调用 factorial(n-1) 前，会把当前的 n、返回地址等信息压入栈</span></span><br><span class=\"line\">    <span class=\"keyword\">return</span> n * <span class=\"built_in\">factorial</span>(n - <span class=\"number\">1</span>);</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"function\"><span class=\"type\">int</span> <span class=\"title\">main</span><span class=\"params\">()</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"type\">int</span> x = <span class=\"number\">5</span>;</span><br><span class=\"line\">    std::cout &lt;&lt; <span class=\"string\">&quot;factorial(&quot;</span> &lt;&lt; x &lt;&lt; <span class=\"string\">&quot;) = &quot;</span> &lt;&lt; <span class=\"built_in\">factorial</span>(x) &lt;&lt; std::endl;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> <span class=\"number\">0</span>;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<ul>\n<li>每次调用 <code>factorial</code> 时，当前函数的局部变量（如 <code>n</code>）和返回地址会压入栈；函数结束时，栈帧被弹出，返回到上一级调用点。</li>\n</ul>\n<h4 id=\"Python-示例\"><a href=\"#Python-示例\" class=\"headerlink\" title=\"Python 示例\"></a>Python 示例</h4><figure class=\"highlight python\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">def</span> <span class=\"title function_\">factorial</span>(<span class=\"params\">n</span>):</span><br><span class=\"line\">    <span class=\"keyword\">if</span> n &lt;= <span class=\"number\">1</span>:</span><br><span class=\"line\">        <span class=\"keyword\">return</span> <span class=\"number\">1</span></span><br><span class=\"line\">    <span class=\"comment\"># 递归调用时，Python 会将当前函数帧压入调用栈</span></span><br><span class=\"line\">    <span class=\"keyword\">return</span> n * factorial(n - <span class=\"number\">1</span>)</span><br><span class=\"line\"><span class=\"keyword\">if</span> </span><br><span class=\"line\">name</span><br><span class=\"line\"> == <span class=\"string\">&quot;</span></span><br><span class=\"line\"><span class=\"string\">__main__</span></span><br><span class=\"line\"><span class=\"string\">&quot;</span>:</span><br><span class=\"line\">    x = <span class=\"number\">5</span></span><br><span class=\"line\">    <span class=\"built_in\">print</span>(<span class=\"string\">f&quot;factorial(<span class=\"subst\">&#123;x&#125;</span>) =&quot;</span>, factorial(x))</span><br></pre></td></tr></table></figure>\n\n<ul>\n<li>Python 解释器内部也维护一个“调用栈”，每个函数调用都会在栈中创建一个帧（Frame），存放局部变量和执行状态。</li>\n</ul>\n<hr>\n<h3 id=\"内存管理（局部变量与函数参数）\"><a href=\"#内存管理（局部变量与函数参数）\" class=\"headerlink\" title=\"内存管理（局部变量与函数参数）\"></a>内存管理（局部变量与函数参数）</h3><h4 id=\"说明\"><a href=\"#说明\" class=\"headerlink\" title=\"说明\"></a>说明</h4><ul>\n<li><strong>栈分配</strong>：编译器在编译期或运行期自动为每个函数分配固定的栈空间，用于存储局部变量和函数参数。函数结束时，这些空间会自动释放，无需程序员手动管理。</li>\n<li><strong>堆分配</strong>：程序员可在运行时动态向操作系统请求内存，使用 <code>new</code>&#x2F;<code>malloc</code>（C++）或创建对象（Python）。这些内存由程序员负责释放（或由垃圾回收器回收）。</li>\n</ul>\n<h4 id=\"C-示例：栈-vs-堆\"><a href=\"#C-示例：栈-vs-堆\" class=\"headerlink\" title=\"C++ 示例：栈 vs 堆\"></a>C++ 示例：栈 vs 堆</h4><figure class=\"highlight cpp\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">#<span class=\"keyword\">include</span> <span class=\"string\">&lt;iostream&gt;</span></span></span><br><span class=\"line\"><span class=\"function\"><span class=\"type\">void</span> <span class=\"title\">stackExample</span><span class=\"params\">()</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"type\">int</span> a = <span class=\"number\">10</span>;             <span class=\"comment\">// 分配在栈上</span></span><br><span class=\"line\">    <span class=\"type\">int</span> b[<span class=\"number\">100</span>];             <span class=\"comment\">// 数组也分配在栈上</span></span><br><span class=\"line\">    std::cout &lt;&lt; <span class=\"string\">&quot;a = &quot;</span> &lt;&lt; a &lt;&lt; std::endl;</span><br><span class=\"line\">    std::cout &lt;&lt; <span class=\"string\">&quot;b[0] = &quot;</span> &lt;&lt; b[<span class=\"number\">0</span>] &lt;&lt; std::endl;</span><br><span class=\"line\">&#125; <span class=\"comment\">// 函数结束时，a 和 b 的栈空间自动释放</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"type\">void</span> <span class=\"title\">heapExample</span><span class=\"params\">()</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"type\">int</span> *p = <span class=\"keyword\">new</span> <span class=\"built_in\">int</span>(<span class=\"number\">20</span>);   <span class=\"comment\">// 在堆上分配一个 int</span></span><br><span class=\"line\">    <span class=\"type\">int</span> *arr = <span class=\"keyword\">new</span> <span class=\"type\">int</span>[<span class=\"number\">100</span>];<span class=\"comment\">// 在堆上分配一个大小为 100 的数组</span></span><br><span class=\"line\">    std::cout &lt;&lt; <span class=\"string\">&quot;*p = &quot;</span> &lt;&lt; *p &lt;&lt; std::endl;</span><br><span class=\"line\">    std::cout &lt;&lt; <span class=\"string\">&quot;arr[0] = &quot;</span> &lt;&lt; arr[<span class=\"number\">0</span>] &lt;&lt; std::endl;</span><br><span class=\"line\">    <span class=\"keyword\">delete</span> p;               <span class=\"comment\">// 释放堆内存</span></span><br><span class=\"line\">    <span class=\"keyword\">delete</span>[] arr;           <span class=\"comment\">// 释放数组</span></span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"function\"><span class=\"type\">int</span> <span class=\"title\">main</span><span class=\"params\">()</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"built_in\">stackExample</span>();</span><br><span class=\"line\">    <span class=\"built_in\">heapExample</span>();</span><br><span class=\"line\">    <span class=\"keyword\">return</span> <span class=\"number\">0</span>;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<ul>\n<li><code>stackExample</code>：变量 <code>a</code> 和数组 <code>b</code> 分配在栈上，由系统自动分配与回收。</li>\n<li><code>heapExample</code>：使用 <code>new</code> 在堆上分配内存，需要手动调用 <code>delete</code>&#x2F;<code>delete[]</code> 来释放，否则会发生内存泄漏。</li>\n</ul>\n<h4 id=\"Python-示例：对象分配在堆上\"><a href=\"#Python-示例：对象分配在堆上\" class=\"headerlink\" title=\"Python 示例：对象分配在堆上\"></a>Python 示例：对象分配在堆上</h4><figure class=\"highlight python\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">def</span> <span class=\"title function_\">memory_example</span>():</span><br><span class=\"line\">    a = <span class=\"number\">10</span>            <span class=\"comment\"># 整数对象 10 存储在堆上，a 是栈帧中的一个引用</span></span><br><span class=\"line\">    lst = [<span class=\"number\">1</span>, <span class=\"number\">2</span>, <span class=\"number\">3</span>]   <span class=\"comment\"># 列表对象存储在堆上，lst 引用保存在栈帧</span></span><br><span class=\"line\">    <span class=\"built_in\">print</span>(a, lst)</span><br><span class=\"line\"><span class=\"keyword\">if</span> </span><br><span class=\"line\">name</span><br><span class=\"line\"> == <span class=\"string\">&quot;</span></span><br><span class=\"line\"><span class=\"string\">__main__</span></span><br><span class=\"line\"><span class=\"string\">&quot;</span>:</span><br><span class=\"line\">    memory_example()</span><br><span class=\"line\">    <span class=\"comment\"># Python 通过引用计数和垃圾回收自动释放不再使用的对象</span></span><br></pre></td></tr></table></figure>\n\n<ul>\n<li>在 Python 中，所有对象都分配在堆上，局部变量仅是对这些对象的引用，保存在栈帧中。函数退出时，局部引用消失，引用计数可能降为 0，垃圾回收器会回收对象。</li>\n</ul>\n<hr>\n<h3 id=\"表达式求值（逆波兰表达式）\"><a href=\"#表达式求值（逆波兰表达式）\" class=\"headerlink\" title=\"表达式求值（逆波兰表达式）\"></a>表达式求值（逆波兰表达式）</h3><h4 id=\"说明-1\"><a href=\"#说明-1\" class=\"headerlink\" title=\"说明\"></a>说明</h4><p>逆波兰表达式（后缀表达式）无需括号即可明确运算顺序，评估过程中需要一个栈来保存操作数、临时结果。</p>\n<ul>\n<li>遇到操作数时，压栈</li>\n<li>遇到运算符时，从栈中弹出相应数量的操作数进行计算，并将结果压回栈</li>\n<li>最后栈顶即为运算结果</li>\n</ul>\n<h4 id=\"C-示例（仅支持-四则运算）\"><a href=\"#C-示例（仅支持-四则运算）\" class=\"headerlink\" title=\"C++ 示例（仅支持 + - * / 四则运算）\"></a>C++ 示例（仅支持 <code>+ - * /</code> 四则运算）</h4><figure class=\"highlight cpp\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">#<span class=\"keyword\">include</span> <span class=\"string\">&lt;iostream&gt;</span></span></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"keyword\">include</span> <span class=\"string\">&lt;stack&gt;</span></span></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"keyword\">include</span> <span class=\"string\">&lt;sstream&gt;</span></span></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"keyword\">include</span> <span class=\"string\">&lt;string&gt;</span></span></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"keyword\">include</span> <span class=\"string\">&lt;vector&gt;</span></span></span><br><span class=\"line\"><span class=\"comment\">// 将字符串拆分为逆波兰表达式的 tokens</span></span><br><span class=\"line\"><span class=\"function\">std::vector&lt;std::string&gt; <span class=\"title\">tokenize</span><span class=\"params\">(<span class=\"type\">const</span> std::string &amp;expr)</span> </span>&#123;</span><br><span class=\"line\">    std::vector&lt;std::string&gt; tokens;</span><br><span class=\"line\">    <span class=\"function\">std::istringstream <span class=\"title\">iss</span><span class=\"params\">(expr)</span></span>;</span><br><span class=\"line\">    std::string token;</span><br><span class=\"line\">    <span class=\"keyword\">while</span> (iss &gt;&gt; token) &#123;</span><br><span class=\"line\">        tokens.<span class=\"built_in\">push_back</span>(token);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> tokens;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"function\"><span class=\"type\">int</span> <span class=\"title\">evalRPN</span><span class=\"params\">(<span class=\"type\">const</span> std::vector&lt;std::string&gt; &amp;tokens)</span> </span>&#123;</span><br><span class=\"line\">    std::stack&lt;<span class=\"type\">int</span>&gt; st;</span><br><span class=\"line\">    <span class=\"keyword\">for</span> (<span class=\"type\">const</span> <span class=\"keyword\">auto</span> &amp;tk : tokens) &#123;</span><br><span class=\"line\">        <span class=\"keyword\">if</span> (tk == <span class=\"string\">&quot;+&quot;</span> || tk == <span class=\"string\">&quot;-&quot;</span> || tk == <span class=\"string\">&quot;</span></span><br><span class=\"line\"><span class=\"string\">_&quot;</span> || tk == <span class=\"string\">&quot;/&quot;</span>) &#123;</span><br><span class=\"line\">            <span class=\"type\">int</span> b = st.<span class=\"built_in\">top</span>(); st.<span class=\"built_in\">pop</span>();</span><br><span class=\"line\">            <span class=\"type\">int</span> a = st.<span class=\"built_in\">top</span>(); st.<span class=\"built_in\">pop</span>();</span><br><span class=\"line\">            <span class=\"type\">int</span> res = <span class=\"number\">0</span>;</span><br><span class=\"line\">            <span class=\"keyword\">if</span> (tk == <span class=\"string\">&quot;+&quot;</span>) res = a + b;</span><br><span class=\"line\">            <span class=\"keyword\">else</span> <span class=\"keyword\">if</span> (tk == <span class=\"string\">&quot;-&quot;</span>) res = a - b;</span><br><span class=\"line\"><span class=\"function\">_*            <span class=\"keyword\">else</span> <span class=\"title\">if</span> <span class=\"params\">(tk == <span class=\"string\">&quot;*</span></span></span></span><br><span class=\"line\"><span class=\"string\"><span class=\"params\"><span class=\"function\">&quot;</span>)</span> res </span>= a * b;</span><br><span class=\"line\">            <span class=\"keyword\">else</span> <span class=\"keyword\">if</span> (tk == <span class=\"string\">&quot;/&quot;</span>) res = a / b;</span><br><span class=\"line\">            st.<span class=\"built_in\">push</span>(res);</span><br><span class=\"line\">        &#125; <span class=\"keyword\">else</span> &#123;</span><br><span class=\"line\">            st.<span class=\"built_in\">push</span>(std::<span class=\"built_in\">stoi</span>(tk));</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> st.<span class=\"built_in\">top</span>();</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"function\"><span class=\"type\">int</span> <span class=\"title\">main</span><span class=\"params\">()</span> </span>&#123;</span><br><span class=\"line\">    std::string expr = <span class=\"string\">&quot;3 4 + 2 * 7 /&quot;</span>;</span><br><span class=\"line\">    <span class=\"comment\">// 对应中缀: ((3 + 4) * 2) / 7 = 2</span></span><br><span class=\"line\">    <span class=\"keyword\">auto</span> tokens = <span class=\"built_in\">tokenize</span>(expr);</span><br><span class=\"line\">    std::cout &lt;&lt; <span class=\"string\">&quot;Result: &quot;</span> &lt;&lt; <span class=\"built_in\">evalRPN</span>(tokens) &lt;&lt; std::endl;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> <span class=\"number\">0</span>;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<ul>\n<li>将逆波兰表达式拆为 token 数组，遍历时用 <code>std::stack&lt;int&gt;</code> 存放操作数。每遇运算符，弹出两个操作数，计算后将结果压回栈。</li>\n</ul>\n<h4 id=\"Python-示例-1\"><a href=\"#Python-示例-1\" class=\"headerlink\" title=\"Python 示例\"></a>Python 示例</h4><figure class=\"highlight python\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">def</span> <span class=\"title function_\">eval_rpn</span>(<span class=\"params\">tokens</span>):</span><br><span class=\"line\">    stack = []</span><br><span class=\"line\">    <span class=\"keyword\">for</span> tk <span class=\"keyword\">in</span> tokens:</span><br><span class=\"line\">        <span class=\"keyword\">if</span> tk <span class=\"keyword\">in</span> &#123;<span class=\"string\">&quot;+&quot;</span>, <span class=\"string\">&quot;-&quot;</span>, <span class=\"string\">&quot;</span></span><br><span class=\"line\"><span class=\"string\">_&quot;</span>, <span class=\"string\">&quot;/&quot;</span>&#125;:</span><br><span class=\"line\">            b = stack.pop()</span><br><span class=\"line\">            a = stack.pop()</span><br><span class=\"line\">            <span class=\"keyword\">if</span> tk == <span class=\"string\">&quot;+&quot;</span>:</span><br><span class=\"line\">                stack.append(a + b)</span><br><span class=\"line\">            <span class=\"keyword\">elif</span> tk == <span class=\"string\">&quot;-&quot;</span>:</span><br><span class=\"line\">                stack.append(a - b)</span><br><span class=\"line\">_*            <span class=\"keyword\">elif</span> tk == <span class=\"string\">&quot;*</span></span><br><span class=\"line\"><span class=\"string\">&quot;</span>:</span><br><span class=\"line\">                stack.append(a * b)</span><br><span class=\"line\">            <span class=\"keyword\">else</span>:</span><br><span class=\"line\">                <span class=\"comment\"># 对于除法，需要注意 Python 的整除与 C++ 不同</span></span><br><span class=\"line\">                stack.append(<span class=\"built_in\">int</span>(a / b))  <span class=\"comment\"># 向零取整</span></span><br><span class=\"line\">        <span class=\"keyword\">else</span>:</span><br><span class=\"line\">            stack.append(<span class=\"built_in\">int</span>(tk))</span><br><span class=\"line\">    <span class=\"keyword\">return</span> stack.pop()</span><br><span class=\"line\"><span class=\"keyword\">if</span> </span><br><span class=\"line\">name</span><br><span class=\"line\"> == <span class=\"string\">&quot;</span></span><br><span class=\"line\"><span class=\"string\">__main__</span></span><br><span class=\"line\"><span class=\"string\">&quot;</span>:</span><br><span class=\"line\">    expr = <span class=\"string\">&quot;3 4 + 2 * 7 /&quot;</span>.split()</span><br><span class=\"line\">    <span class=\"built_in\">print</span>(<span class=\"string\">&quot;Result:&quot;</span>, eval_rpn(expr))  <span class=\"comment\"># 2</span></span><br></pre></td></tr></table></figure>\n\n<ul>\n<li>Python 用列表 <code>stack</code> 模拟栈，操作与 C++ 版本一致。</li>\n</ul>\n<hr>\n<h3 id=\"撤销（Undo）操作\"><a href=\"#撤销（Undo）操作\" class=\"headerlink\" title=\"撤销（Undo）操作\"></a>撤销（Undo）操作</h3><p>许多应用需要实现“撤销”功能，此时可将用户操作或状态快照依次压入栈，用户点击“撤销”时，再次从栈顶弹出即可恢复到上一次状态。</p>\n<h4 id=\"Python-示例：文本编辑器简易撤销栈\"><a href=\"#Python-示例：文本编辑器简易撤销栈\" class=\"headerlink\" title=\"Python 示例：文本编辑器简易撤销栈\"></a>Python 示例：文本编辑器简易撤销栈</h4><figure class=\"highlight python\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">class</span> <span class=\"title class_\">TextEditor</span>:</span><br><span class=\"line\">    <span class=\"keyword\">def</span> </span><br><span class=\"line\"><span class=\"title function_\">__init__</span></span><br><span class=\"line\">(<span class=\"variable language_\">self</span>):</span><br><span class=\"line\">        <span class=\"variable language_\">self</span>.text = <span class=\"string\">&quot;&quot;</span></span><br><span class=\"line\">        <span class=\"variable language_\">self</span>.undo_stack = []  <span class=\"comment\"># 存放历史状态</span></span><br><span class=\"line\">    <span class=\"keyword\">def</span> <span class=\"title function_\">write</span>(<span class=\"params\">self, s</span>):</span><br><span class=\"line\">        <span class=\"comment\"># 在写新内容前，将当前状态压栈</span></span><br><span class=\"line\">        <span class=\"variable language_\">self</span>.undo_stack.append(<span class=\"variable language_\">self</span>.text)</span><br><span class=\"line\">        <span class=\"variable language_\">self</span>.text += s</span><br><span class=\"line\">    <span class=\"keyword\">def</span> <span class=\"title function_\">undo</span>(<span class=\"params\">self</span>):</span><br><span class=\"line\">        <span class=\"keyword\">if</span> <span class=\"variable language_\">self</span>.undo_stack:</span><br><span class=\"line\">            <span class=\"variable language_\">self</span>.text = <span class=\"variable language_\">self</span>.undo_stack.pop()</span><br><span class=\"line\">        <span class=\"keyword\">else</span>:</span><br><span class=\"line\">            <span class=\"built_in\">print</span>(<span class=\"string\">&quot;Nothing to undo&quot;</span>)</span><br><span class=\"line\">    <span class=\"keyword\">def</span> <span class=\"title function_\">show</span>(<span class=\"params\">self</span>):</span><br><span class=\"line\">        <span class=\"built_in\">print</span>(<span class=\"string\">f&quot;Current Text: &#x27;<span class=\"subst\">&#123;self.text&#125;</span>&#x27;&quot;</span>)</span><br><span class=\"line\"><span class=\"keyword\">if</span> </span><br><span class=\"line\">name</span><br><span class=\"line\"> == <span class=\"string\">&quot;</span></span><br><span class=\"line\"><span class=\"string\">__main__</span></span><br><span class=\"line\"><span class=\"string\">&quot;</span>:</span><br><span class=\"line\">    editor = TextEditor()</span><br><span class=\"line\">    editor.write(<span class=\"string\">&quot;Hello&quot;</span>)</span><br><span class=\"line\">    editor.show()        <span class=\"comment\"># Hello</span></span><br><span class=\"line\">    editor.write(<span class=\"string\">&quot;, World!&quot;</span>)</span><br><span class=\"line\">    editor.show()        <span class=\"comment\"># Hello, World!</span></span><br><span class=\"line\">    editor.undo()</span><br><span class=\"line\">    editor.show()        <span class=\"comment\"># Hello</span></span><br><span class=\"line\">    editor.undo()</span><br><span class=\"line\">    editor.show()        <span class=\"comment\"># (空字符串)</span></span><br></pre></td></tr></table></figure>\n\n<ul>\n<li>每次写入之前，将 <code>self.text</code> 的旧值压入 <code>undo_stack</code>。调用 <code>undo()</code> 时，将栈顶字符串弹出并恢复。</li>\n</ul>\n<hr>\n<h3 id=\"浏览器后退功能\"><a href=\"#浏览器后退功能\" class=\"headerlink\" title=\"浏览器后退功能\"></a>浏览器后退功能</h3><p>浏览器维护一个“历史页面访问栈”：</p>\n<ul>\n<li>用户访问新页面时，将当前页面地址压入“后退栈”，同时清空“前进栈”</li>\n<li>点击“后退”时，将当前页面压入“前进栈”，并从“后退栈”弹出最近访问的页面</li>\n<li>点击“前进”时，则反向操作</li>\n</ul>\n<h4 id=\"Python-示例：简易浏览器历史\"><a href=\"#Python-示例：简易浏览器历史\" class=\"headerlink\" title=\"Python 示例：简易浏览器历史\"></a>Python 示例：简易浏览器历史</h4><figure class=\"highlight python\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">class</span> <span class=\"title class_\">BrowserHistory</span>:</span><br><span class=\"line\">    <span class=\"keyword\">def</span> <span class=\"title function_\">__init__</span>(<span class=\"params\">self, homepage: <span class=\"built_in\">str</span></span>):</span><br><span class=\"line\">        <span class=\"variable language_\">self</span>.back_stack = []     <span class=\"comment\"># 后退栈</span></span><br><span class=\"line\">        <span class=\"variable language_\">self</span>.forward_stack = []  <span class=\"comment\"># 前进栈</span></span><br><span class=\"line\">        <span class=\"variable language_\">self</span>.current = homepage  <span class=\"comment\"># 当前页面</span></span><br><span class=\"line\">    <span class=\"keyword\">def</span> <span class=\"title function_\">visit</span>(<span class=\"params\">self, url: <span class=\"built_in\">str</span></span>):</span><br><span class=\"line\">        <span class=\"variable language_\">self</span>.back_stack.append(<span class=\"variable language_\">self</span>.current)</span><br><span class=\"line\">        <span class=\"variable language_\">self</span>.current = url</span><br><span class=\"line\">        <span class=\"variable language_\">self</span>.forward_stack.clear()  <span class=\"comment\"># 新访问清空前进历史</span></span><br><span class=\"line\">    <span class=\"keyword\">def</span> <span class=\"title function_\">back</span>(<span class=\"params\">self</span>):</span><br><span class=\"line\">        <span class=\"keyword\">if</span> <span class=\"variable language_\">self</span>.back_stack:</span><br><span class=\"line\">            <span class=\"variable language_\">self</span>.forward_stack.append(<span class=\"variable language_\">self</span>.current)</span><br><span class=\"line\">            <span class=\"variable language_\">self</span>.current = <span class=\"variable language_\">self</span>.back_stack.pop()</span><br><span class=\"line\">        <span class=\"keyword\">else</span>:</span><br><span class=\"line\">            <span class=\"built_in\">print</span>(<span class=\"string\">&quot;No pages to go back to&quot;</span>)</span><br><span class=\"line\">    <span class=\"keyword\">def</span> <span class=\"title function_\">forward</span>(<span class=\"params\">self</span>):</span><br><span class=\"line\">        <span class=\"keyword\">if</span> <span class=\"variable language_\">self</span>.forward_stack:</span><br><span class=\"line\">            <span class=\"variable language_\">self</span>.back_stack.append(<span class=\"variable language_\">self</span>.current)</span><br><span class=\"line\">            <span class=\"variable language_\">self</span>.current = <span class=\"variable language_\">self</span>.forward_stack.pop()</span><br><span class=\"line\">        <span class=\"keyword\">else</span>:</span><br><span class=\"line\">            <span class=\"built_in\">print</span>(<span class=\"string\">&quot;No pages to go forward to&quot;</span>)</span><br><span class=\"line\">    <span class=\"keyword\">def</span> <span class=\"title function_\">show</span>(<span class=\"params\">self</span>):</span><br><span class=\"line\">        <span class=\"built_in\">print</span>(<span class=\"string\">f&quot;Back: <span class=\"subst\">&#123;self.back_stack&#125;</span>, Current: <span class=\"subst\">&#123;self.current&#125;</span>, Forward: <span class=\"subst\">&#123;self.forward_stack&#125;</span>&quot;</span>)</span><br><span class=\"line\"><span class=\"keyword\">if</span> name == <span class=\"string\">&quot;__main__&quot;</span>:</span><br><span class=\"line\">    browser = BrowserHistory(<span class=\"string\">&quot;homepage.com&quot;</span>)</span><br><span class=\"line\">    browser.show()</span><br><span class=\"line\">    browser.visit(<span class=\"string\">&quot;news.com&quot;</span>)</span><br><span class=\"line\">    browser.show()</span><br><span class=\"line\">    browser.visit(<span class=\"string\">&quot;sports.com&quot;</span>)</span><br><span class=\"line\">    browser.show()</span><br><span class=\"line\">    browser.back()</span><br><span class=\"line\">    browser.show()</span><br><span class=\"line\">    browser.back()</span><br><span class=\"line\">    browser.show()</span><br><span class=\"line\">    browser.forward()</span><br><span class=\"line\">    browser.show()</span><br></pre></td></tr></table></figure>\n\n<ul>\n<li>通过两个栈 (<code>back_stack</code> 和 <code>forward_stack</code>) 维护历史访问记录，实现后退和前进功能。</li>\n</ul>\n<hr>\n<h3 id=\"语法分析与括号匹配\"><a href=\"#语法分析与括号匹配\" class=\"headerlink\" title=\"语法分析与括号匹配\"></a>语法分析与括号匹配</h3><p>在编译器或解释器的语法分析阶段，需要检查表达式或语句是否合法。最常见的是<strong>括号匹配</strong>问题：扫描字符串时，遇到左括号（<code>(</code>、<code>[</code>、<code>&#123;</code>）时压栈，遇到右括号时检查栈顶是否是对应的左括号，若不匹配则报错；最后栈为空则匹配成功。</p>\n<h4 id=\"C-示例：括号匹配\"><a href=\"#C-示例：括号匹配\" class=\"headerlink\" title=\"C++ 示例：括号匹配\"></a>C++ 示例：括号匹配</h4><figure class=\"highlight cpp\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">#<span class=\"keyword\">include</span> <span class=\"string\">&lt;iostream&gt;</span></span></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"keyword\">include</span> <span class=\"string\">&lt;stack&gt;</span></span></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"keyword\">include</span> <span class=\"string\">&lt;string&gt;</span></span></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"keyword\">include</span> <span class=\"string\">&lt;unordered_map&gt;</span></span></span><br><span class=\"line\"><span class=\"function\"><span class=\"type\">bool</span> <span class=\"title\">isValid</span><span class=\"params\">(<span class=\"type\">const</span> std::string &amp;s)</span> </span>&#123;</span><br><span class=\"line\">    std::stack&lt;<span class=\"type\">char</span>&gt; st;</span><br><span class=\"line\">    std::unordered_map&lt;<span class=\"type\">char</span>, <span class=\"type\">char</span>&gt; pairs = &#123;</span><br><span class=\"line\">        &#123;<span class=\"string\">&#x27;)&#x27;</span>, <span class=\"string\">&#x27;(&#x27;</span>&#125;, &#123;<span class=\"string\">&#x27;]&#x27;</span>, <span class=\"string\">&#x27;[&#x27;</span>&#125;, &#123;<span class=\"string\">&#x27;&#125;&#x27;</span>, <span class=\"string\">&#x27;&#123;&#x27;</span>&#125;</span><br><span class=\"line\">    &#125;;</span><br><span class=\"line\">    <span class=\"keyword\">for</span> (<span class=\"type\">char</span> c : s) &#123;</span><br><span class=\"line\">        <span class=\"keyword\">if</span> (c == <span class=\"string\">&#x27;(&#x27;</span> || c == <span class=\"string\">&#x27;[&#x27;</span> || c == <span class=\"string\">&#x27;&#123;&#x27;</span>) &#123;</span><br><span class=\"line\">            st.<span class=\"built_in\">push</span>(c);</span><br><span class=\"line\">        &#125; <span class=\"keyword\">else</span> <span class=\"keyword\">if</span> (c == <span class=\"string\">&#x27;)&#x27;</span> || c == <span class=\"string\">&#x27;]&#x27;</span> || c == <span class=\"string\">&#x27;&#125;&#x27;</span>) &#123;</span><br><span class=\"line\">            <span class=\"keyword\">if</span> (st.<span class=\"built_in\">empty</span>() || st.<span class=\"built_in\">top</span>() != pairs[c]) &#123;</span><br><span class=\"line\">                <span class=\"keyword\">return</span> <span class=\"literal\">false</span>;</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">            st.<span class=\"built_in\">pop</span>();</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        <span class=\"comment\">// 忽略其他字符</span></span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> st.<span class=\"built_in\">empty</span>();</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"function\"><span class=\"type\">int</span> <span class=\"title\">main</span><span class=\"params\">()</span> </span>&#123;</span><br><span class=\"line\">    std::string s1 = <span class=\"string\">&quot;([&#123;&#125;])&quot;</span>;</span><br><span class=\"line\">    std::string s2 = <span class=\"string\">&quot;([&#125;&#123;])&quot;</span>;</span><br><span class=\"line\">    std::cout &lt;&lt; s1 &lt;&lt; <span class=\"string\">&quot; is &quot;</span> &lt;&lt; (<span class=\"built_in\">isValid</span>(s1) ? <span class=\"string\">&quot;valid\\n&quot;</span> : <span class=\"string\">&quot;invalid\\n&quot;</span>);</span><br><span class=\"line\">    std::cout &lt;&lt; s2 &lt;&lt; <span class=\"string\">&quot; is &quot;</span> &lt;&lt; (<span class=\"built_in\">isValid</span>(s2) ? <span class=\"string\">&quot;valid\\n&quot;</span> : <span class=\"string\">&quot;invalid\\n&quot;</span>);</span><br><span class=\"line\">    <span class=\"keyword\">return</span> <span class=\"number\">0</span>;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<ul>\n<li>使用 <code>std::stack&lt;char&gt;</code> 存储左括号，遇到右括号时检查对应关系。</li>\n</ul>\n<h4 id=\"Python-示例-2\"><a href=\"#Python-示例-2\" class=\"headerlink\" title=\"Python 示例\"></a>Python 示例</h4><figure class=\"highlight python\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">def</span> <span class=\"title function_\">is_valid</span>(<span class=\"params\">s: <span class=\"built_in\">str</span></span>) -&gt; <span class=\"built_in\">bool</span>:</span><br><span class=\"line\">    stack = []</span><br><span class=\"line\">    pairs = &#123;<span class=\"string\">&#x27;)&#x27;</span>: <span class=\"string\">&#x27;(&#x27;</span>, <span class=\"string\">&#x27;]&#x27;</span>: <span class=\"string\">&#x27;[&#x27;</span>, <span class=\"string\">&#x27;&#125;&#x27;</span>: <span class=\"string\">&#x27;&#123;&#x27;</span>&#125;</span><br><span class=\"line\">    <span class=\"keyword\">for</span> c <span class=\"keyword\">in</span> s:</span><br><span class=\"line\">        <span class=\"keyword\">if</span> c <span class=\"keyword\">in</span> <span class=\"string\">&#x27;([&#123;&#x27;</span>:</span><br><span class=\"line\">            stack.append(c)</span><br><span class=\"line\">        <span class=\"keyword\">elif</span> c <span class=\"keyword\">in</span> <span class=\"string\">&#x27;)]&#125;&#x27;</span>:</span><br><span class=\"line\">            <span class=\"keyword\">if</span> <span class=\"keyword\">not</span> stack <span class=\"keyword\">or</span> stack[-<span class=\"number\">1</span>] != pairs[c]:</span><br><span class=\"line\">                <span class=\"keyword\">return</span> <span class=\"literal\">False</span></span><br><span class=\"line\">            stack.pop()</span><br><span class=\"line\">        <span class=\"comment\"># 忽略其他字符</span></span><br><span class=\"line\">    <span class=\"keyword\">return</span> <span class=\"keyword\">not</span> stack</span><br><span class=\"line\"><span class=\"keyword\">if</span> name == <span class=\"string\">&quot;__main__&quot;</span>:</span><br><span class=\"line\">    <span class=\"built_in\">print</span>(is_valid(<span class=\"string\">&quot;([&#123;&#125;])&quot;</span>))  <span class=\"comment\"># True</span></span><br><span class=\"line\">    <span class=\"built_in\">print</span>(is_valid(<span class=\"string\">&quot;([&#125;&#123;])&quot;</span>))  <span class=\"comment\"># False</span></span><br></pre></td></tr></table></figure>\n\n<ul>\n<li>逻辑同上，用列表模拟栈。</li>\n</ul>\n<hr>\n<h3 id=\"进程-线程调度与上下文切换\"><a href=\"#进程-线程调度与上下文切换\" class=\"headerlink\" title=\"进程&#x2F;线程调度与上下文切换\"></a>进程&#x2F;线程调度与上下文切换</h3><p>操作系统在进行<strong>线程切换</strong>或<strong>进程切换</strong>时，需要保存当前执行状态（寄存器上下文、程序计数器等）到线程&#x2F;进程的<strong>栈帧</strong>中，待下次重新调度时再从栈中恢复。</p>\n<ul>\n<li>线程栈：每个线程分配固定大小的栈空间，保存其调用链和临时变量。上下文切换时，CPU 会自动“压栈”通用寄存器和程序计数器，然后加载下一个线程的寄存器和 PC 值；切回原线程时，再次“弹栈”恢复上下文。</li>\n</ul>\n<h4 id=\"C-伪示例（伪代码，仅用于说明概念）\"><a href=\"#C-伪示例（伪代码，仅用于说明概念）\" class=\"headerlink\" title=\"C++ 伪示例（伪代码，仅用于说明概念）\"></a>C++ 伪示例（伪代码，仅用于说明概念）</h4><figure class=\"highlight cpp\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">struct</span> <span class=\"title class_\">CPUContext</span> &#123;</span><br><span class=\"line\">    <span class=\"type\">uint64_t</span> rip;     <span class=\"comment\">// 指令指针（程序计数器）</span></span><br><span class=\"line\">    <span class=\"type\">uint64_t</span> rsp;     <span class=\"comment\">// 栈指针</span></span><br><span class=\"line\">    <span class=\"type\">uint64_t</span> regs[<span class=\"number\">16</span>];<span class=\"comment\">// 其他通用寄存器</span></span><br><span class=\"line\">    <span class=\"comment\">// ...</span></span><br><span class=\"line\">&#125;;</span><br><span class=\"line\"><span class=\"function\"><span class=\"type\">void</span> <span class=\"title\">context_switch</span><span class=\"params\">(CPUContext *cur, CPUContext </span></span></span><br><span class=\"line\"><span class=\"params\"><span class=\"function\">_next)</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"comment\">// 保存当前上下文到 cur</span></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">asm</span> <span class=\"title\">volatile</span> <span class=\"params\">(</span></span></span><br><span class=\"line\"><span class=\"params\"><span class=\"function\">        <span class=\"string\">&quot;mov %%rsp, %0\\n\\t&quot;</span></span></span></span><br><span class=\"line\"><span class=\"params\"><span class=\"function\">        <span class=\"string\">&quot;mov %%rax, %1\\n\\t&quot;</span></span></span></span><br><span class=\"line\"><span class=\"params\"><span class=\"function\">        <span class=\"comment\">// … 其他寄存器</span></span></span></span><br><span class=\"line\"><span class=\"params\"><span class=\"function\">_*        : <span class=\"string\">&quot;=m&quot;</span>(cur-&gt;rsp), <span class=\"string\">&quot;=m&quot;</span>(cur-&gt;regs[<span class=\"number\">0</span>]) <span class=\"comment\">/*</span></span></span></span><br><span class=\"line\"><span class=\"comment\"><span class=\"params\"><span class=\"function\"> … </span></span></span></span><br><span class=\"line\"><span class=\"comment\"><span class=\"params\"><span class=\"function\">_/</span></span></span></span><br><span class=\"line\"><span class=\"comment\"><span class=\"params\"><span class=\"function\">        :</span></span></span></span><br><span class=\"line\"><span class=\"comment\"><span class=\"params\"><span class=\"function\">        :</span></span></span></span><br><span class=\"line\"><span class=\"comment\"><span class=\"params\"><span class=\"function\">    );</span></span></span></span><br><span class=\"line\"><span class=\"comment\"><span class=\"params\"><span class=\"function\">    // 加载下一个上下文</span></span></span></span><br><span class=\"line\"><span class=\"comment\"><span class=\"params\"><span class=\"function\">    asm volatile (</span></span></span></span><br><span class=\"line\"><span class=\"comment\"><span class=\"params\"><span class=\"function\">        &quot;mov %0, %%rsp\\n\\t&quot;</span></span></span></span><br><span class=\"line\"><span class=\"comment\"><span class=\"params\"><span class=\"function\">        &quot;mov %1, %%rax\\n\\t&quot;</span></span></span></span><br><span class=\"line\"><span class=\"comment\"><span class=\"params\"><span class=\"function\">        // … 其他寄存器</span></span></span></span><br><span class=\"line\"><span class=\"comment\"><span class=\"params\"><span class=\"function\">        :</span></span></span></span><br><span class=\"line\"><span class=\"comment\"><span class=\"params\"><span class=\"function\">_*        : &quot;m&quot;(next-&gt;rsp), &quot;m&quot;(next-&gt;regs[0]) /*</span></span></span></span><br><span class=\"line\"><span class=\"comment\"><span class=\"params\"><span class=\"function\"> … */</span></span></span></span><br><span class=\"line\"><span class=\"params\"><span class=\"function\">    )</span></span>;</span><br><span class=\"line\">    <span class=\"comment\">// 跳转到下一个线程的指令地址</span></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">asm</span> <span class=\"title\">volatile</span> <span class=\"params\">(<span class=\"string\">&quot;jmp *%0&quot;</span> :: <span class=\"string\">&quot;m&quot;</span>(next-&gt;rip))</span></span>;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<ul>\n<li>该示例仅示意 OS 如何将寄存器状态压栈&#x2F;存储到 <code>CPUContext</code> 结构，模拟上下文切换。真实内核会更复杂，并在内核栈上完成这些操作。</li>\n</ul>\n<hr>\n<h3 id=\"实时系统任务调度与中断处理\"><a href=\"#实时系统任务调度与中断处理\" class=\"headerlink\" title=\"实时系统任务调度与中断处理\"></a>实时系统任务调度与中断处理</h3><p>在实时系统（RTOS）中，每个任务通常分配一个固定大小的栈，用于保存用户态执行时的局部变量和调用帧。</p>\n<ul>\n<li><strong>任务调度</strong>：RTOS 按优先级或时间片轮转调度任务，切换时需保存&#x2F;恢复任务上下文（寄存器、程序计数器等）到各自任务的栈帧。</li>\n<li><strong>中断处理</strong>：发生中断时，CPU 自动将部分寄存器（如程序计数器、标志寄存器）压入当前栈中，跳转到中断处理程序，并使用中断程序自身的栈（通常也是内核栈）执行，处理完毕后从栈中弹出恢复现场。</li>\n</ul>\n<h4 id=\"C-示例（伪代码，基于-ARM-Cortex-M-中断栈）\"><a href=\"#C-示例（伪代码，基于-ARM-Cortex-M-中断栈）\" class=\"headerlink\" title=\"C 示例（伪代码，基于 ARM Cortex-M 中断栈）\"></a>C 示例（伪代码，基于 ARM Cortex-M 中断栈）</h4><figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// 假设 Cortex-M 架构，中断发生时硬件会自动压入 R0-R3、R12、LR、PC、xPSR</span></span><br><span class=\"line\"><span class=\"type\">void</span> <span class=\"title function_\">SysTick_Handler</span><span class=\"params\">(<span class=\"type\">void</span>)</span> &#123;</span><br><span class=\"line\">    <span class=\"comment\">// 此时硬件已将通用寄存器和 xPSR 压入当前任务的栈中，使用 PSP/MSP 寄存器区分</span></span><br><span class=\"line\">    <span class=\"comment\">// 处理中断逻辑</span></span><br><span class=\"line\">    <span class=\"comment\">// ...</span></span><br><span class=\"line\">    <span class=\"comment\">// 退出中断时，硬件自动从栈中弹回寄存器并恢复现场</span></span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"comment\">// 任务创建时，手动构造该任务的初始栈帧</span></span><br><span class=\"line\"><span class=\"type\">uint32_t</span> *<span class=\"title function_\">create_task_stack</span><span class=\"params\">(<span class=\"type\">void</span> (*task_func)(<span class=\"type\">void</span>), <span class=\"type\">uint32_t</span> *stack_top)</span> &#123;</span><br><span class=\"line\">    <span class=\"comment\">// 栈顶需预留硬件自动压栈的空间（8 寄存器）</span></span><br><span class=\"line\">    *(--stack_top) = INITIAL_xPSR;  <span class=\"comment\">// xPSR</span></span><br><span class=\"line\">    *(--stack_top) = (<span class=\"type\">uint32_t</span>)task_func; <span class=\"comment\">// PC</span></span><br><span class=\"line\">    *(--stack_top) = <span class=\"number\">0xFFFFFFFD</span>;    <span class=\"comment\">// LR (使用 PSP 指向任务栈)</span></span><br><span class=\"line\">    <span class=\"comment\">// R12, R3, R2, R1, R0</span></span><br><span class=\"line\">    <span class=\"keyword\">for</span> (<span class=\"type\">int</span> i = <span class=\"number\">0</span>; i &lt; <span class=\"number\">5</span>; i++) &#123;</span><br><span class=\"line\">        *(--stack_top) = <span class=\"number\">0</span>;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"comment\">// 接下来是软件自动压入的寄存器（R4–R11）</span></span><br><span class=\"line\">    <span class=\"keyword\">for</span> (<span class=\"type\">int</span> i = <span class=\"number\">0</span>; i &lt; <span class=\"number\">8</span>; i++) &#123;</span><br><span class=\"line\">        *(--stack_top) = <span class=\"number\">0</span>;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> stack_top; <span class=\"comment\">// 返回任务上下文初始化后的栈顶指针</span></span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<ul>\n<li>在 ARM Cortex-M 系列中，中断或异常发生时，硬件会自动将 R0–R3、R12、LR、PC、xPSR 压栈；退出时硬件弹栈恢复。这段伪代码展示了如何手动为一个新任务构造“假”的中断栈帧，使其从任务函数 <code>task_func</code> 开始执行。</li>\n</ul>\n<hr>\n<h2 id=\"堆与栈在内存中的分布及冲突\"><a href=\"#堆与栈在内存中的分布及冲突\" class=\"headerlink\" title=\"堆与栈在内存中的分布及冲突\"></a>堆与栈在内存中的分布及冲突</h2><h3 id=\"内存布局示意\"><a href=\"#内存布局示意\" class=\"headerlink\" title=\"内存布局示意\"></a>内存布局示意</h3><p>C 语言的内存模型分为 5 个区：栈区、堆区、静态区、常量区、代码区。每个区存储的内容如下：</p>\n<ol>\n<li>栈区：存放函数的参数值、局部变量等，由编译器自动分配和释放，通常在函数执行完后就释放了，其操作方式类似于数据结构中的栈。栈内存分配运算内置于 CPU 的指令集，效率很高，但是分配的内存量有限，比如 iOS 中栈区的大小是 2M。</li>\n<li>堆区：就是通过 new、malloc、realloc 分配的内存块，编译器不会负责它们的释放工作，需要用程序区释放。分配方式类似于数据结构中的链表。“内存泄漏”通常说的就是堆区。</li>\n<li>静态区：全局变量和静态变量的存储是放在一块的，初始化的全局变量和静态变量在一块区域，未初始化的全局变量和未初始化的静态变量在相邻的另一块区域。程序结束后，由系统释放。</li>\n<li>常量区：常量存储在这里，不允许修改。</li>\n<li>代码区：顾名思义，存放代码。</li>\n</ol>\n<p><img src=\"https://gitee.com/tanke11223344/imagehost/raw/main/blog/1749360547853MFckbxyUqonaQtxbuPsc8E3unsc.png\" alt=\"1749360547853MFckbxyUqonaQtxbuPsc8E3unsc.png\"><br><img src=\"https://gitee.com/tanke11223344/imagehost/raw/main/blog/1749360556085D4ivbYK77oSejXxL204cgPNvneb.png\" alt=\"1749360556085D4ivbYK77oSejXxL204cgPNvneb.png\"></p>\n<ul>\n<li><strong>堆区</strong>（Heap）从低地址向高地址方向增长。当程序调用 <code>new</code>&#x2F;<code>malloc</code> 分配内存时，分配器会在堆中寻找足够大的空闲块。</li>\n<li><strong>栈区</strong>（Stack）从高地址向低地址方向增长。当函数调用时，系统在栈顶“向下”分配栈帧；函数返回时，“向上”回收。</li>\n<li>两者通常由中间的空闲区隔开，若向对方增长的空间过大，可能出现<strong>堆与栈冲突</strong>（Stack–Heap Collision）。</li>\n</ul>\n<h3 id=\"栈堆冲突（Stack–Heap-Collision）\"><a href=\"#栈堆冲突（Stack–Heap-Collision）\" class=\"headerlink\" title=\"栈堆冲突（Stack–Heap Collision）\"></a>栈堆冲突（Stack–Heap Collision）</h3><p>当程序对堆申请大量连续内存（如 <code>new</code>&#x2F;<code>malloc</code>）而栈调用层次过深（或线程栈空间不足）时：</p>\n<ul>\n<li><strong>堆过度增长</strong>：不断调用动态分配函数，导致堆区不断向高地址扩展</li>\n<li><strong>栈过度生长</strong>：深度递归或大量局部变量导致栈区向低地址扩展<br>若二者相向增长，最终会相互覆盖（即“冲突”），造成已分配的堆内存或栈空间被意外覆盖，导致程序崩溃或不可预知的错误。</li>\n</ul>\n<h4 id=\"示意场景\"><a href=\"#示意场景\" class=\"headerlink\" title=\"示意场景\"></a>示意场景</h4><figure class=\"highlight cpp\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">#<span class=\"keyword\">include</span> <span class=\"string\">&lt;iostream&gt;</span></span></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"keyword\">include</span> <span class=\"string\">&lt;vector&gt;</span></span></span><br><span class=\"line\"><span class=\"function\"><span class=\"type\">void</span> <span class=\"title\">recurse</span><span class=\"params\">(<span class=\"type\">int</span> depth)</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"comment\">// 每次调用消耗一定的栈空间</span></span><br><span class=\"line\">    <span class=\"type\">char</span> buffer[<span class=\"number\">1024</span>];  <span class=\"comment\">// 1KB 的局部数组</span></span><br><span class=\"line\">    <span class=\"keyword\">if</span> (depth &gt; <span class=\"number\">0</span>) &#123;</span><br><span class=\"line\">        <span class=\"built_in\">recurse</span>(depth - <span class=\"number\">1</span>);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"function\"><span class=\"type\">int</span> <span class=\"title\">main</span><span class=\"params\">()</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"comment\">// 不断分配堆内存</span></span><br><span class=\"line\">    std::vector&lt;<span class=\"type\">int</span>*&gt; allocations;</span><br><span class=\"line\">    <span class=\"keyword\">try</span> &#123;</span><br><span class=\"line\">        <span class=\"keyword\">while</span> (<span class=\"literal\">true</span>) &#123;</span><br><span class=\"line\">            allocations.<span class=\"built_in\">push_back</span>(<span class=\"keyword\">new</span> <span class=\"type\">int</span>[<span class=\"number\">10000</span>]); <span class=\"comment\">// 每次分配 ~40KB</span></span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125; <span class=\"built_in\">catch</span> (std::bad_alloc &amp;e) &#123;</span><br><span class=\"line\">        std::cerr &lt;&lt; <span class=\"string\">&quot;Heap exhausted: &quot;</span> &lt;&lt; e.<span class=\"built_in\">what</span>() &lt;&lt; std::endl;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"comment\">// 同时进行深度递归</span></span><br><span class=\"line\">    <span class=\"built_in\">recurse</span>(<span class=\"number\">100000</span>); <span class=\"comment\">// 这会导致栈溢出</span></span><br><span class=\"line\">    <span class=\"keyword\">return</span> <span class=\"number\">0</span>;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<ul>\n<li>在上述伪示例中，如果同时执行大量 <code>new int[10000]</code>（堆分配）与深度递归 <code>recurse(100000)</code>（栈分配），就可能发生堆与栈冲突。实际运行时，程序要么先出现堆分配失败（抛出 <code>bad_alloc</code>），要么先出现栈溢出 (Stack Overflow)。</li>\n</ul>\n<h4 id=\"如何避免\"><a href=\"#如何避免\" class=\"headerlink\" title=\"如何避免\"></a>如何避免</h4><ol>\n<li><strong>控制递归深度</strong>，或使用迭代替代深度递归，从而减少栈空间消耗。</li>\n<li><strong>限制堆分配总量</strong>，在堆分配时及时释放不再使用的内存，避免过度占用。</li>\n<li><strong>增加可用内存</strong>：在嵌入式或受限环境下，根据需求调整栈大小（编译器或链接器选项）和堆区大小。</li>\n<li><strong>监控与检测工具</strong>：使用工具（如 Valgrind、AddressSanitizer）检测内存越界和栈溢出问题。</li>\n</ol>\n<hr>\n<h2 id=\"堆与栈在不同应用场景中的现实案例\"><a href=\"#堆与栈在不同应用场景中的现实案例\" class=\"headerlink\" title=\"堆与栈在不同应用场景中的现实案例\"></a>堆与栈在不同应用场景中的现实案例</h2><h3 id=\"嵌入式开发\"><a href=\"#嵌入式开发\" class=\"headerlink\" title=\"嵌入式开发\"></a>嵌入式开发</h3><ul>\n<li><strong>堆与栈在 RTOS 中的角色</strong><ul>\n<li><strong>栈</strong>：每个任务分配固定大小的任务栈，用于存储任务函数的调用帧和局部变量。RTOS 切换任务时，会保存&#x2F;恢复任务的寄存器上下文到各自的任务栈中。</li>\n<li><strong>堆</strong>：嵌入式往往内存紧张，避免动态分配；如果使用堆则要小心碎片化。许多 RTOS（如 FreeRTOS）提供“内存池”或“堆区域”管理接口，开发者可根据需求预先分配一段大内存作为堆，通过 <code>pvPortMalloc</code>&#x2F;<code>vPortFree</code> 操作。</li>\n</ul>\n</li>\n</ul>\n<figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// FreeRTOS 示例：创建一个任务，并为其指定栈大小</span></span><br><span class=\"line\"><span class=\"type\">void</span> <span class=\"title function_\">vTaskFunction</span><span class=\"params\">(<span class=\"type\">void</span> *pvParameters)</span> &#123;</span><br><span class=\"line\">    <span class=\"type\">int</span> local_var = <span class=\"number\">42</span>;  <span class=\"comment\">// 存储在任务栈中</span></span><br><span class=\"line\">    <span class=\"keyword\">for</span> (;;) &#123;</span><br><span class=\"line\">        <span class=\"comment\">// Task logic...</span></span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"type\">int</span> <span class=\"title function_\">main</span><span class=\"params\">(<span class=\"type\">void</span>)</span> &#123;</span><br><span class=\"line\">    <span class=\"comment\">// 在创建任务时，指定 256 字 作为任务栈大小</span></span><br><span class=\"line\">    xTaskCreate(vTaskFunction, <span class=\"string\">&quot;Task1&quot;</span>, <span class=\"number\">256</span>, <span class=\"literal\">NULL</span>, <span class=\"number\">1</span>, <span class=\"literal\">NULL</span>);</span><br><span class=\"line\">    vTaskStartScheduler(); <span class=\"comment\">// 启动调度器，开始抢占式多任务</span></span><br><span class=\"line\">    <span class=\"keyword\">return</span> <span class=\"number\">0</span>;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<ul>\n<li><strong>场景说明</strong>：在嵌入式系统中，为了保证实时性和预测性，往往禁止或限制堆分配，更多地使用<strong>静态分配</strong>或<strong>内存池</strong>，仅在启动阶段少量使用堆。</li>\n</ul>\n<hr>\n<h3 id=\"Web-后端\"><a href=\"#Web-后端\" class=\"headerlink\" title=\"Web 后端\"></a>Web 后端</h3><ul>\n<li><p><strong>函数调用与请求栈</strong></p>\n<ul>\n<li>在 Web 服务中，每个 HTTP 请求都可能触发一条线程（或使用协程&#x2F;异步框架），该请求对应的调用堆栈存放在栈内存中。若请求处理链条过深（大量中间件或控制器嵌套），有可能导致栈溢出。</li>\n</ul>\n</li>\n<li><p><strong>缓存管理</strong></p>\n<ul>\n<li><strong>堆</strong>：Java 或 C++ 编写的后端应用中的缓存（如 LRU Cache）通常使用堆结构来维护元素优先级或过期时间。例如，使用 <code>std::priority_queue</code> 或 Python 的 <code>heapq</code> 实现定时淘汰策略。</li>\n</ul>\n</li>\n</ul>\n<h4 id=\"C-示例：基于堆的简单-LRU-缓存（按过期时间）\"><a href=\"#C-示例：基于堆的简单-LRU-缓存（按过期时间）\" class=\"headerlink\" title=\"C++ 示例：基于堆的简单 LRU 缓存（按过期时间）\"></a>C++ 示例：基于堆的简单 LRU 缓存（按过期时间）</h4><figure class=\"highlight cpp\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br><span class=\"line\">47</span><br><span class=\"line\">48</span><br><span class=\"line\">49</span><br><span class=\"line\">50</span><br><span class=\"line\">51</span><br><span class=\"line\">52</span><br><span class=\"line\">53</span><br><span class=\"line\">54</span><br><span class=\"line\">55</span><br><span class=\"line\">56</span><br><span class=\"line\">57</span><br><span class=\"line\">58</span><br><span class=\"line\">59</span><br><span class=\"line\">60</span><br><span class=\"line\">61</span><br><span class=\"line\">62</span><br><span class=\"line\">63</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">#<span class=\"keyword\">include</span> <span class=\"string\">&lt;iostream&gt;</span></span></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"keyword\">include</span> <span class=\"string\">&lt;queue&gt;</span></span></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"keyword\">include</span> <span class=\"string\">&lt;unordered_map&gt;</span></span></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"keyword\">include</span> <span class=\"string\">&lt;chrono&gt;</span></span></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"keyword\">include</span> <span class=\"string\">&lt;thread&gt;</span></span></span><br><span class=\"line\"><span class=\"keyword\">struct</span> <span class=\"title class_\">CacheItem</span> &#123;</span><br><span class=\"line\">    <span class=\"type\">int</span> key;</span><br><span class=\"line\">    std::string value;</span><br><span class=\"line\">    std::chrono::steady_clock::time_point expire_time;</span><br><span class=\"line\">&#125;;</span><br><span class=\"line\"><span class=\"keyword\">struct</span> <span class=\"title class_\">CompareExpire</span> &#123;</span><br><span class=\"line\">    <span class=\"function\"><span class=\"type\">bool</span> <span class=\"title\">operator</span><span class=\"params\">()</span><span class=\"params\">(<span class=\"type\">const</span> CacheItem &amp;a, <span class=\"type\">const</span> CacheItem &amp;b)</span> </span>&#123;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> a.expire_time &gt; b.expire_time; <span class=\"comment\">// 过期时间早的优先级高</span></span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;;</span><br><span class=\"line\"><span class=\"keyword\">class</span> <span class=\"title class_\">LRUCache</span> &#123;</span><br><span class=\"line\"><span class=\"keyword\">public</span>:</span><br><span class=\"line\">    <span class=\"built_in\">LRUCache</span>(<span class=\"type\">size_t</span> capacity): <span class=\"built_in\">capacity_</span>(capacity) &#123;&#125;</span><br><span class=\"line\">    <span class=\"function\"><span class=\"type\">void</span> <span class=\"title\">put</span><span class=\"params\">(<span class=\"type\">int</span> key, <span class=\"type\">const</span> std::string &amp;value, <span class=\"type\">int</span> ttl_seconds)</span> </span>&#123;</span><br><span class=\"line\">        <span class=\"keyword\">auto</span> now = std::chrono::steady_clock::<span class=\"built_in\">now</span>();</span><br><span class=\"line\">        CacheItem item&#123;key, value, now + std::chrono::<span class=\"built_in\">seconds</span>(ttl_seconds)&#125;;</span><br><span class=\"line\">        <span class=\"keyword\">if</span> (cache_map_.<span class=\"built_in\">size</span>() &gt;= capacity_) &#123;</span><br><span class=\"line\">            <span class=\"comment\">// 移除过期或最久未使用元素</span></span><br><span class=\"line\">            <span class=\"built_in\">evict</span>();</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        cache_map_[key] = item;</span><br><span class=\"line\">        min_heap_.<span class=\"built_in\">push</span>(item);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"function\">std::string <span class=\"title\">get</span><span class=\"params\">(<span class=\"type\">int</span> key)</span> </span>&#123;</span><br><span class=\"line\">        <span class=\"keyword\">auto</span> it = cache_map_.<span class=\"built_in\">find</span>(key);</span><br><span class=\"line\">        <span class=\"keyword\">if</span> (it == cache_map_.<span class=\"built_in\">end</span>()) <span class=\"keyword\">return</span> <span class=\"string\">&quot;&quot;</span>; <span class=\"comment\">// 未命中</span></span><br><span class=\"line\">        <span class=\"comment\">// 更新过期时间或移动到最新位置可自行实现</span></span><br><span class=\"line\">        <span class=\"keyword\">return</span> it-&gt;second.value;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"><span class=\"keyword\">private</span>:</span><br><span class=\"line\">    <span class=\"function\"><span class=\"type\">void</span> <span class=\"title\">evict</span><span class=\"params\">()</span> </span>&#123;</span><br><span class=\"line\">        <span class=\"keyword\">auto</span> now = std::chrono::steady_clock::<span class=\"built_in\">now</span>();</span><br><span class=\"line\">        <span class=\"keyword\">while</span> (!min_heap_.<span class=\"built_in\">empty</span>()) &#123;</span><br><span class=\"line\">            <span class=\"keyword\">auto</span> &amp;top = min_heap_.<span class=\"built_in\">top</span>();</span><br><span class=\"line\">            <span class=\"keyword\">if</span> (top.expire_time &lt;= now) &#123;</span><br><span class=\"line\">                <span class=\"comment\">// 已过期，删除</span></span><br><span class=\"line\">                cache_map_.<span class=\"built_in\">erase</span>(top.key);</span><br><span class=\"line\">                min_heap_.<span class=\"built_in\">pop</span>();</span><br><span class=\"line\">            &#125; <span class=\"keyword\">else</span> &#123;</span><br><span class=\"line\">                <span class=\"comment\">// 如果堆顶未过期，但 cache_map_ 超过容量，可自行实现额外的 LRU 逻辑</span></span><br><span class=\"line\">                <span class=\"keyword\">break</span>;</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        <span class=\"comment\">// 这里简化：如果仍然超出容量，可额外删除最老元素</span></span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"type\">size_t</span> capacity_;</span><br><span class=\"line\">    std::unordered_map&lt;<span class=\"type\">int</span>, CacheItem&gt; cache_map_;</span><br><span class=\"line\">    std::priority_queue&lt;CacheItem, std::vector&lt;CacheItem&gt;, CompareExpire&gt; min_heap_;</span><br><span class=\"line\">&#125;;</span><br><span class=\"line\"><span class=\"function\"><span class=\"type\">int</span> <span class=\"title\">main</span><span class=\"params\">()</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"function\">LRUCache <span class=\"title\">cache</span><span class=\"params\">(<span class=\"number\">3</span>)</span></span>;</span><br><span class=\"line\">    cache.<span class=\"built_in\">put</span>(<span class=\"number\">1</span>, <span class=\"string\">&quot;A&quot;</span>, <span class=\"number\">2</span>);</span><br><span class=\"line\">    cache.<span class=\"built_in\">put</span>(<span class=\"number\">2</span>, <span class=\"string\">&quot;B&quot;</span>, <span class=\"number\">5</span>);</span><br><span class=\"line\">    cache.<span class=\"built_in\">put</span>(<span class=\"number\">3</span>, <span class=\"string\">&quot;C&quot;</span>, <span class=\"number\">10</span>);</span><br><span class=\"line\">    std::this_thread::<span class=\"built_in\">sleep_for</span>(std::chrono::<span class=\"built_in\">seconds</span>(<span class=\"number\">3</span>));</span><br><span class=\"line\">    std::cout &lt;&lt; <span class=\"string\">&quot;Get key 1: &quot;</span> &lt;&lt; cache.<span class=\"built_in\">get</span>(<span class=\"number\">1</span>) &lt;&lt; std::endl; <span class=\"comment\">// 可能已过期，返回 &quot;&quot;</span></span><br><span class=\"line\">    <span class=\"keyword\">return</span> <span class=\"number\">0</span>;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<ul>\n<li>使用 <code>std::priority_queue</code>（最小堆）按过期时间排序，当容量满时弹出最早过期项或其他淘汰策略。</li>\n</ul>\n<hr>\n<h3 id=\"游戏开发\"><a href=\"#游戏开发\" class=\"headerlink\" title=\"游戏开发\"></a>游戏开发</h3><blockquote>\n<ul>\n<li><a href=\"https://www.cnblogs.com/KillerAery/p/10765893.html\">游戏架构设计:内存管理 - KillerAery - 博客园</a></li>\n<li><a href=\"https://www.cnblogs.com/zhyan8/p/17238161.html\">【Unity3D】Unity3D 技术栈 - little_fat_sheep - 博客园</a></li>\n</ul>\n</blockquote>\n<ul>\n<li><strong>内存池（Memory Pool）</strong><ul>\n<li>游戏中对象（如子弹、特效、NPC）创建频繁，反复调用 <code>new/delete</code> 会导致堆碎片和性能损耗。常用的做法是在启动时预先向堆申请一大块连续内存，将其切分为固定大小的“内存池块”，通过栈或链表管理空闲块。分配时从池中取出一个空闲块，释放时将其归还池中，而无需操作系统的堆管理。</li>\n</ul>\n</li>\n</ul>\n<h4 id=\"C-示例：简单对象池（以-GameObject-为例）\"><a href=\"#C-示例：简单对象池（以-GameObject-为例）\" class=\"headerlink\" title=\"C++ 示例：简单对象池（以 GameObject 为例）\"></a>C++ 示例：简单对象池（以 <code>GameObject</code> 为例）</h4><figure class=\"highlight cpp\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br><span class=\"line\">47</span><br><span class=\"line\">48</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">#<span class=\"keyword\">include</span> <span class=\"string\">&lt;iostream&gt;</span></span></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"keyword\">include</span> <span class=\"string\">&lt;vector&gt;</span></span></span><br><span class=\"line\"><span class=\"comment\">// 假设游戏对象</span></span><br><span class=\"line\"><span class=\"keyword\">class</span> <span class=\"title class_\">GameObject</span> &#123;</span><br><span class=\"line\"><span class=\"keyword\">public</span>:</span><br><span class=\"line\">    <span class=\"built_in\">GameObject</span>() : <span class=\"built_in\">x</span>(<span class=\"number\">0</span>), <span class=\"built_in\">y</span>(<span class=\"number\">0</span>) &#123;&#125;</span><br><span class=\"line\">    <span class=\"function\"><span class=\"type\">void</span> <span class=\"title\">reset</span><span class=\"params\">()</span> </span>&#123; x = y = <span class=\"number\">0</span>; &#125;</span><br><span class=\"line\">    <span class=\"function\"><span class=\"type\">void</span> <span class=\"title\">set_position</span><span class=\"params\">(<span class=\"type\">int</span> px, <span class=\"type\">int</span> py)</span> </span>&#123; x = px; y = py; &#125;</span><br><span class=\"line\">    <span class=\"function\"><span class=\"type\">void</span> <span class=\"title\">print</span><span class=\"params\">()</span> <span class=\"type\">const</span> </span>&#123; std::cout &lt;&lt; <span class=\"string\">&quot;GameObject at (&quot;</span> &lt;&lt; x &lt;&lt; <span class=\"string\">&quot;, &quot;</span> &lt;&lt; y &lt;&lt; <span class=\"string\">&quot;)\\n&quot;</span>; &#125;</span><br><span class=\"line\"><span class=\"keyword\">private</span>:</span><br><span class=\"line\">    <span class=\"type\">int</span> x, y;</span><br><span class=\"line\">&#125;;</span><br><span class=\"line\"><span class=\"keyword\">class</span> <span class=\"title class_\">ObjectPool</span> &#123;</span><br><span class=\"line\"><span class=\"keyword\">public</span>:</span><br><span class=\"line\">    <span class=\"built_in\">ObjectPool</span>(<span class=\"type\">size_t</span> poolSize) &#123;</span><br><span class=\"line\">        pool_.<span class=\"built_in\">reserve</span>(poolSize);</span><br><span class=\"line\">        <span class=\"keyword\">for</span> (<span class=\"type\">size_t</span> i = <span class=\"number\">0</span>; i &lt; poolSize; ++i) &#123;</span><br><span class=\"line\">            pool_.<span class=\"built_in\">push_back</span>(<span class=\"keyword\">new</span> <span class=\"built_in\">GameObject</span>());</span><br><span class=\"line\">            free_stack_.<span class=\"built_in\">push</span>(pool_.<span class=\"built_in\">back</span>());</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    ~<span class=\"built_in\">ObjectPool</span>() &#123;</span><br><span class=\"line\">        <span class=\"keyword\">for</span> (<span class=\"keyword\">auto</span> obj : pool_) <span class=\"keyword\">delete</span> obj;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"function\">GameObject* <span class=\"title\">acquire</span><span class=\"params\">()</span> </span>&#123;</span><br><span class=\"line\">        <span class=\"keyword\">if</span> (free_stack_.<span class=\"built_in\">empty</span>()) <span class=\"keyword\">return</span> <span class=\"literal\">nullptr</span>;</span><br><span class=\"line\">        GameObject* obj = free_stack_.<span class=\"built_in\">top</span>();</span><br><span class=\"line\">        free_stack_.<span class=\"built_in\">pop</span>();</span><br><span class=\"line\">        <span class=\"keyword\">return</span> obj;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"function\"><span class=\"type\">void</span> <span class=\"title\">release</span><span class=\"params\">(GameObject* obj)</span> </span>&#123;</span><br><span class=\"line\">        obj-&gt;<span class=\"built_in\">reset</span>();</span><br><span class=\"line\">        free_stack_.<span class=\"built_in\">push</span>(obj);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"><span class=\"keyword\">private</span>:</span><br><span class=\"line\">    std::vector&lt;GameObject*&gt; pool_;</span><br><span class=\"line\">    std::stack&lt;GameObject*&gt; free_stack_;</span><br><span class=\"line\">&#125;;</span><br><span class=\"line\"><span class=\"function\"><span class=\"type\">int</span> <span class=\"title\">main</span><span class=\"params\">()</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"function\">ObjectPool <span class=\"title\">pool</span><span class=\"params\">(<span class=\"number\">5</span>)</span></span>;</span><br><span class=\"line\">    GameObject *obj1 = pool.<span class=\"built_in\">acquire</span>();</span><br><span class=\"line\">    obj1-&gt;<span class=\"built_in\">set_position</span>(<span class=\"number\">10</span>, <span class=\"number\">20</span>);</span><br><span class=\"line\">    obj1-&gt;<span class=\"built_in\">print</span>(); <span class=\"comment\">// GameObject at (10, 20)</span></span><br><span class=\"line\">    pool.<span class=\"built_in\">release</span>(obj1);</span><br><span class=\"line\">    GameObject *obj2 = pool.<span class=\"built_in\">acquire</span>();</span><br><span class=\"line\">    obj2-&gt;<span class=\"built_in\">print</span>(); <span class=\"comment\">// GameObject at (0, 0) （重置后）</span></span><br><span class=\"line\">    <span class=\"keyword\">return</span> <span class=\"number\">0</span>;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<ul>\n<li><code>ObjectPool</code> 在构造时一次性向堆申请若干 <code>GameObject</code>，将它们全部存在 <code>pool_</code> 容器中，再把指针压入 <code>free_stack_</code>（栈）。获取时从 <code>free_stack_</code> 弹栈；释放时将对象 <code>reset()</code> 并压回栈。避免了频繁的 <code>new/delete</code>。</li>\n</ul>\n<hr>\n<h3 id=\"操作系统原理\"><a href=\"#操作系统原理\" class=\"headerlink\" title=\"操作系统原理\"></a>操作系统原理</h3><ul>\n<li><p><strong>线程栈</strong></p>\n<ul>\n<li>操作系统为每个线程分配固定大小的内存作为线程栈，用于保存函数调用帧、局部变量和中断上下文。栈空间不足会导致<strong>栈溢出（Stack Overflow）</strong>，可能使程序崩溃。</li>\n</ul>\n</li>\n<li><p><strong>堆碎片与分配器</strong></p>\n<ul>\n<li>应用在堆上频繁分配&#x2F;释放不同大小的块，会导致碎片化（外部碎片）。操作系统或 C 运行时使用<strong>分配算法</strong>（如伙伴系统、空闲链表、slab 分配器）来减少碎片。例如 Linux 内核使用伙伴算法（Buddy Allocator）为内核分配物理页；用户态 C 库（glibc）使用 ptmalloc2，实现复杂的 bin 快表和 mmap 分配，从而提升多线程环境下的分配效率并尽量减少碎片。</li>\n</ul>\n</li>\n</ul>\n<h1 id=\"总结\"><a href=\"#总结\" class=\"headerlink\" title=\"总结\"></a>总结</h1><p>总体而言，<strong>栈</strong>与<strong>堆</strong>在数据结构和内存管理层面都是基础而关键的概念。数据结构层面，栈提供简单高效的 LIFO 存取，堆（优先队列）提供基于优先级的动态调度；内存管理层面，栈由系统自动分配释放，速度快但空间有限；堆则按需动态分配，由程序或运行时负责回收，灵活但需要注意碎片和内存泄漏。理解两者的差异及应用场景（如嵌入式的静态分配、后端的请求栈和缓存管理、游戏的内存池、操作系统的线程栈管理等）可以帮助程序员写出更健壮、高效的代码。</p>\n<ul>\n<li><strong>栈</strong>：自动分配与释放；访问速度快；适用于函数调用、状态机、撤销等场景；容量有限且线程私有。</li>\n<li><strong>堆</strong>：动态分配与释放；灵活但开销较大；可能发生碎片；适用于缓存管理、对象池、动态数据结构等场景。</li>\n<li>理解两者在内存布局上的位置及增长方式，有助于避免栈溢出和堆栈冲突，提高程序安全性与性能。</li>\n</ul>\n","excerpt":"","more":"<h1 id=\"堆、栈及其应用分析\"><a href=\"#堆、栈及其应用分析\" class=\"headerlink\" title=\"堆、栈及其应用分析\"></a>堆、栈及其应用分析</h1><h1 id=\"参考资料\"><a href=\"#参考资料\" class=\"headerlink\" title=\"参考资料\"></a>参考资料</h1><blockquote>\n<ul>\n<li><a href=\"https://www.cnblogs.com/linfangnan/p/12450061.html\">栈结构解析及其应用 - 乌漆 WhiteMoon - 博客园</a></li>\n<li><a href=\"https://www.cnblogs.com/moonandstar08/p/4934597.html\">堆栈信息分析 - moonandstar08 - 博客园</a></li>\n<li><a href=\"https://www.cnblogs.com/tolin/p/14982094.html\">什么是堆?什么是栈?他们之间有什么区别和联系? - tolin - 博客园</a></li>\n</ul>\n</blockquote>\n<h1 id=\"堆-Heap-与-栈-Stack-概述\"><a href=\"#堆-Heap-与-栈-Stack-概述\" class=\"headerlink\" title=\"堆 (Heap) 与 栈 (Stack) 概述\"></a>堆 (Heap) 与 栈 (Stack) 概述</h1><ul>\n<li><p><strong>栈（Stack）</strong></p>\n</li>\n<li><p><strong>数据结构视角</strong>：一种受限的线性结构，只能在同一端（栈顶）进行插入（Push）和删除（Pop），遵循 “后进先出”（LIFO）原则。</p>\n</li>\n<li><p><strong>内存视角</strong>：栈区由操作系统自动分配与回收，用于存储函数调用时的局部变量、函数参数、返回地址等信息。栈空间连续，访问和分配速度极快，但容量有限（通常几 MB），每个线程都有独立栈空间。</p>\n</li>\n<li><p><strong>堆（Heap）</strong></p>\n<ul>\n<li><strong>数据结构视角</strong>：一种近似完全二叉树的优先队列结构（最大堆或最小堆），常用于按优先级提取元素。</li>\n<li><strong>内存视角</strong>：堆区用于动态分配内存，程序运行时可调用 <code>new</code>&#x2F;<code>malloc</code>（C++）或由运行时自动分配（Python）来获取；释放时需 <code>delete</code>&#x2F;<code>free</code> 或由垃圾回收负责。堆空间大但分配、释放开销较大，可能产生内存碎片。</li>\n</ul>\n</li>\n</ul>\n<h2 id=\"数据结构视角\"><a href=\"#数据结构视角\" class=\"headerlink\" title=\"数据结构视角\"></a>数据结构视角</h2><p><strong>栈</strong>：一种线性受限结构，只允许在栈顶进行插入（Push）和删除（Pop），遵循“后进先出”（LIFO）原则。常用操作包括 <code>push</code>（进栈）、<code>pop</code>（出栈）、<code>top</code>（取栈顶）等，这些操作时间复杂度通常为 O(1)。栈可用数组（顺序栈）或链表（链式栈）实现，适用于函数调用、递归计算、撤销操作等场景。</p>\n<blockquote>\n<ul>\n<li><a href=\"https://oi-wiki.org/ds/stack/\">栈 - OI Wiki</a></li>\n</ul>\n</blockquote>\n<h3 id=\"使用数组模拟栈\"><a href=\"#使用数组模拟栈\" class=\"headerlink\" title=\"使用数组模拟栈\"></a>使用数组模拟栈</h3><figure class=\"highlight cpp\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"type\">int</span> st[N];</span><br><span class=\"line\"><span class=\"comment\">// 这里使用 st[0] (即 *st) 代表栈中元素数量，同时也是栈顶下标</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// 压栈 ：</span></span><br><span class=\"line\">st[++*st] = var1;</span><br><span class=\"line\"><span class=\"comment\">// 取栈顶 ：</span></span><br><span class=\"line\"><span class=\"type\">int</span> u = st[*st];</span><br><span class=\"line\"><span class=\"comment\">// 弹栈 ：注意越界问题, *st == 0 时不能继续弹出</span></span><br><span class=\"line\"><span class=\"keyword\">if</span> (*st) --*st;</span><br><span class=\"line\"><span class=\"comment\">// 清空栈</span></span><br><span class=\"line\">*st = <span class=\"number\">0</span>;</span><br></pre></td></tr></table></figure>\n\n<h3 id=\"C-STL-中的栈\"><a href=\"#C-STL-中的栈\" class=\"headerlink\" title=\"C++ STL 中的栈\"></a>C++ STL 中的栈</h3><p>C++ 中的 STL 也提供了一个容器 <code>std::stack</code>，使用前需要引入 <code>stack</code> 头文件。</p>\n<p>STL 中的 <code>stack</code> 容器提供了一众成员函数以供调用，其中较为常用的有：</p>\n<ul>\n<li><p>元素访问</p>\n<ul>\n<li><code>st.top()</code> 返回栈顶</li>\n</ul>\n</li>\n<li><p>修改</p>\n<ul>\n<li><code>st.push()</code> 插入传入的参数到栈顶</li>\n<li><code>st.pop()</code> 弹出栈顶</li>\n</ul>\n</li>\n<li><p>容量</p>\n<ul>\n<li><code>st.empty()</code> 返回是否为空</li>\n<li><code>st.size()</code> 返回元素数量</li>\n</ul>\n</li>\n</ul>\n<p>此外，<code>std::stack</code> 还提供了一些运算符。较为常用的是使用赋值运算符 <code>=</code> 为 <code>stack</code> 赋值，示例：</p>\n<figure class=\"highlight cpp\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// 新建两个栈 st1 和 st2</span></span><br><span class=\"line\">std::stack&lt;<span class=\"type\">int</span>&gt; st1, st2;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// 为 st1 装入 1</span></span><br><span class=\"line\">st<span class=\"number\">1.</span><span class=\"built_in\">push</span>(<span class=\"number\">1</span>);</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// 将 st1 赋值给 st2</span></span><br><span class=\"line\">st2 = st1;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// 输出 st2 的栈顶元素</span></span><br><span class=\"line\">cout &lt;&lt; st<span class=\"number\">2.</span><span class=\"built_in\">top</span>() &lt;&lt; endl;</span><br><span class=\"line\"><span class=\"comment\">// 输出: 1</span></span><br></pre></td></tr></table></figure>\n\n<h3 id=\"使用-Python-中的-list-模拟栈\"><a href=\"#使用-Python-中的-list-模拟栈\" class=\"headerlink\" title=\"使用 Python 中的 list 模拟栈\"></a>使用 Python 中的 list 模拟栈</h3><figure class=\"highlight python\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">st = [<span class=\"number\">5</span>, <span class=\"number\">1</span>, <span class=\"number\">4</span>]</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\"># 使用 append() 向栈顶添加元素</span></span><br><span class=\"line\">st.append(<span class=\"number\">2</span>)</span><br><span class=\"line\">st.append(<span class=\"number\">3</span>)</span><br><span class=\"line\"><span class=\"comment\"># &gt;&gt;&gt; st</span></span><br><span class=\"line\"><span class=\"comment\"># [5, 1, 4, 2, 3]</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\"># 使用 pop 取出栈顶元素</span></span><br><span class=\"line\">st.pop()</span><br><span class=\"line\"><span class=\"comment\"># &gt;&gt;&gt; st</span></span><br><span class=\"line\"><span class=\"comment\"># [5, 1, 4, 2]</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\"># 使用 clear 清空栈</span></span><br><span class=\"line\">st.clear()</span><br></pre></td></tr></table></figure>\n\n<p><strong>堆</strong>（优先队列）: 一种树形结构，即满足堆序性的完全二叉树。每个节点的值都不大于（或不小于）其父节点的值，根节点是最大值（大顶堆）或最小值（小顶堆）。常见操作包括：上浮（shift_up）、下沉（shift_down）、插入（push）和弹出（pop）堆顶元素，以及查询堆顶（top）。堆常用作优先队列，在任务调度、Dijkstra 最短路径、Top-K 计算等场景中非常常见。</p>\n<blockquote>\n<ul>\n<li><a href=\"https://oi-wiki.org/ds/heap/\">堆简介 - OI Wiki</a></li>\n</ul>\n</blockquote>\n<p>堆是一棵树，其每个节点都有一个键值，且每个节点的键值都大于等于&#x2F;小于等于其父亲的键值。</p>\n<p>每个节点的键值都大于等于其父亲键值的堆叫做小根堆，否则叫做大根堆。STL 中的 priority_queue 其实就是一个大根堆。</p>\n<p>（小根）堆主要支持的操作有：插入一个数、查询最小值、删除最小值、合并两个堆、减小一个元素的值。</p>\n<p>一些功能强大的堆（可并堆）还能（高效地）支持 merge 等操作。</p>\n<p>一些功能更强大的堆还支持可持久化，也就是对任意历史版本进行查询或者操作，产生新的版本。</p>\n<h3 id=\"C-堆-优先队列：默认大顶堆（priority-queue）：\"><a href=\"#C-堆-优先队列：默认大顶堆（priority-queue）：\" class=\"headerlink\" title=\"C++ 堆&#x2F;优先队列：默认大顶堆（priority_queue）：\"></a><strong>C++ 堆&#x2F;优先队列</strong>：默认大顶堆（<code>priority_queue</code>）：</h3><figure class=\"highlight cpp\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">std::priority_queue&lt;<span class=\"type\">int</span>&gt; pq;</span><br><span class=\"line\">pq.<span class=\"built_in\">push</span>(<span class=\"number\">5</span>);</span><br><span class=\"line\">pq.<span class=\"built_in\">push</span>(<span class=\"number\">3</span>);</span><br><span class=\"line\"><span class=\"type\">int</span> top = pq.<span class=\"built_in\">top</span>(); <span class=\"comment\">// 5 (最大值)</span></span><br><span class=\"line\">pq.<span class=\"built_in\">pop</span>();</span><br></pre></td></tr></table></figure>\n\n<h3 id=\"Python-堆（heapq-最小堆）：\"><a href=\"#Python-堆（heapq-最小堆）：\" class=\"headerlink\" title=\"Python 堆（heapq 最小堆）：\"></a><strong>Python 堆</strong>（<code>heapq</code> 最小堆）：</h3><figure class=\"highlight python\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">import</span> heapq</span><br><span class=\"line\">heap = []</span><br><span class=\"line\">heapq.heappush(heap, <span class=\"number\">3</span>)</span><br><span class=\"line\">heapq.heappush(heap, <span class=\"number\">5</span>)</span><br><span class=\"line\">top = heapq.heappop(heap)  <span class=\"comment\"># 3 (最小值)</span></span><br></pre></td></tr></table></figure>\n\n<ul>\n<li>如果需要大顶堆，可插入负值或使用第三方实现。</li>\n</ul>\n<h3 id=\"堆排序\"><a href=\"#堆排序\" class=\"headerlink\" title=\"堆排序\"></a>堆排序</h3><blockquote>\n<p><a href=\"https://algorithm-visualizer.org/brute-force/heapsort\">Brute Force Heapsort</a></p>\n</blockquote>\n<p>堆排序是一种高效的、基于比较的排序算法。它利用了堆这种数据结构的特性。基本思想是：</p>\n<ol>\n<li><p>**建堆 (Heapify)**：将待排序的序列构建成一个大顶堆（或小顶堆）。此时，堆顶元素就是整个序列的最大值（或最小值）。</p>\n</li>\n<li><p>**排序 (Sort)**：</p>\n<ul>\n<li>将堆顶元素与序列末尾的元素交换。</li>\n<li>此时，序列末尾的元素即为最大（或最小）值，已经处于正确排序位置。</li>\n<li>将剩余的 n-1 个元素重新调整为一个堆。</li>\n<li>重复此过程，直到所有元素都排序完毕。</li>\n</ul>\n</li>\n</ol>\n<p>堆排序的平均时间复杂度和最坏时间复杂度都是 O(nlogn)。</p>\n<h4 id=\"C-实现堆排序\"><a href=\"#C-实现堆排序\" class=\"headerlink\" title=\"C++ 实现堆排序\"></a>C++ 实现堆排序</h4><p>在 C++ 中，可以利用标准库 <code>&lt;algorithm&gt;</code> 中提供的堆操作函数来方便地实现堆排序。</p>\n<ul>\n<li><code>std::make_heap(first, last)</code>: 将指定范围 <code>[first, last)</code> 内的元素重新排列，使其成为一个大顶堆。</li>\n<li><code>std::sort_heap(first, last)</code>: 将一个已经建好的堆 <code>[first, last)</code> 进行排序。它会重复地将堆顶元素（最大值）移动到序列的末尾，并重新调整剩余部分为堆。</li>\n</ul>\n<p>C++</p>\n<figure class=\"highlight cpp\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">#<span class=\"keyword\">include</span> <span class=\"string\">&lt;iostream&gt;</span></span></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"keyword\">include</span> <span class=\"string\">&lt;vector&gt;</span></span></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"keyword\">include</span> <span class=\"string\">&lt;algorithm&gt;</span> <span class=\"comment\">// 包含 make_heap, sort_heap</span></span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"type\">void</span> <span class=\"title\">print_vector</span><span class=\"params\">(<span class=\"type\">const</span> std::vector&lt;<span class=\"type\">int</span>&gt;&amp; vec)</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">for</span> (<span class=\"type\">int</span> val : vec) &#123;</span><br><span class=\"line\">        std::cout &lt;&lt; val &lt;&lt; <span class=\"string\">&quot; &quot;</span>;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    std::cout &lt;&lt; std::endl;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"type\">int</span> <span class=\"title\">main</span><span class=\"params\">()</span> </span>&#123;</span><br><span class=\"line\">    std::vector&lt;<span class=\"type\">int</span>&gt; v = &#123;<span class=\"number\">3</span>, <span class=\"number\">5</span>, <span class=\"number\">1</span>, <span class=\"number\">8</span>, <span class=\"number\">4</span>, <span class=\"number\">7</span>, <span class=\"number\">2</span>&#125;;</span><br><span class=\"line\">    std::cout &lt;&lt; <span class=\"string\">&quot;Original vector: &quot;</span>;</span><br><span class=\"line\">    <span class=\"built_in\">print_vector</span>(v);</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\">// 1. 将 vector 转换成大顶堆</span></span><br><span class=\"line\">    std::<span class=\"built_in\">make_heap</span>(v.<span class=\"built_in\">begin</span>(), v.<span class=\"built_in\">end</span>());</span><br><span class=\"line\">    std::cout &lt;&lt; <span class=\"string\">&quot;After make_heap (top is max): &quot;</span> &lt;&lt; v.<span class=\"built_in\">front</span>() &lt;&lt; std::endl;</span><br><span class=\"line\">  </span><br><span class=\"line\">    <span class=\"comment\">// 2. 对堆进行排序 (结果为升序)</span></span><br><span class=\"line\">    std::<span class=\"built_in\">sort_heap</span>(v.<span class=\"built_in\">begin</span>(), v.<span class=\"built_in\">end</span>());</span><br><span class=\"line\">  </span><br><span class=\"line\">    std::cout &lt;&lt; <span class=\"string\">&quot;Sorted vector: &quot;</span>;</span><br><span class=\"line\">    <span class=\"built_in\">print_vector</span>(v); <span class=\"comment\">// 输出: 1 2 3 4 5 7 8</span></span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">return</span> <span class=\"number\">0</span>;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<h4 id=\"Python-实现堆排序\"><a href=\"#Python-实现堆排序\" class=\"headerlink\" title=\"Python 实现堆排序\"></a>Python 实现堆排序</h4><p>Python 的 <code>heapq</code> 模块本身不直接提供一个完整的 <code>heapsort</code> 函数，但我们可以很容易地利用其 <code>heappush</code> 和 <code>heappop</code> 来实现。因为 <code>heapq</code> 是最小堆，所以 <code>heappop</code> 总是弹出最小值，天然适合用于升序排序。</p>\n<figure class=\"highlight python\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">import</span> heapq</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">def</span> <span class=\"title function_\">heapsort_asc</span>(<span class=\"params\">iterable</span>):</span><br><span class=\"line\">    <span class=\"string\">&quot;&quot;&quot;</span></span><br><span class=\"line\"><span class=\"string\">    使用 heapq 实现升序排序</span></span><br><span class=\"line\"><span class=\"string\">    &quot;&quot;&quot;</span></span><br><span class=\"line\">    h = []</span><br><span class=\"line\">    <span class=\"comment\"># 将所有元素压入堆中</span></span><br><span class=\"line\">    <span class=\"keyword\">for</span> value <span class=\"keyword\">in</span> iterable:</span><br><span class=\"line\">        heapq.heappush(h, value)</span><br><span class=\"line\">    <span class=\"comment\"># 依次弹出堆中最小的元素，构成有序列表</span></span><br><span class=\"line\">    <span class=\"keyword\">return</span> [heapq.heappop(h) <span class=\"keyword\">for</span> _ <span class=\"keyword\">in</span> <span class=\"built_in\">range</span>(<span class=\"built_in\">len</span>(h))]</span><br><span class=\"line\"></span><br><span class=\"line\">data = [<span class=\"number\">3</span>, <span class=\"number\">5</span>, <span class=\"number\">1</span>, <span class=\"number\">8</span>, <span class=\"number\">4</span>, <span class=\"number\">7</span>, <span class=\"number\">2</span>]</span><br><span class=\"line\"><span class=\"built_in\">print</span>(<span class=\"string\">f&quot;Original list: <span class=\"subst\">&#123;data&#125;</span>&quot;</span>)</span><br><span class=\"line\"></span><br><span class=\"line\">sorted_data = heapsort_asc(data)</span><br><span class=\"line\"><span class=\"built_in\">print</span>(<span class=\"string\">f&quot;Sorted list (ascending): <span class=\"subst\">&#123;sorted_data&#125;</span>&quot;</span>) <span class=\"comment\"># 输出: [1, 2, 3, 4, 5, 7, 8]</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\"># 原地堆排序 (In-place Heap Sort)</span></span><br><span class=\"line\"><span class=\"comment\"># 这更接近于堆排序的经典实现</span></span><br><span class=\"line\"><span class=\"keyword\">def</span> <span class=\"title function_\">heapsort_inplace</span>(<span class=\"params\">arr</span>):</span><br><span class=\"line\">    n = <span class=\"built_in\">len</span>(arr)</span><br><span class=\"line\">    <span class=\"comment\"># 1. 构建大顶堆 (从最后一个非叶子节点开始)</span></span><br><span class=\"line\">    <span class=\"comment\"># 注意：heapq 是最小堆，所以这里通过对负数操作来模拟大顶堆</span></span><br><span class=\"line\">    <span class=\"comment\"># 或者我们手动实现大顶堆的 sift_down</span></span><br><span class=\"line\">    <span class=\"comment\"># 为了简单，我们还是用 heapq 来理解，但传统实现更高效</span></span><br><span class=\"line\">    h = []</span><br><span class=\"line\">    <span class=\"keyword\">for</span> x <span class=\"keyword\">in</span> arr:</span><br><span class=\"line\">        heapq.heappush(h, x)</span><br><span class=\"line\">    arr[:] = [heapq.heappop(h) <span class=\"keyword\">for</span> _ <span class=\"keyword\">in</span> <span class=\"built_in\">range</span>(n)]</span><br><span class=\"line\">    <span class=\"keyword\">return</span> arr</span><br><span class=\"line\"></span><br><span class=\"line\">data_inplace = [<span class=\"number\">3</span>, <span class=\"number\">5</span>, <span class=\"number\">1</span>, <span class=\"number\">8</span>, <span class=\"number\">4</span>, <span class=\"number\">7</span>, <span class=\"number\">2</span>]</span><br><span class=\"line\">heapsort_inplace(data_inplace)</span><br><span class=\"line\"><span class=\"built_in\">print</span>(<span class=\"string\">f&quot;In-place sorted list: <span class=\"subst\">&#123;data_inplace&#125;</span>&quot;</span>)</span><br></pre></td></tr></table></figure>\n\n<p>栈和堆（优先队列）各有特点：</p>\n<ul>\n<li><strong>数据组织</strong>：栈是线性的、受限的结构，只能从一端操作；堆是树形结构，可快速获取最大或最小元素。</li>\n<li><strong>访问效率</strong>：栈操作简单开销小；堆插入&#x2F;删除需维护堆序（O(log n)）。</li>\n<li><strong>应用场景</strong>：栈适合管理临时状态（如函数调用栈、表达式求值、撤销操作）；堆（优先队列）适合按优先级处理元素，如操作系统任务调度、网络请求优先级、算法中的最佳-优先搜索等。</li>\n</ul>\n<h2 id=\"内存分配视角\"><a href=\"#内存分配视角\" class=\"headerlink\" title=\"内存分配视角\"></a>内存分配视角</h2><p>在程序运行时，内存通常分为<strong>代码区</strong>、<strong>数据区</strong>、<strong>堆区</strong>和<strong>栈区</strong>。其中：</p>\n<ul>\n<li><strong>栈区</strong>：由系统自动管理，随函数调用而增长，每次函数调用时分配空间给局部变量、函数参数和返回地址。函数返回时，这些空间自动回收。栈分配速度快、开销低，但空间有限（常见几 MB），且每个线程都有独立的栈空间。如果栈空间不足，会导致栈溢出错误。</li>\n<li><strong>堆区</strong>：用于动态内存分配，程序员（或运行时）在运行时使用 <code>new</code>&#x2F;<code>malloc</code> 等申请内存，由程序员 <code>delete</code>&#x2F;<code>free</code> 释放（在 Python&#x2F;Java 等语言由垃圾回收自动释放）。堆的可用空间远大于栈，存放<strong>动态对象</strong>。堆内存碎片化的风险更高：频繁的分配和释放可能将大块连续内存切割成许多小碎片，降低利用率。</li>\n<li><strong>静态&#x2F;全局区</strong>：编译时分配，程序运行前即确定，存放全局变量、静态变量和常量，在程序整个生命周期存在。</li>\n</ul>\n<p><strong>分配方式</strong>：栈的分配和回收速度极快，操作由 CPU 指令自动完成；堆的分配开销较大，一般需要额外的内存管理算法（如自由链表或分代收集），在 C++ 中需要程序员手动释放。Python 中所有对象都分配在堆上，解释器通过引用计数和垃圾回收来管理。</p>\n<p><strong>访问效率</strong>：由于栈内存连续、分配固定，因此访问和分配速度更高。堆内存由多个块组成，需额外指针管理，因而略慢于栈访问。此外，栈是线程私有的（线程安全），而堆是所有线程共享的（需注意并发安全）。</p>\n<ul>\n<li><strong>C++ 栈 vs 堆 分配</strong>：</li>\n</ul>\n<figure class=\"highlight cpp\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"type\">void</span> <span class=\"title\">func</span><span class=\"params\">()</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"type\">int</span> a = <span class=\"number\">10</span>;            <span class=\"comment\">// 分配在栈上</span></span><br><span class=\"line\">    <span class=\"type\">int</span> *p = <span class=\"keyword\">new</span> <span class=\"built_in\">int</span>(<span class=\"number\">20</span>);  <span class=\"comment\">// 分配在堆上</span></span><br><span class=\"line\">    <span class=\"comment\">// ...</span></span><br><span class=\"line\">    <span class=\"keyword\">delete</span> p;              <span class=\"comment\">// 手动释放堆内存</span></span><br><span class=\"line\">&#125; <span class=\"comment\">// 函数返回时，a 的栈空间自动释放，若忘了 delete，则 p 指向的内存泄露</span></span><br></pre></td></tr></table></figure>\n\n<ul>\n<li><strong>Python 对象分配</strong>：</li>\n</ul>\n<figure class=\"highlight python\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">def</span> <span class=\"title function_\">func</span>():</span><br><span class=\"line\">    a = <span class=\"number\">10</span>             <span class=\"comment\"># 10 是整数对象，存储在堆中；a 是栈帧内的局部引用</span></span><br><span class=\"line\">    b = [<span class=\"number\">1</span>, <span class=\"number\">2</span>, <span class=\"number\">3</span>]      <span class=\"comment\"># 列表对象在堆上分配</span></span><br><span class=\"line\">    <span class=\"comment\"># 变量 a, b 是存放在函数调用栈帧中的引用，当函数结束，这些引用消失</span></span><br></pre></td></tr></table></figure>\n\n<ul>\n<li>Python 不需要显示释放内存，垃圾回收自动回收无用对象。</li>\n</ul>\n<h2 id=\"典型应用场景\"><a href=\"#典型应用场景\" class=\"headerlink\" title=\"典型应用场景\"></a>典型应用场景</h2><h3 id=\"函数调用与返回\"><a href=\"#函数调用与返回\" class=\"headerlink\" title=\"函数调用与返回\"></a>函数调用与返回</h3><p>当程序调用一个函数时，当前上下文（包括当前函数的局部变量、返回地址、CPU 寄存器等）会被“压栈（push）”到栈上；函数执行完成后，栈顶信息被“弹栈（pop）”，程序自动返回调用点并恢复先前状态。这种机制正是栈的典型应用。</p>\n<h4 id=\"C-示例\"><a href=\"#C-示例\" class=\"headerlink\" title=\"C++ 示例\"></a>C++ 示例</h4><figure class=\"highlight cpp\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">#<span class=\"keyword\">include</span> <span class=\"string\">&lt;iostream&gt;</span></span></span><br><span class=\"line\"><span class=\"comment\">// 一个示例函数，用于演示栈帧形成</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"type\">int</span> <span class=\"title\">factorial</span><span class=\"params\">(<span class=\"type\">int</span> n)</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (n &lt;= <span class=\"number\">1</span>) &#123;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> <span class=\"number\">1</span>;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"comment\">// 调用 factorial(n-1) 前，会把当前的 n、返回地址等信息压入栈</span></span><br><span class=\"line\">    <span class=\"keyword\">return</span> n * <span class=\"built_in\">factorial</span>(n - <span class=\"number\">1</span>);</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"function\"><span class=\"type\">int</span> <span class=\"title\">main</span><span class=\"params\">()</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"type\">int</span> x = <span class=\"number\">5</span>;</span><br><span class=\"line\">    std::cout &lt;&lt; <span class=\"string\">&quot;factorial(&quot;</span> &lt;&lt; x &lt;&lt; <span class=\"string\">&quot;) = &quot;</span> &lt;&lt; <span class=\"built_in\">factorial</span>(x) &lt;&lt; std::endl;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> <span class=\"number\">0</span>;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<ul>\n<li>每次调用 <code>factorial</code> 时，当前函数的局部变量（如 <code>n</code>）和返回地址会压入栈；函数结束时，栈帧被弹出，返回到上一级调用点。</li>\n</ul>\n<h4 id=\"Python-示例\"><a href=\"#Python-示例\" class=\"headerlink\" title=\"Python 示例\"></a>Python 示例</h4><figure class=\"highlight python\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">def</span> <span class=\"title function_\">factorial</span>(<span class=\"params\">n</span>):</span><br><span class=\"line\">    <span class=\"keyword\">if</span> n &lt;= <span class=\"number\">1</span>:</span><br><span class=\"line\">        <span class=\"keyword\">return</span> <span class=\"number\">1</span></span><br><span class=\"line\">    <span class=\"comment\"># 递归调用时，Python 会将当前函数帧压入调用栈</span></span><br><span class=\"line\">    <span class=\"keyword\">return</span> n * factorial(n - <span class=\"number\">1</span>)</span><br><span class=\"line\"><span class=\"keyword\">if</span> </span><br><span class=\"line\">name</span><br><span class=\"line\"> == <span class=\"string\">&quot;</span></span><br><span class=\"line\"><span class=\"string\">__main__</span></span><br><span class=\"line\"><span class=\"string\">&quot;</span>:</span><br><span class=\"line\">    x = <span class=\"number\">5</span></span><br><span class=\"line\">    <span class=\"built_in\">print</span>(<span class=\"string\">f&quot;factorial(<span class=\"subst\">&#123;x&#125;</span>) =&quot;</span>, factorial(x))</span><br></pre></td></tr></table></figure>\n\n<ul>\n<li>Python 解释器内部也维护一个“调用栈”，每个函数调用都会在栈中创建一个帧（Frame），存放局部变量和执行状态。</li>\n</ul>\n<hr>\n<h3 id=\"内存管理（局部变量与函数参数）\"><a href=\"#内存管理（局部变量与函数参数）\" class=\"headerlink\" title=\"内存管理（局部变量与函数参数）\"></a>内存管理（局部变量与函数参数）</h3><h4 id=\"说明\"><a href=\"#说明\" class=\"headerlink\" title=\"说明\"></a>说明</h4><ul>\n<li><strong>栈分配</strong>：编译器在编译期或运行期自动为每个函数分配固定的栈空间，用于存储局部变量和函数参数。函数结束时，这些空间会自动释放，无需程序员手动管理。</li>\n<li><strong>堆分配</strong>：程序员可在运行时动态向操作系统请求内存，使用 <code>new</code>&#x2F;<code>malloc</code>（C++）或创建对象（Python）。这些内存由程序员负责释放（或由垃圾回收器回收）。</li>\n</ul>\n<h4 id=\"C-示例：栈-vs-堆\"><a href=\"#C-示例：栈-vs-堆\" class=\"headerlink\" title=\"C++ 示例：栈 vs 堆\"></a>C++ 示例：栈 vs 堆</h4><figure class=\"highlight cpp\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">#<span class=\"keyword\">include</span> <span class=\"string\">&lt;iostream&gt;</span></span></span><br><span class=\"line\"><span class=\"function\"><span class=\"type\">void</span> <span class=\"title\">stackExample</span><span class=\"params\">()</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"type\">int</span> a = <span class=\"number\">10</span>;             <span class=\"comment\">// 分配在栈上</span></span><br><span class=\"line\">    <span class=\"type\">int</span> b[<span class=\"number\">100</span>];             <span class=\"comment\">// 数组也分配在栈上</span></span><br><span class=\"line\">    std::cout &lt;&lt; <span class=\"string\">&quot;a = &quot;</span> &lt;&lt; a &lt;&lt; std::endl;</span><br><span class=\"line\">    std::cout &lt;&lt; <span class=\"string\">&quot;b[0] = &quot;</span> &lt;&lt; b[<span class=\"number\">0</span>] &lt;&lt; std::endl;</span><br><span class=\"line\">&#125; <span class=\"comment\">// 函数结束时，a 和 b 的栈空间自动释放</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"type\">void</span> <span class=\"title\">heapExample</span><span class=\"params\">()</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"type\">int</span> *p = <span class=\"keyword\">new</span> <span class=\"built_in\">int</span>(<span class=\"number\">20</span>);   <span class=\"comment\">// 在堆上分配一个 int</span></span><br><span class=\"line\">    <span class=\"type\">int</span> *arr = <span class=\"keyword\">new</span> <span class=\"type\">int</span>[<span class=\"number\">100</span>];<span class=\"comment\">// 在堆上分配一个大小为 100 的数组</span></span><br><span class=\"line\">    std::cout &lt;&lt; <span class=\"string\">&quot;*p = &quot;</span> &lt;&lt; *p &lt;&lt; std::endl;</span><br><span class=\"line\">    std::cout &lt;&lt; <span class=\"string\">&quot;arr[0] = &quot;</span> &lt;&lt; arr[<span class=\"number\">0</span>] &lt;&lt; std::endl;</span><br><span class=\"line\">    <span class=\"keyword\">delete</span> p;               <span class=\"comment\">// 释放堆内存</span></span><br><span class=\"line\">    <span class=\"keyword\">delete</span>[] arr;           <span class=\"comment\">// 释放数组</span></span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"function\"><span class=\"type\">int</span> <span class=\"title\">main</span><span class=\"params\">()</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"built_in\">stackExample</span>();</span><br><span class=\"line\">    <span class=\"built_in\">heapExample</span>();</span><br><span class=\"line\">    <span class=\"keyword\">return</span> <span class=\"number\">0</span>;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<ul>\n<li><code>stackExample</code>：变量 <code>a</code> 和数组 <code>b</code> 分配在栈上，由系统自动分配与回收。</li>\n<li><code>heapExample</code>：使用 <code>new</code> 在堆上分配内存，需要手动调用 <code>delete</code>&#x2F;<code>delete[]</code> 来释放，否则会发生内存泄漏。</li>\n</ul>\n<h4 id=\"Python-示例：对象分配在堆上\"><a href=\"#Python-示例：对象分配在堆上\" class=\"headerlink\" title=\"Python 示例：对象分配在堆上\"></a>Python 示例：对象分配在堆上</h4><figure class=\"highlight python\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">def</span> <span class=\"title function_\">memory_example</span>():</span><br><span class=\"line\">    a = <span class=\"number\">10</span>            <span class=\"comment\"># 整数对象 10 存储在堆上，a 是栈帧中的一个引用</span></span><br><span class=\"line\">    lst = [<span class=\"number\">1</span>, <span class=\"number\">2</span>, <span class=\"number\">3</span>]   <span class=\"comment\"># 列表对象存储在堆上，lst 引用保存在栈帧</span></span><br><span class=\"line\">    <span class=\"built_in\">print</span>(a, lst)</span><br><span class=\"line\"><span class=\"keyword\">if</span> </span><br><span class=\"line\">name</span><br><span class=\"line\"> == <span class=\"string\">&quot;</span></span><br><span class=\"line\"><span class=\"string\">__main__</span></span><br><span class=\"line\"><span class=\"string\">&quot;</span>:</span><br><span class=\"line\">    memory_example()</span><br><span class=\"line\">    <span class=\"comment\"># Python 通过引用计数和垃圾回收自动释放不再使用的对象</span></span><br></pre></td></tr></table></figure>\n\n<ul>\n<li>在 Python 中，所有对象都分配在堆上，局部变量仅是对这些对象的引用，保存在栈帧中。函数退出时，局部引用消失，引用计数可能降为 0，垃圾回收器会回收对象。</li>\n</ul>\n<hr>\n<h3 id=\"表达式求值（逆波兰表达式）\"><a href=\"#表达式求值（逆波兰表达式）\" class=\"headerlink\" title=\"表达式求值（逆波兰表达式）\"></a>表达式求值（逆波兰表达式）</h3><h4 id=\"说明-1\"><a href=\"#说明-1\" class=\"headerlink\" title=\"说明\"></a>说明</h4><p>逆波兰表达式（后缀表达式）无需括号即可明确运算顺序，评估过程中需要一个栈来保存操作数、临时结果。</p>\n<ul>\n<li>遇到操作数时，压栈</li>\n<li>遇到运算符时，从栈中弹出相应数量的操作数进行计算，并将结果压回栈</li>\n<li>最后栈顶即为运算结果</li>\n</ul>\n<h4 id=\"C-示例（仅支持-四则运算）\"><a href=\"#C-示例（仅支持-四则运算）\" class=\"headerlink\" title=\"C++ 示例（仅支持 + - * / 四则运算）\"></a>C++ 示例（仅支持 <code>+ - * /</code> 四则运算）</h4><figure class=\"highlight cpp\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">#<span class=\"keyword\">include</span> <span class=\"string\">&lt;iostream&gt;</span></span></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"keyword\">include</span> <span class=\"string\">&lt;stack&gt;</span></span></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"keyword\">include</span> <span class=\"string\">&lt;sstream&gt;</span></span></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"keyword\">include</span> <span class=\"string\">&lt;string&gt;</span></span></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"keyword\">include</span> <span class=\"string\">&lt;vector&gt;</span></span></span><br><span class=\"line\"><span class=\"comment\">// 将字符串拆分为逆波兰表达式的 tokens</span></span><br><span class=\"line\"><span class=\"function\">std::vector&lt;std::string&gt; <span class=\"title\">tokenize</span><span class=\"params\">(<span class=\"type\">const</span> std::string &amp;expr)</span> </span>&#123;</span><br><span class=\"line\">    std::vector&lt;std::string&gt; tokens;</span><br><span class=\"line\">    <span class=\"function\">std::istringstream <span class=\"title\">iss</span><span class=\"params\">(expr)</span></span>;</span><br><span class=\"line\">    std::string token;</span><br><span class=\"line\">    <span class=\"keyword\">while</span> (iss &gt;&gt; token) &#123;</span><br><span class=\"line\">        tokens.<span class=\"built_in\">push_back</span>(token);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> tokens;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"function\"><span class=\"type\">int</span> <span class=\"title\">evalRPN</span><span class=\"params\">(<span class=\"type\">const</span> std::vector&lt;std::string&gt; &amp;tokens)</span> </span>&#123;</span><br><span class=\"line\">    std::stack&lt;<span class=\"type\">int</span>&gt; st;</span><br><span class=\"line\">    <span class=\"keyword\">for</span> (<span class=\"type\">const</span> <span class=\"keyword\">auto</span> &amp;tk : tokens) &#123;</span><br><span class=\"line\">        <span class=\"keyword\">if</span> (tk == <span class=\"string\">&quot;+&quot;</span> || tk == <span class=\"string\">&quot;-&quot;</span> || tk == <span class=\"string\">&quot;</span></span><br><span class=\"line\"><span class=\"string\">_&quot;</span> || tk == <span class=\"string\">&quot;/&quot;</span>) &#123;</span><br><span class=\"line\">            <span class=\"type\">int</span> b = st.<span class=\"built_in\">top</span>(); st.<span class=\"built_in\">pop</span>();</span><br><span class=\"line\">            <span class=\"type\">int</span> a = st.<span class=\"built_in\">top</span>(); st.<span class=\"built_in\">pop</span>();</span><br><span class=\"line\">            <span class=\"type\">int</span> res = <span class=\"number\">0</span>;</span><br><span class=\"line\">            <span class=\"keyword\">if</span> (tk == <span class=\"string\">&quot;+&quot;</span>) res = a + b;</span><br><span class=\"line\">            <span class=\"keyword\">else</span> <span class=\"keyword\">if</span> (tk == <span class=\"string\">&quot;-&quot;</span>) res = a - b;</span><br><span class=\"line\"><span class=\"function\">_*            <span class=\"keyword\">else</span> <span class=\"title\">if</span> <span class=\"params\">(tk == <span class=\"string\">&quot;*</span></span></span></span><br><span class=\"line\"><span class=\"string\"><span class=\"params\"><span class=\"function\">&quot;</span>)</span> res </span>= a * b;</span><br><span class=\"line\">            <span class=\"keyword\">else</span> <span class=\"keyword\">if</span> (tk == <span class=\"string\">&quot;/&quot;</span>) res = a / b;</span><br><span class=\"line\">            st.<span class=\"built_in\">push</span>(res);</span><br><span class=\"line\">        &#125; <span class=\"keyword\">else</span> &#123;</span><br><span class=\"line\">            st.<span class=\"built_in\">push</span>(std::<span class=\"built_in\">stoi</span>(tk));</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> st.<span class=\"built_in\">top</span>();</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"function\"><span class=\"type\">int</span> <span class=\"title\">main</span><span class=\"params\">()</span> </span>&#123;</span><br><span class=\"line\">    std::string expr = <span class=\"string\">&quot;3 4 + 2 * 7 /&quot;</span>;</span><br><span class=\"line\">    <span class=\"comment\">// 对应中缀: ((3 + 4) * 2) / 7 = 2</span></span><br><span class=\"line\">    <span class=\"keyword\">auto</span> tokens = <span class=\"built_in\">tokenize</span>(expr);</span><br><span class=\"line\">    std::cout &lt;&lt; <span class=\"string\">&quot;Result: &quot;</span> &lt;&lt; <span class=\"built_in\">evalRPN</span>(tokens) &lt;&lt; std::endl;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> <span class=\"number\">0</span>;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<ul>\n<li>将逆波兰表达式拆为 token 数组，遍历时用 <code>std::stack&lt;int&gt;</code> 存放操作数。每遇运算符，弹出两个操作数，计算后将结果压回栈。</li>\n</ul>\n<h4 id=\"Python-示例-1\"><a href=\"#Python-示例-1\" class=\"headerlink\" title=\"Python 示例\"></a>Python 示例</h4><figure class=\"highlight python\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">def</span> <span class=\"title function_\">eval_rpn</span>(<span class=\"params\">tokens</span>):</span><br><span class=\"line\">    stack = []</span><br><span class=\"line\">    <span class=\"keyword\">for</span> tk <span class=\"keyword\">in</span> tokens:</span><br><span class=\"line\">        <span class=\"keyword\">if</span> tk <span class=\"keyword\">in</span> &#123;<span class=\"string\">&quot;+&quot;</span>, <span class=\"string\">&quot;-&quot;</span>, <span class=\"string\">&quot;</span></span><br><span class=\"line\"><span class=\"string\">_&quot;</span>, <span class=\"string\">&quot;/&quot;</span>&#125;:</span><br><span class=\"line\">            b = stack.pop()</span><br><span class=\"line\">            a = stack.pop()</span><br><span class=\"line\">            <span class=\"keyword\">if</span> tk == <span class=\"string\">&quot;+&quot;</span>:</span><br><span class=\"line\">                stack.append(a + b)</span><br><span class=\"line\">            <span class=\"keyword\">elif</span> tk == <span class=\"string\">&quot;-&quot;</span>:</span><br><span class=\"line\">                stack.append(a - b)</span><br><span class=\"line\">_*            <span class=\"keyword\">elif</span> tk == <span class=\"string\">&quot;*</span></span><br><span class=\"line\"><span class=\"string\">&quot;</span>:</span><br><span class=\"line\">                stack.append(a * b)</span><br><span class=\"line\">            <span class=\"keyword\">else</span>:</span><br><span class=\"line\">                <span class=\"comment\"># 对于除法，需要注意 Python 的整除与 C++ 不同</span></span><br><span class=\"line\">                stack.append(<span class=\"built_in\">int</span>(a / b))  <span class=\"comment\"># 向零取整</span></span><br><span class=\"line\">        <span class=\"keyword\">else</span>:</span><br><span class=\"line\">            stack.append(<span class=\"built_in\">int</span>(tk))</span><br><span class=\"line\">    <span class=\"keyword\">return</span> stack.pop()</span><br><span class=\"line\"><span class=\"keyword\">if</span> </span><br><span class=\"line\">name</span><br><span class=\"line\"> == <span class=\"string\">&quot;</span></span><br><span class=\"line\"><span class=\"string\">__main__</span></span><br><span class=\"line\"><span class=\"string\">&quot;</span>:</span><br><span class=\"line\">    expr = <span class=\"string\">&quot;3 4 + 2 * 7 /&quot;</span>.split()</span><br><span class=\"line\">    <span class=\"built_in\">print</span>(<span class=\"string\">&quot;Result:&quot;</span>, eval_rpn(expr))  <span class=\"comment\"># 2</span></span><br></pre></td></tr></table></figure>\n\n<ul>\n<li>Python 用列表 <code>stack</code> 模拟栈，操作与 C++ 版本一致。</li>\n</ul>\n<hr>\n<h3 id=\"撤销（Undo）操作\"><a href=\"#撤销（Undo）操作\" class=\"headerlink\" title=\"撤销（Undo）操作\"></a>撤销（Undo）操作</h3><p>许多应用需要实现“撤销”功能，此时可将用户操作或状态快照依次压入栈，用户点击“撤销”时，再次从栈顶弹出即可恢复到上一次状态。</p>\n<h4 id=\"Python-示例：文本编辑器简易撤销栈\"><a href=\"#Python-示例：文本编辑器简易撤销栈\" class=\"headerlink\" title=\"Python 示例：文本编辑器简易撤销栈\"></a>Python 示例：文本编辑器简易撤销栈</h4><figure class=\"highlight python\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">class</span> <span class=\"title class_\">TextEditor</span>:</span><br><span class=\"line\">    <span class=\"keyword\">def</span> </span><br><span class=\"line\"><span class=\"title function_\">__init__</span></span><br><span class=\"line\">(<span class=\"variable language_\">self</span>):</span><br><span class=\"line\">        <span class=\"variable language_\">self</span>.text = <span class=\"string\">&quot;&quot;</span></span><br><span class=\"line\">        <span class=\"variable language_\">self</span>.undo_stack = []  <span class=\"comment\"># 存放历史状态</span></span><br><span class=\"line\">    <span class=\"keyword\">def</span> <span class=\"title function_\">write</span>(<span class=\"params\">self, s</span>):</span><br><span class=\"line\">        <span class=\"comment\"># 在写新内容前，将当前状态压栈</span></span><br><span class=\"line\">        <span class=\"variable language_\">self</span>.undo_stack.append(<span class=\"variable language_\">self</span>.text)</span><br><span class=\"line\">        <span class=\"variable language_\">self</span>.text += s</span><br><span class=\"line\">    <span class=\"keyword\">def</span> <span class=\"title function_\">undo</span>(<span class=\"params\">self</span>):</span><br><span class=\"line\">        <span class=\"keyword\">if</span> <span class=\"variable language_\">self</span>.undo_stack:</span><br><span class=\"line\">            <span class=\"variable language_\">self</span>.text = <span class=\"variable language_\">self</span>.undo_stack.pop()</span><br><span class=\"line\">        <span class=\"keyword\">else</span>:</span><br><span class=\"line\">            <span class=\"built_in\">print</span>(<span class=\"string\">&quot;Nothing to undo&quot;</span>)</span><br><span class=\"line\">    <span class=\"keyword\">def</span> <span class=\"title function_\">show</span>(<span class=\"params\">self</span>):</span><br><span class=\"line\">        <span class=\"built_in\">print</span>(<span class=\"string\">f&quot;Current Text: &#x27;<span class=\"subst\">&#123;self.text&#125;</span>&#x27;&quot;</span>)</span><br><span class=\"line\"><span class=\"keyword\">if</span> </span><br><span class=\"line\">name</span><br><span class=\"line\"> == <span class=\"string\">&quot;</span></span><br><span class=\"line\"><span class=\"string\">__main__</span></span><br><span class=\"line\"><span class=\"string\">&quot;</span>:</span><br><span class=\"line\">    editor = TextEditor()</span><br><span class=\"line\">    editor.write(<span class=\"string\">&quot;Hello&quot;</span>)</span><br><span class=\"line\">    editor.show()        <span class=\"comment\"># Hello</span></span><br><span class=\"line\">    editor.write(<span class=\"string\">&quot;, World!&quot;</span>)</span><br><span class=\"line\">    editor.show()        <span class=\"comment\"># Hello, World!</span></span><br><span class=\"line\">    editor.undo()</span><br><span class=\"line\">    editor.show()        <span class=\"comment\"># Hello</span></span><br><span class=\"line\">    editor.undo()</span><br><span class=\"line\">    editor.show()        <span class=\"comment\"># (空字符串)</span></span><br></pre></td></tr></table></figure>\n\n<ul>\n<li>每次写入之前，将 <code>self.text</code> 的旧值压入 <code>undo_stack</code>。调用 <code>undo()</code> 时，将栈顶字符串弹出并恢复。</li>\n</ul>\n<hr>\n<h3 id=\"浏览器后退功能\"><a href=\"#浏览器后退功能\" class=\"headerlink\" title=\"浏览器后退功能\"></a>浏览器后退功能</h3><p>浏览器维护一个“历史页面访问栈”：</p>\n<ul>\n<li>用户访问新页面时，将当前页面地址压入“后退栈”，同时清空“前进栈”</li>\n<li>点击“后退”时，将当前页面压入“前进栈”，并从“后退栈”弹出最近访问的页面</li>\n<li>点击“前进”时，则反向操作</li>\n</ul>\n<h4 id=\"Python-示例：简易浏览器历史\"><a href=\"#Python-示例：简易浏览器历史\" class=\"headerlink\" title=\"Python 示例：简易浏览器历史\"></a>Python 示例：简易浏览器历史</h4><figure class=\"highlight python\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">class</span> <span class=\"title class_\">BrowserHistory</span>:</span><br><span class=\"line\">    <span class=\"keyword\">def</span> <span class=\"title function_\">__init__</span>(<span class=\"params\">self, homepage: <span class=\"built_in\">str</span></span>):</span><br><span class=\"line\">        <span class=\"variable language_\">self</span>.back_stack = []     <span class=\"comment\"># 后退栈</span></span><br><span class=\"line\">        <span class=\"variable language_\">self</span>.forward_stack = []  <span class=\"comment\"># 前进栈</span></span><br><span class=\"line\">        <span class=\"variable language_\">self</span>.current = homepage  <span class=\"comment\"># 当前页面</span></span><br><span class=\"line\">    <span class=\"keyword\">def</span> <span class=\"title function_\">visit</span>(<span class=\"params\">self, url: <span class=\"built_in\">str</span></span>):</span><br><span class=\"line\">        <span class=\"variable language_\">self</span>.back_stack.append(<span class=\"variable language_\">self</span>.current)</span><br><span class=\"line\">        <span class=\"variable language_\">self</span>.current = url</span><br><span class=\"line\">        <span class=\"variable language_\">self</span>.forward_stack.clear()  <span class=\"comment\"># 新访问清空前进历史</span></span><br><span class=\"line\">    <span class=\"keyword\">def</span> <span class=\"title function_\">back</span>(<span class=\"params\">self</span>):</span><br><span class=\"line\">        <span class=\"keyword\">if</span> <span class=\"variable language_\">self</span>.back_stack:</span><br><span class=\"line\">            <span class=\"variable language_\">self</span>.forward_stack.append(<span class=\"variable language_\">self</span>.current)</span><br><span class=\"line\">            <span class=\"variable language_\">self</span>.current = <span class=\"variable language_\">self</span>.back_stack.pop()</span><br><span class=\"line\">        <span class=\"keyword\">else</span>:</span><br><span class=\"line\">            <span class=\"built_in\">print</span>(<span class=\"string\">&quot;No pages to go back to&quot;</span>)</span><br><span class=\"line\">    <span class=\"keyword\">def</span> <span class=\"title function_\">forward</span>(<span class=\"params\">self</span>):</span><br><span class=\"line\">        <span class=\"keyword\">if</span> <span class=\"variable language_\">self</span>.forward_stack:</span><br><span class=\"line\">            <span class=\"variable language_\">self</span>.back_stack.append(<span class=\"variable language_\">self</span>.current)</span><br><span class=\"line\">            <span class=\"variable language_\">self</span>.current = <span class=\"variable language_\">self</span>.forward_stack.pop()</span><br><span class=\"line\">        <span class=\"keyword\">else</span>:</span><br><span class=\"line\">            <span class=\"built_in\">print</span>(<span class=\"string\">&quot;No pages to go forward to&quot;</span>)</span><br><span class=\"line\">    <span class=\"keyword\">def</span> <span class=\"title function_\">show</span>(<span class=\"params\">self</span>):</span><br><span class=\"line\">        <span class=\"built_in\">print</span>(<span class=\"string\">f&quot;Back: <span class=\"subst\">&#123;self.back_stack&#125;</span>, Current: <span class=\"subst\">&#123;self.current&#125;</span>, Forward: <span class=\"subst\">&#123;self.forward_stack&#125;</span>&quot;</span>)</span><br><span class=\"line\"><span class=\"keyword\">if</span> name == <span class=\"string\">&quot;__main__&quot;</span>:</span><br><span class=\"line\">    browser = BrowserHistory(<span class=\"string\">&quot;homepage.com&quot;</span>)</span><br><span class=\"line\">    browser.show()</span><br><span class=\"line\">    browser.visit(<span class=\"string\">&quot;news.com&quot;</span>)</span><br><span class=\"line\">    browser.show()</span><br><span class=\"line\">    browser.visit(<span class=\"string\">&quot;sports.com&quot;</span>)</span><br><span class=\"line\">    browser.show()</span><br><span class=\"line\">    browser.back()</span><br><span class=\"line\">    browser.show()</span><br><span class=\"line\">    browser.back()</span><br><span class=\"line\">    browser.show()</span><br><span class=\"line\">    browser.forward()</span><br><span class=\"line\">    browser.show()</span><br></pre></td></tr></table></figure>\n\n<ul>\n<li>通过两个栈 (<code>back_stack</code> 和 <code>forward_stack</code>) 维护历史访问记录，实现后退和前进功能。</li>\n</ul>\n<hr>\n<h3 id=\"语法分析与括号匹配\"><a href=\"#语法分析与括号匹配\" class=\"headerlink\" title=\"语法分析与括号匹配\"></a>语法分析与括号匹配</h3><p>在编译器或解释器的语法分析阶段，需要检查表达式或语句是否合法。最常见的是<strong>括号匹配</strong>问题：扫描字符串时，遇到左括号（<code>(</code>、<code>[</code>、<code>&#123;</code>）时压栈，遇到右括号时检查栈顶是否是对应的左括号，若不匹配则报错；最后栈为空则匹配成功。</p>\n<h4 id=\"C-示例：括号匹配\"><a href=\"#C-示例：括号匹配\" class=\"headerlink\" title=\"C++ 示例：括号匹配\"></a>C++ 示例：括号匹配</h4><figure class=\"highlight cpp\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">#<span class=\"keyword\">include</span> <span class=\"string\">&lt;iostream&gt;</span></span></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"keyword\">include</span> <span class=\"string\">&lt;stack&gt;</span></span></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"keyword\">include</span> <span class=\"string\">&lt;string&gt;</span></span></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"keyword\">include</span> <span class=\"string\">&lt;unordered_map&gt;</span></span></span><br><span class=\"line\"><span class=\"function\"><span class=\"type\">bool</span> <span class=\"title\">isValid</span><span class=\"params\">(<span class=\"type\">const</span> std::string &amp;s)</span> </span>&#123;</span><br><span class=\"line\">    std::stack&lt;<span class=\"type\">char</span>&gt; st;</span><br><span class=\"line\">    std::unordered_map&lt;<span class=\"type\">char</span>, <span class=\"type\">char</span>&gt; pairs = &#123;</span><br><span class=\"line\">        &#123;<span class=\"string\">&#x27;)&#x27;</span>, <span class=\"string\">&#x27;(&#x27;</span>&#125;, &#123;<span class=\"string\">&#x27;]&#x27;</span>, <span class=\"string\">&#x27;[&#x27;</span>&#125;, &#123;<span class=\"string\">&#x27;&#125;&#x27;</span>, <span class=\"string\">&#x27;&#123;&#x27;</span>&#125;</span><br><span class=\"line\">    &#125;;</span><br><span class=\"line\">    <span class=\"keyword\">for</span> (<span class=\"type\">char</span> c : s) &#123;</span><br><span class=\"line\">        <span class=\"keyword\">if</span> (c == <span class=\"string\">&#x27;(&#x27;</span> || c == <span class=\"string\">&#x27;[&#x27;</span> || c == <span class=\"string\">&#x27;&#123;&#x27;</span>) &#123;</span><br><span class=\"line\">            st.<span class=\"built_in\">push</span>(c);</span><br><span class=\"line\">        &#125; <span class=\"keyword\">else</span> <span class=\"keyword\">if</span> (c == <span class=\"string\">&#x27;)&#x27;</span> || c == <span class=\"string\">&#x27;]&#x27;</span> || c == <span class=\"string\">&#x27;&#125;&#x27;</span>) &#123;</span><br><span class=\"line\">            <span class=\"keyword\">if</span> (st.<span class=\"built_in\">empty</span>() || st.<span class=\"built_in\">top</span>() != pairs[c]) &#123;</span><br><span class=\"line\">                <span class=\"keyword\">return</span> <span class=\"literal\">false</span>;</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">            st.<span class=\"built_in\">pop</span>();</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        <span class=\"comment\">// 忽略其他字符</span></span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> st.<span class=\"built_in\">empty</span>();</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"function\"><span class=\"type\">int</span> <span class=\"title\">main</span><span class=\"params\">()</span> </span>&#123;</span><br><span class=\"line\">    std::string s1 = <span class=\"string\">&quot;([&#123;&#125;])&quot;</span>;</span><br><span class=\"line\">    std::string s2 = <span class=\"string\">&quot;([&#125;&#123;])&quot;</span>;</span><br><span class=\"line\">    std::cout &lt;&lt; s1 &lt;&lt; <span class=\"string\">&quot; is &quot;</span> &lt;&lt; (<span class=\"built_in\">isValid</span>(s1) ? <span class=\"string\">&quot;valid\\n&quot;</span> : <span class=\"string\">&quot;invalid\\n&quot;</span>);</span><br><span class=\"line\">    std::cout &lt;&lt; s2 &lt;&lt; <span class=\"string\">&quot; is &quot;</span> &lt;&lt; (<span class=\"built_in\">isValid</span>(s2) ? <span class=\"string\">&quot;valid\\n&quot;</span> : <span class=\"string\">&quot;invalid\\n&quot;</span>);</span><br><span class=\"line\">    <span class=\"keyword\">return</span> <span class=\"number\">0</span>;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<ul>\n<li>使用 <code>std::stack&lt;char&gt;</code> 存储左括号，遇到右括号时检查对应关系。</li>\n</ul>\n<h4 id=\"Python-示例-2\"><a href=\"#Python-示例-2\" class=\"headerlink\" title=\"Python 示例\"></a>Python 示例</h4><figure class=\"highlight python\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">def</span> <span class=\"title function_\">is_valid</span>(<span class=\"params\">s: <span class=\"built_in\">str</span></span>) -&gt; <span class=\"built_in\">bool</span>:</span><br><span class=\"line\">    stack = []</span><br><span class=\"line\">    pairs = &#123;<span class=\"string\">&#x27;)&#x27;</span>: <span class=\"string\">&#x27;(&#x27;</span>, <span class=\"string\">&#x27;]&#x27;</span>: <span class=\"string\">&#x27;[&#x27;</span>, <span class=\"string\">&#x27;&#125;&#x27;</span>: <span class=\"string\">&#x27;&#123;&#x27;</span>&#125;</span><br><span class=\"line\">    <span class=\"keyword\">for</span> c <span class=\"keyword\">in</span> s:</span><br><span class=\"line\">        <span class=\"keyword\">if</span> c <span class=\"keyword\">in</span> <span class=\"string\">&#x27;([&#123;&#x27;</span>:</span><br><span class=\"line\">            stack.append(c)</span><br><span class=\"line\">        <span class=\"keyword\">elif</span> c <span class=\"keyword\">in</span> <span class=\"string\">&#x27;)]&#125;&#x27;</span>:</span><br><span class=\"line\">            <span class=\"keyword\">if</span> <span class=\"keyword\">not</span> stack <span class=\"keyword\">or</span> stack[-<span class=\"number\">1</span>] != pairs[c]:</span><br><span class=\"line\">                <span class=\"keyword\">return</span> <span class=\"literal\">False</span></span><br><span class=\"line\">            stack.pop()</span><br><span class=\"line\">        <span class=\"comment\"># 忽略其他字符</span></span><br><span class=\"line\">    <span class=\"keyword\">return</span> <span class=\"keyword\">not</span> stack</span><br><span class=\"line\"><span class=\"keyword\">if</span> name == <span class=\"string\">&quot;__main__&quot;</span>:</span><br><span class=\"line\">    <span class=\"built_in\">print</span>(is_valid(<span class=\"string\">&quot;([&#123;&#125;])&quot;</span>))  <span class=\"comment\"># True</span></span><br><span class=\"line\">    <span class=\"built_in\">print</span>(is_valid(<span class=\"string\">&quot;([&#125;&#123;])&quot;</span>))  <span class=\"comment\"># False</span></span><br></pre></td></tr></table></figure>\n\n<ul>\n<li>逻辑同上，用列表模拟栈。</li>\n</ul>\n<hr>\n<h3 id=\"进程-线程调度与上下文切换\"><a href=\"#进程-线程调度与上下文切换\" class=\"headerlink\" title=\"进程&#x2F;线程调度与上下文切换\"></a>进程&#x2F;线程调度与上下文切换</h3><p>操作系统在进行<strong>线程切换</strong>或<strong>进程切换</strong>时，需要保存当前执行状态（寄存器上下文、程序计数器等）到线程&#x2F;进程的<strong>栈帧</strong>中，待下次重新调度时再从栈中恢复。</p>\n<ul>\n<li>线程栈：每个线程分配固定大小的栈空间，保存其调用链和临时变量。上下文切换时，CPU 会自动“压栈”通用寄存器和程序计数器，然后加载下一个线程的寄存器和 PC 值；切回原线程时，再次“弹栈”恢复上下文。</li>\n</ul>\n<h4 id=\"C-伪示例（伪代码，仅用于说明概念）\"><a href=\"#C-伪示例（伪代码，仅用于说明概念）\" class=\"headerlink\" title=\"C++ 伪示例（伪代码，仅用于说明概念）\"></a>C++ 伪示例（伪代码，仅用于说明概念）</h4><figure class=\"highlight cpp\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">struct</span> <span class=\"title class_\">CPUContext</span> &#123;</span><br><span class=\"line\">    <span class=\"type\">uint64_t</span> rip;     <span class=\"comment\">// 指令指针（程序计数器）</span></span><br><span class=\"line\">    <span class=\"type\">uint64_t</span> rsp;     <span class=\"comment\">// 栈指针</span></span><br><span class=\"line\">    <span class=\"type\">uint64_t</span> regs[<span class=\"number\">16</span>];<span class=\"comment\">// 其他通用寄存器</span></span><br><span class=\"line\">    <span class=\"comment\">// ...</span></span><br><span class=\"line\">&#125;;</span><br><span class=\"line\"><span class=\"function\"><span class=\"type\">void</span> <span class=\"title\">context_switch</span><span class=\"params\">(CPUContext *cur, CPUContext </span></span></span><br><span class=\"line\"><span class=\"params\"><span class=\"function\">_next)</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"comment\">// 保存当前上下文到 cur</span></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">asm</span> <span class=\"title\">volatile</span> <span class=\"params\">(</span></span></span><br><span class=\"line\"><span class=\"params\"><span class=\"function\">        <span class=\"string\">&quot;mov %%rsp, %0\\n\\t&quot;</span></span></span></span><br><span class=\"line\"><span class=\"params\"><span class=\"function\">        <span class=\"string\">&quot;mov %%rax, %1\\n\\t&quot;</span></span></span></span><br><span class=\"line\"><span class=\"params\"><span class=\"function\">        <span class=\"comment\">// … 其他寄存器</span></span></span></span><br><span class=\"line\"><span class=\"params\"><span class=\"function\">_*        : <span class=\"string\">&quot;=m&quot;</span>(cur-&gt;rsp), <span class=\"string\">&quot;=m&quot;</span>(cur-&gt;regs[<span class=\"number\">0</span>]) <span class=\"comment\">/*</span></span></span></span><br><span class=\"line\"><span class=\"comment\"><span class=\"params\"><span class=\"function\"> … </span></span></span></span><br><span class=\"line\"><span class=\"comment\"><span class=\"params\"><span class=\"function\">_/</span></span></span></span><br><span class=\"line\"><span class=\"comment\"><span class=\"params\"><span class=\"function\">        :</span></span></span></span><br><span class=\"line\"><span class=\"comment\"><span class=\"params\"><span class=\"function\">        :</span></span></span></span><br><span class=\"line\"><span class=\"comment\"><span class=\"params\"><span class=\"function\">    );</span></span></span></span><br><span class=\"line\"><span class=\"comment\"><span class=\"params\"><span class=\"function\">    // 加载下一个上下文</span></span></span></span><br><span class=\"line\"><span class=\"comment\"><span class=\"params\"><span class=\"function\">    asm volatile (</span></span></span></span><br><span class=\"line\"><span class=\"comment\"><span class=\"params\"><span class=\"function\">        &quot;mov %0, %%rsp\\n\\t&quot;</span></span></span></span><br><span class=\"line\"><span class=\"comment\"><span class=\"params\"><span class=\"function\">        &quot;mov %1, %%rax\\n\\t&quot;</span></span></span></span><br><span class=\"line\"><span class=\"comment\"><span class=\"params\"><span class=\"function\">        // … 其他寄存器</span></span></span></span><br><span class=\"line\"><span class=\"comment\"><span class=\"params\"><span class=\"function\">        :</span></span></span></span><br><span class=\"line\"><span class=\"comment\"><span class=\"params\"><span class=\"function\">_*        : &quot;m&quot;(next-&gt;rsp), &quot;m&quot;(next-&gt;regs[0]) /*</span></span></span></span><br><span class=\"line\"><span class=\"comment\"><span class=\"params\"><span class=\"function\"> … */</span></span></span></span><br><span class=\"line\"><span class=\"params\"><span class=\"function\">    )</span></span>;</span><br><span class=\"line\">    <span class=\"comment\">// 跳转到下一个线程的指令地址</span></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">asm</span> <span class=\"title\">volatile</span> <span class=\"params\">(<span class=\"string\">&quot;jmp *%0&quot;</span> :: <span class=\"string\">&quot;m&quot;</span>(next-&gt;rip))</span></span>;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<ul>\n<li>该示例仅示意 OS 如何将寄存器状态压栈&#x2F;存储到 <code>CPUContext</code> 结构，模拟上下文切换。真实内核会更复杂，并在内核栈上完成这些操作。</li>\n</ul>\n<hr>\n<h3 id=\"实时系统任务调度与中断处理\"><a href=\"#实时系统任务调度与中断处理\" class=\"headerlink\" title=\"实时系统任务调度与中断处理\"></a>实时系统任务调度与中断处理</h3><p>在实时系统（RTOS）中，每个任务通常分配一个固定大小的栈，用于保存用户态执行时的局部变量和调用帧。</p>\n<ul>\n<li><strong>任务调度</strong>：RTOS 按优先级或时间片轮转调度任务，切换时需保存&#x2F;恢复任务上下文（寄存器、程序计数器等）到各自任务的栈帧。</li>\n<li><strong>中断处理</strong>：发生中断时，CPU 自动将部分寄存器（如程序计数器、标志寄存器）压入当前栈中，跳转到中断处理程序，并使用中断程序自身的栈（通常也是内核栈）执行，处理完毕后从栈中弹出恢复现场。</li>\n</ul>\n<h4 id=\"C-示例（伪代码，基于-ARM-Cortex-M-中断栈）\"><a href=\"#C-示例（伪代码，基于-ARM-Cortex-M-中断栈）\" class=\"headerlink\" title=\"C 示例（伪代码，基于 ARM Cortex-M 中断栈）\"></a>C 示例（伪代码，基于 ARM Cortex-M 中断栈）</h4><figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// 假设 Cortex-M 架构，中断发生时硬件会自动压入 R0-R3、R12、LR、PC、xPSR</span></span><br><span class=\"line\"><span class=\"type\">void</span> <span class=\"title function_\">SysTick_Handler</span><span class=\"params\">(<span class=\"type\">void</span>)</span> &#123;</span><br><span class=\"line\">    <span class=\"comment\">// 此时硬件已将通用寄存器和 xPSR 压入当前任务的栈中，使用 PSP/MSP 寄存器区分</span></span><br><span class=\"line\">    <span class=\"comment\">// 处理中断逻辑</span></span><br><span class=\"line\">    <span class=\"comment\">// ...</span></span><br><span class=\"line\">    <span class=\"comment\">// 退出中断时，硬件自动从栈中弹回寄存器并恢复现场</span></span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"comment\">// 任务创建时，手动构造该任务的初始栈帧</span></span><br><span class=\"line\"><span class=\"type\">uint32_t</span> *<span class=\"title function_\">create_task_stack</span><span class=\"params\">(<span class=\"type\">void</span> (*task_func)(<span class=\"type\">void</span>), <span class=\"type\">uint32_t</span> *stack_top)</span> &#123;</span><br><span class=\"line\">    <span class=\"comment\">// 栈顶需预留硬件自动压栈的空间（8 寄存器）</span></span><br><span class=\"line\">    *(--stack_top) = INITIAL_xPSR;  <span class=\"comment\">// xPSR</span></span><br><span class=\"line\">    *(--stack_top) = (<span class=\"type\">uint32_t</span>)task_func; <span class=\"comment\">// PC</span></span><br><span class=\"line\">    *(--stack_top) = <span class=\"number\">0xFFFFFFFD</span>;    <span class=\"comment\">// LR (使用 PSP 指向任务栈)</span></span><br><span class=\"line\">    <span class=\"comment\">// R12, R3, R2, R1, R0</span></span><br><span class=\"line\">    <span class=\"keyword\">for</span> (<span class=\"type\">int</span> i = <span class=\"number\">0</span>; i &lt; <span class=\"number\">5</span>; i++) &#123;</span><br><span class=\"line\">        *(--stack_top) = <span class=\"number\">0</span>;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"comment\">// 接下来是软件自动压入的寄存器（R4–R11）</span></span><br><span class=\"line\">    <span class=\"keyword\">for</span> (<span class=\"type\">int</span> i = <span class=\"number\">0</span>; i &lt; <span class=\"number\">8</span>; i++) &#123;</span><br><span class=\"line\">        *(--stack_top) = <span class=\"number\">0</span>;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> stack_top; <span class=\"comment\">// 返回任务上下文初始化后的栈顶指针</span></span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<ul>\n<li>在 ARM Cortex-M 系列中，中断或异常发生时，硬件会自动将 R0–R3、R12、LR、PC、xPSR 压栈；退出时硬件弹栈恢复。这段伪代码展示了如何手动为一个新任务构造“假”的中断栈帧，使其从任务函数 <code>task_func</code> 开始执行。</li>\n</ul>\n<hr>\n<h2 id=\"堆与栈在内存中的分布及冲突\"><a href=\"#堆与栈在内存中的分布及冲突\" class=\"headerlink\" title=\"堆与栈在内存中的分布及冲突\"></a>堆与栈在内存中的分布及冲突</h2><h3 id=\"内存布局示意\"><a href=\"#内存布局示意\" class=\"headerlink\" title=\"内存布局示意\"></a>内存布局示意</h3><p>C 语言的内存模型分为 5 个区：栈区、堆区、静态区、常量区、代码区。每个区存储的内容如下：</p>\n<ol>\n<li>栈区：存放函数的参数值、局部变量等，由编译器自动分配和释放，通常在函数执行完后就释放了，其操作方式类似于数据结构中的栈。栈内存分配运算内置于 CPU 的指令集，效率很高，但是分配的内存量有限，比如 iOS 中栈区的大小是 2M。</li>\n<li>堆区：就是通过 new、malloc、realloc 分配的内存块，编译器不会负责它们的释放工作，需要用程序区释放。分配方式类似于数据结构中的链表。“内存泄漏”通常说的就是堆区。</li>\n<li>静态区：全局变量和静态变量的存储是放在一块的，初始化的全局变量和静态变量在一块区域，未初始化的全局变量和未初始化的静态变量在相邻的另一块区域。程序结束后，由系统释放。</li>\n<li>常量区：常量存储在这里，不允许修改。</li>\n<li>代码区：顾名思义，存放代码。</li>\n</ol>\n<p><img src=\"https://gitee.com/tanke11223344/imagehost/raw/main/blog/1749360547853MFckbxyUqonaQtxbuPsc8E3unsc.png\" alt=\"1749360547853MFckbxyUqonaQtxbuPsc8E3unsc.png\"><br><img src=\"https://gitee.com/tanke11223344/imagehost/raw/main/blog/1749360556085D4ivbYK77oSejXxL204cgPNvneb.png\" alt=\"1749360556085D4ivbYK77oSejXxL204cgPNvneb.png\"></p>\n<ul>\n<li><strong>堆区</strong>（Heap）从低地址向高地址方向增长。当程序调用 <code>new</code>&#x2F;<code>malloc</code> 分配内存时，分配器会在堆中寻找足够大的空闲块。</li>\n<li><strong>栈区</strong>（Stack）从高地址向低地址方向增长。当函数调用时，系统在栈顶“向下”分配栈帧；函数返回时，“向上”回收。</li>\n<li>两者通常由中间的空闲区隔开，若向对方增长的空间过大，可能出现<strong>堆与栈冲突</strong>（Stack–Heap Collision）。</li>\n</ul>\n<h3 id=\"栈堆冲突（Stack–Heap-Collision）\"><a href=\"#栈堆冲突（Stack–Heap-Collision）\" class=\"headerlink\" title=\"栈堆冲突（Stack–Heap Collision）\"></a>栈堆冲突（Stack–Heap Collision）</h3><p>当程序对堆申请大量连续内存（如 <code>new</code>&#x2F;<code>malloc</code>）而栈调用层次过深（或线程栈空间不足）时：</p>\n<ul>\n<li><strong>堆过度增长</strong>：不断调用动态分配函数，导致堆区不断向高地址扩展</li>\n<li><strong>栈过度生长</strong>：深度递归或大量局部变量导致栈区向低地址扩展<br>若二者相向增长，最终会相互覆盖（即“冲突”），造成已分配的堆内存或栈空间被意外覆盖，导致程序崩溃或不可预知的错误。</li>\n</ul>\n<h4 id=\"示意场景\"><a href=\"#示意场景\" class=\"headerlink\" title=\"示意场景\"></a>示意场景</h4><figure class=\"highlight cpp\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">#<span class=\"keyword\">include</span> <span class=\"string\">&lt;iostream&gt;</span></span></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"keyword\">include</span> <span class=\"string\">&lt;vector&gt;</span></span></span><br><span class=\"line\"><span class=\"function\"><span class=\"type\">void</span> <span class=\"title\">recurse</span><span class=\"params\">(<span class=\"type\">int</span> depth)</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"comment\">// 每次调用消耗一定的栈空间</span></span><br><span class=\"line\">    <span class=\"type\">char</span> buffer[<span class=\"number\">1024</span>];  <span class=\"comment\">// 1KB 的局部数组</span></span><br><span class=\"line\">    <span class=\"keyword\">if</span> (depth &gt; <span class=\"number\">0</span>) &#123;</span><br><span class=\"line\">        <span class=\"built_in\">recurse</span>(depth - <span class=\"number\">1</span>);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"function\"><span class=\"type\">int</span> <span class=\"title\">main</span><span class=\"params\">()</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"comment\">// 不断分配堆内存</span></span><br><span class=\"line\">    std::vector&lt;<span class=\"type\">int</span>*&gt; allocations;</span><br><span class=\"line\">    <span class=\"keyword\">try</span> &#123;</span><br><span class=\"line\">        <span class=\"keyword\">while</span> (<span class=\"literal\">true</span>) &#123;</span><br><span class=\"line\">            allocations.<span class=\"built_in\">push_back</span>(<span class=\"keyword\">new</span> <span class=\"type\">int</span>[<span class=\"number\">10000</span>]); <span class=\"comment\">// 每次分配 ~40KB</span></span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125; <span class=\"built_in\">catch</span> (std::bad_alloc &amp;e) &#123;</span><br><span class=\"line\">        std::cerr &lt;&lt; <span class=\"string\">&quot;Heap exhausted: &quot;</span> &lt;&lt; e.<span class=\"built_in\">what</span>() &lt;&lt; std::endl;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"comment\">// 同时进行深度递归</span></span><br><span class=\"line\">    <span class=\"built_in\">recurse</span>(<span class=\"number\">100000</span>); <span class=\"comment\">// 这会导致栈溢出</span></span><br><span class=\"line\">    <span class=\"keyword\">return</span> <span class=\"number\">0</span>;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<ul>\n<li>在上述伪示例中，如果同时执行大量 <code>new int[10000]</code>（堆分配）与深度递归 <code>recurse(100000)</code>（栈分配），就可能发生堆与栈冲突。实际运行时，程序要么先出现堆分配失败（抛出 <code>bad_alloc</code>），要么先出现栈溢出 (Stack Overflow)。</li>\n</ul>\n<h4 id=\"如何避免\"><a href=\"#如何避免\" class=\"headerlink\" title=\"如何避免\"></a>如何避免</h4><ol>\n<li><strong>控制递归深度</strong>，或使用迭代替代深度递归，从而减少栈空间消耗。</li>\n<li><strong>限制堆分配总量</strong>，在堆分配时及时释放不再使用的内存，避免过度占用。</li>\n<li><strong>增加可用内存</strong>：在嵌入式或受限环境下，根据需求调整栈大小（编译器或链接器选项）和堆区大小。</li>\n<li><strong>监控与检测工具</strong>：使用工具（如 Valgrind、AddressSanitizer）检测内存越界和栈溢出问题。</li>\n</ol>\n<hr>\n<h2 id=\"堆与栈在不同应用场景中的现实案例\"><a href=\"#堆与栈在不同应用场景中的现实案例\" class=\"headerlink\" title=\"堆与栈在不同应用场景中的现实案例\"></a>堆与栈在不同应用场景中的现实案例</h2><h3 id=\"嵌入式开发\"><a href=\"#嵌入式开发\" class=\"headerlink\" title=\"嵌入式开发\"></a>嵌入式开发</h3><ul>\n<li><strong>堆与栈在 RTOS 中的角色</strong><ul>\n<li><strong>栈</strong>：每个任务分配固定大小的任务栈，用于存储任务函数的调用帧和局部变量。RTOS 切换任务时，会保存&#x2F;恢复任务的寄存器上下文到各自的任务栈中。</li>\n<li><strong>堆</strong>：嵌入式往往内存紧张，避免动态分配；如果使用堆则要小心碎片化。许多 RTOS（如 FreeRTOS）提供“内存池”或“堆区域”管理接口，开发者可根据需求预先分配一段大内存作为堆，通过 <code>pvPortMalloc</code>&#x2F;<code>vPortFree</code> 操作。</li>\n</ul>\n</li>\n</ul>\n<figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// FreeRTOS 示例：创建一个任务，并为其指定栈大小</span></span><br><span class=\"line\"><span class=\"type\">void</span> <span class=\"title function_\">vTaskFunction</span><span class=\"params\">(<span class=\"type\">void</span> *pvParameters)</span> &#123;</span><br><span class=\"line\">    <span class=\"type\">int</span> local_var = <span class=\"number\">42</span>;  <span class=\"comment\">// 存储在任务栈中</span></span><br><span class=\"line\">    <span class=\"keyword\">for</span> (;;) &#123;</span><br><span class=\"line\">        <span class=\"comment\">// Task logic...</span></span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"type\">int</span> <span class=\"title function_\">main</span><span class=\"params\">(<span class=\"type\">void</span>)</span> &#123;</span><br><span class=\"line\">    <span class=\"comment\">// 在创建任务时，指定 256 字 作为任务栈大小</span></span><br><span class=\"line\">    xTaskCreate(vTaskFunction, <span class=\"string\">&quot;Task1&quot;</span>, <span class=\"number\">256</span>, <span class=\"literal\">NULL</span>, <span class=\"number\">1</span>, <span class=\"literal\">NULL</span>);</span><br><span class=\"line\">    vTaskStartScheduler(); <span class=\"comment\">// 启动调度器，开始抢占式多任务</span></span><br><span class=\"line\">    <span class=\"keyword\">return</span> <span class=\"number\">0</span>;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<ul>\n<li><strong>场景说明</strong>：在嵌入式系统中，为了保证实时性和预测性，往往禁止或限制堆分配，更多地使用<strong>静态分配</strong>或<strong>内存池</strong>，仅在启动阶段少量使用堆。</li>\n</ul>\n<hr>\n<h3 id=\"Web-后端\"><a href=\"#Web-后端\" class=\"headerlink\" title=\"Web 后端\"></a>Web 后端</h3><ul>\n<li><p><strong>函数调用与请求栈</strong></p>\n<ul>\n<li>在 Web 服务中，每个 HTTP 请求都可能触发一条线程（或使用协程&#x2F;异步框架），该请求对应的调用堆栈存放在栈内存中。若请求处理链条过深（大量中间件或控制器嵌套），有可能导致栈溢出。</li>\n</ul>\n</li>\n<li><p><strong>缓存管理</strong></p>\n<ul>\n<li><strong>堆</strong>：Java 或 C++ 编写的后端应用中的缓存（如 LRU Cache）通常使用堆结构来维护元素优先级或过期时间。例如，使用 <code>std::priority_queue</code> 或 Python 的 <code>heapq</code> 实现定时淘汰策略。</li>\n</ul>\n</li>\n</ul>\n<h4 id=\"C-示例：基于堆的简单-LRU-缓存（按过期时间）\"><a href=\"#C-示例：基于堆的简单-LRU-缓存（按过期时间）\" class=\"headerlink\" title=\"C++ 示例：基于堆的简单 LRU 缓存（按过期时间）\"></a>C++ 示例：基于堆的简单 LRU 缓存（按过期时间）</h4><figure class=\"highlight cpp\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br><span class=\"line\">47</span><br><span class=\"line\">48</span><br><span class=\"line\">49</span><br><span class=\"line\">50</span><br><span class=\"line\">51</span><br><span class=\"line\">52</span><br><span class=\"line\">53</span><br><span class=\"line\">54</span><br><span class=\"line\">55</span><br><span class=\"line\">56</span><br><span class=\"line\">57</span><br><span class=\"line\">58</span><br><span class=\"line\">59</span><br><span class=\"line\">60</span><br><span class=\"line\">61</span><br><span class=\"line\">62</span><br><span class=\"line\">63</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">#<span class=\"keyword\">include</span> <span class=\"string\">&lt;iostream&gt;</span></span></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"keyword\">include</span> <span class=\"string\">&lt;queue&gt;</span></span></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"keyword\">include</span> <span class=\"string\">&lt;unordered_map&gt;</span></span></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"keyword\">include</span> <span class=\"string\">&lt;chrono&gt;</span></span></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"keyword\">include</span> <span class=\"string\">&lt;thread&gt;</span></span></span><br><span class=\"line\"><span class=\"keyword\">struct</span> <span class=\"title class_\">CacheItem</span> &#123;</span><br><span class=\"line\">    <span class=\"type\">int</span> key;</span><br><span class=\"line\">    std::string value;</span><br><span class=\"line\">    std::chrono::steady_clock::time_point expire_time;</span><br><span class=\"line\">&#125;;</span><br><span class=\"line\"><span class=\"keyword\">struct</span> <span class=\"title class_\">CompareExpire</span> &#123;</span><br><span class=\"line\">    <span class=\"function\"><span class=\"type\">bool</span> <span class=\"title\">operator</span><span class=\"params\">()</span><span class=\"params\">(<span class=\"type\">const</span> CacheItem &amp;a, <span class=\"type\">const</span> CacheItem &amp;b)</span> </span>&#123;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> a.expire_time &gt; b.expire_time; <span class=\"comment\">// 过期时间早的优先级高</span></span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;;</span><br><span class=\"line\"><span class=\"keyword\">class</span> <span class=\"title class_\">LRUCache</span> &#123;</span><br><span class=\"line\"><span class=\"keyword\">public</span>:</span><br><span class=\"line\">    <span class=\"built_in\">LRUCache</span>(<span class=\"type\">size_t</span> capacity): <span class=\"built_in\">capacity_</span>(capacity) &#123;&#125;</span><br><span class=\"line\">    <span class=\"function\"><span class=\"type\">void</span> <span class=\"title\">put</span><span class=\"params\">(<span class=\"type\">int</span> key, <span class=\"type\">const</span> std::string &amp;value, <span class=\"type\">int</span> ttl_seconds)</span> </span>&#123;</span><br><span class=\"line\">        <span class=\"keyword\">auto</span> now = std::chrono::steady_clock::<span class=\"built_in\">now</span>();</span><br><span class=\"line\">        CacheItem item&#123;key, value, now + std::chrono::<span class=\"built_in\">seconds</span>(ttl_seconds)&#125;;</span><br><span class=\"line\">        <span class=\"keyword\">if</span> (cache_map_.<span class=\"built_in\">size</span>() &gt;= capacity_) &#123;</span><br><span class=\"line\">            <span class=\"comment\">// 移除过期或最久未使用元素</span></span><br><span class=\"line\">            <span class=\"built_in\">evict</span>();</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        cache_map_[key] = item;</span><br><span class=\"line\">        min_heap_.<span class=\"built_in\">push</span>(item);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"function\">std::string <span class=\"title\">get</span><span class=\"params\">(<span class=\"type\">int</span> key)</span> </span>&#123;</span><br><span class=\"line\">        <span class=\"keyword\">auto</span> it = cache_map_.<span class=\"built_in\">find</span>(key);</span><br><span class=\"line\">        <span class=\"keyword\">if</span> (it == cache_map_.<span class=\"built_in\">end</span>()) <span class=\"keyword\">return</span> <span class=\"string\">&quot;&quot;</span>; <span class=\"comment\">// 未命中</span></span><br><span class=\"line\">        <span class=\"comment\">// 更新过期时间或移动到最新位置可自行实现</span></span><br><span class=\"line\">        <span class=\"keyword\">return</span> it-&gt;second.value;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"><span class=\"keyword\">private</span>:</span><br><span class=\"line\">    <span class=\"function\"><span class=\"type\">void</span> <span class=\"title\">evict</span><span class=\"params\">()</span> </span>&#123;</span><br><span class=\"line\">        <span class=\"keyword\">auto</span> now = std::chrono::steady_clock::<span class=\"built_in\">now</span>();</span><br><span class=\"line\">        <span class=\"keyword\">while</span> (!min_heap_.<span class=\"built_in\">empty</span>()) &#123;</span><br><span class=\"line\">            <span class=\"keyword\">auto</span> &amp;top = min_heap_.<span class=\"built_in\">top</span>();</span><br><span class=\"line\">            <span class=\"keyword\">if</span> (top.expire_time &lt;= now) &#123;</span><br><span class=\"line\">                <span class=\"comment\">// 已过期，删除</span></span><br><span class=\"line\">                cache_map_.<span class=\"built_in\">erase</span>(top.key);</span><br><span class=\"line\">                min_heap_.<span class=\"built_in\">pop</span>();</span><br><span class=\"line\">            &#125; <span class=\"keyword\">else</span> &#123;</span><br><span class=\"line\">                <span class=\"comment\">// 如果堆顶未过期，但 cache_map_ 超过容量，可自行实现额外的 LRU 逻辑</span></span><br><span class=\"line\">                <span class=\"keyword\">break</span>;</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        <span class=\"comment\">// 这里简化：如果仍然超出容量，可额外删除最老元素</span></span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"type\">size_t</span> capacity_;</span><br><span class=\"line\">    std::unordered_map&lt;<span class=\"type\">int</span>, CacheItem&gt; cache_map_;</span><br><span class=\"line\">    std::priority_queue&lt;CacheItem, std::vector&lt;CacheItem&gt;, CompareExpire&gt; min_heap_;</span><br><span class=\"line\">&#125;;</span><br><span class=\"line\"><span class=\"function\"><span class=\"type\">int</span> <span class=\"title\">main</span><span class=\"params\">()</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"function\">LRUCache <span class=\"title\">cache</span><span class=\"params\">(<span class=\"number\">3</span>)</span></span>;</span><br><span class=\"line\">    cache.<span class=\"built_in\">put</span>(<span class=\"number\">1</span>, <span class=\"string\">&quot;A&quot;</span>, <span class=\"number\">2</span>);</span><br><span class=\"line\">    cache.<span class=\"built_in\">put</span>(<span class=\"number\">2</span>, <span class=\"string\">&quot;B&quot;</span>, <span class=\"number\">5</span>);</span><br><span class=\"line\">    cache.<span class=\"built_in\">put</span>(<span class=\"number\">3</span>, <span class=\"string\">&quot;C&quot;</span>, <span class=\"number\">10</span>);</span><br><span class=\"line\">    std::this_thread::<span class=\"built_in\">sleep_for</span>(std::chrono::<span class=\"built_in\">seconds</span>(<span class=\"number\">3</span>));</span><br><span class=\"line\">    std::cout &lt;&lt; <span class=\"string\">&quot;Get key 1: &quot;</span> &lt;&lt; cache.<span class=\"built_in\">get</span>(<span class=\"number\">1</span>) &lt;&lt; std::endl; <span class=\"comment\">// 可能已过期，返回 &quot;&quot;</span></span><br><span class=\"line\">    <span class=\"keyword\">return</span> <span class=\"number\">0</span>;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<ul>\n<li>使用 <code>std::priority_queue</code>（最小堆）按过期时间排序，当容量满时弹出最早过期项或其他淘汰策略。</li>\n</ul>\n<hr>\n<h3 id=\"游戏开发\"><a href=\"#游戏开发\" class=\"headerlink\" title=\"游戏开发\"></a>游戏开发</h3><blockquote>\n<ul>\n<li><a href=\"https://www.cnblogs.com/KillerAery/p/10765893.html\">游戏架构设计:内存管理 - KillerAery - 博客园</a></li>\n<li><a href=\"https://www.cnblogs.com/zhyan8/p/17238161.html\">【Unity3D】Unity3D 技术栈 - little_fat_sheep - 博客园</a></li>\n</ul>\n</blockquote>\n<ul>\n<li><strong>内存池（Memory Pool）</strong><ul>\n<li>游戏中对象（如子弹、特效、NPC）创建频繁，反复调用 <code>new/delete</code> 会导致堆碎片和性能损耗。常用的做法是在启动时预先向堆申请一大块连续内存，将其切分为固定大小的“内存池块”，通过栈或链表管理空闲块。分配时从池中取出一个空闲块，释放时将其归还池中，而无需操作系统的堆管理。</li>\n</ul>\n</li>\n</ul>\n<h4 id=\"C-示例：简单对象池（以-GameObject-为例）\"><a href=\"#C-示例：简单对象池（以-GameObject-为例）\" class=\"headerlink\" title=\"C++ 示例：简单对象池（以 GameObject 为例）\"></a>C++ 示例：简单对象池（以 <code>GameObject</code> 为例）</h4><figure class=\"highlight cpp\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br><span class=\"line\">47</span><br><span class=\"line\">48</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">#<span class=\"keyword\">include</span> <span class=\"string\">&lt;iostream&gt;</span></span></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"keyword\">include</span> <span class=\"string\">&lt;vector&gt;</span></span></span><br><span class=\"line\"><span class=\"comment\">// 假设游戏对象</span></span><br><span class=\"line\"><span class=\"keyword\">class</span> <span class=\"title class_\">GameObject</span> &#123;</span><br><span class=\"line\"><span class=\"keyword\">public</span>:</span><br><span class=\"line\">    <span class=\"built_in\">GameObject</span>() : <span class=\"built_in\">x</span>(<span class=\"number\">0</span>), <span class=\"built_in\">y</span>(<span class=\"number\">0</span>) &#123;&#125;</span><br><span class=\"line\">    <span class=\"function\"><span class=\"type\">void</span> <span class=\"title\">reset</span><span class=\"params\">()</span> </span>&#123; x = y = <span class=\"number\">0</span>; &#125;</span><br><span class=\"line\">    <span class=\"function\"><span class=\"type\">void</span> <span class=\"title\">set_position</span><span class=\"params\">(<span class=\"type\">int</span> px, <span class=\"type\">int</span> py)</span> </span>&#123; x = px; y = py; &#125;</span><br><span class=\"line\">    <span class=\"function\"><span class=\"type\">void</span> <span class=\"title\">print</span><span class=\"params\">()</span> <span class=\"type\">const</span> </span>&#123; std::cout &lt;&lt; <span class=\"string\">&quot;GameObject at (&quot;</span> &lt;&lt; x &lt;&lt; <span class=\"string\">&quot;, &quot;</span> &lt;&lt; y &lt;&lt; <span class=\"string\">&quot;)\\n&quot;</span>; &#125;</span><br><span class=\"line\"><span class=\"keyword\">private</span>:</span><br><span class=\"line\">    <span class=\"type\">int</span> x, y;</span><br><span class=\"line\">&#125;;</span><br><span class=\"line\"><span class=\"keyword\">class</span> <span class=\"title class_\">ObjectPool</span> &#123;</span><br><span class=\"line\"><span class=\"keyword\">public</span>:</span><br><span class=\"line\">    <span class=\"built_in\">ObjectPool</span>(<span class=\"type\">size_t</span> poolSize) &#123;</span><br><span class=\"line\">        pool_.<span class=\"built_in\">reserve</span>(poolSize);</span><br><span class=\"line\">        <span class=\"keyword\">for</span> (<span class=\"type\">size_t</span> i = <span class=\"number\">0</span>; i &lt; poolSize; ++i) &#123;</span><br><span class=\"line\">            pool_.<span class=\"built_in\">push_back</span>(<span class=\"keyword\">new</span> <span class=\"built_in\">GameObject</span>());</span><br><span class=\"line\">            free_stack_.<span class=\"built_in\">push</span>(pool_.<span class=\"built_in\">back</span>());</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    ~<span class=\"built_in\">ObjectPool</span>() &#123;</span><br><span class=\"line\">        <span class=\"keyword\">for</span> (<span class=\"keyword\">auto</span> obj : pool_) <span class=\"keyword\">delete</span> obj;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"function\">GameObject* <span class=\"title\">acquire</span><span class=\"params\">()</span> </span>&#123;</span><br><span class=\"line\">        <span class=\"keyword\">if</span> (free_stack_.<span class=\"built_in\">empty</span>()) <span class=\"keyword\">return</span> <span class=\"literal\">nullptr</span>;</span><br><span class=\"line\">        GameObject* obj = free_stack_.<span class=\"built_in\">top</span>();</span><br><span class=\"line\">        free_stack_.<span class=\"built_in\">pop</span>();</span><br><span class=\"line\">        <span class=\"keyword\">return</span> obj;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"function\"><span class=\"type\">void</span> <span class=\"title\">release</span><span class=\"params\">(GameObject* obj)</span> </span>&#123;</span><br><span class=\"line\">        obj-&gt;<span class=\"built_in\">reset</span>();</span><br><span class=\"line\">        free_stack_.<span class=\"built_in\">push</span>(obj);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"><span class=\"keyword\">private</span>:</span><br><span class=\"line\">    std::vector&lt;GameObject*&gt; pool_;</span><br><span class=\"line\">    std::stack&lt;GameObject*&gt; free_stack_;</span><br><span class=\"line\">&#125;;</span><br><span class=\"line\"><span class=\"function\"><span class=\"type\">int</span> <span class=\"title\">main</span><span class=\"params\">()</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"function\">ObjectPool <span class=\"title\">pool</span><span class=\"params\">(<span class=\"number\">5</span>)</span></span>;</span><br><span class=\"line\">    GameObject *obj1 = pool.<span class=\"built_in\">acquire</span>();</span><br><span class=\"line\">    obj1-&gt;<span class=\"built_in\">set_position</span>(<span class=\"number\">10</span>, <span class=\"number\">20</span>);</span><br><span class=\"line\">    obj1-&gt;<span class=\"built_in\">print</span>(); <span class=\"comment\">// GameObject at (10, 20)</span></span><br><span class=\"line\">    pool.<span class=\"built_in\">release</span>(obj1);</span><br><span class=\"line\">    GameObject *obj2 = pool.<span class=\"built_in\">acquire</span>();</span><br><span class=\"line\">    obj2-&gt;<span class=\"built_in\">print</span>(); <span class=\"comment\">// GameObject at (0, 0) （重置后）</span></span><br><span class=\"line\">    <span class=\"keyword\">return</span> <span class=\"number\">0</span>;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<ul>\n<li><code>ObjectPool</code> 在构造时一次性向堆申请若干 <code>GameObject</code>，将它们全部存在 <code>pool_</code> 容器中，再把指针压入 <code>free_stack_</code>（栈）。获取时从 <code>free_stack_</code> 弹栈；释放时将对象 <code>reset()</code> 并压回栈。避免了频繁的 <code>new/delete</code>。</li>\n</ul>\n<hr>\n<h3 id=\"操作系统原理\"><a href=\"#操作系统原理\" class=\"headerlink\" title=\"操作系统原理\"></a>操作系统原理</h3><ul>\n<li><p><strong>线程栈</strong></p>\n<ul>\n<li>操作系统为每个线程分配固定大小的内存作为线程栈，用于保存函数调用帧、局部变量和中断上下文。栈空间不足会导致<strong>栈溢出（Stack Overflow）</strong>，可能使程序崩溃。</li>\n</ul>\n</li>\n<li><p><strong>堆碎片与分配器</strong></p>\n<ul>\n<li>应用在堆上频繁分配&#x2F;释放不同大小的块，会导致碎片化（外部碎片）。操作系统或 C 运行时使用<strong>分配算法</strong>（如伙伴系统、空闲链表、slab 分配器）来减少碎片。例如 Linux 内核使用伙伴算法（Buddy Allocator）为内核分配物理页；用户态 C 库（glibc）使用 ptmalloc2，实现复杂的 bin 快表和 mmap 分配，从而提升多线程环境下的分配效率并尽量减少碎片。</li>\n</ul>\n</li>\n</ul>\n<h1 id=\"总结\"><a href=\"#总结\" class=\"headerlink\" title=\"总结\"></a>总结</h1><p>总体而言，<strong>栈</strong>与<strong>堆</strong>在数据结构和内存管理层面都是基础而关键的概念。数据结构层面，栈提供简单高效的 LIFO 存取，堆（优先队列）提供基于优先级的动态调度；内存管理层面，栈由系统自动分配释放，速度快但空间有限；堆则按需动态分配，由程序或运行时负责回收，灵活但需要注意碎片和内存泄漏。理解两者的差异及应用场景（如嵌入式的静态分配、后端的请求栈和缓存管理、游戏的内存池、操作系统的线程栈管理等）可以帮助程序员写出更健壮、高效的代码。</p>\n<ul>\n<li><strong>栈</strong>：自动分配与释放；访问速度快；适用于函数调用、状态机、撤销等场景；容量有限且线程私有。</li>\n<li><strong>堆</strong>：动态分配与释放；灵活但开销较大；可能发生碎片；适用于缓存管理、对象池、动态数据结构等场景。</li>\n<li>理解两者在内存布局上的位置及增长方式，有助于避免栈溢出和堆栈冲突，提高程序安全性与性能。</li>\n</ul>\n"},{"title":"2025-05-06-Windows 系统将安装过系统镜像的固态硬盘恢复","date":"2025-05-05T16:00:00.000Z","_content":"# 2025-05-06-Windows 系统将安装过系统镜像的固态硬盘恢复\n\n> 参考博客\n> [如何将制作过的系统盘恢复成普通 U 盘_ubuntu 系统盘还原成普通 u 盘-CSDN 博客](https://blog.csdn.net/yongdad/article/details/139067667)\n\n# U 盘与之类似\n\n`win`+`x` 再按 `k` 打开磁盘管理\n\n![1746540429427EPSZbKOXuo8eWax3h6Qc5lLNnhh.png](https://tk-pichost-1325224430.cos.ap-chengdu.myqcloud.com/blog/1746540429427EPSZbKOXuo8eWax3h6Qc5lLNnhh.png)\n\n将中间的 mis 卷删除,再将整体新增卷即可\n\n![1746540468427V4JObBFySo9XphxGpg3cW57OnMc.png](https://tk-pichost-1325224430.cos.ap-chengdu.myqcloud.com/blog/1746540468427V4JObBFySo9XphxGpg3cW57OnMc.png)\n","source":"_posts/2025-05-06-Windows系统将安装过系统镜像的固态硬盘恢复.md","raw":"---\ntitle: 2025-05-06-Windows 系统将安装过系统镜像的固态硬盘恢复\ndate: 2025-05-06\ntags: 问题解决\n---\n# 2025-05-06-Windows 系统将安装过系统镜像的固态硬盘恢复\n\n> 参考博客\n> [如何将制作过的系统盘恢复成普通 U 盘_ubuntu 系统盘还原成普通 u 盘-CSDN 博客](https://blog.csdn.net/yongdad/article/details/139067667)\n\n# U 盘与之类似\n\n`win`+`x` 再按 `k` 打开磁盘管理\n\n![1746540429427EPSZbKOXuo8eWax3h6Qc5lLNnhh.png](https://tk-pichost-1325224430.cos.ap-chengdu.myqcloud.com/blog/1746540429427EPSZbKOXuo8eWax3h6Qc5lLNnhh.png)\n\n将中间的 mis 卷删除,再将整体新增卷即可\n\n![1746540468427V4JObBFySo9XphxGpg3cW57OnMc.png](https://tk-pichost-1325224430.cos.ap-chengdu.myqcloud.com/blog/1746540468427V4JObBFySo9XphxGpg3cW57OnMc.png)\n","slug":"2025-05-06-Windows系统将安装过系统镜像的固态硬盘恢复","published":1,"updated":"2025-09-26T12:17:21.349Z","_id":"cmg0saj48001ojm8n8qrh4t33","comments":1,"layout":"post","photos":[],"content":"<h1 id=\"2025-05-06-Windows-系统将安装过系统镜像的固态硬盘恢复\"><a href=\"#2025-05-06-Windows-系统将安装过系统镜像的固态硬盘恢复\" class=\"headerlink\" title=\"2025-05-06-Windows 系统将安装过系统镜像的固态硬盘恢复\"></a>2025-05-06-Windows 系统将安装过系统镜像的固态硬盘恢复</h1><blockquote>\n<p>参考博客<br><a href=\"https://blog.csdn.net/yongdad/article/details/139067667\">如何将制作过的系统盘恢复成普通 U 盘_ubuntu 系统盘还原成普通 u 盘-CSDN 博客</a></p>\n</blockquote>\n<h1 id=\"U-盘与之类似\"><a href=\"#U-盘与之类似\" class=\"headerlink\" title=\"U 盘与之类似\"></a>U 盘与之类似</h1><p><code>win</code>+<code>x</code> 再按 <code>k</code> 打开磁盘管理</p>\n<p><img src=\"https://tk-pichost-1325224430.cos.ap-chengdu.myqcloud.com/blog/1746540429427EPSZbKOXuo8eWax3h6Qc5lLNnhh.png\" alt=\"1746540429427EPSZbKOXuo8eWax3h6Qc5lLNnhh.png\"></p>\n<p>将中间的 mis 卷删除,再将整体新增卷即可</p>\n<p><img src=\"https://tk-pichost-1325224430.cos.ap-chengdu.myqcloud.com/blog/1746540468427V4JObBFySo9XphxGpg3cW57OnMc.png\" alt=\"1746540468427V4JObBFySo9XphxGpg3cW57OnMc.png\"></p>\n","excerpt":"","more":"<h1 id=\"2025-05-06-Windows-系统将安装过系统镜像的固态硬盘恢复\"><a href=\"#2025-05-06-Windows-系统将安装过系统镜像的固态硬盘恢复\" class=\"headerlink\" title=\"2025-05-06-Windows 系统将安装过系统镜像的固态硬盘恢复\"></a>2025-05-06-Windows 系统将安装过系统镜像的固态硬盘恢复</h1><blockquote>\n<p>参考博客<br><a href=\"https://blog.csdn.net/yongdad/article/details/139067667\">如何将制作过的系统盘恢复成普通 U 盘_ubuntu 系统盘还原成普通 u 盘-CSDN 博客</a></p>\n</blockquote>\n<h1 id=\"U-盘与之类似\"><a href=\"#U-盘与之类似\" class=\"headerlink\" title=\"U 盘与之类似\"></a>U 盘与之类似</h1><p><code>win</code>+<code>x</code> 再按 <code>k</code> 打开磁盘管理</p>\n<p><img src=\"https://tk-pichost-1325224430.cos.ap-chengdu.myqcloud.com/blog/1746540429427EPSZbKOXuo8eWax3h6Qc5lLNnhh.png\" alt=\"1746540429427EPSZbKOXuo8eWax3h6Qc5lLNnhh.png\"></p>\n<p>将中间的 mis 卷删除,再将整体新增卷即可</p>\n<p><img src=\"https://tk-pichost-1325224430.cos.ap-chengdu.myqcloud.com/blog/1746540468427V4JObBFySo9XphxGpg3cW57OnMc.png\" alt=\"1746540468427V4JObBFySo9XphxGpg3cW57OnMc.png\"></p>\n"},{"title":"2025-05-01-决策树算法及应用","date":"2025-04-30T16:00:00.000Z","_content":"# 决策树算法及应用\n\n# 参考资料\n\n> - [GitHub - zhaoyichanghong/machine_learing_algo_python: implement the machine learning algorithms by p](https://github.com/zhaoyichanghong/machine_learing_algo_python)(机器学习相关的 github 仓库)\n> - [决策树实现与应用](https://aibydoing.com/notebooks/chapter02-10-lab-decision-tree-implementation-and-applications)\n> - [决策树](https://zh.wikipedia.org/zh-cn/%E5%86%B3%E7%AD%96%E6%A0%91)\n\n# 概述\n\n## 机器学习算法分类\n\n## 决策树算法\n\n决策树是一种以树状结构对数据进行划分的分类（Classification）或回归（Regression）模型。其核心思想是：\n\n> 通过“自上而下”的方式，根据某一特征对样本进行二叉或多叉划分，直至满足停止条件（如纯度高、样本数小于阈值等），构造一棵可解释性高的树形模型。在叶节点输出类别（分类树）或数值（回归树）。\n\n决策树具有以下特点：\n\n- **易于理解与可视化**：生成后以树状图呈现，人类可直观理解每个分类/回归决策过程。\n- **无需大量数据预处理**：对数值型与类别型特征均可处理，无需像线性模型那样对特征做严格的标准化、归一化。\n- **自动进行特征选择**：在划分过程中会自动选出最能区分正负样本或最能减少误差的特征。\n\n从数据产生决策树的机器学习技术叫做**决策树学习**，通俗说就是**决策树**。\n\n一个决策树包含三种类型的节点：\n\n1. 决策节点：通常用矩形框来表示\n2. 机会节点：通常用圆圈来表示\n3. 终结点：通常用三角形来表示\n\n![1749360696852J52gbg16toig4zxF2PwcXPMynee.png](https://gitee.com/tanke11223344/imagehost/raw/main/blog/1749360696852J52gbg16toig4zxF2PwcXPMynee.png)\n\n决策树是一种特殊的树形结构，一般由节点和有向边组成。其中，节点表示特征、属性或者一个类，而有向边包含判断条件。决策树从根节点开始延伸，经过不同的判断条件后，到达不同的子节点。而上层子节点又可以作为父节点被进一步划分为下层子节点。一般情况下，我们从根节点输入数据，经过多次判断后，这些数据就会被分为不同的类别。这就构成了一颗简单的分类决策树。\n\n![1749360705910DCD5b5sUbootQ5xUESpcmfBRnDy.png](https://gitee.com/tanke11223344/imagehost/raw/main/blog/1749360705910DCD5b5sUbootQ5xUESpcmfBRnDy.png)\n\n### 算法原理\n\n其实决策树算法如同上面场景一样，其思想非常容易理解，具体的算法流程为：\n\n1. 数据准备 → 通过数据清洗和数据处理，将数据整理为没有缺省值的向量。\n2. 寻找最佳特征 → 遍历每个特征的每一种划分方式，找到最好的划分特征。\n3. 生成分支 → 划分成两个或多个节点。\n4. 生成决策树 → 对分裂后的节点分别继续执行 2-3 步，直到每个节点只有一种类别。\n5. 决策分类 → 根据训练决策树模型，将预测数据进行分类。\n\n## 决策树的基本概念\n\n### 结点类型\n\n1. **根节点 (Root Node)**\n\n- 树的起始节点，包含了整个训练集。\n\n1. **内部节点 (Internal Node)**\n\n- 又称决策节点（Decision Node），表示一个根据某个特征进行划分的测试。\n\n1. **叶节点 (Leaf / Terminal Node)**\n\n- 表示最终的类别（分类树）或数值（回归树）。\n\n1. **分支 (Branch / Edge)**\n\n- 从父节点到子节点的连线，通常对应该节点特征的某个取值或取值范围。\n\n### 树结构与术语\n\n- **路径 (Path)**：从根节点到某个叶节点所经过的结点序列，即一个完整的决策逻辑分支。\n- **深度 (Depth)**：根节点的深度定义为 0，子节点依次递增。树的最大深度称为 高度 (Height)。\n- **样本纯度 (Purity)**：指一个节点中样本类别的一致性。\n- 比如在分类问题中，若节点仅包含同一类别样本，则称该节点纯度为 1（纯节点）。\n- **叶子样本数 (Leaf Sample Count)**：用于限制过拟合，可设定：当某节点样本数不足阈值时，停止划分，将其设为叶节点。\n- **划分停止条件**：\n\n1. 所有样本属于同一类别（分类树），或样本方差足够小（回归树）。\n2. 树达到最大深度。\n3. 节点中样本数量小于某个阈值。\n4. 划分后信息增益或基尼系数提升不足阈值。\n\n---\n\n## 决策树构建的核心要素\n\n### 划分指标\n\n决策树的关键在于如何选择最优划分特征与划分点。常见的三种指标为信息增益、信息增益率和基尼不纯度。\n\n#### 信息增益 (Information Gain) ——ID3\n\n设当前节点样本集为 $D$，共有 $K$ 个类别 $\\{C_1, C_2, \\dots, C_K\\}$。定义：\n\n- 节点 $D$ 信息熵：\n\n$$\nH(D) = -\\sum_{k=1}^K p_k \\log_2 p_k,\\quad p_k = \\frac{|D_k|}{|D|}\n$$\n\n其中 $|D_k|$ 是类别 $C_k$ 在 $D$ 中的样本数。\n\n- 若使用特征 $A$ 进行划分，且 $A$ 共有 $v$ 个互斥取值 $\\{a_1,\\dots,a_v\\}$，则在 $A=a_i$ 处的子集记为 $D_i$。\n\n划分后加权平均的信息熵：\n\n$$\nH(D \\mid A) = \\sum_{i=1}^v \\frac{|D_i|}{|D|} H(D_i)\n$$\n\n- **信息增益**：即划分前后熵的减少量：\n\n$$\n\\text{Gain}(A) = H(D) - H(D \\mid A)\n$$\n\n**ID3 算法**选择信息增益最大的特征进行划分——即令：\n\n$$\nA^* = \\arg\\max_{A} \\text{Gain}(A)\n$$\n\n> **缺点**：信息增益偏向取值多的特征（类别型变量有大量不同取值时容易过拟合）。\n\n#### 信息增益率 (Gain Ratio) ——C4.5\n\n为克服 ID3 的偏向性，C4.5 引入分裂信息（Split Information）来对信息增益进行归一化：\n\n1. **分裂信息**（或称固有信息）：\n\n$$\n\\text{SplitInfo}(A) = -\\sum_{i=1}^v \\frac{|D_i|}{|D|} \\log_2 \\frac{|D_i|}{|D|}\n$$\n\n1. **信息增益率**：\n\n$$\n\\text{GainRatio}(A) = \\frac{\\text{Gain}(A)}{\\text{SplitInfo}(A) + \\epsilon}\n$$\n\n通常选择信息增益率最高的特征进行划分。\n\n> C4.5 同时支持对连续性（数值型）特征的二元划分：先对候选切分点进行排序，再遍历所有相邻两值中点，选取使增益率最大的切分点。\n\n#### 基尼不纯度 (Gini Impurity) ——CART\n\nCART（Classification And Regression Tree）算法采用基尼不纯度作为划分依据。对于节点 $$D$$，基尼不纯度定义为：\n\n$$\n\\mathrm{Gini}(D) = 1 - \\sum_{k=1}^K p_k^2, \\quad p_k = \\frac{|D_k|}{|D|}\n$$\n\n- 若使用特征 $A$ 将 $D$ 划分为两个子集（CART 传统上构建二叉树），设划分后两部分分别为 $D_\\text{left}, D_\\text{right}$，则划分后的基尼系数为加权平均：\n\n$$\n\\mathrm{Gini}(D, A, s) = \\frac{|D_\\text{left}|}{|D|}\\mathrm{Gini}(D_\\text{left}) + \\frac{|D_\\text{right}|}{|D|}\\mathrm{Gini}(D_\\text{right})\n$$\n\n- **基尼增益 (Gini Gain)**（或称基尼减少量）:\n\n$$\n\\Delta \\mathrm{Gini}(A, s) = \\mathrm{Gini}(D) - \\mathrm{Gini}(D, A, s)\n$$\n\nCART 选择使基尼不纯度下降最多（即 $\\Delta \\mathrm{Gini}$ 最大）的特征和切分点。\n\n> **CART 区别**：\n>\n> - 使用基尼而非熵；\n> - 通常只考虑二元（yes/no）划分，即每个节点形成左右两个子节点。\n> - 对数值型特征遍历所有可能切分点；对类别型特征可先将类别编码为虚拟变量 (One-Hot) 或按某种顺序处理。\n\n---\n\n### 特征选择与最佳划分\n\n1. **离散(类别)特征**\n\n- ID3/C4.5 直接按每个取值划分；CART 需要将 $m$ 个类别先切分为两组（所有可能子集划分），计算基尼并选择最优。\n\n1. **连续（数值）特征**\n\n- 首先对该特征在当前节点的所有样本的取值排序：$x_{(1)} \\le x_{(2)} \\le \\dots \\le x_{(n)}$。\n- 对每个相邻取值对 $\\{x_{(i)}, x_{(i+1)}\\}$，将其中点 $s = \\tfrac{x_{(i)}+x_{(i+1)}}{2}$ 作为候选切分点。\n- 分别计算按 $A \\le s$ 与 $A > s$ 两部分划分后的信息增益（或基尼减少量），选择最优 $s^*$。\n\n1. **递归构建**\n\n- 从根节点开始，对当前节点所有候选特征（及可能的切分点）分别计算划分指标；\n- 选出指标最优的特征/切分点，将样本划分到子节点；\n- 对每个子节点递归执行，同样进行“特征选择 → 划分 → 递归”，直到满足停止条件。\n\n---\n\n## 常见决策树算法变体\n\n### ID3 （Quinlan，1986）\n\n- **核心思想**：\n- 使用信息增益作为划分标准；\n- 仅适用于离散（类别）特征；\n- 构建多叉树（一个节点可以有多条分支，对应特征的所有取值）。\n- **简易流程**：\n\n1. 计算当前节点样本集信息熵 $H(D)$。\n2. 对每个候选特征 $A$，计算信息增益 $\\text{Gain}(A)$。\n3. 选取信息增益最大的特征 $A^*$，对该节点进行划分。\n4. 递归地对每个子节点执行上述步骤。\n5. 递归终止条件：\n\n   * 节点样本全属于同一类别（纯度 1）。\n   * 特征集为空（多数投票决定叶节点类别）。\n   * 节点样本数小于阈值。\n\n### C4.5（Quinlan，1993）\n\n- **改进点**：\n\n1. 支持数值型特征的自动二元划分。\n2. 使用信息增益率（Gain Ratio）来选择特征，克服取值多特征的偏向问题。\n3. 支持“有缺失值”处理：当样本缺失特征 $A$ 时，按已知特征在其他样本中的分布进行加权。\n4. 剪枝：可基于统计检验进行后剪枝，减少过拟合。\n\n- **流程**：\n\n1. 对所有特征计算信息增益率 $\\text{GainRatio}(A)$，选取最优特征 $A^*$；\n2. 对于数值型特征，遍历所有候选切分点（相邻排序值中点），计算最佳增益率；\n3. 按 $A^*$ 将节点划分；\n4. 递归；\n5. 在树构建完成后进行后剪枝（可选）。\n\n### CART （Breiman 等，1984）\n\n- **核心思想**：\n- 使用基尼不纯度 (Gini) 作为划分标准；\n- 构建二叉树：每个节点仅有 “是/否” 两个分支；\n- 同时支持分类树 (Classification Tree) 和回归树 (Regression Tree)。\n- **分类树流程**：\n\n1. 计算当前节点的 $\\mathrm{Gini}(D)$。\n2. 对每个候选特征及其所有可能二元切分点，计算基尼减少量 $\\Delta \\mathrm{Gini}(A, s)$。\n3. 选择使 $\\Delta \\mathrm{Gini}$ 最大的特征与切分点 $(A^*, s^*)$。\n4. 将节点划分为左右子节点；\n5. 递归；\n6. **剪枝**：可使用交叉验证来调节树的复杂度，通过最小化验证误差决定是否剪枝。\n\n- **回归树流程**：\n- 用 MSE（均方误差）或绝对误差作为节点不纯度度量：\n\n$$\n\\mathrm{MSE}(D) = \\frac{1}{|D|}\\sum_{i\\in D} (y_i - \\bar y)^2,\\quad \\bar y = \\frac{1}{|D|}\\sum_{i\\in D} y_i\n$$\n\n$$\n\\mathrm{MSE}(D) = \\frac{1}{|D|}\\sum_{i\\in D} (y_i - \\bar y)^2,\\quad \\bar y = \\frac{1}{|D|}\\sum_{i\\in D} y_i\n$$\n\n- 对数值型特征 $A$ 遍历二元切分点，分别计算左右子集的 MSE 加权平均。\n- 选取使 MSE 降低最多的切分。\n- 剪枝一般使用最小化验证集误差或对叶子节点惩罚复杂度（Cost-Complexity Pruning）。\n\n---\n\n## 剪枝 (Pruning)\n\n在决策树中，过深的树容易过拟合训练数据，影响泛化。剪枝是为了提高模型在测试集上的准确性。主要有两种方式：\n\n### 预剪枝 (Pre-pruning)\n\n在构建树的过程中，提前停止划分，常见策略有：\n\n1. **最小样本数**：若节点样本数小于某阈值，停止划分；\n2. **最大深度**：树深度达到设定上限，停止；\n3. **信息增益/基尼减少阈值**：若最优划分的增益（或减少量）小于阈值，则不再划分；\n4. **统计检验**：基于卡方检验等统计检验判定划分是否显著。\n\n> **优点**：减少计算和树的复杂度。\n> **缺点**：一旦提前停止，可能错过后续有效划分，导致欠拟合。\n\n### 后剪枝 (Post-pruning)\n\n先让树尽可能长地生长，然后自底向上裁剪。常见流程：\n\n1. 构建完完全树（直到所有叶节点纯度为 1 或没有更多可划分特征）；\n2. 对每个非叶子节点评估以下两种情况哪种在验证集上性能更好：\n\n- 保留该子树结构；\n- 将其剪为叶节点，并以子树所有样本在该节点的多数类（分类）或平均值（回归）作为输出；\n\n1. 如果剪掉子树后验证误差减少或无显著变化，则保留剪枝操作；否则保留子树；\n2. 重复上述过程，直到没有可剪枝节点或验证集误差不再降低。\n\n> **CART 的 Cost-Complexity Pruning**：定义节点惩罚函数\n\n---\n\n## 决策树的优缺点\n\n### 优点\n\n1. **可解释性强**\n\n- 生成后的决策树可视化，人类易于理解和解释每个决策路径。\n\n1. **无须特征归一化**\n\n- 对数值型与类别型特征均可处理，不要求输入特征尺度统一。\n\n1. **自动特征选择**\n\n- 在划分过程中自动评估并选取对分类/回归最有价值的特征。\n\n1. **鲁棒性强**\n\n- 对缺失值可采用“分裂时加权”或“按多数类分配”等策略进行处理；对异常值不敏感。\n\n1. **易于处理多种类型数据**\n\n- 可以同时处理数值、类别以及缺失值。\n\n### 缺点\n\n1. **容易过拟合**\n\n- 深度过大时对训练数据拟合过度，泛化能力下降。\n\n1. **对噪声敏感**\n\n- 训练数据中的噪声决定划分时可能误导特征选择。\n\n1. **局部最优**\n\n- 由于采用贪心策略（每次只选最优特征），可能无法得到全局最优树。\n\n1. **可用性限制**\n\n- 对高维稀疏数据（如文本）可能效果不佳；容易生成非常深且稀疏的树。\n\n1. **不稳定性**\n\n- 微小的数据变化可能导致决策树结构的大幅改变（当某些样本临界时）。\n\n> **改进思路**：\n>\n> - **集成方法**：随机森林 (Random Forest)、梯度提升树 (Gradient Boosting Trees，如 XGBoost、LightGBM) 通过集成多棵弱树克服单棵树的易过拟合与不稳定问题。\n> - **特征筛选与降维**：在高维稀疏场景下，可结合特征工程、特征选择等方法减小特征维度。\n\n---\n\n## 决策树在实际中的应用场景\n\n### 相关代码示例\n\n> 由于还包含了 c45,cart,id3 为划分指标的决策树代码,我整理在了一个 github 仓库中,下面只展示了 decision_stump.py 的代码\n> [https://github.com/tkzzzzzz6/MLandDL](https://github.com/tkzzzzzz6/MLandDL)\n\n#### decision_stump.py(主要模块)\n\n```python\nimport numpy as np\n\nclass DecisionStump():\n    def __update_parameter(self, h, feature_index, threshold, direction, err_value):\n        self.**__min_err_value** = err_value\n        self.**__feature_index** = feature_index\n        self.**__threshold** = threshold\n        self.**__direction** = direction\n\n    def __select_direction(self, feature_index, threshold, X, y, w):\n        for direction in ['greater', 'less']:\n            h = np.ones_like(y)\n\n            if direction == 'greater':\n                h[np.flatnonzero(X[:, feature_index] < threshold)] = -1\n            else:\n                h[np.flatnonzero(X[:, feature_index] >= threshold)] = -1\n\n            err_value = np.sum(w[np.flatnonzero(h != y)])\n            if err_value < self.**__min_err_value**:\n                self.__update_parameter(h, feature_index, threshold, 'greater', err_value)\n\n    def __select_threshold(self, feature_index, X, y, w):\n        n_samples = X.shape[0]\n\n        for i in range(n_samples):\n            self.__select_direction(feature_index, X[i, feature_index], X, y, w)\n\n    def __select_feature(self, X, y, w):\n        n_features = X.shape[1]\n\n        for i in range(n_features):\n            self.__select_threshold(i, X, y, w)\n\n    def fit(self, X, y, w):\n        self.**__feature_index** = None\n        self.**__threshold** = None\n        self.**__direction** = None\n        self.**__min_err_value** = np.**inf**\n\n        self.__select_feature(X, y, w)\n\n    def predict(self, X):\n        n_samples = X.shape[0]\n\n        y_pred = np.ones(n_samples)\n        if self.**__direction** == 'greater':\n            y_pred[np.flatnonzero(X[:, self.**__feature_index**] < self.**__threshold**)] = -1\n        else:\n            y_pred[np.flatnonzero(X[:, self.**__feature_index**] >= self.**__threshold**)] = -1\n\n        return y_pred\n```\n\n#### 运行结果\n\n![1749360718079T62Tbr1DOojvcLxBIxqcFCvHnlg.png](https://gitee.com/tanke11223344/imagehost/raw/main/blog/1749360718079T62Tbr1DOojvcLxBIxqcFCvHnlg.png)\n\n![1749360730852Tfdmbz1oOo6vFpxAAfkcoEBGnXc.png](https://gitee.com/tanke11223344/imagehost/raw/main/blog/1749360730852Tfdmbz1oOo6vFpxAAfkcoEBGnXc.png)\n![1749360750853Zeg3bB0PioEDr0x9taMclxgOnmh.png](https://gitee.com/tanke11223344/imagehost/raw/main/blog/1749360750853Zeg3bB0PioEDr0x9taMclxgOnmh.png)\n\n### 分类任务\n\n1. **客户流失预测 (Customer Churn Prediction)**\n\n- 业务场景：电信、金融、电商等行业中，通过客户基本属性、历史行为、消费习惯等特征预测是否会流失。\n- 决策树优势：易于解释（可解释哪些因素导致客户流失），可处理混合型特征（年龄、性别、套餐类别、使用时长等）。\n\n1. **信用评估 (Credit Scoring)**\n\n- 业务场景：银行或金融机构根据用户的个人信息（年龄、工作、收入）、信用记录（逾期次数、还款能力）进行信用风险分类（高风险、中风险、低风险）。\n- 应用：决策树可直观地给出“如果收入 < X 且逾期次数 > Y，则分类为高风险”，帮助信贷风控。\n\n1. **医疗诊断**\n\n- 业务场景：根据患者的症状（发热、咳嗽、X 光结果）、检查指标（血常规、心电图）等预测是否患某种疾病。\n- 应用：决策树模型可以给出“若咳嗽持续 > 2 周 且 白细胞数 > 某阈值，则可能为肺炎”，同时提供可解释的诊断决策流程。\n\n1. **垃圾邮件识别**\n\n- 业务场景：根据邮件内容特征（关键字出现次数、发送人是否在白名单）、邮件长度、附件类型等判断是否为垃圾邮件。\n- 应用：决策树可快速处理离散/连续特征，常用于构建初期的规则或与其他模型结合（如 Random Forest）。\n\n### 回归任务\n\n1. **房价预测 (House Price Prediction)**\n\n- 业务场景：根据房屋面积、楼层、房龄、地理位置、交通等因素预测房价。\n- 决策树回归：将房屋特征空间划分为若干区域，每个叶节点输出区域内样本的平均房价。做不到很平滑，但易于理解。\n\n1. **销售额预测**\n\n- 业务场景：预测节假日、促销活动或天气变化对某商品销售额的影响。\n- 决策树回归能够捕获非线性关系，且不需要对特征进行大量预处理。\n\n### 特征工程与规则提取\n\n1. **特征构造**\n\n- 通过决策树可以将某些连续特征自动离散化。例如，若决策树对“年龄”做了三次切分，分别在 25 岁、40 岁产生不同的分支，则可得到“年龄段”特征。\n\n1. **规则提取**\n\n- 从训练好的决策树中可直接提取“如果……则……”的规则，用于可解释性要求高的场景（如审计、医疗）。\n\n### 集成学习基础\n\n1. **随机森林 (Random Forest)**\n\n- 由多棵决策树随机组合而成。每棵树训练时只使用特征子集和样本子集，最后多数投票决定分类结果或平均值决定回归值。\n- 优势：降低单棵决策树的过拟合风险，提高泛化能力。\n\n1. **梯度提升树 (Gradient Boosting Trees)**\n\n- 通过逐步拟合残差的方式构建多个弱决策树，每棵新树在前一棵树的基础上拟合残差，最终组合得到强模型，如 XGBoost、LightGBM、CatBoost。\n\n---\n\n## 总结\n\n1. **决策树** 是一种简单、易理解且可处理混合型特征的模型，既可做分类，也可做回归。\n2. **核心步骤**：选择合适的划分指标（信息增益 / 信息增益率 / 基尼不纯度）、确定最佳划分点，递归生成树，并通过剪枝降低过拟合。\n3. **常见算法**：\n\n- **ID3**（仅支持离散特征，使用信息增益）\n- **C4.5**（支持数值特征 & 离散特征，使用信息增益率，含剪枝）\n- **CART**（构建二叉树，使用基尼不纯度，可用于分类与回归）\n\n1. **优缺点**：\n\n- 优点：可解释性强、无需特征缩放、自动进行特征选择。\n- 缺点：容易过拟合、对噪声敏感、在高维稀疏场景下不够稳定。\n\n1. **典型应用**：\n\n- 客户流失预测、信用评估、医疗诊断、垃圾邮件识别等分类场景；\n- 房价预测、销售额预测等回归场景；\n- 特征工程、规则提取、以及集成学习（随机森林、梯度提升树）的基石。\n","source":"_posts/2025-05-01-决策树算法及应用.md","raw":"---\ntitle:  2025-05-01-决策树算法及应用\ndate: 2025-05-01\ntags: \n    课程学习\n---\n# 决策树算法及应用\n\n# 参考资料\n\n> - [GitHub - zhaoyichanghong/machine_learing_algo_python: implement the machine learning algorithms by p](https://github.com/zhaoyichanghong/machine_learing_algo_python)(机器学习相关的 github 仓库)\n> - [决策树实现与应用](https://aibydoing.com/notebooks/chapter02-10-lab-decision-tree-implementation-and-applications)\n> - [决策树](https://zh.wikipedia.org/zh-cn/%E5%86%B3%E7%AD%96%E6%A0%91)\n\n# 概述\n\n## 机器学习算法分类\n\n## 决策树算法\n\n决策树是一种以树状结构对数据进行划分的分类（Classification）或回归（Regression）模型。其核心思想是：\n\n> 通过“自上而下”的方式，根据某一特征对样本进行二叉或多叉划分，直至满足停止条件（如纯度高、样本数小于阈值等），构造一棵可解释性高的树形模型。在叶节点输出类别（分类树）或数值（回归树）。\n\n决策树具有以下特点：\n\n- **易于理解与可视化**：生成后以树状图呈现，人类可直观理解每个分类/回归决策过程。\n- **无需大量数据预处理**：对数值型与类别型特征均可处理，无需像线性模型那样对特征做严格的标准化、归一化。\n- **自动进行特征选择**：在划分过程中会自动选出最能区分正负样本或最能减少误差的特征。\n\n从数据产生决策树的机器学习技术叫做**决策树学习**，通俗说就是**决策树**。\n\n一个决策树包含三种类型的节点：\n\n1. 决策节点：通常用矩形框来表示\n2. 机会节点：通常用圆圈来表示\n3. 终结点：通常用三角形来表示\n\n![1749360696852J52gbg16toig4zxF2PwcXPMynee.png](https://gitee.com/tanke11223344/imagehost/raw/main/blog/1749360696852J52gbg16toig4zxF2PwcXPMynee.png)\n\n决策树是一种特殊的树形结构，一般由节点和有向边组成。其中，节点表示特征、属性或者一个类，而有向边包含判断条件。决策树从根节点开始延伸，经过不同的判断条件后，到达不同的子节点。而上层子节点又可以作为父节点被进一步划分为下层子节点。一般情况下，我们从根节点输入数据，经过多次判断后，这些数据就会被分为不同的类别。这就构成了一颗简单的分类决策树。\n\n![1749360705910DCD5b5sUbootQ5xUESpcmfBRnDy.png](https://gitee.com/tanke11223344/imagehost/raw/main/blog/1749360705910DCD5b5sUbootQ5xUESpcmfBRnDy.png)\n\n### 算法原理\n\n其实决策树算法如同上面场景一样，其思想非常容易理解，具体的算法流程为：\n\n1. 数据准备 → 通过数据清洗和数据处理，将数据整理为没有缺省值的向量。\n2. 寻找最佳特征 → 遍历每个特征的每一种划分方式，找到最好的划分特征。\n3. 生成分支 → 划分成两个或多个节点。\n4. 生成决策树 → 对分裂后的节点分别继续执行 2-3 步，直到每个节点只有一种类别。\n5. 决策分类 → 根据训练决策树模型，将预测数据进行分类。\n\n## 决策树的基本概念\n\n### 结点类型\n\n1. **根节点 (Root Node)**\n\n- 树的起始节点，包含了整个训练集。\n\n1. **内部节点 (Internal Node)**\n\n- 又称决策节点（Decision Node），表示一个根据某个特征进行划分的测试。\n\n1. **叶节点 (Leaf / Terminal Node)**\n\n- 表示最终的类别（分类树）或数值（回归树）。\n\n1. **分支 (Branch / Edge)**\n\n- 从父节点到子节点的连线，通常对应该节点特征的某个取值或取值范围。\n\n### 树结构与术语\n\n- **路径 (Path)**：从根节点到某个叶节点所经过的结点序列，即一个完整的决策逻辑分支。\n- **深度 (Depth)**：根节点的深度定义为 0，子节点依次递增。树的最大深度称为 高度 (Height)。\n- **样本纯度 (Purity)**：指一个节点中样本类别的一致性。\n- 比如在分类问题中，若节点仅包含同一类别样本，则称该节点纯度为 1（纯节点）。\n- **叶子样本数 (Leaf Sample Count)**：用于限制过拟合，可设定：当某节点样本数不足阈值时，停止划分，将其设为叶节点。\n- **划分停止条件**：\n\n1. 所有样本属于同一类别（分类树），或样本方差足够小（回归树）。\n2. 树达到最大深度。\n3. 节点中样本数量小于某个阈值。\n4. 划分后信息增益或基尼系数提升不足阈值。\n\n---\n\n## 决策树构建的核心要素\n\n### 划分指标\n\n决策树的关键在于如何选择最优划分特征与划分点。常见的三种指标为信息增益、信息增益率和基尼不纯度。\n\n#### 信息增益 (Information Gain) ——ID3\n\n设当前节点样本集为 $D$，共有 $K$ 个类别 $\\{C_1, C_2, \\dots, C_K\\}$。定义：\n\n- 节点 $D$ 信息熵：\n\n$$\nH(D) = -\\sum_{k=1}^K p_k \\log_2 p_k,\\quad p_k = \\frac{|D_k|}{|D|}\n$$\n\n其中 $|D_k|$ 是类别 $C_k$ 在 $D$ 中的样本数。\n\n- 若使用特征 $A$ 进行划分，且 $A$ 共有 $v$ 个互斥取值 $\\{a_1,\\dots,a_v\\}$，则在 $A=a_i$ 处的子集记为 $D_i$。\n\n划分后加权平均的信息熵：\n\n$$\nH(D \\mid A) = \\sum_{i=1}^v \\frac{|D_i|}{|D|} H(D_i)\n$$\n\n- **信息增益**：即划分前后熵的减少量：\n\n$$\n\\text{Gain}(A) = H(D) - H(D \\mid A)\n$$\n\n**ID3 算法**选择信息增益最大的特征进行划分——即令：\n\n$$\nA^* = \\arg\\max_{A} \\text{Gain}(A)\n$$\n\n> **缺点**：信息增益偏向取值多的特征（类别型变量有大量不同取值时容易过拟合）。\n\n#### 信息增益率 (Gain Ratio) ——C4.5\n\n为克服 ID3 的偏向性，C4.5 引入分裂信息（Split Information）来对信息增益进行归一化：\n\n1. **分裂信息**（或称固有信息）：\n\n$$\n\\text{SplitInfo}(A) = -\\sum_{i=1}^v \\frac{|D_i|}{|D|} \\log_2 \\frac{|D_i|}{|D|}\n$$\n\n1. **信息增益率**：\n\n$$\n\\text{GainRatio}(A) = \\frac{\\text{Gain}(A)}{\\text{SplitInfo}(A) + \\epsilon}\n$$\n\n通常选择信息增益率最高的特征进行划分。\n\n> C4.5 同时支持对连续性（数值型）特征的二元划分：先对候选切分点进行排序，再遍历所有相邻两值中点，选取使增益率最大的切分点。\n\n#### 基尼不纯度 (Gini Impurity) ——CART\n\nCART（Classification And Regression Tree）算法采用基尼不纯度作为划分依据。对于节点 $$D$$，基尼不纯度定义为：\n\n$$\n\\mathrm{Gini}(D) = 1 - \\sum_{k=1}^K p_k^2, \\quad p_k = \\frac{|D_k|}{|D|}\n$$\n\n- 若使用特征 $A$ 将 $D$ 划分为两个子集（CART 传统上构建二叉树），设划分后两部分分别为 $D_\\text{left}, D_\\text{right}$，则划分后的基尼系数为加权平均：\n\n$$\n\\mathrm{Gini}(D, A, s) = \\frac{|D_\\text{left}|}{|D|}\\mathrm{Gini}(D_\\text{left}) + \\frac{|D_\\text{right}|}{|D|}\\mathrm{Gini}(D_\\text{right})\n$$\n\n- **基尼增益 (Gini Gain)**（或称基尼减少量）:\n\n$$\n\\Delta \\mathrm{Gini}(A, s) = \\mathrm{Gini}(D) - \\mathrm{Gini}(D, A, s)\n$$\n\nCART 选择使基尼不纯度下降最多（即 $\\Delta \\mathrm{Gini}$ 最大）的特征和切分点。\n\n> **CART 区别**：\n>\n> - 使用基尼而非熵；\n> - 通常只考虑二元（yes/no）划分，即每个节点形成左右两个子节点。\n> - 对数值型特征遍历所有可能切分点；对类别型特征可先将类别编码为虚拟变量 (One-Hot) 或按某种顺序处理。\n\n---\n\n### 特征选择与最佳划分\n\n1. **离散(类别)特征**\n\n- ID3/C4.5 直接按每个取值划分；CART 需要将 $m$ 个类别先切分为两组（所有可能子集划分），计算基尼并选择最优。\n\n1. **连续（数值）特征**\n\n- 首先对该特征在当前节点的所有样本的取值排序：$x_{(1)} \\le x_{(2)} \\le \\dots \\le x_{(n)}$。\n- 对每个相邻取值对 $\\{x_{(i)}, x_{(i+1)}\\}$，将其中点 $s = \\tfrac{x_{(i)}+x_{(i+1)}}{2}$ 作为候选切分点。\n- 分别计算按 $A \\le s$ 与 $A > s$ 两部分划分后的信息增益（或基尼减少量），选择最优 $s^*$。\n\n1. **递归构建**\n\n- 从根节点开始，对当前节点所有候选特征（及可能的切分点）分别计算划分指标；\n- 选出指标最优的特征/切分点，将样本划分到子节点；\n- 对每个子节点递归执行，同样进行“特征选择 → 划分 → 递归”，直到满足停止条件。\n\n---\n\n## 常见决策树算法变体\n\n### ID3 （Quinlan，1986）\n\n- **核心思想**：\n- 使用信息增益作为划分标准；\n- 仅适用于离散（类别）特征；\n- 构建多叉树（一个节点可以有多条分支，对应特征的所有取值）。\n- **简易流程**：\n\n1. 计算当前节点样本集信息熵 $H(D)$。\n2. 对每个候选特征 $A$，计算信息增益 $\\text{Gain}(A)$。\n3. 选取信息增益最大的特征 $A^*$，对该节点进行划分。\n4. 递归地对每个子节点执行上述步骤。\n5. 递归终止条件：\n\n   * 节点样本全属于同一类别（纯度 1）。\n   * 特征集为空（多数投票决定叶节点类别）。\n   * 节点样本数小于阈值。\n\n### C4.5（Quinlan，1993）\n\n- **改进点**：\n\n1. 支持数值型特征的自动二元划分。\n2. 使用信息增益率（Gain Ratio）来选择特征，克服取值多特征的偏向问题。\n3. 支持“有缺失值”处理：当样本缺失特征 $A$ 时，按已知特征在其他样本中的分布进行加权。\n4. 剪枝：可基于统计检验进行后剪枝，减少过拟合。\n\n- **流程**：\n\n1. 对所有特征计算信息增益率 $\\text{GainRatio}(A)$，选取最优特征 $A^*$；\n2. 对于数值型特征，遍历所有候选切分点（相邻排序值中点），计算最佳增益率；\n3. 按 $A^*$ 将节点划分；\n4. 递归；\n5. 在树构建完成后进行后剪枝（可选）。\n\n### CART （Breiman 等，1984）\n\n- **核心思想**：\n- 使用基尼不纯度 (Gini) 作为划分标准；\n- 构建二叉树：每个节点仅有 “是/否” 两个分支；\n- 同时支持分类树 (Classification Tree) 和回归树 (Regression Tree)。\n- **分类树流程**：\n\n1. 计算当前节点的 $\\mathrm{Gini}(D)$。\n2. 对每个候选特征及其所有可能二元切分点，计算基尼减少量 $\\Delta \\mathrm{Gini}(A, s)$。\n3. 选择使 $\\Delta \\mathrm{Gini}$ 最大的特征与切分点 $(A^*, s^*)$。\n4. 将节点划分为左右子节点；\n5. 递归；\n6. **剪枝**：可使用交叉验证来调节树的复杂度，通过最小化验证误差决定是否剪枝。\n\n- **回归树流程**：\n- 用 MSE（均方误差）或绝对误差作为节点不纯度度量：\n\n$$\n\\mathrm{MSE}(D) = \\frac{1}{|D|}\\sum_{i\\in D} (y_i - \\bar y)^2,\\quad \\bar y = \\frac{1}{|D|}\\sum_{i\\in D} y_i\n$$\n\n$$\n\\mathrm{MSE}(D) = \\frac{1}{|D|}\\sum_{i\\in D} (y_i - \\bar y)^2,\\quad \\bar y = \\frac{1}{|D|}\\sum_{i\\in D} y_i\n$$\n\n- 对数值型特征 $A$ 遍历二元切分点，分别计算左右子集的 MSE 加权平均。\n- 选取使 MSE 降低最多的切分。\n- 剪枝一般使用最小化验证集误差或对叶子节点惩罚复杂度（Cost-Complexity Pruning）。\n\n---\n\n## 剪枝 (Pruning)\n\n在决策树中，过深的树容易过拟合训练数据，影响泛化。剪枝是为了提高模型在测试集上的准确性。主要有两种方式：\n\n### 预剪枝 (Pre-pruning)\n\n在构建树的过程中，提前停止划分，常见策略有：\n\n1. **最小样本数**：若节点样本数小于某阈值，停止划分；\n2. **最大深度**：树深度达到设定上限，停止；\n3. **信息增益/基尼减少阈值**：若最优划分的增益（或减少量）小于阈值，则不再划分；\n4. **统计检验**：基于卡方检验等统计检验判定划分是否显著。\n\n> **优点**：减少计算和树的复杂度。\n> **缺点**：一旦提前停止，可能错过后续有效划分，导致欠拟合。\n\n### 后剪枝 (Post-pruning)\n\n先让树尽可能长地生长，然后自底向上裁剪。常见流程：\n\n1. 构建完完全树（直到所有叶节点纯度为 1 或没有更多可划分特征）；\n2. 对每个非叶子节点评估以下两种情况哪种在验证集上性能更好：\n\n- 保留该子树结构；\n- 将其剪为叶节点，并以子树所有样本在该节点的多数类（分类）或平均值（回归）作为输出；\n\n1. 如果剪掉子树后验证误差减少或无显著变化，则保留剪枝操作；否则保留子树；\n2. 重复上述过程，直到没有可剪枝节点或验证集误差不再降低。\n\n> **CART 的 Cost-Complexity Pruning**：定义节点惩罚函数\n\n---\n\n## 决策树的优缺点\n\n### 优点\n\n1. **可解释性强**\n\n- 生成后的决策树可视化，人类易于理解和解释每个决策路径。\n\n1. **无须特征归一化**\n\n- 对数值型与类别型特征均可处理，不要求输入特征尺度统一。\n\n1. **自动特征选择**\n\n- 在划分过程中自动评估并选取对分类/回归最有价值的特征。\n\n1. **鲁棒性强**\n\n- 对缺失值可采用“分裂时加权”或“按多数类分配”等策略进行处理；对异常值不敏感。\n\n1. **易于处理多种类型数据**\n\n- 可以同时处理数值、类别以及缺失值。\n\n### 缺点\n\n1. **容易过拟合**\n\n- 深度过大时对训练数据拟合过度，泛化能力下降。\n\n1. **对噪声敏感**\n\n- 训练数据中的噪声决定划分时可能误导特征选择。\n\n1. **局部最优**\n\n- 由于采用贪心策略（每次只选最优特征），可能无法得到全局最优树。\n\n1. **可用性限制**\n\n- 对高维稀疏数据（如文本）可能效果不佳；容易生成非常深且稀疏的树。\n\n1. **不稳定性**\n\n- 微小的数据变化可能导致决策树结构的大幅改变（当某些样本临界时）。\n\n> **改进思路**：\n>\n> - **集成方法**：随机森林 (Random Forest)、梯度提升树 (Gradient Boosting Trees，如 XGBoost、LightGBM) 通过集成多棵弱树克服单棵树的易过拟合与不稳定问题。\n> - **特征筛选与降维**：在高维稀疏场景下，可结合特征工程、特征选择等方法减小特征维度。\n\n---\n\n## 决策树在实际中的应用场景\n\n### 相关代码示例\n\n> 由于还包含了 c45,cart,id3 为划分指标的决策树代码,我整理在了一个 github 仓库中,下面只展示了 decision_stump.py 的代码\n> [https://github.com/tkzzzzzz6/MLandDL](https://github.com/tkzzzzzz6/MLandDL)\n\n#### decision_stump.py(主要模块)\n\n```python\nimport numpy as np\n\nclass DecisionStump():\n    def __update_parameter(self, h, feature_index, threshold, direction, err_value):\n        self.**__min_err_value** = err_value\n        self.**__feature_index** = feature_index\n        self.**__threshold** = threshold\n        self.**__direction** = direction\n\n    def __select_direction(self, feature_index, threshold, X, y, w):\n        for direction in ['greater', 'less']:\n            h = np.ones_like(y)\n\n            if direction == 'greater':\n                h[np.flatnonzero(X[:, feature_index] < threshold)] = -1\n            else:\n                h[np.flatnonzero(X[:, feature_index] >= threshold)] = -1\n\n            err_value = np.sum(w[np.flatnonzero(h != y)])\n            if err_value < self.**__min_err_value**:\n                self.__update_parameter(h, feature_index, threshold, 'greater', err_value)\n\n    def __select_threshold(self, feature_index, X, y, w):\n        n_samples = X.shape[0]\n\n        for i in range(n_samples):\n            self.__select_direction(feature_index, X[i, feature_index], X, y, w)\n\n    def __select_feature(self, X, y, w):\n        n_features = X.shape[1]\n\n        for i in range(n_features):\n            self.__select_threshold(i, X, y, w)\n\n    def fit(self, X, y, w):\n        self.**__feature_index** = None\n        self.**__threshold** = None\n        self.**__direction** = None\n        self.**__min_err_value** = np.**inf**\n\n        self.__select_feature(X, y, w)\n\n    def predict(self, X):\n        n_samples = X.shape[0]\n\n        y_pred = np.ones(n_samples)\n        if self.**__direction** == 'greater':\n            y_pred[np.flatnonzero(X[:, self.**__feature_index**] < self.**__threshold**)] = -1\n        else:\n            y_pred[np.flatnonzero(X[:, self.**__feature_index**] >= self.**__threshold**)] = -1\n\n        return y_pred\n```\n\n#### 运行结果\n\n![1749360718079T62Tbr1DOojvcLxBIxqcFCvHnlg.png](https://gitee.com/tanke11223344/imagehost/raw/main/blog/1749360718079T62Tbr1DOojvcLxBIxqcFCvHnlg.png)\n\n![1749360730852Tfdmbz1oOo6vFpxAAfkcoEBGnXc.png](https://gitee.com/tanke11223344/imagehost/raw/main/blog/1749360730852Tfdmbz1oOo6vFpxAAfkcoEBGnXc.png)\n![1749360750853Zeg3bB0PioEDr0x9taMclxgOnmh.png](https://gitee.com/tanke11223344/imagehost/raw/main/blog/1749360750853Zeg3bB0PioEDr0x9taMclxgOnmh.png)\n\n### 分类任务\n\n1. **客户流失预测 (Customer Churn Prediction)**\n\n- 业务场景：电信、金融、电商等行业中，通过客户基本属性、历史行为、消费习惯等特征预测是否会流失。\n- 决策树优势：易于解释（可解释哪些因素导致客户流失），可处理混合型特征（年龄、性别、套餐类别、使用时长等）。\n\n1. **信用评估 (Credit Scoring)**\n\n- 业务场景：银行或金融机构根据用户的个人信息（年龄、工作、收入）、信用记录（逾期次数、还款能力）进行信用风险分类（高风险、中风险、低风险）。\n- 应用：决策树可直观地给出“如果收入 < X 且逾期次数 > Y，则分类为高风险”，帮助信贷风控。\n\n1. **医疗诊断**\n\n- 业务场景：根据患者的症状（发热、咳嗽、X 光结果）、检查指标（血常规、心电图）等预测是否患某种疾病。\n- 应用：决策树模型可以给出“若咳嗽持续 > 2 周 且 白细胞数 > 某阈值，则可能为肺炎”，同时提供可解释的诊断决策流程。\n\n1. **垃圾邮件识别**\n\n- 业务场景：根据邮件内容特征（关键字出现次数、发送人是否在白名单）、邮件长度、附件类型等判断是否为垃圾邮件。\n- 应用：决策树可快速处理离散/连续特征，常用于构建初期的规则或与其他模型结合（如 Random Forest）。\n\n### 回归任务\n\n1. **房价预测 (House Price Prediction)**\n\n- 业务场景：根据房屋面积、楼层、房龄、地理位置、交通等因素预测房价。\n- 决策树回归：将房屋特征空间划分为若干区域，每个叶节点输出区域内样本的平均房价。做不到很平滑，但易于理解。\n\n1. **销售额预测**\n\n- 业务场景：预测节假日、促销活动或天气变化对某商品销售额的影响。\n- 决策树回归能够捕获非线性关系，且不需要对特征进行大量预处理。\n\n### 特征工程与规则提取\n\n1. **特征构造**\n\n- 通过决策树可以将某些连续特征自动离散化。例如，若决策树对“年龄”做了三次切分，分别在 25 岁、40 岁产生不同的分支，则可得到“年龄段”特征。\n\n1. **规则提取**\n\n- 从训练好的决策树中可直接提取“如果……则……”的规则，用于可解释性要求高的场景（如审计、医疗）。\n\n### 集成学习基础\n\n1. **随机森林 (Random Forest)**\n\n- 由多棵决策树随机组合而成。每棵树训练时只使用特征子集和样本子集，最后多数投票决定分类结果或平均值决定回归值。\n- 优势：降低单棵决策树的过拟合风险，提高泛化能力。\n\n1. **梯度提升树 (Gradient Boosting Trees)**\n\n- 通过逐步拟合残差的方式构建多个弱决策树，每棵新树在前一棵树的基础上拟合残差，最终组合得到强模型，如 XGBoost、LightGBM、CatBoost。\n\n---\n\n## 总结\n\n1. **决策树** 是一种简单、易理解且可处理混合型特征的模型，既可做分类，也可做回归。\n2. **核心步骤**：选择合适的划分指标（信息增益 / 信息增益率 / 基尼不纯度）、确定最佳划分点，递归生成树，并通过剪枝降低过拟合。\n3. **常见算法**：\n\n- **ID3**（仅支持离散特征，使用信息增益）\n- **C4.5**（支持数值特征 & 离散特征，使用信息增益率，含剪枝）\n- **CART**（构建二叉树，使用基尼不纯度，可用于分类与回归）\n\n1. **优缺点**：\n\n- 优点：可解释性强、无需特征缩放、自动进行特征选择。\n- 缺点：容易过拟合、对噪声敏感、在高维稀疏场景下不够稳定。\n\n1. **典型应用**：\n\n- 客户流失预测、信用评估、医疗诊断、垃圾邮件识别等分类场景；\n- 房价预测、销售额预测等回归场景；\n- 特征工程、规则提取、以及集成学习（随机森林、梯度提升树）的基石。\n","slug":"2025-05-01-决策树算法及应用","published":1,"updated":"2025-09-26T12:17:13.227Z","_id":"cmg0saj48001qjm8n574acpl7","comments":1,"layout":"post","photos":[],"content":"<h1 id=\"决策树算法及应用\"><a href=\"#决策树算法及应用\" class=\"headerlink\" title=\"决策树算法及应用\"></a>决策树算法及应用</h1><h1 id=\"参考资料\"><a href=\"#参考资料\" class=\"headerlink\" title=\"参考资料\"></a>参考资料</h1><blockquote>\n<ul>\n<li><a href=\"https://github.com/zhaoyichanghong/machine_learing_algo_python\">GitHub - zhaoyichanghong&#x2F;machine_learing_algo_python: implement the machine learning algorithms by p</a>(机器学习相关的 github 仓库)</li>\n<li><a href=\"https://aibydoing.com/notebooks/chapter02-10-lab-decision-tree-implementation-and-applications\">决策树实现与应用</a></li>\n<li><a href=\"https://zh.wikipedia.org/zh-cn/%E5%86%B3%E7%AD%96%E6%A0%91\">决策树</a></li>\n</ul>\n</blockquote>\n<h1 id=\"概述\"><a href=\"#概述\" class=\"headerlink\" title=\"概述\"></a>概述</h1><h2 id=\"机器学习算法分类\"><a href=\"#机器学习算法分类\" class=\"headerlink\" title=\"机器学习算法分类\"></a>机器学习算法分类</h2><h2 id=\"决策树算法\"><a href=\"#决策树算法\" class=\"headerlink\" title=\"决策树算法\"></a>决策树算法</h2><p>决策树是一种以树状结构对数据进行划分的分类（Classification）或回归（Regression）模型。其核心思想是：</p>\n<blockquote>\n<p>通过“自上而下”的方式，根据某一特征对样本进行二叉或多叉划分，直至满足停止条件（如纯度高、样本数小于阈值等），构造一棵可解释性高的树形模型。在叶节点输出类别（分类树）或数值（回归树）。</p>\n</blockquote>\n<p>决策树具有以下特点：</p>\n<ul>\n<li><strong>易于理解与可视化</strong>：生成后以树状图呈现，人类可直观理解每个分类&#x2F;回归决策过程。</li>\n<li><strong>无需大量数据预处理</strong>：对数值型与类别型特征均可处理，无需像线性模型那样对特征做严格的标准化、归一化。</li>\n<li><strong>自动进行特征选择</strong>：在划分过程中会自动选出最能区分正负样本或最能减少误差的特征。</li>\n</ul>\n<p>从数据产生决策树的机器学习技术叫做<strong>决策树学习</strong>，通俗说就是<strong>决策树</strong>。</p>\n<p>一个决策树包含三种类型的节点：</p>\n<ol>\n<li>决策节点：通常用矩形框来表示</li>\n<li>机会节点：通常用圆圈来表示</li>\n<li>终结点：通常用三角形来表示</li>\n</ol>\n<p><img src=\"https://gitee.com/tanke11223344/imagehost/raw/main/blog/1749360696852J52gbg16toig4zxF2PwcXPMynee.png\" alt=\"1749360696852J52gbg16toig4zxF2PwcXPMynee.png\"></p>\n<p>决策树是一种特殊的树形结构，一般由节点和有向边组成。其中，节点表示特征、属性或者一个类，而有向边包含判断条件。决策树从根节点开始延伸，经过不同的判断条件后，到达不同的子节点。而上层子节点又可以作为父节点被进一步划分为下层子节点。一般情况下，我们从根节点输入数据，经过多次判断后，这些数据就会被分为不同的类别。这就构成了一颗简单的分类决策树。</p>\n<p><img src=\"https://gitee.com/tanke11223344/imagehost/raw/main/blog/1749360705910DCD5b5sUbootQ5xUESpcmfBRnDy.png\" alt=\"1749360705910DCD5b5sUbootQ5xUESpcmfBRnDy.png\"></p>\n<h3 id=\"算法原理\"><a href=\"#算法原理\" class=\"headerlink\" title=\"算法原理\"></a>算法原理</h3><p>其实决策树算法如同上面场景一样，其思想非常容易理解，具体的算法流程为：</p>\n<ol>\n<li>数据准备 → 通过数据清洗和数据处理，将数据整理为没有缺省值的向量。</li>\n<li>寻找最佳特征 → 遍历每个特征的每一种划分方式，找到最好的划分特征。</li>\n<li>生成分支 → 划分成两个或多个节点。</li>\n<li>生成决策树 → 对分裂后的节点分别继续执行 2-3 步，直到每个节点只有一种类别。</li>\n<li>决策分类 → 根据训练决策树模型，将预测数据进行分类。</li>\n</ol>\n<h2 id=\"决策树的基本概念\"><a href=\"#决策树的基本概念\" class=\"headerlink\" title=\"决策树的基本概念\"></a>决策树的基本概念</h2><h3 id=\"结点类型\"><a href=\"#结点类型\" class=\"headerlink\" title=\"结点类型\"></a>结点类型</h3><ol>\n<li><strong>根节点 (Root Node)</strong></li>\n</ol>\n<ul>\n<li>树的起始节点，包含了整个训练集。</li>\n</ul>\n<ol>\n<li><strong>内部节点 (Internal Node)</strong></li>\n</ol>\n<ul>\n<li>又称决策节点（Decision Node），表示一个根据某个特征进行划分的测试。</li>\n</ul>\n<ol>\n<li><strong>叶节点 (Leaf &#x2F; Terminal Node)</strong></li>\n</ol>\n<ul>\n<li>表示最终的类别（分类树）或数值（回归树）。</li>\n</ul>\n<ol>\n<li><strong>分支 (Branch &#x2F; Edge)</strong></li>\n</ol>\n<ul>\n<li>从父节点到子节点的连线，通常对应该节点特征的某个取值或取值范围。</li>\n</ul>\n<h3 id=\"树结构与术语\"><a href=\"#树结构与术语\" class=\"headerlink\" title=\"树结构与术语\"></a>树结构与术语</h3><ul>\n<li>**路径 (Path)**：从根节点到某个叶节点所经过的结点序列，即一个完整的决策逻辑分支。</li>\n<li>**深度 (Depth)**：根节点的深度定义为 0，子节点依次递增。树的最大深度称为 高度 (Height)。</li>\n<li>**样本纯度 (Purity)**：指一个节点中样本类别的一致性。</li>\n<li>比如在分类问题中，若节点仅包含同一类别样本，则称该节点纯度为 1（纯节点）。</li>\n<li>**叶子样本数 (Leaf Sample Count)**：用于限制过拟合，可设定：当某节点样本数不足阈值时，停止划分，将其设为叶节点。</li>\n<li><strong>划分停止条件</strong>：</li>\n</ul>\n<ol>\n<li>所有样本属于同一类别（分类树），或样本方差足够小（回归树）。</li>\n<li>树达到最大深度。</li>\n<li>节点中样本数量小于某个阈值。</li>\n<li>划分后信息增益或基尼系数提升不足阈值。</li>\n</ol>\n<hr>\n<h2 id=\"决策树构建的核心要素\"><a href=\"#决策树构建的核心要素\" class=\"headerlink\" title=\"决策树构建的核心要素\"></a>决策树构建的核心要素</h2><h3 id=\"划分指标\"><a href=\"#划分指标\" class=\"headerlink\" title=\"划分指标\"></a>划分指标</h3><p>决策树的关键在于如何选择最优划分特征与划分点。常见的三种指标为信息增益、信息增益率和基尼不纯度。</p>\n<h4 id=\"信息增益-Information-Gain-——ID3\"><a href=\"#信息增益-Information-Gain-——ID3\" class=\"headerlink\" title=\"信息增益 (Information Gain) ——ID3\"></a>信息增益 (Information Gain) ——ID3</h4><p>设当前节点样本集为 $D$，共有 $K$ 个类别 ${C_1, C_2, \\dots, C_K}$。定义：</p>\n<ul>\n<li>节点 $D$ 信息熵：</li>\n</ul>\n<p>$$<br>H(D) &#x3D; -\\sum_{k&#x3D;1}^K p_k \\log_2 p_k,\\quad p_k &#x3D; \\frac{|D_k|}{|D|}<br>$$</p>\n<p>其中 $|D_k|$ 是类别 $C_k$ 在 $D$ 中的样本数。</p>\n<ul>\n<li>若使用特征 $A$ 进行划分，且 $A$ 共有 $v$ 个互斥取值 ${a_1,\\dots,a_v}$，则在 $A&#x3D;a_i$ 处的子集记为 $D_i$。</li>\n</ul>\n<p>划分后加权平均的信息熵：</p>\n<p>$$<br>H(D \\mid A) &#x3D; \\sum_{i&#x3D;1}^v \\frac{|D_i|}{|D|} H(D_i)<br>$$</p>\n<ul>\n<li><strong>信息增益</strong>：即划分前后熵的减少量：</li>\n</ul>\n<p>$$<br>\\text{Gain}(A) &#x3D; H(D) - H(D \\mid A)<br>$$</p>\n<p><strong>ID3 算法</strong>选择信息增益最大的特征进行划分——即令：</p>\n<p>$$<br>A^* &#x3D; \\arg\\max_{A} \\text{Gain}(A)<br>$$</p>\n<blockquote>\n<p><strong>缺点</strong>：信息增益偏向取值多的特征（类别型变量有大量不同取值时容易过拟合）。</p>\n</blockquote>\n<h4 id=\"信息增益率-Gain-Ratio-——C4-5\"><a href=\"#信息增益率-Gain-Ratio-——C4-5\" class=\"headerlink\" title=\"信息增益率 (Gain Ratio) ——C4.5\"></a>信息增益率 (Gain Ratio) ——C4.5</h4><p>为克服 ID3 的偏向性，C4.5 引入分裂信息（Split Information）来对信息增益进行归一化：</p>\n<ol>\n<li><strong>分裂信息</strong>（或称固有信息）：</li>\n</ol>\n<p>$$<br>\\text{SplitInfo}(A) &#x3D; -\\sum_{i&#x3D;1}^v \\frac{|D_i|}{|D|} \\log_2 \\frac{|D_i|}{|D|}<br>$$</p>\n<ol>\n<li><strong>信息增益率</strong>：</li>\n</ol>\n<p>$$<br>\\text{GainRatio}(A) &#x3D; \\frac{\\text{Gain}(A)}{\\text{SplitInfo}(A) + \\epsilon}<br>$$</p>\n<p>通常选择信息增益率最高的特征进行划分。</p>\n<blockquote>\n<p>C4.5 同时支持对连续性（数值型）特征的二元划分：先对候选切分点进行排序，再遍历所有相邻两值中点，选取使增益率最大的切分点。</p>\n</blockquote>\n<h4 id=\"基尼不纯度-Gini-Impurity-——CART\"><a href=\"#基尼不纯度-Gini-Impurity-——CART\" class=\"headerlink\" title=\"基尼不纯度 (Gini Impurity) ——CART\"></a>基尼不纯度 (Gini Impurity) ——CART</h4><p>CART（Classification And Regression Tree）算法采用基尼不纯度作为划分依据。对于节点 $$D$$，基尼不纯度定义为：</p>\n<p>$$<br>\\mathrm{Gini}(D) &#x3D; 1 - \\sum_{k&#x3D;1}^K p_k^2, \\quad p_k &#x3D; \\frac{|D_k|}{|D|}<br>$$</p>\n<ul>\n<li>若使用特征 $A$ 将 $D$ 划分为两个子集（CART 传统上构建二叉树），设划分后两部分分别为 $D_\\text{left}, D_\\text{right}$，则划分后的基尼系数为加权平均：</li>\n</ul>\n<p>$$<br>\\mathrm{Gini}(D, A, s) &#x3D; \\frac{|D_\\text{left}|}{|D|}\\mathrm{Gini}(D_\\text{left}) + \\frac{|D_\\text{right}|}{|D|}\\mathrm{Gini}(D_\\text{right})<br>$$</p>\n<ul>\n<li>**基尼增益 (Gini Gain)**（或称基尼减少量）:</li>\n</ul>\n<p>$$<br>\\Delta \\mathrm{Gini}(A, s) &#x3D; \\mathrm{Gini}(D) - \\mathrm{Gini}(D, A, s)<br>$$</p>\n<p>CART 选择使基尼不纯度下降最多（即 $\\Delta \\mathrm{Gini}$ 最大）的特征和切分点。</p>\n<blockquote>\n<p><strong>CART 区别</strong>：</p>\n<ul>\n<li>使用基尼而非熵；</li>\n<li>通常只考虑二元（yes&#x2F;no）划分，即每个节点形成左右两个子节点。</li>\n<li>对数值型特征遍历所有可能切分点；对类别型特征可先将类别编码为虚拟变量 (One-Hot) 或按某种顺序处理。</li>\n</ul>\n</blockquote>\n<hr>\n<h3 id=\"特征选择与最佳划分\"><a href=\"#特征选择与最佳划分\" class=\"headerlink\" title=\"特征选择与最佳划分\"></a>特征选择与最佳划分</h3><ol>\n<li><strong>离散(类别)特征</strong></li>\n</ol>\n<ul>\n<li>ID3&#x2F;C4.5 直接按每个取值划分；CART 需要将 $m$ 个类别先切分为两组（所有可能子集划分），计算基尼并选择最优。</li>\n</ul>\n<ol>\n<li><strong>连续（数值）特征</strong></li>\n</ol>\n<ul>\n<li>首先对该特征在当前节点的所有样本的取值排序：$x_{(1)} \\le x_{(2)} \\le \\dots \\le x_{(n)}$。</li>\n<li>对每个相邻取值对 ${x_{(i)}, x_{(i+1)}}$，将其中点 $s &#x3D; \\tfrac{x_{(i)}+x_{(i+1)}}{2}$ 作为候选切分点。</li>\n<li>分别计算按 $A \\le s$ 与 $A &gt; s$ 两部分划分后的信息增益（或基尼减少量），选择最优 $s^*$。</li>\n</ul>\n<ol>\n<li><strong>递归构建</strong></li>\n</ol>\n<ul>\n<li>从根节点开始，对当前节点所有候选特征（及可能的切分点）分别计算划分指标；</li>\n<li>选出指标最优的特征&#x2F;切分点，将样本划分到子节点；</li>\n<li>对每个子节点递归执行，同样进行“特征选择 → 划分 → 递归”，直到满足停止条件。</li>\n</ul>\n<hr>\n<h2 id=\"常见决策树算法变体\"><a href=\"#常见决策树算法变体\" class=\"headerlink\" title=\"常见决策树算法变体\"></a>常见决策树算法变体</h2><h3 id=\"ID3-（Quinlan，1986）\"><a href=\"#ID3-（Quinlan，1986）\" class=\"headerlink\" title=\"ID3 （Quinlan，1986）\"></a>ID3 （Quinlan，1986）</h3><ul>\n<li><strong>核心思想</strong>：</li>\n<li>使用信息增益作为划分标准；</li>\n<li>仅适用于离散（类别）特征；</li>\n<li>构建多叉树（一个节点可以有多条分支，对应特征的所有取值）。</li>\n<li><strong>简易流程</strong>：</li>\n</ul>\n<ol>\n<li><p>计算当前节点样本集信息熵 $H(D)$。</p>\n</li>\n<li><p>对每个候选特征 $A$，计算信息增益 $\\text{Gain}(A)$。</p>\n</li>\n<li><p>选取信息增益最大的特征 $A^*$，对该节点进行划分。</p>\n</li>\n<li><p>递归地对每个子节点执行上述步骤。</p>\n</li>\n<li><p>递归终止条件：</p>\n<ul>\n<li>节点样本全属于同一类别（纯度 1）。</li>\n<li>特征集为空（多数投票决定叶节点类别）。</li>\n<li>节点样本数小于阈值。</li>\n</ul>\n</li>\n</ol>\n<h3 id=\"C4-5（Quinlan，1993）\"><a href=\"#C4-5（Quinlan，1993）\" class=\"headerlink\" title=\"C4.5（Quinlan，1993）\"></a>C4.5（Quinlan，1993）</h3><ul>\n<li><strong>改进点</strong>：</li>\n</ul>\n<ol>\n<li>支持数值型特征的自动二元划分。</li>\n<li>使用信息增益率（Gain Ratio）来选择特征，克服取值多特征的偏向问题。</li>\n<li>支持“有缺失值”处理：当样本缺失特征 $A$ 时，按已知特征在其他样本中的分布进行加权。</li>\n<li>剪枝：可基于统计检验进行后剪枝，减少过拟合。</li>\n</ol>\n<ul>\n<li><strong>流程</strong>：</li>\n</ul>\n<ol>\n<li>对所有特征计算信息增益率 $\\text{GainRatio}(A)$，选取最优特征 $A^*$；</li>\n<li>对于数值型特征，遍历所有候选切分点（相邻排序值中点），计算最佳增益率；</li>\n<li>按 $A^*$ 将节点划分；</li>\n<li>递归；</li>\n<li>在树构建完成后进行后剪枝（可选）。</li>\n</ol>\n<h3 id=\"CART-（Breiman-等，1984）\"><a href=\"#CART-（Breiman-等，1984）\" class=\"headerlink\" title=\"CART （Breiman 等，1984）\"></a>CART （Breiman 等，1984）</h3><ul>\n<li><strong>核心思想</strong>：</li>\n<li>使用基尼不纯度 (Gini) 作为划分标准；</li>\n<li>构建二叉树：每个节点仅有 “是&#x2F;否” 两个分支；</li>\n<li>同时支持分类树 (Classification Tree) 和回归树 (Regression Tree)。</li>\n<li><strong>分类树流程</strong>：</li>\n</ul>\n<ol>\n<li>计算当前节点的 $\\mathrm{Gini}(D)$。</li>\n<li>对每个候选特征及其所有可能二元切分点，计算基尼减少量 $\\Delta \\mathrm{Gini}(A, s)$。</li>\n<li>选择使 $\\Delta \\mathrm{Gini}$ 最大的特征与切分点 $(A^*, s^*)$。</li>\n<li>将节点划分为左右子节点；</li>\n<li>递归；</li>\n<li><strong>剪枝</strong>：可使用交叉验证来调节树的复杂度，通过最小化验证误差决定是否剪枝。</li>\n</ol>\n<ul>\n<li><strong>回归树流程</strong>：</li>\n<li>用 MSE（均方误差）或绝对误差作为节点不纯度度量：</li>\n</ul>\n<p>$$<br>\\mathrm{MSE}(D) &#x3D; \\frac{1}{|D|}\\sum_{i\\in D} (y_i - \\bar y)^2,\\quad \\bar y &#x3D; \\frac{1}{|D|}\\sum_{i\\in D} y_i<br>$$</p>\n<p>$$<br>\\mathrm{MSE}(D) &#x3D; \\frac{1}{|D|}\\sum_{i\\in D} (y_i - \\bar y)^2,\\quad \\bar y &#x3D; \\frac{1}{|D|}\\sum_{i\\in D} y_i<br>$$</p>\n<ul>\n<li>对数值型特征 $A$ 遍历二元切分点，分别计算左右子集的 MSE 加权平均。</li>\n<li>选取使 MSE 降低最多的切分。</li>\n<li>剪枝一般使用最小化验证集误差或对叶子节点惩罚复杂度（Cost-Complexity Pruning）。</li>\n</ul>\n<hr>\n<h2 id=\"剪枝-Pruning\"><a href=\"#剪枝-Pruning\" class=\"headerlink\" title=\"剪枝 (Pruning)\"></a>剪枝 (Pruning)</h2><p>在决策树中，过深的树容易过拟合训练数据，影响泛化。剪枝是为了提高模型在测试集上的准确性。主要有两种方式：</p>\n<h3 id=\"预剪枝-Pre-pruning\"><a href=\"#预剪枝-Pre-pruning\" class=\"headerlink\" title=\"预剪枝 (Pre-pruning)\"></a>预剪枝 (Pre-pruning)</h3><p>在构建树的过程中，提前停止划分，常见策略有：</p>\n<ol>\n<li><strong>最小样本数</strong>：若节点样本数小于某阈值，停止划分；</li>\n<li><strong>最大深度</strong>：树深度达到设定上限，停止；</li>\n<li><strong>信息增益&#x2F;基尼减少阈值</strong>：若最优划分的增益（或减少量）小于阈值，则不再划分；</li>\n<li><strong>统计检验</strong>：基于卡方检验等统计检验判定划分是否显著。</li>\n</ol>\n<blockquote>\n<p><strong>优点</strong>：减少计算和树的复杂度。<br><strong>缺点</strong>：一旦提前停止，可能错过后续有效划分，导致欠拟合。</p>\n</blockquote>\n<h3 id=\"后剪枝-Post-pruning\"><a href=\"#后剪枝-Post-pruning\" class=\"headerlink\" title=\"后剪枝 (Post-pruning)\"></a>后剪枝 (Post-pruning)</h3><p>先让树尽可能长地生长，然后自底向上裁剪。常见流程：</p>\n<ol>\n<li>构建完完全树（直到所有叶节点纯度为 1 或没有更多可划分特征）；</li>\n<li>对每个非叶子节点评估以下两种情况哪种在验证集上性能更好：</li>\n</ol>\n<ul>\n<li>保留该子树结构；</li>\n<li>将其剪为叶节点，并以子树所有样本在该节点的多数类（分类）或平均值（回归）作为输出；</li>\n</ul>\n<ol>\n<li>如果剪掉子树后验证误差减少或无显著变化，则保留剪枝操作；否则保留子树；</li>\n<li>重复上述过程，直到没有可剪枝节点或验证集误差不再降低。</li>\n</ol>\n<blockquote>\n<p><strong>CART 的 Cost-Complexity Pruning</strong>：定义节点惩罚函数</p>\n</blockquote>\n<hr>\n<h2 id=\"决策树的优缺点\"><a href=\"#决策树的优缺点\" class=\"headerlink\" title=\"决策树的优缺点\"></a>决策树的优缺点</h2><h3 id=\"优点\"><a href=\"#优点\" class=\"headerlink\" title=\"优点\"></a>优点</h3><ol>\n<li><strong>可解释性强</strong></li>\n</ol>\n<ul>\n<li>生成后的决策树可视化，人类易于理解和解释每个决策路径。</li>\n</ul>\n<ol>\n<li><strong>无须特征归一化</strong></li>\n</ol>\n<ul>\n<li>对数值型与类别型特征均可处理，不要求输入特征尺度统一。</li>\n</ul>\n<ol>\n<li><strong>自动特征选择</strong></li>\n</ol>\n<ul>\n<li>在划分过程中自动评估并选取对分类&#x2F;回归最有价值的特征。</li>\n</ul>\n<ol>\n<li><strong>鲁棒性强</strong></li>\n</ol>\n<ul>\n<li>对缺失值可采用“分裂时加权”或“按多数类分配”等策略进行处理；对异常值不敏感。</li>\n</ul>\n<ol>\n<li><strong>易于处理多种类型数据</strong></li>\n</ol>\n<ul>\n<li>可以同时处理数值、类别以及缺失值。</li>\n</ul>\n<h3 id=\"缺点\"><a href=\"#缺点\" class=\"headerlink\" title=\"缺点\"></a>缺点</h3><ol>\n<li><strong>容易过拟合</strong></li>\n</ol>\n<ul>\n<li>深度过大时对训练数据拟合过度，泛化能力下降。</li>\n</ul>\n<ol>\n<li><strong>对噪声敏感</strong></li>\n</ol>\n<ul>\n<li>训练数据中的噪声决定划分时可能误导特征选择。</li>\n</ul>\n<ol>\n<li><strong>局部最优</strong></li>\n</ol>\n<ul>\n<li>由于采用贪心策略（每次只选最优特征），可能无法得到全局最优树。</li>\n</ul>\n<ol>\n<li><strong>可用性限制</strong></li>\n</ol>\n<ul>\n<li>对高维稀疏数据（如文本）可能效果不佳；容易生成非常深且稀疏的树。</li>\n</ul>\n<ol>\n<li><strong>不稳定性</strong></li>\n</ol>\n<ul>\n<li>微小的数据变化可能导致决策树结构的大幅改变（当某些样本临界时）。</li>\n</ul>\n<blockquote>\n<p><strong>改进思路</strong>：</p>\n<ul>\n<li><strong>集成方法</strong>：随机森林 (Random Forest)、梯度提升树 (Gradient Boosting Trees，如 XGBoost、LightGBM) 通过集成多棵弱树克服单棵树的易过拟合与不稳定问题。</li>\n<li><strong>特征筛选与降维</strong>：在高维稀疏场景下，可结合特征工程、特征选择等方法减小特征维度。</li>\n</ul>\n</blockquote>\n<hr>\n<h2 id=\"决策树在实际中的应用场景\"><a href=\"#决策树在实际中的应用场景\" class=\"headerlink\" title=\"决策树在实际中的应用场景\"></a>决策树在实际中的应用场景</h2><h3 id=\"相关代码示例\"><a href=\"#相关代码示例\" class=\"headerlink\" title=\"相关代码示例\"></a>相关代码示例</h3><blockquote>\n<p>由于还包含了 c45,cart,id3 为划分指标的决策树代码,我整理在了一个 github 仓库中,下面只展示了 decision_stump.py 的代码<br><a href=\"https://github.com/tkzzzzzz6/MLandDL\">https://github.com/tkzzzzzz6/MLandDL</a></p>\n</blockquote>\n<h4 id=\"decision-stump-py-主要模块\"><a href=\"#decision-stump-py-主要模块\" class=\"headerlink\" title=\"decision_stump.py(主要模块)\"></a>decision_stump.py(主要模块)</h4><figure class=\"highlight python\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br><span class=\"line\">47</span><br><span class=\"line\">48</span><br><span class=\"line\">49</span><br><span class=\"line\">50</span><br><span class=\"line\">51</span><br><span class=\"line\">52</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">import</span> numpy <span class=\"keyword\">as</span> np</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">class</span> <span class=\"title class_\">DecisionStump</span>():</span><br><span class=\"line\">    <span class=\"keyword\">def</span> <span class=\"title function_\">__update_parameter</span>(<span class=\"params\">self, h, feature_index, threshold, direction, err_value</span>):</span><br><span class=\"line\">        <span class=\"variable language_\">self</span>.**__min_err_value** = err_value</span><br><span class=\"line\">        <span class=\"variable language_\">self</span>.**__feature_index** = feature_index</span><br><span class=\"line\">        <span class=\"variable language_\">self</span>.**__threshold** = threshold</span><br><span class=\"line\">        <span class=\"variable language_\">self</span>.**__direction** = direction</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">def</span> <span class=\"title function_\">__select_direction</span>(<span class=\"params\">self, feature_index, threshold, X, y, w</span>):</span><br><span class=\"line\">        <span class=\"keyword\">for</span> direction <span class=\"keyword\">in</span> [<span class=\"string\">&#x27;greater&#x27;</span>, <span class=\"string\">&#x27;less&#x27;</span>]:</span><br><span class=\"line\">            h = np.ones_like(y)</span><br><span class=\"line\"></span><br><span class=\"line\">            <span class=\"keyword\">if</span> direction == <span class=\"string\">&#x27;greater&#x27;</span>:</span><br><span class=\"line\">                h[np.flatnonzero(X[:, feature_index] &lt; threshold)] = -<span class=\"number\">1</span></span><br><span class=\"line\">            <span class=\"keyword\">else</span>:</span><br><span class=\"line\">                h[np.flatnonzero(X[:, feature_index] &gt;= threshold)] = -<span class=\"number\">1</span></span><br><span class=\"line\"></span><br><span class=\"line\">            err_value = np.<span class=\"built_in\">sum</span>(w[np.flatnonzero(h != y)])</span><br><span class=\"line\">            <span class=\"keyword\">if</span> err_value &lt; <span class=\"variable language_\">self</span>.**__min_err_value**:</span><br><span class=\"line\">                <span class=\"variable language_\">self</span>.__update_parameter(h, feature_index, threshold, <span class=\"string\">&#x27;greater&#x27;</span>, err_value)</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">def</span> <span class=\"title function_\">__select_threshold</span>(<span class=\"params\">self, feature_index, X, y, w</span>):</span><br><span class=\"line\">        n_samples = X.shape[<span class=\"number\">0</span>]</span><br><span class=\"line\"></span><br><span class=\"line\">        <span class=\"keyword\">for</span> i <span class=\"keyword\">in</span> <span class=\"built_in\">range</span>(n_samples):</span><br><span class=\"line\">            <span class=\"variable language_\">self</span>.__select_direction(feature_index, X[i, feature_index], X, y, w)</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">def</span> <span class=\"title function_\">__select_feature</span>(<span class=\"params\">self, X, y, w</span>):</span><br><span class=\"line\">        n_features = X.shape[<span class=\"number\">1</span>]</span><br><span class=\"line\"></span><br><span class=\"line\">        <span class=\"keyword\">for</span> i <span class=\"keyword\">in</span> <span class=\"built_in\">range</span>(n_features):</span><br><span class=\"line\">            <span class=\"variable language_\">self</span>.__select_threshold(i, X, y, w)</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">def</span> <span class=\"title function_\">fit</span>(<span class=\"params\">self, X, y, w</span>):</span><br><span class=\"line\">        <span class=\"variable language_\">self</span>.**__feature_index** = <span class=\"literal\">None</span></span><br><span class=\"line\">        <span class=\"variable language_\">self</span>.**__threshold** = <span class=\"literal\">None</span></span><br><span class=\"line\">        <span class=\"variable language_\">self</span>.**__direction** = <span class=\"literal\">None</span></span><br><span class=\"line\">        <span class=\"variable language_\">self</span>.**__min_err_value** = np.**inf**</span><br><span class=\"line\"></span><br><span class=\"line\">        <span class=\"variable language_\">self</span>.__select_feature(X, y, w)</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">def</span> <span class=\"title function_\">predict</span>(<span class=\"params\">self, X</span>):</span><br><span class=\"line\">        n_samples = X.shape[<span class=\"number\">0</span>]</span><br><span class=\"line\"></span><br><span class=\"line\">        y_pred = np.ones(n_samples)</span><br><span class=\"line\">        <span class=\"keyword\">if</span> <span class=\"variable language_\">self</span>.**__direction** == <span class=\"string\">&#x27;greater&#x27;</span>:</span><br><span class=\"line\">            y_pred[np.flatnonzero(X[:, <span class=\"variable language_\">self</span>.**__feature_index**] &lt; <span class=\"variable language_\">self</span>.**__threshold**)] = -<span class=\"number\">1</span></span><br><span class=\"line\">        <span class=\"keyword\">else</span>:</span><br><span class=\"line\">            y_pred[np.flatnonzero(X[:, <span class=\"variable language_\">self</span>.**__feature_index**] &gt;= <span class=\"variable language_\">self</span>.**__threshold**)] = -<span class=\"number\">1</span></span><br><span class=\"line\"></span><br><span class=\"line\">        <span class=\"keyword\">return</span> y_pred</span><br></pre></td></tr></table></figure>\n\n<h4 id=\"运行结果\"><a href=\"#运行结果\" class=\"headerlink\" title=\"运行结果\"></a>运行结果</h4><p><img src=\"https://gitee.com/tanke11223344/imagehost/raw/main/blog/1749360718079T62Tbr1DOojvcLxBIxqcFCvHnlg.png\" alt=\"1749360718079T62Tbr1DOojvcLxBIxqcFCvHnlg.png\"></p>\n<p><img src=\"https://gitee.com/tanke11223344/imagehost/raw/main/blog/1749360730852Tfdmbz1oOo6vFpxAAfkcoEBGnXc.png\" alt=\"1749360730852Tfdmbz1oOo6vFpxAAfkcoEBGnXc.png\"><br><img src=\"https://gitee.com/tanke11223344/imagehost/raw/main/blog/1749360750853Zeg3bB0PioEDr0x9taMclxgOnmh.png\" alt=\"1749360750853Zeg3bB0PioEDr0x9taMclxgOnmh.png\"></p>\n<h3 id=\"分类任务\"><a href=\"#分类任务\" class=\"headerlink\" title=\"分类任务\"></a>分类任务</h3><ol>\n<li><strong>客户流失预测 (Customer Churn Prediction)</strong></li>\n</ol>\n<ul>\n<li>业务场景：电信、金融、电商等行业中，通过客户基本属性、历史行为、消费习惯等特征预测是否会流失。</li>\n<li>决策树优势：易于解释（可解释哪些因素导致客户流失），可处理混合型特征（年龄、性别、套餐类别、使用时长等）。</li>\n</ul>\n<ol>\n<li><strong>信用评估 (Credit Scoring)</strong></li>\n</ol>\n<ul>\n<li>业务场景：银行或金融机构根据用户的个人信息（年龄、工作、收入）、信用记录（逾期次数、还款能力）进行信用风险分类（高风险、中风险、低风险）。</li>\n<li>应用：决策树可直观地给出“如果收入 &lt; X 且逾期次数 &gt; Y，则分类为高风险”，帮助信贷风控。</li>\n</ul>\n<ol>\n<li><strong>医疗诊断</strong></li>\n</ol>\n<ul>\n<li>业务场景：根据患者的症状（发热、咳嗽、X 光结果）、检查指标（血常规、心电图）等预测是否患某种疾病。</li>\n<li>应用：决策树模型可以给出“若咳嗽持续 &gt; 2 周 且 白细胞数 &gt; 某阈值，则可能为肺炎”，同时提供可解释的诊断决策流程。</li>\n</ul>\n<ol>\n<li><strong>垃圾邮件识别</strong></li>\n</ol>\n<ul>\n<li>业务场景：根据邮件内容特征（关键字出现次数、发送人是否在白名单）、邮件长度、附件类型等判断是否为垃圾邮件。</li>\n<li>应用：决策树可快速处理离散&#x2F;连续特征，常用于构建初期的规则或与其他模型结合（如 Random Forest）。</li>\n</ul>\n<h3 id=\"回归任务\"><a href=\"#回归任务\" class=\"headerlink\" title=\"回归任务\"></a>回归任务</h3><ol>\n<li><strong>房价预测 (House Price Prediction)</strong></li>\n</ol>\n<ul>\n<li>业务场景：根据房屋面积、楼层、房龄、地理位置、交通等因素预测房价。</li>\n<li>决策树回归：将房屋特征空间划分为若干区域，每个叶节点输出区域内样本的平均房价。做不到很平滑，但易于理解。</li>\n</ul>\n<ol>\n<li><strong>销售额预测</strong></li>\n</ol>\n<ul>\n<li>业务场景：预测节假日、促销活动或天气变化对某商品销售额的影响。</li>\n<li>决策树回归能够捕获非线性关系，且不需要对特征进行大量预处理。</li>\n</ul>\n<h3 id=\"特征工程与规则提取\"><a href=\"#特征工程与规则提取\" class=\"headerlink\" title=\"特征工程与规则提取\"></a>特征工程与规则提取</h3><ol>\n<li><strong>特征构造</strong></li>\n</ol>\n<ul>\n<li>通过决策树可以将某些连续特征自动离散化。例如，若决策树对“年龄”做了三次切分，分别在 25 岁、40 岁产生不同的分支，则可得到“年龄段”特征。</li>\n</ul>\n<ol>\n<li><strong>规则提取</strong></li>\n</ol>\n<ul>\n<li>从训练好的决策树中可直接提取“如果……则……”的规则，用于可解释性要求高的场景（如审计、医疗）。</li>\n</ul>\n<h3 id=\"集成学习基础\"><a href=\"#集成学习基础\" class=\"headerlink\" title=\"集成学习基础\"></a>集成学习基础</h3><ol>\n<li><strong>随机森林 (Random Forest)</strong></li>\n</ol>\n<ul>\n<li>由多棵决策树随机组合而成。每棵树训练时只使用特征子集和样本子集，最后多数投票决定分类结果或平均值决定回归值。</li>\n<li>优势：降低单棵决策树的过拟合风险，提高泛化能力。</li>\n</ul>\n<ol>\n<li><strong>梯度提升树 (Gradient Boosting Trees)</strong></li>\n</ol>\n<ul>\n<li>通过逐步拟合残差的方式构建多个弱决策树，每棵新树在前一棵树的基础上拟合残差，最终组合得到强模型，如 XGBoost、LightGBM、CatBoost。</li>\n</ul>\n<hr>\n<h2 id=\"总结\"><a href=\"#总结\" class=\"headerlink\" title=\"总结\"></a>总结</h2><ol>\n<li><strong>决策树</strong> 是一种简单、易理解且可处理混合型特征的模型，既可做分类，也可做回归。</li>\n<li><strong>核心步骤</strong>：选择合适的划分指标（信息增益 &#x2F; 信息增益率 &#x2F; 基尼不纯度）、确定最佳划分点，递归生成树，并通过剪枝降低过拟合。</li>\n<li><strong>常见算法</strong>：</li>\n</ol>\n<ul>\n<li><strong>ID3</strong>（仅支持离散特征，使用信息增益）</li>\n<li><strong>C4.5</strong>（支持数值特征 &amp; 离散特征，使用信息增益率，含剪枝）</li>\n<li><strong>CART</strong>（构建二叉树，使用基尼不纯度，可用于分类与回归）</li>\n</ul>\n<ol>\n<li><strong>优缺点</strong>：</li>\n</ol>\n<ul>\n<li>优点：可解释性强、无需特征缩放、自动进行特征选择。</li>\n<li>缺点：容易过拟合、对噪声敏感、在高维稀疏场景下不够稳定。</li>\n</ul>\n<ol>\n<li><strong>典型应用</strong>：</li>\n</ol>\n<ul>\n<li>客户流失预测、信用评估、医疗诊断、垃圾邮件识别等分类场景；</li>\n<li>房价预测、销售额预测等回归场景；</li>\n<li>特征工程、规则提取、以及集成学习（随机森林、梯度提升树）的基石。</li>\n</ul>\n","excerpt":"","more":"<h1 id=\"决策树算法及应用\"><a href=\"#决策树算法及应用\" class=\"headerlink\" title=\"决策树算法及应用\"></a>决策树算法及应用</h1><h1 id=\"参考资料\"><a href=\"#参考资料\" class=\"headerlink\" title=\"参考资料\"></a>参考资料</h1><blockquote>\n<ul>\n<li><a href=\"https://github.com/zhaoyichanghong/machine_learing_algo_python\">GitHub - zhaoyichanghong&#x2F;machine_learing_algo_python: implement the machine learning algorithms by p</a>(机器学习相关的 github 仓库)</li>\n<li><a href=\"https://aibydoing.com/notebooks/chapter02-10-lab-decision-tree-implementation-and-applications\">决策树实现与应用</a></li>\n<li><a href=\"https://zh.wikipedia.org/zh-cn/%E5%86%B3%E7%AD%96%E6%A0%91\">决策树</a></li>\n</ul>\n</blockquote>\n<h1 id=\"概述\"><a href=\"#概述\" class=\"headerlink\" title=\"概述\"></a>概述</h1><h2 id=\"机器学习算法分类\"><a href=\"#机器学习算法分类\" class=\"headerlink\" title=\"机器学习算法分类\"></a>机器学习算法分类</h2><h2 id=\"决策树算法\"><a href=\"#决策树算法\" class=\"headerlink\" title=\"决策树算法\"></a>决策树算法</h2><p>决策树是一种以树状结构对数据进行划分的分类（Classification）或回归（Regression）模型。其核心思想是：</p>\n<blockquote>\n<p>通过“自上而下”的方式，根据某一特征对样本进行二叉或多叉划分，直至满足停止条件（如纯度高、样本数小于阈值等），构造一棵可解释性高的树形模型。在叶节点输出类别（分类树）或数值（回归树）。</p>\n</blockquote>\n<p>决策树具有以下特点：</p>\n<ul>\n<li><strong>易于理解与可视化</strong>：生成后以树状图呈现，人类可直观理解每个分类&#x2F;回归决策过程。</li>\n<li><strong>无需大量数据预处理</strong>：对数值型与类别型特征均可处理，无需像线性模型那样对特征做严格的标准化、归一化。</li>\n<li><strong>自动进行特征选择</strong>：在划分过程中会自动选出最能区分正负样本或最能减少误差的特征。</li>\n</ul>\n<p>从数据产生决策树的机器学习技术叫做<strong>决策树学习</strong>，通俗说就是<strong>决策树</strong>。</p>\n<p>一个决策树包含三种类型的节点：</p>\n<ol>\n<li>决策节点：通常用矩形框来表示</li>\n<li>机会节点：通常用圆圈来表示</li>\n<li>终结点：通常用三角形来表示</li>\n</ol>\n<p><img src=\"https://gitee.com/tanke11223344/imagehost/raw/main/blog/1749360696852J52gbg16toig4zxF2PwcXPMynee.png\" alt=\"1749360696852J52gbg16toig4zxF2PwcXPMynee.png\"></p>\n<p>决策树是一种特殊的树形结构，一般由节点和有向边组成。其中，节点表示特征、属性或者一个类，而有向边包含判断条件。决策树从根节点开始延伸，经过不同的判断条件后，到达不同的子节点。而上层子节点又可以作为父节点被进一步划分为下层子节点。一般情况下，我们从根节点输入数据，经过多次判断后，这些数据就会被分为不同的类别。这就构成了一颗简单的分类决策树。</p>\n<p><img src=\"https://gitee.com/tanke11223344/imagehost/raw/main/blog/1749360705910DCD5b5sUbootQ5xUESpcmfBRnDy.png\" alt=\"1749360705910DCD5b5sUbootQ5xUESpcmfBRnDy.png\"></p>\n<h3 id=\"算法原理\"><a href=\"#算法原理\" class=\"headerlink\" title=\"算法原理\"></a>算法原理</h3><p>其实决策树算法如同上面场景一样，其思想非常容易理解，具体的算法流程为：</p>\n<ol>\n<li>数据准备 → 通过数据清洗和数据处理，将数据整理为没有缺省值的向量。</li>\n<li>寻找最佳特征 → 遍历每个特征的每一种划分方式，找到最好的划分特征。</li>\n<li>生成分支 → 划分成两个或多个节点。</li>\n<li>生成决策树 → 对分裂后的节点分别继续执行 2-3 步，直到每个节点只有一种类别。</li>\n<li>决策分类 → 根据训练决策树模型，将预测数据进行分类。</li>\n</ol>\n<h2 id=\"决策树的基本概念\"><a href=\"#决策树的基本概念\" class=\"headerlink\" title=\"决策树的基本概念\"></a>决策树的基本概念</h2><h3 id=\"结点类型\"><a href=\"#结点类型\" class=\"headerlink\" title=\"结点类型\"></a>结点类型</h3><ol>\n<li><strong>根节点 (Root Node)</strong></li>\n</ol>\n<ul>\n<li>树的起始节点，包含了整个训练集。</li>\n</ul>\n<ol>\n<li><strong>内部节点 (Internal Node)</strong></li>\n</ol>\n<ul>\n<li>又称决策节点（Decision Node），表示一个根据某个特征进行划分的测试。</li>\n</ul>\n<ol>\n<li><strong>叶节点 (Leaf &#x2F; Terminal Node)</strong></li>\n</ol>\n<ul>\n<li>表示最终的类别（分类树）或数值（回归树）。</li>\n</ul>\n<ol>\n<li><strong>分支 (Branch &#x2F; Edge)</strong></li>\n</ol>\n<ul>\n<li>从父节点到子节点的连线，通常对应该节点特征的某个取值或取值范围。</li>\n</ul>\n<h3 id=\"树结构与术语\"><a href=\"#树结构与术语\" class=\"headerlink\" title=\"树结构与术语\"></a>树结构与术语</h3><ul>\n<li>**路径 (Path)**：从根节点到某个叶节点所经过的结点序列，即一个完整的决策逻辑分支。</li>\n<li>**深度 (Depth)**：根节点的深度定义为 0，子节点依次递增。树的最大深度称为 高度 (Height)。</li>\n<li>**样本纯度 (Purity)**：指一个节点中样本类别的一致性。</li>\n<li>比如在分类问题中，若节点仅包含同一类别样本，则称该节点纯度为 1（纯节点）。</li>\n<li>**叶子样本数 (Leaf Sample Count)**：用于限制过拟合，可设定：当某节点样本数不足阈值时，停止划分，将其设为叶节点。</li>\n<li><strong>划分停止条件</strong>：</li>\n</ul>\n<ol>\n<li>所有样本属于同一类别（分类树），或样本方差足够小（回归树）。</li>\n<li>树达到最大深度。</li>\n<li>节点中样本数量小于某个阈值。</li>\n<li>划分后信息增益或基尼系数提升不足阈值。</li>\n</ol>\n<hr>\n<h2 id=\"决策树构建的核心要素\"><a href=\"#决策树构建的核心要素\" class=\"headerlink\" title=\"决策树构建的核心要素\"></a>决策树构建的核心要素</h2><h3 id=\"划分指标\"><a href=\"#划分指标\" class=\"headerlink\" title=\"划分指标\"></a>划分指标</h3><p>决策树的关键在于如何选择最优划分特征与划分点。常见的三种指标为信息增益、信息增益率和基尼不纯度。</p>\n<h4 id=\"信息增益-Information-Gain-——ID3\"><a href=\"#信息增益-Information-Gain-——ID3\" class=\"headerlink\" title=\"信息增益 (Information Gain) ——ID3\"></a>信息增益 (Information Gain) ——ID3</h4><p>设当前节点样本集为 $D$，共有 $K$ 个类别 ${C_1, C_2, \\dots, C_K}$。定义：</p>\n<ul>\n<li>节点 $D$ 信息熵：</li>\n</ul>\n<p>$$<br>H(D) &#x3D; -\\sum_{k&#x3D;1}^K p_k \\log_2 p_k,\\quad p_k &#x3D; \\frac{|D_k|}{|D|}<br>$$</p>\n<p>其中 $|D_k|$ 是类别 $C_k$ 在 $D$ 中的样本数。</p>\n<ul>\n<li>若使用特征 $A$ 进行划分，且 $A$ 共有 $v$ 个互斥取值 ${a_1,\\dots,a_v}$，则在 $A&#x3D;a_i$ 处的子集记为 $D_i$。</li>\n</ul>\n<p>划分后加权平均的信息熵：</p>\n<p>$$<br>H(D \\mid A) &#x3D; \\sum_{i&#x3D;1}^v \\frac{|D_i|}{|D|} H(D_i)<br>$$</p>\n<ul>\n<li><strong>信息增益</strong>：即划分前后熵的减少量：</li>\n</ul>\n<p>$$<br>\\text{Gain}(A) &#x3D; H(D) - H(D \\mid A)<br>$$</p>\n<p><strong>ID3 算法</strong>选择信息增益最大的特征进行划分——即令：</p>\n<p>$$<br>A^* &#x3D; \\arg\\max_{A} \\text{Gain}(A)<br>$$</p>\n<blockquote>\n<p><strong>缺点</strong>：信息增益偏向取值多的特征（类别型变量有大量不同取值时容易过拟合）。</p>\n</blockquote>\n<h4 id=\"信息增益率-Gain-Ratio-——C4-5\"><a href=\"#信息增益率-Gain-Ratio-——C4-5\" class=\"headerlink\" title=\"信息增益率 (Gain Ratio) ——C4.5\"></a>信息增益率 (Gain Ratio) ——C4.5</h4><p>为克服 ID3 的偏向性，C4.5 引入分裂信息（Split Information）来对信息增益进行归一化：</p>\n<ol>\n<li><strong>分裂信息</strong>（或称固有信息）：</li>\n</ol>\n<p>$$<br>\\text{SplitInfo}(A) &#x3D; -\\sum_{i&#x3D;1}^v \\frac{|D_i|}{|D|} \\log_2 \\frac{|D_i|}{|D|}<br>$$</p>\n<ol>\n<li><strong>信息增益率</strong>：</li>\n</ol>\n<p>$$<br>\\text{GainRatio}(A) &#x3D; \\frac{\\text{Gain}(A)}{\\text{SplitInfo}(A) + \\epsilon}<br>$$</p>\n<p>通常选择信息增益率最高的特征进行划分。</p>\n<blockquote>\n<p>C4.5 同时支持对连续性（数值型）特征的二元划分：先对候选切分点进行排序，再遍历所有相邻两值中点，选取使增益率最大的切分点。</p>\n</blockquote>\n<h4 id=\"基尼不纯度-Gini-Impurity-——CART\"><a href=\"#基尼不纯度-Gini-Impurity-——CART\" class=\"headerlink\" title=\"基尼不纯度 (Gini Impurity) ——CART\"></a>基尼不纯度 (Gini Impurity) ——CART</h4><p>CART（Classification And Regression Tree）算法采用基尼不纯度作为划分依据。对于节点 $$D$$，基尼不纯度定义为：</p>\n<p>$$<br>\\mathrm{Gini}(D) &#x3D; 1 - \\sum_{k&#x3D;1}^K p_k^2, \\quad p_k &#x3D; \\frac{|D_k|}{|D|}<br>$$</p>\n<ul>\n<li>若使用特征 $A$ 将 $D$ 划分为两个子集（CART 传统上构建二叉树），设划分后两部分分别为 $D_\\text{left}, D_\\text{right}$，则划分后的基尼系数为加权平均：</li>\n</ul>\n<p>$$<br>\\mathrm{Gini}(D, A, s) &#x3D; \\frac{|D_\\text{left}|}{|D|}\\mathrm{Gini}(D_\\text{left}) + \\frac{|D_\\text{right}|}{|D|}\\mathrm{Gini}(D_\\text{right})<br>$$</p>\n<ul>\n<li>**基尼增益 (Gini Gain)**（或称基尼减少量）:</li>\n</ul>\n<p>$$<br>\\Delta \\mathrm{Gini}(A, s) &#x3D; \\mathrm{Gini}(D) - \\mathrm{Gini}(D, A, s)<br>$$</p>\n<p>CART 选择使基尼不纯度下降最多（即 $\\Delta \\mathrm{Gini}$ 最大）的特征和切分点。</p>\n<blockquote>\n<p><strong>CART 区别</strong>：</p>\n<ul>\n<li>使用基尼而非熵；</li>\n<li>通常只考虑二元（yes&#x2F;no）划分，即每个节点形成左右两个子节点。</li>\n<li>对数值型特征遍历所有可能切分点；对类别型特征可先将类别编码为虚拟变量 (One-Hot) 或按某种顺序处理。</li>\n</ul>\n</blockquote>\n<hr>\n<h3 id=\"特征选择与最佳划分\"><a href=\"#特征选择与最佳划分\" class=\"headerlink\" title=\"特征选择与最佳划分\"></a>特征选择与最佳划分</h3><ol>\n<li><strong>离散(类别)特征</strong></li>\n</ol>\n<ul>\n<li>ID3&#x2F;C4.5 直接按每个取值划分；CART 需要将 $m$ 个类别先切分为两组（所有可能子集划分），计算基尼并选择最优。</li>\n</ul>\n<ol>\n<li><strong>连续（数值）特征</strong></li>\n</ol>\n<ul>\n<li>首先对该特征在当前节点的所有样本的取值排序：$x_{(1)} \\le x_{(2)} \\le \\dots \\le x_{(n)}$。</li>\n<li>对每个相邻取值对 ${x_{(i)}, x_{(i+1)}}$，将其中点 $s &#x3D; \\tfrac{x_{(i)}+x_{(i+1)}}{2}$ 作为候选切分点。</li>\n<li>分别计算按 $A \\le s$ 与 $A &gt; s$ 两部分划分后的信息增益（或基尼减少量），选择最优 $s^*$。</li>\n</ul>\n<ol>\n<li><strong>递归构建</strong></li>\n</ol>\n<ul>\n<li>从根节点开始，对当前节点所有候选特征（及可能的切分点）分别计算划分指标；</li>\n<li>选出指标最优的特征&#x2F;切分点，将样本划分到子节点；</li>\n<li>对每个子节点递归执行，同样进行“特征选择 → 划分 → 递归”，直到满足停止条件。</li>\n</ul>\n<hr>\n<h2 id=\"常见决策树算法变体\"><a href=\"#常见决策树算法变体\" class=\"headerlink\" title=\"常见决策树算法变体\"></a>常见决策树算法变体</h2><h3 id=\"ID3-（Quinlan，1986）\"><a href=\"#ID3-（Quinlan，1986）\" class=\"headerlink\" title=\"ID3 （Quinlan，1986）\"></a>ID3 （Quinlan，1986）</h3><ul>\n<li><strong>核心思想</strong>：</li>\n<li>使用信息增益作为划分标准；</li>\n<li>仅适用于离散（类别）特征；</li>\n<li>构建多叉树（一个节点可以有多条分支，对应特征的所有取值）。</li>\n<li><strong>简易流程</strong>：</li>\n</ul>\n<ol>\n<li><p>计算当前节点样本集信息熵 $H(D)$。</p>\n</li>\n<li><p>对每个候选特征 $A$，计算信息增益 $\\text{Gain}(A)$。</p>\n</li>\n<li><p>选取信息增益最大的特征 $A^*$，对该节点进行划分。</p>\n</li>\n<li><p>递归地对每个子节点执行上述步骤。</p>\n</li>\n<li><p>递归终止条件：</p>\n<ul>\n<li>节点样本全属于同一类别（纯度 1）。</li>\n<li>特征集为空（多数投票决定叶节点类别）。</li>\n<li>节点样本数小于阈值。</li>\n</ul>\n</li>\n</ol>\n<h3 id=\"C4-5（Quinlan，1993）\"><a href=\"#C4-5（Quinlan，1993）\" class=\"headerlink\" title=\"C4.5（Quinlan，1993）\"></a>C4.5（Quinlan，1993）</h3><ul>\n<li><strong>改进点</strong>：</li>\n</ul>\n<ol>\n<li>支持数值型特征的自动二元划分。</li>\n<li>使用信息增益率（Gain Ratio）来选择特征，克服取值多特征的偏向问题。</li>\n<li>支持“有缺失值”处理：当样本缺失特征 $A$ 时，按已知特征在其他样本中的分布进行加权。</li>\n<li>剪枝：可基于统计检验进行后剪枝，减少过拟合。</li>\n</ol>\n<ul>\n<li><strong>流程</strong>：</li>\n</ul>\n<ol>\n<li>对所有特征计算信息增益率 $\\text{GainRatio}(A)$，选取最优特征 $A^*$；</li>\n<li>对于数值型特征，遍历所有候选切分点（相邻排序值中点），计算最佳增益率；</li>\n<li>按 $A^*$ 将节点划分；</li>\n<li>递归；</li>\n<li>在树构建完成后进行后剪枝（可选）。</li>\n</ol>\n<h3 id=\"CART-（Breiman-等，1984）\"><a href=\"#CART-（Breiman-等，1984）\" class=\"headerlink\" title=\"CART （Breiman 等，1984）\"></a>CART （Breiman 等，1984）</h3><ul>\n<li><strong>核心思想</strong>：</li>\n<li>使用基尼不纯度 (Gini) 作为划分标准；</li>\n<li>构建二叉树：每个节点仅有 “是&#x2F;否” 两个分支；</li>\n<li>同时支持分类树 (Classification Tree) 和回归树 (Regression Tree)。</li>\n<li><strong>分类树流程</strong>：</li>\n</ul>\n<ol>\n<li>计算当前节点的 $\\mathrm{Gini}(D)$。</li>\n<li>对每个候选特征及其所有可能二元切分点，计算基尼减少量 $\\Delta \\mathrm{Gini}(A, s)$。</li>\n<li>选择使 $\\Delta \\mathrm{Gini}$ 最大的特征与切分点 $(A^*, s^*)$。</li>\n<li>将节点划分为左右子节点；</li>\n<li>递归；</li>\n<li><strong>剪枝</strong>：可使用交叉验证来调节树的复杂度，通过最小化验证误差决定是否剪枝。</li>\n</ol>\n<ul>\n<li><strong>回归树流程</strong>：</li>\n<li>用 MSE（均方误差）或绝对误差作为节点不纯度度量：</li>\n</ul>\n<p>$$<br>\\mathrm{MSE}(D) &#x3D; \\frac{1}{|D|}\\sum_{i\\in D} (y_i - \\bar y)^2,\\quad \\bar y &#x3D; \\frac{1}{|D|}\\sum_{i\\in D} y_i<br>$$</p>\n<p>$$<br>\\mathrm{MSE}(D) &#x3D; \\frac{1}{|D|}\\sum_{i\\in D} (y_i - \\bar y)^2,\\quad \\bar y &#x3D; \\frac{1}{|D|}\\sum_{i\\in D} y_i<br>$$</p>\n<ul>\n<li>对数值型特征 $A$ 遍历二元切分点，分别计算左右子集的 MSE 加权平均。</li>\n<li>选取使 MSE 降低最多的切分。</li>\n<li>剪枝一般使用最小化验证集误差或对叶子节点惩罚复杂度（Cost-Complexity Pruning）。</li>\n</ul>\n<hr>\n<h2 id=\"剪枝-Pruning\"><a href=\"#剪枝-Pruning\" class=\"headerlink\" title=\"剪枝 (Pruning)\"></a>剪枝 (Pruning)</h2><p>在决策树中，过深的树容易过拟合训练数据，影响泛化。剪枝是为了提高模型在测试集上的准确性。主要有两种方式：</p>\n<h3 id=\"预剪枝-Pre-pruning\"><a href=\"#预剪枝-Pre-pruning\" class=\"headerlink\" title=\"预剪枝 (Pre-pruning)\"></a>预剪枝 (Pre-pruning)</h3><p>在构建树的过程中，提前停止划分，常见策略有：</p>\n<ol>\n<li><strong>最小样本数</strong>：若节点样本数小于某阈值，停止划分；</li>\n<li><strong>最大深度</strong>：树深度达到设定上限，停止；</li>\n<li><strong>信息增益&#x2F;基尼减少阈值</strong>：若最优划分的增益（或减少量）小于阈值，则不再划分；</li>\n<li><strong>统计检验</strong>：基于卡方检验等统计检验判定划分是否显著。</li>\n</ol>\n<blockquote>\n<p><strong>优点</strong>：减少计算和树的复杂度。<br><strong>缺点</strong>：一旦提前停止，可能错过后续有效划分，导致欠拟合。</p>\n</blockquote>\n<h3 id=\"后剪枝-Post-pruning\"><a href=\"#后剪枝-Post-pruning\" class=\"headerlink\" title=\"后剪枝 (Post-pruning)\"></a>后剪枝 (Post-pruning)</h3><p>先让树尽可能长地生长，然后自底向上裁剪。常见流程：</p>\n<ol>\n<li>构建完完全树（直到所有叶节点纯度为 1 或没有更多可划分特征）；</li>\n<li>对每个非叶子节点评估以下两种情况哪种在验证集上性能更好：</li>\n</ol>\n<ul>\n<li>保留该子树结构；</li>\n<li>将其剪为叶节点，并以子树所有样本在该节点的多数类（分类）或平均值（回归）作为输出；</li>\n</ul>\n<ol>\n<li>如果剪掉子树后验证误差减少或无显著变化，则保留剪枝操作；否则保留子树；</li>\n<li>重复上述过程，直到没有可剪枝节点或验证集误差不再降低。</li>\n</ol>\n<blockquote>\n<p><strong>CART 的 Cost-Complexity Pruning</strong>：定义节点惩罚函数</p>\n</blockquote>\n<hr>\n<h2 id=\"决策树的优缺点\"><a href=\"#决策树的优缺点\" class=\"headerlink\" title=\"决策树的优缺点\"></a>决策树的优缺点</h2><h3 id=\"优点\"><a href=\"#优点\" class=\"headerlink\" title=\"优点\"></a>优点</h3><ol>\n<li><strong>可解释性强</strong></li>\n</ol>\n<ul>\n<li>生成后的决策树可视化，人类易于理解和解释每个决策路径。</li>\n</ul>\n<ol>\n<li><strong>无须特征归一化</strong></li>\n</ol>\n<ul>\n<li>对数值型与类别型特征均可处理，不要求输入特征尺度统一。</li>\n</ul>\n<ol>\n<li><strong>自动特征选择</strong></li>\n</ol>\n<ul>\n<li>在划分过程中自动评估并选取对分类&#x2F;回归最有价值的特征。</li>\n</ul>\n<ol>\n<li><strong>鲁棒性强</strong></li>\n</ol>\n<ul>\n<li>对缺失值可采用“分裂时加权”或“按多数类分配”等策略进行处理；对异常值不敏感。</li>\n</ul>\n<ol>\n<li><strong>易于处理多种类型数据</strong></li>\n</ol>\n<ul>\n<li>可以同时处理数值、类别以及缺失值。</li>\n</ul>\n<h3 id=\"缺点\"><a href=\"#缺点\" class=\"headerlink\" title=\"缺点\"></a>缺点</h3><ol>\n<li><strong>容易过拟合</strong></li>\n</ol>\n<ul>\n<li>深度过大时对训练数据拟合过度，泛化能力下降。</li>\n</ul>\n<ol>\n<li><strong>对噪声敏感</strong></li>\n</ol>\n<ul>\n<li>训练数据中的噪声决定划分时可能误导特征选择。</li>\n</ul>\n<ol>\n<li><strong>局部最优</strong></li>\n</ol>\n<ul>\n<li>由于采用贪心策略（每次只选最优特征），可能无法得到全局最优树。</li>\n</ul>\n<ol>\n<li><strong>可用性限制</strong></li>\n</ol>\n<ul>\n<li>对高维稀疏数据（如文本）可能效果不佳；容易生成非常深且稀疏的树。</li>\n</ul>\n<ol>\n<li><strong>不稳定性</strong></li>\n</ol>\n<ul>\n<li>微小的数据变化可能导致决策树结构的大幅改变（当某些样本临界时）。</li>\n</ul>\n<blockquote>\n<p><strong>改进思路</strong>：</p>\n<ul>\n<li><strong>集成方法</strong>：随机森林 (Random Forest)、梯度提升树 (Gradient Boosting Trees，如 XGBoost、LightGBM) 通过集成多棵弱树克服单棵树的易过拟合与不稳定问题。</li>\n<li><strong>特征筛选与降维</strong>：在高维稀疏场景下，可结合特征工程、特征选择等方法减小特征维度。</li>\n</ul>\n</blockquote>\n<hr>\n<h2 id=\"决策树在实际中的应用场景\"><a href=\"#决策树在实际中的应用场景\" class=\"headerlink\" title=\"决策树在实际中的应用场景\"></a>决策树在实际中的应用场景</h2><h3 id=\"相关代码示例\"><a href=\"#相关代码示例\" class=\"headerlink\" title=\"相关代码示例\"></a>相关代码示例</h3><blockquote>\n<p>由于还包含了 c45,cart,id3 为划分指标的决策树代码,我整理在了一个 github 仓库中,下面只展示了 decision_stump.py 的代码<br><a href=\"https://github.com/tkzzzzzz6/MLandDL\">https://github.com/tkzzzzzz6/MLandDL</a></p>\n</blockquote>\n<h4 id=\"decision-stump-py-主要模块\"><a href=\"#decision-stump-py-主要模块\" class=\"headerlink\" title=\"decision_stump.py(主要模块)\"></a>decision_stump.py(主要模块)</h4><figure class=\"highlight python\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br><span class=\"line\">47</span><br><span class=\"line\">48</span><br><span class=\"line\">49</span><br><span class=\"line\">50</span><br><span class=\"line\">51</span><br><span class=\"line\">52</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">import</span> numpy <span class=\"keyword\">as</span> np</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">class</span> <span class=\"title class_\">DecisionStump</span>():</span><br><span class=\"line\">    <span class=\"keyword\">def</span> <span class=\"title function_\">__update_parameter</span>(<span class=\"params\">self, h, feature_index, threshold, direction, err_value</span>):</span><br><span class=\"line\">        <span class=\"variable language_\">self</span>.**__min_err_value** = err_value</span><br><span class=\"line\">        <span class=\"variable language_\">self</span>.**__feature_index** = feature_index</span><br><span class=\"line\">        <span class=\"variable language_\">self</span>.**__threshold** = threshold</span><br><span class=\"line\">        <span class=\"variable language_\">self</span>.**__direction** = direction</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">def</span> <span class=\"title function_\">__select_direction</span>(<span class=\"params\">self, feature_index, threshold, X, y, w</span>):</span><br><span class=\"line\">        <span class=\"keyword\">for</span> direction <span class=\"keyword\">in</span> [<span class=\"string\">&#x27;greater&#x27;</span>, <span class=\"string\">&#x27;less&#x27;</span>]:</span><br><span class=\"line\">            h = np.ones_like(y)</span><br><span class=\"line\"></span><br><span class=\"line\">            <span class=\"keyword\">if</span> direction == <span class=\"string\">&#x27;greater&#x27;</span>:</span><br><span class=\"line\">                h[np.flatnonzero(X[:, feature_index] &lt; threshold)] = -<span class=\"number\">1</span></span><br><span class=\"line\">            <span class=\"keyword\">else</span>:</span><br><span class=\"line\">                h[np.flatnonzero(X[:, feature_index] &gt;= threshold)] = -<span class=\"number\">1</span></span><br><span class=\"line\"></span><br><span class=\"line\">            err_value = np.<span class=\"built_in\">sum</span>(w[np.flatnonzero(h != y)])</span><br><span class=\"line\">            <span class=\"keyword\">if</span> err_value &lt; <span class=\"variable language_\">self</span>.**__min_err_value**:</span><br><span class=\"line\">                <span class=\"variable language_\">self</span>.__update_parameter(h, feature_index, threshold, <span class=\"string\">&#x27;greater&#x27;</span>, err_value)</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">def</span> <span class=\"title function_\">__select_threshold</span>(<span class=\"params\">self, feature_index, X, y, w</span>):</span><br><span class=\"line\">        n_samples = X.shape[<span class=\"number\">0</span>]</span><br><span class=\"line\"></span><br><span class=\"line\">        <span class=\"keyword\">for</span> i <span class=\"keyword\">in</span> <span class=\"built_in\">range</span>(n_samples):</span><br><span class=\"line\">            <span class=\"variable language_\">self</span>.__select_direction(feature_index, X[i, feature_index], X, y, w)</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">def</span> <span class=\"title function_\">__select_feature</span>(<span class=\"params\">self, X, y, w</span>):</span><br><span class=\"line\">        n_features = X.shape[<span class=\"number\">1</span>]</span><br><span class=\"line\"></span><br><span class=\"line\">        <span class=\"keyword\">for</span> i <span class=\"keyword\">in</span> <span class=\"built_in\">range</span>(n_features):</span><br><span class=\"line\">            <span class=\"variable language_\">self</span>.__select_threshold(i, X, y, w)</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">def</span> <span class=\"title function_\">fit</span>(<span class=\"params\">self, X, y, w</span>):</span><br><span class=\"line\">        <span class=\"variable language_\">self</span>.**__feature_index** = <span class=\"literal\">None</span></span><br><span class=\"line\">        <span class=\"variable language_\">self</span>.**__threshold** = <span class=\"literal\">None</span></span><br><span class=\"line\">        <span class=\"variable language_\">self</span>.**__direction** = <span class=\"literal\">None</span></span><br><span class=\"line\">        <span class=\"variable language_\">self</span>.**__min_err_value** = np.**inf**</span><br><span class=\"line\"></span><br><span class=\"line\">        <span class=\"variable language_\">self</span>.__select_feature(X, y, w)</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">def</span> <span class=\"title function_\">predict</span>(<span class=\"params\">self, X</span>):</span><br><span class=\"line\">        n_samples = X.shape[<span class=\"number\">0</span>]</span><br><span class=\"line\"></span><br><span class=\"line\">        y_pred = np.ones(n_samples)</span><br><span class=\"line\">        <span class=\"keyword\">if</span> <span class=\"variable language_\">self</span>.**__direction** == <span class=\"string\">&#x27;greater&#x27;</span>:</span><br><span class=\"line\">            y_pred[np.flatnonzero(X[:, <span class=\"variable language_\">self</span>.**__feature_index**] &lt; <span class=\"variable language_\">self</span>.**__threshold**)] = -<span class=\"number\">1</span></span><br><span class=\"line\">        <span class=\"keyword\">else</span>:</span><br><span class=\"line\">            y_pred[np.flatnonzero(X[:, <span class=\"variable language_\">self</span>.**__feature_index**] &gt;= <span class=\"variable language_\">self</span>.**__threshold**)] = -<span class=\"number\">1</span></span><br><span class=\"line\"></span><br><span class=\"line\">        <span class=\"keyword\">return</span> y_pred</span><br></pre></td></tr></table></figure>\n\n<h4 id=\"运行结果\"><a href=\"#运行结果\" class=\"headerlink\" title=\"运行结果\"></a>运行结果</h4><p><img src=\"https://gitee.com/tanke11223344/imagehost/raw/main/blog/1749360718079T62Tbr1DOojvcLxBIxqcFCvHnlg.png\" alt=\"1749360718079T62Tbr1DOojvcLxBIxqcFCvHnlg.png\"></p>\n<p><img src=\"https://gitee.com/tanke11223344/imagehost/raw/main/blog/1749360730852Tfdmbz1oOo6vFpxAAfkcoEBGnXc.png\" alt=\"1749360730852Tfdmbz1oOo6vFpxAAfkcoEBGnXc.png\"><br><img src=\"https://gitee.com/tanke11223344/imagehost/raw/main/blog/1749360750853Zeg3bB0PioEDr0x9taMclxgOnmh.png\" alt=\"1749360750853Zeg3bB0PioEDr0x9taMclxgOnmh.png\"></p>\n<h3 id=\"分类任务\"><a href=\"#分类任务\" class=\"headerlink\" title=\"分类任务\"></a>分类任务</h3><ol>\n<li><strong>客户流失预测 (Customer Churn Prediction)</strong></li>\n</ol>\n<ul>\n<li>业务场景：电信、金融、电商等行业中，通过客户基本属性、历史行为、消费习惯等特征预测是否会流失。</li>\n<li>决策树优势：易于解释（可解释哪些因素导致客户流失），可处理混合型特征（年龄、性别、套餐类别、使用时长等）。</li>\n</ul>\n<ol>\n<li><strong>信用评估 (Credit Scoring)</strong></li>\n</ol>\n<ul>\n<li>业务场景：银行或金融机构根据用户的个人信息（年龄、工作、收入）、信用记录（逾期次数、还款能力）进行信用风险分类（高风险、中风险、低风险）。</li>\n<li>应用：决策树可直观地给出“如果收入 &lt; X 且逾期次数 &gt; Y，则分类为高风险”，帮助信贷风控。</li>\n</ul>\n<ol>\n<li><strong>医疗诊断</strong></li>\n</ol>\n<ul>\n<li>业务场景：根据患者的症状（发热、咳嗽、X 光结果）、检查指标（血常规、心电图）等预测是否患某种疾病。</li>\n<li>应用：决策树模型可以给出“若咳嗽持续 &gt; 2 周 且 白细胞数 &gt; 某阈值，则可能为肺炎”，同时提供可解释的诊断决策流程。</li>\n</ul>\n<ol>\n<li><strong>垃圾邮件识别</strong></li>\n</ol>\n<ul>\n<li>业务场景：根据邮件内容特征（关键字出现次数、发送人是否在白名单）、邮件长度、附件类型等判断是否为垃圾邮件。</li>\n<li>应用：决策树可快速处理离散&#x2F;连续特征，常用于构建初期的规则或与其他模型结合（如 Random Forest）。</li>\n</ul>\n<h3 id=\"回归任务\"><a href=\"#回归任务\" class=\"headerlink\" title=\"回归任务\"></a>回归任务</h3><ol>\n<li><strong>房价预测 (House Price Prediction)</strong></li>\n</ol>\n<ul>\n<li>业务场景：根据房屋面积、楼层、房龄、地理位置、交通等因素预测房价。</li>\n<li>决策树回归：将房屋特征空间划分为若干区域，每个叶节点输出区域内样本的平均房价。做不到很平滑，但易于理解。</li>\n</ul>\n<ol>\n<li><strong>销售额预测</strong></li>\n</ol>\n<ul>\n<li>业务场景：预测节假日、促销活动或天气变化对某商品销售额的影响。</li>\n<li>决策树回归能够捕获非线性关系，且不需要对特征进行大量预处理。</li>\n</ul>\n<h3 id=\"特征工程与规则提取\"><a href=\"#特征工程与规则提取\" class=\"headerlink\" title=\"特征工程与规则提取\"></a>特征工程与规则提取</h3><ol>\n<li><strong>特征构造</strong></li>\n</ol>\n<ul>\n<li>通过决策树可以将某些连续特征自动离散化。例如，若决策树对“年龄”做了三次切分，分别在 25 岁、40 岁产生不同的分支，则可得到“年龄段”特征。</li>\n</ul>\n<ol>\n<li><strong>规则提取</strong></li>\n</ol>\n<ul>\n<li>从训练好的决策树中可直接提取“如果……则……”的规则，用于可解释性要求高的场景（如审计、医疗）。</li>\n</ul>\n<h3 id=\"集成学习基础\"><a href=\"#集成学习基础\" class=\"headerlink\" title=\"集成学习基础\"></a>集成学习基础</h3><ol>\n<li><strong>随机森林 (Random Forest)</strong></li>\n</ol>\n<ul>\n<li>由多棵决策树随机组合而成。每棵树训练时只使用特征子集和样本子集，最后多数投票决定分类结果或平均值决定回归值。</li>\n<li>优势：降低单棵决策树的过拟合风险，提高泛化能力。</li>\n</ul>\n<ol>\n<li><strong>梯度提升树 (Gradient Boosting Trees)</strong></li>\n</ol>\n<ul>\n<li>通过逐步拟合残差的方式构建多个弱决策树，每棵新树在前一棵树的基础上拟合残差，最终组合得到强模型，如 XGBoost、LightGBM、CatBoost。</li>\n</ul>\n<hr>\n<h2 id=\"总结\"><a href=\"#总结\" class=\"headerlink\" title=\"总结\"></a>总结</h2><ol>\n<li><strong>决策树</strong> 是一种简单、易理解且可处理混合型特征的模型，既可做分类，也可做回归。</li>\n<li><strong>核心步骤</strong>：选择合适的划分指标（信息增益 &#x2F; 信息增益率 &#x2F; 基尼不纯度）、确定最佳划分点，递归生成树，并通过剪枝降低过拟合。</li>\n<li><strong>常见算法</strong>：</li>\n</ol>\n<ul>\n<li><strong>ID3</strong>（仅支持离散特征，使用信息增益）</li>\n<li><strong>C4.5</strong>（支持数值特征 &amp; 离散特征，使用信息增益率，含剪枝）</li>\n<li><strong>CART</strong>（构建二叉树，使用基尼不纯度，可用于分类与回归）</li>\n</ul>\n<ol>\n<li><strong>优缺点</strong>：</li>\n</ol>\n<ul>\n<li>优点：可解释性强、无需特征缩放、自动进行特征选择。</li>\n<li>缺点：容易过拟合、对噪声敏感、在高维稀疏场景下不够稳定。</li>\n</ul>\n<ol>\n<li><strong>典型应用</strong>：</li>\n</ol>\n<ul>\n<li>客户流失预测、信用评估、医疗诊断、垃圾邮件识别等分类场景；</li>\n<li>房价预测、销售额预测等回归场景；</li>\n<li>特征工程、规则提取、以及集成学习（随机森林、梯度提升树）的基石。</li>\n</ul>\n"},{"title":"2025-05-05-80x86 汇编语言环境配置","date":"2025-05-04T16:00:00.000Z","_content":"\n# 2025-05-05-80x86 汇编语言环境配置\n\n\n> # 参考博客\n>\n> [在 VScode 配置汇编语言环境_vscode asm-CSDN 博客](https://blog.csdn.net/m0_65708726/article/details/130795651?spm=1001.2101.3001.6650.3&utm_medium=distribute.pc_relevant.none-task-blog-2%7Edefault%7EBlogCommendFromBaidu%7ECtr-3-130795651-blog-144669809.235%5Ev43%5Epc_blog_bottom_relevance_base8&depth_1-utm_source=distribute.pc_relevant.none-task-blog-2%7Edefault%7EBlogCommendFromBaidu%7ECtr-3-130795651-blog-144669809.235%5Ev43%5Epc_blog_bottom_relevance_base8&utm_relevant_index=3)\n> [使用 VSCode 学习汇编语言-CSDN 博客](https://blog.csdn.net/weixin_44225025/article/details/108222446)\n> [VSCode 搭建汇编环境-CSDN 博客](https://blog.csdn.net/weixin_42303973/article/details/120444779)\n\n# 安装 MASM/TASM 插件\n\n![1746454873197VkKQbyDXjoxDGjxbqvjcOlZ9nte.png](https://tk-pichost-1325224430.cos.ap-chengdu.myqcloud.com/blog/1746454873197VkKQbyDXjoxDGjxbqvjcOlZ9nte.png)\n# 配置 .vscode/setting.json\n\n```\n{\n    \"masmtasm.ASM.emulator\": \"msdos player\",  \n    \"masmtasm.dosbox.run\": \"exit\",\n    \"masmtasm.ASM.assembler\": \"MASM-v5.00\",\n    \"masmtasm.ASM.actions\": {\n        \"TASM\": {\n            \"baseBundle\": \"<built-in>/TASM.jsdos\",\n            \"before\": [\n                \"set PATH=C:\\\\TASM\"\n            ],\n            \"run\": [\n                \"TASM ${file}\",\n                \"TLINK ${filename}\",\n                \">${filename}\"\n            ],\n            \"debug\": [\n                \"TASM /zi ${file}\",\n                \"TLINK /v/3 ${filename}.obj\",\n                \"TD ${filename}.exe\"\n            ]\n        },\n        \"MASM-v6.11\": {\n            \"baseBundle\": \"<built-in>/MASM-v6.11.jsdos\",\n            \"before\": [\n                \"set PATH=C:\\\\MASM\"\n            ],\n            \"run\": [\n                \"masm ${file};\",\n                \"link ${filename};\",\n                \">${filename}\"\n            ],\n            \"debug\": [\n                \"masm ${file};\",\n                \"link ${filename}.OBJ;\",\n                \">debug ${filename}.exe\"\n            ]\n        },\n        \"MASM-v5.00\": {\n            \"baseBundle\": \"<built-in>/MASM-v5.00.jsdos\",\n            \"before\": [\n                \"set PATH=C:\\\\MASM\"\n            ],\n            \"run\": [\n                \"masm ${file};\",\n                \"link ${filename};\",\n                \">${filename}\"\n            ],\n            \"debug\": [\n                \"masm ${file};\",\n                \"link ${filename}.OBJ;\",\n                \">debug ${filename}.exe\"\n            ],\n            \"support\": [\n                \"jsdos\",\n                \"dosbox\",\n                \"dosboxX\",\n                \"msdos player\"\n            ]\n        }\n    }\n}\n```\n\n# 测试配置环境\n\n创建以.asm 为后缀的文件,将下面的代码复制上去,运行程序\n\n```\n_.MODEL SMALL\n.STACK 100h\n\n.DATA\n    message DB 'Hello, Assembly! Environment test successful!$'\n\n.CODE\nMAIN PROC\n    ; 设置数据段地址\n    MOV AX, @DATA\n    MOV DS, AX\n    \n    ; 显示消息\n    MOV AH, 09h      ; DOS功能：显示字符串\n    LEA DX, message  ; 加载消息地址\n    INT 21h          ; 调用DOS中断\n    \n    ; 返回DOS\n    MOV AH, 4Ch      ; DOS功能：结束程序\n    INT 21h          ; 调用DOS中断\nMAIN ENDP\n__END MAIN_\n```\n\n> 注意:\n>\n> - 路径中最好不要有中文,如果有中文的话可以将项目路径设置为没有中文的路径中再运行\n> - 程序如果要调试的话,需要先调试\n> - 如果运行报错的话一般都是因为路径的问题,可以使用,先启动dox环境再自己编译,链接和运行,完成以后再使用调试的功能\n>\n>eg:\n>编译:masm E1.asm;\n>\n>链接:link E1.obj;\n>\n>运行:E1.exe\n>\n>然后才能debug\n>\n>![17465878142961746587813440.png](https://tk-pichost-1325224430.cos.ap-chengdu.myqcloud.com/blog/17465878142961746587813440.png)\n\n![1746454883775Er3IbHOLQoATO9xPoIYcDBMznKd.png](https://tk-pichost-1325224430.cos.ap-chengdu.myqcloud.com/blog/1746454883775Er3IbHOLQoATO9xPoIYcDBMznKd.png)\n\n出现上面的信息说明基础环境配置成功!\n\n# Extension Settings 拓展设置说明\n\n要实现完整的功能，需要在拓展中进行设置，同时\"设置(首选项)\"中还有一些其他选项，以提供更大的灵活性。\n\n### 汇编工具选择\n\n- 选择使用 MASM 还是 TASM\n\n### 16 位模拟器选择\n\n- **DOSBox**：（默认模式）更加完善\n- **msdos-player**：可以在 cmd 中运行，不会弹出窗口，但对 TD 等图形化界面的处理效果不好\n- **auto**：（推荐，但是有时无法工作）根据情况选择模拟工具：\n\n  - 汇编链接使用 msdos-player 模拟，会比较安静\n  - 运行使用 DOSBox，更加直观稳定\n  - 调试中 MASM(debug)使用 msdos-palyer 在 windows 集成终端中显示（更加美观一些）\n  - 调试中 TASM(TD)在 DOSBox 中运行（目前只能这样）\n\n### 其他配置选项\n\n- 调整 dosbox 窗口大小\n- 规定 dosbox 运行程序之后进行什么操作（是否直接退出程序，还是等待）\n- 启动相关功能之前是否先保存文件（不保存的话，只能操作之前保存的版本，建议保存）\n- 设置自定义汇编工具路径\n","source":"_posts/2025-05-05-80x86汇编语言环境配置.md","raw":"---\ntitle:  2025-05-05-80x86 汇编语言环境配置\ndate: 2025-05-05\ntags: \n    课程学习\n---\n\n# 2025-05-05-80x86 汇编语言环境配置\n\n\n> # 参考博客\n>\n> [在 VScode 配置汇编语言环境_vscode asm-CSDN 博客](https://blog.csdn.net/m0_65708726/article/details/130795651?spm=1001.2101.3001.6650.3&utm_medium=distribute.pc_relevant.none-task-blog-2%7Edefault%7EBlogCommendFromBaidu%7ECtr-3-130795651-blog-144669809.235%5Ev43%5Epc_blog_bottom_relevance_base8&depth_1-utm_source=distribute.pc_relevant.none-task-blog-2%7Edefault%7EBlogCommendFromBaidu%7ECtr-3-130795651-blog-144669809.235%5Ev43%5Epc_blog_bottom_relevance_base8&utm_relevant_index=3)\n> [使用 VSCode 学习汇编语言-CSDN 博客](https://blog.csdn.net/weixin_44225025/article/details/108222446)\n> [VSCode 搭建汇编环境-CSDN 博客](https://blog.csdn.net/weixin_42303973/article/details/120444779)\n\n# 安装 MASM/TASM 插件\n\n![1746454873197VkKQbyDXjoxDGjxbqvjcOlZ9nte.png](https://tk-pichost-1325224430.cos.ap-chengdu.myqcloud.com/blog/1746454873197VkKQbyDXjoxDGjxbqvjcOlZ9nte.png)\n# 配置 .vscode/setting.json\n\n```\n{\n    \"masmtasm.ASM.emulator\": \"msdos player\",  \n    \"masmtasm.dosbox.run\": \"exit\",\n    \"masmtasm.ASM.assembler\": \"MASM-v5.00\",\n    \"masmtasm.ASM.actions\": {\n        \"TASM\": {\n            \"baseBundle\": \"<built-in>/TASM.jsdos\",\n            \"before\": [\n                \"set PATH=C:\\\\TASM\"\n            ],\n            \"run\": [\n                \"TASM ${file}\",\n                \"TLINK ${filename}\",\n                \">${filename}\"\n            ],\n            \"debug\": [\n                \"TASM /zi ${file}\",\n                \"TLINK /v/3 ${filename}.obj\",\n                \"TD ${filename}.exe\"\n            ]\n        },\n        \"MASM-v6.11\": {\n            \"baseBundle\": \"<built-in>/MASM-v6.11.jsdos\",\n            \"before\": [\n                \"set PATH=C:\\\\MASM\"\n            ],\n            \"run\": [\n                \"masm ${file};\",\n                \"link ${filename};\",\n                \">${filename}\"\n            ],\n            \"debug\": [\n                \"masm ${file};\",\n                \"link ${filename}.OBJ;\",\n                \">debug ${filename}.exe\"\n            ]\n        },\n        \"MASM-v5.00\": {\n            \"baseBundle\": \"<built-in>/MASM-v5.00.jsdos\",\n            \"before\": [\n                \"set PATH=C:\\\\MASM\"\n            ],\n            \"run\": [\n                \"masm ${file};\",\n                \"link ${filename};\",\n                \">${filename}\"\n            ],\n            \"debug\": [\n                \"masm ${file};\",\n                \"link ${filename}.OBJ;\",\n                \">debug ${filename}.exe\"\n            ],\n            \"support\": [\n                \"jsdos\",\n                \"dosbox\",\n                \"dosboxX\",\n                \"msdos player\"\n            ]\n        }\n    }\n}\n```\n\n# 测试配置环境\n\n创建以.asm 为后缀的文件,将下面的代码复制上去,运行程序\n\n```\n_.MODEL SMALL\n.STACK 100h\n\n.DATA\n    message DB 'Hello, Assembly! Environment test successful!$'\n\n.CODE\nMAIN PROC\n    ; 设置数据段地址\n    MOV AX, @DATA\n    MOV DS, AX\n    \n    ; 显示消息\n    MOV AH, 09h      ; DOS功能：显示字符串\n    LEA DX, message  ; 加载消息地址\n    INT 21h          ; 调用DOS中断\n    \n    ; 返回DOS\n    MOV AH, 4Ch      ; DOS功能：结束程序\n    INT 21h          ; 调用DOS中断\nMAIN ENDP\n__END MAIN_\n```\n\n> 注意:\n>\n> - 路径中最好不要有中文,如果有中文的话可以将项目路径设置为没有中文的路径中再运行\n> - 程序如果要调试的话,需要先调试\n> - 如果运行报错的话一般都是因为路径的问题,可以使用,先启动dox环境再自己编译,链接和运行,完成以后再使用调试的功能\n>\n>eg:\n>编译:masm E1.asm;\n>\n>链接:link E1.obj;\n>\n>运行:E1.exe\n>\n>然后才能debug\n>\n>![17465878142961746587813440.png](https://tk-pichost-1325224430.cos.ap-chengdu.myqcloud.com/blog/17465878142961746587813440.png)\n\n![1746454883775Er3IbHOLQoATO9xPoIYcDBMznKd.png](https://tk-pichost-1325224430.cos.ap-chengdu.myqcloud.com/blog/1746454883775Er3IbHOLQoATO9xPoIYcDBMznKd.png)\n\n出现上面的信息说明基础环境配置成功!\n\n# Extension Settings 拓展设置说明\n\n要实现完整的功能，需要在拓展中进行设置，同时\"设置(首选项)\"中还有一些其他选项，以提供更大的灵活性。\n\n### 汇编工具选择\n\n- 选择使用 MASM 还是 TASM\n\n### 16 位模拟器选择\n\n- **DOSBox**：（默认模式）更加完善\n- **msdos-player**：可以在 cmd 中运行，不会弹出窗口，但对 TD 等图形化界面的处理效果不好\n- **auto**：（推荐，但是有时无法工作）根据情况选择模拟工具：\n\n  - 汇编链接使用 msdos-player 模拟，会比较安静\n  - 运行使用 DOSBox，更加直观稳定\n  - 调试中 MASM(debug)使用 msdos-palyer 在 windows 集成终端中显示（更加美观一些）\n  - 调试中 TASM(TD)在 DOSBox 中运行（目前只能这样）\n\n### 其他配置选项\n\n- 调整 dosbox 窗口大小\n- 规定 dosbox 运行程序之后进行什么操作（是否直接退出程序，还是等待）\n- 启动相关功能之前是否先保存文件（不保存的话，只能操作之前保存的版本，建议保存）\n- 设置自定义汇编工具路径\n","slug":"2025-05-05-80x86汇编语言环境配置","published":1,"updated":"2025-09-26T12:17:17.696Z","_id":"cmg0saj49001tjm8nc19l0aan","comments":1,"layout":"post","photos":[],"content":"<h1 id=\"2025-05-05-80x86-汇编语言环境配置\"><a href=\"#2025-05-05-80x86-汇编语言环境配置\" class=\"headerlink\" title=\"2025-05-05-80x86 汇编语言环境配置\"></a>2025-05-05-80x86 汇编语言环境配置</h1><blockquote>\n<h1 id=\"参考博客\"><a href=\"#参考博客\" class=\"headerlink\" title=\"参考博客\"></a>参考博客</h1><p><a href=\"https://blog.csdn.net/m0_65708726/article/details/130795651?spm=1001.2101.3001.6650.3&utm_medium=distribute.pc_relevant.none-task-blog-2~default~BlogCommendFromBaidu~Ctr-3-130795651-blog-144669809.235%5Ev43%5Epc_blog_bottom_relevance_base8&depth_1-utm_source=distribute.pc_relevant.none-task-blog-2~default~BlogCommendFromBaidu~Ctr-3-130795651-blog-144669809.235%5Ev43%5Epc_blog_bottom_relevance_base8&utm_relevant_index=3\">在 VScode 配置汇编语言环境_vscode asm-CSDN 博客</a><br><a href=\"https://blog.csdn.net/weixin_44225025/article/details/108222446\">使用 VSCode 学习汇编语言-CSDN 博客</a><br><a href=\"https://blog.csdn.net/weixin_42303973/article/details/120444779\">VSCode 搭建汇编环境-CSDN 博客</a></p>\n</blockquote>\n<h1 id=\"安装-MASM-TASM-插件\"><a href=\"#安装-MASM-TASM-插件\" class=\"headerlink\" title=\"安装 MASM&#x2F;TASM 插件\"></a>安装 MASM&#x2F;TASM 插件</h1><p><img src=\"https://tk-pichost-1325224430.cos.ap-chengdu.myqcloud.com/blog/1746454873197VkKQbyDXjoxDGjxbqvjcOlZ9nte.png\" alt=\"1746454873197VkKQbyDXjoxDGjxbqvjcOlZ9nte.png\"></p>\n<h1 id=\"配置-vscode-setting-json\"><a href=\"#配置-vscode-setting-json\" class=\"headerlink\" title=\"配置 .vscode&#x2F;setting.json\"></a>配置 .vscode&#x2F;setting.json</h1><figure class=\"highlight nix\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br><span class=\"line\">47</span><br><span class=\"line\">48</span><br><span class=\"line\">49</span><br><span class=\"line\">50</span><br><span class=\"line\">51</span><br><span class=\"line\">52</span><br><span class=\"line\">53</span><br><span class=\"line\">54</span><br><span class=\"line\">55</span><br><span class=\"line\">56</span><br><span class=\"line\">57</span><br><span class=\"line\">58</span><br><span class=\"line\">59</span><br><span class=\"line\">60</span><br><span class=\"line\">61</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">&#123;</span><br><span class=\"line\">    <span class=\"string\">&quot;masmtasm.ASM.emulator&quot;</span>: <span class=\"string\">&quot;msdos player&quot;</span>,  </span><br><span class=\"line\">    <span class=\"string\">&quot;masmtasm.dosbox.run&quot;</span>: <span class=\"string\">&quot;exit&quot;</span>,</span><br><span class=\"line\">    <span class=\"string\">&quot;masmtasm.ASM.assembler&quot;</span>: <span class=\"string\">&quot;MASM-v5.00&quot;</span>,</span><br><span class=\"line\">    <span class=\"string\">&quot;masmtasm.ASM.actions&quot;</span>: &#123;</span><br><span class=\"line\">        <span class=\"string\">&quot;TASM&quot;</span>: &#123;</span><br><span class=\"line\">            <span class=\"string\">&quot;baseBundle&quot;</span>: <span class=\"string\">&quot;&lt;built-in&gt;/TASM.jsdos&quot;</span>,</span><br><span class=\"line\">            <span class=\"string\">&quot;before&quot;</span>: [</span><br><span class=\"line\">                <span class=\"string\">&quot;set PATH=C:<span class=\"char escape_\">\\\\</span>TASM&quot;</span></span><br><span class=\"line\">            ],</span><br><span class=\"line\">            <span class=\"string\">&quot;run&quot;</span>: [</span><br><span class=\"line\">                <span class=\"string\">&quot;TASM <span class=\"subst\">$&#123;file&#125;</span>&quot;</span>,</span><br><span class=\"line\">                <span class=\"string\">&quot;TLINK <span class=\"subst\">$&#123;filename&#125;</span>&quot;</span>,</span><br><span class=\"line\">                <span class=\"string\">&quot;&gt;<span class=\"subst\">$&#123;filename&#125;</span>&quot;</span></span><br><span class=\"line\">            ],</span><br><span class=\"line\">            <span class=\"string\">&quot;debug&quot;</span>: [</span><br><span class=\"line\">                <span class=\"string\">&quot;TASM /zi <span class=\"subst\">$&#123;file&#125;</span>&quot;</span>,</span><br><span class=\"line\">                <span class=\"string\">&quot;TLINK /v/3 <span class=\"subst\">$&#123;filename&#125;</span>.obj&quot;</span>,</span><br><span class=\"line\">                <span class=\"string\">&quot;TD <span class=\"subst\">$&#123;filename&#125;</span>.exe&quot;</span></span><br><span class=\"line\">            ]</span><br><span class=\"line\">        &#125;,</span><br><span class=\"line\">        <span class=\"string\">&quot;MASM-v6.11&quot;</span>: &#123;</span><br><span class=\"line\">            <span class=\"string\">&quot;baseBundle&quot;</span>: <span class=\"string\">&quot;&lt;built-in&gt;/MASM-v6.11.jsdos&quot;</span>,</span><br><span class=\"line\">            <span class=\"string\">&quot;before&quot;</span>: [</span><br><span class=\"line\">                <span class=\"string\">&quot;set PATH=C:<span class=\"char escape_\">\\\\</span>MASM&quot;</span></span><br><span class=\"line\">            ],</span><br><span class=\"line\">            <span class=\"string\">&quot;run&quot;</span>: [</span><br><span class=\"line\">                <span class=\"string\">&quot;masm <span class=\"subst\">$&#123;file&#125;</span>;&quot;</span>,</span><br><span class=\"line\">                <span class=\"string\">&quot;link <span class=\"subst\">$&#123;filename&#125;</span>;&quot;</span>,</span><br><span class=\"line\">                <span class=\"string\">&quot;&gt;<span class=\"subst\">$&#123;filename&#125;</span>&quot;</span></span><br><span class=\"line\">            ],</span><br><span class=\"line\">            <span class=\"string\">&quot;debug&quot;</span>: [</span><br><span class=\"line\">                <span class=\"string\">&quot;masm <span class=\"subst\">$&#123;file&#125;</span>;&quot;</span>,</span><br><span class=\"line\">                <span class=\"string\">&quot;link <span class=\"subst\">$&#123;filename&#125;</span>.OBJ;&quot;</span>,</span><br><span class=\"line\">                <span class=\"string\">&quot;&gt;debug <span class=\"subst\">$&#123;filename&#125;</span>.exe&quot;</span></span><br><span class=\"line\">            ]</span><br><span class=\"line\">        &#125;,</span><br><span class=\"line\">        <span class=\"string\">&quot;MASM-v5.00&quot;</span>: &#123;</span><br><span class=\"line\">            <span class=\"string\">&quot;baseBundle&quot;</span>: <span class=\"string\">&quot;&lt;built-in&gt;/MASM-v5.00.jsdos&quot;</span>,</span><br><span class=\"line\">            <span class=\"string\">&quot;before&quot;</span>: [</span><br><span class=\"line\">                <span class=\"string\">&quot;set PATH=C:<span class=\"char escape_\">\\\\</span>MASM&quot;</span></span><br><span class=\"line\">            ],</span><br><span class=\"line\">            <span class=\"string\">&quot;run&quot;</span>: [</span><br><span class=\"line\">                <span class=\"string\">&quot;masm <span class=\"subst\">$&#123;file&#125;</span>;&quot;</span>,</span><br><span class=\"line\">                <span class=\"string\">&quot;link <span class=\"subst\">$&#123;filename&#125;</span>;&quot;</span>,</span><br><span class=\"line\">                <span class=\"string\">&quot;&gt;<span class=\"subst\">$&#123;filename&#125;</span>&quot;</span></span><br><span class=\"line\">            ],</span><br><span class=\"line\">            <span class=\"string\">&quot;debug&quot;</span>: [</span><br><span class=\"line\">                <span class=\"string\">&quot;masm <span class=\"subst\">$&#123;file&#125;</span>;&quot;</span>,</span><br><span class=\"line\">                <span class=\"string\">&quot;link <span class=\"subst\">$&#123;filename&#125;</span>.OBJ;&quot;</span>,</span><br><span class=\"line\">                <span class=\"string\">&quot;&gt;debug <span class=\"subst\">$&#123;filename&#125;</span>.exe&quot;</span></span><br><span class=\"line\">            ],</span><br><span class=\"line\">            <span class=\"string\">&quot;support&quot;</span>: [</span><br><span class=\"line\">                <span class=\"string\">&quot;jsdos&quot;</span>,</span><br><span class=\"line\">                <span class=\"string\">&quot;dosbox&quot;</span>,</span><br><span class=\"line\">                <span class=\"string\">&quot;dosboxX&quot;</span>,</span><br><span class=\"line\">                <span class=\"string\">&quot;msdos player&quot;</span></span><br><span class=\"line\">            ]</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<h1 id=\"测试配置环境\"><a href=\"#测试配置环境\" class=\"headerlink\" title=\"测试配置环境\"></a>测试配置环境</h1><p>创建以.asm 为后缀的文件,将下面的代码复制上去,运行程序</p>\n<figure class=\"highlight x86asm\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">_<span class=\"number\">.</span>MODEL SMALL</span><br><span class=\"line\"><span class=\"meta\">.STACK</span> <span class=\"number\">100h</span></span><br><span class=\"line\"><span class=\"meta\"></span></span><br><span class=\"line\"><span class=\"meta\">.DATA</span></span><br><span class=\"line\">    message <span class=\"built_in\">DB</span> <span class=\"string\">&#x27;Hello, Assembly! Environment test successful!$&#x27;</span></span><br><span class=\"line\"><span class=\"meta\"></span></span><br><span class=\"line\"><span class=\"meta\">.CODE</span></span><br><span class=\"line\">MAIN PROC</span><br><span class=\"line\">    <span class=\"comment\">; 设置数据段地址</span></span><br><span class=\"line\">    <span class=\"keyword\">MOV</span> <span class=\"built_in\">AX</span>, @DATA</span><br><span class=\"line\">    <span class=\"keyword\">MOV</span> <span class=\"built_in\">DS</span>, <span class=\"built_in\">AX</span></span><br><span class=\"line\">    </span><br><span class=\"line\">    <span class=\"comment\">; 显示消息</span></span><br><span class=\"line\">    <span class=\"keyword\">MOV</span> <span class=\"number\">AH</span>, <span class=\"number\">09h</span>      <span class=\"comment\">; DOS功能：显示字符串</span></span><br><span class=\"line\">    <span class=\"keyword\">LEA</span> <span class=\"built_in\">DX</span>, message  <span class=\"comment\">; 加载消息地址</span></span><br><span class=\"line\">    <span class=\"keyword\">INT</span> <span class=\"number\">21h</span>          <span class=\"comment\">; 调用DOS中断</span></span><br><span class=\"line\">    </span><br><span class=\"line\">    <span class=\"comment\">; 返回DOS</span></span><br><span class=\"line\">    <span class=\"keyword\">MOV</span> <span class=\"number\">AH</span>, <span class=\"number\">4Ch</span>      <span class=\"comment\">; DOS功能：结束程序</span></span><br><span class=\"line\">    <span class=\"keyword\">INT</span> <span class=\"number\">21h</span>          <span class=\"comment\">; 调用DOS中断</span></span><br><span class=\"line\">MAIN ENDP</span><br><span class=\"line\">__END MAIN_</span><br></pre></td></tr></table></figure>\n\n<blockquote>\n<p>注意:</p>\n<ul>\n<li>路径中最好不要有中文,如果有中文的话可以将项目路径设置为没有中文的路径中再运行</li>\n<li>程序如果要调试的话,需要先调试</li>\n<li>如果运行报错的话一般都是因为路径的问题,可以使用,先启动dox环境再自己编译,链接和运行,完成以后再使用调试的功能</li>\n</ul>\n<p>eg:<br>编译:masm E1.asm;</p>\n<p>链接:link E1.obj;</p>\n<p>运行:E1.exe</p>\n<p>然后才能debug</p>\n<p><img src=\"https://tk-pichost-1325224430.cos.ap-chengdu.myqcloud.com/blog/17465878142961746587813440.png\" alt=\"17465878142961746587813440.png\"></p>\n</blockquote>\n<p><img src=\"https://tk-pichost-1325224430.cos.ap-chengdu.myqcloud.com/blog/1746454883775Er3IbHOLQoATO9xPoIYcDBMznKd.png\" alt=\"1746454883775Er3IbHOLQoATO9xPoIYcDBMznKd.png\"></p>\n<p>出现上面的信息说明基础环境配置成功!</p>\n<h1 id=\"Extension-Settings-拓展设置说明\"><a href=\"#Extension-Settings-拓展设置说明\" class=\"headerlink\" title=\"Extension Settings 拓展设置说明\"></a>Extension Settings 拓展设置说明</h1><p>要实现完整的功能，需要在拓展中进行设置，同时”设置(首选项)”中还有一些其他选项，以提供更大的灵活性。</p>\n<h3 id=\"汇编工具选择\"><a href=\"#汇编工具选择\" class=\"headerlink\" title=\"汇编工具选择\"></a>汇编工具选择</h3><ul>\n<li>选择使用 MASM 还是 TASM</li>\n</ul>\n<h3 id=\"16-位模拟器选择\"><a href=\"#16-位模拟器选择\" class=\"headerlink\" title=\"16 位模拟器选择\"></a>16 位模拟器选择</h3><ul>\n<li><p><strong>DOSBox</strong>：（默认模式）更加完善</p>\n</li>\n<li><p><strong>msdos-player</strong>：可以在 cmd 中运行，不会弹出窗口，但对 TD 等图形化界面的处理效果不好</p>\n</li>\n<li><p><strong>auto</strong>：（推荐，但是有时无法工作）根据情况选择模拟工具：</p>\n<ul>\n<li>汇编链接使用 msdos-player 模拟，会比较安静</li>\n<li>运行使用 DOSBox，更加直观稳定</li>\n<li>调试中 MASM(debug)使用 msdos-palyer 在 windows 集成终端中显示（更加美观一些）</li>\n<li>调试中 TASM(TD)在 DOSBox 中运行（目前只能这样）</li>\n</ul>\n</li>\n</ul>\n<h3 id=\"其他配置选项\"><a href=\"#其他配置选项\" class=\"headerlink\" title=\"其他配置选项\"></a>其他配置选项</h3><ul>\n<li>调整 dosbox 窗口大小</li>\n<li>规定 dosbox 运行程序之后进行什么操作（是否直接退出程序，还是等待）</li>\n<li>启动相关功能之前是否先保存文件（不保存的话，只能操作之前保存的版本，建议保存）</li>\n<li>设置自定义汇编工具路径</li>\n</ul>\n","excerpt":"","more":"<h1 id=\"2025-05-05-80x86-汇编语言环境配置\"><a href=\"#2025-05-05-80x86-汇编语言环境配置\" class=\"headerlink\" title=\"2025-05-05-80x86 汇编语言环境配置\"></a>2025-05-05-80x86 汇编语言环境配置</h1><blockquote>\n<h1 id=\"参考博客\"><a href=\"#参考博客\" class=\"headerlink\" title=\"参考博客\"></a>参考博客</h1><p><a href=\"https://blog.csdn.net/m0_65708726/article/details/130795651?spm=1001.2101.3001.6650.3&utm_medium=distribute.pc_relevant.none-task-blog-2~default~BlogCommendFromBaidu~Ctr-3-130795651-blog-144669809.235%5Ev43%5Epc_blog_bottom_relevance_base8&depth_1-utm_source=distribute.pc_relevant.none-task-blog-2~default~BlogCommendFromBaidu~Ctr-3-130795651-blog-144669809.235%5Ev43%5Epc_blog_bottom_relevance_base8&utm_relevant_index=3\">在 VScode 配置汇编语言环境_vscode asm-CSDN 博客</a><br><a href=\"https://blog.csdn.net/weixin_44225025/article/details/108222446\">使用 VSCode 学习汇编语言-CSDN 博客</a><br><a href=\"https://blog.csdn.net/weixin_42303973/article/details/120444779\">VSCode 搭建汇编环境-CSDN 博客</a></p>\n</blockquote>\n<h1 id=\"安装-MASM-TASM-插件\"><a href=\"#安装-MASM-TASM-插件\" class=\"headerlink\" title=\"安装 MASM&#x2F;TASM 插件\"></a>安装 MASM&#x2F;TASM 插件</h1><p><img src=\"https://tk-pichost-1325224430.cos.ap-chengdu.myqcloud.com/blog/1746454873197VkKQbyDXjoxDGjxbqvjcOlZ9nte.png\" alt=\"1746454873197VkKQbyDXjoxDGjxbqvjcOlZ9nte.png\"></p>\n<h1 id=\"配置-vscode-setting-json\"><a href=\"#配置-vscode-setting-json\" class=\"headerlink\" title=\"配置 .vscode&#x2F;setting.json\"></a>配置 .vscode&#x2F;setting.json</h1><figure class=\"highlight nix\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br><span class=\"line\">47</span><br><span class=\"line\">48</span><br><span class=\"line\">49</span><br><span class=\"line\">50</span><br><span class=\"line\">51</span><br><span class=\"line\">52</span><br><span class=\"line\">53</span><br><span class=\"line\">54</span><br><span class=\"line\">55</span><br><span class=\"line\">56</span><br><span class=\"line\">57</span><br><span class=\"line\">58</span><br><span class=\"line\">59</span><br><span class=\"line\">60</span><br><span class=\"line\">61</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">&#123;</span><br><span class=\"line\">    <span class=\"string\">&quot;masmtasm.ASM.emulator&quot;</span>: <span class=\"string\">&quot;msdos player&quot;</span>,  </span><br><span class=\"line\">    <span class=\"string\">&quot;masmtasm.dosbox.run&quot;</span>: <span class=\"string\">&quot;exit&quot;</span>,</span><br><span class=\"line\">    <span class=\"string\">&quot;masmtasm.ASM.assembler&quot;</span>: <span class=\"string\">&quot;MASM-v5.00&quot;</span>,</span><br><span class=\"line\">    <span class=\"string\">&quot;masmtasm.ASM.actions&quot;</span>: &#123;</span><br><span class=\"line\">        <span class=\"string\">&quot;TASM&quot;</span>: &#123;</span><br><span class=\"line\">            <span class=\"string\">&quot;baseBundle&quot;</span>: <span class=\"string\">&quot;&lt;built-in&gt;/TASM.jsdos&quot;</span>,</span><br><span class=\"line\">            <span class=\"string\">&quot;before&quot;</span>: [</span><br><span class=\"line\">                <span class=\"string\">&quot;set PATH=C:<span class=\"char escape_\">\\\\</span>TASM&quot;</span></span><br><span class=\"line\">            ],</span><br><span class=\"line\">            <span class=\"string\">&quot;run&quot;</span>: [</span><br><span class=\"line\">                <span class=\"string\">&quot;TASM <span class=\"subst\">$&#123;file&#125;</span>&quot;</span>,</span><br><span class=\"line\">                <span class=\"string\">&quot;TLINK <span class=\"subst\">$&#123;filename&#125;</span>&quot;</span>,</span><br><span class=\"line\">                <span class=\"string\">&quot;&gt;<span class=\"subst\">$&#123;filename&#125;</span>&quot;</span></span><br><span class=\"line\">            ],</span><br><span class=\"line\">            <span class=\"string\">&quot;debug&quot;</span>: [</span><br><span class=\"line\">                <span class=\"string\">&quot;TASM /zi <span class=\"subst\">$&#123;file&#125;</span>&quot;</span>,</span><br><span class=\"line\">                <span class=\"string\">&quot;TLINK /v/3 <span class=\"subst\">$&#123;filename&#125;</span>.obj&quot;</span>,</span><br><span class=\"line\">                <span class=\"string\">&quot;TD <span class=\"subst\">$&#123;filename&#125;</span>.exe&quot;</span></span><br><span class=\"line\">            ]</span><br><span class=\"line\">        &#125;,</span><br><span class=\"line\">        <span class=\"string\">&quot;MASM-v6.11&quot;</span>: &#123;</span><br><span class=\"line\">            <span class=\"string\">&quot;baseBundle&quot;</span>: <span class=\"string\">&quot;&lt;built-in&gt;/MASM-v6.11.jsdos&quot;</span>,</span><br><span class=\"line\">            <span class=\"string\">&quot;before&quot;</span>: [</span><br><span class=\"line\">                <span class=\"string\">&quot;set PATH=C:<span class=\"char escape_\">\\\\</span>MASM&quot;</span></span><br><span class=\"line\">            ],</span><br><span class=\"line\">            <span class=\"string\">&quot;run&quot;</span>: [</span><br><span class=\"line\">                <span class=\"string\">&quot;masm <span class=\"subst\">$&#123;file&#125;</span>;&quot;</span>,</span><br><span class=\"line\">                <span class=\"string\">&quot;link <span class=\"subst\">$&#123;filename&#125;</span>;&quot;</span>,</span><br><span class=\"line\">                <span class=\"string\">&quot;&gt;<span class=\"subst\">$&#123;filename&#125;</span>&quot;</span></span><br><span class=\"line\">            ],</span><br><span class=\"line\">            <span class=\"string\">&quot;debug&quot;</span>: [</span><br><span class=\"line\">                <span class=\"string\">&quot;masm <span class=\"subst\">$&#123;file&#125;</span>;&quot;</span>,</span><br><span class=\"line\">                <span class=\"string\">&quot;link <span class=\"subst\">$&#123;filename&#125;</span>.OBJ;&quot;</span>,</span><br><span class=\"line\">                <span class=\"string\">&quot;&gt;debug <span class=\"subst\">$&#123;filename&#125;</span>.exe&quot;</span></span><br><span class=\"line\">            ]</span><br><span class=\"line\">        &#125;,</span><br><span class=\"line\">        <span class=\"string\">&quot;MASM-v5.00&quot;</span>: &#123;</span><br><span class=\"line\">            <span class=\"string\">&quot;baseBundle&quot;</span>: <span class=\"string\">&quot;&lt;built-in&gt;/MASM-v5.00.jsdos&quot;</span>,</span><br><span class=\"line\">            <span class=\"string\">&quot;before&quot;</span>: [</span><br><span class=\"line\">                <span class=\"string\">&quot;set PATH=C:<span class=\"char escape_\">\\\\</span>MASM&quot;</span></span><br><span class=\"line\">            ],</span><br><span class=\"line\">            <span class=\"string\">&quot;run&quot;</span>: [</span><br><span class=\"line\">                <span class=\"string\">&quot;masm <span class=\"subst\">$&#123;file&#125;</span>;&quot;</span>,</span><br><span class=\"line\">                <span class=\"string\">&quot;link <span class=\"subst\">$&#123;filename&#125;</span>;&quot;</span>,</span><br><span class=\"line\">                <span class=\"string\">&quot;&gt;<span class=\"subst\">$&#123;filename&#125;</span>&quot;</span></span><br><span class=\"line\">            ],</span><br><span class=\"line\">            <span class=\"string\">&quot;debug&quot;</span>: [</span><br><span class=\"line\">                <span class=\"string\">&quot;masm <span class=\"subst\">$&#123;file&#125;</span>;&quot;</span>,</span><br><span class=\"line\">                <span class=\"string\">&quot;link <span class=\"subst\">$&#123;filename&#125;</span>.OBJ;&quot;</span>,</span><br><span class=\"line\">                <span class=\"string\">&quot;&gt;debug <span class=\"subst\">$&#123;filename&#125;</span>.exe&quot;</span></span><br><span class=\"line\">            ],</span><br><span class=\"line\">            <span class=\"string\">&quot;support&quot;</span>: [</span><br><span class=\"line\">                <span class=\"string\">&quot;jsdos&quot;</span>,</span><br><span class=\"line\">                <span class=\"string\">&quot;dosbox&quot;</span>,</span><br><span class=\"line\">                <span class=\"string\">&quot;dosboxX&quot;</span>,</span><br><span class=\"line\">                <span class=\"string\">&quot;msdos player&quot;</span></span><br><span class=\"line\">            ]</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<h1 id=\"测试配置环境\"><a href=\"#测试配置环境\" class=\"headerlink\" title=\"测试配置环境\"></a>测试配置环境</h1><p>创建以.asm 为后缀的文件,将下面的代码复制上去,运行程序</p>\n<figure class=\"highlight x86asm\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">_<span class=\"number\">.</span>MODEL SMALL</span><br><span class=\"line\"><span class=\"meta\">.STACK</span> <span class=\"number\">100h</span></span><br><span class=\"line\"><span class=\"meta\"></span></span><br><span class=\"line\"><span class=\"meta\">.DATA</span></span><br><span class=\"line\">    message <span class=\"built_in\">DB</span> <span class=\"string\">&#x27;Hello, Assembly! Environment test successful!$&#x27;</span></span><br><span class=\"line\"><span class=\"meta\"></span></span><br><span class=\"line\"><span class=\"meta\">.CODE</span></span><br><span class=\"line\">MAIN PROC</span><br><span class=\"line\">    <span class=\"comment\">; 设置数据段地址</span></span><br><span class=\"line\">    <span class=\"keyword\">MOV</span> <span class=\"built_in\">AX</span>, @DATA</span><br><span class=\"line\">    <span class=\"keyword\">MOV</span> <span class=\"built_in\">DS</span>, <span class=\"built_in\">AX</span></span><br><span class=\"line\">    </span><br><span class=\"line\">    <span class=\"comment\">; 显示消息</span></span><br><span class=\"line\">    <span class=\"keyword\">MOV</span> <span class=\"number\">AH</span>, <span class=\"number\">09h</span>      <span class=\"comment\">; DOS功能：显示字符串</span></span><br><span class=\"line\">    <span class=\"keyword\">LEA</span> <span class=\"built_in\">DX</span>, message  <span class=\"comment\">; 加载消息地址</span></span><br><span class=\"line\">    <span class=\"keyword\">INT</span> <span class=\"number\">21h</span>          <span class=\"comment\">; 调用DOS中断</span></span><br><span class=\"line\">    </span><br><span class=\"line\">    <span class=\"comment\">; 返回DOS</span></span><br><span class=\"line\">    <span class=\"keyword\">MOV</span> <span class=\"number\">AH</span>, <span class=\"number\">4Ch</span>      <span class=\"comment\">; DOS功能：结束程序</span></span><br><span class=\"line\">    <span class=\"keyword\">INT</span> <span class=\"number\">21h</span>          <span class=\"comment\">; 调用DOS中断</span></span><br><span class=\"line\">MAIN ENDP</span><br><span class=\"line\">__END MAIN_</span><br></pre></td></tr></table></figure>\n\n<blockquote>\n<p>注意:</p>\n<ul>\n<li>路径中最好不要有中文,如果有中文的话可以将项目路径设置为没有中文的路径中再运行</li>\n<li>程序如果要调试的话,需要先调试</li>\n<li>如果运行报错的话一般都是因为路径的问题,可以使用,先启动dox环境再自己编译,链接和运行,完成以后再使用调试的功能</li>\n</ul>\n<p>eg:<br>编译:masm E1.asm;</p>\n<p>链接:link E1.obj;</p>\n<p>运行:E1.exe</p>\n<p>然后才能debug</p>\n<p><img src=\"https://tk-pichost-1325224430.cos.ap-chengdu.myqcloud.com/blog/17465878142961746587813440.png\" alt=\"17465878142961746587813440.png\"></p>\n</blockquote>\n<p><img src=\"https://tk-pichost-1325224430.cos.ap-chengdu.myqcloud.com/blog/1746454883775Er3IbHOLQoATO9xPoIYcDBMznKd.png\" alt=\"1746454883775Er3IbHOLQoATO9xPoIYcDBMznKd.png\"></p>\n<p>出现上面的信息说明基础环境配置成功!</p>\n<h1 id=\"Extension-Settings-拓展设置说明\"><a href=\"#Extension-Settings-拓展设置说明\" class=\"headerlink\" title=\"Extension Settings 拓展设置说明\"></a>Extension Settings 拓展设置说明</h1><p>要实现完整的功能，需要在拓展中进行设置，同时”设置(首选项)”中还有一些其他选项，以提供更大的灵活性。</p>\n<h3 id=\"汇编工具选择\"><a href=\"#汇编工具选择\" class=\"headerlink\" title=\"汇编工具选择\"></a>汇编工具选择</h3><ul>\n<li>选择使用 MASM 还是 TASM</li>\n</ul>\n<h3 id=\"16-位模拟器选择\"><a href=\"#16-位模拟器选择\" class=\"headerlink\" title=\"16 位模拟器选择\"></a>16 位模拟器选择</h3><ul>\n<li><p><strong>DOSBox</strong>：（默认模式）更加完善</p>\n</li>\n<li><p><strong>msdos-player</strong>：可以在 cmd 中运行，不会弹出窗口，但对 TD 等图形化界面的处理效果不好</p>\n</li>\n<li><p><strong>auto</strong>：（推荐，但是有时无法工作）根据情况选择模拟工具：</p>\n<ul>\n<li>汇编链接使用 msdos-player 模拟，会比较安静</li>\n<li>运行使用 DOSBox，更加直观稳定</li>\n<li>调试中 MASM(debug)使用 msdos-palyer 在 windows 集成终端中显示（更加美观一些）</li>\n<li>调试中 TASM(TD)在 DOSBox 中运行（目前只能这样）</li>\n</ul>\n</li>\n</ul>\n<h3 id=\"其他配置选项\"><a href=\"#其他配置选项\" class=\"headerlink\" title=\"其他配置选项\"></a>其他配置选项</h3><ul>\n<li>调整 dosbox 窗口大小</li>\n<li>规定 dosbox 运行程序之后进行什么操作（是否直接退出程序，还是等待）</li>\n<li>启动相关功能之前是否先保存文件（不保存的话，只能操作之前保存的版本，建议保存）</li>\n<li>设置自定义汇编工具路径</li>\n</ul>\n"},{"title":"2025-05-09-进程调度算法分析","date":"2025-05-08T16:00:00.000Z","_content":"# 进程调度算法分析\n\n# 参考资料\n\n> - [一文看懂 Linux 内核调度分析（进程调度）一](https://zhuanlan.zhihu.com/p/543205467)\n> - [Linux 内核中常见的进程调度算法](https://zhuanlan.zhihu.com/p/661863529)\n> - [Linux 进程调度算法_linux 调度算法-CSDN 博客](https://blog.csdn.net/qq_41897304/article/details/130194906)\n> - [大厂面试爱问的「调度算法」，20 张图一举拿下 - 小林 coding - 博客园](https://www.cnblogs.com/xiaolincoding/p/13631224.html)\n> - [gregsnotes.medium.com](https://gregsnotes.medium.com/how-do-cpus-execute-instructions-in-parallel-dfa15e87a86c)\n\n# 概述\n\n## 调度指标与目标\n\n![1749361099852GUHDb2WbvordpDxnuNEcIg0zn0b.png](https://gitee.com/tanke11223344/imagehost/raw/main/blog/1749361099852GUHDb2WbvordpDxnuNEcIg0zn0b.png)\n\n单核 CPU 处理多个进程和线程\n\n操作系统进程调度的核心目标在于合理分配 CPU 资源，使系统能够同时满足多个性能指标。常见的评估指标包括：\n\n1. **CPU 利用率（CPU Utilization）**\n\n- CPU 在单位时间内非空闲状态的比例。理想情况下应尽量接近 100%。\n\n1. **吞吐量（Throughput）**\n\n- 单位时间内完成的作业（或进程）数量。吞吐量越高，单位时间完成任务越多。\n\n1. **周转时间（Turnaround Time）**\n\n- 从进程提交（到达）到完全执行结束所经历的总时间。\n\n$$\n\\text{Turnaround Time} = \\text{完成时间} - \\text{到达时间}\n$$\n\n1. **带权周转时间（Weighted Turnaround Time）**\n\n- 周转时间与执行时间之比，用于衡量短作业或长作业的相对等待公平性。\n\n$$\n\\text{Weighted Turnaround Time} = \\frac{\\text{Turnaround Time}}{\\text{执行时间}}\n$$\n\n1. **等待时间（Waiting Time）**\n\n- 进程在就绪队列中等待 CPU 的累积时间。\n\n$$\n\\text{Waiting Time} = \\text{Turnaround Time} - \\text{执行时间}\n$$\n\n1. **响应时间（Response Time）**\n\n- 从进程提交到系统开始响应（第一次分配 CPU）的时间。\n\n$$\n\\text{Response Time} = \\text{第一次调度时间} - \\text{到达时间}\n$$\n\n1. **公平性**\n\n- 同类进程应获得相似的资源分配和等待时间；避免饥饿（Starvation）。\n\n不同的调度算法在上述指标上表现各异，系统应根据场景需求权衡：\n\n- **交互式系统**：关注响应时间（如 GUI 系统、服务器应用）。\n- **批处理系统**：关注吞吐量与周转时间（如科学计算、大规模数据处理）。\n- **实时系统**：关注任务能否在规定的截止时间前完成，使用实时调度算法（如 Rate Monotonic Scheduling、Earliest Deadline First）。\n\n---\n\n## 调度算法的分类\n\n根据是否支持抢占（Preemptive）和队列策略，可将操作系统中的调度算法大致分为两类：\n\n1. **非抢占式调度（Non-preemptive Scheduling）**\n\n- 一旦进程被分配 CPU，直到该进程自愿放弃 CPU（如执行完成或进入 I/O 阻塞）才会切换。\n- 算法典型：先来先服务 (FCFS)、短作业优先 (SJF，非抢占版本)、优先级非抢占。\n\n1. **抢占式调度（Preemptive Scheduling）**\n\n- 若有更高优先级的进程到达或某种时间片用尽，会强制剥夺当前进程的 CPU。\n- 算法典型：短剩余时间优先 (SRTF)、优先级抢占、时间片轮转 (RR)、多级反馈队列等。\n\n此外，按照就绪队列结构的不同，调度亦可分为：\n\n- **单级队列（Single Queue）**：所有就绪进程放在同一队列中，统一调度（上述 FCFS、SJF、RR 等）。\n- **多级队列（Multi-Level Queue）**：根据进程类型（交互式 vs 批处理）、优先级等分类，将进程放入多个队列，根据队列优先级逐级调度。\n- **多级反馈队列（Multi-Level Feedback Queue, MLFQ）**：在多级队列的基础上，允许进程在不同队列间动态迁移，从而兼顾响应时间和吞吐量。\n\n---\n\n## 常见单队列调度算法\n\n### 先来先服务 (FCFS)\n\n**概念**：\n\n![1749361112852SlmPb1s55oPHr4xbKuxcR095nZc.png](https://gitee.com/tanke11223344/imagehost/raw/main/blog/1749361112852SlmPb1s55oPHr4xbKuxcR095nZc.png)\n\n- 最简单的调度算法，类比数据结构中的队列,按照进程到达就绪队列的先后顺序分配 CPU，不做抢占。\n- 类似排队买票：先到先服务。\n\n**基本流程**：\n\n1. 就绪队列中，按照到达时间排序。\n2. CPU 空闲时，从队头取出第一个进程执行，运行完毕后再取下一个。\n\n**优点**：\n\n- 实现简单，易于理解和维护。\n- 进程切换开销少，无抢占导致的上下文切换开销。\n\n**缺点**：\n\n- **等待时间不可控**：一旦前面有一个长作业，后续短作业就会被“长作业阻塞”（Convoy Effect），导致平均等待时间变长。\n- **平均周转时间较大**：对短作业不友好。\n- **无差别对待**：不支持优先级，易造成关键任务延迟。\n\n**适用场景**：\n\n- 适合批处理系统中长时间运行、无需交互的作业调度。\n\n---\n\n### 短作业优先 (SJF) 与 最短剩余时间优先 (SRTF)\n\n#### 短作业优先 (SJF, Shortest Job First)\n\n**概念**：\n\n![1749361121852DiHgbhn6Lo2tr7xuqvscwpi2nxg.png](https://gitee.com/tanke11223344/imagehost/raw/main/blog/1749361121852DiHgbhn6Lo2tr7xuqvscwpi2nxg.png)\n\n- 按照进程的估计执行时间（CPU Burst）长短来调度，优先选择执行时间最短的进程（非抢占）。\n- 可以最大化减少平均等待时间。\n\n**流程**：\n\n1. 当 CPU 空闲时，从就绪队列中选择执行时间最短的进程。\n2. 该进程运行至完成，然后再次从剩余进程中选择最短的继续。\n\n**优点**：\n\n- 平均等待时间最小（经证明）。\n\n**缺点**：\n\n- **需要预知执行时间**：在实际系统中很难准确知道每个进程的执行时间，只能通过历史统计或猜测。\n- **可能导致饥饿**：如果系统中不断有短作业到来，长作业可能一直得不到执行机会。\n\n#### 最短剩余时间优先 (SRTF, Shortest Remaining Time First)\n\n**概念**：\n\n- 是 SJF 的抢占式版本。\n- 当有新进程到达，若其估计总执行时间小于当前正在执行进程的剩余执行时间，则抢占当前进程，优先执行新进程。\n\n**流程**：\n\n1. 维护就绪队列中各进程的剩余执行时间。\n2. 当新进程到达或某进程完成后，重新比较就绪队列中剩余时间最小的进程；若与当前执行进程不同，则进行抢占切换。\n\n**优点**：\n\n- 平均等待时间更小，响应更及时。\n\n**缺点**：\n\n- **更频繁的上下文切换**：可能每次新进程到来都要抢占，增加系统负载。\n- **难以预测与饥饿问题**：同样存在长进程饥饿风险。\n\n**适用场景**：\n\n- 对平均等待时间要求很高、可接受大量切换开销的批处理环境。\n\n---\n\n### 优先级调度 (Priority Scheduling)\n\n**概念**：\n\n![1749361133852G5ACbX27MoyabGxHSPOcVVCenIg.png](https://gitee.com/tanke11223344/imagehost/raw/main/blog/1749361133852G5ACbX27MoyabGxHSPOcVVCenIg.png)\n\n- 每个进程都与一个优先级（Priority）相关联，调度时始终选择优先级最高（数值最小或最大，取决于实现约定）的进程执行。\n- 可分为非抢占式优先级调度和抢占式优先级调度：\n- **非抢占式优先级**：一旦进程被选中，直到它完成或自愿阻塞，其他高优先级进程到达也不能抢占。\n- **抢占式优先级**：如果有更高优先级的进程到达，会中断当前进程并调度高优先级进程执行。\n\n**优点**：\n\n- 可以根据任务重要程度分配资源，实现“关键任务优先”。\n\n**缺点**：\n\n- **饥饿（Starvation）**：低优先级进程可能长时间无法获得 CPU。如果系统中高优先级任务持续到达，则低优先级任务可能永远得不到服务。\n- **优先级反转（Priority Inversion）**：低优先级进程持有资源（如锁），阻止高优先级进程执行，造成高优先级任务等待。可通过“优先级继承”等机制缓解。\n\n**优先级分配策略**：\n\n- **静态优先级**：在进程创建时分配，不随运行时变化。\n- **动态优先级**：随着进程运行行为或等待时间动态调整。例如：长时间在就绪队列中等待，优先级随时间递增；使用 “ aging” 技术防止饥饿。\n\n---\n\n### 时间片轮转 (Round Robin, RR)\n\n**概念**：\n\n![1749361149087XcrFbh95yoJy1VxxOlhcL4p3nne.png](https://gitee.com/tanke11223344/imagehost/raw/main/blog/1749361149087XcrFbh95yoJy1VxxOlhcL4p3nne.png)\n\n- 将 CPU 时间分成若干固定长度的时间片（Time Quantum），系统维护一个进程就绪队列（通常是 FIFO）。\n- 每次调度时，将队头进程分配一个完整时间片或直到进程自行阻塞（I/O）／完成。时间片用完后，将该进程移动到队尾，依此循环。\n\n**流程**：\n\n1. 初始化就绪队列，所有进程先按到达顺序加入队列。\n2. 系统为队头进程分配时钟中断，每次时钟中断到来时：\n\n- 若进程尚未完成，且时间片已用完，则将其移动到队尾；\n- 若进程完成或主动阻塞，直接移除或放入相应 I/O 等待队列。\n\n1. 选取下一个队头进程，重复上述步骤。\n\n**关键参数**：\n\n- **时间片大小 (Quantum)**：\n- 小时间片 → 系统响应快，适合交互式处理；但上下文切换频繁，开销大。\n- 大时间片 → 切换开销小，但响应时间变长，接近 FCFS 效果。\n- 通常取值应使上下文切换开销远小于时间片时长（如上下文切换需要 1–2 μs，时间片一般设为 10–100 ms）。\n\n**优点**：\n\n- 对所有进程一视同仁，易于实现和理解；\n- 响应时间有保证（最坏响应时间 = 时间片 × 就绪进程数）；\n- 无饥饿，进程最终会被分配 CPU。\n\n**缺点**：\n\n- 需要设置合适时间片；\n- 上下文切换带来额外开销；\n- 对 CPU 密集型与 I/O 密集型进程无区分，可能浪费时间片给 CPU 密集型作业；\n- 如果时间片与进程执行时间不匹配，则吞吐量和周转时间可能不理想。\n\n**适用场景**：\n\n- 交互式系统，要求快速响应用户输入的环境（如终端、桌面交互系统）。\n\n---\n\n## 多级队列调度与多级反馈队列调度\n\n### 4.1. 多级队列调度 (Multi-Level Queue)\n\n**概念**：\n\n- 根据进程的类别、优先级、服务需求等，将进程划分到不同的就绪队列中。每个队列可应用不同的调度算法或不同时间片长度。\n- 各队列本身也按照优先级排列。当 CPU 空闲时，始终从最高优先级队列调度，若高优先级队列为空，才调度低优先级队列。\n\n**队列示例**：\n\n- **系统交互进程队列**：RR 调度，时间片短；\n- **批处理进程队列**：FCFS 调度；\n- **守护进程队列**：优先级调度或 FCFS；\n\n**特点**：\n\n- 不同类型进程获得不同的服务策略；\n- 各队列永久划分，不动态调整。\n\n**缺点**：\n\n- 需要在设计阶段预先进行进程分类，不灵活；\n- 高优先级队列如果繁忙，低优先级队列可能饥饿。\n\n---\n\n### 多级反馈队列调度 (Multi-Level Feedback Queue, MLFQ)\n\n**概念**：\n\n时间片轮转和最高优先级算法的综合和拓展\n\n- 「多级」表示有多个队列，每个队列优先级从高到低，同时优先级越高时间片越短。\n- 「反馈」表示如果有新的进程加入优先级高的队列时，立刻停止当前正在运行的进程，转而去运行优先级高的队列；\n\n![1749361161852T6LZbQZ7Fon2d3xWr17cscH5nWw.png](https://gitee.com/tanke11223344/imagehost/raw/main/blog/1749361161852T6LZbQZ7Fon2d3xWr17cscH5nWw.png)\n\n- 在多级队列基础上，为了提高灵活性，允许进程在不同队列间根据行为“反馈”向下或向上移动。\n- 目标：使得 I/O 密集型（短 CPU burst）进程获得较高优先级，CPU 密集型（长 CPU burst）进程优先级逐渐降低，从而兼顾系统响应性和吞吐量。\n\n**常见策略参数**：\n\n1. **队列数 (N)**：一般设为 3–5 级，从高到低优先级递减编号。\n2. **时间片 (Quantum)**：不同队列拥有不同时间片长度。一般高优先级队列时间片短（例如 8ms），中/低级队列时间片依次加倍（16ms、32ms）。\n3. **晋升与降级规则**：\n\n- **降级**：进程若在本级队列用完完整时间片（表明可能较 CPU 密集），则移动到下一低级队列；\n- **晋升（或 Aging）**：为了防止长期在低级队列的进程饥饿，可在一定条件下（如等待时间超过阈值）将其提升至更高级队列。\n\n**典型流程**：\n\n1. 所有进程初始进入最高优先级队列（队列 0）。\n2. CPU 空闲时，从优先级最高且非空队列选取队头进程执行一个时间片或至该进程阻塞/完成。\n3. 若用完时间片且仍未完成，则降级到下一级队列尾。\n4. 若在某队列执行过程中阻塞（如进入 I/O），则保持在当前队列级别（或执行完成后重新进入高优先级队列，具体实现可不同）。\n5. 周期性或按需检查低级队列中的进程等待时间，执行晋升。\n\n**优点**：\n\n- 区分不同工作特征的进程（I/O 密集 vs CPU 密集），提高响应速度；\n- 通过动态反馈减少饥饿。\n\n**缺点**：\n\n- 参数较多（队列数、时间片长度、晋升/降级阈值等），需要调优；\n- 实现复杂度较高；\n- 若设计不合理，仍可能出现低优先级进程饥饿。\n\n**适用场景**：\n\n- 一般通用操作系统（如 Linux 的 O(1) 调度器、早期 UNIX 调度），可兼顾交互式任务与后台批处理任务。\n- 要求较高响应性的桌面系统或要求分时公平性的多用户系统。\n\n---\n\n## 调度算法的性能评估示例\n\n下面通过假设的进程集合与到达时间、执行（CPU）时间示例，分别在 FCFS、SJF/SRTF、RR、和多级反馈队列环境下进行调度，计算关键指标并进行比较。\n\n### 示例流程与假设数据\n\n假设有 5 个进程，属性如下：\n\n<table>\n<tr>\n<td>进程 PID<br/></td><td>到达时间 (Arrival)<br/></td><td>CPU 执行时间 (Burst)<br/></td><td>优先级 (Priority)\\*<br/></td></tr>\n<tr>\n<td>P1<br/></td><td>0<br/></td><td>8<br/></td><td>2<br/></td></tr>\n<tr>\n<td>P2<br/></td><td>1<br/></td><td>4<br/></td><td>1<br/></td></tr>\n<tr>\n<td>P3<br/></td><td>2<br/></td><td>9<br/></td><td>3<br/></td></tr>\n<tr>\n<td>P4<br/></td><td>3<br/></td><td>5<br/></td><td>2<br/></td></tr>\n<tr>\n<td>P5<br/></td><td>4<br/></td><td>2<br/></td><td>1<br/></td></tr>\n</table>\n\n> \\*仅在优先级调度或 MLFQ 中使用，数值越小优先级越高。\n\n- 假设系统在时刻 0 之后开始调度，并且已知所有进程到达时间与执行时间。\n- 时间单位可视为毫秒 (ms)。\n\n我们分别对以下调度算法进行分析：\n\n1. FCFS (非抢占)\n2. SJF (假设非抢占)\n3. SRTF (抢占式短作业优先)\n4. RR (时间片 = 3)\n5. 多级反馈队列 (3 级队列，时间片分别 4、8、∞；无晋升)\n\n### FCFS 调度示例分析\n\n#### 调度顺序\n\n<table>\n<tr>\n<td>时间区间<br/></td><td>执行进程<br/></td></tr>\n<tr>\n<td>0–8<br/></td><td>P1<br/></td></tr>\n<tr>\n<td>8–12<br/></td><td>P2<br/></td></tr>\n<tr>\n<td>12–21<br/></td><td>P3<br/></td></tr>\n<tr>\n<td>21–26<br/></td><td>P4<br/></td></tr>\n<tr>\n<td>26–28<br/></td><td>P5<br/></td></tr>\n</table>\n\n解释：\n\n- 时刻 0：P1 到达，分配 CPU；\n- P1 用到时刻 8 才完成；\n- 时刻 1–4 期间，P2、P3、P4、P5 依序到达并进入队列；\n- 时刻 8：CPU 分配给队列头进程 P2（到达时间最早）；\n- 依此类推。\n\n#### 关键指标计算\n\n<table>\n<tr>\n<td>PID<br/></td><td>到达时间<br/></td><td>完成时间 (Finish)<br/></td><td>周转时间 = Finish - Arrival<br/></td><td>执行时间 (Burst)<br/></td><td>等待时间 = Turnaround - Burst<br/></td></tr>\n<tr>\n<td>P1<br/></td><td>0<br/></td><td>8<br/></td><td>8<br/></td><td>8<br/></td><td>0<br/></td></tr>\n<tr>\n<td>P2<br/></td><td>1<br/></td><td>12<br/></td><td>11<br/></td><td>4<br/></td><td>7<br/></td></tr>\n<tr>\n<td>P3<br/></td><td>2<br/></td><td>21<br/></td><td>19<br/></td><td>9<br/></td><td>10<br/></td></tr>\n<tr>\n<td>P4<br/></td><td>3<br/></td><td>26<br/></td><td>23<br/></td><td>5<br/></td><td>18<br/></td></tr>\n<tr>\n<td>P5<br/></td><td>4<br/></td><td>28<br/></td><td>24<br/></td><td>2<br/></td><td>22<br/></td></tr>\n</table>\n\n- **平均周转时间**\n\n$$\n\\frac{8 + 11 + 19 + 23 + 24}{5} = \\frac{85}{5} = 17\n$$\n\n- **平均等待时间**\n\n$$\n\\frac{0 + 7 + 10 + 18 + 22}{5} = \\frac{57}{5} = 11.4\n$$\n\n- **平均带权周转时间**\n\n$$\n\\frac{8/8 + 11/4 + 19/9 + 23/5 + 24/2}{5} = \\frac{1 + 2.75 + 2.11 + 4.6 + 12}{5} \\approx \\frac{22.46}{5} = 4.49\n$$\n\n---\n\n### SJF/SRTF 调度示例分析\n\n#### 非抢占式 SJF\n\n- 排除尚未到达的进程，只在 CPU 空闲且队列中已有进程时进行选择。\n\n**调度顺序**：\n\n1. 时刻 0，P1 到达，CPU 分配给 P1。\n2. P1 执行到 8，期间 P2(1)、P3(2)、P4(3)、P5(4) 到达，队列内剩余执行时间分别 $P2:4, P3:9, P4:5, P5:2$。\n3. CPU 空闲时，于时刻 8 选择执行时间最短的 P5（Burst=2），执行 8–10。\n4. 时刻 10 选择剩余执行时间最短的 P2（Burst=4），执行 10–14。\n5. 时刻 14 选择 P4（Burst=5），执行 14–19。\n6. 最后执行 P3（Burst=9），时刻 19–28。\n\n<table>\n<tr>\n<td>时间区间<br/></td><td>执行进程<br/></td></tr>\n<tr>\n<td>0–8<br/></td><td>P1<br/></td></tr>\n<tr>\n<td>8–10<br/></td><td>P5<br/></td></tr>\n<tr>\n<td>10–14<br/></td><td>P2<br/></td></tr>\n<tr>\n<td>14–19<br/></td><td>P4<br/></td></tr>\n<tr>\n<td>19–28<br/></td><td>P3<br/></td></tr>\n</table>\n\n#### SJF 指标计算\n\n<table>\n<tr>\n<td>PID<br/></td><td>到达<br/></td><td>完成<br/></td><td>周转 = 完成−到达<br/></td><td>执行<br/></td><td>等待 = 周转 − 执行<br/></td></tr>\n<tr>\n<td>P1<br/></td><td>0<br/></td><td>8<br/></td><td>8<br/></td><td>8<br/></td><td>0<br/></td></tr>\n<tr>\n<td>P2<br/></td><td>1<br/></td><td>14<br/></td><td>13<br/></td><td>4<br/></td><td>9<br/></td></tr>\n<tr>\n<td>P3<br/></td><td>2<br/></td><td>28<br/></td><td>26<br/></td><td>9<br/></td><td>17<br/></td></tr>\n<tr>\n<td>P4<br/></td><td>3<br/></td><td>19<br/></td><td>16<br/></td><td>5<br/></td><td>11<br/></td></tr>\n<tr>\n<td>P5<br/></td><td>4<br/></td><td>10<br/></td><td>6<br/></td><td>2<br/></td><td>4<br/></td></tr>\n</table>\n\n- 平均周转时间：$(8 + 13 + 26 + 16 + 6)/5 = 69/5 = 13.8$\n- 平均等待时间：$(0 + 9 + 17 + 11 + 4)/5 = 41/5 = 8.2$\n\n相比 FCFS，SJF 平均周转、等待时间更低。\n\n---\n\n#### 5.3.2. 抢占式 SRTF\n\n在 SJF 基础上，当有新进程到达且其剩余执行时间小于当前正在执行进程的剩余时间时，会发生抢占。\n\n**调度细节**：\n\n- 时刻 0–1：P1 执行 0–1（剩余 7）\n- 时刻 1：P2 到达 (Burst=4)，7 (P1 剩余) > 4 → 抢占。P2 执行 1–2（剩余 3），P1 剩余 7\n- 时刻 2：P3 到达 (Burst=9)，当前最短为 P2(3)，继续。P2 执行 2–3（剩余 2）\n- 时刻 3：P4 到达 (Burst=5)，当前最短为 P2(2)，继续。P2 执行 3–4（剩余 1）\n- 时刻 4：P5 到达 (Burst=2)，此时 P2(1) 与 P5(2)，P2 更短 → P2 执行 4–5（完成）\n- 较早完成 P2，队列剩余 P1(7)、P3(9)、P4(5)、P5(2)\n- 时刻 5：当前最短 P5(Burst=2)，执行 5–7（完成）\n- 时刻 7：队列剩余 P1(7)、P3(9)、P4(5)，最短为 P4(5)，执行 7–12（剩余 0 → 完成）\n- 时刻 12：剩余 P1(7)、P3(9)，选择 P1(7)，执行 12–19（完成）\n- 时刻 19–28：最后 P3(9)，执行到 28（完成）\n\n<table>\n<tr>\n<td>时间区间<br/></td><td>执行进程<br/></td></tr>\n<tr>\n<td>0–1<br/></td><td>P1<br/></td></tr>\n<tr>\n<td>1–4<br/></td><td>P2<br/></td></tr>\n<tr>\n<td>4–5<br/></td><td>P2<br/></td></tr>\n<tr>\n<td>5–7<br/></td><td>P5<br/></td></tr>\n<tr>\n<td>7–12<br/></td><td>P4<br/></td></tr>\n<tr>\n<td>12–19<br/></td><td>P1<br/></td></tr>\n<tr>\n<td>19–28<br/></td><td>P3<br/></td></tr>\n</table>\n\n注意：由于多个时间点属于同一进程的继续执行，合并相邻时间段可简化为：\n\n```\nP1: 0−1, 12−19  \nP2: 1−5  \nP5: 5−7  \nP4: 7−12  \nP3: 19−28\n```\n\n#### SRTF 指标计算\n\n<table>\n<tr>\n<td>PID<br/></td><td>到达<br/></td><td>完成<br/></td><td>周转 = 完成−到达<br/></td><td>执行时间<br/></td><td>等待 = 周转 − 执行<br/></td></tr>\n<tr>\n<td>P1<br/></td><td>0<br/></td><td>19<br/></td><td>19<br/></td><td>8<br/></td><td>11<br/></td></tr>\n<tr>\n<td>P2<br/></td><td>1<br/></td><td>5<br/></td><td>4<br/></td><td>4<br/></td><td>0<br/></td></tr>\n<tr>\n<td>P3<br/></td><td>2<br/></td><td>28<br/></td><td>26<br/></td><td>9<br/></td><td>17<br/></td></tr>\n<tr>\n<td>P4<br/></td><td>3<br/></td><td>12<br/></td><td>9<br/></td><td>5<br/></td><td>4<br/></td></tr>\n<tr>\n<td>P5<br/></td><td>4<br/></td><td>7<br/></td><td>3<br/></td><td>2<br/></td><td>1<br/></td></tr>\n</table>\n\n- 平均周转时间：$(19 + 4 + 26 + 9 + 3)/5 = 61/5 = 12.2$\n- 平均等待时间：$(11 + 0 + 17 + 4 + 1)/5 = 33/5 = 6.6$\n\n相比 SJF，SRTF 的平均等待、周转时间略有改进，但切换开销更高。\n\n---\n\n### RR 调度示例分析（时间片 = 3）\n\n**假设时间片（Quantum） = 3**。采用抢占式策略，时钟中断每 3 单位触发一次。\n\n#### 调度步骤\n\n![1749361179853Sytlb2qLco04MixG0i5cz3AFnxd.png](https://gitee.com/tanke11223344/imagehost/raw/main/blog/1749361179853Sytlb2qLco04MixG0i5cz3AFnxd.png)\n\n1. **时刻 0–1**\n\n- P1 到达并开始执行。\n- 经过 1 单位（时刻 1），P2 到达，仍在 P1 时间片内继续。剩余时间：P1 (7)。\n\n1. **时刻 1–3**\n\n- P1 继续执行至用完剩余时间片（3 单位），时刻 3 停止，剩余 P1(5)。\n- 队列顺序：P2 (到达时刻 1)、P3(2)、P4(3)。\n\n1. **时刻 3–6**\n\n- 从队头取 P2（执行 3 单位），时刻 6 剩余 P2（1）。\n- 新到达 P5(4) 已在队列尾。队列顺序：P3、P4、P5、P1（回到队尾）、P2(1)。\n\n1. **时刻 6–9**\n\n- 执行 P3 3 单位，时刻 9 剩余 P3(6)。队列：P4、P5、P1(5)、P2(1)、P3(6)。\n\n1. **时刻 9–12**\n\n- 执行 P4 3 单位，时刻 12 剩余 P4(2)。队列：P5、P1(5)、P2(1)、P3(6)、P4(2)。\n\n1. **时刻 12–14**\n\n- 执行 P5 2 单位（用完）、时刻 14 完成。队列：P1(5)、P2(1)、P3(6)、P4(2)。\n\n1. **时刻 14–17**\n\n- 执行 P1 3 单位，时刻 17 剩余 P1(2)。队列：P2(1)、P3(6)、P4(2)、P1(2)。\n\n1. **时刻 17–18**\n\n- 执行 P2 1 单位（完成），时刻 18。队列：P3(6)、P4(2)、P1(2)。\n\n1. **时刻 18–21**\n\n- 执行 P3 3 单位，时刻 21 剩余 P3(3)。队列：P4(2)、P1(2)、P3(3)。\n\n1. **时刻 21–23**\n\n   * 执行 P4 2 单位（完成），时刻 23。队列：P1(2)、P3(3)。\n2. **时刻 23–25**\n\n   * 执行 P1 2 单位（完成），时刻 25。队列：P3(3)。\n3. **时刻 25–28**\n\n   * 执行 P3 3 单位（完成），时刻 28。队列空。\n\n#### 调度时间线（Gantt 图）\n\n![1749361187852I1ojbIWGEoHOfLxgZsJciFdWnqd.png](https://gitee.com/tanke11223344/imagehost/raw/main/blog/1749361187852I1ojbIWGEoHOfLxgZsJciFdWnqd.png)\n\n合并表示为各个片段与时间区间：\n\n```\n[0−3]: P1  \n[3−6]: P2  \n[6−9]: P3  \n[9−12]: P4  \n[12−14]: P5  \n[14−17]: P1  \n[17−18]: P2  \n[18−21]: P3  \n[21−23]: P4  \n[23−25]: P1  \n[25−28]: P3\n```\n\n#### RR 指标计算\n\n<table>\n<tr>\n<td>PID<br/></td><td>到达<br/></td><td>完成<br/></td><td>周转 = 完成−到达<br/></td><td>执行时间<br/></td><td>等待 = 周转−执行<br/></td></tr>\n<tr>\n<td>P1<br/></td><td>0<br/></td><td>25<br/></td><td>25<br/></td><td>8<br/></td><td>17<br/></td></tr>\n<tr>\n<td>P2<br/></td><td>1<br/></td><td>18<br/></td><td>17<br/></td><td>4<br/></td><td>13<br/></td></tr>\n<tr>\n<td>P3<br/></td><td>2<br/></td><td>28<br/></td><td>26<br/></td><td>9<br/></td><td>17<br/></td></tr>\n<tr>\n<td>P4<br/></td><td>3<br/></td><td>23<br/></td><td>20<br/></td><td>5<br/></td><td>15<br/></td></tr>\n<tr>\n<td>P5<br/></td><td>4<br/></td><td>14<br/></td><td>10<br/></td><td>2<br/></td><td>8<br/></td></tr>\n</table>\n\n- 平均周转时间：$(25 + 17 + 26 + 20 + 10)/5 = 98/5 = 19.6$\n- 平均等待时间：$(17 + 13 + 17 + 15 + 8)/5 = 70/5 = 14$\n\n相比 FCFS、SJF/SRTF，RR 的平均等待与周转时间更高，但响应时间更有保障（最坏响应时间为 3× 队列长度 ≈ 3×5 = 15）。\n\n---\n\n### 多级反馈队列示例分析\n\n#### 参数假设\n\n- **队列数**：3（Q0、Q1、Q2），优先级从高到低依次为 Q0 > Q1 > Q2。\n- **时间片**：\n- Q0: 4\n- Q1: 8\n- Q2: FCFS（不再分时间片，相当于单独的 FCFS 队列）\n- **进入队列规则**：\n\n1. 所有进程初始进入 Q0。\n2. 在 Q0 中用完 4 单位还未完成，则降级到 Q1 队尾；\n3. 在 Q1 中用完 8 单位还未完成，则降级到 Q2 队尾；\n4. 在 Q2 中 FCFS 执行直至完成（不再降级）。\n5. 未用满本级时间片而发生阻塞，则保持本级队列（按到达顺序放回队尾）。\n6. 无晋升机制（简化模型）。\n\n#### 调度流程\n\n1. **时刻 0–4**\n\n- Q0 队列：P1(8) → 执行 4 单位至 剩余 P1(4)，时刻 4，降级至 Q1 队尾。\n- 在时刻 1–4，P2(4)、P3(9)、P4(5)、P5(2) 先后到达，依次进入 Q0 队尾。\n\n1. **时刻 4–8**\n\n- Q0 调度队头为 P2(4) → 执行 4 单位 完成，时刻 8。\n- Q0 队列剩余：P3(9)、P4(5)、P5(2)\n\n1. **时刻 8–12**\n\n- Q0 队头 P3(9) → 执行 4 单位，剩余 P3(5)，时刻 12，降级到 Q1 队尾。\n- Q0 队列剩余：P4(5)、P5(2)\n\n1. **时刻 12–16**\n\n- Q0 队头 P4(5) → 执行 4 单位，剩余 P4(1)，时刻 16，降级到 Q1 队尾。\n- Q0 队列剩余：P5(2)\n\n1. **时刻 16–18**\n\n- Q0 队头 P5(2) → 执行 2 单位 完成（未用满时片），时刻 18。\n- Q0 队列空，此时切换到 Q1 队列。\n\n1. **Q1 轮询**\n\n- Q1 队列：\n\n  1. P1(4) → 执行 4 单位 完成，时刻 22（未用满时片、直接完成，出列）。\n  2. P3(5) → 执行 5 单位 完成，时刻 27（未用满时片、直接完成）。\n  3. P4(1) → 执行 1 单位 完成，时刻 28。\n\n1. **Q2**\n\n- 对本示例数据，无进程在 Q1 用满 8 单位，因此 Q2 无进程。\n\n#### 调度时间线（简化）\n\n```\n[0−4]   P1 (Q0)  \n[4−8]   P2 (Q0)  \n[8−12]  P3 (Q0)  \n[12−16] P4 (Q0)  \n[16−18] P5 (Q0)  \n[18−22] P1 (Q1)  \n[22−27] P3 (Q1)  \n[27−28] P4 (Q1)\n```\n\n#### 多级反馈队列指标计算\n\n<table>\n<tr>\n<td>PID<br/></td><td>到达<br/></td><td>完成<br/></td><td>周转 = 完成−到达<br/></td><td>执行时间<br/></td><td>等待 = 周转 − 执行<br/></td></tr>\n<tr>\n<td>P1<br/></td><td>0<br/></td><td>22<br/></td><td>22<br/></td><td>8<br/></td><td>14<br/></td></tr>\n<tr>\n<td>P2<br/></td><td>1<br/></td><td>8<br/></td><td>7<br/></td><td>4<br/></td><td>3<br/></td></tr>\n<tr>\n<td>P3<br/></td><td>2<br/></td><td>27<br/></td><td>25<br/></td><td>9<br/></td><td>16<br/></td></tr>\n<tr>\n<td>P4<br/></td><td>3<br/></td><td>28<br/></td><td>25<br/></td><td>5<br/></td><td>20<br/></td></tr>\n<tr>\n<td>P5<br/></td><td>4<br/></td><td>18<br/></td><td>14<br/></td><td>2<br/></td><td>12<br/></td></tr>\n</table>\n\n- 平均周转时间：$(22 + 7 + 25 + 25 + 14)/5 = 93/5 = 18.6$\n- 平均等待时间：$(14 + 3 + 16 + 20 + 12)/5 = 65/5 = 13$\n\n相比 FCFS、SJF、RR，MLFQ 在该示例中：\n\n- 短作业（P2、P5）在 Q0 快速完成，等待时间明显较少；\n- 长作业（P3、P4、P1）因在 Q0 多次降级，等待较长，但总周转时间依然优于简单 RR；\n- 综合考虑响应与吞吐，有一定折中效果。\n\n---\n\n## 调度算法的优缺点总结\n\n<table>\n<tr>\n<td>算法<br/></td><td>优点<br/></td><td>缺点<br/></td><td>适用场景<br/></td></tr>\n<tr>\n<td>FCFS<br/></td><td>实现简单；没有抢占开销<br/></td><td>平均等待/周转时间较大；易出现 Convoy Effect；无优先级区分<br/></td><td>批处理系统、后台任务<br/></td></tr>\n<tr>\n<td>SJF<br/></td><td>平均等待/周转时间最小<br/></td><td>需要预知执行时间；可能导致长作业饥饿<br/></td><td>静态或可预估作业的批处理<br/></td></tr>\n<tr>\n<td>SRTF<br/></td><td>响应迅速、平均等待较小<br/></td><td>抢占频繁，上下文切换开销大；同样存在饥饿<br/></td><td>对延迟敏感的批处理、实验环境<br/></td></tr>\n<tr>\n<td>优先级<br/></td><td>可根据重要性分配资源；实现灵活<br/></td><td>低优先级饥饿；优先级反转问题；需优先级分配策略<br/></td><td>实时系统、含不同优先级任务的系统<br/></td></tr>\n<tr>\n<td>RR<br/></td><td>公平分配、多用户响应快；无饥饿<br/></td><td>平均等待/周转时间偏大；需合理设置时间片<br/></td><td>交互式系统、时分多用户环境<br/></td></tr>\n<tr>\n<td>多级队列<br/></td><td>可对不同进程类型采用不同策略；实现简洁<br/></td><td>队列静态划分；低队列容易饥饿<br/></td><td>操作系统进程分层管理<br/></td></tr>\n<tr>\n<td>多级反馈队列<br/></td><td>综合考虑CPU/I-O 进程；响应与吞吐折中；防止饥饿<br/></td><td>参数较多，调优复杂；实现与维护开销大<br/></td><td>通用操作系统（如 Linux 早期调度）<br/></td></tr>\n<tr>\n<td>实时调度<br/></td><td>能保证任务在截止时间前完成；满足实时要求<br/></td><td>算法复杂；只能针对实时任务；可能牺牲吞吐量和公平性<br/></td><td>硬实时/软实时系统（如航天、工业控制）<br/></td></tr>\n</table>\n\n---\n\n## 在实际操作系统中的典型应用\n\n> - [Linux，Windows 和 UNIX 的进程调度的分析 - 专注 it - 博客园](https://www.cnblogs.com/wanghuaijun/p/8046992.html)\n\n1. **UNIX/Linux 调度器**\n\n- 早期 UNIX 采用基于优先级的多级反馈队列调度（BSD 4.4 era）。\n- Linux 2.6 → 3.x 采用 O(1) 调度器（使用固定数量队列和计时桶），基于多级反馈队列思想。\n- 从 Linux 2.6.23 以后，切换到 CFS（Completely Fair Scheduler，完全公平调度器），采用红黑树实现时间共享，极大提高公平性与可伸缩性。\n\n1. **Windows 调度器**\n\n- 采用最高响应优先级线程抢占 (preemptive, priority-based preemptive scheduling)，具有 32 级动态优先级和 1 级实时优先级。\n- 同时对 I/O 密集型与 CPU 密集型线程进行动态优先级调整（I/O 密集型短期优先，避免饥饿）。\n\n1. **实时操作系统（RTOS）**\n\n- 典型算法：固定优先级抢占调度（Rate Monotonic Scheduling, RMS）、最早截止时间优先 (Earliest Deadline First, EDF)。\n- 可保证在一定负载下满足硬实时任务的周期性执行约束。\n\n1. **虚拟化 / 容器调度**\n\n- Xen、KVM 等虚拟化平台需为每个虚拟 CPU 分配物理 CPU 时间片。\n- Kubernetes 等容器编排系统中，每个容器对应多个线程/进程，调度器采用 CFS，配合 cgroups 限制和调节 CPU 份额。\n\n---\n\n## 优化思路与扩展\n\n1. **自适应时间片**\n\n- 动态调整 RR 时间片大小：初始时给交互进程较小的时间片，若长时间占用则增大；\n- 可以减少上下文切换并兼顾 I/O 密集型进程响应。\n\n1. **混合调度**\n\n- 在多级队列中对不同队列采用不同算法。例如：Q0 用 RR，Q1 用优先级，Q2 用 FCFS；\n- 结合实时任务与后台批处理任务，保证实时约束的同时兼顾吞吐。\n\n1. **基于负载的动态调度**\n\n- 在线监测系统负载、进程行为特征，对队列数、时间片长度、优先级自适应调整；\n- 典型做法：短进程优先、I/O 密集任务优先、长时间等待任务提升优先级。\n\n1. **考虑缓存与上下文切换开销**\n\n- 在多核环境中，调度器需考虑缓存亲和性（CPU Affinity）、减少缓存抖动；\n- 结合软/硬 NUMA 拓扑结构，将线程更合理地分配到 CPU 核心。\n\n1. **公平性与服务质量(QoS)**\n\n- 引入公平队列思路（如 CFS 红黑树），每个就绪线程按“虚拟运行时间”排序；\n- 在云/容器环境中，根据配额/优先级设定不同权重，保证租户公平与性能可预测。\n\n1. **能源感知 (Energy-aware Scheduling)**\n\n- 通过调度让低优先级进程在低频核上执行，高性能进程在高频核执行；\n- 动态调整 CPU 频率与电压（DVFS），配合负载情况与性能需求。\n\n---\n\n# 总结\n\n- **进程调度算法**是操作系统核心组件之一，直接影响系统性能、响应速度和公平性。\n- 常见单队列算法（FCFS、SJF/SRTF、优先级调度、RR）应用于不同场景，各有优缺点：\n- FCFS 实现简单，适合批处理；\n- SJF/SRTF 平均等待最小，但需预估执行时间；\n- 优先级调度可区分任务重要性，但需防止饥饿；\n- RR 公平且适合交互式系统，但需谨慎设置时间片。\n- 多级队列与多级反馈队列结合了多种策略，兼顾交互与吞吐，可在通用操作系统中灵活应用，但实现与调优复杂。\n- 实际操作系统中（Linux、Windows、RTOS）多采用多级/公平调度或基于红黑树的 CFS，以满足多核、多租户、实时与能耗等综合需求。\n- **调度器优化方向**：\n\n1. 提高公平性（如 CFS/Fair Queue）；\n2. 降低上下文切换与缓存抖动开销；\n3. 引入实时、能耗、负载感知等扩展；\n4. 动态自适应调度参数以应对多变负载。\n\n无论在桌面、服务器、嵌入式还是云环境中，选择合适的调度算法并进行针对性优化，都是提升系统响应能力与吞吐效率的关键环节。\n\n---\n\n# 参考文献\n\n- [Silberschatz, A., Galvin, P. B., &amp; Gagne, G. (2018). ](https://www.wiley.com/en-us/Operating+System+Concepts%2C+10th+Edition-p-9781119320913)_Operating System Concepts_[ (10th Edition). Wiley.](https://www.wiley.com/en-us/Operating+System+Concepts%2C+10th+Edition-p-9781119320913)\n- [Tanenbaum, A. S., &amp; Bos, H. (2014). ](https://www.pearson.com/store/p/modern-operating-systems/P100000253296)_Modern Operating Systems_[ (4th Edition). Pearson.](https://www.pearson.com/store/p/modern-operating-systems/P100000253296)\n- [Stallings, W. (2018). ](https://www.pearson.com/store/p/operating-systems-internals-and-design-principles/P100000253343)_Operating Systems: Internals and Design Principles_[ (9th Edition). Pearson.](https://www.pearson.com/store/p/operating-systems-internals-and-design-principles/P100000253343)\n- [Love, R. (2010). ](https://www.informit.com/store/linux-kernel-development-9780672329463)_Linux Kernel Development_[ (3rd Edition). Addison-Wesley.](https://www.informit.com/store/linux-kernel-development-9780672329463)\n- [Bovet, D. P., &amp; Cesati, M. (2005). ](https://www.oreilly.com/library/view/understanding-the-linux/0596005652/)_Understanding the Linux Kernel_[ (3rd Edition). O’Reilly Media.](https://www.oreilly.com/library/view/understanding-the-linux/0596005652/)\n- [Docker 官方文档：“Resource Management and Scheduling”](https://docs.docker.com/config/containers/resource_constraints/)\n- [Mozilla 开源项目 “NSScheduler” 源码与文档](https://github.com/mozilla/NSScheduler)\n- [“Rate Monotonic Scheduling (RMS)” Tutorial, Real-Time Systems Community.](https://rtems.org/rms)\n- [“Earliest Deadline First (EDF) Scheduling”, Real-Time Systems Tutorial.](https://rtems.org/edf)\n\n> **延伸阅读方向**：\n>\n> - 现代多核环境下的调度（例如 CFS 的 Red-Black Tree 结构）\n> - 云计算平台中的容器/虚拟机资源调度策略\n> - 实时操作系统中固定优先级 vs 动态优先级调度算法对比\n","source":"_posts/2025-05-09-进程调度算法分析.md","raw":"---\ntitle:  2025-05-09-进程调度算法分析\ndate: 2025-05-09\ntags: \n    课程学习\n---\n# 进程调度算法分析\n\n# 参考资料\n\n> - [一文看懂 Linux 内核调度分析（进程调度）一](https://zhuanlan.zhihu.com/p/543205467)\n> - [Linux 内核中常见的进程调度算法](https://zhuanlan.zhihu.com/p/661863529)\n> - [Linux 进程调度算法_linux 调度算法-CSDN 博客](https://blog.csdn.net/qq_41897304/article/details/130194906)\n> - [大厂面试爱问的「调度算法」，20 张图一举拿下 - 小林 coding - 博客园](https://www.cnblogs.com/xiaolincoding/p/13631224.html)\n> - [gregsnotes.medium.com](https://gregsnotes.medium.com/how-do-cpus-execute-instructions-in-parallel-dfa15e87a86c)\n\n# 概述\n\n## 调度指标与目标\n\n![1749361099852GUHDb2WbvordpDxnuNEcIg0zn0b.png](https://gitee.com/tanke11223344/imagehost/raw/main/blog/1749361099852GUHDb2WbvordpDxnuNEcIg0zn0b.png)\n\n单核 CPU 处理多个进程和线程\n\n操作系统进程调度的核心目标在于合理分配 CPU 资源，使系统能够同时满足多个性能指标。常见的评估指标包括：\n\n1. **CPU 利用率（CPU Utilization）**\n\n- CPU 在单位时间内非空闲状态的比例。理想情况下应尽量接近 100%。\n\n1. **吞吐量（Throughput）**\n\n- 单位时间内完成的作业（或进程）数量。吞吐量越高，单位时间完成任务越多。\n\n1. **周转时间（Turnaround Time）**\n\n- 从进程提交（到达）到完全执行结束所经历的总时间。\n\n$$\n\\text{Turnaround Time} = \\text{完成时间} - \\text{到达时间}\n$$\n\n1. **带权周转时间（Weighted Turnaround Time）**\n\n- 周转时间与执行时间之比，用于衡量短作业或长作业的相对等待公平性。\n\n$$\n\\text{Weighted Turnaround Time} = \\frac{\\text{Turnaround Time}}{\\text{执行时间}}\n$$\n\n1. **等待时间（Waiting Time）**\n\n- 进程在就绪队列中等待 CPU 的累积时间。\n\n$$\n\\text{Waiting Time} = \\text{Turnaround Time} - \\text{执行时间}\n$$\n\n1. **响应时间（Response Time）**\n\n- 从进程提交到系统开始响应（第一次分配 CPU）的时间。\n\n$$\n\\text{Response Time} = \\text{第一次调度时间} - \\text{到达时间}\n$$\n\n1. **公平性**\n\n- 同类进程应获得相似的资源分配和等待时间；避免饥饿（Starvation）。\n\n不同的调度算法在上述指标上表现各异，系统应根据场景需求权衡：\n\n- **交互式系统**：关注响应时间（如 GUI 系统、服务器应用）。\n- **批处理系统**：关注吞吐量与周转时间（如科学计算、大规模数据处理）。\n- **实时系统**：关注任务能否在规定的截止时间前完成，使用实时调度算法（如 Rate Monotonic Scheduling、Earliest Deadline First）。\n\n---\n\n## 调度算法的分类\n\n根据是否支持抢占（Preemptive）和队列策略，可将操作系统中的调度算法大致分为两类：\n\n1. **非抢占式调度（Non-preemptive Scheduling）**\n\n- 一旦进程被分配 CPU，直到该进程自愿放弃 CPU（如执行完成或进入 I/O 阻塞）才会切换。\n- 算法典型：先来先服务 (FCFS)、短作业优先 (SJF，非抢占版本)、优先级非抢占。\n\n1. **抢占式调度（Preemptive Scheduling）**\n\n- 若有更高优先级的进程到达或某种时间片用尽，会强制剥夺当前进程的 CPU。\n- 算法典型：短剩余时间优先 (SRTF)、优先级抢占、时间片轮转 (RR)、多级反馈队列等。\n\n此外，按照就绪队列结构的不同，调度亦可分为：\n\n- **单级队列（Single Queue）**：所有就绪进程放在同一队列中，统一调度（上述 FCFS、SJF、RR 等）。\n- **多级队列（Multi-Level Queue）**：根据进程类型（交互式 vs 批处理）、优先级等分类，将进程放入多个队列，根据队列优先级逐级调度。\n- **多级反馈队列（Multi-Level Feedback Queue, MLFQ）**：在多级队列的基础上，允许进程在不同队列间动态迁移，从而兼顾响应时间和吞吐量。\n\n---\n\n## 常见单队列调度算法\n\n### 先来先服务 (FCFS)\n\n**概念**：\n\n![1749361112852SlmPb1s55oPHr4xbKuxcR095nZc.png](https://gitee.com/tanke11223344/imagehost/raw/main/blog/1749361112852SlmPb1s55oPHr4xbKuxcR095nZc.png)\n\n- 最简单的调度算法，类比数据结构中的队列,按照进程到达就绪队列的先后顺序分配 CPU，不做抢占。\n- 类似排队买票：先到先服务。\n\n**基本流程**：\n\n1. 就绪队列中，按照到达时间排序。\n2. CPU 空闲时，从队头取出第一个进程执行，运行完毕后再取下一个。\n\n**优点**：\n\n- 实现简单，易于理解和维护。\n- 进程切换开销少，无抢占导致的上下文切换开销。\n\n**缺点**：\n\n- **等待时间不可控**：一旦前面有一个长作业，后续短作业就会被“长作业阻塞”（Convoy Effect），导致平均等待时间变长。\n- **平均周转时间较大**：对短作业不友好。\n- **无差别对待**：不支持优先级，易造成关键任务延迟。\n\n**适用场景**：\n\n- 适合批处理系统中长时间运行、无需交互的作业调度。\n\n---\n\n### 短作业优先 (SJF) 与 最短剩余时间优先 (SRTF)\n\n#### 短作业优先 (SJF, Shortest Job First)\n\n**概念**：\n\n![1749361121852DiHgbhn6Lo2tr7xuqvscwpi2nxg.png](https://gitee.com/tanke11223344/imagehost/raw/main/blog/1749361121852DiHgbhn6Lo2tr7xuqvscwpi2nxg.png)\n\n- 按照进程的估计执行时间（CPU Burst）长短来调度，优先选择执行时间最短的进程（非抢占）。\n- 可以最大化减少平均等待时间。\n\n**流程**：\n\n1. 当 CPU 空闲时，从就绪队列中选择执行时间最短的进程。\n2. 该进程运行至完成，然后再次从剩余进程中选择最短的继续。\n\n**优点**：\n\n- 平均等待时间最小（经证明）。\n\n**缺点**：\n\n- **需要预知执行时间**：在实际系统中很难准确知道每个进程的执行时间，只能通过历史统计或猜测。\n- **可能导致饥饿**：如果系统中不断有短作业到来，长作业可能一直得不到执行机会。\n\n#### 最短剩余时间优先 (SRTF, Shortest Remaining Time First)\n\n**概念**：\n\n- 是 SJF 的抢占式版本。\n- 当有新进程到达，若其估计总执行时间小于当前正在执行进程的剩余执行时间，则抢占当前进程，优先执行新进程。\n\n**流程**：\n\n1. 维护就绪队列中各进程的剩余执行时间。\n2. 当新进程到达或某进程完成后，重新比较就绪队列中剩余时间最小的进程；若与当前执行进程不同，则进行抢占切换。\n\n**优点**：\n\n- 平均等待时间更小，响应更及时。\n\n**缺点**：\n\n- **更频繁的上下文切换**：可能每次新进程到来都要抢占，增加系统负载。\n- **难以预测与饥饿问题**：同样存在长进程饥饿风险。\n\n**适用场景**：\n\n- 对平均等待时间要求很高、可接受大量切换开销的批处理环境。\n\n---\n\n### 优先级调度 (Priority Scheduling)\n\n**概念**：\n\n![1749361133852G5ACbX27MoyabGxHSPOcVVCenIg.png](https://gitee.com/tanke11223344/imagehost/raw/main/blog/1749361133852G5ACbX27MoyabGxHSPOcVVCenIg.png)\n\n- 每个进程都与一个优先级（Priority）相关联，调度时始终选择优先级最高（数值最小或最大，取决于实现约定）的进程执行。\n- 可分为非抢占式优先级调度和抢占式优先级调度：\n- **非抢占式优先级**：一旦进程被选中，直到它完成或自愿阻塞，其他高优先级进程到达也不能抢占。\n- **抢占式优先级**：如果有更高优先级的进程到达，会中断当前进程并调度高优先级进程执行。\n\n**优点**：\n\n- 可以根据任务重要程度分配资源，实现“关键任务优先”。\n\n**缺点**：\n\n- **饥饿（Starvation）**：低优先级进程可能长时间无法获得 CPU。如果系统中高优先级任务持续到达，则低优先级任务可能永远得不到服务。\n- **优先级反转（Priority Inversion）**：低优先级进程持有资源（如锁），阻止高优先级进程执行，造成高优先级任务等待。可通过“优先级继承”等机制缓解。\n\n**优先级分配策略**：\n\n- **静态优先级**：在进程创建时分配，不随运行时变化。\n- **动态优先级**：随着进程运行行为或等待时间动态调整。例如：长时间在就绪队列中等待，优先级随时间递增；使用 “ aging” 技术防止饥饿。\n\n---\n\n### 时间片轮转 (Round Robin, RR)\n\n**概念**：\n\n![1749361149087XcrFbh95yoJy1VxxOlhcL4p3nne.png](https://gitee.com/tanke11223344/imagehost/raw/main/blog/1749361149087XcrFbh95yoJy1VxxOlhcL4p3nne.png)\n\n- 将 CPU 时间分成若干固定长度的时间片（Time Quantum），系统维护一个进程就绪队列（通常是 FIFO）。\n- 每次调度时，将队头进程分配一个完整时间片或直到进程自行阻塞（I/O）／完成。时间片用完后，将该进程移动到队尾，依此循环。\n\n**流程**：\n\n1. 初始化就绪队列，所有进程先按到达顺序加入队列。\n2. 系统为队头进程分配时钟中断，每次时钟中断到来时：\n\n- 若进程尚未完成，且时间片已用完，则将其移动到队尾；\n- 若进程完成或主动阻塞，直接移除或放入相应 I/O 等待队列。\n\n1. 选取下一个队头进程，重复上述步骤。\n\n**关键参数**：\n\n- **时间片大小 (Quantum)**：\n- 小时间片 → 系统响应快，适合交互式处理；但上下文切换频繁，开销大。\n- 大时间片 → 切换开销小，但响应时间变长，接近 FCFS 效果。\n- 通常取值应使上下文切换开销远小于时间片时长（如上下文切换需要 1–2 μs，时间片一般设为 10–100 ms）。\n\n**优点**：\n\n- 对所有进程一视同仁，易于实现和理解；\n- 响应时间有保证（最坏响应时间 = 时间片 × 就绪进程数）；\n- 无饥饿，进程最终会被分配 CPU。\n\n**缺点**：\n\n- 需要设置合适时间片；\n- 上下文切换带来额外开销；\n- 对 CPU 密集型与 I/O 密集型进程无区分，可能浪费时间片给 CPU 密集型作业；\n- 如果时间片与进程执行时间不匹配，则吞吐量和周转时间可能不理想。\n\n**适用场景**：\n\n- 交互式系统，要求快速响应用户输入的环境（如终端、桌面交互系统）。\n\n---\n\n## 多级队列调度与多级反馈队列调度\n\n### 4.1. 多级队列调度 (Multi-Level Queue)\n\n**概念**：\n\n- 根据进程的类别、优先级、服务需求等，将进程划分到不同的就绪队列中。每个队列可应用不同的调度算法或不同时间片长度。\n- 各队列本身也按照优先级排列。当 CPU 空闲时，始终从最高优先级队列调度，若高优先级队列为空，才调度低优先级队列。\n\n**队列示例**：\n\n- **系统交互进程队列**：RR 调度，时间片短；\n- **批处理进程队列**：FCFS 调度；\n- **守护进程队列**：优先级调度或 FCFS；\n\n**特点**：\n\n- 不同类型进程获得不同的服务策略；\n- 各队列永久划分，不动态调整。\n\n**缺点**：\n\n- 需要在设计阶段预先进行进程分类，不灵活；\n- 高优先级队列如果繁忙，低优先级队列可能饥饿。\n\n---\n\n### 多级反馈队列调度 (Multi-Level Feedback Queue, MLFQ)\n\n**概念**：\n\n时间片轮转和最高优先级算法的综合和拓展\n\n- 「多级」表示有多个队列，每个队列优先级从高到低，同时优先级越高时间片越短。\n- 「反馈」表示如果有新的进程加入优先级高的队列时，立刻停止当前正在运行的进程，转而去运行优先级高的队列；\n\n![1749361161852T6LZbQZ7Fon2d3xWr17cscH5nWw.png](https://gitee.com/tanke11223344/imagehost/raw/main/blog/1749361161852T6LZbQZ7Fon2d3xWr17cscH5nWw.png)\n\n- 在多级队列基础上，为了提高灵活性，允许进程在不同队列间根据行为“反馈”向下或向上移动。\n- 目标：使得 I/O 密集型（短 CPU burst）进程获得较高优先级，CPU 密集型（长 CPU burst）进程优先级逐渐降低，从而兼顾系统响应性和吞吐量。\n\n**常见策略参数**：\n\n1. **队列数 (N)**：一般设为 3–5 级，从高到低优先级递减编号。\n2. **时间片 (Quantum)**：不同队列拥有不同时间片长度。一般高优先级队列时间片短（例如 8ms），中/低级队列时间片依次加倍（16ms、32ms）。\n3. **晋升与降级规则**：\n\n- **降级**：进程若在本级队列用完完整时间片（表明可能较 CPU 密集），则移动到下一低级队列；\n- **晋升（或 Aging）**：为了防止长期在低级队列的进程饥饿，可在一定条件下（如等待时间超过阈值）将其提升至更高级队列。\n\n**典型流程**：\n\n1. 所有进程初始进入最高优先级队列（队列 0）。\n2. CPU 空闲时，从优先级最高且非空队列选取队头进程执行一个时间片或至该进程阻塞/完成。\n3. 若用完时间片且仍未完成，则降级到下一级队列尾。\n4. 若在某队列执行过程中阻塞（如进入 I/O），则保持在当前队列级别（或执行完成后重新进入高优先级队列，具体实现可不同）。\n5. 周期性或按需检查低级队列中的进程等待时间，执行晋升。\n\n**优点**：\n\n- 区分不同工作特征的进程（I/O 密集 vs CPU 密集），提高响应速度；\n- 通过动态反馈减少饥饿。\n\n**缺点**：\n\n- 参数较多（队列数、时间片长度、晋升/降级阈值等），需要调优；\n- 实现复杂度较高；\n- 若设计不合理，仍可能出现低优先级进程饥饿。\n\n**适用场景**：\n\n- 一般通用操作系统（如 Linux 的 O(1) 调度器、早期 UNIX 调度），可兼顾交互式任务与后台批处理任务。\n- 要求较高响应性的桌面系统或要求分时公平性的多用户系统。\n\n---\n\n## 调度算法的性能评估示例\n\n下面通过假设的进程集合与到达时间、执行（CPU）时间示例，分别在 FCFS、SJF/SRTF、RR、和多级反馈队列环境下进行调度，计算关键指标并进行比较。\n\n### 示例流程与假设数据\n\n假设有 5 个进程，属性如下：\n\n<table>\n<tr>\n<td>进程 PID<br/></td><td>到达时间 (Arrival)<br/></td><td>CPU 执行时间 (Burst)<br/></td><td>优先级 (Priority)\\*<br/></td></tr>\n<tr>\n<td>P1<br/></td><td>0<br/></td><td>8<br/></td><td>2<br/></td></tr>\n<tr>\n<td>P2<br/></td><td>1<br/></td><td>4<br/></td><td>1<br/></td></tr>\n<tr>\n<td>P3<br/></td><td>2<br/></td><td>9<br/></td><td>3<br/></td></tr>\n<tr>\n<td>P4<br/></td><td>3<br/></td><td>5<br/></td><td>2<br/></td></tr>\n<tr>\n<td>P5<br/></td><td>4<br/></td><td>2<br/></td><td>1<br/></td></tr>\n</table>\n\n> \\*仅在优先级调度或 MLFQ 中使用，数值越小优先级越高。\n\n- 假设系统在时刻 0 之后开始调度，并且已知所有进程到达时间与执行时间。\n- 时间单位可视为毫秒 (ms)。\n\n我们分别对以下调度算法进行分析：\n\n1. FCFS (非抢占)\n2. SJF (假设非抢占)\n3. SRTF (抢占式短作业优先)\n4. RR (时间片 = 3)\n5. 多级反馈队列 (3 级队列，时间片分别 4、8、∞；无晋升)\n\n### FCFS 调度示例分析\n\n#### 调度顺序\n\n<table>\n<tr>\n<td>时间区间<br/></td><td>执行进程<br/></td></tr>\n<tr>\n<td>0–8<br/></td><td>P1<br/></td></tr>\n<tr>\n<td>8–12<br/></td><td>P2<br/></td></tr>\n<tr>\n<td>12–21<br/></td><td>P3<br/></td></tr>\n<tr>\n<td>21–26<br/></td><td>P4<br/></td></tr>\n<tr>\n<td>26–28<br/></td><td>P5<br/></td></tr>\n</table>\n\n解释：\n\n- 时刻 0：P1 到达，分配 CPU；\n- P1 用到时刻 8 才完成；\n- 时刻 1–4 期间，P2、P3、P4、P5 依序到达并进入队列；\n- 时刻 8：CPU 分配给队列头进程 P2（到达时间最早）；\n- 依此类推。\n\n#### 关键指标计算\n\n<table>\n<tr>\n<td>PID<br/></td><td>到达时间<br/></td><td>完成时间 (Finish)<br/></td><td>周转时间 = Finish - Arrival<br/></td><td>执行时间 (Burst)<br/></td><td>等待时间 = Turnaround - Burst<br/></td></tr>\n<tr>\n<td>P1<br/></td><td>0<br/></td><td>8<br/></td><td>8<br/></td><td>8<br/></td><td>0<br/></td></tr>\n<tr>\n<td>P2<br/></td><td>1<br/></td><td>12<br/></td><td>11<br/></td><td>4<br/></td><td>7<br/></td></tr>\n<tr>\n<td>P3<br/></td><td>2<br/></td><td>21<br/></td><td>19<br/></td><td>9<br/></td><td>10<br/></td></tr>\n<tr>\n<td>P4<br/></td><td>3<br/></td><td>26<br/></td><td>23<br/></td><td>5<br/></td><td>18<br/></td></tr>\n<tr>\n<td>P5<br/></td><td>4<br/></td><td>28<br/></td><td>24<br/></td><td>2<br/></td><td>22<br/></td></tr>\n</table>\n\n- **平均周转时间**\n\n$$\n\\frac{8 + 11 + 19 + 23 + 24}{5} = \\frac{85}{5} = 17\n$$\n\n- **平均等待时间**\n\n$$\n\\frac{0 + 7 + 10 + 18 + 22}{5} = \\frac{57}{5} = 11.4\n$$\n\n- **平均带权周转时间**\n\n$$\n\\frac{8/8 + 11/4 + 19/9 + 23/5 + 24/2}{5} = \\frac{1 + 2.75 + 2.11 + 4.6 + 12}{5} \\approx \\frac{22.46}{5} = 4.49\n$$\n\n---\n\n### SJF/SRTF 调度示例分析\n\n#### 非抢占式 SJF\n\n- 排除尚未到达的进程，只在 CPU 空闲且队列中已有进程时进行选择。\n\n**调度顺序**：\n\n1. 时刻 0，P1 到达，CPU 分配给 P1。\n2. P1 执行到 8，期间 P2(1)、P3(2)、P4(3)、P5(4) 到达，队列内剩余执行时间分别 $P2:4, P3:9, P4:5, P5:2$。\n3. CPU 空闲时，于时刻 8 选择执行时间最短的 P5（Burst=2），执行 8–10。\n4. 时刻 10 选择剩余执行时间最短的 P2（Burst=4），执行 10–14。\n5. 时刻 14 选择 P4（Burst=5），执行 14–19。\n6. 最后执行 P3（Burst=9），时刻 19–28。\n\n<table>\n<tr>\n<td>时间区间<br/></td><td>执行进程<br/></td></tr>\n<tr>\n<td>0–8<br/></td><td>P1<br/></td></tr>\n<tr>\n<td>8–10<br/></td><td>P5<br/></td></tr>\n<tr>\n<td>10–14<br/></td><td>P2<br/></td></tr>\n<tr>\n<td>14–19<br/></td><td>P4<br/></td></tr>\n<tr>\n<td>19–28<br/></td><td>P3<br/></td></tr>\n</table>\n\n#### SJF 指标计算\n\n<table>\n<tr>\n<td>PID<br/></td><td>到达<br/></td><td>完成<br/></td><td>周转 = 完成−到达<br/></td><td>执行<br/></td><td>等待 = 周转 − 执行<br/></td></tr>\n<tr>\n<td>P1<br/></td><td>0<br/></td><td>8<br/></td><td>8<br/></td><td>8<br/></td><td>0<br/></td></tr>\n<tr>\n<td>P2<br/></td><td>1<br/></td><td>14<br/></td><td>13<br/></td><td>4<br/></td><td>9<br/></td></tr>\n<tr>\n<td>P3<br/></td><td>2<br/></td><td>28<br/></td><td>26<br/></td><td>9<br/></td><td>17<br/></td></tr>\n<tr>\n<td>P4<br/></td><td>3<br/></td><td>19<br/></td><td>16<br/></td><td>5<br/></td><td>11<br/></td></tr>\n<tr>\n<td>P5<br/></td><td>4<br/></td><td>10<br/></td><td>6<br/></td><td>2<br/></td><td>4<br/></td></tr>\n</table>\n\n- 平均周转时间：$(8 + 13 + 26 + 16 + 6)/5 = 69/5 = 13.8$\n- 平均等待时间：$(0 + 9 + 17 + 11 + 4)/5 = 41/5 = 8.2$\n\n相比 FCFS，SJF 平均周转、等待时间更低。\n\n---\n\n#### 5.3.2. 抢占式 SRTF\n\n在 SJF 基础上，当有新进程到达且其剩余执行时间小于当前正在执行进程的剩余时间时，会发生抢占。\n\n**调度细节**：\n\n- 时刻 0–1：P1 执行 0–1（剩余 7）\n- 时刻 1：P2 到达 (Burst=4)，7 (P1 剩余) > 4 → 抢占。P2 执行 1–2（剩余 3），P1 剩余 7\n- 时刻 2：P3 到达 (Burst=9)，当前最短为 P2(3)，继续。P2 执行 2–3（剩余 2）\n- 时刻 3：P4 到达 (Burst=5)，当前最短为 P2(2)，继续。P2 执行 3–4（剩余 1）\n- 时刻 4：P5 到达 (Burst=2)，此时 P2(1) 与 P5(2)，P2 更短 → P2 执行 4–5（完成）\n- 较早完成 P2，队列剩余 P1(7)、P3(9)、P4(5)、P5(2)\n- 时刻 5：当前最短 P5(Burst=2)，执行 5–7（完成）\n- 时刻 7：队列剩余 P1(7)、P3(9)、P4(5)，最短为 P4(5)，执行 7–12（剩余 0 → 完成）\n- 时刻 12：剩余 P1(7)、P3(9)，选择 P1(7)，执行 12–19（完成）\n- 时刻 19–28：最后 P3(9)，执行到 28（完成）\n\n<table>\n<tr>\n<td>时间区间<br/></td><td>执行进程<br/></td></tr>\n<tr>\n<td>0–1<br/></td><td>P1<br/></td></tr>\n<tr>\n<td>1–4<br/></td><td>P2<br/></td></tr>\n<tr>\n<td>4–5<br/></td><td>P2<br/></td></tr>\n<tr>\n<td>5–7<br/></td><td>P5<br/></td></tr>\n<tr>\n<td>7–12<br/></td><td>P4<br/></td></tr>\n<tr>\n<td>12–19<br/></td><td>P1<br/></td></tr>\n<tr>\n<td>19–28<br/></td><td>P3<br/></td></tr>\n</table>\n\n注意：由于多个时间点属于同一进程的继续执行，合并相邻时间段可简化为：\n\n```\nP1: 0−1, 12−19  \nP2: 1−5  \nP5: 5−7  \nP4: 7−12  \nP3: 19−28\n```\n\n#### SRTF 指标计算\n\n<table>\n<tr>\n<td>PID<br/></td><td>到达<br/></td><td>完成<br/></td><td>周转 = 完成−到达<br/></td><td>执行时间<br/></td><td>等待 = 周转 − 执行<br/></td></tr>\n<tr>\n<td>P1<br/></td><td>0<br/></td><td>19<br/></td><td>19<br/></td><td>8<br/></td><td>11<br/></td></tr>\n<tr>\n<td>P2<br/></td><td>1<br/></td><td>5<br/></td><td>4<br/></td><td>4<br/></td><td>0<br/></td></tr>\n<tr>\n<td>P3<br/></td><td>2<br/></td><td>28<br/></td><td>26<br/></td><td>9<br/></td><td>17<br/></td></tr>\n<tr>\n<td>P4<br/></td><td>3<br/></td><td>12<br/></td><td>9<br/></td><td>5<br/></td><td>4<br/></td></tr>\n<tr>\n<td>P5<br/></td><td>4<br/></td><td>7<br/></td><td>3<br/></td><td>2<br/></td><td>1<br/></td></tr>\n</table>\n\n- 平均周转时间：$(19 + 4 + 26 + 9 + 3)/5 = 61/5 = 12.2$\n- 平均等待时间：$(11 + 0 + 17 + 4 + 1)/5 = 33/5 = 6.6$\n\n相比 SJF，SRTF 的平均等待、周转时间略有改进，但切换开销更高。\n\n---\n\n### RR 调度示例分析（时间片 = 3）\n\n**假设时间片（Quantum） = 3**。采用抢占式策略，时钟中断每 3 单位触发一次。\n\n#### 调度步骤\n\n![1749361179853Sytlb2qLco04MixG0i5cz3AFnxd.png](https://gitee.com/tanke11223344/imagehost/raw/main/blog/1749361179853Sytlb2qLco04MixG0i5cz3AFnxd.png)\n\n1. **时刻 0–1**\n\n- P1 到达并开始执行。\n- 经过 1 单位（时刻 1），P2 到达，仍在 P1 时间片内继续。剩余时间：P1 (7)。\n\n1. **时刻 1–3**\n\n- P1 继续执行至用完剩余时间片（3 单位），时刻 3 停止，剩余 P1(5)。\n- 队列顺序：P2 (到达时刻 1)、P3(2)、P4(3)。\n\n1. **时刻 3–6**\n\n- 从队头取 P2（执行 3 单位），时刻 6 剩余 P2（1）。\n- 新到达 P5(4) 已在队列尾。队列顺序：P3、P4、P5、P1（回到队尾）、P2(1)。\n\n1. **时刻 6–9**\n\n- 执行 P3 3 单位，时刻 9 剩余 P3(6)。队列：P4、P5、P1(5)、P2(1)、P3(6)。\n\n1. **时刻 9–12**\n\n- 执行 P4 3 单位，时刻 12 剩余 P4(2)。队列：P5、P1(5)、P2(1)、P3(6)、P4(2)。\n\n1. **时刻 12–14**\n\n- 执行 P5 2 单位（用完）、时刻 14 完成。队列：P1(5)、P2(1)、P3(6)、P4(2)。\n\n1. **时刻 14–17**\n\n- 执行 P1 3 单位，时刻 17 剩余 P1(2)。队列：P2(1)、P3(6)、P4(2)、P1(2)。\n\n1. **时刻 17–18**\n\n- 执行 P2 1 单位（完成），时刻 18。队列：P3(6)、P4(2)、P1(2)。\n\n1. **时刻 18–21**\n\n- 执行 P3 3 单位，时刻 21 剩余 P3(3)。队列：P4(2)、P1(2)、P3(3)。\n\n1. **时刻 21–23**\n\n   * 执行 P4 2 单位（完成），时刻 23。队列：P1(2)、P3(3)。\n2. **时刻 23–25**\n\n   * 执行 P1 2 单位（完成），时刻 25。队列：P3(3)。\n3. **时刻 25–28**\n\n   * 执行 P3 3 单位（完成），时刻 28。队列空。\n\n#### 调度时间线（Gantt 图）\n\n![1749361187852I1ojbIWGEoHOfLxgZsJciFdWnqd.png](https://gitee.com/tanke11223344/imagehost/raw/main/blog/1749361187852I1ojbIWGEoHOfLxgZsJciFdWnqd.png)\n\n合并表示为各个片段与时间区间：\n\n```\n[0−3]: P1  \n[3−6]: P2  \n[6−9]: P3  \n[9−12]: P4  \n[12−14]: P5  \n[14−17]: P1  \n[17−18]: P2  \n[18−21]: P3  \n[21−23]: P4  \n[23−25]: P1  \n[25−28]: P3\n```\n\n#### RR 指标计算\n\n<table>\n<tr>\n<td>PID<br/></td><td>到达<br/></td><td>完成<br/></td><td>周转 = 完成−到达<br/></td><td>执行时间<br/></td><td>等待 = 周转−执行<br/></td></tr>\n<tr>\n<td>P1<br/></td><td>0<br/></td><td>25<br/></td><td>25<br/></td><td>8<br/></td><td>17<br/></td></tr>\n<tr>\n<td>P2<br/></td><td>1<br/></td><td>18<br/></td><td>17<br/></td><td>4<br/></td><td>13<br/></td></tr>\n<tr>\n<td>P3<br/></td><td>2<br/></td><td>28<br/></td><td>26<br/></td><td>9<br/></td><td>17<br/></td></tr>\n<tr>\n<td>P4<br/></td><td>3<br/></td><td>23<br/></td><td>20<br/></td><td>5<br/></td><td>15<br/></td></tr>\n<tr>\n<td>P5<br/></td><td>4<br/></td><td>14<br/></td><td>10<br/></td><td>2<br/></td><td>8<br/></td></tr>\n</table>\n\n- 平均周转时间：$(25 + 17 + 26 + 20 + 10)/5 = 98/5 = 19.6$\n- 平均等待时间：$(17 + 13 + 17 + 15 + 8)/5 = 70/5 = 14$\n\n相比 FCFS、SJF/SRTF，RR 的平均等待与周转时间更高，但响应时间更有保障（最坏响应时间为 3× 队列长度 ≈ 3×5 = 15）。\n\n---\n\n### 多级反馈队列示例分析\n\n#### 参数假设\n\n- **队列数**：3（Q0、Q1、Q2），优先级从高到低依次为 Q0 > Q1 > Q2。\n- **时间片**：\n- Q0: 4\n- Q1: 8\n- Q2: FCFS（不再分时间片，相当于单独的 FCFS 队列）\n- **进入队列规则**：\n\n1. 所有进程初始进入 Q0。\n2. 在 Q0 中用完 4 单位还未完成，则降级到 Q1 队尾；\n3. 在 Q1 中用完 8 单位还未完成，则降级到 Q2 队尾；\n4. 在 Q2 中 FCFS 执行直至完成（不再降级）。\n5. 未用满本级时间片而发生阻塞，则保持本级队列（按到达顺序放回队尾）。\n6. 无晋升机制（简化模型）。\n\n#### 调度流程\n\n1. **时刻 0–4**\n\n- Q0 队列：P1(8) → 执行 4 单位至 剩余 P1(4)，时刻 4，降级至 Q1 队尾。\n- 在时刻 1–4，P2(4)、P3(9)、P4(5)、P5(2) 先后到达，依次进入 Q0 队尾。\n\n1. **时刻 4–8**\n\n- Q0 调度队头为 P2(4) → 执行 4 单位 完成，时刻 8。\n- Q0 队列剩余：P3(9)、P4(5)、P5(2)\n\n1. **时刻 8–12**\n\n- Q0 队头 P3(9) → 执行 4 单位，剩余 P3(5)，时刻 12，降级到 Q1 队尾。\n- Q0 队列剩余：P4(5)、P5(2)\n\n1. **时刻 12–16**\n\n- Q0 队头 P4(5) → 执行 4 单位，剩余 P4(1)，时刻 16，降级到 Q1 队尾。\n- Q0 队列剩余：P5(2)\n\n1. **时刻 16–18**\n\n- Q0 队头 P5(2) → 执行 2 单位 完成（未用满时片），时刻 18。\n- Q0 队列空，此时切换到 Q1 队列。\n\n1. **Q1 轮询**\n\n- Q1 队列：\n\n  1. P1(4) → 执行 4 单位 完成，时刻 22（未用满时片、直接完成，出列）。\n  2. P3(5) → 执行 5 单位 完成，时刻 27（未用满时片、直接完成）。\n  3. P4(1) → 执行 1 单位 完成，时刻 28。\n\n1. **Q2**\n\n- 对本示例数据，无进程在 Q1 用满 8 单位，因此 Q2 无进程。\n\n#### 调度时间线（简化）\n\n```\n[0−4]   P1 (Q0)  \n[4−8]   P2 (Q0)  \n[8−12]  P3 (Q0)  \n[12−16] P4 (Q0)  \n[16−18] P5 (Q0)  \n[18−22] P1 (Q1)  \n[22−27] P3 (Q1)  \n[27−28] P4 (Q1)\n```\n\n#### 多级反馈队列指标计算\n\n<table>\n<tr>\n<td>PID<br/></td><td>到达<br/></td><td>完成<br/></td><td>周转 = 完成−到达<br/></td><td>执行时间<br/></td><td>等待 = 周转 − 执行<br/></td></tr>\n<tr>\n<td>P1<br/></td><td>0<br/></td><td>22<br/></td><td>22<br/></td><td>8<br/></td><td>14<br/></td></tr>\n<tr>\n<td>P2<br/></td><td>1<br/></td><td>8<br/></td><td>7<br/></td><td>4<br/></td><td>3<br/></td></tr>\n<tr>\n<td>P3<br/></td><td>2<br/></td><td>27<br/></td><td>25<br/></td><td>9<br/></td><td>16<br/></td></tr>\n<tr>\n<td>P4<br/></td><td>3<br/></td><td>28<br/></td><td>25<br/></td><td>5<br/></td><td>20<br/></td></tr>\n<tr>\n<td>P5<br/></td><td>4<br/></td><td>18<br/></td><td>14<br/></td><td>2<br/></td><td>12<br/></td></tr>\n</table>\n\n- 平均周转时间：$(22 + 7 + 25 + 25 + 14)/5 = 93/5 = 18.6$\n- 平均等待时间：$(14 + 3 + 16 + 20 + 12)/5 = 65/5 = 13$\n\n相比 FCFS、SJF、RR，MLFQ 在该示例中：\n\n- 短作业（P2、P5）在 Q0 快速完成，等待时间明显较少；\n- 长作业（P3、P4、P1）因在 Q0 多次降级，等待较长，但总周转时间依然优于简单 RR；\n- 综合考虑响应与吞吐，有一定折中效果。\n\n---\n\n## 调度算法的优缺点总结\n\n<table>\n<tr>\n<td>算法<br/></td><td>优点<br/></td><td>缺点<br/></td><td>适用场景<br/></td></tr>\n<tr>\n<td>FCFS<br/></td><td>实现简单；没有抢占开销<br/></td><td>平均等待/周转时间较大；易出现 Convoy Effect；无优先级区分<br/></td><td>批处理系统、后台任务<br/></td></tr>\n<tr>\n<td>SJF<br/></td><td>平均等待/周转时间最小<br/></td><td>需要预知执行时间；可能导致长作业饥饿<br/></td><td>静态或可预估作业的批处理<br/></td></tr>\n<tr>\n<td>SRTF<br/></td><td>响应迅速、平均等待较小<br/></td><td>抢占频繁，上下文切换开销大；同样存在饥饿<br/></td><td>对延迟敏感的批处理、实验环境<br/></td></tr>\n<tr>\n<td>优先级<br/></td><td>可根据重要性分配资源；实现灵活<br/></td><td>低优先级饥饿；优先级反转问题；需优先级分配策略<br/></td><td>实时系统、含不同优先级任务的系统<br/></td></tr>\n<tr>\n<td>RR<br/></td><td>公平分配、多用户响应快；无饥饿<br/></td><td>平均等待/周转时间偏大；需合理设置时间片<br/></td><td>交互式系统、时分多用户环境<br/></td></tr>\n<tr>\n<td>多级队列<br/></td><td>可对不同进程类型采用不同策略；实现简洁<br/></td><td>队列静态划分；低队列容易饥饿<br/></td><td>操作系统进程分层管理<br/></td></tr>\n<tr>\n<td>多级反馈队列<br/></td><td>综合考虑CPU/I-O 进程；响应与吞吐折中；防止饥饿<br/></td><td>参数较多，调优复杂；实现与维护开销大<br/></td><td>通用操作系统（如 Linux 早期调度）<br/></td></tr>\n<tr>\n<td>实时调度<br/></td><td>能保证任务在截止时间前完成；满足实时要求<br/></td><td>算法复杂；只能针对实时任务；可能牺牲吞吐量和公平性<br/></td><td>硬实时/软实时系统（如航天、工业控制）<br/></td></tr>\n</table>\n\n---\n\n## 在实际操作系统中的典型应用\n\n> - [Linux，Windows 和 UNIX 的进程调度的分析 - 专注 it - 博客园](https://www.cnblogs.com/wanghuaijun/p/8046992.html)\n\n1. **UNIX/Linux 调度器**\n\n- 早期 UNIX 采用基于优先级的多级反馈队列调度（BSD 4.4 era）。\n- Linux 2.6 → 3.x 采用 O(1) 调度器（使用固定数量队列和计时桶），基于多级反馈队列思想。\n- 从 Linux 2.6.23 以后，切换到 CFS（Completely Fair Scheduler，完全公平调度器），采用红黑树实现时间共享，极大提高公平性与可伸缩性。\n\n1. **Windows 调度器**\n\n- 采用最高响应优先级线程抢占 (preemptive, priority-based preemptive scheduling)，具有 32 级动态优先级和 1 级实时优先级。\n- 同时对 I/O 密集型与 CPU 密集型线程进行动态优先级调整（I/O 密集型短期优先，避免饥饿）。\n\n1. **实时操作系统（RTOS）**\n\n- 典型算法：固定优先级抢占调度（Rate Monotonic Scheduling, RMS）、最早截止时间优先 (Earliest Deadline First, EDF)。\n- 可保证在一定负载下满足硬实时任务的周期性执行约束。\n\n1. **虚拟化 / 容器调度**\n\n- Xen、KVM 等虚拟化平台需为每个虚拟 CPU 分配物理 CPU 时间片。\n- Kubernetes 等容器编排系统中，每个容器对应多个线程/进程，调度器采用 CFS，配合 cgroups 限制和调节 CPU 份额。\n\n---\n\n## 优化思路与扩展\n\n1. **自适应时间片**\n\n- 动态调整 RR 时间片大小：初始时给交互进程较小的时间片，若长时间占用则增大；\n- 可以减少上下文切换并兼顾 I/O 密集型进程响应。\n\n1. **混合调度**\n\n- 在多级队列中对不同队列采用不同算法。例如：Q0 用 RR，Q1 用优先级，Q2 用 FCFS；\n- 结合实时任务与后台批处理任务，保证实时约束的同时兼顾吞吐。\n\n1. **基于负载的动态调度**\n\n- 在线监测系统负载、进程行为特征，对队列数、时间片长度、优先级自适应调整；\n- 典型做法：短进程优先、I/O 密集任务优先、长时间等待任务提升优先级。\n\n1. **考虑缓存与上下文切换开销**\n\n- 在多核环境中，调度器需考虑缓存亲和性（CPU Affinity）、减少缓存抖动；\n- 结合软/硬 NUMA 拓扑结构，将线程更合理地分配到 CPU 核心。\n\n1. **公平性与服务质量(QoS)**\n\n- 引入公平队列思路（如 CFS 红黑树），每个就绪线程按“虚拟运行时间”排序；\n- 在云/容器环境中，根据配额/优先级设定不同权重，保证租户公平与性能可预测。\n\n1. **能源感知 (Energy-aware Scheduling)**\n\n- 通过调度让低优先级进程在低频核上执行，高性能进程在高频核执行；\n- 动态调整 CPU 频率与电压（DVFS），配合负载情况与性能需求。\n\n---\n\n# 总结\n\n- **进程调度算法**是操作系统核心组件之一，直接影响系统性能、响应速度和公平性。\n- 常见单队列算法（FCFS、SJF/SRTF、优先级调度、RR）应用于不同场景，各有优缺点：\n- FCFS 实现简单，适合批处理；\n- SJF/SRTF 平均等待最小，但需预估执行时间；\n- 优先级调度可区分任务重要性，但需防止饥饿；\n- RR 公平且适合交互式系统，但需谨慎设置时间片。\n- 多级队列与多级反馈队列结合了多种策略，兼顾交互与吞吐，可在通用操作系统中灵活应用，但实现与调优复杂。\n- 实际操作系统中（Linux、Windows、RTOS）多采用多级/公平调度或基于红黑树的 CFS，以满足多核、多租户、实时与能耗等综合需求。\n- **调度器优化方向**：\n\n1. 提高公平性（如 CFS/Fair Queue）；\n2. 降低上下文切换与缓存抖动开销；\n3. 引入实时、能耗、负载感知等扩展；\n4. 动态自适应调度参数以应对多变负载。\n\n无论在桌面、服务器、嵌入式还是云环境中，选择合适的调度算法并进行针对性优化，都是提升系统响应能力与吞吐效率的关键环节。\n\n---\n\n# 参考文献\n\n- [Silberschatz, A., Galvin, P. B., &amp; Gagne, G. (2018). ](https://www.wiley.com/en-us/Operating+System+Concepts%2C+10th+Edition-p-9781119320913)_Operating System Concepts_[ (10th Edition). Wiley.](https://www.wiley.com/en-us/Operating+System+Concepts%2C+10th+Edition-p-9781119320913)\n- [Tanenbaum, A. S., &amp; Bos, H. (2014). ](https://www.pearson.com/store/p/modern-operating-systems/P100000253296)_Modern Operating Systems_[ (4th Edition). Pearson.](https://www.pearson.com/store/p/modern-operating-systems/P100000253296)\n- [Stallings, W. (2018). ](https://www.pearson.com/store/p/operating-systems-internals-and-design-principles/P100000253343)_Operating Systems: Internals and Design Principles_[ (9th Edition). Pearson.](https://www.pearson.com/store/p/operating-systems-internals-and-design-principles/P100000253343)\n- [Love, R. (2010). ](https://www.informit.com/store/linux-kernel-development-9780672329463)_Linux Kernel Development_[ (3rd Edition). Addison-Wesley.](https://www.informit.com/store/linux-kernel-development-9780672329463)\n- [Bovet, D. P., &amp; Cesati, M. (2005). ](https://www.oreilly.com/library/view/understanding-the-linux/0596005652/)_Understanding the Linux Kernel_[ (3rd Edition). O’Reilly Media.](https://www.oreilly.com/library/view/understanding-the-linux/0596005652/)\n- [Docker 官方文档：“Resource Management and Scheduling”](https://docs.docker.com/config/containers/resource_constraints/)\n- [Mozilla 开源项目 “NSScheduler” 源码与文档](https://github.com/mozilla/NSScheduler)\n- [“Rate Monotonic Scheduling (RMS)” Tutorial, Real-Time Systems Community.](https://rtems.org/rms)\n- [“Earliest Deadline First (EDF) Scheduling”, Real-Time Systems Tutorial.](https://rtems.org/edf)\n\n> **延伸阅读方向**：\n>\n> - 现代多核环境下的调度（例如 CFS 的 Red-Black Tree 结构）\n> - 云计算平台中的容器/虚拟机资源调度策略\n> - 实时操作系统中固定优先级 vs 动态优先级调度算法对比\n","slug":"2025-05-09-进程调度算法分析","published":1,"updated":"2025-09-26T12:17:35.470Z","_id":"cmg0saj49001vjm8nbyjkcykv","comments":1,"layout":"post","photos":[],"content":"<h1 id=\"进程调度算法分析\"><a href=\"#进程调度算法分析\" class=\"headerlink\" title=\"进程调度算法分析\"></a>进程调度算法分析</h1><h1 id=\"参考资料\"><a href=\"#参考资料\" class=\"headerlink\" title=\"参考资料\"></a>参考资料</h1><blockquote>\n<ul>\n<li><a href=\"https://zhuanlan.zhihu.com/p/543205467\">一文看懂 Linux 内核调度分析（进程调度）一</a></li>\n<li><a href=\"https://zhuanlan.zhihu.com/p/661863529\">Linux 内核中常见的进程调度算法</a></li>\n<li><a href=\"https://blog.csdn.net/qq_41897304/article/details/130194906\">Linux 进程调度算法_linux 调度算法-CSDN 博客</a></li>\n<li><a href=\"https://www.cnblogs.com/xiaolincoding/p/13631224.html\">大厂面试爱问的「调度算法」，20 张图一举拿下 - 小林 coding - 博客园</a></li>\n<li><a href=\"https://gregsnotes.medium.com/how-do-cpus-execute-instructions-in-parallel-dfa15e87a86c\">gregsnotes.medium.com</a></li>\n</ul>\n</blockquote>\n<h1 id=\"概述\"><a href=\"#概述\" class=\"headerlink\" title=\"概述\"></a>概述</h1><h2 id=\"调度指标与目标\"><a href=\"#调度指标与目标\" class=\"headerlink\" title=\"调度指标与目标\"></a>调度指标与目标</h2><p><img src=\"https://gitee.com/tanke11223344/imagehost/raw/main/blog/1749361099852GUHDb2WbvordpDxnuNEcIg0zn0b.png\" alt=\"1749361099852GUHDb2WbvordpDxnuNEcIg0zn0b.png\"></p>\n<p>单核 CPU 处理多个进程和线程</p>\n<p>操作系统进程调度的核心目标在于合理分配 CPU 资源，使系统能够同时满足多个性能指标。常见的评估指标包括：</p>\n<ol>\n<li><strong>CPU 利用率（CPU Utilization）</strong></li>\n</ol>\n<ul>\n<li>CPU 在单位时间内非空闲状态的比例。理想情况下应尽量接近 100%。</li>\n</ul>\n<ol>\n<li><strong>吞吐量（Throughput）</strong></li>\n</ol>\n<ul>\n<li>单位时间内完成的作业（或进程）数量。吞吐量越高，单位时间完成任务越多。</li>\n</ul>\n<ol>\n<li><strong>周转时间（Turnaround Time）</strong></li>\n</ol>\n<ul>\n<li>从进程提交（到达）到完全执行结束所经历的总时间。</li>\n</ul>\n<p>$$<br>\\text{Turnaround Time} &#x3D; \\text{完成时间} - \\text{到达时间}<br>$$</p>\n<ol>\n<li><strong>带权周转时间（Weighted Turnaround Time）</strong></li>\n</ol>\n<ul>\n<li>周转时间与执行时间之比，用于衡量短作业或长作业的相对等待公平性。</li>\n</ul>\n<p>$$<br>\\text{Weighted Turnaround Time} &#x3D; \\frac{\\text{Turnaround Time}}{\\text{执行时间}}<br>$$</p>\n<ol>\n<li><strong>等待时间（Waiting Time）</strong></li>\n</ol>\n<ul>\n<li>进程在就绪队列中等待 CPU 的累积时间。</li>\n</ul>\n<p>$$<br>\\text{Waiting Time} &#x3D; \\text{Turnaround Time} - \\text{执行时间}<br>$$</p>\n<ol>\n<li><strong>响应时间（Response Time）</strong></li>\n</ol>\n<ul>\n<li>从进程提交到系统开始响应（第一次分配 CPU）的时间。</li>\n</ul>\n<p>$$<br>\\text{Response Time} &#x3D; \\text{第一次调度时间} - \\text{到达时间}<br>$$</p>\n<ol>\n<li><strong>公平性</strong></li>\n</ol>\n<ul>\n<li>同类进程应获得相似的资源分配和等待时间；避免饥饿（Starvation）。</li>\n</ul>\n<p>不同的调度算法在上述指标上表现各异，系统应根据场景需求权衡：</p>\n<ul>\n<li><strong>交互式系统</strong>：关注响应时间（如 GUI 系统、服务器应用）。</li>\n<li><strong>批处理系统</strong>：关注吞吐量与周转时间（如科学计算、大规模数据处理）。</li>\n<li><strong>实时系统</strong>：关注任务能否在规定的截止时间前完成，使用实时调度算法（如 Rate Monotonic Scheduling、Earliest Deadline First）。</li>\n</ul>\n<hr>\n<h2 id=\"调度算法的分类\"><a href=\"#调度算法的分类\" class=\"headerlink\" title=\"调度算法的分类\"></a>调度算法的分类</h2><p>根据是否支持抢占（Preemptive）和队列策略，可将操作系统中的调度算法大致分为两类：</p>\n<ol>\n<li><strong>非抢占式调度（Non-preemptive Scheduling）</strong></li>\n</ol>\n<ul>\n<li>一旦进程被分配 CPU，直到该进程自愿放弃 CPU（如执行完成或进入 I&#x2F;O 阻塞）才会切换。</li>\n<li>算法典型：先来先服务 (FCFS)、短作业优先 (SJF，非抢占版本)、优先级非抢占。</li>\n</ul>\n<ol>\n<li><strong>抢占式调度（Preemptive Scheduling）</strong></li>\n</ol>\n<ul>\n<li>若有更高优先级的进程到达或某种时间片用尽，会强制剥夺当前进程的 CPU。</li>\n<li>算法典型：短剩余时间优先 (SRTF)、优先级抢占、时间片轮转 (RR)、多级反馈队列等。</li>\n</ul>\n<p>此外，按照就绪队列结构的不同，调度亦可分为：</p>\n<ul>\n<li><strong>单级队列（Single Queue）</strong>：所有就绪进程放在同一队列中，统一调度（上述 FCFS、SJF、RR 等）。</li>\n<li><strong>多级队列（Multi-Level Queue）</strong>：根据进程类型（交互式 vs 批处理）、优先级等分类，将进程放入多个队列，根据队列优先级逐级调度。</li>\n<li><strong>多级反馈队列（Multi-Level Feedback Queue, MLFQ）</strong>：在多级队列的基础上，允许进程在不同队列间动态迁移，从而兼顾响应时间和吞吐量。</li>\n</ul>\n<hr>\n<h2 id=\"常见单队列调度算法\"><a href=\"#常见单队列调度算法\" class=\"headerlink\" title=\"常见单队列调度算法\"></a>常见单队列调度算法</h2><h3 id=\"先来先服务-FCFS\"><a href=\"#先来先服务-FCFS\" class=\"headerlink\" title=\"先来先服务 (FCFS)\"></a>先来先服务 (FCFS)</h3><p><strong>概念</strong>：</p>\n<p><img src=\"https://gitee.com/tanke11223344/imagehost/raw/main/blog/1749361112852SlmPb1s55oPHr4xbKuxcR095nZc.png\" alt=\"1749361112852SlmPb1s55oPHr4xbKuxcR095nZc.png\"></p>\n<ul>\n<li>最简单的调度算法，类比数据结构中的队列,按照进程到达就绪队列的先后顺序分配 CPU，不做抢占。</li>\n<li>类似排队买票：先到先服务。</li>\n</ul>\n<p><strong>基本流程</strong>：</p>\n<ol>\n<li>就绪队列中，按照到达时间排序。</li>\n<li>CPU 空闲时，从队头取出第一个进程执行，运行完毕后再取下一个。</li>\n</ol>\n<p><strong>优点</strong>：</p>\n<ul>\n<li>实现简单，易于理解和维护。</li>\n<li>进程切换开销少，无抢占导致的上下文切换开销。</li>\n</ul>\n<p><strong>缺点</strong>：</p>\n<ul>\n<li><strong>等待时间不可控</strong>：一旦前面有一个长作业，后续短作业就会被“长作业阻塞”（Convoy Effect），导致平均等待时间变长。</li>\n<li><strong>平均周转时间较大</strong>：对短作业不友好。</li>\n<li><strong>无差别对待</strong>：不支持优先级，易造成关键任务延迟。</li>\n</ul>\n<p><strong>适用场景</strong>：</p>\n<ul>\n<li>适合批处理系统中长时间运行、无需交互的作业调度。</li>\n</ul>\n<hr>\n<h3 id=\"短作业优先-SJF-与-最短剩余时间优先-SRTF\"><a href=\"#短作业优先-SJF-与-最短剩余时间优先-SRTF\" class=\"headerlink\" title=\"短作业优先 (SJF) 与 最短剩余时间优先 (SRTF)\"></a>短作业优先 (SJF) 与 最短剩余时间优先 (SRTF)</h3><h4 id=\"短作业优先-SJF-Shortest-Job-First\"><a href=\"#短作业优先-SJF-Shortest-Job-First\" class=\"headerlink\" title=\"短作业优先 (SJF, Shortest Job First)\"></a>短作业优先 (SJF, Shortest Job First)</h4><p><strong>概念</strong>：</p>\n<p><img src=\"https://gitee.com/tanke11223344/imagehost/raw/main/blog/1749361121852DiHgbhn6Lo2tr7xuqvscwpi2nxg.png\" alt=\"1749361121852DiHgbhn6Lo2tr7xuqvscwpi2nxg.png\"></p>\n<ul>\n<li>按照进程的估计执行时间（CPU Burst）长短来调度，优先选择执行时间最短的进程（非抢占）。</li>\n<li>可以最大化减少平均等待时间。</li>\n</ul>\n<p><strong>流程</strong>：</p>\n<ol>\n<li>当 CPU 空闲时，从就绪队列中选择执行时间最短的进程。</li>\n<li>该进程运行至完成，然后再次从剩余进程中选择最短的继续。</li>\n</ol>\n<p><strong>优点</strong>：</p>\n<ul>\n<li>平均等待时间最小（经证明）。</li>\n</ul>\n<p><strong>缺点</strong>：</p>\n<ul>\n<li><strong>需要预知执行时间</strong>：在实际系统中很难准确知道每个进程的执行时间，只能通过历史统计或猜测。</li>\n<li><strong>可能导致饥饿</strong>：如果系统中不断有短作业到来，长作业可能一直得不到执行机会。</li>\n</ul>\n<h4 id=\"最短剩余时间优先-SRTF-Shortest-Remaining-Time-First\"><a href=\"#最短剩余时间优先-SRTF-Shortest-Remaining-Time-First\" class=\"headerlink\" title=\"最短剩余时间优先 (SRTF, Shortest Remaining Time First)\"></a>最短剩余时间优先 (SRTF, Shortest Remaining Time First)</h4><p><strong>概念</strong>：</p>\n<ul>\n<li>是 SJF 的抢占式版本。</li>\n<li>当有新进程到达，若其估计总执行时间小于当前正在执行进程的剩余执行时间，则抢占当前进程，优先执行新进程。</li>\n</ul>\n<p><strong>流程</strong>：</p>\n<ol>\n<li>维护就绪队列中各进程的剩余执行时间。</li>\n<li>当新进程到达或某进程完成后，重新比较就绪队列中剩余时间最小的进程；若与当前执行进程不同，则进行抢占切换。</li>\n</ol>\n<p><strong>优点</strong>：</p>\n<ul>\n<li>平均等待时间更小，响应更及时。</li>\n</ul>\n<p><strong>缺点</strong>：</p>\n<ul>\n<li><strong>更频繁的上下文切换</strong>：可能每次新进程到来都要抢占，增加系统负载。</li>\n<li><strong>难以预测与饥饿问题</strong>：同样存在长进程饥饿风险。</li>\n</ul>\n<p><strong>适用场景</strong>：</p>\n<ul>\n<li>对平均等待时间要求很高、可接受大量切换开销的批处理环境。</li>\n</ul>\n<hr>\n<h3 id=\"优先级调度-Priority-Scheduling\"><a href=\"#优先级调度-Priority-Scheduling\" class=\"headerlink\" title=\"优先级调度 (Priority Scheduling)\"></a>优先级调度 (Priority Scheduling)</h3><p><strong>概念</strong>：</p>\n<p><img src=\"https://gitee.com/tanke11223344/imagehost/raw/main/blog/1749361133852G5ACbX27MoyabGxHSPOcVVCenIg.png\" alt=\"1749361133852G5ACbX27MoyabGxHSPOcVVCenIg.png\"></p>\n<ul>\n<li>每个进程都与一个优先级（Priority）相关联，调度时始终选择优先级最高（数值最小或最大，取决于实现约定）的进程执行。</li>\n<li>可分为非抢占式优先级调度和抢占式优先级调度：</li>\n<li><strong>非抢占式优先级</strong>：一旦进程被选中，直到它完成或自愿阻塞，其他高优先级进程到达也不能抢占。</li>\n<li><strong>抢占式优先级</strong>：如果有更高优先级的进程到达，会中断当前进程并调度高优先级进程执行。</li>\n</ul>\n<p><strong>优点</strong>：</p>\n<ul>\n<li>可以根据任务重要程度分配资源，实现“关键任务优先”。</li>\n</ul>\n<p><strong>缺点</strong>：</p>\n<ul>\n<li><strong>饥饿（Starvation）</strong>：低优先级进程可能长时间无法获得 CPU。如果系统中高优先级任务持续到达，则低优先级任务可能永远得不到服务。</li>\n<li><strong>优先级反转（Priority Inversion）</strong>：低优先级进程持有资源（如锁），阻止高优先级进程执行，造成高优先级任务等待。可通过“优先级继承”等机制缓解。</li>\n</ul>\n<p><strong>优先级分配策略</strong>：</p>\n<ul>\n<li><strong>静态优先级</strong>：在进程创建时分配，不随运行时变化。</li>\n<li><strong>动态优先级</strong>：随着进程运行行为或等待时间动态调整。例如：长时间在就绪队列中等待，优先级随时间递增；使用 “ aging” 技术防止饥饿。</li>\n</ul>\n<hr>\n<h3 id=\"时间片轮转-Round-Robin-RR\"><a href=\"#时间片轮转-Round-Robin-RR\" class=\"headerlink\" title=\"时间片轮转 (Round Robin, RR)\"></a>时间片轮转 (Round Robin, RR)</h3><p><strong>概念</strong>：</p>\n<p><img src=\"https://gitee.com/tanke11223344/imagehost/raw/main/blog/1749361149087XcrFbh95yoJy1VxxOlhcL4p3nne.png\" alt=\"1749361149087XcrFbh95yoJy1VxxOlhcL4p3nne.png\"></p>\n<ul>\n<li>将 CPU 时间分成若干固定长度的时间片（Time Quantum），系统维护一个进程就绪队列（通常是 FIFO）。</li>\n<li>每次调度时，将队头进程分配一个完整时间片或直到进程自行阻塞（I&#x2F;O）／完成。时间片用完后，将该进程移动到队尾，依此循环。</li>\n</ul>\n<p><strong>流程</strong>：</p>\n<ol>\n<li>初始化就绪队列，所有进程先按到达顺序加入队列。</li>\n<li>系统为队头进程分配时钟中断，每次时钟中断到来时：</li>\n</ol>\n<ul>\n<li>若进程尚未完成，且时间片已用完，则将其移动到队尾；</li>\n<li>若进程完成或主动阻塞，直接移除或放入相应 I&#x2F;O 等待队列。</li>\n</ul>\n<ol>\n<li>选取下一个队头进程，重复上述步骤。</li>\n</ol>\n<p><strong>关键参数</strong>：</p>\n<ul>\n<li>**时间片大小 (Quantum)**：</li>\n<li>小时间片 → 系统响应快，适合交互式处理；但上下文切换频繁，开销大。</li>\n<li>大时间片 → 切换开销小，但响应时间变长，接近 FCFS 效果。</li>\n<li>通常取值应使上下文切换开销远小于时间片时长（如上下文切换需要 1–2 μs，时间片一般设为 10–100 ms）。</li>\n</ul>\n<p><strong>优点</strong>：</p>\n<ul>\n<li>对所有进程一视同仁，易于实现和理解；</li>\n<li>响应时间有保证（最坏响应时间 &#x3D; 时间片 × 就绪进程数）；</li>\n<li>无饥饿，进程最终会被分配 CPU。</li>\n</ul>\n<p><strong>缺点</strong>：</p>\n<ul>\n<li>需要设置合适时间片；</li>\n<li>上下文切换带来额外开销；</li>\n<li>对 CPU 密集型与 I&#x2F;O 密集型进程无区分，可能浪费时间片给 CPU 密集型作业；</li>\n<li>如果时间片与进程执行时间不匹配，则吞吐量和周转时间可能不理想。</li>\n</ul>\n<p><strong>适用场景</strong>：</p>\n<ul>\n<li>交互式系统，要求快速响应用户输入的环境（如终端、桌面交互系统）。</li>\n</ul>\n<hr>\n<h2 id=\"多级队列调度与多级反馈队列调度\"><a href=\"#多级队列调度与多级反馈队列调度\" class=\"headerlink\" title=\"多级队列调度与多级反馈队列调度\"></a>多级队列调度与多级反馈队列调度</h2><h3 id=\"4-1-多级队列调度-Multi-Level-Queue\"><a href=\"#4-1-多级队列调度-Multi-Level-Queue\" class=\"headerlink\" title=\"4.1. 多级队列调度 (Multi-Level Queue)\"></a>4.1. 多级队列调度 (Multi-Level Queue)</h3><p><strong>概念</strong>：</p>\n<ul>\n<li>根据进程的类别、优先级、服务需求等，将进程划分到不同的就绪队列中。每个队列可应用不同的调度算法或不同时间片长度。</li>\n<li>各队列本身也按照优先级排列。当 CPU 空闲时，始终从最高优先级队列调度，若高优先级队列为空，才调度低优先级队列。</li>\n</ul>\n<p><strong>队列示例</strong>：</p>\n<ul>\n<li><strong>系统交互进程队列</strong>：RR 调度，时间片短；</li>\n<li><strong>批处理进程队列</strong>：FCFS 调度；</li>\n<li><strong>守护进程队列</strong>：优先级调度或 FCFS；</li>\n</ul>\n<p><strong>特点</strong>：</p>\n<ul>\n<li>不同类型进程获得不同的服务策略；</li>\n<li>各队列永久划分，不动态调整。</li>\n</ul>\n<p><strong>缺点</strong>：</p>\n<ul>\n<li>需要在设计阶段预先进行进程分类，不灵活；</li>\n<li>高优先级队列如果繁忙，低优先级队列可能饥饿。</li>\n</ul>\n<hr>\n<h3 id=\"多级反馈队列调度-Multi-Level-Feedback-Queue-MLFQ\"><a href=\"#多级反馈队列调度-Multi-Level-Feedback-Queue-MLFQ\" class=\"headerlink\" title=\"多级反馈队列调度 (Multi-Level Feedback Queue, MLFQ)\"></a>多级反馈队列调度 (Multi-Level Feedback Queue, MLFQ)</h3><p><strong>概念</strong>：</p>\n<p>时间片轮转和最高优先级算法的综合和拓展</p>\n<ul>\n<li>「多级」表示有多个队列，每个队列优先级从高到低，同时优先级越高时间片越短。</li>\n<li>「反馈」表示如果有新的进程加入优先级高的队列时，立刻停止当前正在运行的进程，转而去运行优先级高的队列；</li>\n</ul>\n<p><img src=\"https://gitee.com/tanke11223344/imagehost/raw/main/blog/1749361161852T6LZbQZ7Fon2d3xWr17cscH5nWw.png\" alt=\"1749361161852T6LZbQZ7Fon2d3xWr17cscH5nWw.png\"></p>\n<ul>\n<li>在多级队列基础上，为了提高灵活性，允许进程在不同队列间根据行为“反馈”向下或向上移动。</li>\n<li>目标：使得 I&#x2F;O 密集型（短 CPU burst）进程获得较高优先级，CPU 密集型（长 CPU burst）进程优先级逐渐降低，从而兼顾系统响应性和吞吐量。</li>\n</ul>\n<p><strong>常见策略参数</strong>：</p>\n<ol>\n<li>**队列数 (N)**：一般设为 3–5 级，从高到低优先级递减编号。</li>\n<li>**时间片 (Quantum)**：不同队列拥有不同时间片长度。一般高优先级队列时间片短（例如 8ms），中&#x2F;低级队列时间片依次加倍（16ms、32ms）。</li>\n<li><strong>晋升与降级规则</strong>：</li>\n</ol>\n<ul>\n<li><strong>降级</strong>：进程若在本级队列用完完整时间片（表明可能较 CPU 密集），则移动到下一低级队列；</li>\n<li><strong>晋升（或 Aging）</strong>：为了防止长期在低级队列的进程饥饿，可在一定条件下（如等待时间超过阈值）将其提升至更高级队列。</li>\n</ul>\n<p><strong>典型流程</strong>：</p>\n<ol>\n<li>所有进程初始进入最高优先级队列（队列 0）。</li>\n<li>CPU 空闲时，从优先级最高且非空队列选取队头进程执行一个时间片或至该进程阻塞&#x2F;完成。</li>\n<li>若用完时间片且仍未完成，则降级到下一级队列尾。</li>\n<li>若在某队列执行过程中阻塞（如进入 I&#x2F;O），则保持在当前队列级别（或执行完成后重新进入高优先级队列，具体实现可不同）。</li>\n<li>周期性或按需检查低级队列中的进程等待时间，执行晋升。</li>\n</ol>\n<p><strong>优点</strong>：</p>\n<ul>\n<li>区分不同工作特征的进程（I&#x2F;O 密集 vs CPU 密集），提高响应速度；</li>\n<li>通过动态反馈减少饥饿。</li>\n</ul>\n<p><strong>缺点</strong>：</p>\n<ul>\n<li>参数较多（队列数、时间片长度、晋升&#x2F;降级阈值等），需要调优；</li>\n<li>实现复杂度较高；</li>\n<li>若设计不合理，仍可能出现低优先级进程饥饿。</li>\n</ul>\n<p><strong>适用场景</strong>：</p>\n<ul>\n<li>一般通用操作系统（如 Linux 的 O(1) 调度器、早期 UNIX 调度），可兼顾交互式任务与后台批处理任务。</li>\n<li>要求较高响应性的桌面系统或要求分时公平性的多用户系统。</li>\n</ul>\n<hr>\n<h2 id=\"调度算法的性能评估示例\"><a href=\"#调度算法的性能评估示例\" class=\"headerlink\" title=\"调度算法的性能评估示例\"></a>调度算法的性能评估示例</h2><p>下面通过假设的进程集合与到达时间、执行（CPU）时间示例，分别在 FCFS、SJF&#x2F;SRTF、RR、和多级反馈队列环境下进行调度，计算关键指标并进行比较。</p>\n<h3 id=\"示例流程与假设数据\"><a href=\"#示例流程与假设数据\" class=\"headerlink\" title=\"示例流程与假设数据\"></a>示例流程与假设数据</h3><p>假设有 5 个进程，属性如下：</p>\n<table>\n<tr>\n<td>进程 PID<br/></td><td>到达时间 (Arrival)<br/></td><td>CPU 执行时间 (Burst)<br/></td><td>优先级 (Priority)\\*<br/></td></tr>\n<tr>\n<td>P1<br/></td><td>0<br/></td><td>8<br/></td><td>2<br/></td></tr>\n<tr>\n<td>P2<br/></td><td>1<br/></td><td>4<br/></td><td>1<br/></td></tr>\n<tr>\n<td>P3<br/></td><td>2<br/></td><td>9<br/></td><td>3<br/></td></tr>\n<tr>\n<td>P4<br/></td><td>3<br/></td><td>5<br/></td><td>2<br/></td></tr>\n<tr>\n<td>P5<br/></td><td>4<br/></td><td>2<br/></td><td>1<br/></td></tr>\n</table>\n\n<blockquote>\n<p>*仅在优先级调度或 MLFQ 中使用，数值越小优先级越高。</p>\n</blockquote>\n<ul>\n<li>假设系统在时刻 0 之后开始调度，并且已知所有进程到达时间与执行时间。</li>\n<li>时间单位可视为毫秒 (ms)。</li>\n</ul>\n<p>我们分别对以下调度算法进行分析：</p>\n<ol>\n<li>FCFS (非抢占)</li>\n<li>SJF (假设非抢占)</li>\n<li>SRTF (抢占式短作业优先)</li>\n<li>RR (时间片 &#x3D; 3)</li>\n<li>多级反馈队列 (3 级队列，时间片分别 4、8、∞；无晋升)</li>\n</ol>\n<h3 id=\"FCFS-调度示例分析\"><a href=\"#FCFS-调度示例分析\" class=\"headerlink\" title=\"FCFS 调度示例分析\"></a>FCFS 调度示例分析</h3><h4 id=\"调度顺序\"><a href=\"#调度顺序\" class=\"headerlink\" title=\"调度顺序\"></a>调度顺序</h4><table>\n<tr>\n<td>时间区间<br/></td><td>执行进程<br/></td></tr>\n<tr>\n<td>0–8<br/></td><td>P1<br/></td></tr>\n<tr>\n<td>8–12<br/></td><td>P2<br/></td></tr>\n<tr>\n<td>12–21<br/></td><td>P3<br/></td></tr>\n<tr>\n<td>21–26<br/></td><td>P4<br/></td></tr>\n<tr>\n<td>26–28<br/></td><td>P5<br/></td></tr>\n</table>\n\n<p>解释：</p>\n<ul>\n<li>时刻 0：P1 到达，分配 CPU；</li>\n<li>P1 用到时刻 8 才完成；</li>\n<li>时刻 1–4 期间，P2、P3、P4、P5 依序到达并进入队列；</li>\n<li>时刻 8：CPU 分配给队列头进程 P2（到达时间最早）；</li>\n<li>依此类推。</li>\n</ul>\n<h4 id=\"关键指标计算\"><a href=\"#关键指标计算\" class=\"headerlink\" title=\"关键指标计算\"></a>关键指标计算</h4><table>\n<tr>\n<td>PID<br/></td><td>到达时间<br/></td><td>完成时间 (Finish)<br/></td><td>周转时间 = Finish - Arrival<br/></td><td>执行时间 (Burst)<br/></td><td>等待时间 = Turnaround - Burst<br/></td></tr>\n<tr>\n<td>P1<br/></td><td>0<br/></td><td>8<br/></td><td>8<br/></td><td>8<br/></td><td>0<br/></td></tr>\n<tr>\n<td>P2<br/></td><td>1<br/></td><td>12<br/></td><td>11<br/></td><td>4<br/></td><td>7<br/></td></tr>\n<tr>\n<td>P3<br/></td><td>2<br/></td><td>21<br/></td><td>19<br/></td><td>9<br/></td><td>10<br/></td></tr>\n<tr>\n<td>P4<br/></td><td>3<br/></td><td>26<br/></td><td>23<br/></td><td>5<br/></td><td>18<br/></td></tr>\n<tr>\n<td>P5<br/></td><td>4<br/></td><td>28<br/></td><td>24<br/></td><td>2<br/></td><td>22<br/></td></tr>\n</table>\n\n<ul>\n<li><strong>平均周转时间</strong></li>\n</ul>\n<p>$$<br>\\frac{8 + 11 + 19 + 23 + 24}{5} &#x3D; \\frac{85}{5} &#x3D; 17<br>$$</p>\n<ul>\n<li><strong>平均等待时间</strong></li>\n</ul>\n<p>$$<br>\\frac{0 + 7 + 10 + 18 + 22}{5} &#x3D; \\frac{57}{5} &#x3D; 11.4<br>$$</p>\n<ul>\n<li><strong>平均带权周转时间</strong></li>\n</ul>\n<p>$$<br>\\frac{8&#x2F;8 + 11&#x2F;4 + 19&#x2F;9 + 23&#x2F;5 + 24&#x2F;2}{5} &#x3D; \\frac{1 + 2.75 + 2.11 + 4.6 + 12}{5} \\approx \\frac{22.46}{5} &#x3D; 4.49<br>$$</p>\n<hr>\n<h3 id=\"SJF-SRTF-调度示例分析\"><a href=\"#SJF-SRTF-调度示例分析\" class=\"headerlink\" title=\"SJF&#x2F;SRTF 调度示例分析\"></a>SJF&#x2F;SRTF 调度示例分析</h3><h4 id=\"非抢占式-SJF\"><a href=\"#非抢占式-SJF\" class=\"headerlink\" title=\"非抢占式 SJF\"></a>非抢占式 SJF</h4><ul>\n<li>排除尚未到达的进程，只在 CPU 空闲且队列中已有进程时进行选择。</li>\n</ul>\n<p><strong>调度顺序</strong>：</p>\n<ol>\n<li>时刻 0，P1 到达，CPU 分配给 P1。</li>\n<li>P1 执行到 8，期间 P2(1)、P3(2)、P4(3)、P5(4) 到达，队列内剩余执行时间分别 $P2:4, P3:9, P4:5, P5:2$。</li>\n<li>CPU 空闲时，于时刻 8 选择执行时间最短的 P5（Burst&#x3D;2），执行 8–10。</li>\n<li>时刻 10 选择剩余执行时间最短的 P2（Burst&#x3D;4），执行 10–14。</li>\n<li>时刻 14 选择 P4（Burst&#x3D;5），执行 14–19。</li>\n<li>最后执行 P3（Burst&#x3D;9），时刻 19–28。</li>\n</ol>\n<table>\n<tr>\n<td>时间区间<br/></td><td>执行进程<br/></td></tr>\n<tr>\n<td>0–8<br/></td><td>P1<br/></td></tr>\n<tr>\n<td>8–10<br/></td><td>P5<br/></td></tr>\n<tr>\n<td>10–14<br/></td><td>P2<br/></td></tr>\n<tr>\n<td>14–19<br/></td><td>P4<br/></td></tr>\n<tr>\n<td>19–28<br/></td><td>P3<br/></td></tr>\n</table>\n\n<h4 id=\"SJF-指标计算\"><a href=\"#SJF-指标计算\" class=\"headerlink\" title=\"SJF 指标计算\"></a>SJF 指标计算</h4><table>\n<tr>\n<td>PID<br/></td><td>到达<br/></td><td>完成<br/></td><td>周转 = 完成−到达<br/></td><td>执行<br/></td><td>等待 = 周转 − 执行<br/></td></tr>\n<tr>\n<td>P1<br/></td><td>0<br/></td><td>8<br/></td><td>8<br/></td><td>8<br/></td><td>0<br/></td></tr>\n<tr>\n<td>P2<br/></td><td>1<br/></td><td>14<br/></td><td>13<br/></td><td>4<br/></td><td>9<br/></td></tr>\n<tr>\n<td>P3<br/></td><td>2<br/></td><td>28<br/></td><td>26<br/></td><td>9<br/></td><td>17<br/></td></tr>\n<tr>\n<td>P4<br/></td><td>3<br/></td><td>19<br/></td><td>16<br/></td><td>5<br/></td><td>11<br/></td></tr>\n<tr>\n<td>P5<br/></td><td>4<br/></td><td>10<br/></td><td>6<br/></td><td>2<br/></td><td>4<br/></td></tr>\n</table>\n\n<ul>\n<li>平均周转时间：$(8 + 13 + 26 + 16 + 6)&#x2F;5 &#x3D; 69&#x2F;5 &#x3D; 13.8$</li>\n<li>平均等待时间：$(0 + 9 + 17 + 11 + 4)&#x2F;5 &#x3D; 41&#x2F;5 &#x3D; 8.2$</li>\n</ul>\n<p>相比 FCFS，SJF 平均周转、等待时间更低。</p>\n<hr>\n<h4 id=\"5-3-2-抢占式-SRTF\"><a href=\"#5-3-2-抢占式-SRTF\" class=\"headerlink\" title=\"5.3.2. 抢占式 SRTF\"></a>5.3.2. 抢占式 SRTF</h4><p>在 SJF 基础上，当有新进程到达且其剩余执行时间小于当前正在执行进程的剩余时间时，会发生抢占。</p>\n<p><strong>调度细节</strong>：</p>\n<ul>\n<li>时刻 0–1：P1 执行 0–1（剩余 7）</li>\n<li>时刻 1：P2 到达 (Burst&#x3D;4)，7 (P1 剩余) &gt; 4 → 抢占。P2 执行 1–2（剩余 3），P1 剩余 7</li>\n<li>时刻 2：P3 到达 (Burst&#x3D;9)，当前最短为 P2(3)，继续。P2 执行 2–3（剩余 2）</li>\n<li>时刻 3：P4 到达 (Burst&#x3D;5)，当前最短为 P2(2)，继续。P2 执行 3–4（剩余 1）</li>\n<li>时刻 4：P5 到达 (Burst&#x3D;2)，此时 P2(1) 与 P5(2)，P2 更短 → P2 执行 4–5（完成）</li>\n<li>较早完成 P2，队列剩余 P1(7)、P3(9)、P4(5)、P5(2)</li>\n<li>时刻 5：当前最短 P5(Burst&#x3D;2)，执行 5–7（完成）</li>\n<li>时刻 7：队列剩余 P1(7)、P3(9)、P4(5)，最短为 P4(5)，执行 7–12（剩余 0 → 完成）</li>\n<li>时刻 12：剩余 P1(7)、P3(9)，选择 P1(7)，执行 12–19（完成）</li>\n<li>时刻 19–28：最后 P3(9)，执行到 28（完成）</li>\n</ul>\n<table>\n<tr>\n<td>时间区间<br/></td><td>执行进程<br/></td></tr>\n<tr>\n<td>0–1<br/></td><td>P1<br/></td></tr>\n<tr>\n<td>1–4<br/></td><td>P2<br/></td></tr>\n<tr>\n<td>4–5<br/></td><td>P2<br/></td></tr>\n<tr>\n<td>5–7<br/></td><td>P5<br/></td></tr>\n<tr>\n<td>7–12<br/></td><td>P4<br/></td></tr>\n<tr>\n<td>12–19<br/></td><td>P1<br/></td></tr>\n<tr>\n<td>19–28<br/></td><td>P3<br/></td></tr>\n</table>\n\n<p>注意：由于多个时间点属于同一进程的继续执行，合并相邻时间段可简化为：</p>\n<figure class=\"highlight apache\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"attribute\">P1</span>: <span class=\"number\">0</span>−<span class=\"number\">1</span>, <span class=\"number\">12</span>−<span class=\"number\">19</span>  </span><br><span class=\"line\"><span class=\"attribute\">P2</span>: <span class=\"number\">1</span>−<span class=\"number\">5</span>  </span><br><span class=\"line\"><span class=\"attribute\">P5</span>: <span class=\"number\">5</span>−<span class=\"number\">7</span>  </span><br><span class=\"line\"><span class=\"attribute\">P4</span>: <span class=\"number\">7</span>−<span class=\"number\">12</span>  </span><br><span class=\"line\"><span class=\"attribute\">P3</span>: <span class=\"number\">19</span>−<span class=\"number\">28</span></span><br></pre></td></tr></table></figure>\n\n<h4 id=\"SRTF-指标计算\"><a href=\"#SRTF-指标计算\" class=\"headerlink\" title=\"SRTF 指标计算\"></a>SRTF 指标计算</h4><table>\n<tr>\n<td>PID<br/></td><td>到达<br/></td><td>完成<br/></td><td>周转 = 完成−到达<br/></td><td>执行时间<br/></td><td>等待 = 周转 − 执行<br/></td></tr>\n<tr>\n<td>P1<br/></td><td>0<br/></td><td>19<br/></td><td>19<br/></td><td>8<br/></td><td>11<br/></td></tr>\n<tr>\n<td>P2<br/></td><td>1<br/></td><td>5<br/></td><td>4<br/></td><td>4<br/></td><td>0<br/></td></tr>\n<tr>\n<td>P3<br/></td><td>2<br/></td><td>28<br/></td><td>26<br/></td><td>9<br/></td><td>17<br/></td></tr>\n<tr>\n<td>P4<br/></td><td>3<br/></td><td>12<br/></td><td>9<br/></td><td>5<br/></td><td>4<br/></td></tr>\n<tr>\n<td>P5<br/></td><td>4<br/></td><td>7<br/></td><td>3<br/></td><td>2<br/></td><td>1<br/></td></tr>\n</table>\n\n<ul>\n<li>平均周转时间：$(19 + 4 + 26 + 9 + 3)&#x2F;5 &#x3D; 61&#x2F;5 &#x3D; 12.2$</li>\n<li>平均等待时间：$(11 + 0 + 17 + 4 + 1)&#x2F;5 &#x3D; 33&#x2F;5 &#x3D; 6.6$</li>\n</ul>\n<p>相比 SJF，SRTF 的平均等待、周转时间略有改进，但切换开销更高。</p>\n<hr>\n<h3 id=\"RR-调度示例分析（时间片-3）\"><a href=\"#RR-调度示例分析（时间片-3）\" class=\"headerlink\" title=\"RR 调度示例分析（时间片 &#x3D; 3）\"></a>RR 调度示例分析（时间片 &#x3D; 3）</h3><p><strong>假设时间片（Quantum） &#x3D; 3</strong>。采用抢占式策略，时钟中断每 3 单位触发一次。</p>\n<h4 id=\"调度步骤\"><a href=\"#调度步骤\" class=\"headerlink\" title=\"调度步骤\"></a>调度步骤</h4><p><img src=\"https://gitee.com/tanke11223344/imagehost/raw/main/blog/1749361179853Sytlb2qLco04MixG0i5cz3AFnxd.png\" alt=\"1749361179853Sytlb2qLco04MixG0i5cz3AFnxd.png\"></p>\n<ol>\n<li><strong>时刻 0–1</strong></li>\n</ol>\n<ul>\n<li>P1 到达并开始执行。</li>\n<li>经过 1 单位（时刻 1），P2 到达，仍在 P1 时间片内继续。剩余时间：P1 (7)。</li>\n</ul>\n<ol>\n<li><strong>时刻 1–3</strong></li>\n</ol>\n<ul>\n<li>P1 继续执行至用完剩余时间片（3 单位），时刻 3 停止，剩余 P1(5)。</li>\n<li>队列顺序：P2 (到达时刻 1)、P3(2)、P4(3)。</li>\n</ul>\n<ol>\n<li><strong>时刻 3–6</strong></li>\n</ol>\n<ul>\n<li>从队头取 P2（执行 3 单位），时刻 6 剩余 P2（1）。</li>\n<li>新到达 P5(4) 已在队列尾。队列顺序：P3、P4、P5、P1（回到队尾）、P2(1)。</li>\n</ul>\n<ol>\n<li><strong>时刻 6–9</strong></li>\n</ol>\n<ul>\n<li>执行 P3 3 单位，时刻 9 剩余 P3(6)。队列：P4、P5、P1(5)、P2(1)、P3(6)。</li>\n</ul>\n<ol>\n<li><strong>时刻 9–12</strong></li>\n</ol>\n<ul>\n<li>执行 P4 3 单位，时刻 12 剩余 P4(2)。队列：P5、P1(5)、P2(1)、P3(6)、P4(2)。</li>\n</ul>\n<ol>\n<li><strong>时刻 12–14</strong></li>\n</ol>\n<ul>\n<li>执行 P5 2 单位（用完）、时刻 14 完成。队列：P1(5)、P2(1)、P3(6)、P4(2)。</li>\n</ul>\n<ol>\n<li><strong>时刻 14–17</strong></li>\n</ol>\n<ul>\n<li>执行 P1 3 单位，时刻 17 剩余 P1(2)。队列：P2(1)、P3(6)、P4(2)、P1(2)。</li>\n</ul>\n<ol>\n<li><strong>时刻 17–18</strong></li>\n</ol>\n<ul>\n<li>执行 P2 1 单位（完成），时刻 18。队列：P3(6)、P4(2)、P1(2)。</li>\n</ul>\n<ol>\n<li><strong>时刻 18–21</strong></li>\n</ol>\n<ul>\n<li>执行 P3 3 单位，时刻 21 剩余 P3(3)。队列：P4(2)、P1(2)、P3(3)。</li>\n</ul>\n<ol>\n<li><p><strong>时刻 21–23</strong></p>\n<ul>\n<li>执行 P4 2 单位（完成），时刻 23。队列：P1(2)、P3(3)。</li>\n</ul>\n</li>\n<li><p><strong>时刻 23–25</strong></p>\n<ul>\n<li>执行 P1 2 单位（完成），时刻 25。队列：P3(3)。</li>\n</ul>\n</li>\n<li><p><strong>时刻 25–28</strong></p>\n<ul>\n<li>执行 P3 3 单位（完成），时刻 28。队列空。</li>\n</ul>\n</li>\n</ol>\n<h4 id=\"调度时间线（Gantt-图）\"><a href=\"#调度时间线（Gantt-图）\" class=\"headerlink\" title=\"调度时间线（Gantt 图）\"></a>调度时间线（Gantt 图）</h4><p><img src=\"https://gitee.com/tanke11223344/imagehost/raw/main/blog/1749361187852I1ojbIWGEoHOfLxgZsJciFdWnqd.png\" alt=\"1749361187852I1ojbIWGEoHOfLxgZsJciFdWnqd.png\"></p>\n<p>合并表示为各个片段与时间区间：</p>\n<figure class=\"highlight markdown\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">[<span class=\"symbol\">0−3</span>]: <span class=\"link\">P1  </span></span><br><span class=\"line\">[<span class=\"symbol\">3−6</span>]: <span class=\"link\">P2  </span></span><br><span class=\"line\">[<span class=\"symbol\">6−9</span>]: <span class=\"link\">P3  </span></span><br><span class=\"line\">[<span class=\"symbol\">9−12</span>]: <span class=\"link\">P4  </span></span><br><span class=\"line\">[<span class=\"symbol\">12−14</span>]: <span class=\"link\">P5  </span></span><br><span class=\"line\">[<span class=\"symbol\">14−17</span>]: <span class=\"link\">P1  </span></span><br><span class=\"line\">[<span class=\"symbol\">17−18</span>]: <span class=\"link\">P2  </span></span><br><span class=\"line\">[<span class=\"symbol\">18−21</span>]: <span class=\"link\">P3  </span></span><br><span class=\"line\">[<span class=\"symbol\">21−23</span>]: <span class=\"link\">P4  </span></span><br><span class=\"line\">[<span class=\"symbol\">23−25</span>]: <span class=\"link\">P1  </span></span><br><span class=\"line\">[<span class=\"symbol\">25−28</span>]: <span class=\"link\">P3</span></span><br></pre></td></tr></table></figure>\n\n<h4 id=\"RR-指标计算\"><a href=\"#RR-指标计算\" class=\"headerlink\" title=\"RR 指标计算\"></a>RR 指标计算</h4><table>\n<tr>\n<td>PID<br/></td><td>到达<br/></td><td>完成<br/></td><td>周转 = 完成−到达<br/></td><td>执行时间<br/></td><td>等待 = 周转−执行<br/></td></tr>\n<tr>\n<td>P1<br/></td><td>0<br/></td><td>25<br/></td><td>25<br/></td><td>8<br/></td><td>17<br/></td></tr>\n<tr>\n<td>P2<br/></td><td>1<br/></td><td>18<br/></td><td>17<br/></td><td>4<br/></td><td>13<br/></td></tr>\n<tr>\n<td>P3<br/></td><td>2<br/></td><td>28<br/></td><td>26<br/></td><td>9<br/></td><td>17<br/></td></tr>\n<tr>\n<td>P4<br/></td><td>3<br/></td><td>23<br/></td><td>20<br/></td><td>5<br/></td><td>15<br/></td></tr>\n<tr>\n<td>P5<br/></td><td>4<br/></td><td>14<br/></td><td>10<br/></td><td>2<br/></td><td>8<br/></td></tr>\n</table>\n\n<ul>\n<li>平均周转时间：$(25 + 17 + 26 + 20 + 10)&#x2F;5 &#x3D; 98&#x2F;5 &#x3D; 19.6$</li>\n<li>平均等待时间：$(17 + 13 + 17 + 15 + 8)&#x2F;5 &#x3D; 70&#x2F;5 &#x3D; 14$</li>\n</ul>\n<p>相比 FCFS、SJF&#x2F;SRTF，RR 的平均等待与周转时间更高，但响应时间更有保障（最坏响应时间为 3× 队列长度 ≈ 3×5 &#x3D; 15）。</p>\n<hr>\n<h3 id=\"多级反馈队列示例分析\"><a href=\"#多级反馈队列示例分析\" class=\"headerlink\" title=\"多级反馈队列示例分析\"></a>多级反馈队列示例分析</h3><h4 id=\"参数假设\"><a href=\"#参数假设\" class=\"headerlink\" title=\"参数假设\"></a>参数假设</h4><ul>\n<li><strong>队列数</strong>：3（Q0、Q1、Q2），优先级从高到低依次为 Q0 &gt; Q1 &gt; Q2。</li>\n<li><strong>时间片</strong>：</li>\n<li>Q0: 4</li>\n<li>Q1: 8</li>\n<li>Q2: FCFS（不再分时间片，相当于单独的 FCFS 队列）</li>\n<li><strong>进入队列规则</strong>：</li>\n</ul>\n<ol>\n<li>所有进程初始进入 Q0。</li>\n<li>在 Q0 中用完 4 单位还未完成，则降级到 Q1 队尾；</li>\n<li>在 Q1 中用完 8 单位还未完成，则降级到 Q2 队尾；</li>\n<li>在 Q2 中 FCFS 执行直至完成（不再降级）。</li>\n<li>未用满本级时间片而发生阻塞，则保持本级队列（按到达顺序放回队尾）。</li>\n<li>无晋升机制（简化模型）。</li>\n</ol>\n<h4 id=\"调度流程\"><a href=\"#调度流程\" class=\"headerlink\" title=\"调度流程\"></a>调度流程</h4><ol>\n<li><strong>时刻 0–4</strong></li>\n</ol>\n<ul>\n<li>Q0 队列：P1(8) → 执行 4 单位至 剩余 P1(4)，时刻 4，降级至 Q1 队尾。</li>\n<li>在时刻 1–4，P2(4)、P3(9)、P4(5)、P5(2) 先后到达，依次进入 Q0 队尾。</li>\n</ul>\n<ol>\n<li><strong>时刻 4–8</strong></li>\n</ol>\n<ul>\n<li>Q0 调度队头为 P2(4) → 执行 4 单位 完成，时刻 8。</li>\n<li>Q0 队列剩余：P3(9)、P4(5)、P5(2)</li>\n</ul>\n<ol>\n<li><strong>时刻 8–12</strong></li>\n</ol>\n<ul>\n<li>Q0 队头 P3(9) → 执行 4 单位，剩余 P3(5)，时刻 12，降级到 Q1 队尾。</li>\n<li>Q0 队列剩余：P4(5)、P5(2)</li>\n</ul>\n<ol>\n<li><strong>时刻 12–16</strong></li>\n</ol>\n<ul>\n<li>Q0 队头 P4(5) → 执行 4 单位，剩余 P4(1)，时刻 16，降级到 Q1 队尾。</li>\n<li>Q0 队列剩余：P5(2)</li>\n</ul>\n<ol>\n<li><strong>时刻 16–18</strong></li>\n</ol>\n<ul>\n<li>Q0 队头 P5(2) → 执行 2 单位 完成（未用满时片），时刻 18。</li>\n<li>Q0 队列空，此时切换到 Q1 队列。</li>\n</ul>\n<ol>\n<li><strong>Q1 轮询</strong></li>\n</ol>\n<ul>\n<li><p>Q1 队列：</p>\n<ol>\n<li>P1(4) → 执行 4 单位 完成，时刻 22（未用满时片、直接完成，出列）。</li>\n<li>P3(5) → 执行 5 单位 完成，时刻 27（未用满时片、直接完成）。</li>\n<li>P4(1) → 执行 1 单位 完成，时刻 28。</li>\n</ol>\n</li>\n</ul>\n<ol>\n<li><strong>Q2</strong></li>\n</ol>\n<ul>\n<li>对本示例数据，无进程在 Q1 用满 8 单位，因此 Q2 无进程。</li>\n</ul>\n<h4 id=\"调度时间线（简化）\"><a href=\"#调度时间线（简化）\" class=\"headerlink\" title=\"调度时间线（简化）\"></a>调度时间线（简化）</h4><figure class=\"highlight armasm\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">[<span class=\"number\">0</span>−<span class=\"number\">4</span>]   <span class=\"built_in\">P1</span> (<span class=\"built_in\">Q0</span>)  </span><br><span class=\"line\">[<span class=\"number\">4</span>−<span class=\"number\">8</span>]   <span class=\"built_in\">P2</span> (<span class=\"built_in\">Q0</span>)  </span><br><span class=\"line\">[<span class=\"number\">8</span>−<span class=\"number\">12</span>]  <span class=\"built_in\">P3</span> (<span class=\"built_in\">Q0</span>)  </span><br><span class=\"line\">[<span class=\"number\">12</span>−<span class=\"number\">16</span>] <span class=\"built_in\">P4</span> (<span class=\"built_in\">Q0</span>)  </span><br><span class=\"line\">[<span class=\"number\">16</span>−<span class=\"number\">18</span>] <span class=\"built_in\">P5</span> (<span class=\"built_in\">Q0</span>)  </span><br><span class=\"line\">[<span class=\"number\">18</span>−<span class=\"number\">22</span>] <span class=\"built_in\">P1</span> (<span class=\"built_in\">Q1</span>)  </span><br><span class=\"line\">[<span class=\"number\">22</span>−<span class=\"number\">27</span>] <span class=\"built_in\">P3</span> (<span class=\"built_in\">Q1</span>)  </span><br><span class=\"line\">[<span class=\"number\">27</span>−<span class=\"number\">28</span>] <span class=\"built_in\">P4</span> (<span class=\"built_in\">Q1</span>)</span><br></pre></td></tr></table></figure>\n\n<h4 id=\"多级反馈队列指标计算\"><a href=\"#多级反馈队列指标计算\" class=\"headerlink\" title=\"多级反馈队列指标计算\"></a>多级反馈队列指标计算</h4><table>\n<tr>\n<td>PID<br/></td><td>到达<br/></td><td>完成<br/></td><td>周转 = 完成−到达<br/></td><td>执行时间<br/></td><td>等待 = 周转 − 执行<br/></td></tr>\n<tr>\n<td>P1<br/></td><td>0<br/></td><td>22<br/></td><td>22<br/></td><td>8<br/></td><td>14<br/></td></tr>\n<tr>\n<td>P2<br/></td><td>1<br/></td><td>8<br/></td><td>7<br/></td><td>4<br/></td><td>3<br/></td></tr>\n<tr>\n<td>P3<br/></td><td>2<br/></td><td>27<br/></td><td>25<br/></td><td>9<br/></td><td>16<br/></td></tr>\n<tr>\n<td>P4<br/></td><td>3<br/></td><td>28<br/></td><td>25<br/></td><td>5<br/></td><td>20<br/></td></tr>\n<tr>\n<td>P5<br/></td><td>4<br/></td><td>18<br/></td><td>14<br/></td><td>2<br/></td><td>12<br/></td></tr>\n</table>\n\n<ul>\n<li>平均周转时间：$(22 + 7 + 25 + 25 + 14)&#x2F;5 &#x3D; 93&#x2F;5 &#x3D; 18.6$</li>\n<li>平均等待时间：$(14 + 3 + 16 + 20 + 12)&#x2F;5 &#x3D; 65&#x2F;5 &#x3D; 13$</li>\n</ul>\n<p>相比 FCFS、SJF、RR，MLFQ 在该示例中：</p>\n<ul>\n<li>短作业（P2、P5）在 Q0 快速完成，等待时间明显较少；</li>\n<li>长作业（P3、P4、P1）因在 Q0 多次降级，等待较长，但总周转时间依然优于简单 RR；</li>\n<li>综合考虑响应与吞吐，有一定折中效果。</li>\n</ul>\n<hr>\n<h2 id=\"调度算法的优缺点总结\"><a href=\"#调度算法的优缺点总结\" class=\"headerlink\" title=\"调度算法的优缺点总结\"></a>调度算法的优缺点总结</h2><table>\n<tr>\n<td>算法<br/></td><td>优点<br/></td><td>缺点<br/></td><td>适用场景<br/></td></tr>\n<tr>\n<td>FCFS<br/></td><td>实现简单；没有抢占开销<br/></td><td>平均等待/周转时间较大；易出现 Convoy Effect；无优先级区分<br/></td><td>批处理系统、后台任务<br/></td></tr>\n<tr>\n<td>SJF<br/></td><td>平均等待/周转时间最小<br/></td><td>需要预知执行时间；可能导致长作业饥饿<br/></td><td>静态或可预估作业的批处理<br/></td></tr>\n<tr>\n<td>SRTF<br/></td><td>响应迅速、平均等待较小<br/></td><td>抢占频繁，上下文切换开销大；同样存在饥饿<br/></td><td>对延迟敏感的批处理、实验环境<br/></td></tr>\n<tr>\n<td>优先级<br/></td><td>可根据重要性分配资源；实现灵活<br/></td><td>低优先级饥饿；优先级反转问题；需优先级分配策略<br/></td><td>实时系统、含不同优先级任务的系统<br/></td></tr>\n<tr>\n<td>RR<br/></td><td>公平分配、多用户响应快；无饥饿<br/></td><td>平均等待/周转时间偏大；需合理设置时间片<br/></td><td>交互式系统、时分多用户环境<br/></td></tr>\n<tr>\n<td>多级队列<br/></td><td>可对不同进程类型采用不同策略；实现简洁<br/></td><td>队列静态划分；低队列容易饥饿<br/></td><td>操作系统进程分层管理<br/></td></tr>\n<tr>\n<td>多级反馈队列<br/></td><td>综合考虑CPU/I-O 进程；响应与吞吐折中；防止饥饿<br/></td><td>参数较多，调优复杂；实现与维护开销大<br/></td><td>通用操作系统（如 Linux 早期调度）<br/></td></tr>\n<tr>\n<td>实时调度<br/></td><td>能保证任务在截止时间前完成；满足实时要求<br/></td><td>算法复杂；只能针对实时任务；可能牺牲吞吐量和公平性<br/></td><td>硬实时/软实时系统（如航天、工业控制）<br/></td></tr>\n</table>\n\n<hr>\n<h2 id=\"在实际操作系统中的典型应用\"><a href=\"#在实际操作系统中的典型应用\" class=\"headerlink\" title=\"在实际操作系统中的典型应用\"></a>在实际操作系统中的典型应用</h2><blockquote>\n<ul>\n<li><a href=\"https://www.cnblogs.com/wanghuaijun/p/8046992.html\">Linux，Windows 和 UNIX 的进程调度的分析 - 专注 it - 博客园</a></li>\n</ul>\n</blockquote>\n<ol>\n<li><strong>UNIX&#x2F;Linux 调度器</strong></li>\n</ol>\n<ul>\n<li>早期 UNIX 采用基于优先级的多级反馈队列调度（BSD 4.4 era）。</li>\n<li>Linux 2.6 → 3.x 采用 O(1) 调度器（使用固定数量队列和计时桶），基于多级反馈队列思想。</li>\n<li>从 Linux 2.6.23 以后，切换到 CFS（Completely Fair Scheduler，完全公平调度器），采用红黑树实现时间共享，极大提高公平性与可伸缩性。</li>\n</ul>\n<ol>\n<li><strong>Windows 调度器</strong></li>\n</ol>\n<ul>\n<li>采用最高响应优先级线程抢占 (preemptive, priority-based preemptive scheduling)，具有 32 级动态优先级和 1 级实时优先级。</li>\n<li>同时对 I&#x2F;O 密集型与 CPU 密集型线程进行动态优先级调整（I&#x2F;O 密集型短期优先，避免饥饿）。</li>\n</ul>\n<ol>\n<li><strong>实时操作系统（RTOS）</strong></li>\n</ol>\n<ul>\n<li>典型算法：固定优先级抢占调度（Rate Monotonic Scheduling, RMS）、最早截止时间优先 (Earliest Deadline First, EDF)。</li>\n<li>可保证在一定负载下满足硬实时任务的周期性执行约束。</li>\n</ul>\n<ol>\n<li><strong>虚拟化 &#x2F; 容器调度</strong></li>\n</ol>\n<ul>\n<li>Xen、KVM 等虚拟化平台需为每个虚拟 CPU 分配物理 CPU 时间片。</li>\n<li>Kubernetes 等容器编排系统中，每个容器对应多个线程&#x2F;进程，调度器采用 CFS，配合 cgroups 限制和调节 CPU 份额。</li>\n</ul>\n<hr>\n<h2 id=\"优化思路与扩展\"><a href=\"#优化思路与扩展\" class=\"headerlink\" title=\"优化思路与扩展\"></a>优化思路与扩展</h2><ol>\n<li><strong>自适应时间片</strong></li>\n</ol>\n<ul>\n<li>动态调整 RR 时间片大小：初始时给交互进程较小的时间片，若长时间占用则增大；</li>\n<li>可以减少上下文切换并兼顾 I&#x2F;O 密集型进程响应。</li>\n</ul>\n<ol>\n<li><strong>混合调度</strong></li>\n</ol>\n<ul>\n<li>在多级队列中对不同队列采用不同算法。例如：Q0 用 RR，Q1 用优先级，Q2 用 FCFS；</li>\n<li>结合实时任务与后台批处理任务，保证实时约束的同时兼顾吞吐。</li>\n</ul>\n<ol>\n<li><strong>基于负载的动态调度</strong></li>\n</ol>\n<ul>\n<li>在线监测系统负载、进程行为特征，对队列数、时间片长度、优先级自适应调整；</li>\n<li>典型做法：短进程优先、I&#x2F;O 密集任务优先、长时间等待任务提升优先级。</li>\n</ul>\n<ol>\n<li><strong>考虑缓存与上下文切换开销</strong></li>\n</ol>\n<ul>\n<li>在多核环境中，调度器需考虑缓存亲和性（CPU Affinity）、减少缓存抖动；</li>\n<li>结合软&#x2F;硬 NUMA 拓扑结构，将线程更合理地分配到 CPU 核心。</li>\n</ul>\n<ol>\n<li><strong>公平性与服务质量(QoS)</strong></li>\n</ol>\n<ul>\n<li>引入公平队列思路（如 CFS 红黑树），每个就绪线程按“虚拟运行时间”排序；</li>\n<li>在云&#x2F;容器环境中，根据配额&#x2F;优先级设定不同权重，保证租户公平与性能可预测。</li>\n</ul>\n<ol>\n<li><strong>能源感知 (Energy-aware Scheduling)</strong></li>\n</ol>\n<ul>\n<li>通过调度让低优先级进程在低频核上执行，高性能进程在高频核执行；</li>\n<li>动态调整 CPU 频率与电压（DVFS），配合负载情况与性能需求。</li>\n</ul>\n<hr>\n<h1 id=\"总结\"><a href=\"#总结\" class=\"headerlink\" title=\"总结\"></a>总结</h1><ul>\n<li><strong>进程调度算法</strong>是操作系统核心组件之一，直接影响系统性能、响应速度和公平性。</li>\n<li>常见单队列算法（FCFS、SJF&#x2F;SRTF、优先级调度、RR）应用于不同场景，各有优缺点：</li>\n<li>FCFS 实现简单，适合批处理；</li>\n<li>SJF&#x2F;SRTF 平均等待最小，但需预估执行时间；</li>\n<li>优先级调度可区分任务重要性，但需防止饥饿；</li>\n<li>RR 公平且适合交互式系统，但需谨慎设置时间片。</li>\n<li>多级队列与多级反馈队列结合了多种策略，兼顾交互与吞吐，可在通用操作系统中灵活应用，但实现与调优复杂。</li>\n<li>实际操作系统中（Linux、Windows、RTOS）多采用多级&#x2F;公平调度或基于红黑树的 CFS，以满足多核、多租户、实时与能耗等综合需求。</li>\n<li><strong>调度器优化方向</strong>：</li>\n</ul>\n<ol>\n<li>提高公平性（如 CFS&#x2F;Fair Queue）；</li>\n<li>降低上下文切换与缓存抖动开销；</li>\n<li>引入实时、能耗、负载感知等扩展；</li>\n<li>动态自适应调度参数以应对多变负载。</li>\n</ol>\n<p>无论在桌面、服务器、嵌入式还是云环境中，选择合适的调度算法并进行针对性优化，都是提升系统响应能力与吞吐效率的关键环节。</p>\n<hr>\n<h1 id=\"参考文献\"><a href=\"#参考文献\" class=\"headerlink\" title=\"参考文献\"></a>参考文献</h1><ul>\n<li><a href=\"https://www.wiley.com/en-us/Operating+System+Concepts%2C+10th+Edition-p-9781119320913\">Silberschatz, A., Galvin, P. B., &amp; Gagne, G. (2018). </a><em>Operating System Concepts</em><a href=\"https://www.wiley.com/en-us/Operating+System+Concepts%2C+10th+Edition-p-9781119320913\"> (10th Edition). Wiley.</a></li>\n<li><a href=\"https://www.pearson.com/store/p/modern-operating-systems/P100000253296\">Tanenbaum, A. S., &amp; Bos, H. (2014). </a><em>Modern Operating Systems</em><a href=\"https://www.pearson.com/store/p/modern-operating-systems/P100000253296\"> (4th Edition). Pearson.</a></li>\n<li><a href=\"https://www.pearson.com/store/p/operating-systems-internals-and-design-principles/P100000253343\">Stallings, W. (2018). </a><em>Operating Systems: Internals and Design Principles</em><a href=\"https://www.pearson.com/store/p/operating-systems-internals-and-design-principles/P100000253343\"> (9th Edition). Pearson.</a></li>\n<li><a href=\"https://www.informit.com/store/linux-kernel-development-9780672329463\">Love, R. (2010). </a><em>Linux Kernel Development</em><a href=\"https://www.informit.com/store/linux-kernel-development-9780672329463\"> (3rd Edition). Addison-Wesley.</a></li>\n<li><a href=\"https://www.oreilly.com/library/view/understanding-the-linux/0596005652/\">Bovet, D. P., &amp; Cesati, M. (2005). </a><em>Understanding the Linux Kernel</em><a href=\"https://www.oreilly.com/library/view/understanding-the-linux/0596005652/\"> (3rd Edition). O’Reilly Media.</a></li>\n<li><a href=\"https://docs.docker.com/config/containers/resource_constraints/\">Docker 官方文档：“Resource Management and Scheduling”</a></li>\n<li><a href=\"https://github.com/mozilla/NSScheduler\">Mozilla 开源项目 “NSScheduler” 源码与文档</a></li>\n<li><a href=\"https://rtems.org/rms\">“Rate Monotonic Scheduling (RMS)” Tutorial, Real-Time Systems Community.</a></li>\n<li><a href=\"https://rtems.org/edf\">“Earliest Deadline First (EDF) Scheduling”, Real-Time Systems Tutorial.</a></li>\n</ul>\n<blockquote>\n<p><strong>延伸阅读方向</strong>：</p>\n<ul>\n<li>现代多核环境下的调度（例如 CFS 的 Red-Black Tree 结构）</li>\n<li>云计算平台中的容器&#x2F;虚拟机资源调度策略</li>\n<li>实时操作系统中固定优先级 vs 动态优先级调度算法对比</li>\n</ul>\n</blockquote>\n","excerpt":"","more":"<h1 id=\"进程调度算法分析\"><a href=\"#进程调度算法分析\" class=\"headerlink\" title=\"进程调度算法分析\"></a>进程调度算法分析</h1><h1 id=\"参考资料\"><a href=\"#参考资料\" class=\"headerlink\" title=\"参考资料\"></a>参考资料</h1><blockquote>\n<ul>\n<li><a href=\"https://zhuanlan.zhihu.com/p/543205467\">一文看懂 Linux 内核调度分析（进程调度）一</a></li>\n<li><a href=\"https://zhuanlan.zhihu.com/p/661863529\">Linux 内核中常见的进程调度算法</a></li>\n<li><a href=\"https://blog.csdn.net/qq_41897304/article/details/130194906\">Linux 进程调度算法_linux 调度算法-CSDN 博客</a></li>\n<li><a href=\"https://www.cnblogs.com/xiaolincoding/p/13631224.html\">大厂面试爱问的「调度算法」，20 张图一举拿下 - 小林 coding - 博客园</a></li>\n<li><a href=\"https://gregsnotes.medium.com/how-do-cpus-execute-instructions-in-parallel-dfa15e87a86c\">gregsnotes.medium.com</a></li>\n</ul>\n</blockquote>\n<h1 id=\"概述\"><a href=\"#概述\" class=\"headerlink\" title=\"概述\"></a>概述</h1><h2 id=\"调度指标与目标\"><a href=\"#调度指标与目标\" class=\"headerlink\" title=\"调度指标与目标\"></a>调度指标与目标</h2><p><img src=\"https://gitee.com/tanke11223344/imagehost/raw/main/blog/1749361099852GUHDb2WbvordpDxnuNEcIg0zn0b.png\" alt=\"1749361099852GUHDb2WbvordpDxnuNEcIg0zn0b.png\"></p>\n<p>单核 CPU 处理多个进程和线程</p>\n<p>操作系统进程调度的核心目标在于合理分配 CPU 资源，使系统能够同时满足多个性能指标。常见的评估指标包括：</p>\n<ol>\n<li><strong>CPU 利用率（CPU Utilization）</strong></li>\n</ol>\n<ul>\n<li>CPU 在单位时间内非空闲状态的比例。理想情况下应尽量接近 100%。</li>\n</ul>\n<ol>\n<li><strong>吞吐量（Throughput）</strong></li>\n</ol>\n<ul>\n<li>单位时间内完成的作业（或进程）数量。吞吐量越高，单位时间完成任务越多。</li>\n</ul>\n<ol>\n<li><strong>周转时间（Turnaround Time）</strong></li>\n</ol>\n<ul>\n<li>从进程提交（到达）到完全执行结束所经历的总时间。</li>\n</ul>\n<p>$$<br>\\text{Turnaround Time} &#x3D; \\text{完成时间} - \\text{到达时间}<br>$$</p>\n<ol>\n<li><strong>带权周转时间（Weighted Turnaround Time）</strong></li>\n</ol>\n<ul>\n<li>周转时间与执行时间之比，用于衡量短作业或长作业的相对等待公平性。</li>\n</ul>\n<p>$$<br>\\text{Weighted Turnaround Time} &#x3D; \\frac{\\text{Turnaround Time}}{\\text{执行时间}}<br>$$</p>\n<ol>\n<li><strong>等待时间（Waiting Time）</strong></li>\n</ol>\n<ul>\n<li>进程在就绪队列中等待 CPU 的累积时间。</li>\n</ul>\n<p>$$<br>\\text{Waiting Time} &#x3D; \\text{Turnaround Time} - \\text{执行时间}<br>$$</p>\n<ol>\n<li><strong>响应时间（Response Time）</strong></li>\n</ol>\n<ul>\n<li>从进程提交到系统开始响应（第一次分配 CPU）的时间。</li>\n</ul>\n<p>$$<br>\\text{Response Time} &#x3D; \\text{第一次调度时间} - \\text{到达时间}<br>$$</p>\n<ol>\n<li><strong>公平性</strong></li>\n</ol>\n<ul>\n<li>同类进程应获得相似的资源分配和等待时间；避免饥饿（Starvation）。</li>\n</ul>\n<p>不同的调度算法在上述指标上表现各异，系统应根据场景需求权衡：</p>\n<ul>\n<li><strong>交互式系统</strong>：关注响应时间（如 GUI 系统、服务器应用）。</li>\n<li><strong>批处理系统</strong>：关注吞吐量与周转时间（如科学计算、大规模数据处理）。</li>\n<li><strong>实时系统</strong>：关注任务能否在规定的截止时间前完成，使用实时调度算法（如 Rate Monotonic Scheduling、Earliest Deadline First）。</li>\n</ul>\n<hr>\n<h2 id=\"调度算法的分类\"><a href=\"#调度算法的分类\" class=\"headerlink\" title=\"调度算法的分类\"></a>调度算法的分类</h2><p>根据是否支持抢占（Preemptive）和队列策略，可将操作系统中的调度算法大致分为两类：</p>\n<ol>\n<li><strong>非抢占式调度（Non-preemptive Scheduling）</strong></li>\n</ol>\n<ul>\n<li>一旦进程被分配 CPU，直到该进程自愿放弃 CPU（如执行完成或进入 I&#x2F;O 阻塞）才会切换。</li>\n<li>算法典型：先来先服务 (FCFS)、短作业优先 (SJF，非抢占版本)、优先级非抢占。</li>\n</ul>\n<ol>\n<li><strong>抢占式调度（Preemptive Scheduling）</strong></li>\n</ol>\n<ul>\n<li>若有更高优先级的进程到达或某种时间片用尽，会强制剥夺当前进程的 CPU。</li>\n<li>算法典型：短剩余时间优先 (SRTF)、优先级抢占、时间片轮转 (RR)、多级反馈队列等。</li>\n</ul>\n<p>此外，按照就绪队列结构的不同，调度亦可分为：</p>\n<ul>\n<li><strong>单级队列（Single Queue）</strong>：所有就绪进程放在同一队列中，统一调度（上述 FCFS、SJF、RR 等）。</li>\n<li><strong>多级队列（Multi-Level Queue）</strong>：根据进程类型（交互式 vs 批处理）、优先级等分类，将进程放入多个队列，根据队列优先级逐级调度。</li>\n<li><strong>多级反馈队列（Multi-Level Feedback Queue, MLFQ）</strong>：在多级队列的基础上，允许进程在不同队列间动态迁移，从而兼顾响应时间和吞吐量。</li>\n</ul>\n<hr>\n<h2 id=\"常见单队列调度算法\"><a href=\"#常见单队列调度算法\" class=\"headerlink\" title=\"常见单队列调度算法\"></a>常见单队列调度算法</h2><h3 id=\"先来先服务-FCFS\"><a href=\"#先来先服务-FCFS\" class=\"headerlink\" title=\"先来先服务 (FCFS)\"></a>先来先服务 (FCFS)</h3><p><strong>概念</strong>：</p>\n<p><img src=\"https://gitee.com/tanke11223344/imagehost/raw/main/blog/1749361112852SlmPb1s55oPHr4xbKuxcR095nZc.png\" alt=\"1749361112852SlmPb1s55oPHr4xbKuxcR095nZc.png\"></p>\n<ul>\n<li>最简单的调度算法，类比数据结构中的队列,按照进程到达就绪队列的先后顺序分配 CPU，不做抢占。</li>\n<li>类似排队买票：先到先服务。</li>\n</ul>\n<p><strong>基本流程</strong>：</p>\n<ol>\n<li>就绪队列中，按照到达时间排序。</li>\n<li>CPU 空闲时，从队头取出第一个进程执行，运行完毕后再取下一个。</li>\n</ol>\n<p><strong>优点</strong>：</p>\n<ul>\n<li>实现简单，易于理解和维护。</li>\n<li>进程切换开销少，无抢占导致的上下文切换开销。</li>\n</ul>\n<p><strong>缺点</strong>：</p>\n<ul>\n<li><strong>等待时间不可控</strong>：一旦前面有一个长作业，后续短作业就会被“长作业阻塞”（Convoy Effect），导致平均等待时间变长。</li>\n<li><strong>平均周转时间较大</strong>：对短作业不友好。</li>\n<li><strong>无差别对待</strong>：不支持优先级，易造成关键任务延迟。</li>\n</ul>\n<p><strong>适用场景</strong>：</p>\n<ul>\n<li>适合批处理系统中长时间运行、无需交互的作业调度。</li>\n</ul>\n<hr>\n<h3 id=\"短作业优先-SJF-与-最短剩余时间优先-SRTF\"><a href=\"#短作业优先-SJF-与-最短剩余时间优先-SRTF\" class=\"headerlink\" title=\"短作业优先 (SJF) 与 最短剩余时间优先 (SRTF)\"></a>短作业优先 (SJF) 与 最短剩余时间优先 (SRTF)</h3><h4 id=\"短作业优先-SJF-Shortest-Job-First\"><a href=\"#短作业优先-SJF-Shortest-Job-First\" class=\"headerlink\" title=\"短作业优先 (SJF, Shortest Job First)\"></a>短作业优先 (SJF, Shortest Job First)</h4><p><strong>概念</strong>：</p>\n<p><img src=\"https://gitee.com/tanke11223344/imagehost/raw/main/blog/1749361121852DiHgbhn6Lo2tr7xuqvscwpi2nxg.png\" alt=\"1749361121852DiHgbhn6Lo2tr7xuqvscwpi2nxg.png\"></p>\n<ul>\n<li>按照进程的估计执行时间（CPU Burst）长短来调度，优先选择执行时间最短的进程（非抢占）。</li>\n<li>可以最大化减少平均等待时间。</li>\n</ul>\n<p><strong>流程</strong>：</p>\n<ol>\n<li>当 CPU 空闲时，从就绪队列中选择执行时间最短的进程。</li>\n<li>该进程运行至完成，然后再次从剩余进程中选择最短的继续。</li>\n</ol>\n<p><strong>优点</strong>：</p>\n<ul>\n<li>平均等待时间最小（经证明）。</li>\n</ul>\n<p><strong>缺点</strong>：</p>\n<ul>\n<li><strong>需要预知执行时间</strong>：在实际系统中很难准确知道每个进程的执行时间，只能通过历史统计或猜测。</li>\n<li><strong>可能导致饥饿</strong>：如果系统中不断有短作业到来，长作业可能一直得不到执行机会。</li>\n</ul>\n<h4 id=\"最短剩余时间优先-SRTF-Shortest-Remaining-Time-First\"><a href=\"#最短剩余时间优先-SRTF-Shortest-Remaining-Time-First\" class=\"headerlink\" title=\"最短剩余时间优先 (SRTF, Shortest Remaining Time First)\"></a>最短剩余时间优先 (SRTF, Shortest Remaining Time First)</h4><p><strong>概念</strong>：</p>\n<ul>\n<li>是 SJF 的抢占式版本。</li>\n<li>当有新进程到达，若其估计总执行时间小于当前正在执行进程的剩余执行时间，则抢占当前进程，优先执行新进程。</li>\n</ul>\n<p><strong>流程</strong>：</p>\n<ol>\n<li>维护就绪队列中各进程的剩余执行时间。</li>\n<li>当新进程到达或某进程完成后，重新比较就绪队列中剩余时间最小的进程；若与当前执行进程不同，则进行抢占切换。</li>\n</ol>\n<p><strong>优点</strong>：</p>\n<ul>\n<li>平均等待时间更小，响应更及时。</li>\n</ul>\n<p><strong>缺点</strong>：</p>\n<ul>\n<li><strong>更频繁的上下文切换</strong>：可能每次新进程到来都要抢占，增加系统负载。</li>\n<li><strong>难以预测与饥饿问题</strong>：同样存在长进程饥饿风险。</li>\n</ul>\n<p><strong>适用场景</strong>：</p>\n<ul>\n<li>对平均等待时间要求很高、可接受大量切换开销的批处理环境。</li>\n</ul>\n<hr>\n<h3 id=\"优先级调度-Priority-Scheduling\"><a href=\"#优先级调度-Priority-Scheduling\" class=\"headerlink\" title=\"优先级调度 (Priority Scheduling)\"></a>优先级调度 (Priority Scheduling)</h3><p><strong>概念</strong>：</p>\n<p><img src=\"https://gitee.com/tanke11223344/imagehost/raw/main/blog/1749361133852G5ACbX27MoyabGxHSPOcVVCenIg.png\" alt=\"1749361133852G5ACbX27MoyabGxHSPOcVVCenIg.png\"></p>\n<ul>\n<li>每个进程都与一个优先级（Priority）相关联，调度时始终选择优先级最高（数值最小或最大，取决于实现约定）的进程执行。</li>\n<li>可分为非抢占式优先级调度和抢占式优先级调度：</li>\n<li><strong>非抢占式优先级</strong>：一旦进程被选中，直到它完成或自愿阻塞，其他高优先级进程到达也不能抢占。</li>\n<li><strong>抢占式优先级</strong>：如果有更高优先级的进程到达，会中断当前进程并调度高优先级进程执行。</li>\n</ul>\n<p><strong>优点</strong>：</p>\n<ul>\n<li>可以根据任务重要程度分配资源，实现“关键任务优先”。</li>\n</ul>\n<p><strong>缺点</strong>：</p>\n<ul>\n<li><strong>饥饿（Starvation）</strong>：低优先级进程可能长时间无法获得 CPU。如果系统中高优先级任务持续到达，则低优先级任务可能永远得不到服务。</li>\n<li><strong>优先级反转（Priority Inversion）</strong>：低优先级进程持有资源（如锁），阻止高优先级进程执行，造成高优先级任务等待。可通过“优先级继承”等机制缓解。</li>\n</ul>\n<p><strong>优先级分配策略</strong>：</p>\n<ul>\n<li><strong>静态优先级</strong>：在进程创建时分配，不随运行时变化。</li>\n<li><strong>动态优先级</strong>：随着进程运行行为或等待时间动态调整。例如：长时间在就绪队列中等待，优先级随时间递增；使用 “ aging” 技术防止饥饿。</li>\n</ul>\n<hr>\n<h3 id=\"时间片轮转-Round-Robin-RR\"><a href=\"#时间片轮转-Round-Robin-RR\" class=\"headerlink\" title=\"时间片轮转 (Round Robin, RR)\"></a>时间片轮转 (Round Robin, RR)</h3><p><strong>概念</strong>：</p>\n<p><img src=\"https://gitee.com/tanke11223344/imagehost/raw/main/blog/1749361149087XcrFbh95yoJy1VxxOlhcL4p3nne.png\" alt=\"1749361149087XcrFbh95yoJy1VxxOlhcL4p3nne.png\"></p>\n<ul>\n<li>将 CPU 时间分成若干固定长度的时间片（Time Quantum），系统维护一个进程就绪队列（通常是 FIFO）。</li>\n<li>每次调度时，将队头进程分配一个完整时间片或直到进程自行阻塞（I&#x2F;O）／完成。时间片用完后，将该进程移动到队尾，依此循环。</li>\n</ul>\n<p><strong>流程</strong>：</p>\n<ol>\n<li>初始化就绪队列，所有进程先按到达顺序加入队列。</li>\n<li>系统为队头进程分配时钟中断，每次时钟中断到来时：</li>\n</ol>\n<ul>\n<li>若进程尚未完成，且时间片已用完，则将其移动到队尾；</li>\n<li>若进程完成或主动阻塞，直接移除或放入相应 I&#x2F;O 等待队列。</li>\n</ul>\n<ol>\n<li>选取下一个队头进程，重复上述步骤。</li>\n</ol>\n<p><strong>关键参数</strong>：</p>\n<ul>\n<li>**时间片大小 (Quantum)**：</li>\n<li>小时间片 → 系统响应快，适合交互式处理；但上下文切换频繁，开销大。</li>\n<li>大时间片 → 切换开销小，但响应时间变长，接近 FCFS 效果。</li>\n<li>通常取值应使上下文切换开销远小于时间片时长（如上下文切换需要 1–2 μs，时间片一般设为 10–100 ms）。</li>\n</ul>\n<p><strong>优点</strong>：</p>\n<ul>\n<li>对所有进程一视同仁，易于实现和理解；</li>\n<li>响应时间有保证（最坏响应时间 &#x3D; 时间片 × 就绪进程数）；</li>\n<li>无饥饿，进程最终会被分配 CPU。</li>\n</ul>\n<p><strong>缺点</strong>：</p>\n<ul>\n<li>需要设置合适时间片；</li>\n<li>上下文切换带来额外开销；</li>\n<li>对 CPU 密集型与 I&#x2F;O 密集型进程无区分，可能浪费时间片给 CPU 密集型作业；</li>\n<li>如果时间片与进程执行时间不匹配，则吞吐量和周转时间可能不理想。</li>\n</ul>\n<p><strong>适用场景</strong>：</p>\n<ul>\n<li>交互式系统，要求快速响应用户输入的环境（如终端、桌面交互系统）。</li>\n</ul>\n<hr>\n<h2 id=\"多级队列调度与多级反馈队列调度\"><a href=\"#多级队列调度与多级反馈队列调度\" class=\"headerlink\" title=\"多级队列调度与多级反馈队列调度\"></a>多级队列调度与多级反馈队列调度</h2><h3 id=\"4-1-多级队列调度-Multi-Level-Queue\"><a href=\"#4-1-多级队列调度-Multi-Level-Queue\" class=\"headerlink\" title=\"4.1. 多级队列调度 (Multi-Level Queue)\"></a>4.1. 多级队列调度 (Multi-Level Queue)</h3><p><strong>概念</strong>：</p>\n<ul>\n<li>根据进程的类别、优先级、服务需求等，将进程划分到不同的就绪队列中。每个队列可应用不同的调度算法或不同时间片长度。</li>\n<li>各队列本身也按照优先级排列。当 CPU 空闲时，始终从最高优先级队列调度，若高优先级队列为空，才调度低优先级队列。</li>\n</ul>\n<p><strong>队列示例</strong>：</p>\n<ul>\n<li><strong>系统交互进程队列</strong>：RR 调度，时间片短；</li>\n<li><strong>批处理进程队列</strong>：FCFS 调度；</li>\n<li><strong>守护进程队列</strong>：优先级调度或 FCFS；</li>\n</ul>\n<p><strong>特点</strong>：</p>\n<ul>\n<li>不同类型进程获得不同的服务策略；</li>\n<li>各队列永久划分，不动态调整。</li>\n</ul>\n<p><strong>缺点</strong>：</p>\n<ul>\n<li>需要在设计阶段预先进行进程分类，不灵活；</li>\n<li>高优先级队列如果繁忙，低优先级队列可能饥饿。</li>\n</ul>\n<hr>\n<h3 id=\"多级反馈队列调度-Multi-Level-Feedback-Queue-MLFQ\"><a href=\"#多级反馈队列调度-Multi-Level-Feedback-Queue-MLFQ\" class=\"headerlink\" title=\"多级反馈队列调度 (Multi-Level Feedback Queue, MLFQ)\"></a>多级反馈队列调度 (Multi-Level Feedback Queue, MLFQ)</h3><p><strong>概念</strong>：</p>\n<p>时间片轮转和最高优先级算法的综合和拓展</p>\n<ul>\n<li>「多级」表示有多个队列，每个队列优先级从高到低，同时优先级越高时间片越短。</li>\n<li>「反馈」表示如果有新的进程加入优先级高的队列时，立刻停止当前正在运行的进程，转而去运行优先级高的队列；</li>\n</ul>\n<p><img src=\"https://gitee.com/tanke11223344/imagehost/raw/main/blog/1749361161852T6LZbQZ7Fon2d3xWr17cscH5nWw.png\" alt=\"1749361161852T6LZbQZ7Fon2d3xWr17cscH5nWw.png\"></p>\n<ul>\n<li>在多级队列基础上，为了提高灵活性，允许进程在不同队列间根据行为“反馈”向下或向上移动。</li>\n<li>目标：使得 I&#x2F;O 密集型（短 CPU burst）进程获得较高优先级，CPU 密集型（长 CPU burst）进程优先级逐渐降低，从而兼顾系统响应性和吞吐量。</li>\n</ul>\n<p><strong>常见策略参数</strong>：</p>\n<ol>\n<li>**队列数 (N)**：一般设为 3–5 级，从高到低优先级递减编号。</li>\n<li>**时间片 (Quantum)**：不同队列拥有不同时间片长度。一般高优先级队列时间片短（例如 8ms），中&#x2F;低级队列时间片依次加倍（16ms、32ms）。</li>\n<li><strong>晋升与降级规则</strong>：</li>\n</ol>\n<ul>\n<li><strong>降级</strong>：进程若在本级队列用完完整时间片（表明可能较 CPU 密集），则移动到下一低级队列；</li>\n<li><strong>晋升（或 Aging）</strong>：为了防止长期在低级队列的进程饥饿，可在一定条件下（如等待时间超过阈值）将其提升至更高级队列。</li>\n</ul>\n<p><strong>典型流程</strong>：</p>\n<ol>\n<li>所有进程初始进入最高优先级队列（队列 0）。</li>\n<li>CPU 空闲时，从优先级最高且非空队列选取队头进程执行一个时间片或至该进程阻塞&#x2F;完成。</li>\n<li>若用完时间片且仍未完成，则降级到下一级队列尾。</li>\n<li>若在某队列执行过程中阻塞（如进入 I&#x2F;O），则保持在当前队列级别（或执行完成后重新进入高优先级队列，具体实现可不同）。</li>\n<li>周期性或按需检查低级队列中的进程等待时间，执行晋升。</li>\n</ol>\n<p><strong>优点</strong>：</p>\n<ul>\n<li>区分不同工作特征的进程（I&#x2F;O 密集 vs CPU 密集），提高响应速度；</li>\n<li>通过动态反馈减少饥饿。</li>\n</ul>\n<p><strong>缺点</strong>：</p>\n<ul>\n<li>参数较多（队列数、时间片长度、晋升&#x2F;降级阈值等），需要调优；</li>\n<li>实现复杂度较高；</li>\n<li>若设计不合理，仍可能出现低优先级进程饥饿。</li>\n</ul>\n<p><strong>适用场景</strong>：</p>\n<ul>\n<li>一般通用操作系统（如 Linux 的 O(1) 调度器、早期 UNIX 调度），可兼顾交互式任务与后台批处理任务。</li>\n<li>要求较高响应性的桌面系统或要求分时公平性的多用户系统。</li>\n</ul>\n<hr>\n<h2 id=\"调度算法的性能评估示例\"><a href=\"#调度算法的性能评估示例\" class=\"headerlink\" title=\"调度算法的性能评估示例\"></a>调度算法的性能评估示例</h2><p>下面通过假设的进程集合与到达时间、执行（CPU）时间示例，分别在 FCFS、SJF&#x2F;SRTF、RR、和多级反馈队列环境下进行调度，计算关键指标并进行比较。</p>\n<h3 id=\"示例流程与假设数据\"><a href=\"#示例流程与假设数据\" class=\"headerlink\" title=\"示例流程与假设数据\"></a>示例流程与假设数据</h3><p>假设有 5 个进程，属性如下：</p>\n<table>\n<tr>\n<td>进程 PID<br/></td><td>到达时间 (Arrival)<br/></td><td>CPU 执行时间 (Burst)<br/></td><td>优先级 (Priority)\\*<br/></td></tr>\n<tr>\n<td>P1<br/></td><td>0<br/></td><td>8<br/></td><td>2<br/></td></tr>\n<tr>\n<td>P2<br/></td><td>1<br/></td><td>4<br/></td><td>1<br/></td></tr>\n<tr>\n<td>P3<br/></td><td>2<br/></td><td>9<br/></td><td>3<br/></td></tr>\n<tr>\n<td>P4<br/></td><td>3<br/></td><td>5<br/></td><td>2<br/></td></tr>\n<tr>\n<td>P5<br/></td><td>4<br/></td><td>2<br/></td><td>1<br/></td></tr>\n</table>\n\n<blockquote>\n<p>*仅在优先级调度或 MLFQ 中使用，数值越小优先级越高。</p>\n</blockquote>\n<ul>\n<li>假设系统在时刻 0 之后开始调度，并且已知所有进程到达时间与执行时间。</li>\n<li>时间单位可视为毫秒 (ms)。</li>\n</ul>\n<p>我们分别对以下调度算法进行分析：</p>\n<ol>\n<li>FCFS (非抢占)</li>\n<li>SJF (假设非抢占)</li>\n<li>SRTF (抢占式短作业优先)</li>\n<li>RR (时间片 &#x3D; 3)</li>\n<li>多级反馈队列 (3 级队列，时间片分别 4、8、∞；无晋升)</li>\n</ol>\n<h3 id=\"FCFS-调度示例分析\"><a href=\"#FCFS-调度示例分析\" class=\"headerlink\" title=\"FCFS 调度示例分析\"></a>FCFS 调度示例分析</h3><h4 id=\"调度顺序\"><a href=\"#调度顺序\" class=\"headerlink\" title=\"调度顺序\"></a>调度顺序</h4><table>\n<tr>\n<td>时间区间<br/></td><td>执行进程<br/></td></tr>\n<tr>\n<td>0–8<br/></td><td>P1<br/></td></tr>\n<tr>\n<td>8–12<br/></td><td>P2<br/></td></tr>\n<tr>\n<td>12–21<br/></td><td>P3<br/></td></tr>\n<tr>\n<td>21–26<br/></td><td>P4<br/></td></tr>\n<tr>\n<td>26–28<br/></td><td>P5<br/></td></tr>\n</table>\n\n<p>解释：</p>\n<ul>\n<li>时刻 0：P1 到达，分配 CPU；</li>\n<li>P1 用到时刻 8 才完成；</li>\n<li>时刻 1–4 期间，P2、P3、P4、P5 依序到达并进入队列；</li>\n<li>时刻 8：CPU 分配给队列头进程 P2（到达时间最早）；</li>\n<li>依此类推。</li>\n</ul>\n<h4 id=\"关键指标计算\"><a href=\"#关键指标计算\" class=\"headerlink\" title=\"关键指标计算\"></a>关键指标计算</h4><table>\n<tr>\n<td>PID<br/></td><td>到达时间<br/></td><td>完成时间 (Finish)<br/></td><td>周转时间 = Finish - Arrival<br/></td><td>执行时间 (Burst)<br/></td><td>等待时间 = Turnaround - Burst<br/></td></tr>\n<tr>\n<td>P1<br/></td><td>0<br/></td><td>8<br/></td><td>8<br/></td><td>8<br/></td><td>0<br/></td></tr>\n<tr>\n<td>P2<br/></td><td>1<br/></td><td>12<br/></td><td>11<br/></td><td>4<br/></td><td>7<br/></td></tr>\n<tr>\n<td>P3<br/></td><td>2<br/></td><td>21<br/></td><td>19<br/></td><td>9<br/></td><td>10<br/></td></tr>\n<tr>\n<td>P4<br/></td><td>3<br/></td><td>26<br/></td><td>23<br/></td><td>5<br/></td><td>18<br/></td></tr>\n<tr>\n<td>P5<br/></td><td>4<br/></td><td>28<br/></td><td>24<br/></td><td>2<br/></td><td>22<br/></td></tr>\n</table>\n\n<ul>\n<li><strong>平均周转时间</strong></li>\n</ul>\n<p>$$<br>\\frac{8 + 11 + 19 + 23 + 24}{5} &#x3D; \\frac{85}{5} &#x3D; 17<br>$$</p>\n<ul>\n<li><strong>平均等待时间</strong></li>\n</ul>\n<p>$$<br>\\frac{0 + 7 + 10 + 18 + 22}{5} &#x3D; \\frac{57}{5} &#x3D; 11.4<br>$$</p>\n<ul>\n<li><strong>平均带权周转时间</strong></li>\n</ul>\n<p>$$<br>\\frac{8&#x2F;8 + 11&#x2F;4 + 19&#x2F;9 + 23&#x2F;5 + 24&#x2F;2}{5} &#x3D; \\frac{1 + 2.75 + 2.11 + 4.6 + 12}{5} \\approx \\frac{22.46}{5} &#x3D; 4.49<br>$$</p>\n<hr>\n<h3 id=\"SJF-SRTF-调度示例分析\"><a href=\"#SJF-SRTF-调度示例分析\" class=\"headerlink\" title=\"SJF&#x2F;SRTF 调度示例分析\"></a>SJF&#x2F;SRTF 调度示例分析</h3><h4 id=\"非抢占式-SJF\"><a href=\"#非抢占式-SJF\" class=\"headerlink\" title=\"非抢占式 SJF\"></a>非抢占式 SJF</h4><ul>\n<li>排除尚未到达的进程，只在 CPU 空闲且队列中已有进程时进行选择。</li>\n</ul>\n<p><strong>调度顺序</strong>：</p>\n<ol>\n<li>时刻 0，P1 到达，CPU 分配给 P1。</li>\n<li>P1 执行到 8，期间 P2(1)、P3(2)、P4(3)、P5(4) 到达，队列内剩余执行时间分别 $P2:4, P3:9, P4:5, P5:2$。</li>\n<li>CPU 空闲时，于时刻 8 选择执行时间最短的 P5（Burst&#x3D;2），执行 8–10。</li>\n<li>时刻 10 选择剩余执行时间最短的 P2（Burst&#x3D;4），执行 10–14。</li>\n<li>时刻 14 选择 P4（Burst&#x3D;5），执行 14–19。</li>\n<li>最后执行 P3（Burst&#x3D;9），时刻 19–28。</li>\n</ol>\n<table>\n<tr>\n<td>时间区间<br/></td><td>执行进程<br/></td></tr>\n<tr>\n<td>0–8<br/></td><td>P1<br/></td></tr>\n<tr>\n<td>8–10<br/></td><td>P5<br/></td></tr>\n<tr>\n<td>10–14<br/></td><td>P2<br/></td></tr>\n<tr>\n<td>14–19<br/></td><td>P4<br/></td></tr>\n<tr>\n<td>19–28<br/></td><td>P3<br/></td></tr>\n</table>\n\n<h4 id=\"SJF-指标计算\"><a href=\"#SJF-指标计算\" class=\"headerlink\" title=\"SJF 指标计算\"></a>SJF 指标计算</h4><table>\n<tr>\n<td>PID<br/></td><td>到达<br/></td><td>完成<br/></td><td>周转 = 完成−到达<br/></td><td>执行<br/></td><td>等待 = 周转 − 执行<br/></td></tr>\n<tr>\n<td>P1<br/></td><td>0<br/></td><td>8<br/></td><td>8<br/></td><td>8<br/></td><td>0<br/></td></tr>\n<tr>\n<td>P2<br/></td><td>1<br/></td><td>14<br/></td><td>13<br/></td><td>4<br/></td><td>9<br/></td></tr>\n<tr>\n<td>P3<br/></td><td>2<br/></td><td>28<br/></td><td>26<br/></td><td>9<br/></td><td>17<br/></td></tr>\n<tr>\n<td>P4<br/></td><td>3<br/></td><td>19<br/></td><td>16<br/></td><td>5<br/></td><td>11<br/></td></tr>\n<tr>\n<td>P5<br/></td><td>4<br/></td><td>10<br/></td><td>6<br/></td><td>2<br/></td><td>4<br/></td></tr>\n</table>\n\n<ul>\n<li>平均周转时间：$(8 + 13 + 26 + 16 + 6)&#x2F;5 &#x3D; 69&#x2F;5 &#x3D; 13.8$</li>\n<li>平均等待时间：$(0 + 9 + 17 + 11 + 4)&#x2F;5 &#x3D; 41&#x2F;5 &#x3D; 8.2$</li>\n</ul>\n<p>相比 FCFS，SJF 平均周转、等待时间更低。</p>\n<hr>\n<h4 id=\"5-3-2-抢占式-SRTF\"><a href=\"#5-3-2-抢占式-SRTF\" class=\"headerlink\" title=\"5.3.2. 抢占式 SRTF\"></a>5.3.2. 抢占式 SRTF</h4><p>在 SJF 基础上，当有新进程到达且其剩余执行时间小于当前正在执行进程的剩余时间时，会发生抢占。</p>\n<p><strong>调度细节</strong>：</p>\n<ul>\n<li>时刻 0–1：P1 执行 0–1（剩余 7）</li>\n<li>时刻 1：P2 到达 (Burst&#x3D;4)，7 (P1 剩余) &gt; 4 → 抢占。P2 执行 1–2（剩余 3），P1 剩余 7</li>\n<li>时刻 2：P3 到达 (Burst&#x3D;9)，当前最短为 P2(3)，继续。P2 执行 2–3（剩余 2）</li>\n<li>时刻 3：P4 到达 (Burst&#x3D;5)，当前最短为 P2(2)，继续。P2 执行 3–4（剩余 1）</li>\n<li>时刻 4：P5 到达 (Burst&#x3D;2)，此时 P2(1) 与 P5(2)，P2 更短 → P2 执行 4–5（完成）</li>\n<li>较早完成 P2，队列剩余 P1(7)、P3(9)、P4(5)、P5(2)</li>\n<li>时刻 5：当前最短 P5(Burst&#x3D;2)，执行 5–7（完成）</li>\n<li>时刻 7：队列剩余 P1(7)、P3(9)、P4(5)，最短为 P4(5)，执行 7–12（剩余 0 → 完成）</li>\n<li>时刻 12：剩余 P1(7)、P3(9)，选择 P1(7)，执行 12–19（完成）</li>\n<li>时刻 19–28：最后 P3(9)，执行到 28（完成）</li>\n</ul>\n<table>\n<tr>\n<td>时间区间<br/></td><td>执行进程<br/></td></tr>\n<tr>\n<td>0–1<br/></td><td>P1<br/></td></tr>\n<tr>\n<td>1–4<br/></td><td>P2<br/></td></tr>\n<tr>\n<td>4–5<br/></td><td>P2<br/></td></tr>\n<tr>\n<td>5–7<br/></td><td>P5<br/></td></tr>\n<tr>\n<td>7–12<br/></td><td>P4<br/></td></tr>\n<tr>\n<td>12–19<br/></td><td>P1<br/></td></tr>\n<tr>\n<td>19–28<br/></td><td>P3<br/></td></tr>\n</table>\n\n<p>注意：由于多个时间点属于同一进程的继续执行，合并相邻时间段可简化为：</p>\n<figure class=\"highlight apache\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"attribute\">P1</span>: <span class=\"number\">0</span>−<span class=\"number\">1</span>, <span class=\"number\">12</span>−<span class=\"number\">19</span>  </span><br><span class=\"line\"><span class=\"attribute\">P2</span>: <span class=\"number\">1</span>−<span class=\"number\">5</span>  </span><br><span class=\"line\"><span class=\"attribute\">P5</span>: <span class=\"number\">5</span>−<span class=\"number\">7</span>  </span><br><span class=\"line\"><span class=\"attribute\">P4</span>: <span class=\"number\">7</span>−<span class=\"number\">12</span>  </span><br><span class=\"line\"><span class=\"attribute\">P3</span>: <span class=\"number\">19</span>−<span class=\"number\">28</span></span><br></pre></td></tr></table></figure>\n\n<h4 id=\"SRTF-指标计算\"><a href=\"#SRTF-指标计算\" class=\"headerlink\" title=\"SRTF 指标计算\"></a>SRTF 指标计算</h4><table>\n<tr>\n<td>PID<br/></td><td>到达<br/></td><td>完成<br/></td><td>周转 = 完成−到达<br/></td><td>执行时间<br/></td><td>等待 = 周转 − 执行<br/></td></tr>\n<tr>\n<td>P1<br/></td><td>0<br/></td><td>19<br/></td><td>19<br/></td><td>8<br/></td><td>11<br/></td></tr>\n<tr>\n<td>P2<br/></td><td>1<br/></td><td>5<br/></td><td>4<br/></td><td>4<br/></td><td>0<br/></td></tr>\n<tr>\n<td>P3<br/></td><td>2<br/></td><td>28<br/></td><td>26<br/></td><td>9<br/></td><td>17<br/></td></tr>\n<tr>\n<td>P4<br/></td><td>3<br/></td><td>12<br/></td><td>9<br/></td><td>5<br/></td><td>4<br/></td></tr>\n<tr>\n<td>P5<br/></td><td>4<br/></td><td>7<br/></td><td>3<br/></td><td>2<br/></td><td>1<br/></td></tr>\n</table>\n\n<ul>\n<li>平均周转时间：$(19 + 4 + 26 + 9 + 3)&#x2F;5 &#x3D; 61&#x2F;5 &#x3D; 12.2$</li>\n<li>平均等待时间：$(11 + 0 + 17 + 4 + 1)&#x2F;5 &#x3D; 33&#x2F;5 &#x3D; 6.6$</li>\n</ul>\n<p>相比 SJF，SRTF 的平均等待、周转时间略有改进，但切换开销更高。</p>\n<hr>\n<h3 id=\"RR-调度示例分析（时间片-3）\"><a href=\"#RR-调度示例分析（时间片-3）\" class=\"headerlink\" title=\"RR 调度示例分析（时间片 &#x3D; 3）\"></a>RR 调度示例分析（时间片 &#x3D; 3）</h3><p><strong>假设时间片（Quantum） &#x3D; 3</strong>。采用抢占式策略，时钟中断每 3 单位触发一次。</p>\n<h4 id=\"调度步骤\"><a href=\"#调度步骤\" class=\"headerlink\" title=\"调度步骤\"></a>调度步骤</h4><p><img src=\"https://gitee.com/tanke11223344/imagehost/raw/main/blog/1749361179853Sytlb2qLco04MixG0i5cz3AFnxd.png\" alt=\"1749361179853Sytlb2qLco04MixG0i5cz3AFnxd.png\"></p>\n<ol>\n<li><strong>时刻 0–1</strong></li>\n</ol>\n<ul>\n<li>P1 到达并开始执行。</li>\n<li>经过 1 单位（时刻 1），P2 到达，仍在 P1 时间片内继续。剩余时间：P1 (7)。</li>\n</ul>\n<ol>\n<li><strong>时刻 1–3</strong></li>\n</ol>\n<ul>\n<li>P1 继续执行至用完剩余时间片（3 单位），时刻 3 停止，剩余 P1(5)。</li>\n<li>队列顺序：P2 (到达时刻 1)、P3(2)、P4(3)。</li>\n</ul>\n<ol>\n<li><strong>时刻 3–6</strong></li>\n</ol>\n<ul>\n<li>从队头取 P2（执行 3 单位），时刻 6 剩余 P2（1）。</li>\n<li>新到达 P5(4) 已在队列尾。队列顺序：P3、P4、P5、P1（回到队尾）、P2(1)。</li>\n</ul>\n<ol>\n<li><strong>时刻 6–9</strong></li>\n</ol>\n<ul>\n<li>执行 P3 3 单位，时刻 9 剩余 P3(6)。队列：P4、P5、P1(5)、P2(1)、P3(6)。</li>\n</ul>\n<ol>\n<li><strong>时刻 9–12</strong></li>\n</ol>\n<ul>\n<li>执行 P4 3 单位，时刻 12 剩余 P4(2)。队列：P5、P1(5)、P2(1)、P3(6)、P4(2)。</li>\n</ul>\n<ol>\n<li><strong>时刻 12–14</strong></li>\n</ol>\n<ul>\n<li>执行 P5 2 单位（用完）、时刻 14 完成。队列：P1(5)、P2(1)、P3(6)、P4(2)。</li>\n</ul>\n<ol>\n<li><strong>时刻 14–17</strong></li>\n</ol>\n<ul>\n<li>执行 P1 3 单位，时刻 17 剩余 P1(2)。队列：P2(1)、P3(6)、P4(2)、P1(2)。</li>\n</ul>\n<ol>\n<li><strong>时刻 17–18</strong></li>\n</ol>\n<ul>\n<li>执行 P2 1 单位（完成），时刻 18。队列：P3(6)、P4(2)、P1(2)。</li>\n</ul>\n<ol>\n<li><strong>时刻 18–21</strong></li>\n</ol>\n<ul>\n<li>执行 P3 3 单位，时刻 21 剩余 P3(3)。队列：P4(2)、P1(2)、P3(3)。</li>\n</ul>\n<ol>\n<li><p><strong>时刻 21–23</strong></p>\n<ul>\n<li>执行 P4 2 单位（完成），时刻 23。队列：P1(2)、P3(3)。</li>\n</ul>\n</li>\n<li><p><strong>时刻 23–25</strong></p>\n<ul>\n<li>执行 P1 2 单位（完成），时刻 25。队列：P3(3)。</li>\n</ul>\n</li>\n<li><p><strong>时刻 25–28</strong></p>\n<ul>\n<li>执行 P3 3 单位（完成），时刻 28。队列空。</li>\n</ul>\n</li>\n</ol>\n<h4 id=\"调度时间线（Gantt-图）\"><a href=\"#调度时间线（Gantt-图）\" class=\"headerlink\" title=\"调度时间线（Gantt 图）\"></a>调度时间线（Gantt 图）</h4><p><img src=\"https://gitee.com/tanke11223344/imagehost/raw/main/blog/1749361187852I1ojbIWGEoHOfLxgZsJciFdWnqd.png\" alt=\"1749361187852I1ojbIWGEoHOfLxgZsJciFdWnqd.png\"></p>\n<p>合并表示为各个片段与时间区间：</p>\n<figure class=\"highlight markdown\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">[<span class=\"symbol\">0−3</span>]: <span class=\"link\">P1  </span></span><br><span class=\"line\">[<span class=\"symbol\">3−6</span>]: <span class=\"link\">P2  </span></span><br><span class=\"line\">[<span class=\"symbol\">6−9</span>]: <span class=\"link\">P3  </span></span><br><span class=\"line\">[<span class=\"symbol\">9−12</span>]: <span class=\"link\">P4  </span></span><br><span class=\"line\">[<span class=\"symbol\">12−14</span>]: <span class=\"link\">P5  </span></span><br><span class=\"line\">[<span class=\"symbol\">14−17</span>]: <span class=\"link\">P1  </span></span><br><span class=\"line\">[<span class=\"symbol\">17−18</span>]: <span class=\"link\">P2  </span></span><br><span class=\"line\">[<span class=\"symbol\">18−21</span>]: <span class=\"link\">P3  </span></span><br><span class=\"line\">[<span class=\"symbol\">21−23</span>]: <span class=\"link\">P4  </span></span><br><span class=\"line\">[<span class=\"symbol\">23−25</span>]: <span class=\"link\">P1  </span></span><br><span class=\"line\">[<span class=\"symbol\">25−28</span>]: <span class=\"link\">P3</span></span><br></pre></td></tr></table></figure>\n\n<h4 id=\"RR-指标计算\"><a href=\"#RR-指标计算\" class=\"headerlink\" title=\"RR 指标计算\"></a>RR 指标计算</h4><table>\n<tr>\n<td>PID<br/></td><td>到达<br/></td><td>完成<br/></td><td>周转 = 完成−到达<br/></td><td>执行时间<br/></td><td>等待 = 周转−执行<br/></td></tr>\n<tr>\n<td>P1<br/></td><td>0<br/></td><td>25<br/></td><td>25<br/></td><td>8<br/></td><td>17<br/></td></tr>\n<tr>\n<td>P2<br/></td><td>1<br/></td><td>18<br/></td><td>17<br/></td><td>4<br/></td><td>13<br/></td></tr>\n<tr>\n<td>P3<br/></td><td>2<br/></td><td>28<br/></td><td>26<br/></td><td>9<br/></td><td>17<br/></td></tr>\n<tr>\n<td>P4<br/></td><td>3<br/></td><td>23<br/></td><td>20<br/></td><td>5<br/></td><td>15<br/></td></tr>\n<tr>\n<td>P5<br/></td><td>4<br/></td><td>14<br/></td><td>10<br/></td><td>2<br/></td><td>8<br/></td></tr>\n</table>\n\n<ul>\n<li>平均周转时间：$(25 + 17 + 26 + 20 + 10)&#x2F;5 &#x3D; 98&#x2F;5 &#x3D; 19.6$</li>\n<li>平均等待时间：$(17 + 13 + 17 + 15 + 8)&#x2F;5 &#x3D; 70&#x2F;5 &#x3D; 14$</li>\n</ul>\n<p>相比 FCFS、SJF&#x2F;SRTF，RR 的平均等待与周转时间更高，但响应时间更有保障（最坏响应时间为 3× 队列长度 ≈ 3×5 &#x3D; 15）。</p>\n<hr>\n<h3 id=\"多级反馈队列示例分析\"><a href=\"#多级反馈队列示例分析\" class=\"headerlink\" title=\"多级反馈队列示例分析\"></a>多级反馈队列示例分析</h3><h4 id=\"参数假设\"><a href=\"#参数假设\" class=\"headerlink\" title=\"参数假设\"></a>参数假设</h4><ul>\n<li><strong>队列数</strong>：3（Q0、Q1、Q2），优先级从高到低依次为 Q0 &gt; Q1 &gt; Q2。</li>\n<li><strong>时间片</strong>：</li>\n<li>Q0: 4</li>\n<li>Q1: 8</li>\n<li>Q2: FCFS（不再分时间片，相当于单独的 FCFS 队列）</li>\n<li><strong>进入队列规则</strong>：</li>\n</ul>\n<ol>\n<li>所有进程初始进入 Q0。</li>\n<li>在 Q0 中用完 4 单位还未完成，则降级到 Q1 队尾；</li>\n<li>在 Q1 中用完 8 单位还未完成，则降级到 Q2 队尾；</li>\n<li>在 Q2 中 FCFS 执行直至完成（不再降级）。</li>\n<li>未用满本级时间片而发生阻塞，则保持本级队列（按到达顺序放回队尾）。</li>\n<li>无晋升机制（简化模型）。</li>\n</ol>\n<h4 id=\"调度流程\"><a href=\"#调度流程\" class=\"headerlink\" title=\"调度流程\"></a>调度流程</h4><ol>\n<li><strong>时刻 0–4</strong></li>\n</ol>\n<ul>\n<li>Q0 队列：P1(8) → 执行 4 单位至 剩余 P1(4)，时刻 4，降级至 Q1 队尾。</li>\n<li>在时刻 1–4，P2(4)、P3(9)、P4(5)、P5(2) 先后到达，依次进入 Q0 队尾。</li>\n</ul>\n<ol>\n<li><strong>时刻 4–8</strong></li>\n</ol>\n<ul>\n<li>Q0 调度队头为 P2(4) → 执行 4 单位 完成，时刻 8。</li>\n<li>Q0 队列剩余：P3(9)、P4(5)、P5(2)</li>\n</ul>\n<ol>\n<li><strong>时刻 8–12</strong></li>\n</ol>\n<ul>\n<li>Q0 队头 P3(9) → 执行 4 单位，剩余 P3(5)，时刻 12，降级到 Q1 队尾。</li>\n<li>Q0 队列剩余：P4(5)、P5(2)</li>\n</ul>\n<ol>\n<li><strong>时刻 12–16</strong></li>\n</ol>\n<ul>\n<li>Q0 队头 P4(5) → 执行 4 单位，剩余 P4(1)，时刻 16，降级到 Q1 队尾。</li>\n<li>Q0 队列剩余：P5(2)</li>\n</ul>\n<ol>\n<li><strong>时刻 16–18</strong></li>\n</ol>\n<ul>\n<li>Q0 队头 P5(2) → 执行 2 单位 完成（未用满时片），时刻 18。</li>\n<li>Q0 队列空，此时切换到 Q1 队列。</li>\n</ul>\n<ol>\n<li><strong>Q1 轮询</strong></li>\n</ol>\n<ul>\n<li><p>Q1 队列：</p>\n<ol>\n<li>P1(4) → 执行 4 单位 完成，时刻 22（未用满时片、直接完成，出列）。</li>\n<li>P3(5) → 执行 5 单位 完成，时刻 27（未用满时片、直接完成）。</li>\n<li>P4(1) → 执行 1 单位 完成，时刻 28。</li>\n</ol>\n</li>\n</ul>\n<ol>\n<li><strong>Q2</strong></li>\n</ol>\n<ul>\n<li>对本示例数据，无进程在 Q1 用满 8 单位，因此 Q2 无进程。</li>\n</ul>\n<h4 id=\"调度时间线（简化）\"><a href=\"#调度时间线（简化）\" class=\"headerlink\" title=\"调度时间线（简化）\"></a>调度时间线（简化）</h4><figure class=\"highlight armasm\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">[<span class=\"number\">0</span>−<span class=\"number\">4</span>]   <span class=\"built_in\">P1</span> (<span class=\"built_in\">Q0</span>)  </span><br><span class=\"line\">[<span class=\"number\">4</span>−<span class=\"number\">8</span>]   <span class=\"built_in\">P2</span> (<span class=\"built_in\">Q0</span>)  </span><br><span class=\"line\">[<span class=\"number\">8</span>−<span class=\"number\">12</span>]  <span class=\"built_in\">P3</span> (<span class=\"built_in\">Q0</span>)  </span><br><span class=\"line\">[<span class=\"number\">12</span>−<span class=\"number\">16</span>] <span class=\"built_in\">P4</span> (<span class=\"built_in\">Q0</span>)  </span><br><span class=\"line\">[<span class=\"number\">16</span>−<span class=\"number\">18</span>] <span class=\"built_in\">P5</span> (<span class=\"built_in\">Q0</span>)  </span><br><span class=\"line\">[<span class=\"number\">18</span>−<span class=\"number\">22</span>] <span class=\"built_in\">P1</span> (<span class=\"built_in\">Q1</span>)  </span><br><span class=\"line\">[<span class=\"number\">22</span>−<span class=\"number\">27</span>] <span class=\"built_in\">P3</span> (<span class=\"built_in\">Q1</span>)  </span><br><span class=\"line\">[<span class=\"number\">27</span>−<span class=\"number\">28</span>] <span class=\"built_in\">P4</span> (<span class=\"built_in\">Q1</span>)</span><br></pre></td></tr></table></figure>\n\n<h4 id=\"多级反馈队列指标计算\"><a href=\"#多级反馈队列指标计算\" class=\"headerlink\" title=\"多级反馈队列指标计算\"></a>多级反馈队列指标计算</h4><table>\n<tr>\n<td>PID<br/></td><td>到达<br/></td><td>完成<br/></td><td>周转 = 完成−到达<br/></td><td>执行时间<br/></td><td>等待 = 周转 − 执行<br/></td></tr>\n<tr>\n<td>P1<br/></td><td>0<br/></td><td>22<br/></td><td>22<br/></td><td>8<br/></td><td>14<br/></td></tr>\n<tr>\n<td>P2<br/></td><td>1<br/></td><td>8<br/></td><td>7<br/></td><td>4<br/></td><td>3<br/></td></tr>\n<tr>\n<td>P3<br/></td><td>2<br/></td><td>27<br/></td><td>25<br/></td><td>9<br/></td><td>16<br/></td></tr>\n<tr>\n<td>P4<br/></td><td>3<br/></td><td>28<br/></td><td>25<br/></td><td>5<br/></td><td>20<br/></td></tr>\n<tr>\n<td>P5<br/></td><td>4<br/></td><td>18<br/></td><td>14<br/></td><td>2<br/></td><td>12<br/></td></tr>\n</table>\n\n<ul>\n<li>平均周转时间：$(22 + 7 + 25 + 25 + 14)&#x2F;5 &#x3D; 93&#x2F;5 &#x3D; 18.6$</li>\n<li>平均等待时间：$(14 + 3 + 16 + 20 + 12)&#x2F;5 &#x3D; 65&#x2F;5 &#x3D; 13$</li>\n</ul>\n<p>相比 FCFS、SJF、RR，MLFQ 在该示例中：</p>\n<ul>\n<li>短作业（P2、P5）在 Q0 快速完成，等待时间明显较少；</li>\n<li>长作业（P3、P4、P1）因在 Q0 多次降级，等待较长，但总周转时间依然优于简单 RR；</li>\n<li>综合考虑响应与吞吐，有一定折中效果。</li>\n</ul>\n<hr>\n<h2 id=\"调度算法的优缺点总结\"><a href=\"#调度算法的优缺点总结\" class=\"headerlink\" title=\"调度算法的优缺点总结\"></a>调度算法的优缺点总结</h2><table>\n<tr>\n<td>算法<br/></td><td>优点<br/></td><td>缺点<br/></td><td>适用场景<br/></td></tr>\n<tr>\n<td>FCFS<br/></td><td>实现简单；没有抢占开销<br/></td><td>平均等待/周转时间较大；易出现 Convoy Effect；无优先级区分<br/></td><td>批处理系统、后台任务<br/></td></tr>\n<tr>\n<td>SJF<br/></td><td>平均等待/周转时间最小<br/></td><td>需要预知执行时间；可能导致长作业饥饿<br/></td><td>静态或可预估作业的批处理<br/></td></tr>\n<tr>\n<td>SRTF<br/></td><td>响应迅速、平均等待较小<br/></td><td>抢占频繁，上下文切换开销大；同样存在饥饿<br/></td><td>对延迟敏感的批处理、实验环境<br/></td></tr>\n<tr>\n<td>优先级<br/></td><td>可根据重要性分配资源；实现灵活<br/></td><td>低优先级饥饿；优先级反转问题；需优先级分配策略<br/></td><td>实时系统、含不同优先级任务的系统<br/></td></tr>\n<tr>\n<td>RR<br/></td><td>公平分配、多用户响应快；无饥饿<br/></td><td>平均等待/周转时间偏大；需合理设置时间片<br/></td><td>交互式系统、时分多用户环境<br/></td></tr>\n<tr>\n<td>多级队列<br/></td><td>可对不同进程类型采用不同策略；实现简洁<br/></td><td>队列静态划分；低队列容易饥饿<br/></td><td>操作系统进程分层管理<br/></td></tr>\n<tr>\n<td>多级反馈队列<br/></td><td>综合考虑CPU/I-O 进程；响应与吞吐折中；防止饥饿<br/></td><td>参数较多，调优复杂；实现与维护开销大<br/></td><td>通用操作系统（如 Linux 早期调度）<br/></td></tr>\n<tr>\n<td>实时调度<br/></td><td>能保证任务在截止时间前完成；满足实时要求<br/></td><td>算法复杂；只能针对实时任务；可能牺牲吞吐量和公平性<br/></td><td>硬实时/软实时系统（如航天、工业控制）<br/></td></tr>\n</table>\n\n<hr>\n<h2 id=\"在实际操作系统中的典型应用\"><a href=\"#在实际操作系统中的典型应用\" class=\"headerlink\" title=\"在实际操作系统中的典型应用\"></a>在实际操作系统中的典型应用</h2><blockquote>\n<ul>\n<li><a href=\"https://www.cnblogs.com/wanghuaijun/p/8046992.html\">Linux，Windows 和 UNIX 的进程调度的分析 - 专注 it - 博客园</a></li>\n</ul>\n</blockquote>\n<ol>\n<li><strong>UNIX&#x2F;Linux 调度器</strong></li>\n</ol>\n<ul>\n<li>早期 UNIX 采用基于优先级的多级反馈队列调度（BSD 4.4 era）。</li>\n<li>Linux 2.6 → 3.x 采用 O(1) 调度器（使用固定数量队列和计时桶），基于多级反馈队列思想。</li>\n<li>从 Linux 2.6.23 以后，切换到 CFS（Completely Fair Scheduler，完全公平调度器），采用红黑树实现时间共享，极大提高公平性与可伸缩性。</li>\n</ul>\n<ol>\n<li><strong>Windows 调度器</strong></li>\n</ol>\n<ul>\n<li>采用最高响应优先级线程抢占 (preemptive, priority-based preemptive scheduling)，具有 32 级动态优先级和 1 级实时优先级。</li>\n<li>同时对 I&#x2F;O 密集型与 CPU 密集型线程进行动态优先级调整（I&#x2F;O 密集型短期优先，避免饥饿）。</li>\n</ul>\n<ol>\n<li><strong>实时操作系统（RTOS）</strong></li>\n</ol>\n<ul>\n<li>典型算法：固定优先级抢占调度（Rate Monotonic Scheduling, RMS）、最早截止时间优先 (Earliest Deadline First, EDF)。</li>\n<li>可保证在一定负载下满足硬实时任务的周期性执行约束。</li>\n</ul>\n<ol>\n<li><strong>虚拟化 &#x2F; 容器调度</strong></li>\n</ol>\n<ul>\n<li>Xen、KVM 等虚拟化平台需为每个虚拟 CPU 分配物理 CPU 时间片。</li>\n<li>Kubernetes 等容器编排系统中，每个容器对应多个线程&#x2F;进程，调度器采用 CFS，配合 cgroups 限制和调节 CPU 份额。</li>\n</ul>\n<hr>\n<h2 id=\"优化思路与扩展\"><a href=\"#优化思路与扩展\" class=\"headerlink\" title=\"优化思路与扩展\"></a>优化思路与扩展</h2><ol>\n<li><strong>自适应时间片</strong></li>\n</ol>\n<ul>\n<li>动态调整 RR 时间片大小：初始时给交互进程较小的时间片，若长时间占用则增大；</li>\n<li>可以减少上下文切换并兼顾 I&#x2F;O 密集型进程响应。</li>\n</ul>\n<ol>\n<li><strong>混合调度</strong></li>\n</ol>\n<ul>\n<li>在多级队列中对不同队列采用不同算法。例如：Q0 用 RR，Q1 用优先级，Q2 用 FCFS；</li>\n<li>结合实时任务与后台批处理任务，保证实时约束的同时兼顾吞吐。</li>\n</ul>\n<ol>\n<li><strong>基于负载的动态调度</strong></li>\n</ol>\n<ul>\n<li>在线监测系统负载、进程行为特征，对队列数、时间片长度、优先级自适应调整；</li>\n<li>典型做法：短进程优先、I&#x2F;O 密集任务优先、长时间等待任务提升优先级。</li>\n</ul>\n<ol>\n<li><strong>考虑缓存与上下文切换开销</strong></li>\n</ol>\n<ul>\n<li>在多核环境中，调度器需考虑缓存亲和性（CPU Affinity）、减少缓存抖动；</li>\n<li>结合软&#x2F;硬 NUMA 拓扑结构，将线程更合理地分配到 CPU 核心。</li>\n</ul>\n<ol>\n<li><strong>公平性与服务质量(QoS)</strong></li>\n</ol>\n<ul>\n<li>引入公平队列思路（如 CFS 红黑树），每个就绪线程按“虚拟运行时间”排序；</li>\n<li>在云&#x2F;容器环境中，根据配额&#x2F;优先级设定不同权重，保证租户公平与性能可预测。</li>\n</ul>\n<ol>\n<li><strong>能源感知 (Energy-aware Scheduling)</strong></li>\n</ol>\n<ul>\n<li>通过调度让低优先级进程在低频核上执行，高性能进程在高频核执行；</li>\n<li>动态调整 CPU 频率与电压（DVFS），配合负载情况与性能需求。</li>\n</ul>\n<hr>\n<h1 id=\"总结\"><a href=\"#总结\" class=\"headerlink\" title=\"总结\"></a>总结</h1><ul>\n<li><strong>进程调度算法</strong>是操作系统核心组件之一，直接影响系统性能、响应速度和公平性。</li>\n<li>常见单队列算法（FCFS、SJF&#x2F;SRTF、优先级调度、RR）应用于不同场景，各有优缺点：</li>\n<li>FCFS 实现简单，适合批处理；</li>\n<li>SJF&#x2F;SRTF 平均等待最小，但需预估执行时间；</li>\n<li>优先级调度可区分任务重要性，但需防止饥饿；</li>\n<li>RR 公平且适合交互式系统，但需谨慎设置时间片。</li>\n<li>多级队列与多级反馈队列结合了多种策略，兼顾交互与吞吐，可在通用操作系统中灵活应用，但实现与调优复杂。</li>\n<li>实际操作系统中（Linux、Windows、RTOS）多采用多级&#x2F;公平调度或基于红黑树的 CFS，以满足多核、多租户、实时与能耗等综合需求。</li>\n<li><strong>调度器优化方向</strong>：</li>\n</ul>\n<ol>\n<li>提高公平性（如 CFS&#x2F;Fair Queue）；</li>\n<li>降低上下文切换与缓存抖动开销；</li>\n<li>引入实时、能耗、负载感知等扩展；</li>\n<li>动态自适应调度参数以应对多变负载。</li>\n</ol>\n<p>无论在桌面、服务器、嵌入式还是云环境中，选择合适的调度算法并进行针对性优化，都是提升系统响应能力与吞吐效率的关键环节。</p>\n<hr>\n<h1 id=\"参考文献\"><a href=\"#参考文献\" class=\"headerlink\" title=\"参考文献\"></a>参考文献</h1><ul>\n<li><a href=\"https://www.wiley.com/en-us/Operating+System+Concepts%2C+10th+Edition-p-9781119320913\">Silberschatz, A., Galvin, P. B., &amp; Gagne, G. (2018). </a><em>Operating System Concepts</em><a href=\"https://www.wiley.com/en-us/Operating+System+Concepts%2C+10th+Edition-p-9781119320913\"> (10th Edition). Wiley.</a></li>\n<li><a href=\"https://www.pearson.com/store/p/modern-operating-systems/P100000253296\">Tanenbaum, A. S., &amp; Bos, H. (2014). </a><em>Modern Operating Systems</em><a href=\"https://www.pearson.com/store/p/modern-operating-systems/P100000253296\"> (4th Edition). Pearson.</a></li>\n<li><a href=\"https://www.pearson.com/store/p/operating-systems-internals-and-design-principles/P100000253343\">Stallings, W. (2018). </a><em>Operating Systems: Internals and Design Principles</em><a href=\"https://www.pearson.com/store/p/operating-systems-internals-and-design-principles/P100000253343\"> (9th Edition). Pearson.</a></li>\n<li><a href=\"https://www.informit.com/store/linux-kernel-development-9780672329463\">Love, R. (2010). </a><em>Linux Kernel Development</em><a href=\"https://www.informit.com/store/linux-kernel-development-9780672329463\"> (3rd Edition). Addison-Wesley.</a></li>\n<li><a href=\"https://www.oreilly.com/library/view/understanding-the-linux/0596005652/\">Bovet, D. P., &amp; Cesati, M. (2005). </a><em>Understanding the Linux Kernel</em><a href=\"https://www.oreilly.com/library/view/understanding-the-linux/0596005652/\"> (3rd Edition). O’Reilly Media.</a></li>\n<li><a href=\"https://docs.docker.com/config/containers/resource_constraints/\">Docker 官方文档：“Resource Management and Scheduling”</a></li>\n<li><a href=\"https://github.com/mozilla/NSScheduler\">Mozilla 开源项目 “NSScheduler” 源码与文档</a></li>\n<li><a href=\"https://rtems.org/rms\">“Rate Monotonic Scheduling (RMS)” Tutorial, Real-Time Systems Community.</a></li>\n<li><a href=\"https://rtems.org/edf\">“Earliest Deadline First (EDF) Scheduling”, Real-Time Systems Tutorial.</a></li>\n</ul>\n<blockquote>\n<p><strong>延伸阅读方向</strong>：</p>\n<ul>\n<li>现代多核环境下的调度（例如 CFS 的 Red-Black Tree 结构）</li>\n<li>云计算平台中的容器&#x2F;虚拟机资源调度策略</li>\n<li>实时操作系统中固定优先级 vs 动态优先级调度算法对比</li>\n</ul>\n</blockquote>\n"},{"title":"2025-05-07-二分查找","date":"2025-05-06T16:00:00.000Z","_content":"# 2025-05-07-二分查找\n\n> 参考博客\n> [代码随想录](https://programmercarl.com/0704.%E4%BA%8C%E5%88%86%E6%9F%A5%E6%89%BE.html#%E6%80%9D%E8%B7%AF)\n\n使用二分法的前提条件\n\n- 元素有序且不重复\n\n希望通过这道题目，大家会发现平时写二分法，为什么总写不好，就是因为对区间定义不清楚。\n\n确定要查找的区间到底是左闭右开[left, right)，还是左闭又闭[left, right]，这就是不变量。\n\n然后在二分查找的循环中，坚持循环不变量的原则，很多细节问题，自然会知道如何处理了。\n\n# [704. 二分查找 - 力扣（LeetCode）](https://leetcode.cn/problems/binary-search/description/)\n\n> ## 解法一采用闭区间的二分\n\n```cpp\nclass Solution {\npublic:\n    int search(vector<int>& nums, int target) {\n        int left=0,right = nums.size()-1;\n        while(left <= right){\n        int mid = (left+right)/2;\n            if(nums[mid] == target)return mid;\n            if(nums[mid] < target)left = mid + 1;\n            if(nums[mid] > target)right = mid -1;\n        }\n        return -1;\n    }\n};\n```\n\n> ## 解法二 采用左闭右开的区间进行二分\n\n```cpp\nclass Solution {\npublic:\n    int search(vector<int>& nums, int target) {\n        int left=0,right = nums.size();\n        while(left < right){\n        int mid = (left+right)/2;\n            if(nums[mid] == target)return mid;\n            if(nums[mid] < target)left = mid + 1;\n            if(nums[mid] > target)right = mid;\n        }\n        return -1;\n    }\n};\n```\n\n# [35. 搜索插入位置 - 力扣（LeetCode）](https://leetcode.cn/problems/search-insert-position/description/)\n\n```cpp\nclass Solution\n{\npublic:\n    int searchInsert(vector<int> &nums, int target)\n    {\n        int left = 0, right = nums.size() - 1;\n        int mid = 0;\n        while (left <= right)\n        {\n            mid = (left + right) / 2;\n            if (nums[mid] < target)\n            {\n                left = mid + 1;\n            }\n            if (nums[mid] > target)\n            {\n                right = mid - 1;\n            }\n            if (nums[mid] == target)\n                return mid;\n        }\n        return left;\n    }\n};\n```\n\n# [34. 在排序数组中查找元素的第一个和最后一个位置 - 力扣（LeetCode）](https://leetcode.cn/problems/find-first-and-last-position-of-element-in-sorted-array/description/)\n\n> [灵茶山艾府题解](https://leetcode.cn/problems/find-first-and-last-position-of-element-in-sorted-array/solutions/1980196/er-fen-cha-zhao-zong-shi-xie-bu-dui-yi-g-t9l9)\n\n> [官方题解](https://leetcode.cn/problems/find-first-and-last-position-of-element-in-sorted-array/solutions/504484/zai-pai-xu-shu-zu-zhong-cha-zhao-yuan-su-de-di-3-4/)\n\n>>\n\n```cpp\nclass Solution\n{\n    int lower_bound(vector<int> &nums, int target)\n    {\n        int left = 0, right = (int)nums.size() - 1;\n        while (left <= right)\n        {\n            int mid = left + (right - left) / 2;\n            if (nums[mid] >= target)\n                right = mid - 1;\n            if (nums[mid] < target)\n                left = mid + 1;\n        }\n        return left;\n    }\n\npublic:\n    vector<int> searchRange(vector<int> &nums, int target)\n    {\n        int start = lower_bound(nums, target);\n        if (start == nums.size() || nums[start] != target)\n            return {-1, -1};\n        int end = lower_bound(nums, target + 1) - 1;\n        return {start, end};\n    }\n};\n```\n\n# [69. x 的平方根  - 力扣（LeetCode）](https://leetcode.cn/problems/sqrtx/)\n\n> ## 参考博客\n>\n> [求整数平方根算法-CSDN 博客](https://blog.csdn.net/Poo_Chai/article/details/101976547)\n\n> [IEEE 754_IEEE 二进制浮点数算术标准](https://baike.baidu.com/item/IEEE%20754)\n>\n ## 二分\n```cpp\n\nclass Solution\n{\npublic:\nint mySqrt(int x)\n{\nint left = 0, right = x;\nwhile(left <=right){\nlong long mid = left + (right - left) / 2;\nif(mid * mid <= x){\nleft = mid + 1;\n}\nelse{\nright = mid - 1;\n}\n}\nreturn right;\n}\n};\n```\n ## 牛顿迭代法\n```cpp\n// f(x) = x^2 - C_\n// f'(x) = 2x_\n\n// f(x) = 0 的解为 x = sqrt(C)_\n// f(x) ~= f(x0) + f'(x0)(x - x0)_\n//  0 = x0^2 - C + 2x0(x - x0)_\n//  x = (C - x0^2) / 2x0 + x0 = (x0 + C / x0) / 2_\n\nclass Solution\n{\npublic:\n    int mySqrt(int x)\n    {\n        if(x == 0)\n            return 0;\n        long x0 = x;\n        while(x0 * x0 > x){\n            x0 = (x0 + x / x0) / 2;\n        }\n        return (int)x0;\n    }\n};\n```\n ## 神奇的 0x5f3759df\n \n ```cpp\n// 使用快速平方根算法（Fast Inverse Square Root）的变体_\n// 0x5f3759df 是一个魔法数字，用于快速估计平方根_\nclass Solution\n{\npublic:\nint mySqrt(int x)\n{\n        // 使用 long 类型避免整数溢出_\nlong x0 = x;\n        // 使用魔法数字进行快速估计_\n        // x0>>1 相当于除以 2，用于快速估计_\nx0 = 0x5f3759df - (x0>>1);\n       // 使用牛顿迭代法进行精确化_\n        // 迭代公式：x = (x + n/x) / 2_\nwhile (x0 * x0 > x)\n{\nx0 = (x0 + x / x0) / 2;\n}\nreturn (int)x0;\n}\n};\n\n```\n ## 位运算\n ```cpp\n_// 使用位运算求解x的算术平方根_\nint mySqrt(int x)\n{\n_    // m初始化为2^30，用于逐位检查_\n    unsigned m = 0x40000000, y = 0, b = 0;\n\n    while (m != 0)\n    {\n_        // 计算当前位可能的平方值_\n        b = y | m;\n_        // y右移一位，为下一位做准备_\n        y = y >> 1;\n_        // 如果x大于等于当前平方值，说明该位可以取1_\n        if (x >= b)\n        {\n_            // 更新x的值_\n            x = x - b;\n_            // 将当前位设为1_\n            y = y | m;\n        }\n_        // m右移两位，检查下一位_\n        m = m >> 2;\n    }\n\n    return y;\n}\n```\n\n ## 袖珍计算器(使用 exp 与 ln 函数进行求解)\n\n使用$\\sqrt{x} = e^{\\frac{1}{2}lnx}$\n\n ```cpp\n\n#include <cmath>\n\n_// 使用数学公式求解 x 的算术平方根_\n_// 利用公式：sqrt(x) = e^(0.5 * ln(x))_\nclass Solution\n{\npublic:\nint mySqrt(int x)\n{\n_        // 处理特殊情况：x 为 0 时直接返回 0_\nif(x == 0)\nreturn 0;\n_        // 使用 exp 和 log 函数计算平方根_\n_        // exp(0.5 * log(x)) = e^(0.5 * ln(x)) = sqrt(x)_\nint res = exp(0.5 * log(x));\nreturn (long long)(res + 1) * (res + 1) <= x ? res + 1 : res;\n}\n};\n\n```\n\n# [367. 有效的完全平方数 - 力扣（LeetCode）](https://leetcode.cn/problems/valid-perfect-square/solutions/1081379/you-xiao-de-wan-quan-ping-fang-shu-by-le-wkee/)\n\n> 与前面的题非常相似\n\n```cpp\n\nclass Solution\n{\npublic:\nbool isPerfectSquare(int num)\n{\nint left = 0, right = num;\nwhile(left <= right){\nlong long mid = left + (right - left) / 2;\nif(mid * mid == num)\nreturn true;\nelse if(mid * mid < num)\nleft = mid + 1;\nelse\nright = mid - 1;\n}\nreturn false;\n}\n};\n\n```\n\n\n\n\n","source":"_posts/2025-05-07-二分查找.md","raw":"---\ntitle: 2025-05-07-二分查找\ndate: 2025-05-07\ntags: 算法学习\n---\n# 2025-05-07-二分查找\n\n> 参考博客\n> [代码随想录](https://programmercarl.com/0704.%E4%BA%8C%E5%88%86%E6%9F%A5%E6%89%BE.html#%E6%80%9D%E8%B7%AF)\n\n使用二分法的前提条件\n\n- 元素有序且不重复\n\n希望通过这道题目，大家会发现平时写二分法，为什么总写不好，就是因为对区间定义不清楚。\n\n确定要查找的区间到底是左闭右开[left, right)，还是左闭又闭[left, right]，这就是不变量。\n\n然后在二分查找的循环中，坚持循环不变量的原则，很多细节问题，自然会知道如何处理了。\n\n# [704. 二分查找 - 力扣（LeetCode）](https://leetcode.cn/problems/binary-search/description/)\n\n> ## 解法一采用闭区间的二分\n\n```cpp\nclass Solution {\npublic:\n    int search(vector<int>& nums, int target) {\n        int left=0,right = nums.size()-1;\n        while(left <= right){\n        int mid = (left+right)/2;\n            if(nums[mid] == target)return mid;\n            if(nums[mid] < target)left = mid + 1;\n            if(nums[mid] > target)right = mid -1;\n        }\n        return -1;\n    }\n};\n```\n\n> ## 解法二 采用左闭右开的区间进行二分\n\n```cpp\nclass Solution {\npublic:\n    int search(vector<int>& nums, int target) {\n        int left=0,right = nums.size();\n        while(left < right){\n        int mid = (left+right)/2;\n            if(nums[mid] == target)return mid;\n            if(nums[mid] < target)left = mid + 1;\n            if(nums[mid] > target)right = mid;\n        }\n        return -1;\n    }\n};\n```\n\n# [35. 搜索插入位置 - 力扣（LeetCode）](https://leetcode.cn/problems/search-insert-position/description/)\n\n```cpp\nclass Solution\n{\npublic:\n    int searchInsert(vector<int> &nums, int target)\n    {\n        int left = 0, right = nums.size() - 1;\n        int mid = 0;\n        while (left <= right)\n        {\n            mid = (left + right) / 2;\n            if (nums[mid] < target)\n            {\n                left = mid + 1;\n            }\n            if (nums[mid] > target)\n            {\n                right = mid - 1;\n            }\n            if (nums[mid] == target)\n                return mid;\n        }\n        return left;\n    }\n};\n```\n\n# [34. 在排序数组中查找元素的第一个和最后一个位置 - 力扣（LeetCode）](https://leetcode.cn/problems/find-first-and-last-position-of-element-in-sorted-array/description/)\n\n> [灵茶山艾府题解](https://leetcode.cn/problems/find-first-and-last-position-of-element-in-sorted-array/solutions/1980196/er-fen-cha-zhao-zong-shi-xie-bu-dui-yi-g-t9l9)\n\n> [官方题解](https://leetcode.cn/problems/find-first-and-last-position-of-element-in-sorted-array/solutions/504484/zai-pai-xu-shu-zu-zhong-cha-zhao-yuan-su-de-di-3-4/)\n\n>>\n\n```cpp\nclass Solution\n{\n    int lower_bound(vector<int> &nums, int target)\n    {\n        int left = 0, right = (int)nums.size() - 1;\n        while (left <= right)\n        {\n            int mid = left + (right - left) / 2;\n            if (nums[mid] >= target)\n                right = mid - 1;\n            if (nums[mid] < target)\n                left = mid + 1;\n        }\n        return left;\n    }\n\npublic:\n    vector<int> searchRange(vector<int> &nums, int target)\n    {\n        int start = lower_bound(nums, target);\n        if (start == nums.size() || nums[start] != target)\n            return {-1, -1};\n        int end = lower_bound(nums, target + 1) - 1;\n        return {start, end};\n    }\n};\n```\n\n# [69. x 的平方根  - 力扣（LeetCode）](https://leetcode.cn/problems/sqrtx/)\n\n> ## 参考博客\n>\n> [求整数平方根算法-CSDN 博客](https://blog.csdn.net/Poo_Chai/article/details/101976547)\n\n> [IEEE 754_IEEE 二进制浮点数算术标准](https://baike.baidu.com/item/IEEE%20754)\n>\n ## 二分\n```cpp\n\nclass Solution\n{\npublic:\nint mySqrt(int x)\n{\nint left = 0, right = x;\nwhile(left <=right){\nlong long mid = left + (right - left) / 2;\nif(mid * mid <= x){\nleft = mid + 1;\n}\nelse{\nright = mid - 1;\n}\n}\nreturn right;\n}\n};\n```\n ## 牛顿迭代法\n```cpp\n// f(x) = x^2 - C_\n// f'(x) = 2x_\n\n// f(x) = 0 的解为 x = sqrt(C)_\n// f(x) ~= f(x0) + f'(x0)(x - x0)_\n//  0 = x0^2 - C + 2x0(x - x0)_\n//  x = (C - x0^2) / 2x0 + x0 = (x0 + C / x0) / 2_\n\nclass Solution\n{\npublic:\n    int mySqrt(int x)\n    {\n        if(x == 0)\n            return 0;\n        long x0 = x;\n        while(x0 * x0 > x){\n            x0 = (x0 + x / x0) / 2;\n        }\n        return (int)x0;\n    }\n};\n```\n ## 神奇的 0x5f3759df\n \n ```cpp\n// 使用快速平方根算法（Fast Inverse Square Root）的变体_\n// 0x5f3759df 是一个魔法数字，用于快速估计平方根_\nclass Solution\n{\npublic:\nint mySqrt(int x)\n{\n        // 使用 long 类型避免整数溢出_\nlong x0 = x;\n        // 使用魔法数字进行快速估计_\n        // x0>>1 相当于除以 2，用于快速估计_\nx0 = 0x5f3759df - (x0>>1);\n       // 使用牛顿迭代法进行精确化_\n        // 迭代公式：x = (x + n/x) / 2_\nwhile (x0 * x0 > x)\n{\nx0 = (x0 + x / x0) / 2;\n}\nreturn (int)x0;\n}\n};\n\n```\n ## 位运算\n ```cpp\n_// 使用位运算求解x的算术平方根_\nint mySqrt(int x)\n{\n_    // m初始化为2^30，用于逐位检查_\n    unsigned m = 0x40000000, y = 0, b = 0;\n\n    while (m != 0)\n    {\n_        // 计算当前位可能的平方值_\n        b = y | m;\n_        // y右移一位，为下一位做准备_\n        y = y >> 1;\n_        // 如果x大于等于当前平方值，说明该位可以取1_\n        if (x >= b)\n        {\n_            // 更新x的值_\n            x = x - b;\n_            // 将当前位设为1_\n            y = y | m;\n        }\n_        // m右移两位，检查下一位_\n        m = m >> 2;\n    }\n\n    return y;\n}\n```\n\n ## 袖珍计算器(使用 exp 与 ln 函数进行求解)\n\n使用$\\sqrt{x} = e^{\\frac{1}{2}lnx}$\n\n ```cpp\n\n#include <cmath>\n\n_// 使用数学公式求解 x 的算术平方根_\n_// 利用公式：sqrt(x) = e^(0.5 * ln(x))_\nclass Solution\n{\npublic:\nint mySqrt(int x)\n{\n_        // 处理特殊情况：x 为 0 时直接返回 0_\nif(x == 0)\nreturn 0;\n_        // 使用 exp 和 log 函数计算平方根_\n_        // exp(0.5 * log(x)) = e^(0.5 * ln(x)) = sqrt(x)_\nint res = exp(0.5 * log(x));\nreturn (long long)(res + 1) * (res + 1) <= x ? res + 1 : res;\n}\n};\n\n```\n\n# [367. 有效的完全平方数 - 力扣（LeetCode）](https://leetcode.cn/problems/valid-perfect-square/solutions/1081379/you-xiao-de-wan-quan-ping-fang-shu-by-le-wkee/)\n\n> 与前面的题非常相似\n\n```cpp\n\nclass Solution\n{\npublic:\nbool isPerfectSquare(int num)\n{\nint left = 0, right = num;\nwhile(left <= right){\nlong long mid = left + (right - left) / 2;\nif(mid * mid == num)\nreturn true;\nelse if(mid * mid < num)\nleft = mid + 1;\nelse\nright = mid - 1;\n}\nreturn false;\n}\n};\n\n```\n\n\n\n\n","slug":"2025-05-07-二分查找","published":1,"updated":"2025-09-26T12:17:26.646Z","_id":"cmg0saj49001wjm8ndm6x7og0","comments":1,"layout":"post","photos":[],"content":"<h1 id=\"2025-05-07-二分查找\"><a href=\"#2025-05-07-二分查找\" class=\"headerlink\" title=\"2025-05-07-二分查找\"></a>2025-05-07-二分查找</h1><blockquote>\n<p>参考博客<br><a href=\"https://programmercarl.com/0704.%E4%BA%8C%E5%88%86%E6%9F%A5%E6%89%BE.html#%E6%80%9D%E8%B7%AF\">代码随想录</a></p>\n</blockquote>\n<p>使用二分法的前提条件</p>\n<ul>\n<li>元素有序且不重复</li>\n</ul>\n<p>希望通过这道题目，大家会发现平时写二分法，为什么总写不好，就是因为对区间定义不清楚。</p>\n<p>确定要查找的区间到底是左闭右开[left, right)，还是左闭又闭[left, right]，这就是不变量。</p>\n<p>然后在二分查找的循环中，坚持循环不变量的原则，很多细节问题，自然会知道如何处理了。</p>\n<h1 id=\"704-二分查找-力扣（LeetCode）\"><a href=\"#704-二分查找-力扣（LeetCode）\" class=\"headerlink\" title=\"704. 二分查找 - 力扣（LeetCode）\"></a><a href=\"https://leetcode.cn/problems/binary-search/description/\">704. 二分查找 - 力扣（LeetCode）</a></h1><blockquote>\n<h2 id=\"解法一采用闭区间的二分\"><a href=\"#解法一采用闭区间的二分\" class=\"headerlink\" title=\"解法一采用闭区间的二分\"></a>解法一采用闭区间的二分</h2></blockquote>\n<figure class=\"highlight cpp\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">class</span> <span class=\"title class_\">Solution</span> &#123;</span><br><span class=\"line\"><span class=\"keyword\">public</span>:</span><br><span class=\"line\">    <span class=\"function\"><span class=\"type\">int</span> <span class=\"title\">search</span><span class=\"params\">(vector&lt;<span class=\"type\">int</span>&gt;&amp; nums, <span class=\"type\">int</span> target)</span> </span>&#123;</span><br><span class=\"line\">        <span class=\"type\">int</span> left=<span class=\"number\">0</span>,right = nums.<span class=\"built_in\">size</span>()<span class=\"number\">-1</span>;</span><br><span class=\"line\">        <span class=\"keyword\">while</span>(left &lt;= right)&#123;</span><br><span class=\"line\">        <span class=\"type\">int</span> mid = (left+right)/<span class=\"number\">2</span>;</span><br><span class=\"line\">            <span class=\"keyword\">if</span>(nums[mid] == target)<span class=\"keyword\">return</span> mid;</span><br><span class=\"line\">            <span class=\"keyword\">if</span>(nums[mid] &lt; target)left = mid + <span class=\"number\">1</span>;</span><br><span class=\"line\">            <span class=\"keyword\">if</span>(nums[mid] &gt; target)right = mid <span class=\"number\">-1</span>;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> <span class=\"number\">-1</span>;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;;</span><br></pre></td></tr></table></figure>\n\n<blockquote>\n<h2 id=\"解法二-采用左闭右开的区间进行二分\"><a href=\"#解法二-采用左闭右开的区间进行二分\" class=\"headerlink\" title=\"解法二 采用左闭右开的区间进行二分\"></a>解法二 采用左闭右开的区间进行二分</h2></blockquote>\n<figure class=\"highlight cpp\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">class</span> <span class=\"title class_\">Solution</span> &#123;</span><br><span class=\"line\"><span class=\"keyword\">public</span>:</span><br><span class=\"line\">    <span class=\"function\"><span class=\"type\">int</span> <span class=\"title\">search</span><span class=\"params\">(vector&lt;<span class=\"type\">int</span>&gt;&amp; nums, <span class=\"type\">int</span> target)</span> </span>&#123;</span><br><span class=\"line\">        <span class=\"type\">int</span> left=<span class=\"number\">0</span>,right = nums.<span class=\"built_in\">size</span>();</span><br><span class=\"line\">        <span class=\"keyword\">while</span>(left &lt; right)&#123;</span><br><span class=\"line\">        <span class=\"type\">int</span> mid = (left+right)/<span class=\"number\">2</span>;</span><br><span class=\"line\">            <span class=\"keyword\">if</span>(nums[mid] == target)<span class=\"keyword\">return</span> mid;</span><br><span class=\"line\">            <span class=\"keyword\">if</span>(nums[mid] &lt; target)left = mid + <span class=\"number\">1</span>;</span><br><span class=\"line\">            <span class=\"keyword\">if</span>(nums[mid] &gt; target)right = mid;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> <span class=\"number\">-1</span>;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;;</span><br></pre></td></tr></table></figure>\n\n<h1 id=\"35-搜索插入位置-力扣（LeetCode）\"><a href=\"#35-搜索插入位置-力扣（LeetCode）\" class=\"headerlink\" title=\"35. 搜索插入位置 - 力扣（LeetCode）\"></a><a href=\"https://leetcode.cn/problems/search-insert-position/description/\">35. 搜索插入位置 - 力扣（LeetCode）</a></h1><figure class=\"highlight cpp\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">class</span> <span class=\"title class_\">Solution</span></span><br><span class=\"line\">&#123;</span><br><span class=\"line\"><span class=\"keyword\">public</span>:</span><br><span class=\"line\">    <span class=\"function\"><span class=\"type\">int</span> <span class=\"title\">searchInsert</span><span class=\"params\">(vector&lt;<span class=\"type\">int</span>&gt; &amp;nums, <span class=\"type\">int</span> target)</span></span></span><br><span class=\"line\"><span class=\"function\">    </span>&#123;</span><br><span class=\"line\">        <span class=\"type\">int</span> left = <span class=\"number\">0</span>, right = nums.<span class=\"built_in\">size</span>() - <span class=\"number\">1</span>;</span><br><span class=\"line\">        <span class=\"type\">int</span> mid = <span class=\"number\">0</span>;</span><br><span class=\"line\">        <span class=\"keyword\">while</span> (left &lt;= right)</span><br><span class=\"line\">        &#123;</span><br><span class=\"line\">            mid = (left + right) / <span class=\"number\">2</span>;</span><br><span class=\"line\">            <span class=\"keyword\">if</span> (nums[mid] &lt; target)</span><br><span class=\"line\">            &#123;</span><br><span class=\"line\">                left = mid + <span class=\"number\">1</span>;</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">            <span class=\"keyword\">if</span> (nums[mid] &gt; target)</span><br><span class=\"line\">            &#123;</span><br><span class=\"line\">                right = mid - <span class=\"number\">1</span>;</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">            <span class=\"keyword\">if</span> (nums[mid] == target)</span><br><span class=\"line\">                <span class=\"keyword\">return</span> mid;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> left;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;;</span><br></pre></td></tr></table></figure>\n\n<h1 id=\"34-在排序数组中查找元素的第一个和最后一个位置-力扣（LeetCode）\"><a href=\"#34-在排序数组中查找元素的第一个和最后一个位置-力扣（LeetCode）\" class=\"headerlink\" title=\"34. 在排序数组中查找元素的第一个和最后一个位置 - 力扣（LeetCode）\"></a><a href=\"https://leetcode.cn/problems/find-first-and-last-position-of-element-in-sorted-array/description/\">34. 在排序数组中查找元素的第一个和最后一个位置 - 力扣（LeetCode）</a></h1><blockquote>\n<p><a href=\"https://leetcode.cn/problems/find-first-and-last-position-of-element-in-sorted-array/solutions/1980196/er-fen-cha-zhao-zong-shi-xie-bu-dui-yi-g-t9l9\">灵茶山艾府题解</a></p>\n</blockquote>\n<blockquote>\n<p><a href=\"https://leetcode.cn/problems/find-first-and-last-position-of-element-in-sorted-array/solutions/504484/zai-pai-xu-shu-zu-zhong-cha-zhao-yuan-su-de-di-3-4/\">官方题解</a></p>\n</blockquote>\n<blockquote>\n<blockquote>\n</blockquote>\n</blockquote>\n<figure class=\"highlight cpp\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">class</span> <span class=\"title class_\">Solution</span></span><br><span class=\"line\">&#123;</span><br><span class=\"line\">    <span class=\"function\"><span class=\"type\">int</span> <span class=\"title\">lower_bound</span><span class=\"params\">(vector&lt;<span class=\"type\">int</span>&gt; &amp;nums, <span class=\"type\">int</span> target)</span></span></span><br><span class=\"line\"><span class=\"function\">    </span>&#123;</span><br><span class=\"line\">        <span class=\"type\">int</span> left = <span class=\"number\">0</span>, right = (<span class=\"type\">int</span>)nums.<span class=\"built_in\">size</span>() - <span class=\"number\">1</span>;</span><br><span class=\"line\">        <span class=\"keyword\">while</span> (left &lt;= right)</span><br><span class=\"line\">        &#123;</span><br><span class=\"line\">            <span class=\"type\">int</span> mid = left + (right - left) / <span class=\"number\">2</span>;</span><br><span class=\"line\">            <span class=\"keyword\">if</span> (nums[mid] &gt;= target)</span><br><span class=\"line\">                right = mid - <span class=\"number\">1</span>;</span><br><span class=\"line\">            <span class=\"keyword\">if</span> (nums[mid] &lt; target)</span><br><span class=\"line\">                left = mid + <span class=\"number\">1</span>;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> left;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">public</span>:</span><br><span class=\"line\">    <span class=\"function\">vector&lt;<span class=\"type\">int</span>&gt; <span class=\"title\">searchRange</span><span class=\"params\">(vector&lt;<span class=\"type\">int</span>&gt; &amp;nums, <span class=\"type\">int</span> target)</span></span></span><br><span class=\"line\"><span class=\"function\">    </span>&#123;</span><br><span class=\"line\">        <span class=\"type\">int</span> start = <span class=\"built_in\">lower_bound</span>(nums, target);</span><br><span class=\"line\">        <span class=\"keyword\">if</span> (start == nums.<span class=\"built_in\">size</span>() || nums[start] != target)</span><br><span class=\"line\">            <span class=\"keyword\">return</span> &#123;<span class=\"number\">-1</span>, <span class=\"number\">-1</span>&#125;;</span><br><span class=\"line\">        <span class=\"type\">int</span> end = <span class=\"built_in\">lower_bound</span>(nums, target + <span class=\"number\">1</span>) - <span class=\"number\">1</span>;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> &#123;start, end&#125;;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;;</span><br></pre></td></tr></table></figure>\n\n<h1 id=\"69-x-的平方根-力扣（LeetCode）\"><a href=\"#69-x-的平方根-力扣（LeetCode）\" class=\"headerlink\" title=\"69. x 的平方根  - 力扣（LeetCode）\"></a><a href=\"https://leetcode.cn/problems/sqrtx/\">69. x 的平方根  - 力扣（LeetCode）</a></h1><blockquote>\n<h2 id=\"参考博客\"><a href=\"#参考博客\" class=\"headerlink\" title=\"参考博客\"></a>参考博客</h2><p><a href=\"https://blog.csdn.net/Poo_Chai/article/details/101976547\">求整数平方根算法-CSDN 博客</a></p>\n</blockquote>\n<blockquote>\n<p><a href=\"https://baike.baidu.com/item/IEEE%20754\">IEEE 754_IEEE 二进制浮点数算术标准</a></p>\n</blockquote>\n<h2 id=\"二分\"><a href=\"#二分\" class=\"headerlink\" title=\"二分\"></a>二分</h2><figure class=\"highlight cpp\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">class</span> <span class=\"title class_\">Solution</span></span><br><span class=\"line\">&#123;</span><br><span class=\"line\"><span class=\"keyword\">public</span>:</span><br><span class=\"line\"><span class=\"function\"><span class=\"type\">int</span> <span class=\"title\">mySqrt</span><span class=\"params\">(<span class=\"type\">int</span> x)</span></span></span><br><span class=\"line\"><span class=\"function\"></span>&#123;</span><br><span class=\"line\"><span class=\"type\">int</span> left = <span class=\"number\">0</span>, right = x;</span><br><span class=\"line\"><span class=\"keyword\">while</span>(left &lt;=right)&#123;</span><br><span class=\"line\"><span class=\"type\">long</span> <span class=\"type\">long</span> mid = left + (right - left) / <span class=\"number\">2</span>;</span><br><span class=\"line\"><span class=\"keyword\">if</span>(mid * mid &lt;= x)&#123;</span><br><span class=\"line\">left = mid + <span class=\"number\">1</span>;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"keyword\">else</span>&#123;</span><br><span class=\"line\">right = mid - <span class=\"number\">1</span>;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"keyword\">return</span> right;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\">&#125;;</span><br></pre></td></tr></table></figure>\n<h2 id=\"牛顿迭代法\"><a href=\"#牛顿迭代法\" class=\"headerlink\" title=\"牛顿迭代法\"></a>牛顿迭代法</h2><figure class=\"highlight cpp\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// f(x) = x^2 - C_</span></span><br><span class=\"line\"><span class=\"comment\">// f&#x27;(x) = 2x_</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// f(x) = 0 的解为 x = sqrt(C)_</span></span><br><span class=\"line\"><span class=\"comment\">// f(x) ~= f(x0) + f&#x27;(x0)(x - x0)_</span></span><br><span class=\"line\"><span class=\"comment\">//  0 = x0^2 - C + 2x0(x - x0)_</span></span><br><span class=\"line\"><span class=\"comment\">//  x = (C - x0^2) / 2x0 + x0 = (x0 + C / x0) / 2_</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">class</span> <span class=\"title class_\">Solution</span></span><br><span class=\"line\">&#123;</span><br><span class=\"line\"><span class=\"keyword\">public</span>:</span><br><span class=\"line\">    <span class=\"function\"><span class=\"type\">int</span> <span class=\"title\">mySqrt</span><span class=\"params\">(<span class=\"type\">int</span> x)</span></span></span><br><span class=\"line\"><span class=\"function\">    </span>&#123;</span><br><span class=\"line\">        <span class=\"keyword\">if</span>(x == <span class=\"number\">0</span>)</span><br><span class=\"line\">            <span class=\"keyword\">return</span> <span class=\"number\">0</span>;</span><br><span class=\"line\">        <span class=\"type\">long</span> x0 = x;</span><br><span class=\"line\">        <span class=\"keyword\">while</span>(x0 * x0 &gt; x)&#123;</span><br><span class=\"line\">            x0 = (x0 + x / x0) / <span class=\"number\">2</span>;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> (<span class=\"type\">int</span>)x0;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;;</span><br></pre></td></tr></table></figure>\n<h2 id=\"神奇的-0x5f3759df\"><a href=\"#神奇的-0x5f3759df\" class=\"headerlink\" title=\"神奇的 0x5f3759df\"></a>神奇的 0x5f3759df</h2> <figure class=\"highlight cpp\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// 使用快速平方根算法（Fast Inverse Square Root）的变体_</span></span><br><span class=\"line\"><span class=\"comment\">// 0x5f3759df 是一个魔法数字，用于快速估计平方根_</span></span><br><span class=\"line\"><span class=\"keyword\">class</span> <span class=\"title class_\">Solution</span></span><br><span class=\"line\">&#123;</span><br><span class=\"line\"><span class=\"keyword\">public</span>:</span><br><span class=\"line\"><span class=\"function\"><span class=\"type\">int</span> <span class=\"title\">mySqrt</span><span class=\"params\">(<span class=\"type\">int</span> x)</span></span></span><br><span class=\"line\"><span class=\"function\"></span>&#123;</span><br><span class=\"line\">        <span class=\"comment\">// 使用 long 类型避免整数溢出_</span></span><br><span class=\"line\"><span class=\"type\">long</span> x0 = x;</span><br><span class=\"line\">        <span class=\"comment\">// 使用魔法数字进行快速估计_</span></span><br><span class=\"line\">        <span class=\"comment\">// x0&gt;&gt;1 相当于除以 2，用于快速估计_</span></span><br><span class=\"line\">x0 = <span class=\"number\">0x5f3759df</span> - (x0&gt;&gt;<span class=\"number\">1</span>);</span><br><span class=\"line\">       <span class=\"comment\">// 使用牛顿迭代法进行精确化_</span></span><br><span class=\"line\">        <span class=\"comment\">// 迭代公式：x = (x + n/x) / 2_</span></span><br><span class=\"line\"><span class=\"keyword\">while</span> (x0 * x0 &gt; x)</span><br><span class=\"line\">&#123;</span><br><span class=\"line\">x0 = (x0 + x / x0) / <span class=\"number\">2</span>;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"keyword\">return</span> (<span class=\"type\">int</span>)x0;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\">&#125;;</span><br><span class=\"line\"></span><br></pre></td></tr></table></figure>\n<h2 id=\"位运算\"><a href=\"#位运算\" class=\"headerlink\" title=\"位运算\"></a>位运算</h2> <figure class=\"highlight cpp\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">_<span class=\"comment\">// 使用位运算求解x的算术平方根_</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"type\">int</span> <span class=\"title\">mySqrt</span><span class=\"params\">(<span class=\"type\">int</span> x)</span></span></span><br><span class=\"line\"><span class=\"function\"></span>&#123;</span><br><span class=\"line\">_    <span class=\"comment\">// m初始化为2^30，用于逐位检查_</span></span><br><span class=\"line\">    <span class=\"type\">unsigned</span> m = <span class=\"number\">0x40000000</span>, y = <span class=\"number\">0</span>, b = <span class=\"number\">0</span>;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">while</span> (m != <span class=\"number\">0</span>)</span><br><span class=\"line\">    &#123;</span><br><span class=\"line\">_        <span class=\"comment\">// 计算当前位可能的平方值_</span></span><br><span class=\"line\">        b = y | m;</span><br><span class=\"line\">_        <span class=\"comment\">// y右移一位，为下一位做准备_</span></span><br><span class=\"line\">        y = y &gt;&gt; <span class=\"number\">1</span>;</span><br><span class=\"line\">_        <span class=\"comment\">// 如果x大于等于当前平方值，说明该位可以取1_</span></span><br><span class=\"line\">        <span class=\"keyword\">if</span> (x &gt;= b)</span><br><span class=\"line\">        &#123;</span><br><span class=\"line\">_            <span class=\"comment\">// 更新x的值_</span></span><br><span class=\"line\">            x = x - b;</span><br><span class=\"line\">_            <span class=\"comment\">// 将当前位设为1_</span></span><br><span class=\"line\">            y = y | m;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">_        <span class=\"comment\">// m右移两位，检查下一位_</span></span><br><span class=\"line\">        m = m &gt;&gt; <span class=\"number\">2</span>;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">return</span> y;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<h2 id=\"袖珍计算器-使用-exp-与-ln-函数进行求解\"><a href=\"#袖珍计算器-使用-exp-与-ln-函数进行求解\" class=\"headerlink\" title=\"袖珍计算器(使用 exp 与 ln 函数进行求解)\"></a>袖珍计算器(使用 exp 与 ln 函数进行求解)</h2><p>使用$\\sqrt{x} &#x3D; e^{\\frac{1}{2}lnx}$</p>\n <figure class=\"highlight cpp\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"keyword\">include</span> <span class=\"string\">&lt;cmath&gt;</span></span></span><br><span class=\"line\"></span><br><span class=\"line\">_<span class=\"comment\">// 使用数学公式求解 x 的算术平方根_</span></span><br><span class=\"line\">_<span class=\"comment\">// 利用公式：sqrt(x) = e^(0.5 * ln(x))_</span></span><br><span class=\"line\"><span class=\"keyword\">class</span> <span class=\"title class_\">Solution</span></span><br><span class=\"line\">&#123;</span><br><span class=\"line\"><span class=\"keyword\">public</span>:</span><br><span class=\"line\"><span class=\"function\"><span class=\"type\">int</span> <span class=\"title\">mySqrt</span><span class=\"params\">(<span class=\"type\">int</span> x)</span></span></span><br><span class=\"line\"><span class=\"function\"></span>&#123;</span><br><span class=\"line\">_        <span class=\"comment\">// 处理特殊情况：x 为 0 时直接返回 0_</span></span><br><span class=\"line\"><span class=\"keyword\">if</span>(x == <span class=\"number\">0</span>)</span><br><span class=\"line\"><span class=\"keyword\">return</span> <span class=\"number\">0</span>;</span><br><span class=\"line\">_        <span class=\"comment\">// 使用 exp 和 log 函数计算平方根_</span></span><br><span class=\"line\">_        <span class=\"comment\">// exp(0.5 * log(x)) = e^(0.5 * ln(x)) = sqrt(x)_</span></span><br><span class=\"line\"><span class=\"type\">int</span> res = <span class=\"built_in\">exp</span>(<span class=\"number\">0.5</span> * <span class=\"built_in\">log</span>(x));</span><br><span class=\"line\"><span class=\"keyword\">return</span> (<span class=\"type\">long</span> <span class=\"type\">long</span>)(res + <span class=\"number\">1</span>) * (res + <span class=\"number\">1</span>) &lt;= x ? res + <span class=\"number\">1</span> : res;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\">&#125;;</span><br><span class=\"line\"></span><br></pre></td></tr></table></figure>\n\n<h1 id=\"367-有效的完全平方数-力扣（LeetCode）\"><a href=\"#367-有效的完全平方数-力扣（LeetCode）\" class=\"headerlink\" title=\"367. 有效的完全平方数 - 力扣（LeetCode）\"></a><a href=\"https://leetcode.cn/problems/valid-perfect-square/solutions/1081379/you-xiao-de-wan-quan-ping-fang-shu-by-le-wkee/\">367. 有效的完全平方数 - 力扣（LeetCode）</a></h1><blockquote>\n<p>与前面的题非常相似</p>\n</blockquote>\n<figure class=\"highlight cpp\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">class</span> <span class=\"title class_\">Solution</span></span><br><span class=\"line\">&#123;</span><br><span class=\"line\"><span class=\"keyword\">public</span>:</span><br><span class=\"line\"><span class=\"function\"><span class=\"type\">bool</span> <span class=\"title\">isPerfectSquare</span><span class=\"params\">(<span class=\"type\">int</span> num)</span></span></span><br><span class=\"line\"><span class=\"function\"></span>&#123;</span><br><span class=\"line\"><span class=\"type\">int</span> left = <span class=\"number\">0</span>, right = num;</span><br><span class=\"line\"><span class=\"keyword\">while</span>(left &lt;= right)&#123;</span><br><span class=\"line\"><span class=\"type\">long</span> <span class=\"type\">long</span> mid = left + (right - left) / <span class=\"number\">2</span>;</span><br><span class=\"line\"><span class=\"keyword\">if</span>(mid * mid == num)</span><br><span class=\"line\"><span class=\"keyword\">return</span> <span class=\"literal\">true</span>;</span><br><span class=\"line\"><span class=\"keyword\">else</span> <span class=\"keyword\">if</span>(mid * mid &lt; num)</span><br><span class=\"line\">left = mid + <span class=\"number\">1</span>;</span><br><span class=\"line\"><span class=\"keyword\">else</span></span><br><span class=\"line\">right = mid - <span class=\"number\">1</span>;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"keyword\">return</span> <span class=\"literal\">false</span>;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\">&#125;;</span><br><span class=\"line\"></span><br></pre></td></tr></table></figure>\n\n\n\n\n","excerpt":"","more":"<h1 id=\"2025-05-07-二分查找\"><a href=\"#2025-05-07-二分查找\" class=\"headerlink\" title=\"2025-05-07-二分查找\"></a>2025-05-07-二分查找</h1><blockquote>\n<p>参考博客<br><a href=\"https://programmercarl.com/0704.%E4%BA%8C%E5%88%86%E6%9F%A5%E6%89%BE.html#%E6%80%9D%E8%B7%AF\">代码随想录</a></p>\n</blockquote>\n<p>使用二分法的前提条件</p>\n<ul>\n<li>元素有序且不重复</li>\n</ul>\n<p>希望通过这道题目，大家会发现平时写二分法，为什么总写不好，就是因为对区间定义不清楚。</p>\n<p>确定要查找的区间到底是左闭右开[left, right)，还是左闭又闭[left, right]，这就是不变量。</p>\n<p>然后在二分查找的循环中，坚持循环不变量的原则，很多细节问题，自然会知道如何处理了。</p>\n<h1 id=\"704-二分查找-力扣（LeetCode）\"><a href=\"#704-二分查找-力扣（LeetCode）\" class=\"headerlink\" title=\"704. 二分查找 - 力扣（LeetCode）\"></a><a href=\"https://leetcode.cn/problems/binary-search/description/\">704. 二分查找 - 力扣（LeetCode）</a></h1><blockquote>\n<h2 id=\"解法一采用闭区间的二分\"><a href=\"#解法一采用闭区间的二分\" class=\"headerlink\" title=\"解法一采用闭区间的二分\"></a>解法一采用闭区间的二分</h2></blockquote>\n<figure class=\"highlight cpp\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">class</span> <span class=\"title class_\">Solution</span> &#123;</span><br><span class=\"line\"><span class=\"keyword\">public</span>:</span><br><span class=\"line\">    <span class=\"function\"><span class=\"type\">int</span> <span class=\"title\">search</span><span class=\"params\">(vector&lt;<span class=\"type\">int</span>&gt;&amp; nums, <span class=\"type\">int</span> target)</span> </span>&#123;</span><br><span class=\"line\">        <span class=\"type\">int</span> left=<span class=\"number\">0</span>,right = nums.<span class=\"built_in\">size</span>()<span class=\"number\">-1</span>;</span><br><span class=\"line\">        <span class=\"keyword\">while</span>(left &lt;= right)&#123;</span><br><span class=\"line\">        <span class=\"type\">int</span> mid = (left+right)/<span class=\"number\">2</span>;</span><br><span class=\"line\">            <span class=\"keyword\">if</span>(nums[mid] == target)<span class=\"keyword\">return</span> mid;</span><br><span class=\"line\">            <span class=\"keyword\">if</span>(nums[mid] &lt; target)left = mid + <span class=\"number\">1</span>;</span><br><span class=\"line\">            <span class=\"keyword\">if</span>(nums[mid] &gt; target)right = mid <span class=\"number\">-1</span>;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> <span class=\"number\">-1</span>;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;;</span><br></pre></td></tr></table></figure>\n\n<blockquote>\n<h2 id=\"解法二-采用左闭右开的区间进行二分\"><a href=\"#解法二-采用左闭右开的区间进行二分\" class=\"headerlink\" title=\"解法二 采用左闭右开的区间进行二分\"></a>解法二 采用左闭右开的区间进行二分</h2></blockquote>\n<figure class=\"highlight cpp\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">class</span> <span class=\"title class_\">Solution</span> &#123;</span><br><span class=\"line\"><span class=\"keyword\">public</span>:</span><br><span class=\"line\">    <span class=\"function\"><span class=\"type\">int</span> <span class=\"title\">search</span><span class=\"params\">(vector&lt;<span class=\"type\">int</span>&gt;&amp; nums, <span class=\"type\">int</span> target)</span> </span>&#123;</span><br><span class=\"line\">        <span class=\"type\">int</span> left=<span class=\"number\">0</span>,right = nums.<span class=\"built_in\">size</span>();</span><br><span class=\"line\">        <span class=\"keyword\">while</span>(left &lt; right)&#123;</span><br><span class=\"line\">        <span class=\"type\">int</span> mid = (left+right)/<span class=\"number\">2</span>;</span><br><span class=\"line\">            <span class=\"keyword\">if</span>(nums[mid] == target)<span class=\"keyword\">return</span> mid;</span><br><span class=\"line\">            <span class=\"keyword\">if</span>(nums[mid] &lt; target)left = mid + <span class=\"number\">1</span>;</span><br><span class=\"line\">            <span class=\"keyword\">if</span>(nums[mid] &gt; target)right = mid;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> <span class=\"number\">-1</span>;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;;</span><br></pre></td></tr></table></figure>\n\n<h1 id=\"35-搜索插入位置-力扣（LeetCode）\"><a href=\"#35-搜索插入位置-力扣（LeetCode）\" class=\"headerlink\" title=\"35. 搜索插入位置 - 力扣（LeetCode）\"></a><a href=\"https://leetcode.cn/problems/search-insert-position/description/\">35. 搜索插入位置 - 力扣（LeetCode）</a></h1><figure class=\"highlight cpp\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">class</span> <span class=\"title class_\">Solution</span></span><br><span class=\"line\">&#123;</span><br><span class=\"line\"><span class=\"keyword\">public</span>:</span><br><span class=\"line\">    <span class=\"function\"><span class=\"type\">int</span> <span class=\"title\">searchInsert</span><span class=\"params\">(vector&lt;<span class=\"type\">int</span>&gt; &amp;nums, <span class=\"type\">int</span> target)</span></span></span><br><span class=\"line\"><span class=\"function\">    </span>&#123;</span><br><span class=\"line\">        <span class=\"type\">int</span> left = <span class=\"number\">0</span>, right = nums.<span class=\"built_in\">size</span>() - <span class=\"number\">1</span>;</span><br><span class=\"line\">        <span class=\"type\">int</span> mid = <span class=\"number\">0</span>;</span><br><span class=\"line\">        <span class=\"keyword\">while</span> (left &lt;= right)</span><br><span class=\"line\">        &#123;</span><br><span class=\"line\">            mid = (left + right) / <span class=\"number\">2</span>;</span><br><span class=\"line\">            <span class=\"keyword\">if</span> (nums[mid] &lt; target)</span><br><span class=\"line\">            &#123;</span><br><span class=\"line\">                left = mid + <span class=\"number\">1</span>;</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">            <span class=\"keyword\">if</span> (nums[mid] &gt; target)</span><br><span class=\"line\">            &#123;</span><br><span class=\"line\">                right = mid - <span class=\"number\">1</span>;</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">            <span class=\"keyword\">if</span> (nums[mid] == target)</span><br><span class=\"line\">                <span class=\"keyword\">return</span> mid;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> left;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;;</span><br></pre></td></tr></table></figure>\n\n<h1 id=\"34-在排序数组中查找元素的第一个和最后一个位置-力扣（LeetCode）\"><a href=\"#34-在排序数组中查找元素的第一个和最后一个位置-力扣（LeetCode）\" class=\"headerlink\" title=\"34. 在排序数组中查找元素的第一个和最后一个位置 - 力扣（LeetCode）\"></a><a href=\"https://leetcode.cn/problems/find-first-and-last-position-of-element-in-sorted-array/description/\">34. 在排序数组中查找元素的第一个和最后一个位置 - 力扣（LeetCode）</a></h1><blockquote>\n<p><a href=\"https://leetcode.cn/problems/find-first-and-last-position-of-element-in-sorted-array/solutions/1980196/er-fen-cha-zhao-zong-shi-xie-bu-dui-yi-g-t9l9\">灵茶山艾府题解</a></p>\n</blockquote>\n<blockquote>\n<p><a href=\"https://leetcode.cn/problems/find-first-and-last-position-of-element-in-sorted-array/solutions/504484/zai-pai-xu-shu-zu-zhong-cha-zhao-yuan-su-de-di-3-4/\">官方题解</a></p>\n</blockquote>\n<blockquote>\n<blockquote>\n</blockquote>\n</blockquote>\n<figure class=\"highlight cpp\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">class</span> <span class=\"title class_\">Solution</span></span><br><span class=\"line\">&#123;</span><br><span class=\"line\">    <span class=\"function\"><span class=\"type\">int</span> <span class=\"title\">lower_bound</span><span class=\"params\">(vector&lt;<span class=\"type\">int</span>&gt; &amp;nums, <span class=\"type\">int</span> target)</span></span></span><br><span class=\"line\"><span class=\"function\">    </span>&#123;</span><br><span class=\"line\">        <span class=\"type\">int</span> left = <span class=\"number\">0</span>, right = (<span class=\"type\">int</span>)nums.<span class=\"built_in\">size</span>() - <span class=\"number\">1</span>;</span><br><span class=\"line\">        <span class=\"keyword\">while</span> (left &lt;= right)</span><br><span class=\"line\">        &#123;</span><br><span class=\"line\">            <span class=\"type\">int</span> mid = left + (right - left) / <span class=\"number\">2</span>;</span><br><span class=\"line\">            <span class=\"keyword\">if</span> (nums[mid] &gt;= target)</span><br><span class=\"line\">                right = mid - <span class=\"number\">1</span>;</span><br><span class=\"line\">            <span class=\"keyword\">if</span> (nums[mid] &lt; target)</span><br><span class=\"line\">                left = mid + <span class=\"number\">1</span>;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> left;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">public</span>:</span><br><span class=\"line\">    <span class=\"function\">vector&lt;<span class=\"type\">int</span>&gt; <span class=\"title\">searchRange</span><span class=\"params\">(vector&lt;<span class=\"type\">int</span>&gt; &amp;nums, <span class=\"type\">int</span> target)</span></span></span><br><span class=\"line\"><span class=\"function\">    </span>&#123;</span><br><span class=\"line\">        <span class=\"type\">int</span> start = <span class=\"built_in\">lower_bound</span>(nums, target);</span><br><span class=\"line\">        <span class=\"keyword\">if</span> (start == nums.<span class=\"built_in\">size</span>() || nums[start] != target)</span><br><span class=\"line\">            <span class=\"keyword\">return</span> &#123;<span class=\"number\">-1</span>, <span class=\"number\">-1</span>&#125;;</span><br><span class=\"line\">        <span class=\"type\">int</span> end = <span class=\"built_in\">lower_bound</span>(nums, target + <span class=\"number\">1</span>) - <span class=\"number\">1</span>;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> &#123;start, end&#125;;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;;</span><br></pre></td></tr></table></figure>\n\n<h1 id=\"69-x-的平方根-力扣（LeetCode）\"><a href=\"#69-x-的平方根-力扣（LeetCode）\" class=\"headerlink\" title=\"69. x 的平方根  - 力扣（LeetCode）\"></a><a href=\"https://leetcode.cn/problems/sqrtx/\">69. x 的平方根  - 力扣（LeetCode）</a></h1><blockquote>\n<h2 id=\"参考博客\"><a href=\"#参考博客\" class=\"headerlink\" title=\"参考博客\"></a>参考博客</h2><p><a href=\"https://blog.csdn.net/Poo_Chai/article/details/101976547\">求整数平方根算法-CSDN 博客</a></p>\n</blockquote>\n<blockquote>\n<p><a href=\"https://baike.baidu.com/item/IEEE%20754\">IEEE 754_IEEE 二进制浮点数算术标准</a></p>\n</blockquote>\n<h2 id=\"二分\"><a href=\"#二分\" class=\"headerlink\" title=\"二分\"></a>二分</h2><figure class=\"highlight cpp\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">class</span> <span class=\"title class_\">Solution</span></span><br><span class=\"line\">&#123;</span><br><span class=\"line\"><span class=\"keyword\">public</span>:</span><br><span class=\"line\"><span class=\"function\"><span class=\"type\">int</span> <span class=\"title\">mySqrt</span><span class=\"params\">(<span class=\"type\">int</span> x)</span></span></span><br><span class=\"line\"><span class=\"function\"></span>&#123;</span><br><span class=\"line\"><span class=\"type\">int</span> left = <span class=\"number\">0</span>, right = x;</span><br><span class=\"line\"><span class=\"keyword\">while</span>(left &lt;=right)&#123;</span><br><span class=\"line\"><span class=\"type\">long</span> <span class=\"type\">long</span> mid = left + (right - left) / <span class=\"number\">2</span>;</span><br><span class=\"line\"><span class=\"keyword\">if</span>(mid * mid &lt;= x)&#123;</span><br><span class=\"line\">left = mid + <span class=\"number\">1</span>;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"keyword\">else</span>&#123;</span><br><span class=\"line\">right = mid - <span class=\"number\">1</span>;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"keyword\">return</span> right;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\">&#125;;</span><br></pre></td></tr></table></figure>\n<h2 id=\"牛顿迭代法\"><a href=\"#牛顿迭代法\" class=\"headerlink\" title=\"牛顿迭代法\"></a>牛顿迭代法</h2><figure class=\"highlight cpp\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// f(x) = x^2 - C_</span></span><br><span class=\"line\"><span class=\"comment\">// f&#x27;(x) = 2x_</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// f(x) = 0 的解为 x = sqrt(C)_</span></span><br><span class=\"line\"><span class=\"comment\">// f(x) ~= f(x0) + f&#x27;(x0)(x - x0)_</span></span><br><span class=\"line\"><span class=\"comment\">//  0 = x0^2 - C + 2x0(x - x0)_</span></span><br><span class=\"line\"><span class=\"comment\">//  x = (C - x0^2) / 2x0 + x0 = (x0 + C / x0) / 2_</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">class</span> <span class=\"title class_\">Solution</span></span><br><span class=\"line\">&#123;</span><br><span class=\"line\"><span class=\"keyword\">public</span>:</span><br><span class=\"line\">    <span class=\"function\"><span class=\"type\">int</span> <span class=\"title\">mySqrt</span><span class=\"params\">(<span class=\"type\">int</span> x)</span></span></span><br><span class=\"line\"><span class=\"function\">    </span>&#123;</span><br><span class=\"line\">        <span class=\"keyword\">if</span>(x == <span class=\"number\">0</span>)</span><br><span class=\"line\">            <span class=\"keyword\">return</span> <span class=\"number\">0</span>;</span><br><span class=\"line\">        <span class=\"type\">long</span> x0 = x;</span><br><span class=\"line\">        <span class=\"keyword\">while</span>(x0 * x0 &gt; x)&#123;</span><br><span class=\"line\">            x0 = (x0 + x / x0) / <span class=\"number\">2</span>;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> (<span class=\"type\">int</span>)x0;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;;</span><br></pre></td></tr></table></figure>\n<h2 id=\"神奇的-0x5f3759df\"><a href=\"#神奇的-0x5f3759df\" class=\"headerlink\" title=\"神奇的 0x5f3759df\"></a>神奇的 0x5f3759df</h2> <figure class=\"highlight cpp\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// 使用快速平方根算法（Fast Inverse Square Root）的变体_</span></span><br><span class=\"line\"><span class=\"comment\">// 0x5f3759df 是一个魔法数字，用于快速估计平方根_</span></span><br><span class=\"line\"><span class=\"keyword\">class</span> <span class=\"title class_\">Solution</span></span><br><span class=\"line\">&#123;</span><br><span class=\"line\"><span class=\"keyword\">public</span>:</span><br><span class=\"line\"><span class=\"function\"><span class=\"type\">int</span> <span class=\"title\">mySqrt</span><span class=\"params\">(<span class=\"type\">int</span> x)</span></span></span><br><span class=\"line\"><span class=\"function\"></span>&#123;</span><br><span class=\"line\">        <span class=\"comment\">// 使用 long 类型避免整数溢出_</span></span><br><span class=\"line\"><span class=\"type\">long</span> x0 = x;</span><br><span class=\"line\">        <span class=\"comment\">// 使用魔法数字进行快速估计_</span></span><br><span class=\"line\">        <span class=\"comment\">// x0&gt;&gt;1 相当于除以 2，用于快速估计_</span></span><br><span class=\"line\">x0 = <span class=\"number\">0x5f3759df</span> - (x0&gt;&gt;<span class=\"number\">1</span>);</span><br><span class=\"line\">       <span class=\"comment\">// 使用牛顿迭代法进行精确化_</span></span><br><span class=\"line\">        <span class=\"comment\">// 迭代公式：x = (x + n/x) / 2_</span></span><br><span class=\"line\"><span class=\"keyword\">while</span> (x0 * x0 &gt; x)</span><br><span class=\"line\">&#123;</span><br><span class=\"line\">x0 = (x0 + x / x0) / <span class=\"number\">2</span>;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"keyword\">return</span> (<span class=\"type\">int</span>)x0;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\">&#125;;</span><br><span class=\"line\"></span><br></pre></td></tr></table></figure>\n<h2 id=\"位运算\"><a href=\"#位运算\" class=\"headerlink\" title=\"位运算\"></a>位运算</h2> <figure class=\"highlight cpp\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">_<span class=\"comment\">// 使用位运算求解x的算术平方根_</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"type\">int</span> <span class=\"title\">mySqrt</span><span class=\"params\">(<span class=\"type\">int</span> x)</span></span></span><br><span class=\"line\"><span class=\"function\"></span>&#123;</span><br><span class=\"line\">_    <span class=\"comment\">// m初始化为2^30，用于逐位检查_</span></span><br><span class=\"line\">    <span class=\"type\">unsigned</span> m = <span class=\"number\">0x40000000</span>, y = <span class=\"number\">0</span>, b = <span class=\"number\">0</span>;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">while</span> (m != <span class=\"number\">0</span>)</span><br><span class=\"line\">    &#123;</span><br><span class=\"line\">_        <span class=\"comment\">// 计算当前位可能的平方值_</span></span><br><span class=\"line\">        b = y | m;</span><br><span class=\"line\">_        <span class=\"comment\">// y右移一位，为下一位做准备_</span></span><br><span class=\"line\">        y = y &gt;&gt; <span class=\"number\">1</span>;</span><br><span class=\"line\">_        <span class=\"comment\">// 如果x大于等于当前平方值，说明该位可以取1_</span></span><br><span class=\"line\">        <span class=\"keyword\">if</span> (x &gt;= b)</span><br><span class=\"line\">        &#123;</span><br><span class=\"line\">_            <span class=\"comment\">// 更新x的值_</span></span><br><span class=\"line\">            x = x - b;</span><br><span class=\"line\">_            <span class=\"comment\">// 将当前位设为1_</span></span><br><span class=\"line\">            y = y | m;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">_        <span class=\"comment\">// m右移两位，检查下一位_</span></span><br><span class=\"line\">        m = m &gt;&gt; <span class=\"number\">2</span>;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">return</span> y;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<h2 id=\"袖珍计算器-使用-exp-与-ln-函数进行求解\"><a href=\"#袖珍计算器-使用-exp-与-ln-函数进行求解\" class=\"headerlink\" title=\"袖珍计算器(使用 exp 与 ln 函数进行求解)\"></a>袖珍计算器(使用 exp 与 ln 函数进行求解)</h2><p>使用$\\sqrt{x} &#x3D; e^{\\frac{1}{2}lnx}$</p>\n <figure class=\"highlight cpp\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"keyword\">include</span> <span class=\"string\">&lt;cmath&gt;</span></span></span><br><span class=\"line\"></span><br><span class=\"line\">_<span class=\"comment\">// 使用数学公式求解 x 的算术平方根_</span></span><br><span class=\"line\">_<span class=\"comment\">// 利用公式：sqrt(x) = e^(0.5 * ln(x))_</span></span><br><span class=\"line\"><span class=\"keyword\">class</span> <span class=\"title class_\">Solution</span></span><br><span class=\"line\">&#123;</span><br><span class=\"line\"><span class=\"keyword\">public</span>:</span><br><span class=\"line\"><span class=\"function\"><span class=\"type\">int</span> <span class=\"title\">mySqrt</span><span class=\"params\">(<span class=\"type\">int</span> x)</span></span></span><br><span class=\"line\"><span class=\"function\"></span>&#123;</span><br><span class=\"line\">_        <span class=\"comment\">// 处理特殊情况：x 为 0 时直接返回 0_</span></span><br><span class=\"line\"><span class=\"keyword\">if</span>(x == <span class=\"number\">0</span>)</span><br><span class=\"line\"><span class=\"keyword\">return</span> <span class=\"number\">0</span>;</span><br><span class=\"line\">_        <span class=\"comment\">// 使用 exp 和 log 函数计算平方根_</span></span><br><span class=\"line\">_        <span class=\"comment\">// exp(0.5 * log(x)) = e^(0.5 * ln(x)) = sqrt(x)_</span></span><br><span class=\"line\"><span class=\"type\">int</span> res = <span class=\"built_in\">exp</span>(<span class=\"number\">0.5</span> * <span class=\"built_in\">log</span>(x));</span><br><span class=\"line\"><span class=\"keyword\">return</span> (<span class=\"type\">long</span> <span class=\"type\">long</span>)(res + <span class=\"number\">1</span>) * (res + <span class=\"number\">1</span>) &lt;= x ? res + <span class=\"number\">1</span> : res;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\">&#125;;</span><br><span class=\"line\"></span><br></pre></td></tr></table></figure>\n\n<h1 id=\"367-有效的完全平方数-力扣（LeetCode）\"><a href=\"#367-有效的完全平方数-力扣（LeetCode）\" class=\"headerlink\" title=\"367. 有效的完全平方数 - 力扣（LeetCode）\"></a><a href=\"https://leetcode.cn/problems/valid-perfect-square/solutions/1081379/you-xiao-de-wan-quan-ping-fang-shu-by-le-wkee/\">367. 有效的完全平方数 - 力扣（LeetCode）</a></h1><blockquote>\n<p>与前面的题非常相似</p>\n</blockquote>\n<figure class=\"highlight cpp\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">class</span> <span class=\"title class_\">Solution</span></span><br><span class=\"line\">&#123;</span><br><span class=\"line\"><span class=\"keyword\">public</span>:</span><br><span class=\"line\"><span class=\"function\"><span class=\"type\">bool</span> <span class=\"title\">isPerfectSquare</span><span class=\"params\">(<span class=\"type\">int</span> num)</span></span></span><br><span class=\"line\"><span class=\"function\"></span>&#123;</span><br><span class=\"line\"><span class=\"type\">int</span> left = <span class=\"number\">0</span>, right = num;</span><br><span class=\"line\"><span class=\"keyword\">while</span>(left &lt;= right)&#123;</span><br><span class=\"line\"><span class=\"type\">long</span> <span class=\"type\">long</span> mid = left + (right - left) / <span class=\"number\">2</span>;</span><br><span class=\"line\"><span class=\"keyword\">if</span>(mid * mid == num)</span><br><span class=\"line\"><span class=\"keyword\">return</span> <span class=\"literal\">true</span>;</span><br><span class=\"line\"><span class=\"keyword\">else</span> <span class=\"keyword\">if</span>(mid * mid &lt; num)</span><br><span class=\"line\">left = mid + <span class=\"number\">1</span>;</span><br><span class=\"line\"><span class=\"keyword\">else</span></span><br><span class=\"line\">right = mid - <span class=\"number\">1</span>;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"keyword\">return</span> <span class=\"literal\">false</span>;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\">&#125;;</span><br><span class=\"line\"></span><br></pre></td></tr></table></figure>\n\n\n\n\n"},{"title":"2025-05-12-虚函数","date":"2025-05-11T16:00:00.000Z","_content":"2025-05-12-虚函数\n\n> # 参考资源\n>\n> [对 C++ 虚函数不了解？看完这篇文章掌握虚函数的原理和作用](https://zhuanlan.zhihu.com/p/629281871)\n>\n> [4-虚函数_哔哩哔哩_bilibili](https://www.bilibili.com/video/BV1QV4y1U73z/)\n>\n> [C++ 虚函数和纯虚函数的区别](https://www.runoob.com/w3cnote/cpp-virtual-functions.html)\n>\n> [C++ 多态--虚函数 virtual 及 override_虚函数 override-CSDN 博客](https://blog.csdn.net/i_chaoren/article/details/77281785)\n>\n> [C++ 虚函数](https://zhuanlan.zhihu.com/p/54145222)\n\n虚函数是在父类中定义的一种特殊类型的函数，允许子类重写该函数以适应其自身需求。虚函数的调用取决于对象的实际类型，而不是指针或引用类型。通过将函数声明为虚函数，可以使继承层次结构中的每个子类都能够使用其自己的实现，从而提高代码的可扩展性和灵活性。在 C++ 中，使用关键字\"virtual\"来定义虚函数。\n\n- 虚函数不代表函数为不被实现的函数。\n- 为了允许用基类的指针来调用子类的这个函数。\n- 定义一个函数为纯虚函数，才代表函数没有被实现。\n- 纯虚函数是为了实现一个接口，起到一个规范的作用，规范继承这个类的程序员必须实现这个函数。\n\n虚函数虚在所谓\"推迟联编\"或者\"动态联编\"上，一个类函数的调用并不是在编译时刻被确定的，而是在运行时刻被确定的。由于编写代码的时候并不能确定被调用的是基类的函数还是哪个派生类的函数，所以被成为\"虚\"函数。\n\n# Motivation\n\n虚函数可以让子类对象在运行时动态地继承和修改父类的成员函数，使得代码更加灵活、可重用，并且可以实现多态性和[抽象类](https://zhida.zhihu.com/search?content_id=227971983&content_type=Article&match_order=1&q=%E6%8A%BD%E8%B1%A1%E7%B1%BB&zhida_source=entity)等高级特性。\n\n1. 通过虚函数，可以实现多态性（Polymorphism），即同一个函数名可以在不同的子类中表现出不同的行为，这样可以提高代码的可重用性和灵活性。\n2. 避免静态绑定，在使用父类指针或引用调用子类对象的成员函数时，如果没有使用虚函数，则会进行静态绑定（Static Binding），即只能调用父类的成员函数，无法调用子类特有的成员函数。\n3. 虚函数的调用是[动态绑定](https://zhida.zhihu.com/search?content_id=227971983&content_type=Article&match_order=1&q=%E5%8A%A8%E6%80%81%E7%BB%91%E5%AE%9A&zhida_source=entity)（Dynamic Binding）的，即在运行时根据指针或引用所指向的对象类型来选择调用哪个函数，从而实现动态多态性。\n4. 抽象类是一种不能直接实例化的类，只能被其他类继承并实现其虚函数。通过定义[纯虚函数](https://zhida.zhihu.com/search?content_id=227971983&content_type=Article&match_order=1&q=%E7%BA%AF%E8%99%9A%E5%87%BD%E6%95%B0&zhida_source=entity)（Pure Virtual Function），可以使得一个类成为抽象类，强制其子类必须实现该函数。\n\n```cpp\n// 形状基类，定义了计算面积和周长的虚函数\nclass Shape {\npublic:\n   // 计算面积的虚函数，提供默认实\n   // 使用virtual关键字，允许派生类重写\n   virtual double calculateArea() {\n       return 0.0; // 基类提供默认实现\n   }\n\n   // 计算周长的虚函数，提供默认实现\n   // 使用virtual关键字，允许派生类重写\n   virtual double calculatePerimeter() {\n       return 0.0; // 基类提供默认实现\n   }\n\n   // 虚析构函数，确保派生类对象正确释放\n   virtual ~Shape() {} // 虚析构函数\n};\n\n// 矩形类，继承自Shape基类\nclass Rectangle : public Shape {\nprivate:\n   // 矩形的私有成员：宽和高\n   double width;\n   double height;\n\npublic:\n   // 构造函数，初始化矩形的宽和高\n   Rectangle(double w, double h) : width(w), height(h) {}\n\n   // 重写基类的calculateArea虚函数\n   // override关键字确保正确重写基类虚函数\n   double calculateArea() override {\n       return width * height; // 矩形面积计算\n   }\n\n   // 重写基类的calculatePerimeter虚函数\n   double calculatePerimeter() override {\n       return 2 * (width + height); // 矩形周长计算\n   }\n};\n\n// 圆形类，继承自Shape基类\nclass Circle : public Shape {\nprivate:\n   // 圆形的私有成员：半径\n   double radius;\n   // 圆周率常量\n   const double PI = 3.14159;\n\npublic:\n   // 构造函数，初始化圆形的半径\n   Circle(double r) : radius(r) {}\n\n   // 重写基类的calculateArea虚函数\n   // override关键字确保正确重写基类虚函数\n   double calculateArea() override {\n       return PI * radius * radius; // 圆形面积计算\n   }\n\n   // 重写基类的calculatePerimeter虚函数\n   double calculatePerimeter() override {\n       return 2 * PI * radius; // 圆形周长计算\n   }\n};\n```\n\n# Concept\n\n**虚函数只能借助于指针或者引用来达到多态的效果。**\n\n> **多态**的本质是“同一个函数调用，能够根据不同对象表现出不同的行为\n\n# Method\n\n![1747056760477QGSmb9FB5obI4CxbD3RcFRIynCe.png](https://tk-pichost-1325224430.cos.ap-chengdu.myqcloud.com/blog/1747056760477QGSmb9FB5obI4CxbD3RcFRIynCe.png)\n\n# 知识点\n\n## 虚函数声明\n\n从简单的例子开始\n\n```cpp\nclass Animal\n{\npublic:\n    virtual void shout()\n    {\n        cout << \"动物叫了一声\\n\";\n    }\n};\n\nclass Cat : public Animal\n{\npublic:\n    void shout() override\n    {\n        cout << \"喵喵喵\\n\";\n    }\n};\n```\n\n**解释：**\n\n- 代码通过 `Animal` 基类定义了一个虚函数 `shout()`，为派生类提供了一个默认实现。\n- `Cat` 类继承自 `Animal`，使用 `override` 关键字重写了 `shout()` 方法，展示了虚函数允许派生类提供自己的特定实现。\n- 这个示例体现了 C++ 多态性的基本原理：基类定义一个通用接口，派生类可以根据自身特性灵活地实现具体行为。\n\n> 需要注意的是，在子类中重写虚函数时，其访问权限不能更严格（即不能由 public 变为 private 或 protected），否则编译器会报错。\n\n## 纯虚函数与抽象类\n\n### 纯虚函数\n\n纯虚函数是指在基类中定义的没有实现的虚函数。使用纯虚函数可以使该函数只有函数原型，而没有具体的实现。注：这里的“=0”表示该函数为纯虚函数。\n\n纯虚函数的作用是让子类必须实现该函数，并且不能直接创建该类对象（即该类为抽象类）。\n\n```cpp\nvirtual void func() = 0;\n```\n\n```cpp\nclass Shape {\npublic:\n   // 纯虚函数，没有默认实现\n   virtual double calculateArea() = 0;\n   \n   // 包含纯虚函数的类成为抽象类\n   virtual void draw() = 0;\n};\n\nclass Rectangle : public Shape {\npublic:\n   // 必须实现基类的纯虚函数\n   double calculateArea() override {\n       return width * height;\n   }\n   \n   void draw() override {\n       // 绘制矩形的具体实现\n   }\n\nprivate:\n   double width;\n   double height;\n};\n```\n\n**解释：**\n\n- 代码通过 `Shape` 基类定义了两个纯虚函数 `calculateArea()` 和 `draw()`，使 `Shape` 成为一个抽象类。\n- 纯虚函数（`= 0`）没有默认实现，强制派生类必须提供具体实现。\n- `Rectangle` 类继承自 `Shape`，必须实现所有纯虚函数，否则仍将是抽象类。\n- 这个示例展示了纯虚函数作为接口的设计模式，确保派生类提供必要的具体行为。\n\n### 抽象类\n\n抽象类是包含纯虚函数的类，它们不能被实例化，只能被继承。抽象类只能用作其他类的基类。如果一个类继承了抽象类，则必须实现所有的纯虚函数，否则该类也会成为抽象类。\n\n```cpp\nclass Shape\n{\npublic:\n_    // 纯虚函数_\n    virtual double getArea() = 0;\n};\n\n_// 继承自抽象类Shape_\nclass Rectangle : public Shape\n{\npublic:\n    double **width**;\n    double **height**;\n    double getArea() { return **width** * **height**; }\n};\n\n_// 继承自抽象类Shape_\nclass Circle : public Shape\n{\npublic:\n    double **radius**;\n    double getArea() { return 3.14 * **radius** * **radius**; }\n};\n```\n\nShape 为抽象类，其中包含纯虚函数 getArea()，Rectangle 和 Circle 均继承自 Shape，并且实现了 getArea()函数的具体内容。\n\n### 多重继承中的虚函数\n\n在多重继承中，如果一个类同时继承了多个基类，而这些基类中都有同名的虚函数，那么子类必须对这些虚函数进行重写并实现。此时，需要使用作用域限定符来指明重写的是哪个基类的虚函数。\n\n```cpp\nclass Base1\n{\npublic:\n    virtual void func() { cout << \"Base1::func()\" << endl; }\n};\n\nclass Base2\n{\npublic:\n    virtual void func() { cout << \"Base2::func()\" << endl; }\n};\n\nclass Derived : public Base1, public Base2\n{\npublic:\n    virtual void func()\n    {\n        Base1::func();\n        Base2::func();\n    }\n};\n```\n\n派生类 Derived 同时继承了 Base1 和 Base2，这两个基类中都有名为 func 的虚函数。在 Derived 中，我们通过使用作用域限定符 Base1::和 Base2::，分别调用了两个基类中的虚函数。\n\n### **总结**\n\n- 优点：\n\n  - 实现多态性：通过虚函数，可以在不知道对象具体类型的情况下，调用特定对象的方法。\n  - 代码灵活性：虚函数允许子类覆盖父类的方法，并且不需要改变基类的代码。\n  - 代码可维护性：虚函数使得代码易于维护和扩展，因为子类可以通过重载虚函数来实现自己的行为。\n- 缺点：\n\n  - 额外的开销：虚函数需要额外的开销来支持运行时的动态绑定和查找虚表。这可能会影响程序的性能。\n  - 可能会引起混淆：由于虚函数的存在，同名的函数可能会被不同的类定义。如果没有正确的使用虚函数，可能会导致混淆和错误的结果。\n  - 不适合于小型应用：虚函数对于小型应用来说可能过于复杂和冗余。在这种情况下，使用虚函数可能会导致更多的开销而不是提高效率。\n\n# Example\n\n```cpp\n#include <iostream>\n#include <string>\n\n// 基类Entity，定义了一个虚函数GetName()\nclass Entity {\npublic:\n   // 虚函数，返回一个默认的实体名称\n   // 使用virtual关键字，允许派生类重写\n   virtual std::string GetName() { return \"Entity\"; }\n};\n\n// 派生类Player，继承自Entity\nclass Player : public Entity {\nprivate:\n   // 私有成员，存储玩家名称\n   std::string m_Name;\n\npublic:\n   // 构造函数，使用传入的名称初始化玩家\n   Player(const std::string& name) :m_Name(name) {};\n\n   // 重写基类的GetName()虚函数\n   // override关键字确保正确重写基类虚函数\n   std::string GetName() override { return m_Name; };\n\n   // 设置玩家名称的成员函数\n   void SetName(std::string name) { m_Name = name; };\n};\n\n// 打印实体名称的函数\n// 接受一个Entity指针作为参数，体现了多态性\nvoid PrintName(Entity* entity) {\n   // 调用虚函数GetName()，实际执行的是对象的具体实现\n   std::cout << entity->GetName() << std::endl;\n};\n\nint main() {\n   // 创建一个基类Entity对象的指针\n   Entity* e = new Entity();\n   // 调用PrintName()，将打印\"Entity\"\n   PrintName(e);\n\n   // 创建一个Player对象，名称为\"tanke\"\n   Player* p = new Player(\"tanke\");\n   // 调用PrintName()，将打印\"tanke\"\n   PrintName(p);\n\n   // 修改Player对象的名称为\"wangjie\"\n   p->SetName(\"wangjie\");\n\n   // 将Player指针赋值给基类指针，体现了多态性\n   Entity* e1 = p;\n   // 调用PrintName()，将打印\"wangjie\"\n   PrintName(p);\n\n   // 等待用户输入，保持窗口打开\n   std::cin.get();\n\n   return 0;\n}\n```\n\n**解释：**\n\n- 代码通过 `Entity` 基类定义了一个虚函数 `GetName()`，为派生类提供了一个默认实现。\n- `Player` 类继承自 `Entity`，并使用 `override` 关键字重写了 `GetName()` 方法。\n- `PrintName()` 函数接受一个 `Entity` 指针，展示了 C++ 多态性的关键特征 - 可以通过基类指针调用派生类的具体实现。\n\n![1747056796676Ue1zbj8hco94t9xuRBRcd0jWnXg.png](https://tk-pichost-1325224430.cos.ap-chengdu.myqcloud.com/blog/1747056796676Ue1zbj8hco94t9xuRBRcd0jWnXg.png)\n\n# 思考\n\n1. 虚函数应用于继承层次结构中的多态性，即通过基类指针或引用调用派生类对象的成员函数。\n2. 可以将虚函数作为接口定义，让不同的派生类实现自己的版本，以满足各自的需求。\n3. 避免在构造函数和析构函数中调用虚函数，因为此时对象还未完全构造或已经被销毁。\n4. 虚函数的声明应该在公共部分（例如基类），而不是在私有部分（例如派生类）中声明。\n5. 将虚函数的实现定义为 inline 可以提高程序的执行效率。\n6. 在使用纯虚函数时，需要给出其具体实现。可以在派生类中实现，也可以在基类中实现。\n7. 避免过度使用虚函数，因为虚函数会增加程序的开销。在没有必要的情况下，可以使用普通成员函数代替虚函数。\n","source":"_posts/2025-05-12-虚函数.md","raw":"---\ntitle: 2025-05-12-虚函数\ndate: 2025-05-12\ntags: 程序开发\n\n---\n2025-05-12-虚函数\n\n> # 参考资源\n>\n> [对 C++ 虚函数不了解？看完这篇文章掌握虚函数的原理和作用](https://zhuanlan.zhihu.com/p/629281871)\n>\n> [4-虚函数_哔哩哔哩_bilibili](https://www.bilibili.com/video/BV1QV4y1U73z/)\n>\n> [C++ 虚函数和纯虚函数的区别](https://www.runoob.com/w3cnote/cpp-virtual-functions.html)\n>\n> [C++ 多态--虚函数 virtual 及 override_虚函数 override-CSDN 博客](https://blog.csdn.net/i_chaoren/article/details/77281785)\n>\n> [C++ 虚函数](https://zhuanlan.zhihu.com/p/54145222)\n\n虚函数是在父类中定义的一种特殊类型的函数，允许子类重写该函数以适应其自身需求。虚函数的调用取决于对象的实际类型，而不是指针或引用类型。通过将函数声明为虚函数，可以使继承层次结构中的每个子类都能够使用其自己的实现，从而提高代码的可扩展性和灵活性。在 C++ 中，使用关键字\"virtual\"来定义虚函数。\n\n- 虚函数不代表函数为不被实现的函数。\n- 为了允许用基类的指针来调用子类的这个函数。\n- 定义一个函数为纯虚函数，才代表函数没有被实现。\n- 纯虚函数是为了实现一个接口，起到一个规范的作用，规范继承这个类的程序员必须实现这个函数。\n\n虚函数虚在所谓\"推迟联编\"或者\"动态联编\"上，一个类函数的调用并不是在编译时刻被确定的，而是在运行时刻被确定的。由于编写代码的时候并不能确定被调用的是基类的函数还是哪个派生类的函数，所以被成为\"虚\"函数。\n\n# Motivation\n\n虚函数可以让子类对象在运行时动态地继承和修改父类的成员函数，使得代码更加灵活、可重用，并且可以实现多态性和[抽象类](https://zhida.zhihu.com/search?content_id=227971983&content_type=Article&match_order=1&q=%E6%8A%BD%E8%B1%A1%E7%B1%BB&zhida_source=entity)等高级特性。\n\n1. 通过虚函数，可以实现多态性（Polymorphism），即同一个函数名可以在不同的子类中表现出不同的行为，这样可以提高代码的可重用性和灵活性。\n2. 避免静态绑定，在使用父类指针或引用调用子类对象的成员函数时，如果没有使用虚函数，则会进行静态绑定（Static Binding），即只能调用父类的成员函数，无法调用子类特有的成员函数。\n3. 虚函数的调用是[动态绑定](https://zhida.zhihu.com/search?content_id=227971983&content_type=Article&match_order=1&q=%E5%8A%A8%E6%80%81%E7%BB%91%E5%AE%9A&zhida_source=entity)（Dynamic Binding）的，即在运行时根据指针或引用所指向的对象类型来选择调用哪个函数，从而实现动态多态性。\n4. 抽象类是一种不能直接实例化的类，只能被其他类继承并实现其虚函数。通过定义[纯虚函数](https://zhida.zhihu.com/search?content_id=227971983&content_type=Article&match_order=1&q=%E7%BA%AF%E8%99%9A%E5%87%BD%E6%95%B0&zhida_source=entity)（Pure Virtual Function），可以使得一个类成为抽象类，强制其子类必须实现该函数。\n\n```cpp\n// 形状基类，定义了计算面积和周长的虚函数\nclass Shape {\npublic:\n   // 计算面积的虚函数，提供默认实\n   // 使用virtual关键字，允许派生类重写\n   virtual double calculateArea() {\n       return 0.0; // 基类提供默认实现\n   }\n\n   // 计算周长的虚函数，提供默认实现\n   // 使用virtual关键字，允许派生类重写\n   virtual double calculatePerimeter() {\n       return 0.0; // 基类提供默认实现\n   }\n\n   // 虚析构函数，确保派生类对象正确释放\n   virtual ~Shape() {} // 虚析构函数\n};\n\n// 矩形类，继承自Shape基类\nclass Rectangle : public Shape {\nprivate:\n   // 矩形的私有成员：宽和高\n   double width;\n   double height;\n\npublic:\n   // 构造函数，初始化矩形的宽和高\n   Rectangle(double w, double h) : width(w), height(h) {}\n\n   // 重写基类的calculateArea虚函数\n   // override关键字确保正确重写基类虚函数\n   double calculateArea() override {\n       return width * height; // 矩形面积计算\n   }\n\n   // 重写基类的calculatePerimeter虚函数\n   double calculatePerimeter() override {\n       return 2 * (width + height); // 矩形周长计算\n   }\n};\n\n// 圆形类，继承自Shape基类\nclass Circle : public Shape {\nprivate:\n   // 圆形的私有成员：半径\n   double radius;\n   // 圆周率常量\n   const double PI = 3.14159;\n\npublic:\n   // 构造函数，初始化圆形的半径\n   Circle(double r) : radius(r) {}\n\n   // 重写基类的calculateArea虚函数\n   // override关键字确保正确重写基类虚函数\n   double calculateArea() override {\n       return PI * radius * radius; // 圆形面积计算\n   }\n\n   // 重写基类的calculatePerimeter虚函数\n   double calculatePerimeter() override {\n       return 2 * PI * radius; // 圆形周长计算\n   }\n};\n```\n\n# Concept\n\n**虚函数只能借助于指针或者引用来达到多态的效果。**\n\n> **多态**的本质是“同一个函数调用，能够根据不同对象表现出不同的行为\n\n# Method\n\n![1747056760477QGSmb9FB5obI4CxbD3RcFRIynCe.png](https://tk-pichost-1325224430.cos.ap-chengdu.myqcloud.com/blog/1747056760477QGSmb9FB5obI4CxbD3RcFRIynCe.png)\n\n# 知识点\n\n## 虚函数声明\n\n从简单的例子开始\n\n```cpp\nclass Animal\n{\npublic:\n    virtual void shout()\n    {\n        cout << \"动物叫了一声\\n\";\n    }\n};\n\nclass Cat : public Animal\n{\npublic:\n    void shout() override\n    {\n        cout << \"喵喵喵\\n\";\n    }\n};\n```\n\n**解释：**\n\n- 代码通过 `Animal` 基类定义了一个虚函数 `shout()`，为派生类提供了一个默认实现。\n- `Cat` 类继承自 `Animal`，使用 `override` 关键字重写了 `shout()` 方法，展示了虚函数允许派生类提供自己的特定实现。\n- 这个示例体现了 C++ 多态性的基本原理：基类定义一个通用接口，派生类可以根据自身特性灵活地实现具体行为。\n\n> 需要注意的是，在子类中重写虚函数时，其访问权限不能更严格（即不能由 public 变为 private 或 protected），否则编译器会报错。\n\n## 纯虚函数与抽象类\n\n### 纯虚函数\n\n纯虚函数是指在基类中定义的没有实现的虚函数。使用纯虚函数可以使该函数只有函数原型，而没有具体的实现。注：这里的“=0”表示该函数为纯虚函数。\n\n纯虚函数的作用是让子类必须实现该函数，并且不能直接创建该类对象（即该类为抽象类）。\n\n```cpp\nvirtual void func() = 0;\n```\n\n```cpp\nclass Shape {\npublic:\n   // 纯虚函数，没有默认实现\n   virtual double calculateArea() = 0;\n   \n   // 包含纯虚函数的类成为抽象类\n   virtual void draw() = 0;\n};\n\nclass Rectangle : public Shape {\npublic:\n   // 必须实现基类的纯虚函数\n   double calculateArea() override {\n       return width * height;\n   }\n   \n   void draw() override {\n       // 绘制矩形的具体实现\n   }\n\nprivate:\n   double width;\n   double height;\n};\n```\n\n**解释：**\n\n- 代码通过 `Shape` 基类定义了两个纯虚函数 `calculateArea()` 和 `draw()`，使 `Shape` 成为一个抽象类。\n- 纯虚函数（`= 0`）没有默认实现，强制派生类必须提供具体实现。\n- `Rectangle` 类继承自 `Shape`，必须实现所有纯虚函数，否则仍将是抽象类。\n- 这个示例展示了纯虚函数作为接口的设计模式，确保派生类提供必要的具体行为。\n\n### 抽象类\n\n抽象类是包含纯虚函数的类，它们不能被实例化，只能被继承。抽象类只能用作其他类的基类。如果一个类继承了抽象类，则必须实现所有的纯虚函数，否则该类也会成为抽象类。\n\n```cpp\nclass Shape\n{\npublic:\n_    // 纯虚函数_\n    virtual double getArea() = 0;\n};\n\n_// 继承自抽象类Shape_\nclass Rectangle : public Shape\n{\npublic:\n    double **width**;\n    double **height**;\n    double getArea() { return **width** * **height**; }\n};\n\n_// 继承自抽象类Shape_\nclass Circle : public Shape\n{\npublic:\n    double **radius**;\n    double getArea() { return 3.14 * **radius** * **radius**; }\n};\n```\n\nShape 为抽象类，其中包含纯虚函数 getArea()，Rectangle 和 Circle 均继承自 Shape，并且实现了 getArea()函数的具体内容。\n\n### 多重继承中的虚函数\n\n在多重继承中，如果一个类同时继承了多个基类，而这些基类中都有同名的虚函数，那么子类必须对这些虚函数进行重写并实现。此时，需要使用作用域限定符来指明重写的是哪个基类的虚函数。\n\n```cpp\nclass Base1\n{\npublic:\n    virtual void func() { cout << \"Base1::func()\" << endl; }\n};\n\nclass Base2\n{\npublic:\n    virtual void func() { cout << \"Base2::func()\" << endl; }\n};\n\nclass Derived : public Base1, public Base2\n{\npublic:\n    virtual void func()\n    {\n        Base1::func();\n        Base2::func();\n    }\n};\n```\n\n派生类 Derived 同时继承了 Base1 和 Base2，这两个基类中都有名为 func 的虚函数。在 Derived 中，我们通过使用作用域限定符 Base1::和 Base2::，分别调用了两个基类中的虚函数。\n\n### **总结**\n\n- 优点：\n\n  - 实现多态性：通过虚函数，可以在不知道对象具体类型的情况下，调用特定对象的方法。\n  - 代码灵活性：虚函数允许子类覆盖父类的方法，并且不需要改变基类的代码。\n  - 代码可维护性：虚函数使得代码易于维护和扩展，因为子类可以通过重载虚函数来实现自己的行为。\n- 缺点：\n\n  - 额外的开销：虚函数需要额外的开销来支持运行时的动态绑定和查找虚表。这可能会影响程序的性能。\n  - 可能会引起混淆：由于虚函数的存在，同名的函数可能会被不同的类定义。如果没有正确的使用虚函数，可能会导致混淆和错误的结果。\n  - 不适合于小型应用：虚函数对于小型应用来说可能过于复杂和冗余。在这种情况下，使用虚函数可能会导致更多的开销而不是提高效率。\n\n# Example\n\n```cpp\n#include <iostream>\n#include <string>\n\n// 基类Entity，定义了一个虚函数GetName()\nclass Entity {\npublic:\n   // 虚函数，返回一个默认的实体名称\n   // 使用virtual关键字，允许派生类重写\n   virtual std::string GetName() { return \"Entity\"; }\n};\n\n// 派生类Player，继承自Entity\nclass Player : public Entity {\nprivate:\n   // 私有成员，存储玩家名称\n   std::string m_Name;\n\npublic:\n   // 构造函数，使用传入的名称初始化玩家\n   Player(const std::string& name) :m_Name(name) {};\n\n   // 重写基类的GetName()虚函数\n   // override关键字确保正确重写基类虚函数\n   std::string GetName() override { return m_Name; };\n\n   // 设置玩家名称的成员函数\n   void SetName(std::string name) { m_Name = name; };\n};\n\n// 打印实体名称的函数\n// 接受一个Entity指针作为参数，体现了多态性\nvoid PrintName(Entity* entity) {\n   // 调用虚函数GetName()，实际执行的是对象的具体实现\n   std::cout << entity->GetName() << std::endl;\n};\n\nint main() {\n   // 创建一个基类Entity对象的指针\n   Entity* e = new Entity();\n   // 调用PrintName()，将打印\"Entity\"\n   PrintName(e);\n\n   // 创建一个Player对象，名称为\"tanke\"\n   Player* p = new Player(\"tanke\");\n   // 调用PrintName()，将打印\"tanke\"\n   PrintName(p);\n\n   // 修改Player对象的名称为\"wangjie\"\n   p->SetName(\"wangjie\");\n\n   // 将Player指针赋值给基类指针，体现了多态性\n   Entity* e1 = p;\n   // 调用PrintName()，将打印\"wangjie\"\n   PrintName(p);\n\n   // 等待用户输入，保持窗口打开\n   std::cin.get();\n\n   return 0;\n}\n```\n\n**解释：**\n\n- 代码通过 `Entity` 基类定义了一个虚函数 `GetName()`，为派生类提供了一个默认实现。\n- `Player` 类继承自 `Entity`，并使用 `override` 关键字重写了 `GetName()` 方法。\n- `PrintName()` 函数接受一个 `Entity` 指针，展示了 C++ 多态性的关键特征 - 可以通过基类指针调用派生类的具体实现。\n\n![1747056796676Ue1zbj8hco94t9xuRBRcd0jWnXg.png](https://tk-pichost-1325224430.cos.ap-chengdu.myqcloud.com/blog/1747056796676Ue1zbj8hco94t9xuRBRcd0jWnXg.png)\n\n# 思考\n\n1. 虚函数应用于继承层次结构中的多态性，即通过基类指针或引用调用派生类对象的成员函数。\n2. 可以将虚函数作为接口定义，让不同的派生类实现自己的版本，以满足各自的需求。\n3. 避免在构造函数和析构函数中调用虚函数，因为此时对象还未完全构造或已经被销毁。\n4. 虚函数的声明应该在公共部分（例如基类），而不是在私有部分（例如派生类）中声明。\n5. 将虚函数的实现定义为 inline 可以提高程序的执行效率。\n6. 在使用纯虚函数时，需要给出其具体实现。可以在派生类中实现，也可以在基类中实现。\n7. 避免过度使用虚函数，因为虚函数会增加程序的开销。在没有必要的情况下，可以使用普通成员函数代替虚函数。\n","slug":"2025-05-12-虚函数","published":1,"updated":"2025-09-26T12:17:47.396Z","_id":"cmg0saj4a001zjm8nberm4y8i","comments":1,"layout":"post","photos":[],"content":"<p>2025-05-12-虚函数</p>\n<blockquote>\n<h1 id=\"参考资源\"><a href=\"#参考资源\" class=\"headerlink\" title=\"参考资源\"></a>参考资源</h1><p><a href=\"https://zhuanlan.zhihu.com/p/629281871\">对 C++ 虚函数不了解？看完这篇文章掌握虚函数的原理和作用</a></p>\n<p><a href=\"https://www.bilibili.com/video/BV1QV4y1U73z/\">4-虚函数_哔哩哔哩_bilibili</a></p>\n<p><a href=\"https://www.runoob.com/w3cnote/cpp-virtual-functions.html\">C++ 虚函数和纯虚函数的区别</a></p>\n<p><a href=\"https://blog.csdn.net/i_chaoren/article/details/77281785\">C++ 多态–虚函数 virtual 及 override_虚函数 override-CSDN 博客</a></p>\n<p><a href=\"https://zhuanlan.zhihu.com/p/54145222\">C++ 虚函数</a></p>\n</blockquote>\n<p>虚函数是在父类中定义的一种特殊类型的函数，允许子类重写该函数以适应其自身需求。虚函数的调用取决于对象的实际类型，而不是指针或引用类型。通过将函数声明为虚函数，可以使继承层次结构中的每个子类都能够使用其自己的实现，从而提高代码的可扩展性和灵活性。在 C++ 中，使用关键字”virtual”来定义虚函数。</p>\n<ul>\n<li>虚函数不代表函数为不被实现的函数。</li>\n<li>为了允许用基类的指针来调用子类的这个函数。</li>\n<li>定义一个函数为纯虚函数，才代表函数没有被实现。</li>\n<li>纯虚函数是为了实现一个接口，起到一个规范的作用，规范继承这个类的程序员必须实现这个函数。</li>\n</ul>\n<p>虚函数虚在所谓”推迟联编”或者”动态联编”上，一个类函数的调用并不是在编译时刻被确定的，而是在运行时刻被确定的。由于编写代码的时候并不能确定被调用的是基类的函数还是哪个派生类的函数，所以被成为”虚”函数。</p>\n<h1 id=\"Motivation\"><a href=\"#Motivation\" class=\"headerlink\" title=\"Motivation\"></a>Motivation</h1><p>虚函数可以让子类对象在运行时动态地继承和修改父类的成员函数，使得代码更加灵活、可重用，并且可以实现多态性和<a href=\"https://zhida.zhihu.com/search?content_id=227971983&content_type=Article&match_order=1&q=%E6%8A%BD%E8%B1%A1%E7%B1%BB&zhida_source=entity\">抽象类</a>等高级特性。</p>\n<ol>\n<li>通过虚函数，可以实现多态性（Polymorphism），即同一个函数名可以在不同的子类中表现出不同的行为，这样可以提高代码的可重用性和灵活性。</li>\n<li>避免静态绑定，在使用父类指针或引用调用子类对象的成员函数时，如果没有使用虚函数，则会进行静态绑定（Static Binding），即只能调用父类的成员函数，无法调用子类特有的成员函数。</li>\n<li>虚函数的调用是<a href=\"https://zhida.zhihu.com/search?content_id=227971983&content_type=Article&match_order=1&q=%E5%8A%A8%E6%80%81%E7%BB%91%E5%AE%9A&zhida_source=entity\">动态绑定</a>（Dynamic Binding）的，即在运行时根据指针或引用所指向的对象类型来选择调用哪个函数，从而实现动态多态性。</li>\n<li>抽象类是一种不能直接实例化的类，只能被其他类继承并实现其虚函数。通过定义<a href=\"https://zhida.zhihu.com/search?content_id=227971983&content_type=Article&match_order=1&q=%E7%BA%AF%E8%99%9A%E5%87%BD%E6%95%B0&zhida_source=entity\">纯虚函数</a>（Pure Virtual Function），可以使得一个类成为抽象类，强制其子类必须实现该函数。</li>\n</ol>\n<figure class=\"highlight cpp\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br><span class=\"line\">47</span><br><span class=\"line\">48</span><br><span class=\"line\">49</span><br><span class=\"line\">50</span><br><span class=\"line\">51</span><br><span class=\"line\">52</span><br><span class=\"line\">53</span><br><span class=\"line\">54</span><br><span class=\"line\">55</span><br><span class=\"line\">56</span><br><span class=\"line\">57</span><br><span class=\"line\">58</span><br><span class=\"line\">59</span><br><span class=\"line\">60</span><br><span class=\"line\">61</span><br><span class=\"line\">62</span><br><span class=\"line\">63</span><br><span class=\"line\">64</span><br><span class=\"line\">65</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// 形状基类，定义了计算面积和周长的虚函数</span></span><br><span class=\"line\"><span class=\"keyword\">class</span> <span class=\"title class_\">Shape</span> &#123;</span><br><span class=\"line\"><span class=\"keyword\">public</span>:</span><br><span class=\"line\">   <span class=\"comment\">// 计算面积的虚函数，提供默认实</span></span><br><span class=\"line\">   <span class=\"comment\">// 使用virtual关键字，允许派生类重写</span></span><br><span class=\"line\">   <span class=\"function\"><span class=\"keyword\">virtual</span> <span class=\"type\">double</span> <span class=\"title\">calculateArea</span><span class=\"params\">()</span> </span>&#123;</span><br><span class=\"line\">       <span class=\"keyword\">return</span> <span class=\"number\">0.0</span>; <span class=\"comment\">// 基类提供默认实现</span></span><br><span class=\"line\">   &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">   <span class=\"comment\">// 计算周长的虚函数，提供默认实现</span></span><br><span class=\"line\">   <span class=\"comment\">// 使用virtual关键字，允许派生类重写</span></span><br><span class=\"line\">   <span class=\"function\"><span class=\"keyword\">virtual</span> <span class=\"type\">double</span> <span class=\"title\">calculatePerimeter</span><span class=\"params\">()</span> </span>&#123;</span><br><span class=\"line\">       <span class=\"keyword\">return</span> <span class=\"number\">0.0</span>; <span class=\"comment\">// 基类提供默认实现</span></span><br><span class=\"line\">   &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">   <span class=\"comment\">// 虚析构函数，确保派生类对象正确释放</span></span><br><span class=\"line\">   <span class=\"keyword\">virtual</span> ~<span class=\"built_in\">Shape</span>() &#123;&#125; <span class=\"comment\">// 虚析构函数</span></span><br><span class=\"line\">&#125;;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// 矩形类，继承自Shape基类</span></span><br><span class=\"line\"><span class=\"keyword\">class</span> <span class=\"title class_\">Rectangle</span> : <span class=\"keyword\">public</span> Shape &#123;</span><br><span class=\"line\"><span class=\"keyword\">private</span>:</span><br><span class=\"line\">   <span class=\"comment\">// 矩形的私有成员：宽和高</span></span><br><span class=\"line\">   <span class=\"type\">double</span> width;</span><br><span class=\"line\">   <span class=\"type\">double</span> height;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">public</span>:</span><br><span class=\"line\">   <span class=\"comment\">// 构造函数，初始化矩形的宽和高</span></span><br><span class=\"line\">   <span class=\"built_in\">Rectangle</span>(<span class=\"type\">double</span> w, <span class=\"type\">double</span> h) : <span class=\"built_in\">width</span>(w), <span class=\"built_in\">height</span>(h) &#123;&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">   <span class=\"comment\">// 重写基类的calculateArea虚函数</span></span><br><span class=\"line\">   <span class=\"comment\">// override关键字确保正确重写基类虚函数</span></span><br><span class=\"line\">   <span class=\"function\"><span class=\"type\">double</span> <span class=\"title\">calculateArea</span><span class=\"params\">()</span> <span class=\"keyword\">override</span> </span>&#123;</span><br><span class=\"line\">       <span class=\"keyword\">return</span> width * height; <span class=\"comment\">// 矩形面积计算</span></span><br><span class=\"line\">   &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">   <span class=\"comment\">// 重写基类的calculatePerimeter虚函数</span></span><br><span class=\"line\">   <span class=\"function\"><span class=\"type\">double</span> <span class=\"title\">calculatePerimeter</span><span class=\"params\">()</span> <span class=\"keyword\">override</span> </span>&#123;</span><br><span class=\"line\">       <span class=\"keyword\">return</span> <span class=\"number\">2</span> * (width + height); <span class=\"comment\">// 矩形周长计算</span></span><br><span class=\"line\">   &#125;</span><br><span class=\"line\">&#125;;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// 圆形类，继承自Shape基类</span></span><br><span class=\"line\"><span class=\"keyword\">class</span> <span class=\"title class_\">Circle</span> : <span class=\"keyword\">public</span> Shape &#123;</span><br><span class=\"line\"><span class=\"keyword\">private</span>:</span><br><span class=\"line\">   <span class=\"comment\">// 圆形的私有成员：半径</span></span><br><span class=\"line\">   <span class=\"type\">double</span> radius;</span><br><span class=\"line\">   <span class=\"comment\">// 圆周率常量</span></span><br><span class=\"line\">   <span class=\"type\">const</span> <span class=\"type\">double</span> PI = <span class=\"number\">3.14159</span>;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">public</span>:</span><br><span class=\"line\">   <span class=\"comment\">// 构造函数，初始化圆形的半径</span></span><br><span class=\"line\">   <span class=\"built_in\">Circle</span>(<span class=\"type\">double</span> r) : <span class=\"built_in\">radius</span>(r) &#123;&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">   <span class=\"comment\">// 重写基类的calculateArea虚函数</span></span><br><span class=\"line\">   <span class=\"comment\">// override关键字确保正确重写基类虚函数</span></span><br><span class=\"line\">   <span class=\"function\"><span class=\"type\">double</span> <span class=\"title\">calculateArea</span><span class=\"params\">()</span> <span class=\"keyword\">override</span> </span>&#123;</span><br><span class=\"line\">       <span class=\"keyword\">return</span> PI * radius * radius; <span class=\"comment\">// 圆形面积计算</span></span><br><span class=\"line\">   &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">   <span class=\"comment\">// 重写基类的calculatePerimeter虚函数</span></span><br><span class=\"line\">   <span class=\"function\"><span class=\"type\">double</span> <span class=\"title\">calculatePerimeter</span><span class=\"params\">()</span> <span class=\"keyword\">override</span> </span>&#123;</span><br><span class=\"line\">       <span class=\"keyword\">return</span> <span class=\"number\">2</span> * PI * radius; <span class=\"comment\">// 圆形周长计算</span></span><br><span class=\"line\">   &#125;</span><br><span class=\"line\">&#125;;</span><br></pre></td></tr></table></figure>\n\n<h1 id=\"Concept\"><a href=\"#Concept\" class=\"headerlink\" title=\"Concept\"></a>Concept</h1><p><strong>虚函数只能借助于指针或者引用来达到多态的效果。</strong></p>\n<blockquote>\n<p><strong>多态</strong>的本质是“同一个函数调用，能够根据不同对象表现出不同的行为</p>\n</blockquote>\n<h1 id=\"Method\"><a href=\"#Method\" class=\"headerlink\" title=\"Method\"></a>Method</h1><p><img src=\"https://tk-pichost-1325224430.cos.ap-chengdu.myqcloud.com/blog/1747056760477QGSmb9FB5obI4CxbD3RcFRIynCe.png\" alt=\"1747056760477QGSmb9FB5obI4CxbD3RcFRIynCe.png\"></p>\n<h1 id=\"知识点\"><a href=\"#知识点\" class=\"headerlink\" title=\"知识点\"></a>知识点</h1><h2 id=\"虚函数声明\"><a href=\"#虚函数声明\" class=\"headerlink\" title=\"虚函数声明\"></a>虚函数声明</h2><p>从简单的例子开始</p>\n<figure class=\"highlight cpp\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">class</span> <span class=\"title class_\">Animal</span></span><br><span class=\"line\">&#123;</span><br><span class=\"line\"><span class=\"keyword\">public</span>:</span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">virtual</span> <span class=\"type\">void</span> <span class=\"title\">shout</span><span class=\"params\">()</span></span></span><br><span class=\"line\"><span class=\"function\">    </span>&#123;</span><br><span class=\"line\">        cout &lt;&lt; <span class=\"string\">&quot;动物叫了一声\\n&quot;</span>;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">class</span> <span class=\"title class_\">Cat</span> : <span class=\"keyword\">public</span> Animal</span><br><span class=\"line\">&#123;</span><br><span class=\"line\"><span class=\"keyword\">public</span>:</span><br><span class=\"line\">    <span class=\"function\"><span class=\"type\">void</span> <span class=\"title\">shout</span><span class=\"params\">()</span> <span class=\"keyword\">override</span></span></span><br><span class=\"line\"><span class=\"function\">    </span>&#123;</span><br><span class=\"line\">        cout &lt;&lt; <span class=\"string\">&quot;喵喵喵\\n&quot;</span>;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;;</span><br></pre></td></tr></table></figure>\n\n<p><strong>解释：</strong></p>\n<ul>\n<li>代码通过 <code>Animal</code> 基类定义了一个虚函数 <code>shout()</code>，为派生类提供了一个默认实现。</li>\n<li><code>Cat</code> 类继承自 <code>Animal</code>，使用 <code>override</code> 关键字重写了 <code>shout()</code> 方法，展示了虚函数允许派生类提供自己的特定实现。</li>\n<li>这个示例体现了 C++ 多态性的基本原理：基类定义一个通用接口，派生类可以根据自身特性灵活地实现具体行为。</li>\n</ul>\n<blockquote>\n<p>需要注意的是，在子类中重写虚函数时，其访问权限不能更严格（即不能由 public 变为 private 或 protected），否则编译器会报错。</p>\n</blockquote>\n<h2 id=\"纯虚函数与抽象类\"><a href=\"#纯虚函数与抽象类\" class=\"headerlink\" title=\"纯虚函数与抽象类\"></a>纯虚函数与抽象类</h2><h3 id=\"纯虚函数\"><a href=\"#纯虚函数\" class=\"headerlink\" title=\"纯虚函数\"></a>纯虚函数</h3><p>纯虚函数是指在基类中定义的没有实现的虚函数。使用纯虚函数可以使该函数只有函数原型，而没有具体的实现。注：这里的“&#x3D;0”表示该函数为纯虚函数。</p>\n<p>纯虚函数的作用是让子类必须实现该函数，并且不能直接创建该类对象（即该类为抽象类）。</p>\n<figure class=\"highlight cpp\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">virtual</span> <span class=\"type\">void</span> <span class=\"title\">func</span><span class=\"params\">()</span> </span>= <span class=\"number\">0</span>;</span><br></pre></td></tr></table></figure>\n\n<figure class=\"highlight cpp\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">class</span> <span class=\"title class_\">Shape</span> &#123;</span><br><span class=\"line\"><span class=\"keyword\">public</span>:</span><br><span class=\"line\">   <span class=\"comment\">// 纯虚函数，没有默认实现</span></span><br><span class=\"line\">   <span class=\"function\"><span class=\"keyword\">virtual</span> <span class=\"type\">double</span> <span class=\"title\">calculateArea</span><span class=\"params\">()</span> </span>= <span class=\"number\">0</span>;</span><br><span class=\"line\">   </span><br><span class=\"line\">   <span class=\"comment\">// 包含纯虚函数的类成为抽象类</span></span><br><span class=\"line\">   <span class=\"function\"><span class=\"keyword\">virtual</span> <span class=\"type\">void</span> <span class=\"title\">draw</span><span class=\"params\">()</span> </span>= <span class=\"number\">0</span>;</span><br><span class=\"line\">&#125;;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">class</span> <span class=\"title class_\">Rectangle</span> : <span class=\"keyword\">public</span> Shape &#123;</span><br><span class=\"line\"><span class=\"keyword\">public</span>:</span><br><span class=\"line\">   <span class=\"comment\">// 必须实现基类的纯虚函数</span></span><br><span class=\"line\">   <span class=\"function\"><span class=\"type\">double</span> <span class=\"title\">calculateArea</span><span class=\"params\">()</span> <span class=\"keyword\">override</span> </span>&#123;</span><br><span class=\"line\">       <span class=\"keyword\">return</span> width * height;</span><br><span class=\"line\">   &#125;</span><br><span class=\"line\">   </span><br><span class=\"line\">   <span class=\"function\"><span class=\"type\">void</span> <span class=\"title\">draw</span><span class=\"params\">()</span> <span class=\"keyword\">override</span> </span>&#123;</span><br><span class=\"line\">       <span class=\"comment\">// 绘制矩形的具体实现</span></span><br><span class=\"line\">   &#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">private</span>:</span><br><span class=\"line\">   <span class=\"type\">double</span> width;</span><br><span class=\"line\">   <span class=\"type\">double</span> height;</span><br><span class=\"line\">&#125;;</span><br></pre></td></tr></table></figure>\n\n<p><strong>解释：</strong></p>\n<ul>\n<li>代码通过 <code>Shape</code> 基类定义了两个纯虚函数 <code>calculateArea()</code> 和 <code>draw()</code>，使 <code>Shape</code> 成为一个抽象类。</li>\n<li>纯虚函数（<code>= 0</code>）没有默认实现，强制派生类必须提供具体实现。</li>\n<li><code>Rectangle</code> 类继承自 <code>Shape</code>，必须实现所有纯虚函数，否则仍将是抽象类。</li>\n<li>这个示例展示了纯虚函数作为接口的设计模式，确保派生类提供必要的具体行为。</li>\n</ul>\n<h3 id=\"抽象类\"><a href=\"#抽象类\" class=\"headerlink\" title=\"抽象类\"></a>抽象类</h3><p>抽象类是包含纯虚函数的类，它们不能被实例化，只能被继承。抽象类只能用作其他类的基类。如果一个类继承了抽象类，则必须实现所有的纯虚函数，否则该类也会成为抽象类。</p>\n<figure class=\"highlight cpp\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">class</span> <span class=\"title class_\">Shape</span></span><br><span class=\"line\">&#123;</span><br><span class=\"line\"><span class=\"keyword\">public</span>:</span><br><span class=\"line\">_    <span class=\"comment\">// 纯虚函数_</span></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">virtual</span> <span class=\"type\">double</span> <span class=\"title\">getArea</span><span class=\"params\">()</span> </span>= <span class=\"number\">0</span>;</span><br><span class=\"line\">&#125;;</span><br><span class=\"line\"></span><br><span class=\"line\">_<span class=\"comment\">// 继承自抽象类Shape_</span></span><br><span class=\"line\"><span class=\"keyword\">class</span> <span class=\"title class_\">Rectangle</span> : <span class=\"keyword\">public</span> Shape</span><br><span class=\"line\">&#123;</span><br><span class=\"line\"><span class=\"keyword\">public</span>:</span><br><span class=\"line\">    <span class=\"type\">double</span> **width**;</span><br><span class=\"line\">    <span class=\"type\">double</span> **height**;</span><br><span class=\"line\">    <span class=\"function\"><span class=\"type\">double</span> <span class=\"title\">getArea</span><span class=\"params\">()</span> </span>&#123; <span class=\"keyword\">return</span> **width** * **height**; &#125;</span><br><span class=\"line\">&#125;;</span><br><span class=\"line\"></span><br><span class=\"line\">_<span class=\"comment\">// 继承自抽象类Shape_</span></span><br><span class=\"line\"><span class=\"keyword\">class</span> <span class=\"title class_\">Circle</span> : <span class=\"keyword\">public</span> Shape</span><br><span class=\"line\">&#123;</span><br><span class=\"line\"><span class=\"keyword\">public</span>:</span><br><span class=\"line\">    <span class=\"type\">double</span> **radius**;</span><br><span class=\"line\">    <span class=\"function\"><span class=\"type\">double</span> <span class=\"title\">getArea</span><span class=\"params\">()</span> </span>&#123; <span class=\"keyword\">return</span> <span class=\"number\">3.14</span> * **radius** * **radius**; &#125;</span><br><span class=\"line\">&#125;;</span><br></pre></td></tr></table></figure>\n\n<p>Shape 为抽象类，其中包含纯虚函数 getArea()，Rectangle 和 Circle 均继承自 Shape，并且实现了 getArea()函数的具体内容。</p>\n<h3 id=\"多重继承中的虚函数\"><a href=\"#多重继承中的虚函数\" class=\"headerlink\" title=\"多重继承中的虚函数\"></a>多重继承中的虚函数</h3><p>在多重继承中，如果一个类同时继承了多个基类，而这些基类中都有同名的虚函数，那么子类必须对这些虚函数进行重写并实现。此时，需要使用作用域限定符来指明重写的是哪个基类的虚函数。</p>\n<figure class=\"highlight cpp\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">class</span> <span class=\"title class_\">Base1</span></span><br><span class=\"line\">&#123;</span><br><span class=\"line\"><span class=\"keyword\">public</span>:</span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">virtual</span> <span class=\"type\">void</span> <span class=\"title\">func</span><span class=\"params\">()</span> </span>&#123; cout &lt;&lt; <span class=\"string\">&quot;Base1::func()&quot;</span> &lt;&lt; endl; &#125;</span><br><span class=\"line\">&#125;;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">class</span> <span class=\"title class_\">Base2</span></span><br><span class=\"line\">&#123;</span><br><span class=\"line\"><span class=\"keyword\">public</span>:</span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">virtual</span> <span class=\"type\">void</span> <span class=\"title\">func</span><span class=\"params\">()</span> </span>&#123; cout &lt;&lt; <span class=\"string\">&quot;Base2::func()&quot;</span> &lt;&lt; endl; &#125;</span><br><span class=\"line\">&#125;;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">class</span> <span class=\"title class_\">Derived</span> : <span class=\"keyword\">public</span> Base1, <span class=\"keyword\">public</span> Base2</span><br><span class=\"line\">&#123;</span><br><span class=\"line\"><span class=\"keyword\">public</span>:</span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">virtual</span> <span class=\"type\">void</span> <span class=\"title\">func</span><span class=\"params\">()</span></span></span><br><span class=\"line\"><span class=\"function\">    </span>&#123;</span><br><span class=\"line\">        Base1::<span class=\"built_in\">func</span>();</span><br><span class=\"line\">        Base2::<span class=\"built_in\">func</span>();</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;;</span><br></pre></td></tr></table></figure>\n\n<p>派生类 Derived 同时继承了 Base1 和 Base2，这两个基类中都有名为 func 的虚函数。在 Derived 中，我们通过使用作用域限定符 Base1::和 Base2::，分别调用了两个基类中的虚函数。</p>\n<h3 id=\"总结\"><a href=\"#总结\" class=\"headerlink\" title=\"总结\"></a><strong>总结</strong></h3><ul>\n<li><p>优点：</p>\n<ul>\n<li>实现多态性：通过虚函数，可以在不知道对象具体类型的情况下，调用特定对象的方法。</li>\n<li>代码灵活性：虚函数允许子类覆盖父类的方法，并且不需要改变基类的代码。</li>\n<li>代码可维护性：虚函数使得代码易于维护和扩展，因为子类可以通过重载虚函数来实现自己的行为。</li>\n</ul>\n</li>\n<li><p>缺点：</p>\n<ul>\n<li>额外的开销：虚函数需要额外的开销来支持运行时的动态绑定和查找虚表。这可能会影响程序的性能。</li>\n<li>可能会引起混淆：由于虚函数的存在，同名的函数可能会被不同的类定义。如果没有正确的使用虚函数，可能会导致混淆和错误的结果。</li>\n<li>不适合于小型应用：虚函数对于小型应用来说可能过于复杂和冗余。在这种情况下，使用虚函数可能会导致更多的开销而不是提高效率。</li>\n</ul>\n</li>\n</ul>\n<h1 id=\"Example\"><a href=\"#Example\" class=\"headerlink\" title=\"Example\"></a>Example</h1><figure class=\"highlight cpp\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br><span class=\"line\">47</span><br><span class=\"line\">48</span><br><span class=\"line\">49</span><br><span class=\"line\">50</span><br><span class=\"line\">51</span><br><span class=\"line\">52</span><br><span class=\"line\">53</span><br><span class=\"line\">54</span><br><span class=\"line\">55</span><br><span class=\"line\">56</span><br><span class=\"line\">57</span><br><span class=\"line\">58</span><br><span class=\"line\">59</span><br><span class=\"line\">60</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">#<span class=\"keyword\">include</span> <span class=\"string\">&lt;iostream&gt;</span></span></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"keyword\">include</span> <span class=\"string\">&lt;string&gt;</span></span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// 基类Entity，定义了一个虚函数GetName()</span></span><br><span class=\"line\"><span class=\"keyword\">class</span> <span class=\"title class_\">Entity</span> &#123;</span><br><span class=\"line\"><span class=\"keyword\">public</span>:</span><br><span class=\"line\">   <span class=\"comment\">// 虚函数，返回一个默认的实体名称</span></span><br><span class=\"line\">   <span class=\"comment\">// 使用virtual关键字，允许派生类重写</span></span><br><span class=\"line\">   <span class=\"function\"><span class=\"keyword\">virtual</span> std::string <span class=\"title\">GetName</span><span class=\"params\">()</span> </span>&#123; <span class=\"keyword\">return</span> <span class=\"string\">&quot;Entity&quot;</span>; &#125;</span><br><span class=\"line\">&#125;;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// 派生类Player，继承自Entity</span></span><br><span class=\"line\"><span class=\"keyword\">class</span> <span class=\"title class_\">Player</span> : <span class=\"keyword\">public</span> Entity &#123;</span><br><span class=\"line\"><span class=\"keyword\">private</span>:</span><br><span class=\"line\">   <span class=\"comment\">// 私有成员，存储玩家名称</span></span><br><span class=\"line\">   std::string m_Name;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">public</span>:</span><br><span class=\"line\">   <span class=\"comment\">// 构造函数，使用传入的名称初始化玩家</span></span><br><span class=\"line\">   <span class=\"built_in\">Player</span>(<span class=\"type\">const</span> std::string&amp; name) :<span class=\"built_in\">m_Name</span>(name) &#123;&#125;;</span><br><span class=\"line\"></span><br><span class=\"line\">   <span class=\"comment\">// 重写基类的GetName()虚函数</span></span><br><span class=\"line\">   <span class=\"comment\">// override关键字确保正确重写基类虚函数</span></span><br><span class=\"line\">   <span class=\"function\">std::string <span class=\"title\">GetName</span><span class=\"params\">()</span> <span class=\"keyword\">override</span> </span>&#123; <span class=\"keyword\">return</span> m_Name; &#125;;</span><br><span class=\"line\"></span><br><span class=\"line\">   <span class=\"comment\">// 设置玩家名称的成员函数</span></span><br><span class=\"line\">   <span class=\"function\"><span class=\"type\">void</span> <span class=\"title\">SetName</span><span class=\"params\">(std::string name)</span> </span>&#123; m_Name = name; &#125;;</span><br><span class=\"line\">&#125;;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// 打印实体名称的函数</span></span><br><span class=\"line\"><span class=\"comment\">// 接受一个Entity指针作为参数，体现了多态性</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"type\">void</span> <span class=\"title\">PrintName</span><span class=\"params\">(Entity* entity)</span> </span>&#123;</span><br><span class=\"line\">   <span class=\"comment\">// 调用虚函数GetName()，实际执行的是对象的具体实现</span></span><br><span class=\"line\">   std::cout &lt;&lt; entity-&gt;<span class=\"built_in\">GetName</span>() &lt;&lt; std::endl;</span><br><span class=\"line\">&#125;;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"type\">int</span> <span class=\"title\">main</span><span class=\"params\">()</span> </span>&#123;</span><br><span class=\"line\">   <span class=\"comment\">// 创建一个基类Entity对象的指针</span></span><br><span class=\"line\">   Entity* e = <span class=\"keyword\">new</span> <span class=\"built_in\">Entity</span>();</span><br><span class=\"line\">   <span class=\"comment\">// 调用PrintName()，将打印&quot;Entity&quot;</span></span><br><span class=\"line\">   <span class=\"built_in\">PrintName</span>(e);</span><br><span class=\"line\"></span><br><span class=\"line\">   <span class=\"comment\">// 创建一个Player对象，名称为&quot;tanke&quot;</span></span><br><span class=\"line\">   Player* p = <span class=\"keyword\">new</span> <span class=\"built_in\">Player</span>(<span class=\"string\">&quot;tanke&quot;</span>);</span><br><span class=\"line\">   <span class=\"comment\">// 调用PrintName()，将打印&quot;tanke&quot;</span></span><br><span class=\"line\">   <span class=\"built_in\">PrintName</span>(p);</span><br><span class=\"line\"></span><br><span class=\"line\">   <span class=\"comment\">// 修改Player对象的名称为&quot;wangjie&quot;</span></span><br><span class=\"line\">   p-&gt;<span class=\"built_in\">SetName</span>(<span class=\"string\">&quot;wangjie&quot;</span>);</span><br><span class=\"line\"></span><br><span class=\"line\">   <span class=\"comment\">// 将Player指针赋值给基类指针，体现了多态性</span></span><br><span class=\"line\">   Entity* e1 = p;</span><br><span class=\"line\">   <span class=\"comment\">// 调用PrintName()，将打印&quot;wangjie&quot;</span></span><br><span class=\"line\">   <span class=\"built_in\">PrintName</span>(p);</span><br><span class=\"line\"></span><br><span class=\"line\">   <span class=\"comment\">// 等待用户输入，保持窗口打开</span></span><br><span class=\"line\">   std::cin.<span class=\"built_in\">get</span>();</span><br><span class=\"line\"></span><br><span class=\"line\">   <span class=\"keyword\">return</span> <span class=\"number\">0</span>;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p><strong>解释：</strong></p>\n<ul>\n<li>代码通过 <code>Entity</code> 基类定义了一个虚函数 <code>GetName()</code>，为派生类提供了一个默认实现。</li>\n<li><code>Player</code> 类继承自 <code>Entity</code>，并使用 <code>override</code> 关键字重写了 <code>GetName()</code> 方法。</li>\n<li><code>PrintName()</code> 函数接受一个 <code>Entity</code> 指针，展示了 C++ 多态性的关键特征 - 可以通过基类指针调用派生类的具体实现。</li>\n</ul>\n<p><img src=\"https://tk-pichost-1325224430.cos.ap-chengdu.myqcloud.com/blog/1747056796676Ue1zbj8hco94t9xuRBRcd0jWnXg.png\" alt=\"1747056796676Ue1zbj8hco94t9xuRBRcd0jWnXg.png\"></p>\n<h1 id=\"思考\"><a href=\"#思考\" class=\"headerlink\" title=\"思考\"></a>思考</h1><ol>\n<li>虚函数应用于继承层次结构中的多态性，即通过基类指针或引用调用派生类对象的成员函数。</li>\n<li>可以将虚函数作为接口定义，让不同的派生类实现自己的版本，以满足各自的需求。</li>\n<li>避免在构造函数和析构函数中调用虚函数，因为此时对象还未完全构造或已经被销毁。</li>\n<li>虚函数的声明应该在公共部分（例如基类），而不是在私有部分（例如派生类）中声明。</li>\n<li>将虚函数的实现定义为 inline 可以提高程序的执行效率。</li>\n<li>在使用纯虚函数时，需要给出其具体实现。可以在派生类中实现，也可以在基类中实现。</li>\n<li>避免过度使用虚函数，因为虚函数会增加程序的开销。在没有必要的情况下，可以使用普通成员函数代替虚函数。</li>\n</ol>\n","excerpt":"","more":"<p>2025-05-12-虚函数</p>\n<blockquote>\n<h1 id=\"参考资源\"><a href=\"#参考资源\" class=\"headerlink\" title=\"参考资源\"></a>参考资源</h1><p><a href=\"https://zhuanlan.zhihu.com/p/629281871\">对 C++ 虚函数不了解？看完这篇文章掌握虚函数的原理和作用</a></p>\n<p><a href=\"https://www.bilibili.com/video/BV1QV4y1U73z/\">4-虚函数_哔哩哔哩_bilibili</a></p>\n<p><a href=\"https://www.runoob.com/w3cnote/cpp-virtual-functions.html\">C++ 虚函数和纯虚函数的区别</a></p>\n<p><a href=\"https://blog.csdn.net/i_chaoren/article/details/77281785\">C++ 多态–虚函数 virtual 及 override_虚函数 override-CSDN 博客</a></p>\n<p><a href=\"https://zhuanlan.zhihu.com/p/54145222\">C++ 虚函数</a></p>\n</blockquote>\n<p>虚函数是在父类中定义的一种特殊类型的函数，允许子类重写该函数以适应其自身需求。虚函数的调用取决于对象的实际类型，而不是指针或引用类型。通过将函数声明为虚函数，可以使继承层次结构中的每个子类都能够使用其自己的实现，从而提高代码的可扩展性和灵活性。在 C++ 中，使用关键字”virtual”来定义虚函数。</p>\n<ul>\n<li>虚函数不代表函数为不被实现的函数。</li>\n<li>为了允许用基类的指针来调用子类的这个函数。</li>\n<li>定义一个函数为纯虚函数，才代表函数没有被实现。</li>\n<li>纯虚函数是为了实现一个接口，起到一个规范的作用，规范继承这个类的程序员必须实现这个函数。</li>\n</ul>\n<p>虚函数虚在所谓”推迟联编”或者”动态联编”上，一个类函数的调用并不是在编译时刻被确定的，而是在运行时刻被确定的。由于编写代码的时候并不能确定被调用的是基类的函数还是哪个派生类的函数，所以被成为”虚”函数。</p>\n<h1 id=\"Motivation\"><a href=\"#Motivation\" class=\"headerlink\" title=\"Motivation\"></a>Motivation</h1><p>虚函数可以让子类对象在运行时动态地继承和修改父类的成员函数，使得代码更加灵活、可重用，并且可以实现多态性和<a href=\"https://zhida.zhihu.com/search?content_id=227971983&content_type=Article&match_order=1&q=%E6%8A%BD%E8%B1%A1%E7%B1%BB&zhida_source=entity\">抽象类</a>等高级特性。</p>\n<ol>\n<li>通过虚函数，可以实现多态性（Polymorphism），即同一个函数名可以在不同的子类中表现出不同的行为，这样可以提高代码的可重用性和灵活性。</li>\n<li>避免静态绑定，在使用父类指针或引用调用子类对象的成员函数时，如果没有使用虚函数，则会进行静态绑定（Static Binding），即只能调用父类的成员函数，无法调用子类特有的成员函数。</li>\n<li>虚函数的调用是<a href=\"https://zhida.zhihu.com/search?content_id=227971983&content_type=Article&match_order=1&q=%E5%8A%A8%E6%80%81%E7%BB%91%E5%AE%9A&zhida_source=entity\">动态绑定</a>（Dynamic Binding）的，即在运行时根据指针或引用所指向的对象类型来选择调用哪个函数，从而实现动态多态性。</li>\n<li>抽象类是一种不能直接实例化的类，只能被其他类继承并实现其虚函数。通过定义<a href=\"https://zhida.zhihu.com/search?content_id=227971983&content_type=Article&match_order=1&q=%E7%BA%AF%E8%99%9A%E5%87%BD%E6%95%B0&zhida_source=entity\">纯虚函数</a>（Pure Virtual Function），可以使得一个类成为抽象类，强制其子类必须实现该函数。</li>\n</ol>\n<figure class=\"highlight cpp\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br><span class=\"line\">47</span><br><span class=\"line\">48</span><br><span class=\"line\">49</span><br><span class=\"line\">50</span><br><span class=\"line\">51</span><br><span class=\"line\">52</span><br><span class=\"line\">53</span><br><span class=\"line\">54</span><br><span class=\"line\">55</span><br><span class=\"line\">56</span><br><span class=\"line\">57</span><br><span class=\"line\">58</span><br><span class=\"line\">59</span><br><span class=\"line\">60</span><br><span class=\"line\">61</span><br><span class=\"line\">62</span><br><span class=\"line\">63</span><br><span class=\"line\">64</span><br><span class=\"line\">65</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// 形状基类，定义了计算面积和周长的虚函数</span></span><br><span class=\"line\"><span class=\"keyword\">class</span> <span class=\"title class_\">Shape</span> &#123;</span><br><span class=\"line\"><span class=\"keyword\">public</span>:</span><br><span class=\"line\">   <span class=\"comment\">// 计算面积的虚函数，提供默认实</span></span><br><span class=\"line\">   <span class=\"comment\">// 使用virtual关键字，允许派生类重写</span></span><br><span class=\"line\">   <span class=\"function\"><span class=\"keyword\">virtual</span> <span class=\"type\">double</span> <span class=\"title\">calculateArea</span><span class=\"params\">()</span> </span>&#123;</span><br><span class=\"line\">       <span class=\"keyword\">return</span> <span class=\"number\">0.0</span>; <span class=\"comment\">// 基类提供默认实现</span></span><br><span class=\"line\">   &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">   <span class=\"comment\">// 计算周长的虚函数，提供默认实现</span></span><br><span class=\"line\">   <span class=\"comment\">// 使用virtual关键字，允许派生类重写</span></span><br><span class=\"line\">   <span class=\"function\"><span class=\"keyword\">virtual</span> <span class=\"type\">double</span> <span class=\"title\">calculatePerimeter</span><span class=\"params\">()</span> </span>&#123;</span><br><span class=\"line\">       <span class=\"keyword\">return</span> <span class=\"number\">0.0</span>; <span class=\"comment\">// 基类提供默认实现</span></span><br><span class=\"line\">   &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">   <span class=\"comment\">// 虚析构函数，确保派生类对象正确释放</span></span><br><span class=\"line\">   <span class=\"keyword\">virtual</span> ~<span class=\"built_in\">Shape</span>() &#123;&#125; <span class=\"comment\">// 虚析构函数</span></span><br><span class=\"line\">&#125;;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// 矩形类，继承自Shape基类</span></span><br><span class=\"line\"><span class=\"keyword\">class</span> <span class=\"title class_\">Rectangle</span> : <span class=\"keyword\">public</span> Shape &#123;</span><br><span class=\"line\"><span class=\"keyword\">private</span>:</span><br><span class=\"line\">   <span class=\"comment\">// 矩形的私有成员：宽和高</span></span><br><span class=\"line\">   <span class=\"type\">double</span> width;</span><br><span class=\"line\">   <span class=\"type\">double</span> height;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">public</span>:</span><br><span class=\"line\">   <span class=\"comment\">// 构造函数，初始化矩形的宽和高</span></span><br><span class=\"line\">   <span class=\"built_in\">Rectangle</span>(<span class=\"type\">double</span> w, <span class=\"type\">double</span> h) : <span class=\"built_in\">width</span>(w), <span class=\"built_in\">height</span>(h) &#123;&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">   <span class=\"comment\">// 重写基类的calculateArea虚函数</span></span><br><span class=\"line\">   <span class=\"comment\">// override关键字确保正确重写基类虚函数</span></span><br><span class=\"line\">   <span class=\"function\"><span class=\"type\">double</span> <span class=\"title\">calculateArea</span><span class=\"params\">()</span> <span class=\"keyword\">override</span> </span>&#123;</span><br><span class=\"line\">       <span class=\"keyword\">return</span> width * height; <span class=\"comment\">// 矩形面积计算</span></span><br><span class=\"line\">   &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">   <span class=\"comment\">// 重写基类的calculatePerimeter虚函数</span></span><br><span class=\"line\">   <span class=\"function\"><span class=\"type\">double</span> <span class=\"title\">calculatePerimeter</span><span class=\"params\">()</span> <span class=\"keyword\">override</span> </span>&#123;</span><br><span class=\"line\">       <span class=\"keyword\">return</span> <span class=\"number\">2</span> * (width + height); <span class=\"comment\">// 矩形周长计算</span></span><br><span class=\"line\">   &#125;</span><br><span class=\"line\">&#125;;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// 圆形类，继承自Shape基类</span></span><br><span class=\"line\"><span class=\"keyword\">class</span> <span class=\"title class_\">Circle</span> : <span class=\"keyword\">public</span> Shape &#123;</span><br><span class=\"line\"><span class=\"keyword\">private</span>:</span><br><span class=\"line\">   <span class=\"comment\">// 圆形的私有成员：半径</span></span><br><span class=\"line\">   <span class=\"type\">double</span> radius;</span><br><span class=\"line\">   <span class=\"comment\">// 圆周率常量</span></span><br><span class=\"line\">   <span class=\"type\">const</span> <span class=\"type\">double</span> PI = <span class=\"number\">3.14159</span>;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">public</span>:</span><br><span class=\"line\">   <span class=\"comment\">// 构造函数，初始化圆形的半径</span></span><br><span class=\"line\">   <span class=\"built_in\">Circle</span>(<span class=\"type\">double</span> r) : <span class=\"built_in\">radius</span>(r) &#123;&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">   <span class=\"comment\">// 重写基类的calculateArea虚函数</span></span><br><span class=\"line\">   <span class=\"comment\">// override关键字确保正确重写基类虚函数</span></span><br><span class=\"line\">   <span class=\"function\"><span class=\"type\">double</span> <span class=\"title\">calculateArea</span><span class=\"params\">()</span> <span class=\"keyword\">override</span> </span>&#123;</span><br><span class=\"line\">       <span class=\"keyword\">return</span> PI * radius * radius; <span class=\"comment\">// 圆形面积计算</span></span><br><span class=\"line\">   &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">   <span class=\"comment\">// 重写基类的calculatePerimeter虚函数</span></span><br><span class=\"line\">   <span class=\"function\"><span class=\"type\">double</span> <span class=\"title\">calculatePerimeter</span><span class=\"params\">()</span> <span class=\"keyword\">override</span> </span>&#123;</span><br><span class=\"line\">       <span class=\"keyword\">return</span> <span class=\"number\">2</span> * PI * radius; <span class=\"comment\">// 圆形周长计算</span></span><br><span class=\"line\">   &#125;</span><br><span class=\"line\">&#125;;</span><br></pre></td></tr></table></figure>\n\n<h1 id=\"Concept\"><a href=\"#Concept\" class=\"headerlink\" title=\"Concept\"></a>Concept</h1><p><strong>虚函数只能借助于指针或者引用来达到多态的效果。</strong></p>\n<blockquote>\n<p><strong>多态</strong>的本质是“同一个函数调用，能够根据不同对象表现出不同的行为</p>\n</blockquote>\n<h1 id=\"Method\"><a href=\"#Method\" class=\"headerlink\" title=\"Method\"></a>Method</h1><p><img src=\"https://tk-pichost-1325224430.cos.ap-chengdu.myqcloud.com/blog/1747056760477QGSmb9FB5obI4CxbD3RcFRIynCe.png\" alt=\"1747056760477QGSmb9FB5obI4CxbD3RcFRIynCe.png\"></p>\n<h1 id=\"知识点\"><a href=\"#知识点\" class=\"headerlink\" title=\"知识点\"></a>知识点</h1><h2 id=\"虚函数声明\"><a href=\"#虚函数声明\" class=\"headerlink\" title=\"虚函数声明\"></a>虚函数声明</h2><p>从简单的例子开始</p>\n<figure class=\"highlight cpp\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">class</span> <span class=\"title class_\">Animal</span></span><br><span class=\"line\">&#123;</span><br><span class=\"line\"><span class=\"keyword\">public</span>:</span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">virtual</span> <span class=\"type\">void</span> <span class=\"title\">shout</span><span class=\"params\">()</span></span></span><br><span class=\"line\"><span class=\"function\">    </span>&#123;</span><br><span class=\"line\">        cout &lt;&lt; <span class=\"string\">&quot;动物叫了一声\\n&quot;</span>;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">class</span> <span class=\"title class_\">Cat</span> : <span class=\"keyword\">public</span> Animal</span><br><span class=\"line\">&#123;</span><br><span class=\"line\"><span class=\"keyword\">public</span>:</span><br><span class=\"line\">    <span class=\"function\"><span class=\"type\">void</span> <span class=\"title\">shout</span><span class=\"params\">()</span> <span class=\"keyword\">override</span></span></span><br><span class=\"line\"><span class=\"function\">    </span>&#123;</span><br><span class=\"line\">        cout &lt;&lt; <span class=\"string\">&quot;喵喵喵\\n&quot;</span>;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;;</span><br></pre></td></tr></table></figure>\n\n<p><strong>解释：</strong></p>\n<ul>\n<li>代码通过 <code>Animal</code> 基类定义了一个虚函数 <code>shout()</code>，为派生类提供了一个默认实现。</li>\n<li><code>Cat</code> 类继承自 <code>Animal</code>，使用 <code>override</code> 关键字重写了 <code>shout()</code> 方法，展示了虚函数允许派生类提供自己的特定实现。</li>\n<li>这个示例体现了 C++ 多态性的基本原理：基类定义一个通用接口，派生类可以根据自身特性灵活地实现具体行为。</li>\n</ul>\n<blockquote>\n<p>需要注意的是，在子类中重写虚函数时，其访问权限不能更严格（即不能由 public 变为 private 或 protected），否则编译器会报错。</p>\n</blockquote>\n<h2 id=\"纯虚函数与抽象类\"><a href=\"#纯虚函数与抽象类\" class=\"headerlink\" title=\"纯虚函数与抽象类\"></a>纯虚函数与抽象类</h2><h3 id=\"纯虚函数\"><a href=\"#纯虚函数\" class=\"headerlink\" title=\"纯虚函数\"></a>纯虚函数</h3><p>纯虚函数是指在基类中定义的没有实现的虚函数。使用纯虚函数可以使该函数只有函数原型，而没有具体的实现。注：这里的“&#x3D;0”表示该函数为纯虚函数。</p>\n<p>纯虚函数的作用是让子类必须实现该函数，并且不能直接创建该类对象（即该类为抽象类）。</p>\n<figure class=\"highlight cpp\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">virtual</span> <span class=\"type\">void</span> <span class=\"title\">func</span><span class=\"params\">()</span> </span>= <span class=\"number\">0</span>;</span><br></pre></td></tr></table></figure>\n\n<figure class=\"highlight cpp\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">class</span> <span class=\"title class_\">Shape</span> &#123;</span><br><span class=\"line\"><span class=\"keyword\">public</span>:</span><br><span class=\"line\">   <span class=\"comment\">// 纯虚函数，没有默认实现</span></span><br><span class=\"line\">   <span class=\"function\"><span class=\"keyword\">virtual</span> <span class=\"type\">double</span> <span class=\"title\">calculateArea</span><span class=\"params\">()</span> </span>= <span class=\"number\">0</span>;</span><br><span class=\"line\">   </span><br><span class=\"line\">   <span class=\"comment\">// 包含纯虚函数的类成为抽象类</span></span><br><span class=\"line\">   <span class=\"function\"><span class=\"keyword\">virtual</span> <span class=\"type\">void</span> <span class=\"title\">draw</span><span class=\"params\">()</span> </span>= <span class=\"number\">0</span>;</span><br><span class=\"line\">&#125;;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">class</span> <span class=\"title class_\">Rectangle</span> : <span class=\"keyword\">public</span> Shape &#123;</span><br><span class=\"line\"><span class=\"keyword\">public</span>:</span><br><span class=\"line\">   <span class=\"comment\">// 必须实现基类的纯虚函数</span></span><br><span class=\"line\">   <span class=\"function\"><span class=\"type\">double</span> <span class=\"title\">calculateArea</span><span class=\"params\">()</span> <span class=\"keyword\">override</span> </span>&#123;</span><br><span class=\"line\">       <span class=\"keyword\">return</span> width * height;</span><br><span class=\"line\">   &#125;</span><br><span class=\"line\">   </span><br><span class=\"line\">   <span class=\"function\"><span class=\"type\">void</span> <span class=\"title\">draw</span><span class=\"params\">()</span> <span class=\"keyword\">override</span> </span>&#123;</span><br><span class=\"line\">       <span class=\"comment\">// 绘制矩形的具体实现</span></span><br><span class=\"line\">   &#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">private</span>:</span><br><span class=\"line\">   <span class=\"type\">double</span> width;</span><br><span class=\"line\">   <span class=\"type\">double</span> height;</span><br><span class=\"line\">&#125;;</span><br></pre></td></tr></table></figure>\n\n<p><strong>解释：</strong></p>\n<ul>\n<li>代码通过 <code>Shape</code> 基类定义了两个纯虚函数 <code>calculateArea()</code> 和 <code>draw()</code>，使 <code>Shape</code> 成为一个抽象类。</li>\n<li>纯虚函数（<code>= 0</code>）没有默认实现，强制派生类必须提供具体实现。</li>\n<li><code>Rectangle</code> 类继承自 <code>Shape</code>，必须实现所有纯虚函数，否则仍将是抽象类。</li>\n<li>这个示例展示了纯虚函数作为接口的设计模式，确保派生类提供必要的具体行为。</li>\n</ul>\n<h3 id=\"抽象类\"><a href=\"#抽象类\" class=\"headerlink\" title=\"抽象类\"></a>抽象类</h3><p>抽象类是包含纯虚函数的类，它们不能被实例化，只能被继承。抽象类只能用作其他类的基类。如果一个类继承了抽象类，则必须实现所有的纯虚函数，否则该类也会成为抽象类。</p>\n<figure class=\"highlight cpp\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">class</span> <span class=\"title class_\">Shape</span></span><br><span class=\"line\">&#123;</span><br><span class=\"line\"><span class=\"keyword\">public</span>:</span><br><span class=\"line\">_    <span class=\"comment\">// 纯虚函数_</span></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">virtual</span> <span class=\"type\">double</span> <span class=\"title\">getArea</span><span class=\"params\">()</span> </span>= <span class=\"number\">0</span>;</span><br><span class=\"line\">&#125;;</span><br><span class=\"line\"></span><br><span class=\"line\">_<span class=\"comment\">// 继承自抽象类Shape_</span></span><br><span class=\"line\"><span class=\"keyword\">class</span> <span class=\"title class_\">Rectangle</span> : <span class=\"keyword\">public</span> Shape</span><br><span class=\"line\">&#123;</span><br><span class=\"line\"><span class=\"keyword\">public</span>:</span><br><span class=\"line\">    <span class=\"type\">double</span> **width**;</span><br><span class=\"line\">    <span class=\"type\">double</span> **height**;</span><br><span class=\"line\">    <span class=\"function\"><span class=\"type\">double</span> <span class=\"title\">getArea</span><span class=\"params\">()</span> </span>&#123; <span class=\"keyword\">return</span> **width** * **height**; &#125;</span><br><span class=\"line\">&#125;;</span><br><span class=\"line\"></span><br><span class=\"line\">_<span class=\"comment\">// 继承自抽象类Shape_</span></span><br><span class=\"line\"><span class=\"keyword\">class</span> <span class=\"title class_\">Circle</span> : <span class=\"keyword\">public</span> Shape</span><br><span class=\"line\">&#123;</span><br><span class=\"line\"><span class=\"keyword\">public</span>:</span><br><span class=\"line\">    <span class=\"type\">double</span> **radius**;</span><br><span class=\"line\">    <span class=\"function\"><span class=\"type\">double</span> <span class=\"title\">getArea</span><span class=\"params\">()</span> </span>&#123; <span class=\"keyword\">return</span> <span class=\"number\">3.14</span> * **radius** * **radius**; &#125;</span><br><span class=\"line\">&#125;;</span><br></pre></td></tr></table></figure>\n\n<p>Shape 为抽象类，其中包含纯虚函数 getArea()，Rectangle 和 Circle 均继承自 Shape，并且实现了 getArea()函数的具体内容。</p>\n<h3 id=\"多重继承中的虚函数\"><a href=\"#多重继承中的虚函数\" class=\"headerlink\" title=\"多重继承中的虚函数\"></a>多重继承中的虚函数</h3><p>在多重继承中，如果一个类同时继承了多个基类，而这些基类中都有同名的虚函数，那么子类必须对这些虚函数进行重写并实现。此时，需要使用作用域限定符来指明重写的是哪个基类的虚函数。</p>\n<figure class=\"highlight cpp\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">class</span> <span class=\"title class_\">Base1</span></span><br><span class=\"line\">&#123;</span><br><span class=\"line\"><span class=\"keyword\">public</span>:</span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">virtual</span> <span class=\"type\">void</span> <span class=\"title\">func</span><span class=\"params\">()</span> </span>&#123; cout &lt;&lt; <span class=\"string\">&quot;Base1::func()&quot;</span> &lt;&lt; endl; &#125;</span><br><span class=\"line\">&#125;;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">class</span> <span class=\"title class_\">Base2</span></span><br><span class=\"line\">&#123;</span><br><span class=\"line\"><span class=\"keyword\">public</span>:</span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">virtual</span> <span class=\"type\">void</span> <span class=\"title\">func</span><span class=\"params\">()</span> </span>&#123; cout &lt;&lt; <span class=\"string\">&quot;Base2::func()&quot;</span> &lt;&lt; endl; &#125;</span><br><span class=\"line\">&#125;;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">class</span> <span class=\"title class_\">Derived</span> : <span class=\"keyword\">public</span> Base1, <span class=\"keyword\">public</span> Base2</span><br><span class=\"line\">&#123;</span><br><span class=\"line\"><span class=\"keyword\">public</span>:</span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">virtual</span> <span class=\"type\">void</span> <span class=\"title\">func</span><span class=\"params\">()</span></span></span><br><span class=\"line\"><span class=\"function\">    </span>&#123;</span><br><span class=\"line\">        Base1::<span class=\"built_in\">func</span>();</span><br><span class=\"line\">        Base2::<span class=\"built_in\">func</span>();</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;;</span><br></pre></td></tr></table></figure>\n\n<p>派生类 Derived 同时继承了 Base1 和 Base2，这两个基类中都有名为 func 的虚函数。在 Derived 中，我们通过使用作用域限定符 Base1::和 Base2::，分别调用了两个基类中的虚函数。</p>\n<h3 id=\"总结\"><a href=\"#总结\" class=\"headerlink\" title=\"总结\"></a><strong>总结</strong></h3><ul>\n<li><p>优点：</p>\n<ul>\n<li>实现多态性：通过虚函数，可以在不知道对象具体类型的情况下，调用特定对象的方法。</li>\n<li>代码灵活性：虚函数允许子类覆盖父类的方法，并且不需要改变基类的代码。</li>\n<li>代码可维护性：虚函数使得代码易于维护和扩展，因为子类可以通过重载虚函数来实现自己的行为。</li>\n</ul>\n</li>\n<li><p>缺点：</p>\n<ul>\n<li>额外的开销：虚函数需要额外的开销来支持运行时的动态绑定和查找虚表。这可能会影响程序的性能。</li>\n<li>可能会引起混淆：由于虚函数的存在，同名的函数可能会被不同的类定义。如果没有正确的使用虚函数，可能会导致混淆和错误的结果。</li>\n<li>不适合于小型应用：虚函数对于小型应用来说可能过于复杂和冗余。在这种情况下，使用虚函数可能会导致更多的开销而不是提高效率。</li>\n</ul>\n</li>\n</ul>\n<h1 id=\"Example\"><a href=\"#Example\" class=\"headerlink\" title=\"Example\"></a>Example</h1><figure class=\"highlight cpp\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br><span class=\"line\">47</span><br><span class=\"line\">48</span><br><span class=\"line\">49</span><br><span class=\"line\">50</span><br><span class=\"line\">51</span><br><span class=\"line\">52</span><br><span class=\"line\">53</span><br><span class=\"line\">54</span><br><span class=\"line\">55</span><br><span class=\"line\">56</span><br><span class=\"line\">57</span><br><span class=\"line\">58</span><br><span class=\"line\">59</span><br><span class=\"line\">60</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">#<span class=\"keyword\">include</span> <span class=\"string\">&lt;iostream&gt;</span></span></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"keyword\">include</span> <span class=\"string\">&lt;string&gt;</span></span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// 基类Entity，定义了一个虚函数GetName()</span></span><br><span class=\"line\"><span class=\"keyword\">class</span> <span class=\"title class_\">Entity</span> &#123;</span><br><span class=\"line\"><span class=\"keyword\">public</span>:</span><br><span class=\"line\">   <span class=\"comment\">// 虚函数，返回一个默认的实体名称</span></span><br><span class=\"line\">   <span class=\"comment\">// 使用virtual关键字，允许派生类重写</span></span><br><span class=\"line\">   <span class=\"function\"><span class=\"keyword\">virtual</span> std::string <span class=\"title\">GetName</span><span class=\"params\">()</span> </span>&#123; <span class=\"keyword\">return</span> <span class=\"string\">&quot;Entity&quot;</span>; &#125;</span><br><span class=\"line\">&#125;;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// 派生类Player，继承自Entity</span></span><br><span class=\"line\"><span class=\"keyword\">class</span> <span class=\"title class_\">Player</span> : <span class=\"keyword\">public</span> Entity &#123;</span><br><span class=\"line\"><span class=\"keyword\">private</span>:</span><br><span class=\"line\">   <span class=\"comment\">// 私有成员，存储玩家名称</span></span><br><span class=\"line\">   std::string m_Name;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">public</span>:</span><br><span class=\"line\">   <span class=\"comment\">// 构造函数，使用传入的名称初始化玩家</span></span><br><span class=\"line\">   <span class=\"built_in\">Player</span>(<span class=\"type\">const</span> std::string&amp; name) :<span class=\"built_in\">m_Name</span>(name) &#123;&#125;;</span><br><span class=\"line\"></span><br><span class=\"line\">   <span class=\"comment\">// 重写基类的GetName()虚函数</span></span><br><span class=\"line\">   <span class=\"comment\">// override关键字确保正确重写基类虚函数</span></span><br><span class=\"line\">   <span class=\"function\">std::string <span class=\"title\">GetName</span><span class=\"params\">()</span> <span class=\"keyword\">override</span> </span>&#123; <span class=\"keyword\">return</span> m_Name; &#125;;</span><br><span class=\"line\"></span><br><span class=\"line\">   <span class=\"comment\">// 设置玩家名称的成员函数</span></span><br><span class=\"line\">   <span class=\"function\"><span class=\"type\">void</span> <span class=\"title\">SetName</span><span class=\"params\">(std::string name)</span> </span>&#123; m_Name = name; &#125;;</span><br><span class=\"line\">&#125;;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// 打印实体名称的函数</span></span><br><span class=\"line\"><span class=\"comment\">// 接受一个Entity指针作为参数，体现了多态性</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"type\">void</span> <span class=\"title\">PrintName</span><span class=\"params\">(Entity* entity)</span> </span>&#123;</span><br><span class=\"line\">   <span class=\"comment\">// 调用虚函数GetName()，实际执行的是对象的具体实现</span></span><br><span class=\"line\">   std::cout &lt;&lt; entity-&gt;<span class=\"built_in\">GetName</span>() &lt;&lt; std::endl;</span><br><span class=\"line\">&#125;;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"type\">int</span> <span class=\"title\">main</span><span class=\"params\">()</span> </span>&#123;</span><br><span class=\"line\">   <span class=\"comment\">// 创建一个基类Entity对象的指针</span></span><br><span class=\"line\">   Entity* e = <span class=\"keyword\">new</span> <span class=\"built_in\">Entity</span>();</span><br><span class=\"line\">   <span class=\"comment\">// 调用PrintName()，将打印&quot;Entity&quot;</span></span><br><span class=\"line\">   <span class=\"built_in\">PrintName</span>(e);</span><br><span class=\"line\"></span><br><span class=\"line\">   <span class=\"comment\">// 创建一个Player对象，名称为&quot;tanke&quot;</span></span><br><span class=\"line\">   Player* p = <span class=\"keyword\">new</span> <span class=\"built_in\">Player</span>(<span class=\"string\">&quot;tanke&quot;</span>);</span><br><span class=\"line\">   <span class=\"comment\">// 调用PrintName()，将打印&quot;tanke&quot;</span></span><br><span class=\"line\">   <span class=\"built_in\">PrintName</span>(p);</span><br><span class=\"line\"></span><br><span class=\"line\">   <span class=\"comment\">// 修改Player对象的名称为&quot;wangjie&quot;</span></span><br><span class=\"line\">   p-&gt;<span class=\"built_in\">SetName</span>(<span class=\"string\">&quot;wangjie&quot;</span>);</span><br><span class=\"line\"></span><br><span class=\"line\">   <span class=\"comment\">// 将Player指针赋值给基类指针，体现了多态性</span></span><br><span class=\"line\">   Entity* e1 = p;</span><br><span class=\"line\">   <span class=\"comment\">// 调用PrintName()，将打印&quot;wangjie&quot;</span></span><br><span class=\"line\">   <span class=\"built_in\">PrintName</span>(p);</span><br><span class=\"line\"></span><br><span class=\"line\">   <span class=\"comment\">// 等待用户输入，保持窗口打开</span></span><br><span class=\"line\">   std::cin.<span class=\"built_in\">get</span>();</span><br><span class=\"line\"></span><br><span class=\"line\">   <span class=\"keyword\">return</span> <span class=\"number\">0</span>;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p><strong>解释：</strong></p>\n<ul>\n<li>代码通过 <code>Entity</code> 基类定义了一个虚函数 <code>GetName()</code>，为派生类提供了一个默认实现。</li>\n<li><code>Player</code> 类继承自 <code>Entity</code>，并使用 <code>override</code> 关键字重写了 <code>GetName()</code> 方法。</li>\n<li><code>PrintName()</code> 函数接受一个 <code>Entity</code> 指针，展示了 C++ 多态性的关键特征 - 可以通过基类指针调用派生类的具体实现。</li>\n</ul>\n<p><img src=\"https://tk-pichost-1325224430.cos.ap-chengdu.myqcloud.com/blog/1747056796676Ue1zbj8hco94t9xuRBRcd0jWnXg.png\" alt=\"1747056796676Ue1zbj8hco94t9xuRBRcd0jWnXg.png\"></p>\n<h1 id=\"思考\"><a href=\"#思考\" class=\"headerlink\" title=\"思考\"></a>思考</h1><ol>\n<li>虚函数应用于继承层次结构中的多态性，即通过基类指针或引用调用派生类对象的成员函数。</li>\n<li>可以将虚函数作为接口定义，让不同的派生类实现自己的版本，以满足各自的需求。</li>\n<li>避免在构造函数和析构函数中调用虚函数，因为此时对象还未完全构造或已经被销毁。</li>\n<li>虚函数的声明应该在公共部分（例如基类），而不是在私有部分（例如派生类）中声明。</li>\n<li>将虚函数的实现定义为 inline 可以提高程序的执行效率。</li>\n<li>在使用纯虚函数时，需要给出其具体实现。可以在派生类中实现，也可以在基类中实现。</li>\n<li>避免过度使用虚函数，因为虚函数会增加程序的开销。在没有必要的情况下，可以使用普通成员函数代替虚函数。</li>\n</ol>\n"},{"title":"2025-04-20-CPU-GPU-NPU 的区别及应用前景","date":"2025-04-19T16:00:00.000Z","_content":"# CPU-GPU-NPU 的区别及应用前景\n\n# 参考资料\n\n> - [CPU、GPU、NPU 的区别_npu 和 gpu 区别-CSDN 博客](https://blog.csdn.net/qq_36944952/article/details/125951835)\n> - [一文看懂 CPU， GPU， NPU， TPU 是什麼？](https://blog.qnap.com/zh/%E4%B8%80%E6%96%87%E7%9C%8B%E6%87%82-cpu-gpu-npu-tpu-%E6%98%AF%E4%BB%80%E9%BA%BC/)\n> - [NPU 的概念理解，以及和 CPU/GPU 的区别解析。 - AlphaGeek - 博客园](https://www.cnblogs.com/geekbruce/articles/18675150)\n> - [AI 实验室：CPU、GPU、TPU 和 NPU 的发展历程和区别](https://zhuanlan.zhihu.com/p/670414115)\n> - [GPU 进阶笔记（三）:华为 NPU/GPU 演进（2024）](https://arthurchiao.github.io/blog/gpu-advanced-notes-3-zh/)\n\n---\n\n# 概述\n\n现代的计算机， 大多遵守[冯诺依曼](https://so.csdn.net/so/search?q=%E5%86%AF%E8%AF%BA%E4%BE%9D%E6%9B%BC&spm=1001.2101.3001.7020)体系结构，即\n\n![1749359273853C1PzbOGpLoF9vXxxxUccT9IHnhd.png](https://gitee.com/tanke11223344/imagehost/raw/main/blog/1749359273853C1PzbOGpLoF9vXxxxUccT9IHnhd.png)\n\n> - CPU，即中央处理器，是一台计算机的运算核心和控制核心。其功能主要是解释计算机指令以及处理计算机软件中的数据。CPU 由运算器、控制器、寄存器、高速缓存及实现它们之间联系的数据、控制及状态的总线构成\n> - 存储器，分为外存和内存， 用于存储数据（使用二进制方式存储）\n> - 输入设备，用户给计算机发号施令的设备\n> - 输出设备，计算机个用户汇报结果的设备\n\n---\n\n![1749359294853F2FQbuNabouwzVxKPSvcLOzmnV2.png](https://gitee.com/tanke11223344/imagehost/raw/main/blog/1749359294853F2FQbuNabouwzVxKPSvcLOzmnV2.png)\n\n![1749359311853Wotpb6o17oqdBExt6LEckgMHnLF.png](https://gitee.com/tanke11223344/imagehost/raw/main/blog/1749359311853Wotpb6o17oqdBExt6LEckgMHnLF.png)\n\nCPU/GPU/NPU 等等都是硬件芯片，简单来说，晶体管既可以用来实现逻辑控制单元， 也可以用来实现运算单元（算力）。 在芯片总面积一定的情况下，就看控制和算力怎么分。\n\n- CPU：通用目的处理器，重逻辑控制；\n- GPU：通用目的并行处理器（GPGPU），图形处理器；\n- NPU：专用处理器，相比 CPU/GPU，擅长执行更具体的计算任务。\n\n## CPU**（Central Processing Unit，中央处理器）**\n\n> - [CPU 处理器架构和工作原理浅析 - 流星泪 - 博客园](https://www.cnblogs.com/Zhengxue/p/14232394.html)\n> - [CPU 结构](https://zhang-each.github.io/My-CS-Notebook/System/03-cpu/#32-%E5%9F%BA%E6%9C%AC%E7%9A%84%E5%8A%9F%E8%83%BD%E7%BB%84%E4%BB%B6)\n>   对于 CPU 的原理和结构上面两篇博客已经描述的非常清晰了，如有需要请跳转上面两个链接\n\n- 定义：负责执行操作系统及各类应用程序指令，以通用性强、控制流能力强见长。\n- 特点：核心数通常较少（如 4～16 核），内核频率高，善于处理复杂的分支和通用计算任务。\n\n![1749359324854FWMObJX3so9xi5xe9VMcloVunZf.png](https://gitee.com/tanke11223344/imagehost/raw/main/blog/1749359324854FWMObJX3so9xi5xe9VMcloVunZf.png)\n![1749359334854NddybhxCNo9zTuxUlTBcd35vnxf.png](https://gitee.com/tanke11223344/imagehost/raw/main/blog/1749359334854NddybhxCNo9zTuxUlTBcd35vnxf.png)\n![1749359345855XWfSbujSDoQ6AjxMu3gceQJRn1d.png](https://gitee.com/tanke11223344/imagehost/raw/main/blog/1749359345855XWfSbujSDoQ6AjxMu3gceQJRn1d.png)\n\n大部分芯片面积都用在了逻辑单元，因此逻辑控制能力强，算力弱（相对 GPU,NPU）。\n\n### 应用场景\n\n- **操作系统与通用计算**：执行各种应用程序逻辑、文件 I/O、网络请求等。\n- **轻量级 AI 推理**：CPU 在推理任务中仍可胜任一些场景（如桌面级简单模型），但效率不及 GPU/NPU。\n- **控制流程复杂的任务**：诸如数据库事务处理、复杂分支逻辑的软件。\n\n## GPU**（Graphics Processing Unit，图形处理器）**\n\n> - [GPU 的工作原理](https://zhuanlan.zhihu.com/p/34675934)\n> - [一文理清 GPU 工作原理](http://www.uml.org.cn/Computer/202407111.asp)\n> - [GPU 硬件原理架构（一）](https://blog.csdn.net/u012294613/article/details/140209282)\n\n显卡分为集显,核显和独显\n\n![1749359366853M81rbfVt3oEGeaxj7cYcQlKfnFe.png](https://gitee.com/tanke11223344/imagehost/raw/main/blog/1749359366853M81rbfVt3oEGeaxj7cYcQlKfnFe.png)\n![1749359378854UVDPbCqnto9k8fxRHZiczM2Xnme.png](https://gitee.com/tanke11223344/imagehost/raw/main/blog/1749359378854UVDPbCqnto9k8fxRHZiczM2Xnme.png)\n\n- 定义：最初用于图形渲染，后发展为通用并行计算加速器，具备海量并行计算单元。\n- 特点：拥有数百到上千个计算核心（CUDA 核心、流处理器等），擅长大规模矩阵运算和并行数据处理。\n\n![1749359391853QDjibwrBgopF9vxSohgcOGoRnLh.png](https://gitee.com/tanke11223344/imagehost/raw/main/blog/1749359391853QDjibwrBgopF9vxSohgcOGoRnLh.png)\n![1749359401853EoQpbqAtgokSYrxEGZ3cnS3hnna.png](https://gitee.com/tanke11223344/imagehost/raw/main/blog/1749359401853EoQpbqAtgokSYrxEGZ3cnS3hnna.png)\n\n大部分芯片面积用在了计算单元，因此并行计算能力强，但逻辑控制弱。 适合图像渲染、矩阵计算之类的并行计算场景。作为协处理器，需要在 CPU 的指挥下工作。\n\n![1749359412854Ct5AbHn4MopusoxweETcLJoXnYc.png](https://gitee.com/tanke11223344/imagehost/raw/main/blog/1749359412854Ct5AbHn4MopusoxweETcLJoXnYc.png)\n\n### 应用场景\n\n- **图形渲染与游戏**：2D/3D 渲染、物理特效计算。\n- **深度学习训练**：TensorFlow、PyTorch 等框架常将张量运算 offload 到 GPU，借助其大规模并行加速矩阵运算。\n- **科学与工程计算**：大规模数值仿真、视频转码、加密/解密算法（通过 CUDA/OpenCL）。\n\n### CUDA\n\nCUDA 是 NVIDIA 推出的并行计算平台与编程模型，允许开发者使用 C/C++（以及其他语言绑定）直接在 GPU 上编写并行代码，将大量浮点与整数运算分配给成百上千个并行执行的 CUDA 核心，从而在深度学习训练、科学计算、图像处理等领域显著提升计算性能。\n\n![1749359428857MbQjb1NEHodtObxEWX7cXdavnQe.png](https://gitee.com/tanke11223344/imagehost/raw/main/blog/1749359428857MbQjb1NEHodtObxEWX7cXdavnQe.png)\n\n在这个框架下，CUDA 就像一座“软件桥梁”：它对上层开发者提供了一套统一的 API，开发者只需在 Python、C++ 中调用相应接口，就能将运算任务提交给 GPU；对下层，CUDA 又会自动将这些高层调用翻译成不同 GPU 架构所需的低阶指令。\n\n不论是图形渲染、AI 推理，还是流体模拟等数值运算，都要经过这层“中介”，由 CUDA 负责调度和分派运算到各个并行核心。这样一来，开发者无需关心底层硬件如何切分任务、如何分配资源，只需调用高层接口，就能一键触发 GPU 的海量并行加速，极大简化了并行编程的复杂度。\n\n## NPU **（Neural Processing Unit，神经网络处理单元）**\n\n按照上文所述，CPU 和 GPU 都是较为通用的芯片，但是随着人们的计算需求越来越专业化，人们希望有芯片可以更加符合自己的专业需求，这时，便产生了 ASIC（专用集成电路）的概念。\n\nASIC 是指依产品需求不同而定制化的特殊规格集成电路，由特定使用者要求和特定电子系统的需要而设计、制造。当然这概念不用记，简单来说就是**定制化芯片。**\n\n**因为 ASIC 很“专一”，只做一件事，所以就会比 CPU、GPU 等能做很多件事的芯片在某件事上做的更好，实现更高的处理速度和更低的能耗。但相应的，ASIC 的生产成本也非常高。**\n\n> [NPU 与超异构计算杂谈 - 吴建明 wujianming - 博客园](https://www.cnblogs.com/wujianming-110117/p/18240352)\n\n![1749359439854BAVzbOB4Goo5lOxgYorcpuHCnXf.png](https://gitee.com/tanke11223344/imagehost/raw/main/blog/1749359439854BAVzbOB4Goo5lOxgYorcpuHCnXf.png)\n\n- 定义：专为深度学习推理（Inference）设计的专用加速器。\n- 特点：在硬件层面高度优化了矩阵乘加运算、卷积操作，以及常见的神经网络算子，通常集成于 SoC（System-on-Chip）中，拥有极高的能效比。\n\n也是协处理器。在 wikipedia 中没有专门的 NPU （Neural Processing Unit） 页面，而是归到 [AI Processors](https://en.wikipedia.org/wiki/AI_accelerator) 大类里面， 指的是一类特殊目的硬件加速器，更接近 ASIC，硬件实现神经网络运算， 比如张量运算、卷积、点积、激活函数、多维矩阵运算等等。\n\n> 如果还不清楚什么是神经网络，可以看看 [以图像识别为例，关于卷积神经网络（CNN）的直观解释](https://arthurchiao.art/blog/cnn-intuitive-explanation-zh/)[（2016）](https://arthurchiao.art/blog/cnn-intuitive-explanation-zh/)。\n\n在这些特殊任务上，比 CPU/GPU 这种通用处理器效率更高，功耗更小，响应更快（比如一个时钟周期内可以完成几十万个乘法运算）， 因此适合用在手机、边缘计算、物联网等等场景。\n\n### 应用场景\n\n- **边缘端 AI 推理**：智能手机（人脸识别、AI 拍照、语音助手）、智能摄像头（实时目标检测、行为分析）、物联网设备（智能音箱、家居安防）。\n- **数据中心推理加速**：在服务器侧为海量请求提供低延迟 AI 预测（如推荐系统、在线广告投放）。\n- **专用智能芯片（如 AI 手机 SoC、智能驾驶芯片）**：为计算机视觉、自动驾驶、工业检测等应用提供高效算力。\n\n## TPU （ Tensor Processing Unit 张量处理单元）\n\n> - [In-Datacenter Performance Analysis of a Tensor Processing Unit](https://arxiv.org/abs/1704.04760)(论文)\n> - [Google 深度揭秘 TPU：一文看懂运算原理，以及为何碾压 GPU](https://zhuanlan.zhihu.com/p/26882794)\n> - [TPU 原理技术与 xPU - 吴建明 wujianming - 博客园](https://www.cnblogs.com/wujianming-110117/p/16333077.html)\n\nTPU：这里特制 Google 的 Tensor Processing Unit，目的跟 NPU 差不多。对 TPU 和 GPU 的使用场景区别有一个非常形象的比喻：\n\n> 如果外面下雨了，你其实并不需要知道每秒到底有多少滴雨， 而只要知道雨是大还是小。 与此类似，神经网络通常不需要 16/32bit 浮点数做精确计算，可能 8bit 整型预测的精度就足以满足需求了。\n\n### RISC，CISC 和 TPU 指令集\n\n可编程性是 TPU 的另一个重要设计目标。TPU 不是设计用来运行某一种神经网络，而是要能加速许多不同类型的模型。\n\n大多数当代 CPU 都采用了精简指令集(RISC)。但 Google 选择复杂指令集(CISC)作为 TPU 指令集的基础，这一指令集侧重于运行更复杂的任务。\n\n![1749359477855MLA4btRsFoybvux8t65cel3pnje.png](https://gitee.com/tanke11223344/imagehost/raw/main/blog/1749359477855MLA4btRsFoybvux8t65cel3pnje.png)\n\nTPU 包括以下计算资源：\n\n- 矩阵乘法单元(MUX)：65,536 个 8 位乘法和加法单元，运行矩阵计算\n- 统一缓冲(UB)：作为寄存器工作的 24MB 容量 SRAM\n- 激活单元(AU)：硬件连接的激活函数\n\n### 矩阵乘法单元的并行计算\n\n![1749359489852Mu3PbFejZoqWdmxvDQLcvDnAnEe.gif](https://gitee.com/tanke11223344/imagehost/raw/main/blog/1749359489852Mu3PbFejZoqWdmxvDQLcvDnAnEe.gif)\n\nGoogle TPU 中通过 MAC 模块进行矩阵乘法的加速，官方给出的加速矩阵乘法运算示意图如上 Google 为其设计了 MXU 作为矩阵处理器，可以在单个时钟周期内处理数十万次运算，也就是矩阵（Matrix）运算。\n\n### 脉动阵列\n\n![1749359504852Gh9Abp8gToml6TxEiipc6UYKnvb.png](https://gitee.com/tanke11223344/imagehost/raw/main/blog/1749359504852Gh9Abp8gToml6TxEiipc6UYKnvb.png)\n\nMXU 有着与传统 CPU、GPU 截然不同的架构，称为脉动阵列（systolic array）。之所以叫“脉动”，是因为在这种结构中，数据一波一波地流过芯片，与心脏跳动供血的方式类似。\n\n## 架构上的主要区别\n\n以上对比可概括为：\n\n- **CPU**：“万金油”式处理器，几乎什么都能做，但不擅长大规模并行计算；\n- **GPU**：并行吞吐巨大的加速引擎，不仅做图形，还广泛用于深度学习训练；\n- **NPU**：进一步聚焦于 AI 推理，将神经网络最常用的算子在硬件层面高度裁剪，能耗与性能比最优。\n\n---\n\n# 发展现状与应用前景\n\n## CPU 未来动向\n\n- **专用指令集扩展**：为了更好地兼顾 AI 推理性能，现代 CPU 已在向量指令（如 Intel AVX-512、ARM SVE）倾斜。\n- **异构集成**：如 AMD 的 APU、Intel 的集成显卡（iGPU），未来更多 SoC 将把 CPU、GPU、NPU 三者集成在一个芯片内，形成协同加速。\n- **边缘侧轻量化 AI 推理**：通过框架优化（如 ONNX Runtime）在 CPU 上做低精度推理（INT8/FP16），降低能耗。\n\n## GPU 的发展趋势\n\n- **Tensor 核心与混合精度**：从 NVIDIA 的 Volta 架构开始，GPU 内已集成专用张量核心（Tensor Core），提高深度学习训练/推理效率。\n- **异构并行**：更多厂商（AMD、Intel、以及新兴的 AI 芯片公司）推出专用于 AI 的 GPU 级别加速器，支持 FP16、INT8、INT4 等低精度运算。\n- **云端与数据中心规模化部署**：GPU 在云计算平台（AWS、Azure、Google Cloud）作为主力推理与训练设备，将继续占据主流地位。\n\n## NPU 的前景展望\n\n- **能效领先**：随着 5G+IoT+AIoT 的普及，边缘端对低功耗高效能的 AI 芯片需求激增，NPU 市场规模将持续扩大。\n- **集成化与定制化**：手机 SoC（如华为麒麟、苹果 A 系列）以及汽车/工业级芯片中将越来越普遍地集成 NPU；同时，也会出现多种定制化 NPU（例如自动驾驶专用 NPU、医疗影像专用 NPU）。\n- **GPNPU（GPU + NPU 的融合）**：未来会有更多将 GPU 与 NPU 功能融合在一颗芯片上的设计，以兼顾通用并行计算与 AI 推理效率，推动 AI 端云协同。\n- **生态与软件栈完善**：从硬件到软件框架（如 TensorRT、OpenVINO、NNAdapter、CAMERA），都将围绕 NPU 优化，使开发者可以更方便地将模型部署到 NPU 上。\n\n---\n\n# 总结\n\nCPU（中央处理器）适合通用计算，处理广泛任务但不擅长并行处理。GPU（图形处理器）专为并行任务设计，广泛用于图形渲染和 AI 模型训练。NPU（神经处理单元）优化 AI 和机器学习任务，特别在边缘计算中因能效高而受青睐。未来，NPU 可能更多集成到移动设备和 IoT 设备中，GPU 继续主导 AI 训练和高性能计算，CPU 维持通用计算核心。\n\nCPU、GPU 和 NPU 是现代计算的核心组件，各有独特功能和应用。CPU（中央处理器）是通用计算的核心，设计上处理广泛任务，如运行操作系统和生产力软件，但不擅长并行处理。GPU（图形处理器）专为并行任务优化，拥有数千核心，适合图形渲染和 AI 模型训练，如深度学习加速。NPU（神经处理单元）则是为 AI 和机器学习设计，优化矩阵运算，能效高，特别适合边缘计算和实时 AI 任务，如智能手机的图像识别。\n\n> **小结**：\n>\n> - 在通用计算领域，**CPU** 依旧是基础，但其 AI 加速能力会更多依赖于向量化指令和异构协同；\n> - **GPU** 将继续主导深度学习训练，并向 AI 推理、科学计算等方向拓展；\n> - **NPU** 则在边缘 AI 推理场景中大放异彩，并与 GPU 形成 “端 + 云” 协同加速架构。\n","source":"_posts/2025-04-20-CPU-GPU-NPU 的区别及应用前景.md","raw":"---\ntitle:  2025-04-20-CPU-GPU-NPU 的区别及应用前景\ndate: 2025-04-20\ntags: \n    课程学习\n---\n# CPU-GPU-NPU 的区别及应用前景\n\n# 参考资料\n\n> - [CPU、GPU、NPU 的区别_npu 和 gpu 区别-CSDN 博客](https://blog.csdn.net/qq_36944952/article/details/125951835)\n> - [一文看懂 CPU， GPU， NPU， TPU 是什麼？](https://blog.qnap.com/zh/%E4%B8%80%E6%96%87%E7%9C%8B%E6%87%82-cpu-gpu-npu-tpu-%E6%98%AF%E4%BB%80%E9%BA%BC/)\n> - [NPU 的概念理解，以及和 CPU/GPU 的区别解析。 - AlphaGeek - 博客园](https://www.cnblogs.com/geekbruce/articles/18675150)\n> - [AI 实验室：CPU、GPU、TPU 和 NPU 的发展历程和区别](https://zhuanlan.zhihu.com/p/670414115)\n> - [GPU 进阶笔记（三）:华为 NPU/GPU 演进（2024）](https://arthurchiao.github.io/blog/gpu-advanced-notes-3-zh/)\n\n---\n\n# 概述\n\n现代的计算机， 大多遵守[冯诺依曼](https://so.csdn.net/so/search?q=%E5%86%AF%E8%AF%BA%E4%BE%9D%E6%9B%BC&spm=1001.2101.3001.7020)体系结构，即\n\n![1749359273853C1PzbOGpLoF9vXxxxUccT9IHnhd.png](https://gitee.com/tanke11223344/imagehost/raw/main/blog/1749359273853C1PzbOGpLoF9vXxxxUccT9IHnhd.png)\n\n> - CPU，即中央处理器，是一台计算机的运算核心和控制核心。其功能主要是解释计算机指令以及处理计算机软件中的数据。CPU 由运算器、控制器、寄存器、高速缓存及实现它们之间联系的数据、控制及状态的总线构成\n> - 存储器，分为外存和内存， 用于存储数据（使用二进制方式存储）\n> - 输入设备，用户给计算机发号施令的设备\n> - 输出设备，计算机个用户汇报结果的设备\n\n---\n\n![1749359294853F2FQbuNabouwzVxKPSvcLOzmnV2.png](https://gitee.com/tanke11223344/imagehost/raw/main/blog/1749359294853F2FQbuNabouwzVxKPSvcLOzmnV2.png)\n\n![1749359311853Wotpb6o17oqdBExt6LEckgMHnLF.png](https://gitee.com/tanke11223344/imagehost/raw/main/blog/1749359311853Wotpb6o17oqdBExt6LEckgMHnLF.png)\n\nCPU/GPU/NPU 等等都是硬件芯片，简单来说，晶体管既可以用来实现逻辑控制单元， 也可以用来实现运算单元（算力）。 在芯片总面积一定的情况下，就看控制和算力怎么分。\n\n- CPU：通用目的处理器，重逻辑控制；\n- GPU：通用目的并行处理器（GPGPU），图形处理器；\n- NPU：专用处理器，相比 CPU/GPU，擅长执行更具体的计算任务。\n\n## CPU**（Central Processing Unit，中央处理器）**\n\n> - [CPU 处理器架构和工作原理浅析 - 流星泪 - 博客园](https://www.cnblogs.com/Zhengxue/p/14232394.html)\n> - [CPU 结构](https://zhang-each.github.io/My-CS-Notebook/System/03-cpu/#32-%E5%9F%BA%E6%9C%AC%E7%9A%84%E5%8A%9F%E8%83%BD%E7%BB%84%E4%BB%B6)\n>   对于 CPU 的原理和结构上面两篇博客已经描述的非常清晰了，如有需要请跳转上面两个链接\n\n- 定义：负责执行操作系统及各类应用程序指令，以通用性强、控制流能力强见长。\n- 特点：核心数通常较少（如 4～16 核），内核频率高，善于处理复杂的分支和通用计算任务。\n\n![1749359324854FWMObJX3so9xi5xe9VMcloVunZf.png](https://gitee.com/tanke11223344/imagehost/raw/main/blog/1749359324854FWMObJX3so9xi5xe9VMcloVunZf.png)\n![1749359334854NddybhxCNo9zTuxUlTBcd35vnxf.png](https://gitee.com/tanke11223344/imagehost/raw/main/blog/1749359334854NddybhxCNo9zTuxUlTBcd35vnxf.png)\n![1749359345855XWfSbujSDoQ6AjxMu3gceQJRn1d.png](https://gitee.com/tanke11223344/imagehost/raw/main/blog/1749359345855XWfSbujSDoQ6AjxMu3gceQJRn1d.png)\n\n大部分芯片面积都用在了逻辑单元，因此逻辑控制能力强，算力弱（相对 GPU,NPU）。\n\n### 应用场景\n\n- **操作系统与通用计算**：执行各种应用程序逻辑、文件 I/O、网络请求等。\n- **轻量级 AI 推理**：CPU 在推理任务中仍可胜任一些场景（如桌面级简单模型），但效率不及 GPU/NPU。\n- **控制流程复杂的任务**：诸如数据库事务处理、复杂分支逻辑的软件。\n\n## GPU**（Graphics Processing Unit，图形处理器）**\n\n> - [GPU 的工作原理](https://zhuanlan.zhihu.com/p/34675934)\n> - [一文理清 GPU 工作原理](http://www.uml.org.cn/Computer/202407111.asp)\n> - [GPU 硬件原理架构（一）](https://blog.csdn.net/u012294613/article/details/140209282)\n\n显卡分为集显,核显和独显\n\n![1749359366853M81rbfVt3oEGeaxj7cYcQlKfnFe.png](https://gitee.com/tanke11223344/imagehost/raw/main/blog/1749359366853M81rbfVt3oEGeaxj7cYcQlKfnFe.png)\n![1749359378854UVDPbCqnto9k8fxRHZiczM2Xnme.png](https://gitee.com/tanke11223344/imagehost/raw/main/blog/1749359378854UVDPbCqnto9k8fxRHZiczM2Xnme.png)\n\n- 定义：最初用于图形渲染，后发展为通用并行计算加速器，具备海量并行计算单元。\n- 特点：拥有数百到上千个计算核心（CUDA 核心、流处理器等），擅长大规模矩阵运算和并行数据处理。\n\n![1749359391853QDjibwrBgopF9vxSohgcOGoRnLh.png](https://gitee.com/tanke11223344/imagehost/raw/main/blog/1749359391853QDjibwrBgopF9vxSohgcOGoRnLh.png)\n![1749359401853EoQpbqAtgokSYrxEGZ3cnS3hnna.png](https://gitee.com/tanke11223344/imagehost/raw/main/blog/1749359401853EoQpbqAtgokSYrxEGZ3cnS3hnna.png)\n\n大部分芯片面积用在了计算单元，因此并行计算能力强，但逻辑控制弱。 适合图像渲染、矩阵计算之类的并行计算场景。作为协处理器，需要在 CPU 的指挥下工作。\n\n![1749359412854Ct5AbHn4MopusoxweETcLJoXnYc.png](https://gitee.com/tanke11223344/imagehost/raw/main/blog/1749359412854Ct5AbHn4MopusoxweETcLJoXnYc.png)\n\n### 应用场景\n\n- **图形渲染与游戏**：2D/3D 渲染、物理特效计算。\n- **深度学习训练**：TensorFlow、PyTorch 等框架常将张量运算 offload 到 GPU，借助其大规模并行加速矩阵运算。\n- **科学与工程计算**：大规模数值仿真、视频转码、加密/解密算法（通过 CUDA/OpenCL）。\n\n### CUDA\n\nCUDA 是 NVIDIA 推出的并行计算平台与编程模型，允许开发者使用 C/C++（以及其他语言绑定）直接在 GPU 上编写并行代码，将大量浮点与整数运算分配给成百上千个并行执行的 CUDA 核心，从而在深度学习训练、科学计算、图像处理等领域显著提升计算性能。\n\n![1749359428857MbQjb1NEHodtObxEWX7cXdavnQe.png](https://gitee.com/tanke11223344/imagehost/raw/main/blog/1749359428857MbQjb1NEHodtObxEWX7cXdavnQe.png)\n\n在这个框架下，CUDA 就像一座“软件桥梁”：它对上层开发者提供了一套统一的 API，开发者只需在 Python、C++ 中调用相应接口，就能将运算任务提交给 GPU；对下层，CUDA 又会自动将这些高层调用翻译成不同 GPU 架构所需的低阶指令。\n\n不论是图形渲染、AI 推理，还是流体模拟等数值运算，都要经过这层“中介”，由 CUDA 负责调度和分派运算到各个并行核心。这样一来，开发者无需关心底层硬件如何切分任务、如何分配资源，只需调用高层接口，就能一键触发 GPU 的海量并行加速，极大简化了并行编程的复杂度。\n\n## NPU **（Neural Processing Unit，神经网络处理单元）**\n\n按照上文所述，CPU 和 GPU 都是较为通用的芯片，但是随着人们的计算需求越来越专业化，人们希望有芯片可以更加符合自己的专业需求，这时，便产生了 ASIC（专用集成电路）的概念。\n\nASIC 是指依产品需求不同而定制化的特殊规格集成电路，由特定使用者要求和特定电子系统的需要而设计、制造。当然这概念不用记，简单来说就是**定制化芯片。**\n\n**因为 ASIC 很“专一”，只做一件事，所以就会比 CPU、GPU 等能做很多件事的芯片在某件事上做的更好，实现更高的处理速度和更低的能耗。但相应的，ASIC 的生产成本也非常高。**\n\n> [NPU 与超异构计算杂谈 - 吴建明 wujianming - 博客园](https://www.cnblogs.com/wujianming-110117/p/18240352)\n\n![1749359439854BAVzbOB4Goo5lOxgYorcpuHCnXf.png](https://gitee.com/tanke11223344/imagehost/raw/main/blog/1749359439854BAVzbOB4Goo5lOxgYorcpuHCnXf.png)\n\n- 定义：专为深度学习推理（Inference）设计的专用加速器。\n- 特点：在硬件层面高度优化了矩阵乘加运算、卷积操作，以及常见的神经网络算子，通常集成于 SoC（System-on-Chip）中，拥有极高的能效比。\n\n也是协处理器。在 wikipedia 中没有专门的 NPU （Neural Processing Unit） 页面，而是归到 [AI Processors](https://en.wikipedia.org/wiki/AI_accelerator) 大类里面， 指的是一类特殊目的硬件加速器，更接近 ASIC，硬件实现神经网络运算， 比如张量运算、卷积、点积、激活函数、多维矩阵运算等等。\n\n> 如果还不清楚什么是神经网络，可以看看 [以图像识别为例，关于卷积神经网络（CNN）的直观解释](https://arthurchiao.art/blog/cnn-intuitive-explanation-zh/)[（2016）](https://arthurchiao.art/blog/cnn-intuitive-explanation-zh/)。\n\n在这些特殊任务上，比 CPU/GPU 这种通用处理器效率更高，功耗更小，响应更快（比如一个时钟周期内可以完成几十万个乘法运算）， 因此适合用在手机、边缘计算、物联网等等场景。\n\n### 应用场景\n\n- **边缘端 AI 推理**：智能手机（人脸识别、AI 拍照、语音助手）、智能摄像头（实时目标检测、行为分析）、物联网设备（智能音箱、家居安防）。\n- **数据中心推理加速**：在服务器侧为海量请求提供低延迟 AI 预测（如推荐系统、在线广告投放）。\n- **专用智能芯片（如 AI 手机 SoC、智能驾驶芯片）**：为计算机视觉、自动驾驶、工业检测等应用提供高效算力。\n\n## TPU （ Tensor Processing Unit 张量处理单元）\n\n> - [In-Datacenter Performance Analysis of a Tensor Processing Unit](https://arxiv.org/abs/1704.04760)(论文)\n> - [Google 深度揭秘 TPU：一文看懂运算原理，以及为何碾压 GPU](https://zhuanlan.zhihu.com/p/26882794)\n> - [TPU 原理技术与 xPU - 吴建明 wujianming - 博客园](https://www.cnblogs.com/wujianming-110117/p/16333077.html)\n\nTPU：这里特制 Google 的 Tensor Processing Unit，目的跟 NPU 差不多。对 TPU 和 GPU 的使用场景区别有一个非常形象的比喻：\n\n> 如果外面下雨了，你其实并不需要知道每秒到底有多少滴雨， 而只要知道雨是大还是小。 与此类似，神经网络通常不需要 16/32bit 浮点数做精确计算，可能 8bit 整型预测的精度就足以满足需求了。\n\n### RISC，CISC 和 TPU 指令集\n\n可编程性是 TPU 的另一个重要设计目标。TPU 不是设计用来运行某一种神经网络，而是要能加速许多不同类型的模型。\n\n大多数当代 CPU 都采用了精简指令集(RISC)。但 Google 选择复杂指令集(CISC)作为 TPU 指令集的基础，这一指令集侧重于运行更复杂的任务。\n\n![1749359477855MLA4btRsFoybvux8t65cel3pnje.png](https://gitee.com/tanke11223344/imagehost/raw/main/blog/1749359477855MLA4btRsFoybvux8t65cel3pnje.png)\n\nTPU 包括以下计算资源：\n\n- 矩阵乘法单元(MUX)：65,536 个 8 位乘法和加法单元，运行矩阵计算\n- 统一缓冲(UB)：作为寄存器工作的 24MB 容量 SRAM\n- 激活单元(AU)：硬件连接的激活函数\n\n### 矩阵乘法单元的并行计算\n\n![1749359489852Mu3PbFejZoqWdmxvDQLcvDnAnEe.gif](https://gitee.com/tanke11223344/imagehost/raw/main/blog/1749359489852Mu3PbFejZoqWdmxvDQLcvDnAnEe.gif)\n\nGoogle TPU 中通过 MAC 模块进行矩阵乘法的加速，官方给出的加速矩阵乘法运算示意图如上 Google 为其设计了 MXU 作为矩阵处理器，可以在单个时钟周期内处理数十万次运算，也就是矩阵（Matrix）运算。\n\n### 脉动阵列\n\n![1749359504852Gh9Abp8gToml6TxEiipc6UYKnvb.png](https://gitee.com/tanke11223344/imagehost/raw/main/blog/1749359504852Gh9Abp8gToml6TxEiipc6UYKnvb.png)\n\nMXU 有着与传统 CPU、GPU 截然不同的架构，称为脉动阵列（systolic array）。之所以叫“脉动”，是因为在这种结构中，数据一波一波地流过芯片，与心脏跳动供血的方式类似。\n\n## 架构上的主要区别\n\n以上对比可概括为：\n\n- **CPU**：“万金油”式处理器，几乎什么都能做，但不擅长大规模并行计算；\n- **GPU**：并行吞吐巨大的加速引擎，不仅做图形，还广泛用于深度学习训练；\n- **NPU**：进一步聚焦于 AI 推理，将神经网络最常用的算子在硬件层面高度裁剪，能耗与性能比最优。\n\n---\n\n# 发展现状与应用前景\n\n## CPU 未来动向\n\n- **专用指令集扩展**：为了更好地兼顾 AI 推理性能，现代 CPU 已在向量指令（如 Intel AVX-512、ARM SVE）倾斜。\n- **异构集成**：如 AMD 的 APU、Intel 的集成显卡（iGPU），未来更多 SoC 将把 CPU、GPU、NPU 三者集成在一个芯片内，形成协同加速。\n- **边缘侧轻量化 AI 推理**：通过框架优化（如 ONNX Runtime）在 CPU 上做低精度推理（INT8/FP16），降低能耗。\n\n## GPU 的发展趋势\n\n- **Tensor 核心与混合精度**：从 NVIDIA 的 Volta 架构开始，GPU 内已集成专用张量核心（Tensor Core），提高深度学习训练/推理效率。\n- **异构并行**：更多厂商（AMD、Intel、以及新兴的 AI 芯片公司）推出专用于 AI 的 GPU 级别加速器，支持 FP16、INT8、INT4 等低精度运算。\n- **云端与数据中心规模化部署**：GPU 在云计算平台（AWS、Azure、Google Cloud）作为主力推理与训练设备，将继续占据主流地位。\n\n## NPU 的前景展望\n\n- **能效领先**：随着 5G+IoT+AIoT 的普及，边缘端对低功耗高效能的 AI 芯片需求激增，NPU 市场规模将持续扩大。\n- **集成化与定制化**：手机 SoC（如华为麒麟、苹果 A 系列）以及汽车/工业级芯片中将越来越普遍地集成 NPU；同时，也会出现多种定制化 NPU（例如自动驾驶专用 NPU、医疗影像专用 NPU）。\n- **GPNPU（GPU + NPU 的融合）**：未来会有更多将 GPU 与 NPU 功能融合在一颗芯片上的设计，以兼顾通用并行计算与 AI 推理效率，推动 AI 端云协同。\n- **生态与软件栈完善**：从硬件到软件框架（如 TensorRT、OpenVINO、NNAdapter、CAMERA），都将围绕 NPU 优化，使开发者可以更方便地将模型部署到 NPU 上。\n\n---\n\n# 总结\n\nCPU（中央处理器）适合通用计算，处理广泛任务但不擅长并行处理。GPU（图形处理器）专为并行任务设计，广泛用于图形渲染和 AI 模型训练。NPU（神经处理单元）优化 AI 和机器学习任务，特别在边缘计算中因能效高而受青睐。未来，NPU 可能更多集成到移动设备和 IoT 设备中，GPU 继续主导 AI 训练和高性能计算，CPU 维持通用计算核心。\n\nCPU、GPU 和 NPU 是现代计算的核心组件，各有独特功能和应用。CPU（中央处理器）是通用计算的核心，设计上处理广泛任务，如运行操作系统和生产力软件，但不擅长并行处理。GPU（图形处理器）专为并行任务优化，拥有数千核心，适合图形渲染和 AI 模型训练，如深度学习加速。NPU（神经处理单元）则是为 AI 和机器学习设计，优化矩阵运算，能效高，特别适合边缘计算和实时 AI 任务，如智能手机的图像识别。\n\n> **小结**：\n>\n> - 在通用计算领域，**CPU** 依旧是基础，但其 AI 加速能力会更多依赖于向量化指令和异构协同；\n> - **GPU** 将继续主导深度学习训练，并向 AI 推理、科学计算等方向拓展；\n> - **NPU** 则在边缘 AI 推理场景中大放异彩，并与 GPU 形成 “端 + 云” 协同加速架构。\n","slug":"2025-04-20-CPU-GPU-NPU 的区别及应用前景","published":1,"updated":"2025-09-26T12:16:55.238Z","_id":"cmg0saj4a0021jm8nah3ebhz0","comments":1,"layout":"post","photos":[],"content":"<h1 id=\"CPU-GPU-NPU-的区别及应用前景\"><a href=\"#CPU-GPU-NPU-的区别及应用前景\" class=\"headerlink\" title=\"CPU-GPU-NPU 的区别及应用前景\"></a>CPU-GPU-NPU 的区别及应用前景</h1><h1 id=\"参考资料\"><a href=\"#参考资料\" class=\"headerlink\" title=\"参考资料\"></a>参考资料</h1><blockquote>\n<ul>\n<li><a href=\"https://blog.csdn.net/qq_36944952/article/details/125951835\">CPU、GPU、NPU 的区别_npu 和 gpu 区别-CSDN 博客</a></li>\n<li><a href=\"https://blog.qnap.com/zh/%E4%B8%80%E6%96%87%E7%9C%8B%E6%87%82-cpu-gpu-npu-tpu-%E6%98%AF%E4%BB%80%E9%BA%BC/\">一文看懂 CPU， GPU， NPU， TPU 是什麼？</a></li>\n<li><a href=\"https://www.cnblogs.com/geekbruce/articles/18675150\">NPU 的概念理解，以及和 CPU&#x2F;GPU 的区别解析。 - AlphaGeek - 博客园</a></li>\n<li><a href=\"https://zhuanlan.zhihu.com/p/670414115\">AI 实验室：CPU、GPU、TPU 和 NPU 的发展历程和区别</a></li>\n<li><a href=\"https://arthurchiao.github.io/blog/gpu-advanced-notes-3-zh/\">GPU 进阶笔记（三）:华为 NPU&#x2F;GPU 演进（2024）</a></li>\n</ul>\n</blockquote>\n<hr>\n<h1 id=\"概述\"><a href=\"#概述\" class=\"headerlink\" title=\"概述\"></a>概述</h1><p>现代的计算机， 大多遵守<a href=\"https://so.csdn.net/so/search?q=%E5%86%AF%E8%AF%BA%E4%BE%9D%E6%9B%BC&spm=1001.2101.3001.7020\">冯诺依曼</a>体系结构，即</p>\n<p><img src=\"https://gitee.com/tanke11223344/imagehost/raw/main/blog/1749359273853C1PzbOGpLoF9vXxxxUccT9IHnhd.png\" alt=\"1749359273853C1PzbOGpLoF9vXxxxUccT9IHnhd.png\"></p>\n<blockquote>\n<ul>\n<li>CPU，即中央处理器，是一台计算机的运算核心和控制核心。其功能主要是解释计算机指令以及处理计算机软件中的数据。CPU 由运算器、控制器、寄存器、高速缓存及实现它们之间联系的数据、控制及状态的总线构成</li>\n<li>存储器，分为外存和内存， 用于存储数据（使用二进制方式存储）</li>\n<li>输入设备，用户给计算机发号施令的设备</li>\n<li>输出设备，计算机个用户汇报结果的设备</li>\n</ul>\n</blockquote>\n<hr>\n<p><img src=\"https://gitee.com/tanke11223344/imagehost/raw/main/blog/1749359294853F2FQbuNabouwzVxKPSvcLOzmnV2.png\" alt=\"1749359294853F2FQbuNabouwzVxKPSvcLOzmnV2.png\"></p>\n<p><img src=\"https://gitee.com/tanke11223344/imagehost/raw/main/blog/1749359311853Wotpb6o17oqdBExt6LEckgMHnLF.png\" alt=\"1749359311853Wotpb6o17oqdBExt6LEckgMHnLF.png\"></p>\n<p>CPU&#x2F;GPU&#x2F;NPU 等等都是硬件芯片，简单来说，晶体管既可以用来实现逻辑控制单元， 也可以用来实现运算单元（算力）。 在芯片总面积一定的情况下，就看控制和算力怎么分。</p>\n<ul>\n<li>CPU：通用目的处理器，重逻辑控制；</li>\n<li>GPU：通用目的并行处理器（GPGPU），图形处理器；</li>\n<li>NPU：专用处理器，相比 CPU&#x2F;GPU，擅长执行更具体的计算任务。</li>\n</ul>\n<h2 id=\"CPU（Central-Processing-Unit，中央处理器）\"><a href=\"#CPU（Central-Processing-Unit，中央处理器）\" class=\"headerlink\" title=\"CPU（Central Processing Unit，中央处理器）\"></a>CPU<strong>（Central Processing Unit，中央处理器）</strong></h2><blockquote>\n<ul>\n<li><a href=\"https://www.cnblogs.com/Zhengxue/p/14232394.html\">CPU 处理器架构和工作原理浅析 - 流星泪 - 博客园</a></li>\n<li><a href=\"https://zhang-each.github.io/My-CS-Notebook/System/03-cpu/#32-%E5%9F%BA%E6%9C%AC%E7%9A%84%E5%8A%9F%E8%83%BD%E7%BB%84%E4%BB%B6\">CPU 结构</a><br>对于 CPU 的原理和结构上面两篇博客已经描述的非常清晰了，如有需要请跳转上面两个链接</li>\n</ul>\n</blockquote>\n<ul>\n<li>定义：负责执行操作系统及各类应用程序指令，以通用性强、控制流能力强见长。</li>\n<li>特点：核心数通常较少（如 4～16 核），内核频率高，善于处理复杂的分支和通用计算任务。</li>\n</ul>\n<p><img src=\"https://gitee.com/tanke11223344/imagehost/raw/main/blog/1749359324854FWMObJX3so9xi5xe9VMcloVunZf.png\" alt=\"1749359324854FWMObJX3so9xi5xe9VMcloVunZf.png\"><br><img src=\"https://gitee.com/tanke11223344/imagehost/raw/main/blog/1749359334854NddybhxCNo9zTuxUlTBcd35vnxf.png\" alt=\"1749359334854NddybhxCNo9zTuxUlTBcd35vnxf.png\"><br><img src=\"https://gitee.com/tanke11223344/imagehost/raw/main/blog/1749359345855XWfSbujSDoQ6AjxMu3gceQJRn1d.png\" alt=\"1749359345855XWfSbujSDoQ6AjxMu3gceQJRn1d.png\"></p>\n<p>大部分芯片面积都用在了逻辑单元，因此逻辑控制能力强，算力弱（相对 GPU,NPU）。</p>\n<h3 id=\"应用场景\"><a href=\"#应用场景\" class=\"headerlink\" title=\"应用场景\"></a>应用场景</h3><ul>\n<li><strong>操作系统与通用计算</strong>：执行各种应用程序逻辑、文件 I&#x2F;O、网络请求等。</li>\n<li><strong>轻量级 AI 推理</strong>：CPU 在推理任务中仍可胜任一些场景（如桌面级简单模型），但效率不及 GPU&#x2F;NPU。</li>\n<li><strong>控制流程复杂的任务</strong>：诸如数据库事务处理、复杂分支逻辑的软件。</li>\n</ul>\n<h2 id=\"GPU（Graphics-Processing-Unit，图形处理器）\"><a href=\"#GPU（Graphics-Processing-Unit，图形处理器）\" class=\"headerlink\" title=\"GPU（Graphics Processing Unit，图形处理器）\"></a>GPU<strong>（Graphics Processing Unit，图形处理器）</strong></h2><blockquote>\n<ul>\n<li><a href=\"https://zhuanlan.zhihu.com/p/34675934\">GPU 的工作原理</a></li>\n<li><a href=\"http://www.uml.org.cn/Computer/202407111.asp\">一文理清 GPU 工作原理</a></li>\n<li><a href=\"https://blog.csdn.net/u012294613/article/details/140209282\">GPU 硬件原理架构（一）</a></li>\n</ul>\n</blockquote>\n<p>显卡分为集显,核显和独显</p>\n<p><img src=\"https://gitee.com/tanke11223344/imagehost/raw/main/blog/1749359366853M81rbfVt3oEGeaxj7cYcQlKfnFe.png\" alt=\"1749359366853M81rbfVt3oEGeaxj7cYcQlKfnFe.png\"><br><img src=\"https://gitee.com/tanke11223344/imagehost/raw/main/blog/1749359378854UVDPbCqnto9k8fxRHZiczM2Xnme.png\" alt=\"1749359378854UVDPbCqnto9k8fxRHZiczM2Xnme.png\"></p>\n<ul>\n<li>定义：最初用于图形渲染，后发展为通用并行计算加速器，具备海量并行计算单元。</li>\n<li>特点：拥有数百到上千个计算核心（CUDA 核心、流处理器等），擅长大规模矩阵运算和并行数据处理。</li>\n</ul>\n<p><img src=\"https://gitee.com/tanke11223344/imagehost/raw/main/blog/1749359391853QDjibwrBgopF9vxSohgcOGoRnLh.png\" alt=\"1749359391853QDjibwrBgopF9vxSohgcOGoRnLh.png\"><br><img src=\"https://gitee.com/tanke11223344/imagehost/raw/main/blog/1749359401853EoQpbqAtgokSYrxEGZ3cnS3hnna.png\" alt=\"1749359401853EoQpbqAtgokSYrxEGZ3cnS3hnna.png\"></p>\n<p>大部分芯片面积用在了计算单元，因此并行计算能力强，但逻辑控制弱。 适合图像渲染、矩阵计算之类的并行计算场景。作为协处理器，需要在 CPU 的指挥下工作。</p>\n<p><img src=\"https://gitee.com/tanke11223344/imagehost/raw/main/blog/1749359412854Ct5AbHn4MopusoxweETcLJoXnYc.png\" alt=\"1749359412854Ct5AbHn4MopusoxweETcLJoXnYc.png\"></p>\n<h3 id=\"应用场景-1\"><a href=\"#应用场景-1\" class=\"headerlink\" title=\"应用场景\"></a>应用场景</h3><ul>\n<li><strong>图形渲染与游戏</strong>：2D&#x2F;3D 渲染、物理特效计算。</li>\n<li><strong>深度学习训练</strong>：TensorFlow、PyTorch 等框架常将张量运算 offload 到 GPU，借助其大规模并行加速矩阵运算。</li>\n<li><strong>科学与工程计算</strong>：大规模数值仿真、视频转码、加密&#x2F;解密算法（通过 CUDA&#x2F;OpenCL）。</li>\n</ul>\n<h3 id=\"CUDA\"><a href=\"#CUDA\" class=\"headerlink\" title=\"CUDA\"></a>CUDA</h3><p>CUDA 是 NVIDIA 推出的并行计算平台与编程模型，允许开发者使用 C&#x2F;C++（以及其他语言绑定）直接在 GPU 上编写并行代码，将大量浮点与整数运算分配给成百上千个并行执行的 CUDA 核心，从而在深度学习训练、科学计算、图像处理等领域显著提升计算性能。</p>\n<p><img src=\"https://gitee.com/tanke11223344/imagehost/raw/main/blog/1749359428857MbQjb1NEHodtObxEWX7cXdavnQe.png\" alt=\"1749359428857MbQjb1NEHodtObxEWX7cXdavnQe.png\"></p>\n<p>在这个框架下，CUDA 就像一座“软件桥梁”：它对上层开发者提供了一套统一的 API，开发者只需在 Python、C++ 中调用相应接口，就能将运算任务提交给 GPU；对下层，CUDA 又会自动将这些高层调用翻译成不同 GPU 架构所需的低阶指令。</p>\n<p>不论是图形渲染、AI 推理，还是流体模拟等数值运算，都要经过这层“中介”，由 CUDA 负责调度和分派运算到各个并行核心。这样一来，开发者无需关心底层硬件如何切分任务、如何分配资源，只需调用高层接口，就能一键触发 GPU 的海量并行加速，极大简化了并行编程的复杂度。</p>\n<h2 id=\"NPU-（Neural-Processing-Unit，神经网络处理单元）\"><a href=\"#NPU-（Neural-Processing-Unit，神经网络处理单元）\" class=\"headerlink\" title=\"NPU （Neural Processing Unit，神经网络处理单元）\"></a>NPU <strong>（Neural Processing Unit，神经网络处理单元）</strong></h2><p>按照上文所述，CPU 和 GPU 都是较为通用的芯片，但是随着人们的计算需求越来越专业化，人们希望有芯片可以更加符合自己的专业需求，这时，便产生了 ASIC（专用集成电路）的概念。</p>\n<p>ASIC 是指依产品需求不同而定制化的特殊规格集成电路，由特定使用者要求和特定电子系统的需要而设计、制造。当然这概念不用记，简单来说就是<strong>定制化芯片。</strong></p>\n<p><strong>因为 ASIC 很“专一”，只做一件事，所以就会比 CPU、GPU 等能做很多件事的芯片在某件事上做的更好，实现更高的处理速度和更低的能耗。但相应的，ASIC 的生产成本也非常高。</strong></p>\n<blockquote>\n<p><a href=\"https://www.cnblogs.com/wujianming-110117/p/18240352\">NPU 与超异构计算杂谈 - 吴建明 wujianming - 博客园</a></p>\n</blockquote>\n<p><img src=\"https://gitee.com/tanke11223344/imagehost/raw/main/blog/1749359439854BAVzbOB4Goo5lOxgYorcpuHCnXf.png\" alt=\"1749359439854BAVzbOB4Goo5lOxgYorcpuHCnXf.png\"></p>\n<ul>\n<li>定义：专为深度学习推理（Inference）设计的专用加速器。</li>\n<li>特点：在硬件层面高度优化了矩阵乘加运算、卷积操作，以及常见的神经网络算子，通常集成于 SoC（System-on-Chip）中，拥有极高的能效比。</li>\n</ul>\n<p>也是协处理器。在 wikipedia 中没有专门的 NPU （Neural Processing Unit） 页面，而是归到 <a href=\"https://en.wikipedia.org/wiki/AI_accelerator\">AI Processors</a> 大类里面， 指的是一类特殊目的硬件加速器，更接近 ASIC，硬件实现神经网络运算， 比如张量运算、卷积、点积、激活函数、多维矩阵运算等等。</p>\n<blockquote>\n<p>如果还不清楚什么是神经网络，可以看看 <a href=\"https://arthurchiao.art/blog/cnn-intuitive-explanation-zh/\">以图像识别为例，关于卷积神经网络（CNN）的直观解释</a><a href=\"https://arthurchiao.art/blog/cnn-intuitive-explanation-zh/\">（2016）</a>。</p>\n</blockquote>\n<p>在这些特殊任务上，比 CPU&#x2F;GPU 这种通用处理器效率更高，功耗更小，响应更快（比如一个时钟周期内可以完成几十万个乘法运算）， 因此适合用在手机、边缘计算、物联网等等场景。</p>\n<h3 id=\"应用场景-2\"><a href=\"#应用场景-2\" class=\"headerlink\" title=\"应用场景\"></a>应用场景</h3><ul>\n<li><strong>边缘端 AI 推理</strong>：智能手机（人脸识别、AI 拍照、语音助手）、智能摄像头（实时目标检测、行为分析）、物联网设备（智能音箱、家居安防）。</li>\n<li><strong>数据中心推理加速</strong>：在服务器侧为海量请求提供低延迟 AI 预测（如推荐系统、在线广告投放）。</li>\n<li><strong>专用智能芯片（如 AI 手机 SoC、智能驾驶芯片）</strong>：为计算机视觉、自动驾驶、工业检测等应用提供高效算力。</li>\n</ul>\n<h2 id=\"TPU-（-Tensor-Processing-Unit-张量处理单元）\"><a href=\"#TPU-（-Tensor-Processing-Unit-张量处理单元）\" class=\"headerlink\" title=\"TPU （ Tensor Processing Unit 张量处理单元）\"></a>TPU （ Tensor Processing Unit 张量处理单元）</h2><blockquote>\n<ul>\n<li><a href=\"https://arxiv.org/abs/1704.04760\">In-Datacenter Performance Analysis of a Tensor Processing Unit</a>(论文)</li>\n<li><a href=\"https://zhuanlan.zhihu.com/p/26882794\">Google 深度揭秘 TPU：一文看懂运算原理，以及为何碾压 GPU</a></li>\n<li><a href=\"https://www.cnblogs.com/wujianming-110117/p/16333077.html\">TPU 原理技术与 xPU - 吴建明 wujianming - 博客园</a></li>\n</ul>\n</blockquote>\n<p>TPU：这里特制 Google 的 Tensor Processing Unit，目的跟 NPU 差不多。对 TPU 和 GPU 的使用场景区别有一个非常形象的比喻：</p>\n<blockquote>\n<p>如果外面下雨了，你其实并不需要知道每秒到底有多少滴雨， 而只要知道雨是大还是小。 与此类似，神经网络通常不需要 16&#x2F;32bit 浮点数做精确计算，可能 8bit 整型预测的精度就足以满足需求了。</p>\n</blockquote>\n<h3 id=\"RISC，CISC-和-TPU-指令集\"><a href=\"#RISC，CISC-和-TPU-指令集\" class=\"headerlink\" title=\"RISC，CISC 和 TPU 指令集\"></a>RISC，CISC 和 TPU 指令集</h3><p>可编程性是 TPU 的另一个重要设计目标。TPU 不是设计用来运行某一种神经网络，而是要能加速许多不同类型的模型。</p>\n<p>大多数当代 CPU 都采用了精简指令集(RISC)。但 Google 选择复杂指令集(CISC)作为 TPU 指令集的基础，这一指令集侧重于运行更复杂的任务。</p>\n<p><img src=\"https://gitee.com/tanke11223344/imagehost/raw/main/blog/1749359477855MLA4btRsFoybvux8t65cel3pnje.png\" alt=\"1749359477855MLA4btRsFoybvux8t65cel3pnje.png\"></p>\n<p>TPU 包括以下计算资源：</p>\n<ul>\n<li>矩阵乘法单元(MUX)：65,536 个 8 位乘法和加法单元，运行矩阵计算</li>\n<li>统一缓冲(UB)：作为寄存器工作的 24MB 容量 SRAM</li>\n<li>激活单元(AU)：硬件连接的激活函数</li>\n</ul>\n<h3 id=\"矩阵乘法单元的并行计算\"><a href=\"#矩阵乘法单元的并行计算\" class=\"headerlink\" title=\"矩阵乘法单元的并行计算\"></a>矩阵乘法单元的并行计算</h3><p><img src=\"https://gitee.com/tanke11223344/imagehost/raw/main/blog/1749359489852Mu3PbFejZoqWdmxvDQLcvDnAnEe.gif\" alt=\"1749359489852Mu3PbFejZoqWdmxvDQLcvDnAnEe.gif\"></p>\n<p>Google TPU 中通过 MAC 模块进行矩阵乘法的加速，官方给出的加速矩阵乘法运算示意图如上 Google 为其设计了 MXU 作为矩阵处理器，可以在单个时钟周期内处理数十万次运算，也就是矩阵（Matrix）运算。</p>\n<h3 id=\"脉动阵列\"><a href=\"#脉动阵列\" class=\"headerlink\" title=\"脉动阵列\"></a>脉动阵列</h3><p><img src=\"https://gitee.com/tanke11223344/imagehost/raw/main/blog/1749359504852Gh9Abp8gToml6TxEiipc6UYKnvb.png\" alt=\"1749359504852Gh9Abp8gToml6TxEiipc6UYKnvb.png\"></p>\n<p>MXU 有着与传统 CPU、GPU 截然不同的架构，称为脉动阵列（systolic array）。之所以叫“脉动”，是因为在这种结构中，数据一波一波地流过芯片，与心脏跳动供血的方式类似。</p>\n<h2 id=\"架构上的主要区别\"><a href=\"#架构上的主要区别\" class=\"headerlink\" title=\"架构上的主要区别\"></a>架构上的主要区别</h2><p>以上对比可概括为：</p>\n<ul>\n<li><strong>CPU</strong>：“万金油”式处理器，几乎什么都能做，但不擅长大规模并行计算；</li>\n<li><strong>GPU</strong>：并行吞吐巨大的加速引擎，不仅做图形，还广泛用于深度学习训练；</li>\n<li><strong>NPU</strong>：进一步聚焦于 AI 推理，将神经网络最常用的算子在硬件层面高度裁剪，能耗与性能比最优。</li>\n</ul>\n<hr>\n<h1 id=\"发展现状与应用前景\"><a href=\"#发展现状与应用前景\" class=\"headerlink\" title=\"发展现状与应用前景\"></a>发展现状与应用前景</h1><h2 id=\"CPU-未来动向\"><a href=\"#CPU-未来动向\" class=\"headerlink\" title=\"CPU 未来动向\"></a>CPU 未来动向</h2><ul>\n<li><strong>专用指令集扩展</strong>：为了更好地兼顾 AI 推理性能，现代 CPU 已在向量指令（如 Intel AVX-512、ARM SVE）倾斜。</li>\n<li><strong>异构集成</strong>：如 AMD 的 APU、Intel 的集成显卡（iGPU），未来更多 SoC 将把 CPU、GPU、NPU 三者集成在一个芯片内，形成协同加速。</li>\n<li><strong>边缘侧轻量化 AI 推理</strong>：通过框架优化（如 ONNX Runtime）在 CPU 上做低精度推理（INT8&#x2F;FP16），降低能耗。</li>\n</ul>\n<h2 id=\"GPU-的发展趋势\"><a href=\"#GPU-的发展趋势\" class=\"headerlink\" title=\"GPU 的发展趋势\"></a>GPU 的发展趋势</h2><ul>\n<li><strong>Tensor 核心与混合精度</strong>：从 NVIDIA 的 Volta 架构开始，GPU 内已集成专用张量核心（Tensor Core），提高深度学习训练&#x2F;推理效率。</li>\n<li><strong>异构并行</strong>：更多厂商（AMD、Intel、以及新兴的 AI 芯片公司）推出专用于 AI 的 GPU 级别加速器，支持 FP16、INT8、INT4 等低精度运算。</li>\n<li><strong>云端与数据中心规模化部署</strong>：GPU 在云计算平台（AWS、Azure、Google Cloud）作为主力推理与训练设备，将继续占据主流地位。</li>\n</ul>\n<h2 id=\"NPU-的前景展望\"><a href=\"#NPU-的前景展望\" class=\"headerlink\" title=\"NPU 的前景展望\"></a>NPU 的前景展望</h2><ul>\n<li><strong>能效领先</strong>：随着 5G+IoT+AIoT 的普及，边缘端对低功耗高效能的 AI 芯片需求激增，NPU 市场规模将持续扩大。</li>\n<li><strong>集成化与定制化</strong>：手机 SoC（如华为麒麟、苹果 A 系列）以及汽车&#x2F;工业级芯片中将越来越普遍地集成 NPU；同时，也会出现多种定制化 NPU（例如自动驾驶专用 NPU、医疗影像专用 NPU）。</li>\n<li><strong>GPNPU（GPU + NPU 的融合）</strong>：未来会有更多将 GPU 与 NPU 功能融合在一颗芯片上的设计，以兼顾通用并行计算与 AI 推理效率，推动 AI 端云协同。</li>\n<li><strong>生态与软件栈完善</strong>：从硬件到软件框架（如 TensorRT、OpenVINO、NNAdapter、CAMERA），都将围绕 NPU 优化，使开发者可以更方便地将模型部署到 NPU 上。</li>\n</ul>\n<hr>\n<h1 id=\"总结\"><a href=\"#总结\" class=\"headerlink\" title=\"总结\"></a>总结</h1><p>CPU（中央处理器）适合通用计算，处理广泛任务但不擅长并行处理。GPU（图形处理器）专为并行任务设计，广泛用于图形渲染和 AI 模型训练。NPU（神经处理单元）优化 AI 和机器学习任务，特别在边缘计算中因能效高而受青睐。未来，NPU 可能更多集成到移动设备和 IoT 设备中，GPU 继续主导 AI 训练和高性能计算，CPU 维持通用计算核心。</p>\n<p>CPU、GPU 和 NPU 是现代计算的核心组件，各有独特功能和应用。CPU（中央处理器）是通用计算的核心，设计上处理广泛任务，如运行操作系统和生产力软件，但不擅长并行处理。GPU（图形处理器）专为并行任务优化，拥有数千核心，适合图形渲染和 AI 模型训练，如深度学习加速。NPU（神经处理单元）则是为 AI 和机器学习设计，优化矩阵运算，能效高，特别适合边缘计算和实时 AI 任务，如智能手机的图像识别。</p>\n<blockquote>\n<p><strong>小结</strong>：</p>\n<ul>\n<li>在通用计算领域，<strong>CPU</strong> 依旧是基础，但其 AI 加速能力会更多依赖于向量化指令和异构协同；</li>\n<li><strong>GPU</strong> 将继续主导深度学习训练，并向 AI 推理、科学计算等方向拓展；</li>\n<li><strong>NPU</strong> 则在边缘 AI 推理场景中大放异彩，并与 GPU 形成 “端 + 云” 协同加速架构。</li>\n</ul>\n</blockquote>\n","excerpt":"","more":"<h1 id=\"CPU-GPU-NPU-的区别及应用前景\"><a href=\"#CPU-GPU-NPU-的区别及应用前景\" class=\"headerlink\" title=\"CPU-GPU-NPU 的区别及应用前景\"></a>CPU-GPU-NPU 的区别及应用前景</h1><h1 id=\"参考资料\"><a href=\"#参考资料\" class=\"headerlink\" title=\"参考资料\"></a>参考资料</h1><blockquote>\n<ul>\n<li><a href=\"https://blog.csdn.net/qq_36944952/article/details/125951835\">CPU、GPU、NPU 的区别_npu 和 gpu 区别-CSDN 博客</a></li>\n<li><a href=\"https://blog.qnap.com/zh/%E4%B8%80%E6%96%87%E7%9C%8B%E6%87%82-cpu-gpu-npu-tpu-%E6%98%AF%E4%BB%80%E9%BA%BC/\">一文看懂 CPU， GPU， NPU， TPU 是什麼？</a></li>\n<li><a href=\"https://www.cnblogs.com/geekbruce/articles/18675150\">NPU 的概念理解，以及和 CPU&#x2F;GPU 的区别解析。 - AlphaGeek - 博客园</a></li>\n<li><a href=\"https://zhuanlan.zhihu.com/p/670414115\">AI 实验室：CPU、GPU、TPU 和 NPU 的发展历程和区别</a></li>\n<li><a href=\"https://arthurchiao.github.io/blog/gpu-advanced-notes-3-zh/\">GPU 进阶笔记（三）:华为 NPU&#x2F;GPU 演进（2024）</a></li>\n</ul>\n</blockquote>\n<hr>\n<h1 id=\"概述\"><a href=\"#概述\" class=\"headerlink\" title=\"概述\"></a>概述</h1><p>现代的计算机， 大多遵守<a href=\"https://so.csdn.net/so/search?q=%E5%86%AF%E8%AF%BA%E4%BE%9D%E6%9B%BC&spm=1001.2101.3001.7020\">冯诺依曼</a>体系结构，即</p>\n<p><img src=\"https://gitee.com/tanke11223344/imagehost/raw/main/blog/1749359273853C1PzbOGpLoF9vXxxxUccT9IHnhd.png\" alt=\"1749359273853C1PzbOGpLoF9vXxxxUccT9IHnhd.png\"></p>\n<blockquote>\n<ul>\n<li>CPU，即中央处理器，是一台计算机的运算核心和控制核心。其功能主要是解释计算机指令以及处理计算机软件中的数据。CPU 由运算器、控制器、寄存器、高速缓存及实现它们之间联系的数据、控制及状态的总线构成</li>\n<li>存储器，分为外存和内存， 用于存储数据（使用二进制方式存储）</li>\n<li>输入设备，用户给计算机发号施令的设备</li>\n<li>输出设备，计算机个用户汇报结果的设备</li>\n</ul>\n</blockquote>\n<hr>\n<p><img src=\"https://gitee.com/tanke11223344/imagehost/raw/main/blog/1749359294853F2FQbuNabouwzVxKPSvcLOzmnV2.png\" alt=\"1749359294853F2FQbuNabouwzVxKPSvcLOzmnV2.png\"></p>\n<p><img src=\"https://gitee.com/tanke11223344/imagehost/raw/main/blog/1749359311853Wotpb6o17oqdBExt6LEckgMHnLF.png\" alt=\"1749359311853Wotpb6o17oqdBExt6LEckgMHnLF.png\"></p>\n<p>CPU&#x2F;GPU&#x2F;NPU 等等都是硬件芯片，简单来说，晶体管既可以用来实现逻辑控制单元， 也可以用来实现运算单元（算力）。 在芯片总面积一定的情况下，就看控制和算力怎么分。</p>\n<ul>\n<li>CPU：通用目的处理器，重逻辑控制；</li>\n<li>GPU：通用目的并行处理器（GPGPU），图形处理器；</li>\n<li>NPU：专用处理器，相比 CPU&#x2F;GPU，擅长执行更具体的计算任务。</li>\n</ul>\n<h2 id=\"CPU（Central-Processing-Unit，中央处理器）\"><a href=\"#CPU（Central-Processing-Unit，中央处理器）\" class=\"headerlink\" title=\"CPU（Central Processing Unit，中央处理器）\"></a>CPU<strong>（Central Processing Unit，中央处理器）</strong></h2><blockquote>\n<ul>\n<li><a href=\"https://www.cnblogs.com/Zhengxue/p/14232394.html\">CPU 处理器架构和工作原理浅析 - 流星泪 - 博客园</a></li>\n<li><a href=\"https://zhang-each.github.io/My-CS-Notebook/System/03-cpu/#32-%E5%9F%BA%E6%9C%AC%E7%9A%84%E5%8A%9F%E8%83%BD%E7%BB%84%E4%BB%B6\">CPU 结构</a><br>对于 CPU 的原理和结构上面两篇博客已经描述的非常清晰了，如有需要请跳转上面两个链接</li>\n</ul>\n</blockquote>\n<ul>\n<li>定义：负责执行操作系统及各类应用程序指令，以通用性强、控制流能力强见长。</li>\n<li>特点：核心数通常较少（如 4～16 核），内核频率高，善于处理复杂的分支和通用计算任务。</li>\n</ul>\n<p><img src=\"https://gitee.com/tanke11223344/imagehost/raw/main/blog/1749359324854FWMObJX3so9xi5xe9VMcloVunZf.png\" alt=\"1749359324854FWMObJX3so9xi5xe9VMcloVunZf.png\"><br><img src=\"https://gitee.com/tanke11223344/imagehost/raw/main/blog/1749359334854NddybhxCNo9zTuxUlTBcd35vnxf.png\" alt=\"1749359334854NddybhxCNo9zTuxUlTBcd35vnxf.png\"><br><img src=\"https://gitee.com/tanke11223344/imagehost/raw/main/blog/1749359345855XWfSbujSDoQ6AjxMu3gceQJRn1d.png\" alt=\"1749359345855XWfSbujSDoQ6AjxMu3gceQJRn1d.png\"></p>\n<p>大部分芯片面积都用在了逻辑单元，因此逻辑控制能力强，算力弱（相对 GPU,NPU）。</p>\n<h3 id=\"应用场景\"><a href=\"#应用场景\" class=\"headerlink\" title=\"应用场景\"></a>应用场景</h3><ul>\n<li><strong>操作系统与通用计算</strong>：执行各种应用程序逻辑、文件 I&#x2F;O、网络请求等。</li>\n<li><strong>轻量级 AI 推理</strong>：CPU 在推理任务中仍可胜任一些场景（如桌面级简单模型），但效率不及 GPU&#x2F;NPU。</li>\n<li><strong>控制流程复杂的任务</strong>：诸如数据库事务处理、复杂分支逻辑的软件。</li>\n</ul>\n<h2 id=\"GPU（Graphics-Processing-Unit，图形处理器）\"><a href=\"#GPU（Graphics-Processing-Unit，图形处理器）\" class=\"headerlink\" title=\"GPU（Graphics Processing Unit，图形处理器）\"></a>GPU<strong>（Graphics Processing Unit，图形处理器）</strong></h2><blockquote>\n<ul>\n<li><a href=\"https://zhuanlan.zhihu.com/p/34675934\">GPU 的工作原理</a></li>\n<li><a href=\"http://www.uml.org.cn/Computer/202407111.asp\">一文理清 GPU 工作原理</a></li>\n<li><a href=\"https://blog.csdn.net/u012294613/article/details/140209282\">GPU 硬件原理架构（一）</a></li>\n</ul>\n</blockquote>\n<p>显卡分为集显,核显和独显</p>\n<p><img src=\"https://gitee.com/tanke11223344/imagehost/raw/main/blog/1749359366853M81rbfVt3oEGeaxj7cYcQlKfnFe.png\" alt=\"1749359366853M81rbfVt3oEGeaxj7cYcQlKfnFe.png\"><br><img src=\"https://gitee.com/tanke11223344/imagehost/raw/main/blog/1749359378854UVDPbCqnto9k8fxRHZiczM2Xnme.png\" alt=\"1749359378854UVDPbCqnto9k8fxRHZiczM2Xnme.png\"></p>\n<ul>\n<li>定义：最初用于图形渲染，后发展为通用并行计算加速器，具备海量并行计算单元。</li>\n<li>特点：拥有数百到上千个计算核心（CUDA 核心、流处理器等），擅长大规模矩阵运算和并行数据处理。</li>\n</ul>\n<p><img src=\"https://gitee.com/tanke11223344/imagehost/raw/main/blog/1749359391853QDjibwrBgopF9vxSohgcOGoRnLh.png\" alt=\"1749359391853QDjibwrBgopF9vxSohgcOGoRnLh.png\"><br><img src=\"https://gitee.com/tanke11223344/imagehost/raw/main/blog/1749359401853EoQpbqAtgokSYrxEGZ3cnS3hnna.png\" alt=\"1749359401853EoQpbqAtgokSYrxEGZ3cnS3hnna.png\"></p>\n<p>大部分芯片面积用在了计算单元，因此并行计算能力强，但逻辑控制弱。 适合图像渲染、矩阵计算之类的并行计算场景。作为协处理器，需要在 CPU 的指挥下工作。</p>\n<p><img src=\"https://gitee.com/tanke11223344/imagehost/raw/main/blog/1749359412854Ct5AbHn4MopusoxweETcLJoXnYc.png\" alt=\"1749359412854Ct5AbHn4MopusoxweETcLJoXnYc.png\"></p>\n<h3 id=\"应用场景-1\"><a href=\"#应用场景-1\" class=\"headerlink\" title=\"应用场景\"></a>应用场景</h3><ul>\n<li><strong>图形渲染与游戏</strong>：2D&#x2F;3D 渲染、物理特效计算。</li>\n<li><strong>深度学习训练</strong>：TensorFlow、PyTorch 等框架常将张量运算 offload 到 GPU，借助其大规模并行加速矩阵运算。</li>\n<li><strong>科学与工程计算</strong>：大规模数值仿真、视频转码、加密&#x2F;解密算法（通过 CUDA&#x2F;OpenCL）。</li>\n</ul>\n<h3 id=\"CUDA\"><a href=\"#CUDA\" class=\"headerlink\" title=\"CUDA\"></a>CUDA</h3><p>CUDA 是 NVIDIA 推出的并行计算平台与编程模型，允许开发者使用 C&#x2F;C++（以及其他语言绑定）直接在 GPU 上编写并行代码，将大量浮点与整数运算分配给成百上千个并行执行的 CUDA 核心，从而在深度学习训练、科学计算、图像处理等领域显著提升计算性能。</p>\n<p><img src=\"https://gitee.com/tanke11223344/imagehost/raw/main/blog/1749359428857MbQjb1NEHodtObxEWX7cXdavnQe.png\" alt=\"1749359428857MbQjb1NEHodtObxEWX7cXdavnQe.png\"></p>\n<p>在这个框架下，CUDA 就像一座“软件桥梁”：它对上层开发者提供了一套统一的 API，开发者只需在 Python、C++ 中调用相应接口，就能将运算任务提交给 GPU；对下层，CUDA 又会自动将这些高层调用翻译成不同 GPU 架构所需的低阶指令。</p>\n<p>不论是图形渲染、AI 推理，还是流体模拟等数值运算，都要经过这层“中介”，由 CUDA 负责调度和分派运算到各个并行核心。这样一来，开发者无需关心底层硬件如何切分任务、如何分配资源，只需调用高层接口，就能一键触发 GPU 的海量并行加速，极大简化了并行编程的复杂度。</p>\n<h2 id=\"NPU-（Neural-Processing-Unit，神经网络处理单元）\"><a href=\"#NPU-（Neural-Processing-Unit，神经网络处理单元）\" class=\"headerlink\" title=\"NPU （Neural Processing Unit，神经网络处理单元）\"></a>NPU <strong>（Neural Processing Unit，神经网络处理单元）</strong></h2><p>按照上文所述，CPU 和 GPU 都是较为通用的芯片，但是随着人们的计算需求越来越专业化，人们希望有芯片可以更加符合自己的专业需求，这时，便产生了 ASIC（专用集成电路）的概念。</p>\n<p>ASIC 是指依产品需求不同而定制化的特殊规格集成电路，由特定使用者要求和特定电子系统的需要而设计、制造。当然这概念不用记，简单来说就是<strong>定制化芯片。</strong></p>\n<p><strong>因为 ASIC 很“专一”，只做一件事，所以就会比 CPU、GPU 等能做很多件事的芯片在某件事上做的更好，实现更高的处理速度和更低的能耗。但相应的，ASIC 的生产成本也非常高。</strong></p>\n<blockquote>\n<p><a href=\"https://www.cnblogs.com/wujianming-110117/p/18240352\">NPU 与超异构计算杂谈 - 吴建明 wujianming - 博客园</a></p>\n</blockquote>\n<p><img src=\"https://gitee.com/tanke11223344/imagehost/raw/main/blog/1749359439854BAVzbOB4Goo5lOxgYorcpuHCnXf.png\" alt=\"1749359439854BAVzbOB4Goo5lOxgYorcpuHCnXf.png\"></p>\n<ul>\n<li>定义：专为深度学习推理（Inference）设计的专用加速器。</li>\n<li>特点：在硬件层面高度优化了矩阵乘加运算、卷积操作，以及常见的神经网络算子，通常集成于 SoC（System-on-Chip）中，拥有极高的能效比。</li>\n</ul>\n<p>也是协处理器。在 wikipedia 中没有专门的 NPU （Neural Processing Unit） 页面，而是归到 <a href=\"https://en.wikipedia.org/wiki/AI_accelerator\">AI Processors</a> 大类里面， 指的是一类特殊目的硬件加速器，更接近 ASIC，硬件实现神经网络运算， 比如张量运算、卷积、点积、激活函数、多维矩阵运算等等。</p>\n<blockquote>\n<p>如果还不清楚什么是神经网络，可以看看 <a href=\"https://arthurchiao.art/blog/cnn-intuitive-explanation-zh/\">以图像识别为例，关于卷积神经网络（CNN）的直观解释</a><a href=\"https://arthurchiao.art/blog/cnn-intuitive-explanation-zh/\">（2016）</a>。</p>\n</blockquote>\n<p>在这些特殊任务上，比 CPU&#x2F;GPU 这种通用处理器效率更高，功耗更小，响应更快（比如一个时钟周期内可以完成几十万个乘法运算）， 因此适合用在手机、边缘计算、物联网等等场景。</p>\n<h3 id=\"应用场景-2\"><a href=\"#应用场景-2\" class=\"headerlink\" title=\"应用场景\"></a>应用场景</h3><ul>\n<li><strong>边缘端 AI 推理</strong>：智能手机（人脸识别、AI 拍照、语音助手）、智能摄像头（实时目标检测、行为分析）、物联网设备（智能音箱、家居安防）。</li>\n<li><strong>数据中心推理加速</strong>：在服务器侧为海量请求提供低延迟 AI 预测（如推荐系统、在线广告投放）。</li>\n<li><strong>专用智能芯片（如 AI 手机 SoC、智能驾驶芯片）</strong>：为计算机视觉、自动驾驶、工业检测等应用提供高效算力。</li>\n</ul>\n<h2 id=\"TPU-（-Tensor-Processing-Unit-张量处理单元）\"><a href=\"#TPU-（-Tensor-Processing-Unit-张量处理单元）\" class=\"headerlink\" title=\"TPU （ Tensor Processing Unit 张量处理单元）\"></a>TPU （ Tensor Processing Unit 张量处理单元）</h2><blockquote>\n<ul>\n<li><a href=\"https://arxiv.org/abs/1704.04760\">In-Datacenter Performance Analysis of a Tensor Processing Unit</a>(论文)</li>\n<li><a href=\"https://zhuanlan.zhihu.com/p/26882794\">Google 深度揭秘 TPU：一文看懂运算原理，以及为何碾压 GPU</a></li>\n<li><a href=\"https://www.cnblogs.com/wujianming-110117/p/16333077.html\">TPU 原理技术与 xPU - 吴建明 wujianming - 博客园</a></li>\n</ul>\n</blockquote>\n<p>TPU：这里特制 Google 的 Tensor Processing Unit，目的跟 NPU 差不多。对 TPU 和 GPU 的使用场景区别有一个非常形象的比喻：</p>\n<blockquote>\n<p>如果外面下雨了，你其实并不需要知道每秒到底有多少滴雨， 而只要知道雨是大还是小。 与此类似，神经网络通常不需要 16&#x2F;32bit 浮点数做精确计算，可能 8bit 整型预测的精度就足以满足需求了。</p>\n</blockquote>\n<h3 id=\"RISC，CISC-和-TPU-指令集\"><a href=\"#RISC，CISC-和-TPU-指令集\" class=\"headerlink\" title=\"RISC，CISC 和 TPU 指令集\"></a>RISC，CISC 和 TPU 指令集</h3><p>可编程性是 TPU 的另一个重要设计目标。TPU 不是设计用来运行某一种神经网络，而是要能加速许多不同类型的模型。</p>\n<p>大多数当代 CPU 都采用了精简指令集(RISC)。但 Google 选择复杂指令集(CISC)作为 TPU 指令集的基础，这一指令集侧重于运行更复杂的任务。</p>\n<p><img src=\"https://gitee.com/tanke11223344/imagehost/raw/main/blog/1749359477855MLA4btRsFoybvux8t65cel3pnje.png\" alt=\"1749359477855MLA4btRsFoybvux8t65cel3pnje.png\"></p>\n<p>TPU 包括以下计算资源：</p>\n<ul>\n<li>矩阵乘法单元(MUX)：65,536 个 8 位乘法和加法单元，运行矩阵计算</li>\n<li>统一缓冲(UB)：作为寄存器工作的 24MB 容量 SRAM</li>\n<li>激活单元(AU)：硬件连接的激活函数</li>\n</ul>\n<h3 id=\"矩阵乘法单元的并行计算\"><a href=\"#矩阵乘法单元的并行计算\" class=\"headerlink\" title=\"矩阵乘法单元的并行计算\"></a>矩阵乘法单元的并行计算</h3><p><img src=\"https://gitee.com/tanke11223344/imagehost/raw/main/blog/1749359489852Mu3PbFejZoqWdmxvDQLcvDnAnEe.gif\" alt=\"1749359489852Mu3PbFejZoqWdmxvDQLcvDnAnEe.gif\"></p>\n<p>Google TPU 中通过 MAC 模块进行矩阵乘法的加速，官方给出的加速矩阵乘法运算示意图如上 Google 为其设计了 MXU 作为矩阵处理器，可以在单个时钟周期内处理数十万次运算，也就是矩阵（Matrix）运算。</p>\n<h3 id=\"脉动阵列\"><a href=\"#脉动阵列\" class=\"headerlink\" title=\"脉动阵列\"></a>脉动阵列</h3><p><img src=\"https://gitee.com/tanke11223344/imagehost/raw/main/blog/1749359504852Gh9Abp8gToml6TxEiipc6UYKnvb.png\" alt=\"1749359504852Gh9Abp8gToml6TxEiipc6UYKnvb.png\"></p>\n<p>MXU 有着与传统 CPU、GPU 截然不同的架构，称为脉动阵列（systolic array）。之所以叫“脉动”，是因为在这种结构中，数据一波一波地流过芯片，与心脏跳动供血的方式类似。</p>\n<h2 id=\"架构上的主要区别\"><a href=\"#架构上的主要区别\" class=\"headerlink\" title=\"架构上的主要区别\"></a>架构上的主要区别</h2><p>以上对比可概括为：</p>\n<ul>\n<li><strong>CPU</strong>：“万金油”式处理器，几乎什么都能做，但不擅长大规模并行计算；</li>\n<li><strong>GPU</strong>：并行吞吐巨大的加速引擎，不仅做图形，还广泛用于深度学习训练；</li>\n<li><strong>NPU</strong>：进一步聚焦于 AI 推理，将神经网络最常用的算子在硬件层面高度裁剪，能耗与性能比最优。</li>\n</ul>\n<hr>\n<h1 id=\"发展现状与应用前景\"><a href=\"#发展现状与应用前景\" class=\"headerlink\" title=\"发展现状与应用前景\"></a>发展现状与应用前景</h1><h2 id=\"CPU-未来动向\"><a href=\"#CPU-未来动向\" class=\"headerlink\" title=\"CPU 未来动向\"></a>CPU 未来动向</h2><ul>\n<li><strong>专用指令集扩展</strong>：为了更好地兼顾 AI 推理性能，现代 CPU 已在向量指令（如 Intel AVX-512、ARM SVE）倾斜。</li>\n<li><strong>异构集成</strong>：如 AMD 的 APU、Intel 的集成显卡（iGPU），未来更多 SoC 将把 CPU、GPU、NPU 三者集成在一个芯片内，形成协同加速。</li>\n<li><strong>边缘侧轻量化 AI 推理</strong>：通过框架优化（如 ONNX Runtime）在 CPU 上做低精度推理（INT8&#x2F;FP16），降低能耗。</li>\n</ul>\n<h2 id=\"GPU-的发展趋势\"><a href=\"#GPU-的发展趋势\" class=\"headerlink\" title=\"GPU 的发展趋势\"></a>GPU 的发展趋势</h2><ul>\n<li><strong>Tensor 核心与混合精度</strong>：从 NVIDIA 的 Volta 架构开始，GPU 内已集成专用张量核心（Tensor Core），提高深度学习训练&#x2F;推理效率。</li>\n<li><strong>异构并行</strong>：更多厂商（AMD、Intel、以及新兴的 AI 芯片公司）推出专用于 AI 的 GPU 级别加速器，支持 FP16、INT8、INT4 等低精度运算。</li>\n<li><strong>云端与数据中心规模化部署</strong>：GPU 在云计算平台（AWS、Azure、Google Cloud）作为主力推理与训练设备，将继续占据主流地位。</li>\n</ul>\n<h2 id=\"NPU-的前景展望\"><a href=\"#NPU-的前景展望\" class=\"headerlink\" title=\"NPU 的前景展望\"></a>NPU 的前景展望</h2><ul>\n<li><strong>能效领先</strong>：随着 5G+IoT+AIoT 的普及，边缘端对低功耗高效能的 AI 芯片需求激增，NPU 市场规模将持续扩大。</li>\n<li><strong>集成化与定制化</strong>：手机 SoC（如华为麒麟、苹果 A 系列）以及汽车&#x2F;工业级芯片中将越来越普遍地集成 NPU；同时，也会出现多种定制化 NPU（例如自动驾驶专用 NPU、医疗影像专用 NPU）。</li>\n<li><strong>GPNPU（GPU + NPU 的融合）</strong>：未来会有更多将 GPU 与 NPU 功能融合在一颗芯片上的设计，以兼顾通用并行计算与 AI 推理效率，推动 AI 端云协同。</li>\n<li><strong>生态与软件栈完善</strong>：从硬件到软件框架（如 TensorRT、OpenVINO、NNAdapter、CAMERA），都将围绕 NPU 优化，使开发者可以更方便地将模型部署到 NPU 上。</li>\n</ul>\n<hr>\n<h1 id=\"总结\"><a href=\"#总结\" class=\"headerlink\" title=\"总结\"></a>总结</h1><p>CPU（中央处理器）适合通用计算，处理广泛任务但不擅长并行处理。GPU（图形处理器）专为并行任务设计，广泛用于图形渲染和 AI 模型训练。NPU（神经处理单元）优化 AI 和机器学习任务，特别在边缘计算中因能效高而受青睐。未来，NPU 可能更多集成到移动设备和 IoT 设备中，GPU 继续主导 AI 训练和高性能计算，CPU 维持通用计算核心。</p>\n<p>CPU、GPU 和 NPU 是现代计算的核心组件，各有独特功能和应用。CPU（中央处理器）是通用计算的核心，设计上处理广泛任务，如运行操作系统和生产力软件，但不擅长并行处理。GPU（图形处理器）专为并行任务优化，拥有数千核心，适合图形渲染和 AI 模型训练，如深度学习加速。NPU（神经处理单元）则是为 AI 和机器学习设计，优化矩阵运算，能效高，特别适合边缘计算和实时 AI 任务，如智能手机的图像识别。</p>\n<blockquote>\n<p><strong>小结</strong>：</p>\n<ul>\n<li>在通用计算领域，<strong>CPU</strong> 依旧是基础，但其 AI 加速能力会更多依赖于向量化指令和异构协同；</li>\n<li><strong>GPU</strong> 将继续主导深度学习训练，并向 AI 推理、科学计算等方向拓展；</li>\n<li><strong>NPU</strong> 则在边缘 AI 推理场景中大放异彩，并与 GPU 形成 “端 + 云” 协同加速架构。</li>\n</ul>\n</blockquote>\n"},{"title":"2025-05-08-deepseek 本地化部署","date":"2025-05-07T16:00:00.000Z","_content":"\n# 2025-05-08-deepseek 本地化部署\n\n> 参考博客\n> [本地部署 DeepSeek：小白也能轻松搞定！](https://www.cnblogs.com/xiezhr/p/18712410)\n>\n> [如何给本地部署的 DeepSeek 投喂数据，让他更懂你](https://www.cnblogs.com/xiezhr/p/18714692)\n\n**[实验目的]：**理解系统架构与原理，掌握 DeepSeek 的基本工作原理、内部架构和检索机制，了解其在大规模语义检索中的优势。学习如何在本地环境中部署和调试 DeepSeek 系统，包括环境配置、依赖安装、参数调优等关键步骤。\n\n## **我的电脑硬件配置**\n\n- CPU：英特尔酷睿 i5-13600KF 十四核\n- GPU:  4060TI 8G\n- 内存：16GB\n- 操作系统：Windows 11\n\n![17467115411301746711540958.png](https://tk-pichost-1325224430.cos.ap-chengdu.myqcloud.com/blog/17467115411301746711540958.png)\n\n# 本地部署\n\n## **下载并安装 Ollama**\n\n访问官网：[https://ollama.com/](https://ollama.com/) 下载\n\n![1746711596129JMZnbPx10ozMxux4hPTcIqtunjh.png](https://tk-pichost-1325224430.cos.ap-chengdu.myqcloud.com/blog/1746711596129JMZnbPx10ozMxux4hPTcIqtunjh.png)\n\n双击 OllamaSetup.exe 进行安装：\n\n![1746711612129TVVNbC31CoCYhDxCKkbcJSkBnDd.png](https://tk-pichost-1325224430.cos.ap-chengdu.myqcloud.com/blog/1746711612129TVVNbC31CoCYhDxCKkbcJSkBnDd.png)\n\n## **通过 Ollama 拉取 DeepSeek 模型**\n\n这里我选择是的 1.5b，整个模型大小 1.1 GB。\n\n更多版本可以在这里查看：[https://ollama.com/library/deepseek-r1](https://ollama.com/library/deepseek-r1)\n\n```bash\nollama run deepseek-r1:1.5b\n```\n\n### 终端回答\n\n![1746711633130MXyibKvdcoR5hQxMe6wca3Kknje.png](https://tk-pichost-1325224430.cos.ap-chengdu.myqcloud.com/blog/1746711633130MXyibKvdcoR5hQxMe6wca3Kknje.png)\n\n### 使用 open-webui 包回答\n\n> 注意:\n>\n> - 系统需要安装 conda 进行虚拟环境的配置,并且 webui 需要 python 版本在 3.11 才能安装\n> - Open WebUI 的核心包大小相对较小，但它会拉取一些额外的依赖包（如用于 RAG 功能的嵌入模型或前端支持的库），这些依赖可能会增加总体安装体积。例如，首次运行时，它可能会下载约 900MB 的嵌入模型（如 all-MiniLM-L6-v2）用于本地功能。\n\n#### 使用 pip 安装 open-webui 包\n\n> [GitHub - open-webui/open-webui: User-friendly AI Interface (Supports Ollama, OpenAI API, ...)](https://github.com/open-webui/open-webui)\n>\n> [DeepSeek-R1 本地部署指南：Ollama 助你轻松实现，支持 2G 显卡](https://zhuanlan.zhihu.com/p/20642808493)\n\n- **相关命令**\n\n```bash\nconda create -n webui python=3.11\n\nconda activate webui\n\npip install open-webui\n\nopen-webui serve\n```\n\n浏览器访问本地 8080 端口 http://localhost:8080\n\n可以发现 openui 的页面非常类似 chatgpt 的页面,功能也非常丰富\n\n![1746711653308NpvZbeAjYolqB1x856ucgkZ8nme.png](https://tk-pichost-1325224430.cos.ap-chengdu.myqcloud.com/blog/1746711653308NpvZbeAjYolqB1x856ucgkZ8nme.png)\n\n#### 使用 docker 安装和运行 open-webui\n\n> 注意执行命令之前打开 docker desktop\n\n- **相关命令**\n- 如果 Ollama 在您的计算机上，请使用此命令：\n\n```bash\ndocker run -d -p 3000:8080 --add-host=host.docker.internal:host-gateway -v open-webui:/app/backend/data --name open-webui --restart always ghcr.io/open-webui/open-webui:main\n```\n\n- 如果 Ollama 在不同的服务器上，请使用此命令：\n- 要连接到另一台服务器上的 Ollama，请将 `OLLAMA_BASE_URL` 更改为服务器的 URL：\n\n```bash\ndocker run -d -p 3000:8080 -e OLLAMA_BASE_URL=https://example.com -v open-webui:/app/backend/data --name open-webui --restart always ghcr.io/open-webui/open-webui:main\n```\n\n- 要使用 Nvidia GPU 支持运行 Open WebUI，请使用此命令：\n\n```bash\ndocker run -d -p 3000:8080 --gpus all --add-host=host.docker.internal:host-gateway -v open-webui:/app/backend/data --name open-webui --restart always ghcr.io/open-webui/open-webui:cuda\n```\n\n![1746711672132MNpobPZcDotI3HxC3COcLU7Gn8c.png](https://tk-pichost-1325224430.cos.ap-chengdu.myqcloud.com/blog/1746711672132MNpobPZcDotI3HxC3COcLU7Gn8c.png)\n\n![1746711689131OZBebZZ4DoPg2bxLFWLcJjp2nFe.png](https://tk-pichost-1325224430.cos.ap-chengdu.myqcloud.com/blog/1746711689131OZBebZZ4DoPg2bxLFWLcJjp2nFe.png)\n\n可以发现本地端口映射为 3000,浏览器输入对应网址 http://localhost:3000/即可进入对应的界面\n\n> 实测初始加载和响应速度比似乎用 pip 安装慢了不少,但是后面问题回答速度还是非常快的\n\n### 使用 `Page Assit` 浏览器插件回答\n\n- **WebUI****界面**\n\n![1746711710130VY2rbRym1oF4MyxeMbXcReNSnvW.png](https://tk-pichost-1325224430.cos.ap-chengdu.myqcloud.com/blog/1746711710130VY2rbRym1oF4MyxeMbXcReNSnvW.png)\n\n- **知识库**\n\n> - 使用 nomic-embed-text 文本嵌入模型\n\n[https://ollama.com/library/nomic-embed-text](https://ollama.com/library/nomic-embed-text)\n\n```bash\nollama pull nomic-embed-text\n```\n\n![1746711726064OWejb8BWloAcuVxrkFpcdQIbnve.png](https://tk-pichost-1325224430.cos.ap-chengdu.myqcloud.com/blog/1746711726064OWejb8BWloAcuVxrkFpcdQIbnve.png)\n\n- 效果\n\n![1746711742063XIL9bn9tuoRJDsxQPkucmGBTn1d.png](https://tk-pichost-1325224430.cos.ap-chengdu.myqcloud.com/blog/1746711742063XIL9bn9tuoRJDsxQPkucmGBTn1d.png)\n\n# linux 服务器部署\n\n> [Ollama Linux 部署与应用 LLama 3](https://zhuanlan.zhihu.com/p/694331045)\n\n## Linux 下 Ollama 的安装与配置\n\n```bash\ncurl -fsSL https://ollama.com/install.sh | sh\n#也许需要相应的权限才能安装，可以使用命令\nsudo curl -fsSL https://ollama.com/install.sh | sh\n```\n\n上面的命令老是网络连接出现问题,因为我使用的是 ubuntu 系统的服务器,也可以使用下面的命令安装,速度快很多\n\n```bash\nsudo snap install ollama\n```\n\n后面的步骤和在 windows11 本地部署的流程相类似,都是拉取和运行模型,再使用 docker 部署 open-webui 再访问对应的端口使用,所以对应命令我直接粘贴不再详细解释\n\n```bash\nollama run deepseek-r1:1.5b\n```\n\n> 注意后面的命令最好都添加上 sudo,以防不必要的权限报错\n\n### 启动 Docker 服务\n\n```bash\nsudo systemctl start docker\n```\n\n### 查看 Docker 服务状态\n\n```bash\nsudo systemctl status docker\n```\n\n### 使用 docker 安装 open-webui\n\n```bash\nsudo docker run -d -p 3000:8080 --add-host=host.docker.internal:host-gateway -v open-webui:/app/backend/data --name open-webui --restart always ghcr.io/open-webui/open-webui:main\n```\n\n本地端口映射为 8080,浏览器输入对应网址 http://`<ip>`:8080/即可进入对应的界面\n\n![1746711758065YRpwbq3EPoN8h7xLMrfcC2J7n5g.png](https://tk-pichost-1325224430.cos.ap-chengdu.myqcloud.com/blog/1746711758065YRpwbq3EPoN8h7xLMrfcC2J7n5g.png)\n\n### 停止 Docker 服务()\n\n```bash\nsudo systemctl stop docker\n```\n\n# 总结\n\n虽然 1.5B 和 7B 级别的小参数模型在资源占用和响应延迟方面具有明显优势，但其生成效果和理解能力相对有限，仅适用于边缘计算中的基础性任务。不过，在特定场景下仍具备一定的应用价值。对于日常生产中的高质量生成需求，仍推荐使用部署在云端服务器的大参数模型，以确保效果和稳定性。\n","source":"_posts/2025-05-08-deepseek本地化部署.md","raw":"---\ntitle: 2025-05-08-deepseek 本地化部署\ndate: 2025-05-08\ntags: \n    深度学习\n    程序开发\n---\n\n# 2025-05-08-deepseek 本地化部署\n\n> 参考博客\n> [本地部署 DeepSeek：小白也能轻松搞定！](https://www.cnblogs.com/xiezhr/p/18712410)\n>\n> [如何给本地部署的 DeepSeek 投喂数据，让他更懂你](https://www.cnblogs.com/xiezhr/p/18714692)\n\n**[实验目的]：**理解系统架构与原理，掌握 DeepSeek 的基本工作原理、内部架构和检索机制，了解其在大规模语义检索中的优势。学习如何在本地环境中部署和调试 DeepSeek 系统，包括环境配置、依赖安装、参数调优等关键步骤。\n\n## **我的电脑硬件配置**\n\n- CPU：英特尔酷睿 i5-13600KF 十四核\n- GPU:  4060TI 8G\n- 内存：16GB\n- 操作系统：Windows 11\n\n![17467115411301746711540958.png](https://tk-pichost-1325224430.cos.ap-chengdu.myqcloud.com/blog/17467115411301746711540958.png)\n\n# 本地部署\n\n## **下载并安装 Ollama**\n\n访问官网：[https://ollama.com/](https://ollama.com/) 下载\n\n![1746711596129JMZnbPx10ozMxux4hPTcIqtunjh.png](https://tk-pichost-1325224430.cos.ap-chengdu.myqcloud.com/blog/1746711596129JMZnbPx10ozMxux4hPTcIqtunjh.png)\n\n双击 OllamaSetup.exe 进行安装：\n\n![1746711612129TVVNbC31CoCYhDxCKkbcJSkBnDd.png](https://tk-pichost-1325224430.cos.ap-chengdu.myqcloud.com/blog/1746711612129TVVNbC31CoCYhDxCKkbcJSkBnDd.png)\n\n## **通过 Ollama 拉取 DeepSeek 模型**\n\n这里我选择是的 1.5b，整个模型大小 1.1 GB。\n\n更多版本可以在这里查看：[https://ollama.com/library/deepseek-r1](https://ollama.com/library/deepseek-r1)\n\n```bash\nollama run deepseek-r1:1.5b\n```\n\n### 终端回答\n\n![1746711633130MXyibKvdcoR5hQxMe6wca3Kknje.png](https://tk-pichost-1325224430.cos.ap-chengdu.myqcloud.com/blog/1746711633130MXyibKvdcoR5hQxMe6wca3Kknje.png)\n\n### 使用 open-webui 包回答\n\n> 注意:\n>\n> - 系统需要安装 conda 进行虚拟环境的配置,并且 webui 需要 python 版本在 3.11 才能安装\n> - Open WebUI 的核心包大小相对较小，但它会拉取一些额外的依赖包（如用于 RAG 功能的嵌入模型或前端支持的库），这些依赖可能会增加总体安装体积。例如，首次运行时，它可能会下载约 900MB 的嵌入模型（如 all-MiniLM-L6-v2）用于本地功能。\n\n#### 使用 pip 安装 open-webui 包\n\n> [GitHub - open-webui/open-webui: User-friendly AI Interface (Supports Ollama, OpenAI API, ...)](https://github.com/open-webui/open-webui)\n>\n> [DeepSeek-R1 本地部署指南：Ollama 助你轻松实现，支持 2G 显卡](https://zhuanlan.zhihu.com/p/20642808493)\n\n- **相关命令**\n\n```bash\nconda create -n webui python=3.11\n\nconda activate webui\n\npip install open-webui\n\nopen-webui serve\n```\n\n浏览器访问本地 8080 端口 http://localhost:8080\n\n可以发现 openui 的页面非常类似 chatgpt 的页面,功能也非常丰富\n\n![1746711653308NpvZbeAjYolqB1x856ucgkZ8nme.png](https://tk-pichost-1325224430.cos.ap-chengdu.myqcloud.com/blog/1746711653308NpvZbeAjYolqB1x856ucgkZ8nme.png)\n\n#### 使用 docker 安装和运行 open-webui\n\n> 注意执行命令之前打开 docker desktop\n\n- **相关命令**\n- 如果 Ollama 在您的计算机上，请使用此命令：\n\n```bash\ndocker run -d -p 3000:8080 --add-host=host.docker.internal:host-gateway -v open-webui:/app/backend/data --name open-webui --restart always ghcr.io/open-webui/open-webui:main\n```\n\n- 如果 Ollama 在不同的服务器上，请使用此命令：\n- 要连接到另一台服务器上的 Ollama，请将 `OLLAMA_BASE_URL` 更改为服务器的 URL：\n\n```bash\ndocker run -d -p 3000:8080 -e OLLAMA_BASE_URL=https://example.com -v open-webui:/app/backend/data --name open-webui --restart always ghcr.io/open-webui/open-webui:main\n```\n\n- 要使用 Nvidia GPU 支持运行 Open WebUI，请使用此命令：\n\n```bash\ndocker run -d -p 3000:8080 --gpus all --add-host=host.docker.internal:host-gateway -v open-webui:/app/backend/data --name open-webui --restart always ghcr.io/open-webui/open-webui:cuda\n```\n\n![1746711672132MNpobPZcDotI3HxC3COcLU7Gn8c.png](https://tk-pichost-1325224430.cos.ap-chengdu.myqcloud.com/blog/1746711672132MNpobPZcDotI3HxC3COcLU7Gn8c.png)\n\n![1746711689131OZBebZZ4DoPg2bxLFWLcJjp2nFe.png](https://tk-pichost-1325224430.cos.ap-chengdu.myqcloud.com/blog/1746711689131OZBebZZ4DoPg2bxLFWLcJjp2nFe.png)\n\n可以发现本地端口映射为 3000,浏览器输入对应网址 http://localhost:3000/即可进入对应的界面\n\n> 实测初始加载和响应速度比似乎用 pip 安装慢了不少,但是后面问题回答速度还是非常快的\n\n### 使用 `Page Assit` 浏览器插件回答\n\n- **WebUI****界面**\n\n![1746711710130VY2rbRym1oF4MyxeMbXcReNSnvW.png](https://tk-pichost-1325224430.cos.ap-chengdu.myqcloud.com/blog/1746711710130VY2rbRym1oF4MyxeMbXcReNSnvW.png)\n\n- **知识库**\n\n> - 使用 nomic-embed-text 文本嵌入模型\n\n[https://ollama.com/library/nomic-embed-text](https://ollama.com/library/nomic-embed-text)\n\n```bash\nollama pull nomic-embed-text\n```\n\n![1746711726064OWejb8BWloAcuVxrkFpcdQIbnve.png](https://tk-pichost-1325224430.cos.ap-chengdu.myqcloud.com/blog/1746711726064OWejb8BWloAcuVxrkFpcdQIbnve.png)\n\n- 效果\n\n![1746711742063XIL9bn9tuoRJDsxQPkucmGBTn1d.png](https://tk-pichost-1325224430.cos.ap-chengdu.myqcloud.com/blog/1746711742063XIL9bn9tuoRJDsxQPkucmGBTn1d.png)\n\n# linux 服务器部署\n\n> [Ollama Linux 部署与应用 LLama 3](https://zhuanlan.zhihu.com/p/694331045)\n\n## Linux 下 Ollama 的安装与配置\n\n```bash\ncurl -fsSL https://ollama.com/install.sh | sh\n#也许需要相应的权限才能安装，可以使用命令\nsudo curl -fsSL https://ollama.com/install.sh | sh\n```\n\n上面的命令老是网络连接出现问题,因为我使用的是 ubuntu 系统的服务器,也可以使用下面的命令安装,速度快很多\n\n```bash\nsudo snap install ollama\n```\n\n后面的步骤和在 windows11 本地部署的流程相类似,都是拉取和运行模型,再使用 docker 部署 open-webui 再访问对应的端口使用,所以对应命令我直接粘贴不再详细解释\n\n```bash\nollama run deepseek-r1:1.5b\n```\n\n> 注意后面的命令最好都添加上 sudo,以防不必要的权限报错\n\n### 启动 Docker 服务\n\n```bash\nsudo systemctl start docker\n```\n\n### 查看 Docker 服务状态\n\n```bash\nsudo systemctl status docker\n```\n\n### 使用 docker 安装 open-webui\n\n```bash\nsudo docker run -d -p 3000:8080 --add-host=host.docker.internal:host-gateway -v open-webui:/app/backend/data --name open-webui --restart always ghcr.io/open-webui/open-webui:main\n```\n\n本地端口映射为 8080,浏览器输入对应网址 http://`<ip>`:8080/即可进入对应的界面\n\n![1746711758065YRpwbq3EPoN8h7xLMrfcC2J7n5g.png](https://tk-pichost-1325224430.cos.ap-chengdu.myqcloud.com/blog/1746711758065YRpwbq3EPoN8h7xLMrfcC2J7n5g.png)\n\n### 停止 Docker 服务()\n\n```bash\nsudo systemctl stop docker\n```\n\n# 总结\n\n虽然 1.5B 和 7B 级别的小参数模型在资源占用和响应延迟方面具有明显优势，但其生成效果和理解能力相对有限，仅适用于边缘计算中的基础性任务。不过，在特定场景下仍具备一定的应用价值。对于日常生产中的高质量生成需求，仍推荐使用部署在云端服务器的大参数模型，以确保效果和稳定性。\n","slug":"2025-05-08-deepseek本地化部署","published":1,"updated":"2025-09-26T12:17:31.223Z","_id":"cmg0saj4a0024jm8n3j5o7rye","comments":1,"layout":"post","photos":[],"content":"<h1 id=\"2025-05-08-deepseek-本地化部署\"><a href=\"#2025-05-08-deepseek-本地化部署\" class=\"headerlink\" title=\"2025-05-08-deepseek 本地化部署\"></a>2025-05-08-deepseek 本地化部署</h1><blockquote>\n<p>参考博客<br><a href=\"https://www.cnblogs.com/xiezhr/p/18712410\">本地部署 DeepSeek：小白也能轻松搞定！</a></p>\n<p><a href=\"https://www.cnblogs.com/xiezhr/p/18714692\">如何给本地部署的 DeepSeek 投喂数据，让他更懂你</a></p>\n</blockquote>\n<p><strong>[实验目的]：</strong>理解系统架构与原理，掌握 DeepSeek 的基本工作原理、内部架构和检索机制，了解其在大规模语义检索中的优势。学习如何在本地环境中部署和调试 DeepSeek 系统，包括环境配置、依赖安装、参数调优等关键步骤。</p>\n<h2 id=\"我的电脑硬件配置\"><a href=\"#我的电脑硬件配置\" class=\"headerlink\" title=\"我的电脑硬件配置\"></a><strong>我的电脑硬件配置</strong></h2><ul>\n<li>CPU：英特尔酷睿 i5-13600KF 十四核</li>\n<li>GPU:  4060TI 8G</li>\n<li>内存：16GB</li>\n<li>操作系统：Windows 11</li>\n</ul>\n<p><img src=\"https://tk-pichost-1325224430.cos.ap-chengdu.myqcloud.com/blog/17467115411301746711540958.png\" alt=\"17467115411301746711540958.png\"></p>\n<h1 id=\"本地部署\"><a href=\"#本地部署\" class=\"headerlink\" title=\"本地部署\"></a>本地部署</h1><h2 id=\"下载并安装-Ollama\"><a href=\"#下载并安装-Ollama\" class=\"headerlink\" title=\"下载并安装 Ollama\"></a><strong>下载并安装 Ollama</strong></h2><p>访问官网：<a href=\"https://ollama.com/\">https://ollama.com/</a> 下载</p>\n<p><img src=\"https://tk-pichost-1325224430.cos.ap-chengdu.myqcloud.com/blog/1746711596129JMZnbPx10ozMxux4hPTcIqtunjh.png\" alt=\"1746711596129JMZnbPx10ozMxux4hPTcIqtunjh.png\"></p>\n<p>双击 OllamaSetup.exe 进行安装：</p>\n<p><img src=\"https://tk-pichost-1325224430.cos.ap-chengdu.myqcloud.com/blog/1746711612129TVVNbC31CoCYhDxCKkbcJSkBnDd.png\" alt=\"1746711612129TVVNbC31CoCYhDxCKkbcJSkBnDd.png\"></p>\n<h2 id=\"通过-Ollama-拉取-DeepSeek-模型\"><a href=\"#通过-Ollama-拉取-DeepSeek-模型\" class=\"headerlink\" title=\"通过 Ollama 拉取 DeepSeek 模型\"></a><strong>通过 Ollama 拉取 DeepSeek 模型</strong></h2><p>这里我选择是的 1.5b，整个模型大小 1.1 GB。</p>\n<p>更多版本可以在这里查看：<a href=\"https://ollama.com/library/deepseek-r1\">https://ollama.com/library/deepseek-r1</a></p>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">ollama run deepseek-r1:1.5b</span><br></pre></td></tr></table></figure>\n\n<h3 id=\"终端回答\"><a href=\"#终端回答\" class=\"headerlink\" title=\"终端回答\"></a>终端回答</h3><p><img src=\"https://tk-pichost-1325224430.cos.ap-chengdu.myqcloud.com/blog/1746711633130MXyibKvdcoR5hQxMe6wca3Kknje.png\" alt=\"1746711633130MXyibKvdcoR5hQxMe6wca3Kknje.png\"></p>\n<h3 id=\"使用-open-webui-包回答\"><a href=\"#使用-open-webui-包回答\" class=\"headerlink\" title=\"使用 open-webui 包回答\"></a>使用 open-webui 包回答</h3><blockquote>\n<p>注意:</p>\n<ul>\n<li>系统需要安装 conda 进行虚拟环境的配置,并且 webui 需要 python 版本在 3.11 才能安装</li>\n<li>Open WebUI 的核心包大小相对较小，但它会拉取一些额外的依赖包（如用于 RAG 功能的嵌入模型或前端支持的库），这些依赖可能会增加总体安装体积。例如，首次运行时，它可能会下载约 900MB 的嵌入模型（如 all-MiniLM-L6-v2）用于本地功能。</li>\n</ul>\n</blockquote>\n<h4 id=\"使用-pip-安装-open-webui-包\"><a href=\"#使用-pip-安装-open-webui-包\" class=\"headerlink\" title=\"使用 pip 安装 open-webui 包\"></a>使用 pip 安装 open-webui 包</h4><blockquote>\n<p><a href=\"https://github.com/open-webui/open-webui\">GitHub - open-webui&#x2F;open-webui: User-friendly AI Interface (Supports Ollama, OpenAI API, …)</a></p>\n<p><a href=\"https://zhuanlan.zhihu.com/p/20642808493\">DeepSeek-R1 本地部署指南：Ollama 助你轻松实现，支持 2G 显卡</a></p>\n</blockquote>\n<ul>\n<li><strong>相关命令</strong></li>\n</ul>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">conda create -n webui python=3.11</span><br><span class=\"line\"></span><br><span class=\"line\">conda activate webui</span><br><span class=\"line\"></span><br><span class=\"line\">pip install open-webui</span><br><span class=\"line\"></span><br><span class=\"line\">open-webui serve</span><br></pre></td></tr></table></figure>\n\n<p>浏览器访问本地 8080 端口 <a href=\"http://localhost:8080/\">http://localhost:8080</a></p>\n<p>可以发现 openui 的页面非常类似 chatgpt 的页面,功能也非常丰富</p>\n<p><img src=\"https://tk-pichost-1325224430.cos.ap-chengdu.myqcloud.com/blog/1746711653308NpvZbeAjYolqB1x856ucgkZ8nme.png\" alt=\"1746711653308NpvZbeAjYolqB1x856ucgkZ8nme.png\"></p>\n<h4 id=\"使用-docker-安装和运行-open-webui\"><a href=\"#使用-docker-安装和运行-open-webui\" class=\"headerlink\" title=\"使用 docker 安装和运行 open-webui\"></a>使用 docker 安装和运行 open-webui</h4><blockquote>\n<p>注意执行命令之前打开 docker desktop</p>\n</blockquote>\n<ul>\n<li><strong>相关命令</strong></li>\n<li>如果 Ollama 在您的计算机上，请使用此命令：</li>\n</ul>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">docker run -d -p 3000:8080 --add-host=host.docker.internal:host-gateway -v open-webui:/app/backend/data --name open-webui --restart always ghcr.io/open-webui/open-webui:main</span><br></pre></td></tr></table></figure>\n\n<ul>\n<li>如果 Ollama 在不同的服务器上，请使用此命令：</li>\n<li>要连接到另一台服务器上的 Ollama，请将 <code>OLLAMA_BASE_URL</code> 更改为服务器的 URL：</li>\n</ul>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">docker run -d -p 3000:8080 -e OLLAMA_BASE_URL=https://example.com -v open-webui:/app/backend/data --name open-webui --restart always ghcr.io/open-webui/open-webui:main</span><br></pre></td></tr></table></figure>\n\n<ul>\n<li>要使用 Nvidia GPU 支持运行 Open WebUI，请使用此命令：</li>\n</ul>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">docker run -d -p 3000:8080 --gpus all --add-host=host.docker.internal:host-gateway -v open-webui:/app/backend/data --name open-webui --restart always ghcr.io/open-webui/open-webui:cuda</span><br></pre></td></tr></table></figure>\n\n<p><img src=\"https://tk-pichost-1325224430.cos.ap-chengdu.myqcloud.com/blog/1746711672132MNpobPZcDotI3HxC3COcLU7Gn8c.png\" alt=\"1746711672132MNpobPZcDotI3HxC3COcLU7Gn8c.png\"></p>\n<p><img src=\"https://tk-pichost-1325224430.cos.ap-chengdu.myqcloud.com/blog/1746711689131OZBebZZ4DoPg2bxLFWLcJjp2nFe.png\" alt=\"1746711689131OZBebZZ4DoPg2bxLFWLcJjp2nFe.png\"></p>\n<p>可以发现本地端口映射为 3000,浏览器输入对应网址 <a href=\"http://localhost:3000/%E5%8D%B3%E5%8F%AF%E8%BF%9B%E5%85%A5%E5%AF%B9%E5%BA%94%E7%9A%84%E7%95%8C%E9%9D%A2\">http://localhost:3000/即可进入对应的界面</a></p>\n<blockquote>\n<p>实测初始加载和响应速度比似乎用 pip 安装慢了不少,但是后面问题回答速度还是非常快的</p>\n</blockquote>\n<h3 id=\"使用-Page-Assit-浏览器插件回答\"><a href=\"#使用-Page-Assit-浏览器插件回答\" class=\"headerlink\" title=\"使用 Page Assit 浏览器插件回答\"></a>使用 <code>Page Assit</code> 浏览器插件回答</h3><ul>\n<li><strong>WebUI****界面</strong></li>\n</ul>\n<p><img src=\"https://tk-pichost-1325224430.cos.ap-chengdu.myqcloud.com/blog/1746711710130VY2rbRym1oF4MyxeMbXcReNSnvW.png\" alt=\"1746711710130VY2rbRym1oF4MyxeMbXcReNSnvW.png\"></p>\n<ul>\n<li><strong>知识库</strong></li>\n</ul>\n<blockquote>\n<ul>\n<li>使用 nomic-embed-text 文本嵌入模型</li>\n</ul>\n</blockquote>\n<p><a href=\"https://ollama.com/library/nomic-embed-text\">https://ollama.com/library/nomic-embed-text</a></p>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">ollama pull nomic-embed-text</span><br></pre></td></tr></table></figure>\n\n<p><img src=\"https://tk-pichost-1325224430.cos.ap-chengdu.myqcloud.com/blog/1746711726064OWejb8BWloAcuVxrkFpcdQIbnve.png\" alt=\"1746711726064OWejb8BWloAcuVxrkFpcdQIbnve.png\"></p>\n<ul>\n<li>效果</li>\n</ul>\n<p><img src=\"https://tk-pichost-1325224430.cos.ap-chengdu.myqcloud.com/blog/1746711742063XIL9bn9tuoRJDsxQPkucmGBTn1d.png\" alt=\"1746711742063XIL9bn9tuoRJDsxQPkucmGBTn1d.png\"></p>\n<h1 id=\"linux-服务器部署\"><a href=\"#linux-服务器部署\" class=\"headerlink\" title=\"linux 服务器部署\"></a>linux 服务器部署</h1><blockquote>\n<p><a href=\"https://zhuanlan.zhihu.com/p/694331045\">Ollama Linux 部署与应用 LLama 3</a></p>\n</blockquote>\n<h2 id=\"Linux-下-Ollama-的安装与配置\"><a href=\"#Linux-下-Ollama-的安装与配置\" class=\"headerlink\" title=\"Linux 下 Ollama 的安装与配置\"></a>Linux 下 Ollama 的安装与配置</h2><figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">curl -fsSL https://ollama.com/install.sh | sh</span><br><span class=\"line\"><span class=\"comment\">#也许需要相应的权限才能安装，可以使用命令</span></span><br><span class=\"line\"><span class=\"built_in\">sudo</span> curl -fsSL https://ollama.com/install.sh | sh</span><br></pre></td></tr></table></figure>\n\n<p>上面的命令老是网络连接出现问题,因为我使用的是 ubuntu 系统的服务器,也可以使用下面的命令安装,速度快很多</p>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"built_in\">sudo</span> snap install ollama</span><br></pre></td></tr></table></figure>\n\n<p>后面的步骤和在 windows11 本地部署的流程相类似,都是拉取和运行模型,再使用 docker 部署 open-webui 再访问对应的端口使用,所以对应命令我直接粘贴不再详细解释</p>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">ollama run deepseek-r1:1.5b</span><br></pre></td></tr></table></figure>\n\n<blockquote>\n<p>注意后面的命令最好都添加上 sudo,以防不必要的权限报错</p>\n</blockquote>\n<h3 id=\"启动-Docker-服务\"><a href=\"#启动-Docker-服务\" class=\"headerlink\" title=\"启动 Docker 服务\"></a>启动 Docker 服务</h3><figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"built_in\">sudo</span> systemctl start docker</span><br></pre></td></tr></table></figure>\n\n<h3 id=\"查看-Docker-服务状态\"><a href=\"#查看-Docker-服务状态\" class=\"headerlink\" title=\"查看 Docker 服务状态\"></a>查看 Docker 服务状态</h3><figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"built_in\">sudo</span> systemctl status docker</span><br></pre></td></tr></table></figure>\n\n<h3 id=\"使用-docker-安装-open-webui\"><a href=\"#使用-docker-安装-open-webui\" class=\"headerlink\" title=\"使用 docker 安装 open-webui\"></a>使用 docker 安装 open-webui</h3><figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"built_in\">sudo</span> docker run -d -p 3000:8080 --add-host=host.docker.internal:host-gateway -v open-webui:/app/backend/data --name open-webui --restart always ghcr.io/open-webui/open-webui:main</span><br></pre></td></tr></table></figure>\n\n<p>本地端口映射为 8080,浏览器输入对应网址 http:&#x2F;&#x2F;<code>&lt;ip&gt;</code>:8080&#x2F;即可进入对应的界面</p>\n<p><img src=\"https://tk-pichost-1325224430.cos.ap-chengdu.myqcloud.com/blog/1746711758065YRpwbq3EPoN8h7xLMrfcC2J7n5g.png\" alt=\"1746711758065YRpwbq3EPoN8h7xLMrfcC2J7n5g.png\"></p>\n<h3 id=\"停止-Docker-服务\"><a href=\"#停止-Docker-服务\" class=\"headerlink\" title=\"停止 Docker 服务()\"></a>停止 Docker 服务()</h3><figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"built_in\">sudo</span> systemctl stop docker</span><br></pre></td></tr></table></figure>\n\n<h1 id=\"总结\"><a href=\"#总结\" class=\"headerlink\" title=\"总结\"></a>总结</h1><p>虽然 1.5B 和 7B 级别的小参数模型在资源占用和响应延迟方面具有明显优势，但其生成效果和理解能力相对有限，仅适用于边缘计算中的基础性任务。不过，在特定场景下仍具备一定的应用价值。对于日常生产中的高质量生成需求，仍推荐使用部署在云端服务器的大参数模型，以确保效果和稳定性。</p>\n","excerpt":"","more":"<h1 id=\"2025-05-08-deepseek-本地化部署\"><a href=\"#2025-05-08-deepseek-本地化部署\" class=\"headerlink\" title=\"2025-05-08-deepseek 本地化部署\"></a>2025-05-08-deepseek 本地化部署</h1><blockquote>\n<p>参考博客<br><a href=\"https://www.cnblogs.com/xiezhr/p/18712410\">本地部署 DeepSeek：小白也能轻松搞定！</a></p>\n<p><a href=\"https://www.cnblogs.com/xiezhr/p/18714692\">如何给本地部署的 DeepSeek 投喂数据，让他更懂你</a></p>\n</blockquote>\n<p><strong>[实验目的]：</strong>理解系统架构与原理，掌握 DeepSeek 的基本工作原理、内部架构和检索机制，了解其在大规模语义检索中的优势。学习如何在本地环境中部署和调试 DeepSeek 系统，包括环境配置、依赖安装、参数调优等关键步骤。</p>\n<h2 id=\"我的电脑硬件配置\"><a href=\"#我的电脑硬件配置\" class=\"headerlink\" title=\"我的电脑硬件配置\"></a><strong>我的电脑硬件配置</strong></h2><ul>\n<li>CPU：英特尔酷睿 i5-13600KF 十四核</li>\n<li>GPU:  4060TI 8G</li>\n<li>内存：16GB</li>\n<li>操作系统：Windows 11</li>\n</ul>\n<p><img src=\"https://tk-pichost-1325224430.cos.ap-chengdu.myqcloud.com/blog/17467115411301746711540958.png\" alt=\"17467115411301746711540958.png\"></p>\n<h1 id=\"本地部署\"><a href=\"#本地部署\" class=\"headerlink\" title=\"本地部署\"></a>本地部署</h1><h2 id=\"下载并安装-Ollama\"><a href=\"#下载并安装-Ollama\" class=\"headerlink\" title=\"下载并安装 Ollama\"></a><strong>下载并安装 Ollama</strong></h2><p>访问官网：<a href=\"https://ollama.com/\">https://ollama.com/</a> 下载</p>\n<p><img src=\"https://tk-pichost-1325224430.cos.ap-chengdu.myqcloud.com/blog/1746711596129JMZnbPx10ozMxux4hPTcIqtunjh.png\" alt=\"1746711596129JMZnbPx10ozMxux4hPTcIqtunjh.png\"></p>\n<p>双击 OllamaSetup.exe 进行安装：</p>\n<p><img src=\"https://tk-pichost-1325224430.cos.ap-chengdu.myqcloud.com/blog/1746711612129TVVNbC31CoCYhDxCKkbcJSkBnDd.png\" alt=\"1746711612129TVVNbC31CoCYhDxCKkbcJSkBnDd.png\"></p>\n<h2 id=\"通过-Ollama-拉取-DeepSeek-模型\"><a href=\"#通过-Ollama-拉取-DeepSeek-模型\" class=\"headerlink\" title=\"通过 Ollama 拉取 DeepSeek 模型\"></a><strong>通过 Ollama 拉取 DeepSeek 模型</strong></h2><p>这里我选择是的 1.5b，整个模型大小 1.1 GB。</p>\n<p>更多版本可以在这里查看：<a href=\"https://ollama.com/library/deepseek-r1\">https://ollama.com/library/deepseek-r1</a></p>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">ollama run deepseek-r1:1.5b</span><br></pre></td></tr></table></figure>\n\n<h3 id=\"终端回答\"><a href=\"#终端回答\" class=\"headerlink\" title=\"终端回答\"></a>终端回答</h3><p><img src=\"https://tk-pichost-1325224430.cos.ap-chengdu.myqcloud.com/blog/1746711633130MXyibKvdcoR5hQxMe6wca3Kknje.png\" alt=\"1746711633130MXyibKvdcoR5hQxMe6wca3Kknje.png\"></p>\n<h3 id=\"使用-open-webui-包回答\"><a href=\"#使用-open-webui-包回答\" class=\"headerlink\" title=\"使用 open-webui 包回答\"></a>使用 open-webui 包回答</h3><blockquote>\n<p>注意:</p>\n<ul>\n<li>系统需要安装 conda 进行虚拟环境的配置,并且 webui 需要 python 版本在 3.11 才能安装</li>\n<li>Open WebUI 的核心包大小相对较小，但它会拉取一些额外的依赖包（如用于 RAG 功能的嵌入模型或前端支持的库），这些依赖可能会增加总体安装体积。例如，首次运行时，它可能会下载约 900MB 的嵌入模型（如 all-MiniLM-L6-v2）用于本地功能。</li>\n</ul>\n</blockquote>\n<h4 id=\"使用-pip-安装-open-webui-包\"><a href=\"#使用-pip-安装-open-webui-包\" class=\"headerlink\" title=\"使用 pip 安装 open-webui 包\"></a>使用 pip 安装 open-webui 包</h4><blockquote>\n<p><a href=\"https://github.com/open-webui/open-webui\">GitHub - open-webui&#x2F;open-webui: User-friendly AI Interface (Supports Ollama, OpenAI API, …)</a></p>\n<p><a href=\"https://zhuanlan.zhihu.com/p/20642808493\">DeepSeek-R1 本地部署指南：Ollama 助你轻松实现，支持 2G 显卡</a></p>\n</blockquote>\n<ul>\n<li><strong>相关命令</strong></li>\n</ul>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">conda create -n webui python=3.11</span><br><span class=\"line\"></span><br><span class=\"line\">conda activate webui</span><br><span class=\"line\"></span><br><span class=\"line\">pip install open-webui</span><br><span class=\"line\"></span><br><span class=\"line\">open-webui serve</span><br></pre></td></tr></table></figure>\n\n<p>浏览器访问本地 8080 端口 <a href=\"http://localhost:8080/\">http://localhost:8080</a></p>\n<p>可以发现 openui 的页面非常类似 chatgpt 的页面,功能也非常丰富</p>\n<p><img src=\"https://tk-pichost-1325224430.cos.ap-chengdu.myqcloud.com/blog/1746711653308NpvZbeAjYolqB1x856ucgkZ8nme.png\" alt=\"1746711653308NpvZbeAjYolqB1x856ucgkZ8nme.png\"></p>\n<h4 id=\"使用-docker-安装和运行-open-webui\"><a href=\"#使用-docker-安装和运行-open-webui\" class=\"headerlink\" title=\"使用 docker 安装和运行 open-webui\"></a>使用 docker 安装和运行 open-webui</h4><blockquote>\n<p>注意执行命令之前打开 docker desktop</p>\n</blockquote>\n<ul>\n<li><strong>相关命令</strong></li>\n<li>如果 Ollama 在您的计算机上，请使用此命令：</li>\n</ul>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">docker run -d -p 3000:8080 --add-host=host.docker.internal:host-gateway -v open-webui:/app/backend/data --name open-webui --restart always ghcr.io/open-webui/open-webui:main</span><br></pre></td></tr></table></figure>\n\n<ul>\n<li>如果 Ollama 在不同的服务器上，请使用此命令：</li>\n<li>要连接到另一台服务器上的 Ollama，请将 <code>OLLAMA_BASE_URL</code> 更改为服务器的 URL：</li>\n</ul>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">docker run -d -p 3000:8080 -e OLLAMA_BASE_URL=https://example.com -v open-webui:/app/backend/data --name open-webui --restart always ghcr.io/open-webui/open-webui:main</span><br></pre></td></tr></table></figure>\n\n<ul>\n<li>要使用 Nvidia GPU 支持运行 Open WebUI，请使用此命令：</li>\n</ul>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">docker run -d -p 3000:8080 --gpus all --add-host=host.docker.internal:host-gateway -v open-webui:/app/backend/data --name open-webui --restart always ghcr.io/open-webui/open-webui:cuda</span><br></pre></td></tr></table></figure>\n\n<p><img src=\"https://tk-pichost-1325224430.cos.ap-chengdu.myqcloud.com/blog/1746711672132MNpobPZcDotI3HxC3COcLU7Gn8c.png\" alt=\"1746711672132MNpobPZcDotI3HxC3COcLU7Gn8c.png\"></p>\n<p><img src=\"https://tk-pichost-1325224430.cos.ap-chengdu.myqcloud.com/blog/1746711689131OZBebZZ4DoPg2bxLFWLcJjp2nFe.png\" alt=\"1746711689131OZBebZZ4DoPg2bxLFWLcJjp2nFe.png\"></p>\n<p>可以发现本地端口映射为 3000,浏览器输入对应网址 <a href=\"http://localhost:3000/%E5%8D%B3%E5%8F%AF%E8%BF%9B%E5%85%A5%E5%AF%B9%E5%BA%94%E7%9A%84%E7%95%8C%E9%9D%A2\">http://localhost:3000/即可进入对应的界面</a></p>\n<blockquote>\n<p>实测初始加载和响应速度比似乎用 pip 安装慢了不少,但是后面问题回答速度还是非常快的</p>\n</blockquote>\n<h3 id=\"使用-Page-Assit-浏览器插件回答\"><a href=\"#使用-Page-Assit-浏览器插件回答\" class=\"headerlink\" title=\"使用 Page Assit 浏览器插件回答\"></a>使用 <code>Page Assit</code> 浏览器插件回答</h3><ul>\n<li><strong>WebUI****界面</strong></li>\n</ul>\n<p><img src=\"https://tk-pichost-1325224430.cos.ap-chengdu.myqcloud.com/blog/1746711710130VY2rbRym1oF4MyxeMbXcReNSnvW.png\" alt=\"1746711710130VY2rbRym1oF4MyxeMbXcReNSnvW.png\"></p>\n<ul>\n<li><strong>知识库</strong></li>\n</ul>\n<blockquote>\n<ul>\n<li>使用 nomic-embed-text 文本嵌入模型</li>\n</ul>\n</blockquote>\n<p><a href=\"https://ollama.com/library/nomic-embed-text\">https://ollama.com/library/nomic-embed-text</a></p>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">ollama pull nomic-embed-text</span><br></pre></td></tr></table></figure>\n\n<p><img src=\"https://tk-pichost-1325224430.cos.ap-chengdu.myqcloud.com/blog/1746711726064OWejb8BWloAcuVxrkFpcdQIbnve.png\" alt=\"1746711726064OWejb8BWloAcuVxrkFpcdQIbnve.png\"></p>\n<ul>\n<li>效果</li>\n</ul>\n<p><img src=\"https://tk-pichost-1325224430.cos.ap-chengdu.myqcloud.com/blog/1746711742063XIL9bn9tuoRJDsxQPkucmGBTn1d.png\" alt=\"1746711742063XIL9bn9tuoRJDsxQPkucmGBTn1d.png\"></p>\n<h1 id=\"linux-服务器部署\"><a href=\"#linux-服务器部署\" class=\"headerlink\" title=\"linux 服务器部署\"></a>linux 服务器部署</h1><blockquote>\n<p><a href=\"https://zhuanlan.zhihu.com/p/694331045\">Ollama Linux 部署与应用 LLama 3</a></p>\n</blockquote>\n<h2 id=\"Linux-下-Ollama-的安装与配置\"><a href=\"#Linux-下-Ollama-的安装与配置\" class=\"headerlink\" title=\"Linux 下 Ollama 的安装与配置\"></a>Linux 下 Ollama 的安装与配置</h2><figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">curl -fsSL https://ollama.com/install.sh | sh</span><br><span class=\"line\"><span class=\"comment\">#也许需要相应的权限才能安装，可以使用命令</span></span><br><span class=\"line\"><span class=\"built_in\">sudo</span> curl -fsSL https://ollama.com/install.sh | sh</span><br></pre></td></tr></table></figure>\n\n<p>上面的命令老是网络连接出现问题,因为我使用的是 ubuntu 系统的服务器,也可以使用下面的命令安装,速度快很多</p>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"built_in\">sudo</span> snap install ollama</span><br></pre></td></tr></table></figure>\n\n<p>后面的步骤和在 windows11 本地部署的流程相类似,都是拉取和运行模型,再使用 docker 部署 open-webui 再访问对应的端口使用,所以对应命令我直接粘贴不再详细解释</p>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">ollama run deepseek-r1:1.5b</span><br></pre></td></tr></table></figure>\n\n<blockquote>\n<p>注意后面的命令最好都添加上 sudo,以防不必要的权限报错</p>\n</blockquote>\n<h3 id=\"启动-Docker-服务\"><a href=\"#启动-Docker-服务\" class=\"headerlink\" title=\"启动 Docker 服务\"></a>启动 Docker 服务</h3><figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"built_in\">sudo</span> systemctl start docker</span><br></pre></td></tr></table></figure>\n\n<h3 id=\"查看-Docker-服务状态\"><a href=\"#查看-Docker-服务状态\" class=\"headerlink\" title=\"查看 Docker 服务状态\"></a>查看 Docker 服务状态</h3><figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"built_in\">sudo</span> systemctl status docker</span><br></pre></td></tr></table></figure>\n\n<h3 id=\"使用-docker-安装-open-webui\"><a href=\"#使用-docker-安装-open-webui\" class=\"headerlink\" title=\"使用 docker 安装 open-webui\"></a>使用 docker 安装 open-webui</h3><figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"built_in\">sudo</span> docker run -d -p 3000:8080 --add-host=host.docker.internal:host-gateway -v open-webui:/app/backend/data --name open-webui --restart always ghcr.io/open-webui/open-webui:main</span><br></pre></td></tr></table></figure>\n\n<p>本地端口映射为 8080,浏览器输入对应网址 http:&#x2F;&#x2F;<code>&lt;ip&gt;</code>:8080&#x2F;即可进入对应的界面</p>\n<p><img src=\"https://tk-pichost-1325224430.cos.ap-chengdu.myqcloud.com/blog/1746711758065YRpwbq3EPoN8h7xLMrfcC2J7n5g.png\" alt=\"1746711758065YRpwbq3EPoN8h7xLMrfcC2J7n5g.png\"></p>\n<h3 id=\"停止-Docker-服务\"><a href=\"#停止-Docker-服务\" class=\"headerlink\" title=\"停止 Docker 服务()\"></a>停止 Docker 服务()</h3><figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"built_in\">sudo</span> systemctl stop docker</span><br></pre></td></tr></table></figure>\n\n<h1 id=\"总结\"><a href=\"#总结\" class=\"headerlink\" title=\"总结\"></a>总结</h1><p>虽然 1.5B 和 7B 级别的小参数模型在资源占用和响应延迟方面具有明显优势，但其生成效果和理解能力相对有限，仅适用于边缘计算中的基础性任务。不过，在特定场景下仍具备一定的应用价值。对于日常生产中的高质量生成需求，仍推荐使用部署在云端服务器的大参数模型，以确保效果和稳定性。</p>\n"},{"title":"2025-05-11-域适应(Domain Adaptation)","date":"2025-05-10T16:00:00.000Z","_content":"# 2025-05-11-域适应(Domain Adaptation)\n\n---\n\n> # 相关资源\n>\n> [【機器學習 2021】概述領域自適應 (Domain Adaptation) 李宏毅_哔哩哔哩_bilibili](https://www.bilibili.com/video/BV1TL411p7Us/)\n>\n> [20 年_86.More about Domain Adaptation (1_2)_哔哩哔哩_bilibili](https://www.bilibili.com/video/BV1aSd1YaEqb/)\n>\n> [Rules for ML2021, Spring](https://speech.ee.ntu.edu.tw/~hylee/ml/2021-spring.php)\n\n# Motivation:\n\n![1746952370351MppybvXJRo4cHvxum83cqcgcnbc.png](https://tk-pichost-1325224430.cos.ap-chengdu.myqcloud.com/blog/1746952370351MppybvXJRo4cHvxum83cqcgcnbc.png)\n\n减少源领域和目标领域之间的分布差异，使得模型能够在目标领域上有效地应用，即使目标领域的数据分布与源领域有所不同。\n\n# Method:\n\n## **1_Domain Adversarial Training (DAT)**\n\nDAT 通过构建一个 **对抗神经网络架构** 来减少源领域和目标领域之间的分布差异。这个架构通常由两个部分组成：\n\n1. **特征提取器**（Feature Extractor）：这个模块的任务是从输入数据中提取特征，不管这些数据来自源领域还是目标领域。它尽量学习到能够表示所有数据的特征。\n2. **领域判别器**（Domain Classifier）：这个模块的任务是区分数据来自源领域还是目标领域。模型的目标是让领域判别器无法判断出数据的来源，即源领域和目标领域的特征应该是不可区分的。\n3. **任务分类器**（Task Classifier）：这是模型的主任务部分，例如图像分类器、语音识别模型等。它负责根据输入数据做出相应的任务预测（如分类、回归等）,在下面的图中就是对应的 Label predictor。\n\n![1746952390480CRNkbVepCoqqFqxtObocM5vEnKd.png](https://tk-pichost-1325224430.cos.ap-chengdu.myqcloud.com/blog/1746952390480CRNkbVepCoqqFqxtObocM5vEnKd.png)\n\n> - 图中 Generator 和 Discriminator 的目标是相反的,对应的结构和 Gan 网络的结构非常的类似\n> - 公式 $\\theta_f^*=\\min {L-L_d}$中 $L_{d}$不是越小越好,因为$L_{d}$太小的话,从另外的角度 Generator 还是能够识别出 S 与 T 域之间的区别,而我们的任务是要实现 L 低的同时,Discriminator 无法识别 S 与 T 域之间的区别,但是实际训练中,对应的公式还是够用的\n\n### 目标：\n\n- **最大化任务分类器的性能**：任务分类器应该能够在源领域和目标领域的共享特征上做出正确的预测。\n- **最小化领域判别器的性能**：领域判别器应该无法区分源领域和目标领域的数据，即模型的特征表示对于源领域和目标领域是共享的。\n\n### 训练过程：\n\n- 特征提取器和任务分类器会一起训练，目标是让任务分类器在源领域和目标领域的数据上都能有效地进行任务预测。\n- 领域判别器则与特征提取器对抗训练，目的是使得特征提取器提取的特征对源领域和目标领域是不可区分的（即最大程度地消除源领域和目标领域之间的差异）。\n\n## 2_Desicion Boundary(决策边界)\n\n![1746952402479IPMwbL6jAonV7NxDa8Lcu92wn6d.png](https://tk-pichost-1325224430.cos.ap-chengdu.myqcloud.com/blog/1746952402479IPMwbL6jAonV7NxDa8Lcu92wn6d.png)\n\n1. **特征提取器（Feature Extractor）**：这是一个用于从输入图像中提取特征的模块。在图片中，未标记的图像输入通过特征提取器后，送入到后续的标签预测器中。\n2. **标签预测器（Label Predictor）**：这个模块负责根据从特征提取器获得的特征，预测标签。预测的标签是一个类别分布。\n3. **小熵（Small entropy）**：在上方的图示中，图像的标签预测分布显示出一个小的熵值，即该模型对预测类别有很强的信心，预测结果集中在一个类别上，显示为一个尖锐的条形图，表示标签的确定性。\n4. **大熵（Large entropy）**：在下方的图示中，标签预测分布的熵较大，表示模型对不同类别的预测没有明确偏向，结果显示为一个较平坦的分布图，表示模型对该数据的预测不确定。\n\n这种方法在 **决策边界迭代精炼训练（DIRT-T）** 中使用，旨在通过对未标记数据的预测熵进行优化，使得模型在决策边界附近的预测更加精确，从而提高分类性能。\n\n### **DIRT-T (Decision-boundary Iterative Refinement Training with a Teacher)**\n\n> [DIRT-T (Decision-boundary Iterative Refinement Training with a Teacher)](https://arxiv.org/abs/1802.08735)\n\n**DIRT-T** 是一种用于无监督学习的训练方法，特别是在半监督学习中常见。通过**决策边界的迭代精炼**来提升模型在无标签数据上的性能。具体来说，**DIRT-T** 通过使用“教师”模型来帮助改进“学生”模型的预测。\n\n> 有点类似知识蒸馏\n\n#### 主要概念：\n\n- **决策边界（Decision Boundary）**：模型在特征空间中划分不同类别的边界。**DIRT-T** 关注的是使得模型在决策边界附近的预测更加精确。\n- **教师模型（Teacher Model）**：这是一个预训练或较强的模型，通常在训练过程中用于为学生模型提供指导。教师模型用来生成标签或进行软标签预测，帮助学生模型进行训练。\n- **迭代精炼**：模型不断调整其在决策边界附近的预测，通过教师模型的指导，使得模型在这些边界区域的表现更加精确，逐步减少决策的模糊性。\n- **未标记数据的学习**：**DIRT-T** 通过对未标记数据进行学习，在决策边界附近加强模型的推理能力，尽量减少标签预测的错误。\n\n#### 目的：\n\n是通过教师模型的指导，在无标签数据的基础上不断调整模型的决策边界，使得模型在目标任务上的性能提升，尤其是在训练数据非常稀缺或没有标签时。\n\n### **Maximum Classifier Discrepancy (MCD)**\n\n> [Maximum Classifier Discrepancy](https://arxiv.org/abs/1712.02560)\n\n**MCD（最大分类器不一致性）** 是一种用于 **领域适应**（Domain Adaptation）和 **半监督学习** 的方法，旨在最小化源领域和目标领域之间的分布差异。其基本思想是通过最大化不同模型之间的 **分类器不一致性** 来改善领域迁移。\n\n#### 主要概念：\n\n- **分类器不一致性**：在领域适应的背景下，不同的分类器（或同一分类器在不同数据上）可能会做出不同的预测。**MCD** 试图通过最大化这种不一致性来发现领域间的差异并加以减少。\n- **最大化不一致性**：具体来说，**MCD** 方法通过引入多个模型（如源领域模型和目标领域模型）或不同的数据视角（源数据和目标数据）进行训练，并使用分类器之间的 **不一致性**（如标签预测的差异）来对模型进行优化。\n- **领域适应**：在迁移学习中，源领域（例如，带标签的数据）和目标领域（没有标签的数据）之间存在不同的分布。**MCD** 通过最大化不同分类器之间的差异，学习一个更加泛化的特征表示，减少领域间的分布差异，从而提高目标领域的性能。\n\n#### 目的：\n\n**MCD** 的目标是使得模型在源领域和目标领域上能够学习到共同的、具有广泛适用性的特征表示，从而帮助模型更好地适应目标领域的数据，尤其是在目标领域数据少或没有标签的情况下。\n\n# Resources:\n\n因为我们后面主要研究的领域是多目标域适应,后面表格对应的都是这方面的论文\n\n> 这里提供一个 github 仓库,有除了 MTDA 的其他 DA 领域的论文资源总览\n> [GitHub - zhaoxin94/awesome-domain-adaptation: A collection of AWESOME things about domian adaptation](https://github.com/zhaoxin94/awesome-domain-adaptation)\n\n<table>\n<tr>\n<td>[[1810.11547] Unsupervised Multi-Target Domain Adaptation: An Information Theoretic Approach](https://arxiv.org/abs/1810.11547)<br/></td><td>[seqam-lab/MTDA-ITA: Code for Unsupervised Multi-Target Domain Adaptation: An Information Theoretic Approach](https://github.com/seqam-lab/MTDA-ITA)<br/></td></tr>\n<tr>\n<td>[[2211.03876] CoNMix for Source-free Single and Multi-target Domain Adaptation](https://arxiv.org/abs/2211.03876)<br/></td><td><br/></td></tr>\n<tr>\n<td>[[2104.00808v1] Curriculum Graph Co-Teaching for Multi-Target Domain Adaptation](https://arxiv.org/abs/2104.00808v1)<br/></td><td><br/></td></tr>\n<tr>\n<td>[[2407.13771] Training-Free Model Merging for Multi-target Domain Adaptation](https://arxiv.org/abs/2407.13771)<br/></td><td><br/></td></tr>\n<tr>\n<td>[[2007.07077] Unsupervised Multi-Target Domain Adaptation Through Knowledge Distillation](https://arxiv.org/abs/2007.07077)<br/></td><td><br/></td></tr>\n<tr>\n<td>[[2106.03418] Multi-Target Domain Adaptation with Collaborative Consistency Learning](https://arxiv.org/abs/2106.03418)<br/></td><td><br/></td></tr>\n<tr>\n<td>[[2210.01578] Cooperative Self-Training for Multi-Target Adaptive Semantic Segmentation](https://arxiv.org/abs/2210.01578)<br/></td><td><br/></td></tr>\n<tr>\n<td>[[2401.05465] D3GU: Multi-Target Active Domain Adaptation via Enhancing Domain Alignment](https://arxiv.org/abs/2401.05465)<br/></td><td>[lzhangbj/D3GU: [WACV 2024] D3GU: Multi-target Active Domain Adaptation via Enhancing Domain Alignment](https://github.com/lzhangbj/D3GU)<br/></td></tr>\n</table>\n","source":"_posts/2025-05-11-域适应(Domain Adaptation).md","raw":"---\ntitle: 2025-05-11-域适应(Domain Adaptation)\ndate: 2025-05-11\ntags: 深度学习\n---\n# 2025-05-11-域适应(Domain Adaptation)\n\n---\n\n> # 相关资源\n>\n> [【機器學習 2021】概述領域自適應 (Domain Adaptation) 李宏毅_哔哩哔哩_bilibili](https://www.bilibili.com/video/BV1TL411p7Us/)\n>\n> [20 年_86.More about Domain Adaptation (1_2)_哔哩哔哩_bilibili](https://www.bilibili.com/video/BV1aSd1YaEqb/)\n>\n> [Rules for ML2021, Spring](https://speech.ee.ntu.edu.tw/~hylee/ml/2021-spring.php)\n\n# Motivation:\n\n![1746952370351MppybvXJRo4cHvxum83cqcgcnbc.png](https://tk-pichost-1325224430.cos.ap-chengdu.myqcloud.com/blog/1746952370351MppybvXJRo4cHvxum83cqcgcnbc.png)\n\n减少源领域和目标领域之间的分布差异，使得模型能够在目标领域上有效地应用，即使目标领域的数据分布与源领域有所不同。\n\n# Method:\n\n## **1_Domain Adversarial Training (DAT)**\n\nDAT 通过构建一个 **对抗神经网络架构** 来减少源领域和目标领域之间的分布差异。这个架构通常由两个部分组成：\n\n1. **特征提取器**（Feature Extractor）：这个模块的任务是从输入数据中提取特征，不管这些数据来自源领域还是目标领域。它尽量学习到能够表示所有数据的特征。\n2. **领域判别器**（Domain Classifier）：这个模块的任务是区分数据来自源领域还是目标领域。模型的目标是让领域判别器无法判断出数据的来源，即源领域和目标领域的特征应该是不可区分的。\n3. **任务分类器**（Task Classifier）：这是模型的主任务部分，例如图像分类器、语音识别模型等。它负责根据输入数据做出相应的任务预测（如分类、回归等）,在下面的图中就是对应的 Label predictor。\n\n![1746952390480CRNkbVepCoqqFqxtObocM5vEnKd.png](https://tk-pichost-1325224430.cos.ap-chengdu.myqcloud.com/blog/1746952390480CRNkbVepCoqqFqxtObocM5vEnKd.png)\n\n> - 图中 Generator 和 Discriminator 的目标是相反的,对应的结构和 Gan 网络的结构非常的类似\n> - 公式 $\\theta_f^*=\\min {L-L_d}$中 $L_{d}$不是越小越好,因为$L_{d}$太小的话,从另外的角度 Generator 还是能够识别出 S 与 T 域之间的区别,而我们的任务是要实现 L 低的同时,Discriminator 无法识别 S 与 T 域之间的区别,但是实际训练中,对应的公式还是够用的\n\n### 目标：\n\n- **最大化任务分类器的性能**：任务分类器应该能够在源领域和目标领域的共享特征上做出正确的预测。\n- **最小化领域判别器的性能**：领域判别器应该无法区分源领域和目标领域的数据，即模型的特征表示对于源领域和目标领域是共享的。\n\n### 训练过程：\n\n- 特征提取器和任务分类器会一起训练，目标是让任务分类器在源领域和目标领域的数据上都能有效地进行任务预测。\n- 领域判别器则与特征提取器对抗训练，目的是使得特征提取器提取的特征对源领域和目标领域是不可区分的（即最大程度地消除源领域和目标领域之间的差异）。\n\n## 2_Desicion Boundary(决策边界)\n\n![1746952402479IPMwbL6jAonV7NxDa8Lcu92wn6d.png](https://tk-pichost-1325224430.cos.ap-chengdu.myqcloud.com/blog/1746952402479IPMwbL6jAonV7NxDa8Lcu92wn6d.png)\n\n1. **特征提取器（Feature Extractor）**：这是一个用于从输入图像中提取特征的模块。在图片中，未标记的图像输入通过特征提取器后，送入到后续的标签预测器中。\n2. **标签预测器（Label Predictor）**：这个模块负责根据从特征提取器获得的特征，预测标签。预测的标签是一个类别分布。\n3. **小熵（Small entropy）**：在上方的图示中，图像的标签预测分布显示出一个小的熵值，即该模型对预测类别有很强的信心，预测结果集中在一个类别上，显示为一个尖锐的条形图，表示标签的确定性。\n4. **大熵（Large entropy）**：在下方的图示中，标签预测分布的熵较大，表示模型对不同类别的预测没有明确偏向，结果显示为一个较平坦的分布图，表示模型对该数据的预测不确定。\n\n这种方法在 **决策边界迭代精炼训练（DIRT-T）** 中使用，旨在通过对未标记数据的预测熵进行优化，使得模型在决策边界附近的预测更加精确，从而提高分类性能。\n\n### **DIRT-T (Decision-boundary Iterative Refinement Training with a Teacher)**\n\n> [DIRT-T (Decision-boundary Iterative Refinement Training with a Teacher)](https://arxiv.org/abs/1802.08735)\n\n**DIRT-T** 是一种用于无监督学习的训练方法，特别是在半监督学习中常见。通过**决策边界的迭代精炼**来提升模型在无标签数据上的性能。具体来说，**DIRT-T** 通过使用“教师”模型来帮助改进“学生”模型的预测。\n\n> 有点类似知识蒸馏\n\n#### 主要概念：\n\n- **决策边界（Decision Boundary）**：模型在特征空间中划分不同类别的边界。**DIRT-T** 关注的是使得模型在决策边界附近的预测更加精确。\n- **教师模型（Teacher Model）**：这是一个预训练或较强的模型，通常在训练过程中用于为学生模型提供指导。教师模型用来生成标签或进行软标签预测，帮助学生模型进行训练。\n- **迭代精炼**：模型不断调整其在决策边界附近的预测，通过教师模型的指导，使得模型在这些边界区域的表现更加精确，逐步减少决策的模糊性。\n- **未标记数据的学习**：**DIRT-T** 通过对未标记数据进行学习，在决策边界附近加强模型的推理能力，尽量减少标签预测的错误。\n\n#### 目的：\n\n是通过教师模型的指导，在无标签数据的基础上不断调整模型的决策边界，使得模型在目标任务上的性能提升，尤其是在训练数据非常稀缺或没有标签时。\n\n### **Maximum Classifier Discrepancy (MCD)**\n\n> [Maximum Classifier Discrepancy](https://arxiv.org/abs/1712.02560)\n\n**MCD（最大分类器不一致性）** 是一种用于 **领域适应**（Domain Adaptation）和 **半监督学习** 的方法，旨在最小化源领域和目标领域之间的分布差异。其基本思想是通过最大化不同模型之间的 **分类器不一致性** 来改善领域迁移。\n\n#### 主要概念：\n\n- **分类器不一致性**：在领域适应的背景下，不同的分类器（或同一分类器在不同数据上）可能会做出不同的预测。**MCD** 试图通过最大化这种不一致性来发现领域间的差异并加以减少。\n- **最大化不一致性**：具体来说，**MCD** 方法通过引入多个模型（如源领域模型和目标领域模型）或不同的数据视角（源数据和目标数据）进行训练，并使用分类器之间的 **不一致性**（如标签预测的差异）来对模型进行优化。\n- **领域适应**：在迁移学习中，源领域（例如，带标签的数据）和目标领域（没有标签的数据）之间存在不同的分布。**MCD** 通过最大化不同分类器之间的差异，学习一个更加泛化的特征表示，减少领域间的分布差异，从而提高目标领域的性能。\n\n#### 目的：\n\n**MCD** 的目标是使得模型在源领域和目标领域上能够学习到共同的、具有广泛适用性的特征表示，从而帮助模型更好地适应目标领域的数据，尤其是在目标领域数据少或没有标签的情况下。\n\n# Resources:\n\n因为我们后面主要研究的领域是多目标域适应,后面表格对应的都是这方面的论文\n\n> 这里提供一个 github 仓库,有除了 MTDA 的其他 DA 领域的论文资源总览\n> [GitHub - zhaoxin94/awesome-domain-adaptation: A collection of AWESOME things about domian adaptation](https://github.com/zhaoxin94/awesome-domain-adaptation)\n\n<table>\n<tr>\n<td>[[1810.11547] Unsupervised Multi-Target Domain Adaptation: An Information Theoretic Approach](https://arxiv.org/abs/1810.11547)<br/></td><td>[seqam-lab/MTDA-ITA: Code for Unsupervised Multi-Target Domain Adaptation: An Information Theoretic Approach](https://github.com/seqam-lab/MTDA-ITA)<br/></td></tr>\n<tr>\n<td>[[2211.03876] CoNMix for Source-free Single and Multi-target Domain Adaptation](https://arxiv.org/abs/2211.03876)<br/></td><td><br/></td></tr>\n<tr>\n<td>[[2104.00808v1] Curriculum Graph Co-Teaching for Multi-Target Domain Adaptation](https://arxiv.org/abs/2104.00808v1)<br/></td><td><br/></td></tr>\n<tr>\n<td>[[2407.13771] Training-Free Model Merging for Multi-target Domain Adaptation](https://arxiv.org/abs/2407.13771)<br/></td><td><br/></td></tr>\n<tr>\n<td>[[2007.07077] Unsupervised Multi-Target Domain Adaptation Through Knowledge Distillation](https://arxiv.org/abs/2007.07077)<br/></td><td><br/></td></tr>\n<tr>\n<td>[[2106.03418] Multi-Target Domain Adaptation with Collaborative Consistency Learning](https://arxiv.org/abs/2106.03418)<br/></td><td><br/></td></tr>\n<tr>\n<td>[[2210.01578] Cooperative Self-Training for Multi-Target Adaptive Semantic Segmentation](https://arxiv.org/abs/2210.01578)<br/></td><td><br/></td></tr>\n<tr>\n<td>[[2401.05465] D3GU: Multi-Target Active Domain Adaptation via Enhancing Domain Alignment](https://arxiv.org/abs/2401.05465)<br/></td><td>[lzhangbj/D3GU: [WACV 2024] D3GU: Multi-target Active Domain Adaptation via Enhancing Domain Alignment](https://github.com/lzhangbj/D3GU)<br/></td></tr>\n</table>\n","slug":"2025-05-11-域适应(Domain Adaptation)","published":1,"updated":"2025-09-26T12:17:43.892Z","_id":"cmg0saj4b0026jm8nc6xhhaon","comments":1,"layout":"post","photos":[],"content":"<h1 id=\"2025-05-11-域适应-Domain-Adaptation\"><a href=\"#2025-05-11-域适应-Domain-Adaptation\" class=\"headerlink\" title=\"2025-05-11-域适应(Domain Adaptation)\"></a>2025-05-11-域适应(Domain Adaptation)</h1><hr>\n<blockquote>\n<h1 id=\"相关资源\"><a href=\"#相关资源\" class=\"headerlink\" title=\"相关资源\"></a>相关资源</h1><p><a href=\"https://www.bilibili.com/video/BV1TL411p7Us/\">【機器學習 2021】概述領域自適應 (Domain Adaptation) 李宏毅_哔哩哔哩_bilibili</a></p>\n<p><a href=\"https://www.bilibili.com/video/BV1aSd1YaEqb/\">20 年_86.More about Domain Adaptation (1_2)_哔哩哔哩_bilibili</a></p>\n<p><a href=\"https://speech.ee.ntu.edu.tw/~hylee/ml/2021-spring.php\">Rules for ML2021, Spring</a></p>\n</blockquote>\n<h1 id=\"Motivation\"><a href=\"#Motivation\" class=\"headerlink\" title=\"Motivation:\"></a>Motivation:</h1><p><img src=\"https://tk-pichost-1325224430.cos.ap-chengdu.myqcloud.com/blog/1746952370351MppybvXJRo4cHvxum83cqcgcnbc.png\" alt=\"1746952370351MppybvXJRo4cHvxum83cqcgcnbc.png\"></p>\n<p>减少源领域和目标领域之间的分布差异，使得模型能够在目标领域上有效地应用，即使目标领域的数据分布与源领域有所不同。</p>\n<h1 id=\"Method\"><a href=\"#Method\" class=\"headerlink\" title=\"Method:\"></a>Method:</h1><h2 id=\"1-Domain-Adversarial-Training-DAT\"><a href=\"#1-Domain-Adversarial-Training-DAT\" class=\"headerlink\" title=\"1_Domain Adversarial Training (DAT)\"></a><strong>1_Domain Adversarial Training (DAT)</strong></h2><p>DAT 通过构建一个 <strong>对抗神经网络架构</strong> 来减少源领域和目标领域之间的分布差异。这个架构通常由两个部分组成：</p>\n<ol>\n<li><strong>特征提取器</strong>（Feature Extractor）：这个模块的任务是从输入数据中提取特征，不管这些数据来自源领域还是目标领域。它尽量学习到能够表示所有数据的特征。</li>\n<li><strong>领域判别器</strong>（Domain Classifier）：这个模块的任务是区分数据来自源领域还是目标领域。模型的目标是让领域判别器无法判断出数据的来源，即源领域和目标领域的特征应该是不可区分的。</li>\n<li><strong>任务分类器</strong>（Task Classifier）：这是模型的主任务部分，例如图像分类器、语音识别模型等。它负责根据输入数据做出相应的任务预测（如分类、回归等）,在下面的图中就是对应的 Label predictor。</li>\n</ol>\n<p><img src=\"https://tk-pichost-1325224430.cos.ap-chengdu.myqcloud.com/blog/1746952390480CRNkbVepCoqqFqxtObocM5vEnKd.png\" alt=\"1746952390480CRNkbVepCoqqFqxtObocM5vEnKd.png\"></p>\n<blockquote>\n<ul>\n<li>图中 Generator 和 Discriminator 的目标是相反的,对应的结构和 Gan 网络的结构非常的类似</li>\n<li>公式 $\\theta_f^*&#x3D;\\min {L-L_d}$中 $L_{d}$不是越小越好,因为$L_{d}$太小的话,从另外的角度 Generator 还是能够识别出 S 与 T 域之间的区别,而我们的任务是要实现 L 低的同时,Discriminator 无法识别 S 与 T 域之间的区别,但是实际训练中,对应的公式还是够用的</li>\n</ul>\n</blockquote>\n<h3 id=\"目标：\"><a href=\"#目标：\" class=\"headerlink\" title=\"目标：\"></a>目标：</h3><ul>\n<li><strong>最大化任务分类器的性能</strong>：任务分类器应该能够在源领域和目标领域的共享特征上做出正确的预测。</li>\n<li><strong>最小化领域判别器的性能</strong>：领域判别器应该无法区分源领域和目标领域的数据，即模型的特征表示对于源领域和目标领域是共享的。</li>\n</ul>\n<h3 id=\"训练过程：\"><a href=\"#训练过程：\" class=\"headerlink\" title=\"训练过程：\"></a>训练过程：</h3><ul>\n<li>特征提取器和任务分类器会一起训练，目标是让任务分类器在源领域和目标领域的数据上都能有效地进行任务预测。</li>\n<li>领域判别器则与特征提取器对抗训练，目的是使得特征提取器提取的特征对源领域和目标领域是不可区分的（即最大程度地消除源领域和目标领域之间的差异）。</li>\n</ul>\n<h2 id=\"2-Desicion-Boundary-决策边界\"><a href=\"#2-Desicion-Boundary-决策边界\" class=\"headerlink\" title=\"2_Desicion Boundary(决策边界)\"></a>2_Desicion Boundary(决策边界)</h2><p><img src=\"https://tk-pichost-1325224430.cos.ap-chengdu.myqcloud.com/blog/1746952402479IPMwbL6jAonV7NxDa8Lcu92wn6d.png\" alt=\"1746952402479IPMwbL6jAonV7NxDa8Lcu92wn6d.png\"></p>\n<ol>\n<li><strong>特征提取器（Feature Extractor）</strong>：这是一个用于从输入图像中提取特征的模块。在图片中，未标记的图像输入通过特征提取器后，送入到后续的标签预测器中。</li>\n<li><strong>标签预测器（Label Predictor）</strong>：这个模块负责根据从特征提取器获得的特征，预测标签。预测的标签是一个类别分布。</li>\n<li><strong>小熵（Small entropy）</strong>：在上方的图示中，图像的标签预测分布显示出一个小的熵值，即该模型对预测类别有很强的信心，预测结果集中在一个类别上，显示为一个尖锐的条形图，表示标签的确定性。</li>\n<li><strong>大熵（Large entropy）</strong>：在下方的图示中，标签预测分布的熵较大，表示模型对不同类别的预测没有明确偏向，结果显示为一个较平坦的分布图，表示模型对该数据的预测不确定。</li>\n</ol>\n<p>这种方法在 <strong>决策边界迭代精炼训练（DIRT-T）</strong> 中使用，旨在通过对未标记数据的预测熵进行优化，使得模型在决策边界附近的预测更加精确，从而提高分类性能。</p>\n<h3 id=\"DIRT-T-Decision-boundary-Iterative-Refinement-Training-with-a-Teacher\"><a href=\"#DIRT-T-Decision-boundary-Iterative-Refinement-Training-with-a-Teacher\" class=\"headerlink\" title=\"DIRT-T (Decision-boundary Iterative Refinement Training with a Teacher)\"></a><strong>DIRT-T (Decision-boundary Iterative Refinement Training with a Teacher)</strong></h3><blockquote>\n<p><a href=\"https://arxiv.org/abs/1802.08735\">DIRT-T (Decision-boundary Iterative Refinement Training with a Teacher)</a></p>\n</blockquote>\n<p><strong>DIRT-T</strong> 是一种用于无监督学习的训练方法，特别是在半监督学习中常见。通过<strong>决策边界的迭代精炼</strong>来提升模型在无标签数据上的性能。具体来说，<strong>DIRT-T</strong> 通过使用“教师”模型来帮助改进“学生”模型的预测。</p>\n<blockquote>\n<p>有点类似知识蒸馏</p>\n</blockquote>\n<h4 id=\"主要概念：\"><a href=\"#主要概念：\" class=\"headerlink\" title=\"主要概念：\"></a>主要概念：</h4><ul>\n<li><strong>决策边界（Decision Boundary）</strong>：模型在特征空间中划分不同类别的边界。<strong>DIRT-T</strong> 关注的是使得模型在决策边界附近的预测更加精确。</li>\n<li><strong>教师模型（Teacher Model）</strong>：这是一个预训练或较强的模型，通常在训练过程中用于为学生模型提供指导。教师模型用来生成标签或进行软标签预测，帮助学生模型进行训练。</li>\n<li><strong>迭代精炼</strong>：模型不断调整其在决策边界附近的预测，通过教师模型的指导，使得模型在这些边界区域的表现更加精确，逐步减少决策的模糊性。</li>\n<li><strong>未标记数据的学习</strong>：<strong>DIRT-T</strong> 通过对未标记数据进行学习，在决策边界附近加强模型的推理能力，尽量减少标签预测的错误。</li>\n</ul>\n<h4 id=\"目的：\"><a href=\"#目的：\" class=\"headerlink\" title=\"目的：\"></a>目的：</h4><p>是通过教师模型的指导，在无标签数据的基础上不断调整模型的决策边界，使得模型在目标任务上的性能提升，尤其是在训练数据非常稀缺或没有标签时。</p>\n<h3 id=\"Maximum-Classifier-Discrepancy-MCD\"><a href=\"#Maximum-Classifier-Discrepancy-MCD\" class=\"headerlink\" title=\"Maximum Classifier Discrepancy (MCD)\"></a><strong>Maximum Classifier Discrepancy (MCD)</strong></h3><blockquote>\n<p><a href=\"https://arxiv.org/abs/1712.02560\">Maximum Classifier Discrepancy</a></p>\n</blockquote>\n<p><strong>MCD（最大分类器不一致性）</strong> 是一种用于 <strong>领域适应</strong>（Domain Adaptation）和 <strong>半监督学习</strong> 的方法，旨在最小化源领域和目标领域之间的分布差异。其基本思想是通过最大化不同模型之间的 <strong>分类器不一致性</strong> 来改善领域迁移。</p>\n<h4 id=\"主要概念：-1\"><a href=\"#主要概念：-1\" class=\"headerlink\" title=\"主要概念：\"></a>主要概念：</h4><ul>\n<li><strong>分类器不一致性</strong>：在领域适应的背景下，不同的分类器（或同一分类器在不同数据上）可能会做出不同的预测。<strong>MCD</strong> 试图通过最大化这种不一致性来发现领域间的差异并加以减少。</li>\n<li><strong>最大化不一致性</strong>：具体来说，<strong>MCD</strong> 方法通过引入多个模型（如源领域模型和目标领域模型）或不同的数据视角（源数据和目标数据）进行训练，并使用分类器之间的 <strong>不一致性</strong>（如标签预测的差异）来对模型进行优化。</li>\n<li><strong>领域适应</strong>：在迁移学习中，源领域（例如，带标签的数据）和目标领域（没有标签的数据）之间存在不同的分布。<strong>MCD</strong> 通过最大化不同分类器之间的差异，学习一个更加泛化的特征表示，减少领域间的分布差异，从而提高目标领域的性能。</li>\n</ul>\n<h4 id=\"目的：-1\"><a href=\"#目的：-1\" class=\"headerlink\" title=\"目的：\"></a>目的：</h4><p><strong>MCD</strong> 的目标是使得模型在源领域和目标领域上能够学习到共同的、具有广泛适用性的特征表示，从而帮助模型更好地适应目标领域的数据，尤其是在目标领域数据少或没有标签的情况下。</p>\n<h1 id=\"Resources\"><a href=\"#Resources\" class=\"headerlink\" title=\"Resources:\"></a>Resources:</h1><p>因为我们后面主要研究的领域是多目标域适应,后面表格对应的都是这方面的论文</p>\n<blockquote>\n<p>这里提供一个 github 仓库,有除了 MTDA 的其他 DA 领域的论文资源总览<br><a href=\"https://github.com/zhaoxin94/awesome-domain-adaptation\">GitHub - zhaoxin94&#x2F;awesome-domain-adaptation: A collection of AWESOME things about domian adaptation</a></p>\n</blockquote>\n<table>\n<tr>\n<td>[[1810.11547] Unsupervised Multi-Target Domain Adaptation: An Information Theoretic Approach](https://arxiv.org/abs/1810.11547)<br/></td><td>[seqam-lab/MTDA-ITA: Code for Unsupervised Multi-Target Domain Adaptation: An Information Theoretic Approach](https://github.com/seqam-lab/MTDA-ITA)<br/></td></tr>\n<tr>\n<td>[[2211.03876] CoNMix for Source-free Single and Multi-target Domain Adaptation](https://arxiv.org/abs/2211.03876)<br/></td><td><br/></td></tr>\n<tr>\n<td>[[2104.00808v1] Curriculum Graph Co-Teaching for Multi-Target Domain Adaptation](https://arxiv.org/abs/2104.00808v1)<br/></td><td><br/></td></tr>\n<tr>\n<td>[[2407.13771] Training-Free Model Merging for Multi-target Domain Adaptation](https://arxiv.org/abs/2407.13771)<br/></td><td><br/></td></tr>\n<tr>\n<td>[[2007.07077] Unsupervised Multi-Target Domain Adaptation Through Knowledge Distillation](https://arxiv.org/abs/2007.07077)<br/></td><td><br/></td></tr>\n<tr>\n<td>[[2106.03418] Multi-Target Domain Adaptation with Collaborative Consistency Learning](https://arxiv.org/abs/2106.03418)<br/></td><td><br/></td></tr>\n<tr>\n<td>[[2210.01578] Cooperative Self-Training for Multi-Target Adaptive Semantic Segmentation](https://arxiv.org/abs/2210.01578)<br/></td><td><br/></td></tr>\n<tr>\n<td>[[2401.05465] D3GU: Multi-Target Active Domain Adaptation via Enhancing Domain Alignment](https://arxiv.org/abs/2401.05465)<br/></td><td>[lzhangbj/D3GU: [WACV 2024] D3GU: Multi-target Active Domain Adaptation via Enhancing Domain Alignment](https://github.com/lzhangbj/D3GU)<br/></td></tr>\n</table>\n","excerpt":"","more":"<h1 id=\"2025-05-11-域适应-Domain-Adaptation\"><a href=\"#2025-05-11-域适应-Domain-Adaptation\" class=\"headerlink\" title=\"2025-05-11-域适应(Domain Adaptation)\"></a>2025-05-11-域适应(Domain Adaptation)</h1><hr>\n<blockquote>\n<h1 id=\"相关资源\"><a href=\"#相关资源\" class=\"headerlink\" title=\"相关资源\"></a>相关资源</h1><p><a href=\"https://www.bilibili.com/video/BV1TL411p7Us/\">【機器學習 2021】概述領域自適應 (Domain Adaptation) 李宏毅_哔哩哔哩_bilibili</a></p>\n<p><a href=\"https://www.bilibili.com/video/BV1aSd1YaEqb/\">20 年_86.More about Domain Adaptation (1_2)_哔哩哔哩_bilibili</a></p>\n<p><a href=\"https://speech.ee.ntu.edu.tw/~hylee/ml/2021-spring.php\">Rules for ML2021, Spring</a></p>\n</blockquote>\n<h1 id=\"Motivation\"><a href=\"#Motivation\" class=\"headerlink\" title=\"Motivation:\"></a>Motivation:</h1><p><img src=\"https://tk-pichost-1325224430.cos.ap-chengdu.myqcloud.com/blog/1746952370351MppybvXJRo4cHvxum83cqcgcnbc.png\" alt=\"1746952370351MppybvXJRo4cHvxum83cqcgcnbc.png\"></p>\n<p>减少源领域和目标领域之间的分布差异，使得模型能够在目标领域上有效地应用，即使目标领域的数据分布与源领域有所不同。</p>\n<h1 id=\"Method\"><a href=\"#Method\" class=\"headerlink\" title=\"Method:\"></a>Method:</h1><h2 id=\"1-Domain-Adversarial-Training-DAT\"><a href=\"#1-Domain-Adversarial-Training-DAT\" class=\"headerlink\" title=\"1_Domain Adversarial Training (DAT)\"></a><strong>1_Domain Adversarial Training (DAT)</strong></h2><p>DAT 通过构建一个 <strong>对抗神经网络架构</strong> 来减少源领域和目标领域之间的分布差异。这个架构通常由两个部分组成：</p>\n<ol>\n<li><strong>特征提取器</strong>（Feature Extractor）：这个模块的任务是从输入数据中提取特征，不管这些数据来自源领域还是目标领域。它尽量学习到能够表示所有数据的特征。</li>\n<li><strong>领域判别器</strong>（Domain Classifier）：这个模块的任务是区分数据来自源领域还是目标领域。模型的目标是让领域判别器无法判断出数据的来源，即源领域和目标领域的特征应该是不可区分的。</li>\n<li><strong>任务分类器</strong>（Task Classifier）：这是模型的主任务部分，例如图像分类器、语音识别模型等。它负责根据输入数据做出相应的任务预测（如分类、回归等）,在下面的图中就是对应的 Label predictor。</li>\n</ol>\n<p><img src=\"https://tk-pichost-1325224430.cos.ap-chengdu.myqcloud.com/blog/1746952390480CRNkbVepCoqqFqxtObocM5vEnKd.png\" alt=\"1746952390480CRNkbVepCoqqFqxtObocM5vEnKd.png\"></p>\n<blockquote>\n<ul>\n<li>图中 Generator 和 Discriminator 的目标是相反的,对应的结构和 Gan 网络的结构非常的类似</li>\n<li>公式 $\\theta_f^*&#x3D;\\min {L-L_d}$中 $L_{d}$不是越小越好,因为$L_{d}$太小的话,从另外的角度 Generator 还是能够识别出 S 与 T 域之间的区别,而我们的任务是要实现 L 低的同时,Discriminator 无法识别 S 与 T 域之间的区别,但是实际训练中,对应的公式还是够用的</li>\n</ul>\n</blockquote>\n<h3 id=\"目标：\"><a href=\"#目标：\" class=\"headerlink\" title=\"目标：\"></a>目标：</h3><ul>\n<li><strong>最大化任务分类器的性能</strong>：任务分类器应该能够在源领域和目标领域的共享特征上做出正确的预测。</li>\n<li><strong>最小化领域判别器的性能</strong>：领域判别器应该无法区分源领域和目标领域的数据，即模型的特征表示对于源领域和目标领域是共享的。</li>\n</ul>\n<h3 id=\"训练过程：\"><a href=\"#训练过程：\" class=\"headerlink\" title=\"训练过程：\"></a>训练过程：</h3><ul>\n<li>特征提取器和任务分类器会一起训练，目标是让任务分类器在源领域和目标领域的数据上都能有效地进行任务预测。</li>\n<li>领域判别器则与特征提取器对抗训练，目的是使得特征提取器提取的特征对源领域和目标领域是不可区分的（即最大程度地消除源领域和目标领域之间的差异）。</li>\n</ul>\n<h2 id=\"2-Desicion-Boundary-决策边界\"><a href=\"#2-Desicion-Boundary-决策边界\" class=\"headerlink\" title=\"2_Desicion Boundary(决策边界)\"></a>2_Desicion Boundary(决策边界)</h2><p><img src=\"https://tk-pichost-1325224430.cos.ap-chengdu.myqcloud.com/blog/1746952402479IPMwbL6jAonV7NxDa8Lcu92wn6d.png\" alt=\"1746952402479IPMwbL6jAonV7NxDa8Lcu92wn6d.png\"></p>\n<ol>\n<li><strong>特征提取器（Feature Extractor）</strong>：这是一个用于从输入图像中提取特征的模块。在图片中，未标记的图像输入通过特征提取器后，送入到后续的标签预测器中。</li>\n<li><strong>标签预测器（Label Predictor）</strong>：这个模块负责根据从特征提取器获得的特征，预测标签。预测的标签是一个类别分布。</li>\n<li><strong>小熵（Small entropy）</strong>：在上方的图示中，图像的标签预测分布显示出一个小的熵值，即该模型对预测类别有很强的信心，预测结果集中在一个类别上，显示为一个尖锐的条形图，表示标签的确定性。</li>\n<li><strong>大熵（Large entropy）</strong>：在下方的图示中，标签预测分布的熵较大，表示模型对不同类别的预测没有明确偏向，结果显示为一个较平坦的分布图，表示模型对该数据的预测不确定。</li>\n</ol>\n<p>这种方法在 <strong>决策边界迭代精炼训练（DIRT-T）</strong> 中使用，旨在通过对未标记数据的预测熵进行优化，使得模型在决策边界附近的预测更加精确，从而提高分类性能。</p>\n<h3 id=\"DIRT-T-Decision-boundary-Iterative-Refinement-Training-with-a-Teacher\"><a href=\"#DIRT-T-Decision-boundary-Iterative-Refinement-Training-with-a-Teacher\" class=\"headerlink\" title=\"DIRT-T (Decision-boundary Iterative Refinement Training with a Teacher)\"></a><strong>DIRT-T (Decision-boundary Iterative Refinement Training with a Teacher)</strong></h3><blockquote>\n<p><a href=\"https://arxiv.org/abs/1802.08735\">DIRT-T (Decision-boundary Iterative Refinement Training with a Teacher)</a></p>\n</blockquote>\n<p><strong>DIRT-T</strong> 是一种用于无监督学习的训练方法，特别是在半监督学习中常见。通过<strong>决策边界的迭代精炼</strong>来提升模型在无标签数据上的性能。具体来说，<strong>DIRT-T</strong> 通过使用“教师”模型来帮助改进“学生”模型的预测。</p>\n<blockquote>\n<p>有点类似知识蒸馏</p>\n</blockquote>\n<h4 id=\"主要概念：\"><a href=\"#主要概念：\" class=\"headerlink\" title=\"主要概念：\"></a>主要概念：</h4><ul>\n<li><strong>决策边界（Decision Boundary）</strong>：模型在特征空间中划分不同类别的边界。<strong>DIRT-T</strong> 关注的是使得模型在决策边界附近的预测更加精确。</li>\n<li><strong>教师模型（Teacher Model）</strong>：这是一个预训练或较强的模型，通常在训练过程中用于为学生模型提供指导。教师模型用来生成标签或进行软标签预测，帮助学生模型进行训练。</li>\n<li><strong>迭代精炼</strong>：模型不断调整其在决策边界附近的预测，通过教师模型的指导，使得模型在这些边界区域的表现更加精确，逐步减少决策的模糊性。</li>\n<li><strong>未标记数据的学习</strong>：<strong>DIRT-T</strong> 通过对未标记数据进行学习，在决策边界附近加强模型的推理能力，尽量减少标签预测的错误。</li>\n</ul>\n<h4 id=\"目的：\"><a href=\"#目的：\" class=\"headerlink\" title=\"目的：\"></a>目的：</h4><p>是通过教师模型的指导，在无标签数据的基础上不断调整模型的决策边界，使得模型在目标任务上的性能提升，尤其是在训练数据非常稀缺或没有标签时。</p>\n<h3 id=\"Maximum-Classifier-Discrepancy-MCD\"><a href=\"#Maximum-Classifier-Discrepancy-MCD\" class=\"headerlink\" title=\"Maximum Classifier Discrepancy (MCD)\"></a><strong>Maximum Classifier Discrepancy (MCD)</strong></h3><blockquote>\n<p><a href=\"https://arxiv.org/abs/1712.02560\">Maximum Classifier Discrepancy</a></p>\n</blockquote>\n<p><strong>MCD（最大分类器不一致性）</strong> 是一种用于 <strong>领域适应</strong>（Domain Adaptation）和 <strong>半监督学习</strong> 的方法，旨在最小化源领域和目标领域之间的分布差异。其基本思想是通过最大化不同模型之间的 <strong>分类器不一致性</strong> 来改善领域迁移。</p>\n<h4 id=\"主要概念：-1\"><a href=\"#主要概念：-1\" class=\"headerlink\" title=\"主要概念：\"></a>主要概念：</h4><ul>\n<li><strong>分类器不一致性</strong>：在领域适应的背景下，不同的分类器（或同一分类器在不同数据上）可能会做出不同的预测。<strong>MCD</strong> 试图通过最大化这种不一致性来发现领域间的差异并加以减少。</li>\n<li><strong>最大化不一致性</strong>：具体来说，<strong>MCD</strong> 方法通过引入多个模型（如源领域模型和目标领域模型）或不同的数据视角（源数据和目标数据）进行训练，并使用分类器之间的 <strong>不一致性</strong>（如标签预测的差异）来对模型进行优化。</li>\n<li><strong>领域适应</strong>：在迁移学习中，源领域（例如，带标签的数据）和目标领域（没有标签的数据）之间存在不同的分布。<strong>MCD</strong> 通过最大化不同分类器之间的差异，学习一个更加泛化的特征表示，减少领域间的分布差异，从而提高目标领域的性能。</li>\n</ul>\n<h4 id=\"目的：-1\"><a href=\"#目的：-1\" class=\"headerlink\" title=\"目的：\"></a>目的：</h4><p><strong>MCD</strong> 的目标是使得模型在源领域和目标领域上能够学习到共同的、具有广泛适用性的特征表示，从而帮助模型更好地适应目标领域的数据，尤其是在目标领域数据少或没有标签的情况下。</p>\n<h1 id=\"Resources\"><a href=\"#Resources\" class=\"headerlink\" title=\"Resources:\"></a>Resources:</h1><p>因为我们后面主要研究的领域是多目标域适应,后面表格对应的都是这方面的论文</p>\n<blockquote>\n<p>这里提供一个 github 仓库,有除了 MTDA 的其他 DA 领域的论文资源总览<br><a href=\"https://github.com/zhaoxin94/awesome-domain-adaptation\">GitHub - zhaoxin94&#x2F;awesome-domain-adaptation: A collection of AWESOME things about domian adaptation</a></p>\n</blockquote>\n<table>\n<tr>\n<td>[[1810.11547] Unsupervised Multi-Target Domain Adaptation: An Information Theoretic Approach](https://arxiv.org/abs/1810.11547)<br/></td><td>[seqam-lab/MTDA-ITA: Code for Unsupervised Multi-Target Domain Adaptation: An Information Theoretic Approach](https://github.com/seqam-lab/MTDA-ITA)<br/></td></tr>\n<tr>\n<td>[[2211.03876] CoNMix for Source-free Single and Multi-target Domain Adaptation](https://arxiv.org/abs/2211.03876)<br/></td><td><br/></td></tr>\n<tr>\n<td>[[2104.00808v1] Curriculum Graph Co-Teaching for Multi-Target Domain Adaptation](https://arxiv.org/abs/2104.00808v1)<br/></td><td><br/></td></tr>\n<tr>\n<td>[[2407.13771] Training-Free Model Merging for Multi-target Domain Adaptation](https://arxiv.org/abs/2407.13771)<br/></td><td><br/></td></tr>\n<tr>\n<td>[[2007.07077] Unsupervised Multi-Target Domain Adaptation Through Knowledge Distillation](https://arxiv.org/abs/2007.07077)<br/></td><td><br/></td></tr>\n<tr>\n<td>[[2106.03418] Multi-Target Domain Adaptation with Collaborative Consistency Learning](https://arxiv.org/abs/2106.03418)<br/></td><td><br/></td></tr>\n<tr>\n<td>[[2210.01578] Cooperative Self-Training for Multi-Target Adaptive Semantic Segmentation](https://arxiv.org/abs/2210.01578)<br/></td><td><br/></td></tr>\n<tr>\n<td>[[2401.05465] D3GU: Multi-Target Active Domain Adaptation via Enhancing Domain Alignment](https://arxiv.org/abs/2401.05465)<br/></td><td>[lzhangbj/D3GU: [WACV 2024] D3GU: Multi-target Active Domain Adaptation via Enhancing Domain Alignment](https://github.com/lzhangbj/D3GU)<br/></td></tr>\n</table>\n"},{"title":"2025-05-11-银行家算法分析","date":"2025-05-10T16:00:00.000Z","_content":"# 银行家算法分析\n\n# 参考资料\n\n> - [操作系统——银行家算法(Banker&#39;s Algorithm) - 王陆 - 博客园](https://www.cnblogs.com/wkfvawl/p/11929508.html)\n> - [操作系统 - 《银行家算法》_1、银行家算法的应用,根据题目要求能够找到某种状态下的安全序列,当进程请求资源-CSDN 博客](https://blog.csdn.net/qq_63976098/article/details/133957267?utm_medium=distribute.pc_relevant.none-task-blog-2~default~baidujs_baidulandingword~default-0-133957267-blog-112762387.235%5Ev43%5Epc_blog_bottom_relevance_base1&spm=1001.2101.3001.4242.1&utm_relevant_index=2)\n> - [银行家算法详解与实现-CSDN 博客](https://blog.csdn.net/weixin_39478524/article/details/80604876?spm=1001.2101.3001.6650.3&utm_medium=distribute.pc_relevant.none-task-blog-2%7Edefault%7EBlogCommendFromBaidu%7ERate-3-80604876-blog-112762387.235%5Ev43%5Epc_blog_bottom_relevance_base1&depth_1-utm_source=distribute.pc_relevant.none-task-blog-2%7Edefault%7EBlogCommendFromBaidu%7ERate-3-80604876-blog-112762387.235%5Ev43%5Epc_blog_bottom_relevance_base1&utm_relevant_index=5)\n> - [GitHub - TCL606/BankerAlgorithm: 银行家算法示例](https://github.com/TCL606/BankerAlgorithm)\n\n# 概述\n\n> - [面试官:什么是死锁?怎么排查死锁?怎么避免死锁? - 小林 coding - 博客园](https://www.cnblogs.com/xiaolincoding/p/14604726.html)\n> - [死锁解析-CSDN 博客](https://blog.csdn.net/Appleeatingboy/article/details/122425760)\n\n![1749361500080AZV1b08W0oKjH6xawopc1lAMnId.png](https://gitee.com/tanke11223344/imagehost/raw/main/blog/1749361500080AZV1b08W0oKjH6xawopc1lAMnId.png)\n\n持有并等待条件导致的死锁\n\n在多进程或多线程并发访问资源的场景下，[死锁](https://zh.wikipedia.org/zh-cn/%E6%AD%BB%E9%94%81)（Deadlock）是一种让人头疼的问题：几个任务相互等待，谁也拿不到继续执行的机会。银行家算法（Banker’s Algorithm）就是荷兰计算机科学家 Dijkstra 提出的一套“贷款”式资源分配方案，保证系统不陷入死锁。\n\n---\n\n## 为什么需要银行家算法\n\n想象一家银行有一笔总资金，多个客户（进程）可能随时来申请贷款（资源）。如果不加以控制，一旦所有客户都拿走部分贷款，却留下一些客户的需求得不到满足，就可能让银行陷入“钱不够分”又“谁也不肯还款”的窘境。操作系统中的资源（内存块、I/O 通道、锁等）同理：若乱放行，很可能出现死锁，各进程互相等待而永远卡住。\n\n> 在银行中，客户申请贷款的数量是有限的，每个客户在第一次申请贷款时要声明完成该项目所需的最大资金量，在满足所有贷款要求时，客户应及时归还。银行家在客户申请的贷款数量不超过自己拥有的最大值时，都应尽量满足客户的需要。在这样的描述中，银行家就好比操作系统，资金就是资源，客户就相当于要申请资源的进程。\n\n**银行家算法**的核心思想是：\n\n> **在满足安全条件的前提下才分配资源，永远确保系统处于“安全状态”——即总能找到一种方式，让所有进程依次完成。**\n\n---\n\n## 算法流程\n\n![1749361508854CGbfbU3Dyo2pNKxusM6ctBtQnzc.png](https://gitee.com/tanke11223344/imagehost/raw/main/blog/1749361508854CGbfbU3Dyo2pNKxusM6ctBtQnzc.png)\n\n## 算法需要管理的“账本”\n\n银行家算法维护四张表/向量，仿佛银行的“账本”：\n\n1. **Available**（可用资源向量）\n\n系统当前还剩余多少个各类资源可以分配。\n\n1. **Max**（最大需求矩阵）\n\n每个进程一生中最多可能向系统请求多少该类资源，事先必须申报。\n\n1. **Allocation**（已分配矩阵）\n\n系统已发给每个进程多少资源。\n\n1. **Need**（需求矩阵）\n\n每个进程还“差”多少资源才算满足最大需求，它等于\n\n$$\n\\text{Need}[i][j] = \\text{Max}[i][j] - \\text{Allocation}[i][j].\n$$\n\n> 只有在 `Request ≤ Need` 且 `Request ≤ Available` 的条件下，才会尝试分配。更重要的是，真正分配前还要做一次“安全性检查”（Safety Check）。\n\n---\n\n## 什么是“安全状态”？\n\n“安全状态”意味着：**即便所有进程都提出最坏请求，系统依然能保证按某种顺序让它们一个个拿到资源、干完活再归还。**\n\n![1749361523852SZ4fbKIHtohXHVxeJyncXATFngN.png](https://gitee.com/tanke11223344/imagehost/raw/main/blog/1749361523852SZ4fbKIHtohXHVxeJyncXATFngN.png)\n\n要检测这一点，算法会模拟一个“假设执行”过程：\n\n1. 复制一份可用资源 `Work = Available`，并标记所有进程 `Finish[i] = false`。\n2. 找到一个 `Finish[i]==false` 且其 `Need[i] ≤ Work` 的进程 $P_i$（说明它现在提出最大需求也能满足）。\n3. 假设让它拿到所需资源并执行完毕：把它手里原本的 `Allocation[i]` 全部“还给”Work (`Work += Allocation[i]`)，并把 `Finish[i]=true`。\n4. 重复第 2、3 步，直到没有可满足的进程为止。\n5. 如果最后所有 `Finish[i]` 都变成了 `true`，说明系统处于安全状态；否则，不安全。\n\n---\n\n## 分配资源前的“试探”与回滚\n\n当某个进程 $P_i$ 发出一笔资源请求 `Request[i]` 时，银行家算法按照以下步骤执行：\n\n### **合法性检查**\n\n- 若 `Request[i][j] > Need[i][j]` ——进程请求超过申报最大值，直接报错；\n- 若 `Request[i][j] > Available[j]` ——当前可用资源不足，让进程等待。\n\n### **试探性分配**\n\n```\nAvailable   := Available - Request[i]\nAllocation[i] := Allocation[i] + Request[i]\nNeed[i]      := Need[i] - Request[i]\n```\n\n### **安全性检测**\n\n- 如果“假设执行”后仍处于安全状态，就真正批准这笔分配；\n- 否则回退到分配前的状态，让进程继续等待。\n\n这样，系统永远不会进入一个“一旦分配就死锁”的局面。\n\n---\n\n## 一步步示例演示\n\n![1749361538853O7BAb59LFoU6gqxAchUc6gBLnEf.png](https://gitee.com/tanke11223344/imagehost/raw/main/blog/1749361538853O7BAb59LFoU6gqxAchUc6gBLnEf.png)\n\n假设有 5 个进程 $P_0…P_4$，3 类资源 $A,B,C$，初始数据如下：\n\n```\nAvailable = [3, 3, 2]   // 还空闲的 A、B、C 实例数\n\nMax =\nP0: [7, 5, 3]  \nP1: [3, 2, 2]\nP2: [9, 0, 2]\nP3: [2, 2, 2]\nP4: [4, 3, 3]\n\nAllocation =\nP0: [0, 1, 0]\nP1: [2, 0, 0]\nP2: [3, 0, 2]\nP3: [2, 1, 1]\nP4: [0, 0, 2]\n\nNeed = Max − Allocation =\nP0: [7,4,3]\nP1: [1,2,2]\nP2: [6,0,0]\nP3: [0,1,1]\nP4: [4,3,1]\n```\n\n### 安全性检查示例\n\n1. `Work = [3,3,2]`\n2. 找到 $P_1$（Need `[1,2,2]` ≤ Work）→ “假设”它执行并还资源 →\n\n```\nWork = [3,3,2] + Alloc[P1]=[2,0,0] = [5,3,2]\nFinish[P1] = true\n```\n\n1. 再找 $P_3$（Need `[0,1,1]` ≤ `[5,3,2]`），放行并还：\n\n```\nWork = [5,3,2] + [2,1,1] = [7,4,3]\nFinish[P3] = true\n```\n\n1. 然后 $P_0$, $P_2$, $P_4$ 依次被发现、安全、放行……最终所有 `Finish[]` 都是 `true`，说明系统安全。\n\n### 进程发请求示例\n\n若 $P_1$ 再请求 `[1,0,2]`：\n\n1. `Request` ≤ `Need` && ≤ `Available`（`[3,3,2]`），合法；\n2. 暂时分配后 `Available’=[2,3,0]`，`Alloc[1]=[3,0,2]`，`Need[1]=[0,2,0]`；\n3. 再用安全性检查，仍找得一条完成序列 → 批准；\n\n反之，若分配后安全性检查失败，就拒绝这次请求并回滚，保证系统永不死锁。\n\n---\n\n## 代码实现\n\n### C++ 版本\n\n```cpp\n#include <vector>\n#include <iostream>\nusing namespace std;\n\n// 安全性检查\nbool isSafe(vector<int> Available,\n            vector<vector<int>>& Max,\n            vector<vector<int>>& Alloc) {\n    int n = Max.size(), m = Available.size();\n    vector<int> Work = Available;\n    vector<bool> Finish(n, false);\n\n    // 计算 Need\n    vector<vector<int>> Need(n, vector<int>(m));\n    for (int i = 0; i < n; ++i)\n      for (int j = 0; j < m; ++j)\n        Need[i][j] = Max[i][j] - Alloc[i][j];\n\n    // 模拟放行\n    for (int k = 0; k < n; ++k) {\n        bool found = false;\n        for (int i = 0; i < n; ++i) {\n            if (!Finish[i]) {\n                bool ok = true;\n                for (int j = 0; j < m; ++j)\n                    if (Need[i][j] > Work[j]) { ok = false; break; }\n                if (ok) {\n                    for (int j = 0; j < m; ++j) Work[j] += Alloc[i][j];\n                    Finish[i] = true;\n                    found = true;\n                }\n            }\n        }\n        if (!found) break;\n    }\n    // 全能放行才安全\n    for (bool f : Finish) if (!f) return false;\n    return true;\n}\n\n// 请求资源接口\nbool requestResource(int pid, vector<int> Request,\n                     vector<int>& Available,\n                     vector<vector<int>>& Max,\n                     vector<vector<int>>& Alloc) {\n    int m = Available.size();\n    // 合法性检查\n    for (int j = 0; j < m; ++j)\n        if (Request[j] > Max[pid][j] - Alloc[pid][j]\n         || Request[j] > Available[j]) return false;\n\n    // 试探性分配\n    for (int j = 0; j < m; ++j) {\n        Available[j] -= Request[j];\n        Alloc[pid][j]   += Request[j];\n    }\n\n    // 安全检测：通过就保留，否则回滚\n    if (isSafe(Available, Max, Alloc)) return true;\n    for (int j = 0; j < m; ++j) {\n        Available[j] += Request[j];\n        Alloc[pid][j]   -= Request[j];\n    }\n    return false;\n}\n\nint main(){\n    vector<int> Available{3,3,2};\n    vector<vector<int>> Max{\n        {7,5,3},{3,2,2},{9,0,2},{2,2,2},{4,3,3}\n    };\n    vector<vector<int>> Alloc{\n        {0,1,0},{2,0,0},{3,0,2},{2,1,1},{0,0,2}\n    };\n\n    cout << \"初始安全? \" << (isSafe(Available, Max, Alloc) ? \"是\\n\" : \"否\\n\");\n\n    vector<int> req{1,0,2};\n    cout << \"P1 请求 [1,0,2]: \"\n         << (requestResource(1, req, Available, Max, Alloc) ? \"批准\\n\":\"拒绝\\n\");\n}\n```\n\n### Python 版本\n\n```python\ndef is_safe(available, max_d, alloc):\n    n, m = len(max_d), len(available)\n    work = available[:]\n    finish = [False]*n\n    need = [[max_d[i][j]-alloc[i][j] for j in range(m)]\n            for i in range(n)]\n\n    while True:\n        found = False\n        for i in range(n):\n            if not finish[i] and all(need[i][j] <= work[j] for j in range(m)):\n                for j in range(m):\n                    work[j] += alloc[i][j]\n                finish[i] = True\n                found = True\n        if not found: break\n    return all(finish)\n\ndef request_resource(pid, req, available, max_d, alloc):\n    m = len(available)\n    # 合法性检查\n    for j in range(m):\n        if req[j] > max_d[pid][j]-alloc[pid][j] or req[j] > available[j]:\n            return False\n    # 试探分配\n    for j in range(m):\n        available[j] -= req[j]\n        alloc[pid][j] += req[j]\n    if is_safe(available, max_d, alloc):\n        return True\n    # 回滚\n    for j in range(m):\n        available[j] += req[j]\n        alloc[pid][j] -= req[j]\n    return False\n\nif __name__ == \"__main__\":\n    avail = [3,3,2]\n    max_d = [[7,5,3],[3,2,2],[9,0,2],[2,2,2],[4,3,3]]\n    alloc = [[0,1,0],[2,0,0],[3,0,2],[2,1,1],[0,0,2]]\n    print(\"初始安全?\", is_safe(avail, max_d, alloc))\n    print(\"P1 请求 [1,0,2]:\",\n          \"批准\" if request_resource(1, [1,0,2], avail, max_d, alloc) else \"拒绝\")\n```\n\n### Go 版本\n\n```go\npackage main\n\nimport \"fmt\"\n\n_// BankersAlgorithm 结构体定义了银行家算法所需的数据结构_\n_// available: 可用资源向量_\n_// max: 最大需求矩阵_\n_// allocation: 分配矩阵_\n_// need: 需求矩阵_\ntype BankersAlgorithm struct {\n **available**  []int\n **max**        [][]int\n **allocation** [][]int\n **need**       [][]int\n}\n\n_// NewBankersAlgorithm 初始化银行家算法_\n_// 参数:_\n_//   - available: 系统可用资源向量_\n_//   - max: 进程最大需求矩阵_\n_//   - allocation: 当前分配矩阵_\n_// 返回: 初始化后的银行家算法实例_\nfunc NewBankersAlgorithm(available []int, max [][]int, allocation [][]int) *BankersAlgorithm {\n _// 创建新的银行家算法实例_\n ba := &BankersAlgorithm{\n  **available**:  make([]int, len(available)),\n  **max**:        make([][]int, len(max)),\n  **allocation**: make([][]int, len(allocation)),\n  **need**:       make([][]int, len(max)),\n }\n\n _// 复制可用资源向量_\n copy(ba.available, available)\n \n _// 复制最大需求矩阵_\n for i := range max {\n  ba.max[i] = make([]int, len(max[i]))\n  copy(ba.max[i], max[i])\n }\n \n _// 复制分配矩阵_\n for i := range allocation {\n  ba.allocation[i] = make([]int, len(allocation[i]))\n  copy(ba.allocation[i], allocation[i])\n }\n\n _// 计算需求矩阵 need = max - allocation_\n for i := range max {\n  ba.need[i] = make([]int, len(max[i]))\n  for j := range max[i] {\n   ba.need[i][j] = max[i][j] - allocation[i][j]\n  }\n }\n\n return ba\n}\n\n_// RequestResources 处理进程的资源请求_\n_// 参数:_\n_//   - processID: 请求资源的进程ID_\n_//   - request: 请求的资源向量_\n_// 返回: 请求是否成功_\nfunc (ba *BankersAlgorithm) RequestResources(processID int, request []int) bool {\n _// 检查请求是否超过最大需求_\n for i := range request {\n  if request[i] > ba.need[processID][i] {\n   fmt.Printf(\"进程 %d 请求的资源超过最大需求\\n\", processID)\n   return false\n  }\n }\n\n _// 检查系统是否有足够的可用资源_\n for i := range request {\n  if request[i] > ba.available[i] {\n   fmt.Printf(\"资源不足，进程 %d 需等待\\n\", processID)\n   return false\n  }\n }\n\n _// 试探性分配资源_\n for i := range request {\n  ba.available[i] -= request[i]\n  ba.allocation[processID][i] += request[i]\n  ba.need[processID][i] -= request[i]\n }\n\n _// 检查分配后系统是否安全_\n if !ba.isSafe() {\n  fmt.Println(\"分配后系统处于不安全状态，撤销分配\")\n  _// 撤销分配，恢复原状态_\n  for i := range request {\n   ba.available[i] += request[i]\n   ba.allocation[processID][i] -= request[i]\n   ba.need[processID][i] += request[i]\n  }\n  return false\n }\n\n fmt.Println(\"资源分配成功，系统处于安全状态\")\n return true\n}\n\n_// isSafe 检查系统是否处于安全状态_\n_// 返回: 系统是否安全_\nfunc (ba *BankersAlgorithm) isSafe() bool {\n _// 初始化工作向量和完成向量_\n work := make([]int, len(ba.available))\n copy(work, ba.available)\n finish := make([]bool, len(ba.max))\n\n _// 寻找可以完成的进程_\n for {\n  found := false\n  for i := range ba.max {\n   if !finish[i] && ba.canFinish(work, ba.need[i]) {\n    _// 进程i可以完成，释放其资源_\n    for j := range work {\n     work[j] += ba.allocation[i][j]\n    }\n    finish[i] = true\n    found = true\n   }\n  }\n\n  if !found {\n   break\n  }\n }\n\n _// 检查是否所有进程都能完成_\n for _, f := range finish {\n  if !f {\n   return false\n  }\n }\n\n return true\n}\n\n_// canFinish 检查进程是否能够完成_\n_// 参数:_\n_//   - work: 当前可用资源向量_\n_//   - need: 进程需求向量_\n_// 返回: 进程是否可以完成_\nfunc (ba *BankersAlgorithm) canFinish(work []int, need []int) bool {\n for i := range work {\n  if need[i] > work[i] {\n   return false\n  }\n }\n return true\n}\n\nfunc main() {\n _// 初始化系统资源数据_\n available := []int{3, 3, 2}  _// 可用资源向量_\n max := [][]int{              _// 最大需求矩阵_\n  {7, 5, 3},\n  {3, 2, 2},\n  {9, 0, 2},\n  {2, 2, 2},\n  {4, 3, 3},\n }\n allocation := [][]int{       _// 当前分配矩阵_\n  {0, 1, 0},\n  {2, 0, 0},\n  {3, 0, 2},\n  {2, 1, 1},\n  {0, 0, 2},\n }\n\n _// 创建银行家算法实例_\n ba := NewBankersAlgorithm(available, max, allocation)\n\n _// 模拟进程1请求资源_\n processID := 1\n request := []int{0, 2, 0}\n\n _// 处理资源请求_\n if ba.RequestResources(processID, request) {\n  fmt.Println(\"资源分配成功\")\n } else {\n  fmt.Println(\"资源分配失败\")\n }\n}\n```\n\n---\n\n## 算法效率与适用场景\n\n- **时间复杂度**：每次请求都要调用一次安全性检查，最坏 $O(n^2 \\times m)$（$n$ 是进程数，$m$ 是资源种类数）。\n- **优点**：只要需求申报准确，能彻底避免死锁；逻辑清晰，易于理解与实现。\n- **缺点**：\n\n1. 计算量较大，不适合大量进程和资源同时在线的场景；\n2. 要求进程提前申报最大需求，有时难以预估；\n3. 如果申报过高就浪费资源，过低又可能限制并发度。\n\n**典型应用**：\n\n> 嵌入式实时系统、小型操作系统、数据库连接池管理等场景——进程/线程数目不多、资源类型有限、死锁成本高，正好适合使用银行家算法来保证系统健康运行。\n\n---\n\n# 总结\n\n银行家算法用“银行发放贷款”这一比喻，把死锁避免转化为“安全性检查 + 试探性分配 + 回滚”三步走。理解它的核心，就是：\n\n1. **维护 Available/Max/Allocation/Need** 这四张“账本”；\n2. **安全性检测**：模拟最坏情况看系统是否还能让所有进程“还清”资源；\n3. **只在安全状态下正式分配**，否则拒绝并回滚。\n\n这样的设计保证了系统永不进入死锁，但也带来了计算开销和使用局限。在实际工程中，我们要根据并发规模与实时性要求，权衡是否使用这一经典算法。希望本文的通俗讲解和示例代码，能让你对银行家算法有清晰而深入的理解。\n","source":"_posts/2025-05-11-银行家算法分析.md","raw":"---\ntitle:  2025-05-11-银行家算法分析\ndate: 2025-05-11\ntags: \n    课程学习\n---\n# 银行家算法分析\n\n# 参考资料\n\n> - [操作系统——银行家算法(Banker&#39;s Algorithm) - 王陆 - 博客园](https://www.cnblogs.com/wkfvawl/p/11929508.html)\n> - [操作系统 - 《银行家算法》_1、银行家算法的应用,根据题目要求能够找到某种状态下的安全序列,当进程请求资源-CSDN 博客](https://blog.csdn.net/qq_63976098/article/details/133957267?utm_medium=distribute.pc_relevant.none-task-blog-2~default~baidujs_baidulandingword~default-0-133957267-blog-112762387.235%5Ev43%5Epc_blog_bottom_relevance_base1&spm=1001.2101.3001.4242.1&utm_relevant_index=2)\n> - [银行家算法详解与实现-CSDN 博客](https://blog.csdn.net/weixin_39478524/article/details/80604876?spm=1001.2101.3001.6650.3&utm_medium=distribute.pc_relevant.none-task-blog-2%7Edefault%7EBlogCommendFromBaidu%7ERate-3-80604876-blog-112762387.235%5Ev43%5Epc_blog_bottom_relevance_base1&depth_1-utm_source=distribute.pc_relevant.none-task-blog-2%7Edefault%7EBlogCommendFromBaidu%7ERate-3-80604876-blog-112762387.235%5Ev43%5Epc_blog_bottom_relevance_base1&utm_relevant_index=5)\n> - [GitHub - TCL606/BankerAlgorithm: 银行家算法示例](https://github.com/TCL606/BankerAlgorithm)\n\n# 概述\n\n> - [面试官:什么是死锁?怎么排查死锁?怎么避免死锁? - 小林 coding - 博客园](https://www.cnblogs.com/xiaolincoding/p/14604726.html)\n> - [死锁解析-CSDN 博客](https://blog.csdn.net/Appleeatingboy/article/details/122425760)\n\n![1749361500080AZV1b08W0oKjH6xawopc1lAMnId.png](https://gitee.com/tanke11223344/imagehost/raw/main/blog/1749361500080AZV1b08W0oKjH6xawopc1lAMnId.png)\n\n持有并等待条件导致的死锁\n\n在多进程或多线程并发访问资源的场景下，[死锁](https://zh.wikipedia.org/zh-cn/%E6%AD%BB%E9%94%81)（Deadlock）是一种让人头疼的问题：几个任务相互等待，谁也拿不到继续执行的机会。银行家算法（Banker’s Algorithm）就是荷兰计算机科学家 Dijkstra 提出的一套“贷款”式资源分配方案，保证系统不陷入死锁。\n\n---\n\n## 为什么需要银行家算法\n\n想象一家银行有一笔总资金，多个客户（进程）可能随时来申请贷款（资源）。如果不加以控制，一旦所有客户都拿走部分贷款，却留下一些客户的需求得不到满足，就可能让银行陷入“钱不够分”又“谁也不肯还款”的窘境。操作系统中的资源（内存块、I/O 通道、锁等）同理：若乱放行，很可能出现死锁，各进程互相等待而永远卡住。\n\n> 在银行中，客户申请贷款的数量是有限的，每个客户在第一次申请贷款时要声明完成该项目所需的最大资金量，在满足所有贷款要求时，客户应及时归还。银行家在客户申请的贷款数量不超过自己拥有的最大值时，都应尽量满足客户的需要。在这样的描述中，银行家就好比操作系统，资金就是资源，客户就相当于要申请资源的进程。\n\n**银行家算法**的核心思想是：\n\n> **在满足安全条件的前提下才分配资源，永远确保系统处于“安全状态”——即总能找到一种方式，让所有进程依次完成。**\n\n---\n\n## 算法流程\n\n![1749361508854CGbfbU3Dyo2pNKxusM6ctBtQnzc.png](https://gitee.com/tanke11223344/imagehost/raw/main/blog/1749361508854CGbfbU3Dyo2pNKxusM6ctBtQnzc.png)\n\n## 算法需要管理的“账本”\n\n银行家算法维护四张表/向量，仿佛银行的“账本”：\n\n1. **Available**（可用资源向量）\n\n系统当前还剩余多少个各类资源可以分配。\n\n1. **Max**（最大需求矩阵）\n\n每个进程一生中最多可能向系统请求多少该类资源，事先必须申报。\n\n1. **Allocation**（已分配矩阵）\n\n系统已发给每个进程多少资源。\n\n1. **Need**（需求矩阵）\n\n每个进程还“差”多少资源才算满足最大需求，它等于\n\n$$\n\\text{Need}[i][j] = \\text{Max}[i][j] - \\text{Allocation}[i][j].\n$$\n\n> 只有在 `Request ≤ Need` 且 `Request ≤ Available` 的条件下，才会尝试分配。更重要的是，真正分配前还要做一次“安全性检查”（Safety Check）。\n\n---\n\n## 什么是“安全状态”？\n\n“安全状态”意味着：**即便所有进程都提出最坏请求，系统依然能保证按某种顺序让它们一个个拿到资源、干完活再归还。**\n\n![1749361523852SZ4fbKIHtohXHVxeJyncXATFngN.png](https://gitee.com/tanke11223344/imagehost/raw/main/blog/1749361523852SZ4fbKIHtohXHVxeJyncXATFngN.png)\n\n要检测这一点，算法会模拟一个“假设执行”过程：\n\n1. 复制一份可用资源 `Work = Available`，并标记所有进程 `Finish[i] = false`。\n2. 找到一个 `Finish[i]==false` 且其 `Need[i] ≤ Work` 的进程 $P_i$（说明它现在提出最大需求也能满足）。\n3. 假设让它拿到所需资源并执行完毕：把它手里原本的 `Allocation[i]` 全部“还给”Work (`Work += Allocation[i]`)，并把 `Finish[i]=true`。\n4. 重复第 2、3 步，直到没有可满足的进程为止。\n5. 如果最后所有 `Finish[i]` 都变成了 `true`，说明系统处于安全状态；否则，不安全。\n\n---\n\n## 分配资源前的“试探”与回滚\n\n当某个进程 $P_i$ 发出一笔资源请求 `Request[i]` 时，银行家算法按照以下步骤执行：\n\n### **合法性检查**\n\n- 若 `Request[i][j] > Need[i][j]` ——进程请求超过申报最大值，直接报错；\n- 若 `Request[i][j] > Available[j]` ——当前可用资源不足，让进程等待。\n\n### **试探性分配**\n\n```\nAvailable   := Available - Request[i]\nAllocation[i] := Allocation[i] + Request[i]\nNeed[i]      := Need[i] - Request[i]\n```\n\n### **安全性检测**\n\n- 如果“假设执行”后仍处于安全状态，就真正批准这笔分配；\n- 否则回退到分配前的状态，让进程继续等待。\n\n这样，系统永远不会进入一个“一旦分配就死锁”的局面。\n\n---\n\n## 一步步示例演示\n\n![1749361538853O7BAb59LFoU6gqxAchUc6gBLnEf.png](https://gitee.com/tanke11223344/imagehost/raw/main/blog/1749361538853O7BAb59LFoU6gqxAchUc6gBLnEf.png)\n\n假设有 5 个进程 $P_0…P_4$，3 类资源 $A,B,C$，初始数据如下：\n\n```\nAvailable = [3, 3, 2]   // 还空闲的 A、B、C 实例数\n\nMax =\nP0: [7, 5, 3]  \nP1: [3, 2, 2]\nP2: [9, 0, 2]\nP3: [2, 2, 2]\nP4: [4, 3, 3]\n\nAllocation =\nP0: [0, 1, 0]\nP1: [2, 0, 0]\nP2: [3, 0, 2]\nP3: [2, 1, 1]\nP4: [0, 0, 2]\n\nNeed = Max − Allocation =\nP0: [7,4,3]\nP1: [1,2,2]\nP2: [6,0,0]\nP3: [0,1,1]\nP4: [4,3,1]\n```\n\n### 安全性检查示例\n\n1. `Work = [3,3,2]`\n2. 找到 $P_1$（Need `[1,2,2]` ≤ Work）→ “假设”它执行并还资源 →\n\n```\nWork = [3,3,2] + Alloc[P1]=[2,0,0] = [5,3,2]\nFinish[P1] = true\n```\n\n1. 再找 $P_3$（Need `[0,1,1]` ≤ `[5,3,2]`），放行并还：\n\n```\nWork = [5,3,2] + [2,1,1] = [7,4,3]\nFinish[P3] = true\n```\n\n1. 然后 $P_0$, $P_2$, $P_4$ 依次被发现、安全、放行……最终所有 `Finish[]` 都是 `true`，说明系统安全。\n\n### 进程发请求示例\n\n若 $P_1$ 再请求 `[1,0,2]`：\n\n1. `Request` ≤ `Need` && ≤ `Available`（`[3,3,2]`），合法；\n2. 暂时分配后 `Available’=[2,3,0]`，`Alloc[1]=[3,0,2]`，`Need[1]=[0,2,0]`；\n3. 再用安全性检查，仍找得一条完成序列 → 批准；\n\n反之，若分配后安全性检查失败，就拒绝这次请求并回滚，保证系统永不死锁。\n\n---\n\n## 代码实现\n\n### C++ 版本\n\n```cpp\n#include <vector>\n#include <iostream>\nusing namespace std;\n\n// 安全性检查\nbool isSafe(vector<int> Available,\n            vector<vector<int>>& Max,\n            vector<vector<int>>& Alloc) {\n    int n = Max.size(), m = Available.size();\n    vector<int> Work = Available;\n    vector<bool> Finish(n, false);\n\n    // 计算 Need\n    vector<vector<int>> Need(n, vector<int>(m));\n    for (int i = 0; i < n; ++i)\n      for (int j = 0; j < m; ++j)\n        Need[i][j] = Max[i][j] - Alloc[i][j];\n\n    // 模拟放行\n    for (int k = 0; k < n; ++k) {\n        bool found = false;\n        for (int i = 0; i < n; ++i) {\n            if (!Finish[i]) {\n                bool ok = true;\n                for (int j = 0; j < m; ++j)\n                    if (Need[i][j] > Work[j]) { ok = false; break; }\n                if (ok) {\n                    for (int j = 0; j < m; ++j) Work[j] += Alloc[i][j];\n                    Finish[i] = true;\n                    found = true;\n                }\n            }\n        }\n        if (!found) break;\n    }\n    // 全能放行才安全\n    for (bool f : Finish) if (!f) return false;\n    return true;\n}\n\n// 请求资源接口\nbool requestResource(int pid, vector<int> Request,\n                     vector<int>& Available,\n                     vector<vector<int>>& Max,\n                     vector<vector<int>>& Alloc) {\n    int m = Available.size();\n    // 合法性检查\n    for (int j = 0; j < m; ++j)\n        if (Request[j] > Max[pid][j] - Alloc[pid][j]\n         || Request[j] > Available[j]) return false;\n\n    // 试探性分配\n    for (int j = 0; j < m; ++j) {\n        Available[j] -= Request[j];\n        Alloc[pid][j]   += Request[j];\n    }\n\n    // 安全检测：通过就保留，否则回滚\n    if (isSafe(Available, Max, Alloc)) return true;\n    for (int j = 0; j < m; ++j) {\n        Available[j] += Request[j];\n        Alloc[pid][j]   -= Request[j];\n    }\n    return false;\n}\n\nint main(){\n    vector<int> Available{3,3,2};\n    vector<vector<int>> Max{\n        {7,5,3},{3,2,2},{9,0,2},{2,2,2},{4,3,3}\n    };\n    vector<vector<int>> Alloc{\n        {0,1,0},{2,0,0},{3,0,2},{2,1,1},{0,0,2}\n    };\n\n    cout << \"初始安全? \" << (isSafe(Available, Max, Alloc) ? \"是\\n\" : \"否\\n\");\n\n    vector<int> req{1,0,2};\n    cout << \"P1 请求 [1,0,2]: \"\n         << (requestResource(1, req, Available, Max, Alloc) ? \"批准\\n\":\"拒绝\\n\");\n}\n```\n\n### Python 版本\n\n```python\ndef is_safe(available, max_d, alloc):\n    n, m = len(max_d), len(available)\n    work = available[:]\n    finish = [False]*n\n    need = [[max_d[i][j]-alloc[i][j] for j in range(m)]\n            for i in range(n)]\n\n    while True:\n        found = False\n        for i in range(n):\n            if not finish[i] and all(need[i][j] <= work[j] for j in range(m)):\n                for j in range(m):\n                    work[j] += alloc[i][j]\n                finish[i] = True\n                found = True\n        if not found: break\n    return all(finish)\n\ndef request_resource(pid, req, available, max_d, alloc):\n    m = len(available)\n    # 合法性检查\n    for j in range(m):\n        if req[j] > max_d[pid][j]-alloc[pid][j] or req[j] > available[j]:\n            return False\n    # 试探分配\n    for j in range(m):\n        available[j] -= req[j]\n        alloc[pid][j] += req[j]\n    if is_safe(available, max_d, alloc):\n        return True\n    # 回滚\n    for j in range(m):\n        available[j] += req[j]\n        alloc[pid][j] -= req[j]\n    return False\n\nif __name__ == \"__main__\":\n    avail = [3,3,2]\n    max_d = [[7,5,3],[3,2,2],[9,0,2],[2,2,2],[4,3,3]]\n    alloc = [[0,1,0],[2,0,0],[3,0,2],[2,1,1],[0,0,2]]\n    print(\"初始安全?\", is_safe(avail, max_d, alloc))\n    print(\"P1 请求 [1,0,2]:\",\n          \"批准\" if request_resource(1, [1,0,2], avail, max_d, alloc) else \"拒绝\")\n```\n\n### Go 版本\n\n```go\npackage main\n\nimport \"fmt\"\n\n_// BankersAlgorithm 结构体定义了银行家算法所需的数据结构_\n_// available: 可用资源向量_\n_// max: 最大需求矩阵_\n_// allocation: 分配矩阵_\n_// need: 需求矩阵_\ntype BankersAlgorithm struct {\n **available**  []int\n **max**        [][]int\n **allocation** [][]int\n **need**       [][]int\n}\n\n_// NewBankersAlgorithm 初始化银行家算法_\n_// 参数:_\n_//   - available: 系统可用资源向量_\n_//   - max: 进程最大需求矩阵_\n_//   - allocation: 当前分配矩阵_\n_// 返回: 初始化后的银行家算法实例_\nfunc NewBankersAlgorithm(available []int, max [][]int, allocation [][]int) *BankersAlgorithm {\n _// 创建新的银行家算法实例_\n ba := &BankersAlgorithm{\n  **available**:  make([]int, len(available)),\n  **max**:        make([][]int, len(max)),\n  **allocation**: make([][]int, len(allocation)),\n  **need**:       make([][]int, len(max)),\n }\n\n _// 复制可用资源向量_\n copy(ba.available, available)\n \n _// 复制最大需求矩阵_\n for i := range max {\n  ba.max[i] = make([]int, len(max[i]))\n  copy(ba.max[i], max[i])\n }\n \n _// 复制分配矩阵_\n for i := range allocation {\n  ba.allocation[i] = make([]int, len(allocation[i]))\n  copy(ba.allocation[i], allocation[i])\n }\n\n _// 计算需求矩阵 need = max - allocation_\n for i := range max {\n  ba.need[i] = make([]int, len(max[i]))\n  for j := range max[i] {\n   ba.need[i][j] = max[i][j] - allocation[i][j]\n  }\n }\n\n return ba\n}\n\n_// RequestResources 处理进程的资源请求_\n_// 参数:_\n_//   - processID: 请求资源的进程ID_\n_//   - request: 请求的资源向量_\n_// 返回: 请求是否成功_\nfunc (ba *BankersAlgorithm) RequestResources(processID int, request []int) bool {\n _// 检查请求是否超过最大需求_\n for i := range request {\n  if request[i] > ba.need[processID][i] {\n   fmt.Printf(\"进程 %d 请求的资源超过最大需求\\n\", processID)\n   return false\n  }\n }\n\n _// 检查系统是否有足够的可用资源_\n for i := range request {\n  if request[i] > ba.available[i] {\n   fmt.Printf(\"资源不足，进程 %d 需等待\\n\", processID)\n   return false\n  }\n }\n\n _// 试探性分配资源_\n for i := range request {\n  ba.available[i] -= request[i]\n  ba.allocation[processID][i] += request[i]\n  ba.need[processID][i] -= request[i]\n }\n\n _// 检查分配后系统是否安全_\n if !ba.isSafe() {\n  fmt.Println(\"分配后系统处于不安全状态，撤销分配\")\n  _// 撤销分配，恢复原状态_\n  for i := range request {\n   ba.available[i] += request[i]\n   ba.allocation[processID][i] -= request[i]\n   ba.need[processID][i] += request[i]\n  }\n  return false\n }\n\n fmt.Println(\"资源分配成功，系统处于安全状态\")\n return true\n}\n\n_// isSafe 检查系统是否处于安全状态_\n_// 返回: 系统是否安全_\nfunc (ba *BankersAlgorithm) isSafe() bool {\n _// 初始化工作向量和完成向量_\n work := make([]int, len(ba.available))\n copy(work, ba.available)\n finish := make([]bool, len(ba.max))\n\n _// 寻找可以完成的进程_\n for {\n  found := false\n  for i := range ba.max {\n   if !finish[i] && ba.canFinish(work, ba.need[i]) {\n    _// 进程i可以完成，释放其资源_\n    for j := range work {\n     work[j] += ba.allocation[i][j]\n    }\n    finish[i] = true\n    found = true\n   }\n  }\n\n  if !found {\n   break\n  }\n }\n\n _// 检查是否所有进程都能完成_\n for _, f := range finish {\n  if !f {\n   return false\n  }\n }\n\n return true\n}\n\n_// canFinish 检查进程是否能够完成_\n_// 参数:_\n_//   - work: 当前可用资源向量_\n_//   - need: 进程需求向量_\n_// 返回: 进程是否可以完成_\nfunc (ba *BankersAlgorithm) canFinish(work []int, need []int) bool {\n for i := range work {\n  if need[i] > work[i] {\n   return false\n  }\n }\n return true\n}\n\nfunc main() {\n _// 初始化系统资源数据_\n available := []int{3, 3, 2}  _// 可用资源向量_\n max := [][]int{              _// 最大需求矩阵_\n  {7, 5, 3},\n  {3, 2, 2},\n  {9, 0, 2},\n  {2, 2, 2},\n  {4, 3, 3},\n }\n allocation := [][]int{       _// 当前分配矩阵_\n  {0, 1, 0},\n  {2, 0, 0},\n  {3, 0, 2},\n  {2, 1, 1},\n  {0, 0, 2},\n }\n\n _// 创建银行家算法实例_\n ba := NewBankersAlgorithm(available, max, allocation)\n\n _// 模拟进程1请求资源_\n processID := 1\n request := []int{0, 2, 0}\n\n _// 处理资源请求_\n if ba.RequestResources(processID, request) {\n  fmt.Println(\"资源分配成功\")\n } else {\n  fmt.Println(\"资源分配失败\")\n }\n}\n```\n\n---\n\n## 算法效率与适用场景\n\n- **时间复杂度**：每次请求都要调用一次安全性检查，最坏 $O(n^2 \\times m)$（$n$ 是进程数，$m$ 是资源种类数）。\n- **优点**：只要需求申报准确，能彻底避免死锁；逻辑清晰，易于理解与实现。\n- **缺点**：\n\n1. 计算量较大，不适合大量进程和资源同时在线的场景；\n2. 要求进程提前申报最大需求，有时难以预估；\n3. 如果申报过高就浪费资源，过低又可能限制并发度。\n\n**典型应用**：\n\n> 嵌入式实时系统、小型操作系统、数据库连接池管理等场景——进程/线程数目不多、资源类型有限、死锁成本高，正好适合使用银行家算法来保证系统健康运行。\n\n---\n\n# 总结\n\n银行家算法用“银行发放贷款”这一比喻，把死锁避免转化为“安全性检查 + 试探性分配 + 回滚”三步走。理解它的核心，就是：\n\n1. **维护 Available/Max/Allocation/Need** 这四张“账本”；\n2. **安全性检测**：模拟最坏情况看系统是否还能让所有进程“还清”资源；\n3. **只在安全状态下正式分配**，否则拒绝并回滚。\n\n这样的设计保证了系统永不进入死锁，但也带来了计算开销和使用局限。在实际工程中，我们要根据并发规模与实时性要求，权衡是否使用这一经典算法。希望本文的通俗讲解和示例代码，能让你对银行家算法有清晰而深入的理解。\n","slug":"2025-05-11-银行家算法分析","published":1,"updated":"2025-09-26T12:17:39.591Z","_id":"cmg0saj4d0029jm8ng5r48sfr","comments":1,"layout":"post","photos":[],"content":"<h1 id=\"银行家算法分析\"><a href=\"#银行家算法分析\" class=\"headerlink\" title=\"银行家算法分析\"></a>银行家算法分析</h1><h1 id=\"参考资料\"><a href=\"#参考资料\" class=\"headerlink\" title=\"参考资料\"></a>参考资料</h1><blockquote>\n<ul>\n<li><a href=\"https://www.cnblogs.com/wkfvawl/p/11929508.html\">操作系统——银行家算法(Banker&#39;s Algorithm) - 王陆 - 博客园</a></li>\n<li><a href=\"https://blog.csdn.net/qq_63976098/article/details/133957267?utm_medium=distribute.pc_relevant.none-task-blog-2~default~baidujs_baidulandingword~default-0-133957267-blog-112762387.235%5Ev43%5Epc_blog_bottom_relevance_base1&spm=1001.2101.3001.4242.1&utm_relevant_index=2\">操作系统 - 《银行家算法》_1、银行家算法的应用,根据题目要求能够找到某种状态下的安全序列,当进程请求资源-CSDN 博客</a></li>\n<li><a href=\"https://blog.csdn.net/weixin_39478524/article/details/80604876?spm=1001.2101.3001.6650.3&utm_medium=distribute.pc_relevant.none-task-blog-2~default~BlogCommendFromBaidu~Rate-3-80604876-blog-112762387.235%5Ev43%5Epc_blog_bottom_relevance_base1&depth_1-utm_source=distribute.pc_relevant.none-task-blog-2~default~BlogCommendFromBaidu~Rate-3-80604876-blog-112762387.235%5Ev43%5Epc_blog_bottom_relevance_base1&utm_relevant_index=5\">银行家算法详解与实现-CSDN 博客</a></li>\n<li><a href=\"https://github.com/TCL606/BankerAlgorithm\">GitHub - TCL606&#x2F;BankerAlgorithm: 银行家算法示例</a></li>\n</ul>\n</blockquote>\n<h1 id=\"概述\"><a href=\"#概述\" class=\"headerlink\" title=\"概述\"></a>概述</h1><blockquote>\n<ul>\n<li><a href=\"https://www.cnblogs.com/xiaolincoding/p/14604726.html\">面试官:什么是死锁?怎么排查死锁?怎么避免死锁? - 小林 coding - 博客园</a></li>\n<li><a href=\"https://blog.csdn.net/Appleeatingboy/article/details/122425760\">死锁解析-CSDN 博客</a></li>\n</ul>\n</blockquote>\n<p><img src=\"https://gitee.com/tanke11223344/imagehost/raw/main/blog/1749361500080AZV1b08W0oKjH6xawopc1lAMnId.png\" alt=\"1749361500080AZV1b08W0oKjH6xawopc1lAMnId.png\"></p>\n<p>持有并等待条件导致的死锁</p>\n<p>在多进程或多线程并发访问资源的场景下，<a href=\"https://zh.wikipedia.org/zh-cn/%E6%AD%BB%E9%94%81\">死锁</a>（Deadlock）是一种让人头疼的问题：几个任务相互等待，谁也拿不到继续执行的机会。银行家算法（Banker’s Algorithm）就是荷兰计算机科学家 Dijkstra 提出的一套“贷款”式资源分配方案，保证系统不陷入死锁。</p>\n<hr>\n<h2 id=\"为什么需要银行家算法\"><a href=\"#为什么需要银行家算法\" class=\"headerlink\" title=\"为什么需要银行家算法\"></a>为什么需要银行家算法</h2><p>想象一家银行有一笔总资金，多个客户（进程）可能随时来申请贷款（资源）。如果不加以控制，一旦所有客户都拿走部分贷款，却留下一些客户的需求得不到满足，就可能让银行陷入“钱不够分”又“谁也不肯还款”的窘境。操作系统中的资源（内存块、I&#x2F;O 通道、锁等）同理：若乱放行，很可能出现死锁，各进程互相等待而永远卡住。</p>\n<blockquote>\n<p>在银行中，客户申请贷款的数量是有限的，每个客户在第一次申请贷款时要声明完成该项目所需的最大资金量，在满足所有贷款要求时，客户应及时归还。银行家在客户申请的贷款数量不超过自己拥有的最大值时，都应尽量满足客户的需要。在这样的描述中，银行家就好比操作系统，资金就是资源，客户就相当于要申请资源的进程。</p>\n</blockquote>\n<p><strong>银行家算法</strong>的核心思想是：</p>\n<blockquote>\n<p><strong>在满足安全条件的前提下才分配资源，永远确保系统处于“安全状态”——即总能找到一种方式，让所有进程依次完成。</strong></p>\n</blockquote>\n<hr>\n<h2 id=\"算法流程\"><a href=\"#算法流程\" class=\"headerlink\" title=\"算法流程\"></a>算法流程</h2><p><img src=\"https://gitee.com/tanke11223344/imagehost/raw/main/blog/1749361508854CGbfbU3Dyo2pNKxusM6ctBtQnzc.png\" alt=\"1749361508854CGbfbU3Dyo2pNKxusM6ctBtQnzc.png\"></p>\n<h2 id=\"算法需要管理的“账本”\"><a href=\"#算法需要管理的“账本”\" class=\"headerlink\" title=\"算法需要管理的“账本”\"></a>算法需要管理的“账本”</h2><p>银行家算法维护四张表&#x2F;向量，仿佛银行的“账本”：</p>\n<ol>\n<li><strong>Available</strong>（可用资源向量）</li>\n</ol>\n<p>系统当前还剩余多少个各类资源可以分配。</p>\n<ol>\n<li><strong>Max</strong>（最大需求矩阵）</li>\n</ol>\n<p>每个进程一生中最多可能向系统请求多少该类资源，事先必须申报。</p>\n<ol>\n<li><strong>Allocation</strong>（已分配矩阵）</li>\n</ol>\n<p>系统已发给每个进程多少资源。</p>\n<ol>\n<li><strong>Need</strong>（需求矩阵）</li>\n</ol>\n<p>每个进程还“差”多少资源才算满足最大需求，它等于</p>\n<p>$$<br>\\text{Need}[i][j] &#x3D; \\text{Max}[i][j] - \\text{Allocation}[i][j].<br>$$</p>\n<blockquote>\n<p>只有在 <code>Request ≤ Need</code> 且 <code>Request ≤ Available</code> 的条件下，才会尝试分配。更重要的是，真正分配前还要做一次“安全性检查”（Safety Check）。</p>\n</blockquote>\n<hr>\n<h2 id=\"什么是“安全状态”？\"><a href=\"#什么是“安全状态”？\" class=\"headerlink\" title=\"什么是“安全状态”？\"></a>什么是“安全状态”？</h2><p>“安全状态”意味着：<strong>即便所有进程都提出最坏请求，系统依然能保证按某种顺序让它们一个个拿到资源、干完活再归还。</strong></p>\n<p><img src=\"https://gitee.com/tanke11223344/imagehost/raw/main/blog/1749361523852SZ4fbKIHtohXHVxeJyncXATFngN.png\" alt=\"1749361523852SZ4fbKIHtohXHVxeJyncXATFngN.png\"></p>\n<p>要检测这一点，算法会模拟一个“假设执行”过程：</p>\n<ol>\n<li>复制一份可用资源 <code>Work = Available</code>，并标记所有进程 <code>Finish[i] = false</code>。</li>\n<li>找到一个 <code>Finish[i]==false</code> 且其 <code>Need[i] ≤ Work</code> 的进程 $P_i$（说明它现在提出最大需求也能满足）。</li>\n<li>假设让它拿到所需资源并执行完毕：把它手里原本的 <code>Allocation[i]</code> 全部“还给”Work (<code>Work += Allocation[i]</code>)，并把 <code>Finish[i]=true</code>。</li>\n<li>重复第 2、3 步，直到没有可满足的进程为止。</li>\n<li>如果最后所有 <code>Finish[i]</code> 都变成了 <code>true</code>，说明系统处于安全状态；否则，不安全。</li>\n</ol>\n<hr>\n<h2 id=\"分配资源前的“试探”与回滚\"><a href=\"#分配资源前的“试探”与回滚\" class=\"headerlink\" title=\"分配资源前的“试探”与回滚\"></a>分配资源前的“试探”与回滚</h2><p>当某个进程 $P_i$ 发出一笔资源请求 <code>Request[i]</code> 时，银行家算法按照以下步骤执行：</p>\n<h3 id=\"合法性检查\"><a href=\"#合法性检查\" class=\"headerlink\" title=\"合法性检查\"></a><strong>合法性检查</strong></h3><ul>\n<li>若 <code>Request[i][j] &gt; Need[i][j]</code> ——进程请求超过申报最大值，直接报错；</li>\n<li>若 <code>Request[i][j] &gt; Available[j]</code> ——当前可用资源不足，让进程等待。</li>\n</ul>\n<h3 id=\"试探性分配\"><a href=\"#试探性分配\" class=\"headerlink\" title=\"试探性分配\"></a><strong>试探性分配</strong></h3><figure class=\"highlight inform7\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">Available   := Available - Request<span class=\"comment\">[i]</span></span><br><span class=\"line\">Allocation<span class=\"comment\">[i]</span> := Allocation<span class=\"comment\">[i]</span> + Request<span class=\"comment\">[i]</span></span><br><span class=\"line\">Need<span class=\"comment\">[i]</span>      := Need<span class=\"comment\">[i]</span> - Request<span class=\"comment\">[i]</span></span><br></pre></td></tr></table></figure>\n\n<h3 id=\"安全性检测\"><a href=\"#安全性检测\" class=\"headerlink\" title=\"安全性检测\"></a><strong>安全性检测</strong></h3><ul>\n<li>如果“假设执行”后仍处于安全状态，就真正批准这笔分配；</li>\n<li>否则回退到分配前的状态，让进程继续等待。</li>\n</ul>\n<p>这样，系统永远不会进入一个“一旦分配就死锁”的局面。</p>\n<hr>\n<h2 id=\"一步步示例演示\"><a href=\"#一步步示例演示\" class=\"headerlink\" title=\"一步步示例演示\"></a>一步步示例演示</h2><p><img src=\"https://gitee.com/tanke11223344/imagehost/raw/main/blog/1749361538853O7BAb59LFoU6gqxAchUc6gBLnEf.png\" alt=\"1749361538853O7BAb59LFoU6gqxAchUc6gBLnEf.png\"></p>\n<p>假设有 5 个进程 $P_0…P_4$，3 类资源 $A,B,C$，初始数据如下：</p>\n<figure class=\"highlight makefile\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">Available = [3, 3, 2]   // 还空闲的 A、B、C 实例数</span><br><span class=\"line\"></span><br><span class=\"line\">Max =</span><br><span class=\"line\"><span class=\"section\">P0: [7, 5, 3]  </span></span><br><span class=\"line\"><span class=\"section\">P1: [3, 2, 2]</span></span><br><span class=\"line\"><span class=\"section\">P2: [9, 0, 2]</span></span><br><span class=\"line\"><span class=\"section\">P3: [2, 2, 2]</span></span><br><span class=\"line\"><span class=\"section\">P4: [4, 3, 3]</span></span><br><span class=\"line\"></span><br><span class=\"line\">Allocation =</span><br><span class=\"line\"><span class=\"section\">P0: [0, 1, 0]</span></span><br><span class=\"line\"><span class=\"section\">P1: [2, 0, 0]</span></span><br><span class=\"line\"><span class=\"section\">P2: [3, 0, 2]</span></span><br><span class=\"line\"><span class=\"section\">P3: [2, 1, 1]</span></span><br><span class=\"line\"><span class=\"section\">P4: [0, 0, 2]</span></span><br><span class=\"line\"></span><br><span class=\"line\">Need = Max − Allocation =</span><br><span class=\"line\"><span class=\"section\">P0: [7,4,3]</span></span><br><span class=\"line\"><span class=\"section\">P1: [1,2,2]</span></span><br><span class=\"line\"><span class=\"section\">P2: [6,0,0]</span></span><br><span class=\"line\"><span class=\"section\">P3: [0,1,1]</span></span><br><span class=\"line\"><span class=\"section\">P4: [4,3,1]</span></span><br></pre></td></tr></table></figure>\n\n<h3 id=\"安全性检查示例\"><a href=\"#安全性检查示例\" class=\"headerlink\" title=\"安全性检查示例\"></a>安全性检查示例</h3><ol>\n<li><code>Work = [3,3,2]</code></li>\n<li>找到 $P_1$（Need <code>[1,2,2]</code> ≤ Work）→ “假设”它执行并还资源 →</li>\n</ol>\n<figure class=\"highlight inform7\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">Work = <span class=\"comment\">[3,3,2]</span> + Alloc<span class=\"comment\">[P1]</span>=<span class=\"comment\">[2,0,0]</span> = <span class=\"comment\">[5,3,2]</span></span><br><span class=\"line\">Finish<span class=\"comment\">[P1]</span> = true</span><br></pre></td></tr></table></figure>\n\n<ol>\n<li>再找 $P_3$（Need <code>[0,1,1]</code> ≤ <code>[5,3,2]</code>），放行并还：</li>\n</ol>\n<figure class=\"highlight inform7\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">Work = <span class=\"comment\">[5,3,2]</span> + <span class=\"comment\">[2,1,1]</span> = <span class=\"comment\">[7,4,3]</span></span><br><span class=\"line\">Finish<span class=\"comment\">[P3]</span> = true</span><br></pre></td></tr></table></figure>\n\n<ol>\n<li>然后 $P_0$, $P_2$, $P_4$ 依次被发现、安全、放行……最终所有 <code>Finish[]</code> 都是 <code>true</code>，说明系统安全。</li>\n</ol>\n<h3 id=\"进程发请求示例\"><a href=\"#进程发请求示例\" class=\"headerlink\" title=\"进程发请求示例\"></a>进程发请求示例</h3><p>若 $P_1$ 再请求 <code>[1,0,2]</code>：</p>\n<ol>\n<li><code>Request</code> ≤ <code>Need</code> &amp;&amp; ≤ <code>Available</code>（<code>[3,3,2]</code>），合法；</li>\n<li>暂时分配后 <code>Available’=[2,3,0]</code>，<code>Alloc[1]=[3,0,2]</code>，<code>Need[1]=[0,2,0]</code>；</li>\n<li>再用安全性检查，仍找得一条完成序列 → 批准；</li>\n</ol>\n<p>反之，若分配后安全性检查失败，就拒绝这次请求并回滚，保证系统永不死锁。</p>\n<hr>\n<h2 id=\"代码实现\"><a href=\"#代码实现\" class=\"headerlink\" title=\"代码实现\"></a>代码实现</h2><h3 id=\"C-版本\"><a href=\"#C-版本\" class=\"headerlink\" title=\"C++ 版本\"></a>C++ 版本</h3><figure class=\"highlight cpp\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br><span class=\"line\">47</span><br><span class=\"line\">48</span><br><span class=\"line\">49</span><br><span class=\"line\">50</span><br><span class=\"line\">51</span><br><span class=\"line\">52</span><br><span class=\"line\">53</span><br><span class=\"line\">54</span><br><span class=\"line\">55</span><br><span class=\"line\">56</span><br><span class=\"line\">57</span><br><span class=\"line\">58</span><br><span class=\"line\">59</span><br><span class=\"line\">60</span><br><span class=\"line\">61</span><br><span class=\"line\">62</span><br><span class=\"line\">63</span><br><span class=\"line\">64</span><br><span class=\"line\">65</span><br><span class=\"line\">66</span><br><span class=\"line\">67</span><br><span class=\"line\">68</span><br><span class=\"line\">69</span><br><span class=\"line\">70</span><br><span class=\"line\">71</span><br><span class=\"line\">72</span><br><span class=\"line\">73</span><br><span class=\"line\">74</span><br><span class=\"line\">75</span><br><span class=\"line\">76</span><br><span class=\"line\">77</span><br><span class=\"line\">78</span><br><span class=\"line\">79</span><br><span class=\"line\">80</span><br><span class=\"line\">81</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">#<span class=\"keyword\">include</span> <span class=\"string\">&lt;vector&gt;</span></span></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"keyword\">include</span> <span class=\"string\">&lt;iostream&gt;</span></span></span><br><span class=\"line\"><span class=\"keyword\">using</span> <span class=\"keyword\">namespace</span> std;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// 安全性检查</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"type\">bool</span> <span class=\"title\">isSafe</span><span class=\"params\">(vector&lt;<span class=\"type\">int</span>&gt; Available,</span></span></span><br><span class=\"line\"><span class=\"params\"><span class=\"function\">            vector&lt;vector&lt;<span class=\"type\">int</span>&gt;&gt;&amp; Max,</span></span></span><br><span class=\"line\"><span class=\"params\"><span class=\"function\">            vector&lt;vector&lt;<span class=\"type\">int</span>&gt;&gt;&amp; Alloc)</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"type\">int</span> n = Max.<span class=\"built_in\">size</span>(), m = Available.<span class=\"built_in\">size</span>();</span><br><span class=\"line\">    vector&lt;<span class=\"type\">int</span>&gt; Work = Available;</span><br><span class=\"line\">    <span class=\"function\">vector&lt;<span class=\"type\">bool</span>&gt; <span class=\"title\">Finish</span><span class=\"params\">(n, <span class=\"literal\">false</span>)</span></span>;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\">// 计算 Need</span></span><br><span class=\"line\">    vector&lt;vector&lt;<span class=\"type\">int</span>&gt;&gt; <span class=\"built_in\">Need</span>(n, <span class=\"built_in\">vector</span>&lt;<span class=\"type\">int</span>&gt;(m));</span><br><span class=\"line\">    <span class=\"keyword\">for</span> (<span class=\"type\">int</span> i = <span class=\"number\">0</span>; i &lt; n; ++i)</span><br><span class=\"line\">      <span class=\"keyword\">for</span> (<span class=\"type\">int</span> j = <span class=\"number\">0</span>; j &lt; m; ++j)</span><br><span class=\"line\">        Need[i][j] = Max[i][j] - Alloc[i][j];</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\">// 模拟放行</span></span><br><span class=\"line\">    <span class=\"keyword\">for</span> (<span class=\"type\">int</span> k = <span class=\"number\">0</span>; k &lt; n; ++k) &#123;</span><br><span class=\"line\">        <span class=\"type\">bool</span> found = <span class=\"literal\">false</span>;</span><br><span class=\"line\">        <span class=\"keyword\">for</span> (<span class=\"type\">int</span> i = <span class=\"number\">0</span>; i &lt; n; ++i) &#123;</span><br><span class=\"line\">            <span class=\"keyword\">if</span> (!Finish[i]) &#123;</span><br><span class=\"line\">                <span class=\"type\">bool</span> ok = <span class=\"literal\">true</span>;</span><br><span class=\"line\">                <span class=\"keyword\">for</span> (<span class=\"type\">int</span> j = <span class=\"number\">0</span>; j &lt; m; ++j)</span><br><span class=\"line\">                    <span class=\"keyword\">if</span> (Need[i][j] &gt; Work[j]) &#123; ok = <span class=\"literal\">false</span>; <span class=\"keyword\">break</span>; &#125;</span><br><span class=\"line\">                <span class=\"keyword\">if</span> (ok) &#123;</span><br><span class=\"line\">                    <span class=\"keyword\">for</span> (<span class=\"type\">int</span> j = <span class=\"number\">0</span>; j &lt; m; ++j) Work[j] += Alloc[i][j];</span><br><span class=\"line\">                    Finish[i] = <span class=\"literal\">true</span>;</span><br><span class=\"line\">                    found = <span class=\"literal\">true</span>;</span><br><span class=\"line\">                &#125;</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        <span class=\"keyword\">if</span> (!found) <span class=\"keyword\">break</span>;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"comment\">// 全能放行才安全</span></span><br><span class=\"line\">    <span class=\"keyword\">for</span> (<span class=\"type\">bool</span> f : Finish) <span class=\"keyword\">if</span> (!f) <span class=\"keyword\">return</span> <span class=\"literal\">false</span>;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> <span class=\"literal\">true</span>;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// 请求资源接口</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"type\">bool</span> <span class=\"title\">requestResource</span><span class=\"params\">(<span class=\"type\">int</span> pid, vector&lt;<span class=\"type\">int</span>&gt; Request,</span></span></span><br><span class=\"line\"><span class=\"params\"><span class=\"function\">                     vector&lt;<span class=\"type\">int</span>&gt;&amp; Available,</span></span></span><br><span class=\"line\"><span class=\"params\"><span class=\"function\">                     vector&lt;vector&lt;<span class=\"type\">int</span>&gt;&gt;&amp; Max,</span></span></span><br><span class=\"line\"><span class=\"params\"><span class=\"function\">                     vector&lt;vector&lt;<span class=\"type\">int</span>&gt;&gt;&amp; Alloc)</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"type\">int</span> m = Available.<span class=\"built_in\">size</span>();</span><br><span class=\"line\">    <span class=\"comment\">// 合法性检查</span></span><br><span class=\"line\">    <span class=\"keyword\">for</span> (<span class=\"type\">int</span> j = <span class=\"number\">0</span>; j &lt; m; ++j)</span><br><span class=\"line\">        <span class=\"keyword\">if</span> (Request[j] &gt; Max[pid][j] - Alloc[pid][j]</span><br><span class=\"line\">         || Request[j] &gt; Available[j]) <span class=\"keyword\">return</span> <span class=\"literal\">false</span>;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\">// 试探性分配</span></span><br><span class=\"line\">    <span class=\"keyword\">for</span> (<span class=\"type\">int</span> j = <span class=\"number\">0</span>; j &lt; m; ++j) &#123;</span><br><span class=\"line\">        Available[j] -= Request[j];</span><br><span class=\"line\">        Alloc[pid][j]   += Request[j];</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\">// 安全检测：通过就保留，否则回滚</span></span><br><span class=\"line\">    <span class=\"keyword\">if</span> (<span class=\"built_in\">isSafe</span>(Available, Max, Alloc)) <span class=\"keyword\">return</span> <span class=\"literal\">true</span>;</span><br><span class=\"line\">    <span class=\"keyword\">for</span> (<span class=\"type\">int</span> j = <span class=\"number\">0</span>; j &lt; m; ++j) &#123;</span><br><span class=\"line\">        Available[j] += Request[j];</span><br><span class=\"line\">        Alloc[pid][j]   -= Request[j];</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> <span class=\"literal\">false</span>;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"type\">int</span> <span class=\"title\">main</span><span class=\"params\">()</span></span>&#123;</span><br><span class=\"line\">    vector&lt;<span class=\"type\">int</span>&gt; Available&#123;<span class=\"number\">3</span>,<span class=\"number\">3</span>,<span class=\"number\">2</span>&#125;;</span><br><span class=\"line\">    vector&lt;vector&lt;<span class=\"type\">int</span>&gt;&gt; Max&#123;</span><br><span class=\"line\">        &#123;<span class=\"number\">7</span>,<span class=\"number\">5</span>,<span class=\"number\">3</span>&#125;,&#123;<span class=\"number\">3</span>,<span class=\"number\">2</span>,<span class=\"number\">2</span>&#125;,&#123;<span class=\"number\">9</span>,<span class=\"number\">0</span>,<span class=\"number\">2</span>&#125;,&#123;<span class=\"number\">2</span>,<span class=\"number\">2</span>,<span class=\"number\">2</span>&#125;,&#123;<span class=\"number\">4</span>,<span class=\"number\">3</span>,<span class=\"number\">3</span>&#125;</span><br><span class=\"line\">    &#125;;</span><br><span class=\"line\">    vector&lt;vector&lt;<span class=\"type\">int</span>&gt;&gt; Alloc&#123;</span><br><span class=\"line\">        &#123;<span class=\"number\">0</span>,<span class=\"number\">1</span>,<span class=\"number\">0</span>&#125;,&#123;<span class=\"number\">2</span>,<span class=\"number\">0</span>,<span class=\"number\">0</span>&#125;,&#123;<span class=\"number\">3</span>,<span class=\"number\">0</span>,<span class=\"number\">2</span>&#125;,&#123;<span class=\"number\">2</span>,<span class=\"number\">1</span>,<span class=\"number\">1</span>&#125;,&#123;<span class=\"number\">0</span>,<span class=\"number\">0</span>,<span class=\"number\">2</span>&#125;</span><br><span class=\"line\">    &#125;;</span><br><span class=\"line\"></span><br><span class=\"line\">    cout &lt;&lt; <span class=\"string\">&quot;初始安全? &quot;</span> &lt;&lt; (<span class=\"built_in\">isSafe</span>(Available, Max, Alloc) ? <span class=\"string\">&quot;是\\n&quot;</span> : <span class=\"string\">&quot;否\\n&quot;</span>);</span><br><span class=\"line\"></span><br><span class=\"line\">    vector&lt;<span class=\"type\">int</span>&gt; req&#123;<span class=\"number\">1</span>,<span class=\"number\">0</span>,<span class=\"number\">2</span>&#125;;</span><br><span class=\"line\">    cout &lt;&lt; <span class=\"string\">&quot;P1 请求 [1,0,2]: &quot;</span></span><br><span class=\"line\">         &lt;&lt; (<span class=\"built_in\">requestResource</span>(<span class=\"number\">1</span>, req, Available, Max, Alloc) ? <span class=\"string\">&quot;批准\\n&quot;</span>:<span class=\"string\">&quot;拒绝\\n&quot;</span>);</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<h3 id=\"Python-版本\"><a href=\"#Python-版本\" class=\"headerlink\" title=\"Python 版本\"></a>Python 版本</h3><figure class=\"highlight python\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">def</span> <span class=\"title function_\">is_safe</span>(<span class=\"params\">available, max_d, alloc</span>):</span><br><span class=\"line\">    n, m = <span class=\"built_in\">len</span>(max_d), <span class=\"built_in\">len</span>(available)</span><br><span class=\"line\">    work = available[:]</span><br><span class=\"line\">    finish = [<span class=\"literal\">False</span>]*n</span><br><span class=\"line\">    need = [[max_d[i][j]-alloc[i][j] <span class=\"keyword\">for</span> j <span class=\"keyword\">in</span> <span class=\"built_in\">range</span>(m)]</span><br><span class=\"line\">            <span class=\"keyword\">for</span> i <span class=\"keyword\">in</span> <span class=\"built_in\">range</span>(n)]</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">while</span> <span class=\"literal\">True</span>:</span><br><span class=\"line\">        found = <span class=\"literal\">False</span></span><br><span class=\"line\">        <span class=\"keyword\">for</span> i <span class=\"keyword\">in</span> <span class=\"built_in\">range</span>(n):</span><br><span class=\"line\">            <span class=\"keyword\">if</span> <span class=\"keyword\">not</span> finish[i] <span class=\"keyword\">and</span> <span class=\"built_in\">all</span>(need[i][j] &lt;= work[j] <span class=\"keyword\">for</span> j <span class=\"keyword\">in</span> <span class=\"built_in\">range</span>(m)):</span><br><span class=\"line\">                <span class=\"keyword\">for</span> j <span class=\"keyword\">in</span> <span class=\"built_in\">range</span>(m):</span><br><span class=\"line\">                    work[j] += alloc[i][j]</span><br><span class=\"line\">                finish[i] = <span class=\"literal\">True</span></span><br><span class=\"line\">                found = <span class=\"literal\">True</span></span><br><span class=\"line\">        <span class=\"keyword\">if</span> <span class=\"keyword\">not</span> found: <span class=\"keyword\">break</span></span><br><span class=\"line\">    <span class=\"keyword\">return</span> <span class=\"built_in\">all</span>(finish)</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">def</span> <span class=\"title function_\">request_resource</span>(<span class=\"params\">pid, req, available, max_d, alloc</span>):</span><br><span class=\"line\">    m = <span class=\"built_in\">len</span>(available)</span><br><span class=\"line\">    <span class=\"comment\"># 合法性检查</span></span><br><span class=\"line\">    <span class=\"keyword\">for</span> j <span class=\"keyword\">in</span> <span class=\"built_in\">range</span>(m):</span><br><span class=\"line\">        <span class=\"keyword\">if</span> req[j] &gt; max_d[pid][j]-alloc[pid][j] <span class=\"keyword\">or</span> req[j] &gt; available[j]:</span><br><span class=\"line\">            <span class=\"keyword\">return</span> <span class=\"literal\">False</span></span><br><span class=\"line\">    <span class=\"comment\"># 试探分配</span></span><br><span class=\"line\">    <span class=\"keyword\">for</span> j <span class=\"keyword\">in</span> <span class=\"built_in\">range</span>(m):</span><br><span class=\"line\">        available[j] -= req[j]</span><br><span class=\"line\">        alloc[pid][j] += req[j]</span><br><span class=\"line\">    <span class=\"keyword\">if</span> is_safe(available, max_d, alloc):</span><br><span class=\"line\">        <span class=\"keyword\">return</span> <span class=\"literal\">True</span></span><br><span class=\"line\">    <span class=\"comment\"># 回滚</span></span><br><span class=\"line\">    <span class=\"keyword\">for</span> j <span class=\"keyword\">in</span> <span class=\"built_in\">range</span>(m):</span><br><span class=\"line\">        available[j] += req[j]</span><br><span class=\"line\">        alloc[pid][j] -= req[j]</span><br><span class=\"line\">    <span class=\"keyword\">return</span> <span class=\"literal\">False</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">if</span> __name__ == <span class=\"string\">&quot;__main__&quot;</span>:</span><br><span class=\"line\">    avail = [<span class=\"number\">3</span>,<span class=\"number\">3</span>,<span class=\"number\">2</span>]</span><br><span class=\"line\">    max_d = [[<span class=\"number\">7</span>,<span class=\"number\">5</span>,<span class=\"number\">3</span>],[<span class=\"number\">3</span>,<span class=\"number\">2</span>,<span class=\"number\">2</span>],[<span class=\"number\">9</span>,<span class=\"number\">0</span>,<span class=\"number\">2</span>],[<span class=\"number\">2</span>,<span class=\"number\">2</span>,<span class=\"number\">2</span>],[<span class=\"number\">4</span>,<span class=\"number\">3</span>,<span class=\"number\">3</span>]]</span><br><span class=\"line\">    alloc = [[<span class=\"number\">0</span>,<span class=\"number\">1</span>,<span class=\"number\">0</span>],[<span class=\"number\">2</span>,<span class=\"number\">0</span>,<span class=\"number\">0</span>],[<span class=\"number\">3</span>,<span class=\"number\">0</span>,<span class=\"number\">2</span>],[<span class=\"number\">2</span>,<span class=\"number\">1</span>,<span class=\"number\">1</span>],[<span class=\"number\">0</span>,<span class=\"number\">0</span>,<span class=\"number\">2</span>]]</span><br><span class=\"line\">    <span class=\"built_in\">print</span>(<span class=\"string\">&quot;初始安全?&quot;</span>, is_safe(avail, max_d, alloc))</span><br><span class=\"line\">    <span class=\"built_in\">print</span>(<span class=\"string\">&quot;P1 请求 [1,0,2]:&quot;</span>,</span><br><span class=\"line\">          <span class=\"string\">&quot;批准&quot;</span> <span class=\"keyword\">if</span> request_resource(<span class=\"number\">1</span>, [<span class=\"number\">1</span>,<span class=\"number\">0</span>,<span class=\"number\">2</span>], avail, max_d, alloc) <span class=\"keyword\">else</span> <span class=\"string\">&quot;拒绝&quot;</span>)</span><br></pre></td></tr></table></figure>\n\n<h3 id=\"Go-版本\"><a href=\"#Go-版本\" class=\"headerlink\" title=\"Go 版本\"></a>Go 版本</h3><figure class=\"highlight go\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br><span class=\"line\">47</span><br><span class=\"line\">48</span><br><span class=\"line\">49</span><br><span class=\"line\">50</span><br><span class=\"line\">51</span><br><span class=\"line\">52</span><br><span class=\"line\">53</span><br><span class=\"line\">54</span><br><span class=\"line\">55</span><br><span class=\"line\">56</span><br><span class=\"line\">57</span><br><span class=\"line\">58</span><br><span class=\"line\">59</span><br><span class=\"line\">60</span><br><span class=\"line\">61</span><br><span class=\"line\">62</span><br><span class=\"line\">63</span><br><span class=\"line\">64</span><br><span class=\"line\">65</span><br><span class=\"line\">66</span><br><span class=\"line\">67</span><br><span class=\"line\">68</span><br><span class=\"line\">69</span><br><span class=\"line\">70</span><br><span class=\"line\">71</span><br><span class=\"line\">72</span><br><span class=\"line\">73</span><br><span class=\"line\">74</span><br><span class=\"line\">75</span><br><span class=\"line\">76</span><br><span class=\"line\">77</span><br><span class=\"line\">78</span><br><span class=\"line\">79</span><br><span class=\"line\">80</span><br><span class=\"line\">81</span><br><span class=\"line\">82</span><br><span class=\"line\">83</span><br><span class=\"line\">84</span><br><span class=\"line\">85</span><br><span class=\"line\">86</span><br><span class=\"line\">87</span><br><span class=\"line\">88</span><br><span class=\"line\">89</span><br><span class=\"line\">90</span><br><span class=\"line\">91</span><br><span class=\"line\">92</span><br><span class=\"line\">93</span><br><span class=\"line\">94</span><br><span class=\"line\">95</span><br><span class=\"line\">96</span><br><span class=\"line\">97</span><br><span class=\"line\">98</span><br><span class=\"line\">99</span><br><span class=\"line\">100</span><br><span class=\"line\">101</span><br><span class=\"line\">102</span><br><span class=\"line\">103</span><br><span class=\"line\">104</span><br><span class=\"line\">105</span><br><span class=\"line\">106</span><br><span class=\"line\">107</span><br><span class=\"line\">108</span><br><span class=\"line\">109</span><br><span class=\"line\">110</span><br><span class=\"line\">111</span><br><span class=\"line\">112</span><br><span class=\"line\">113</span><br><span class=\"line\">114</span><br><span class=\"line\">115</span><br><span class=\"line\">116</span><br><span class=\"line\">117</span><br><span class=\"line\">118</span><br><span class=\"line\">119</span><br><span class=\"line\">120</span><br><span class=\"line\">121</span><br><span class=\"line\">122</span><br><span class=\"line\">123</span><br><span class=\"line\">124</span><br><span class=\"line\">125</span><br><span class=\"line\">126</span><br><span class=\"line\">127</span><br><span class=\"line\">128</span><br><span class=\"line\">129</span><br><span class=\"line\">130</span><br><span class=\"line\">131</span><br><span class=\"line\">132</span><br><span class=\"line\">133</span><br><span class=\"line\">134</span><br><span class=\"line\">135</span><br><span class=\"line\">136</span><br><span class=\"line\">137</span><br><span class=\"line\">138</span><br><span class=\"line\">139</span><br><span class=\"line\">140</span><br><span class=\"line\">141</span><br><span class=\"line\">142</span><br><span class=\"line\">143</span><br><span class=\"line\">144</span><br><span class=\"line\">145</span><br><span class=\"line\">146</span><br><span class=\"line\">147</span><br><span class=\"line\">148</span><br><span class=\"line\">149</span><br><span class=\"line\">150</span><br><span class=\"line\">151</span><br><span class=\"line\">152</span><br><span class=\"line\">153</span><br><span class=\"line\">154</span><br><span class=\"line\">155</span><br><span class=\"line\">156</span><br><span class=\"line\">157</span><br><span class=\"line\">158</span><br><span class=\"line\">159</span><br><span class=\"line\">160</span><br><span class=\"line\">161</span><br><span class=\"line\">162</span><br><span class=\"line\">163</span><br><span class=\"line\">164</span><br><span class=\"line\">165</span><br><span class=\"line\">166</span><br><span class=\"line\">167</span><br><span class=\"line\">168</span><br><span class=\"line\">169</span><br><span class=\"line\">170</span><br><span class=\"line\">171</span><br><span class=\"line\">172</span><br><span class=\"line\">173</span><br><span class=\"line\">174</span><br><span class=\"line\">175</span><br><span class=\"line\">176</span><br><span class=\"line\">177</span><br><span class=\"line\">178</span><br><span class=\"line\">179</span><br><span class=\"line\">180</span><br><span class=\"line\">181</span><br><span class=\"line\">182</span><br><span class=\"line\">183</span><br><span class=\"line\">184</span><br><span class=\"line\">185</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">package</span> main</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">import</span> <span class=\"string\">&quot;fmt&quot;</span></span><br><span class=\"line\"></span><br><span class=\"line\">_<span class=\"comment\">// BankersAlgorithm 结构体定义了银行家算法所需的数据结构_</span></span><br><span class=\"line\">_<span class=\"comment\">// available: 可用资源向量_</span></span><br><span class=\"line\">_<span class=\"comment\">// max: 最大需求矩阵_</span></span><br><span class=\"line\">_<span class=\"comment\">// allocation: 分配矩阵_</span></span><br><span class=\"line\">_<span class=\"comment\">// need: 需求矩阵_</span></span><br><span class=\"line\"><span class=\"keyword\">type</span> BankersAlgorithm <span class=\"keyword\">struct</span> &#123;</span><br><span class=\"line\"> **available**  []<span class=\"type\">int</span></span><br><span class=\"line\"> **max**        [][]<span class=\"type\">int</span></span><br><span class=\"line\"> **allocation** [][]<span class=\"type\">int</span></span><br><span class=\"line\"> **need**       [][]<span class=\"type\">int</span></span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">_<span class=\"comment\">// NewBankersAlgorithm 初始化银行家算法_</span></span><br><span class=\"line\">_<span class=\"comment\">// 参数:_</span></span><br><span class=\"line\">_<span class=\"comment\">//   - available: 系统可用资源向量_</span></span><br><span class=\"line\">_<span class=\"comment\">//   - max: 进程最大需求矩阵_</span></span><br><span class=\"line\">_<span class=\"comment\">//   - allocation: 当前分配矩阵_</span></span><br><span class=\"line\">_<span class=\"comment\">// 返回: 初始化后的银行家算法实例_</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">func</span> <span class=\"title\">NewBankersAlgorithm</span><span class=\"params\">(available []<span class=\"type\">int</span>, max [][]<span class=\"type\">int</span>, allocation [][]<span class=\"type\">int</span>)</span></span> *BankersAlgorithm &#123;</span><br><span class=\"line\"> _<span class=\"comment\">// 创建新的银行家算法实例_</span></span><br><span class=\"line\"> ba := &amp;BankersAlgorithm&#123;</span><br><span class=\"line\">  **available**:  <span class=\"built_in\">make</span>([]<span class=\"type\">int</span>, <span class=\"built_in\">len</span>(available)),</span><br><span class=\"line\">  **max**:        <span class=\"built_in\">make</span>([][]<span class=\"type\">int</span>, <span class=\"built_in\">len</span>(max)),</span><br><span class=\"line\">  **allocation**: <span class=\"built_in\">make</span>([][]<span class=\"type\">int</span>, <span class=\"built_in\">len</span>(allocation)),</span><br><span class=\"line\">  **need**:       <span class=\"built_in\">make</span>([][]<span class=\"type\">int</span>, <span class=\"built_in\">len</span>(max)),</span><br><span class=\"line\"> &#125;</span><br><span class=\"line\"></span><br><span class=\"line\"> _<span class=\"comment\">// 复制可用资源向量_</span></span><br><span class=\"line\"> <span class=\"built_in\">copy</span>(ba.available, available)</span><br><span class=\"line\"> </span><br><span class=\"line\"> _<span class=\"comment\">// 复制最大需求矩阵_</span></span><br><span class=\"line\"> <span class=\"keyword\">for</span> i := <span class=\"keyword\">range</span> max &#123;</span><br><span class=\"line\">  ba.max[i] = <span class=\"built_in\">make</span>([]<span class=\"type\">int</span>, <span class=\"built_in\">len</span>(max[i]))</span><br><span class=\"line\">  <span class=\"built_in\">copy</span>(ba.max[i], max[i])</span><br><span class=\"line\"> &#125;</span><br><span class=\"line\"> </span><br><span class=\"line\"> _<span class=\"comment\">// 复制分配矩阵_</span></span><br><span class=\"line\"> <span class=\"keyword\">for</span> i := <span class=\"keyword\">range</span> allocation &#123;</span><br><span class=\"line\">  ba.allocation[i] = <span class=\"built_in\">make</span>([]<span class=\"type\">int</span>, <span class=\"built_in\">len</span>(allocation[i]))</span><br><span class=\"line\">  <span class=\"built_in\">copy</span>(ba.allocation[i], allocation[i])</span><br><span class=\"line\"> &#125;</span><br><span class=\"line\"></span><br><span class=\"line\"> _<span class=\"comment\">// 计算需求矩阵 need = max - allocation_</span></span><br><span class=\"line\"> <span class=\"keyword\">for</span> i := <span class=\"keyword\">range</span> max &#123;</span><br><span class=\"line\">  ba.need[i] = <span class=\"built_in\">make</span>([]<span class=\"type\">int</span>, <span class=\"built_in\">len</span>(max[i]))</span><br><span class=\"line\">  <span class=\"keyword\">for</span> j := <span class=\"keyword\">range</span> max[i] &#123;</span><br><span class=\"line\">   ba.need[i][j] = max[i][j] - allocation[i][j]</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\"> &#125;</span><br><span class=\"line\"></span><br><span class=\"line\"> <span class=\"keyword\">return</span> ba</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">_<span class=\"comment\">// RequestResources 处理进程的资源请求_</span></span><br><span class=\"line\">_<span class=\"comment\">// 参数:_</span></span><br><span class=\"line\">_<span class=\"comment\">//   - processID: 请求资源的进程ID_</span></span><br><span class=\"line\">_<span class=\"comment\">//   - request: 请求的资源向量_</span></span><br><span class=\"line\">_<span class=\"comment\">// 返回: 请求是否成功_</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">func</span> <span class=\"params\">(ba *BankersAlgorithm)</span></span> RequestResources(processID <span class=\"type\">int</span>, request []<span class=\"type\">int</span>) <span class=\"type\">bool</span> &#123;</span><br><span class=\"line\"> _<span class=\"comment\">// 检查请求是否超过最大需求_</span></span><br><span class=\"line\"> <span class=\"keyword\">for</span> i := <span class=\"keyword\">range</span> request &#123;</span><br><span class=\"line\">  <span class=\"keyword\">if</span> request[i] &gt; ba.need[processID][i] &#123;</span><br><span class=\"line\">   fmt.Printf(<span class=\"string\">&quot;进程 %d 请求的资源超过最大需求\\n&quot;</span>, processID)</span><br><span class=\"line\">   <span class=\"keyword\">return</span> <span class=\"literal\">false</span></span><br><span class=\"line\">  &#125;</span><br><span class=\"line\"> &#125;</span><br><span class=\"line\"></span><br><span class=\"line\"> _<span class=\"comment\">// 检查系统是否有足够的可用资源_</span></span><br><span class=\"line\"> <span class=\"keyword\">for</span> i := <span class=\"keyword\">range</span> request &#123;</span><br><span class=\"line\">  <span class=\"keyword\">if</span> request[i] &gt; ba.available[i] &#123;</span><br><span class=\"line\">   fmt.Printf(<span class=\"string\">&quot;资源不足，进程 %d 需等待\\n&quot;</span>, processID)</span><br><span class=\"line\">   <span class=\"keyword\">return</span> <span class=\"literal\">false</span></span><br><span class=\"line\">  &#125;</span><br><span class=\"line\"> &#125;</span><br><span class=\"line\"></span><br><span class=\"line\"> _<span class=\"comment\">// 试探性分配资源_</span></span><br><span class=\"line\"> <span class=\"keyword\">for</span> i := <span class=\"keyword\">range</span> request &#123;</span><br><span class=\"line\">  ba.available[i] -= request[i]</span><br><span class=\"line\">  ba.allocation[processID][i] += request[i]</span><br><span class=\"line\">  ba.need[processID][i] -= request[i]</span><br><span class=\"line\"> &#125;</span><br><span class=\"line\"></span><br><span class=\"line\"> _<span class=\"comment\">// 检查分配后系统是否安全_</span></span><br><span class=\"line\"> <span class=\"keyword\">if</span> !ba.isSafe() &#123;</span><br><span class=\"line\">  fmt.Println(<span class=\"string\">&quot;分配后系统处于不安全状态，撤销分配&quot;</span>)</span><br><span class=\"line\">  _<span class=\"comment\">// 撤销分配，恢复原状态_</span></span><br><span class=\"line\">  <span class=\"keyword\">for</span> i := <span class=\"keyword\">range</span> request &#123;</span><br><span class=\"line\">   ba.available[i] += request[i]</span><br><span class=\"line\">   ba.allocation[processID][i] -= request[i]</span><br><span class=\"line\">   ba.need[processID][i] += request[i]</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">  <span class=\"keyword\">return</span> <span class=\"literal\">false</span></span><br><span class=\"line\"> &#125;</span><br><span class=\"line\"></span><br><span class=\"line\"> fmt.Println(<span class=\"string\">&quot;资源分配成功，系统处于安全状态&quot;</span>)</span><br><span class=\"line\"> <span class=\"keyword\">return</span> <span class=\"literal\">true</span></span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">_<span class=\"comment\">// isSafe 检查系统是否处于安全状态_</span></span><br><span class=\"line\">_<span class=\"comment\">// 返回: 系统是否安全_</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">func</span> <span class=\"params\">(ba *BankersAlgorithm)</span></span> isSafe() <span class=\"type\">bool</span> &#123;</span><br><span class=\"line\"> _<span class=\"comment\">// 初始化工作向量和完成向量_</span></span><br><span class=\"line\"> work := <span class=\"built_in\">make</span>([]<span class=\"type\">int</span>, <span class=\"built_in\">len</span>(ba.available))</span><br><span class=\"line\"> <span class=\"built_in\">copy</span>(work, ba.available)</span><br><span class=\"line\"> finish := <span class=\"built_in\">make</span>([]<span class=\"type\">bool</span>, <span class=\"built_in\">len</span>(ba.max))</span><br><span class=\"line\"></span><br><span class=\"line\"> _<span class=\"comment\">// 寻找可以完成的进程_</span></span><br><span class=\"line\"> <span class=\"keyword\">for</span> &#123;</span><br><span class=\"line\">  found := <span class=\"literal\">false</span></span><br><span class=\"line\">  <span class=\"keyword\">for</span> i := <span class=\"keyword\">range</span> ba.max &#123;</span><br><span class=\"line\">   <span class=\"keyword\">if</span> !finish[i] &amp;&amp; ba.canFinish(work, ba.need[i]) &#123;</span><br><span class=\"line\">    _<span class=\"comment\">// 进程i可以完成，释放其资源_</span></span><br><span class=\"line\">    <span class=\"keyword\">for</span> j := <span class=\"keyword\">range</span> work &#123;</span><br><span class=\"line\">     work[j] += ba.allocation[i][j]</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    finish[i] = <span class=\"literal\">true</span></span><br><span class=\"line\">    found = <span class=\"literal\">true</span></span><br><span class=\"line\">   &#125;</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">  <span class=\"keyword\">if</span> !found &#123;</span><br><span class=\"line\">   <span class=\"keyword\">break</span></span><br><span class=\"line\">  &#125;</span><br><span class=\"line\"> &#125;</span><br><span class=\"line\"></span><br><span class=\"line\"> _<span class=\"comment\">// 检查是否所有进程都能完成_</span></span><br><span class=\"line\"> <span class=\"keyword\">for</span> _, f := <span class=\"keyword\">range</span> finish &#123;</span><br><span class=\"line\">  <span class=\"keyword\">if</span> !f &#123;</span><br><span class=\"line\">   <span class=\"keyword\">return</span> <span class=\"literal\">false</span></span><br><span class=\"line\">  &#125;</span><br><span class=\"line\"> &#125;</span><br><span class=\"line\"></span><br><span class=\"line\"> <span class=\"keyword\">return</span> <span class=\"literal\">true</span></span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">_<span class=\"comment\">// canFinish 检查进程是否能够完成_</span></span><br><span class=\"line\">_<span class=\"comment\">// 参数:_</span></span><br><span class=\"line\">_<span class=\"comment\">//   - work: 当前可用资源向量_</span></span><br><span class=\"line\">_<span class=\"comment\">//   - need: 进程需求向量_</span></span><br><span class=\"line\">_<span class=\"comment\">// 返回: 进程是否可以完成_</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">func</span> <span class=\"params\">(ba *BankersAlgorithm)</span></span> canFinish(work []<span class=\"type\">int</span>, need []<span class=\"type\">int</span>) <span class=\"type\">bool</span> &#123;</span><br><span class=\"line\"> <span class=\"keyword\">for</span> i := <span class=\"keyword\">range</span> work &#123;</span><br><span class=\"line\">  <span class=\"keyword\">if</span> need[i] &gt; work[i] &#123;</span><br><span class=\"line\">   <span class=\"keyword\">return</span> <span class=\"literal\">false</span></span><br><span class=\"line\">  &#125;</span><br><span class=\"line\"> &#125;</span><br><span class=\"line\"> <span class=\"keyword\">return</span> <span class=\"literal\">true</span></span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">func</span> <span class=\"title\">main</span><span class=\"params\">()</span></span> &#123;</span><br><span class=\"line\"> _<span class=\"comment\">// 初始化系统资源数据_</span></span><br><span class=\"line\"> available := []<span class=\"type\">int</span>&#123;<span class=\"number\">3</span>, <span class=\"number\">3</span>, <span class=\"number\">2</span>&#125;  _<span class=\"comment\">// 可用资源向量_</span></span><br><span class=\"line\"> max := [][]<span class=\"type\">int</span>&#123;              _<span class=\"comment\">// 最大需求矩阵_</span></span><br><span class=\"line\">  &#123;<span class=\"number\">7</span>, <span class=\"number\">5</span>, <span class=\"number\">3</span>&#125;,</span><br><span class=\"line\">  &#123;<span class=\"number\">3</span>, <span class=\"number\">2</span>, <span class=\"number\">2</span>&#125;,</span><br><span class=\"line\">  &#123;<span class=\"number\">9</span>, <span class=\"number\">0</span>, <span class=\"number\">2</span>&#125;,</span><br><span class=\"line\">  &#123;<span class=\"number\">2</span>, <span class=\"number\">2</span>, <span class=\"number\">2</span>&#125;,</span><br><span class=\"line\">  &#123;<span class=\"number\">4</span>, <span class=\"number\">3</span>, <span class=\"number\">3</span>&#125;,</span><br><span class=\"line\"> &#125;</span><br><span class=\"line\"> allocation := [][]<span class=\"type\">int</span>&#123;       _<span class=\"comment\">// 当前分配矩阵_</span></span><br><span class=\"line\">  &#123;<span class=\"number\">0</span>, <span class=\"number\">1</span>, <span class=\"number\">0</span>&#125;,</span><br><span class=\"line\">  &#123;<span class=\"number\">2</span>, <span class=\"number\">0</span>, <span class=\"number\">0</span>&#125;,</span><br><span class=\"line\">  &#123;<span class=\"number\">3</span>, <span class=\"number\">0</span>, <span class=\"number\">2</span>&#125;,</span><br><span class=\"line\">  &#123;<span class=\"number\">2</span>, <span class=\"number\">1</span>, <span class=\"number\">1</span>&#125;,</span><br><span class=\"line\">  &#123;<span class=\"number\">0</span>, <span class=\"number\">0</span>, <span class=\"number\">2</span>&#125;,</span><br><span class=\"line\"> &#125;</span><br><span class=\"line\"></span><br><span class=\"line\"> _<span class=\"comment\">// 创建银行家算法实例_</span></span><br><span class=\"line\"> ba := NewBankersAlgorithm(available, max, allocation)</span><br><span class=\"line\"></span><br><span class=\"line\"> _<span class=\"comment\">// 模拟进程1请求资源_</span></span><br><span class=\"line\"> processID := <span class=\"number\">1</span></span><br><span class=\"line\"> request := []<span class=\"type\">int</span>&#123;<span class=\"number\">0</span>, <span class=\"number\">2</span>, <span class=\"number\">0</span>&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"> _<span class=\"comment\">// 处理资源请求_</span></span><br><span class=\"line\"> <span class=\"keyword\">if</span> ba.RequestResources(processID, request) &#123;</span><br><span class=\"line\">  fmt.Println(<span class=\"string\">&quot;资源分配成功&quot;</span>)</span><br><span class=\"line\"> &#125; <span class=\"keyword\">else</span> &#123;</span><br><span class=\"line\">  fmt.Println(<span class=\"string\">&quot;资源分配失败&quot;</span>)</span><br><span class=\"line\"> &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<hr>\n<h2 id=\"算法效率与适用场景\"><a href=\"#算法效率与适用场景\" class=\"headerlink\" title=\"算法效率与适用场景\"></a>算法效率与适用场景</h2><ul>\n<li><strong>时间复杂度</strong>：每次请求都要调用一次安全性检查，最坏 $O(n^2 \\times m)$（$n$ 是进程数，$m$ 是资源种类数）。</li>\n<li><strong>优点</strong>：只要需求申报准确，能彻底避免死锁；逻辑清晰，易于理解与实现。</li>\n<li><strong>缺点</strong>：</li>\n</ul>\n<ol>\n<li>计算量较大，不适合大量进程和资源同时在线的场景；</li>\n<li>要求进程提前申报最大需求，有时难以预估；</li>\n<li>如果申报过高就浪费资源，过低又可能限制并发度。</li>\n</ol>\n<p><strong>典型应用</strong>：</p>\n<blockquote>\n<p>嵌入式实时系统、小型操作系统、数据库连接池管理等场景——进程&#x2F;线程数目不多、资源类型有限、死锁成本高，正好适合使用银行家算法来保证系统健康运行。</p>\n</blockquote>\n<hr>\n<h1 id=\"总结\"><a href=\"#总结\" class=\"headerlink\" title=\"总结\"></a>总结</h1><p>银行家算法用“银行发放贷款”这一比喻，把死锁避免转化为“安全性检查 + 试探性分配 + 回滚”三步走。理解它的核心，就是：</p>\n<ol>\n<li><strong>维护 Available&#x2F;Max&#x2F;Allocation&#x2F;Need</strong> 这四张“账本”；</li>\n<li><strong>安全性检测</strong>：模拟最坏情况看系统是否还能让所有进程“还清”资源；</li>\n<li><strong>只在安全状态下正式分配</strong>，否则拒绝并回滚。</li>\n</ol>\n<p>这样的设计保证了系统永不进入死锁，但也带来了计算开销和使用局限。在实际工程中，我们要根据并发规模与实时性要求，权衡是否使用这一经典算法。希望本文的通俗讲解和示例代码，能让你对银行家算法有清晰而深入的理解。</p>\n","excerpt":"","more":"<h1 id=\"银行家算法分析\"><a href=\"#银行家算法分析\" class=\"headerlink\" title=\"银行家算法分析\"></a>银行家算法分析</h1><h1 id=\"参考资料\"><a href=\"#参考资料\" class=\"headerlink\" title=\"参考资料\"></a>参考资料</h1><blockquote>\n<ul>\n<li><a href=\"https://www.cnblogs.com/wkfvawl/p/11929508.html\">操作系统——银行家算法(Banker&#39;s Algorithm) - 王陆 - 博客园</a></li>\n<li><a href=\"https://blog.csdn.net/qq_63976098/article/details/133957267?utm_medium=distribute.pc_relevant.none-task-blog-2~default~baidujs_baidulandingword~default-0-133957267-blog-112762387.235%5Ev43%5Epc_blog_bottom_relevance_base1&spm=1001.2101.3001.4242.1&utm_relevant_index=2\">操作系统 - 《银行家算法》_1、银行家算法的应用,根据题目要求能够找到某种状态下的安全序列,当进程请求资源-CSDN 博客</a></li>\n<li><a href=\"https://blog.csdn.net/weixin_39478524/article/details/80604876?spm=1001.2101.3001.6650.3&utm_medium=distribute.pc_relevant.none-task-blog-2~default~BlogCommendFromBaidu~Rate-3-80604876-blog-112762387.235%5Ev43%5Epc_blog_bottom_relevance_base1&depth_1-utm_source=distribute.pc_relevant.none-task-blog-2~default~BlogCommendFromBaidu~Rate-3-80604876-blog-112762387.235%5Ev43%5Epc_blog_bottom_relevance_base1&utm_relevant_index=5\">银行家算法详解与实现-CSDN 博客</a></li>\n<li><a href=\"https://github.com/TCL606/BankerAlgorithm\">GitHub - TCL606&#x2F;BankerAlgorithm: 银行家算法示例</a></li>\n</ul>\n</blockquote>\n<h1 id=\"概述\"><a href=\"#概述\" class=\"headerlink\" title=\"概述\"></a>概述</h1><blockquote>\n<ul>\n<li><a href=\"https://www.cnblogs.com/xiaolincoding/p/14604726.html\">面试官:什么是死锁?怎么排查死锁?怎么避免死锁? - 小林 coding - 博客园</a></li>\n<li><a href=\"https://blog.csdn.net/Appleeatingboy/article/details/122425760\">死锁解析-CSDN 博客</a></li>\n</ul>\n</blockquote>\n<p><img src=\"https://gitee.com/tanke11223344/imagehost/raw/main/blog/1749361500080AZV1b08W0oKjH6xawopc1lAMnId.png\" alt=\"1749361500080AZV1b08W0oKjH6xawopc1lAMnId.png\"></p>\n<p>持有并等待条件导致的死锁</p>\n<p>在多进程或多线程并发访问资源的场景下，<a href=\"https://zh.wikipedia.org/zh-cn/%E6%AD%BB%E9%94%81\">死锁</a>（Deadlock）是一种让人头疼的问题：几个任务相互等待，谁也拿不到继续执行的机会。银行家算法（Banker’s Algorithm）就是荷兰计算机科学家 Dijkstra 提出的一套“贷款”式资源分配方案，保证系统不陷入死锁。</p>\n<hr>\n<h2 id=\"为什么需要银行家算法\"><a href=\"#为什么需要银行家算法\" class=\"headerlink\" title=\"为什么需要银行家算法\"></a>为什么需要银行家算法</h2><p>想象一家银行有一笔总资金，多个客户（进程）可能随时来申请贷款（资源）。如果不加以控制，一旦所有客户都拿走部分贷款，却留下一些客户的需求得不到满足，就可能让银行陷入“钱不够分”又“谁也不肯还款”的窘境。操作系统中的资源（内存块、I&#x2F;O 通道、锁等）同理：若乱放行，很可能出现死锁，各进程互相等待而永远卡住。</p>\n<blockquote>\n<p>在银行中，客户申请贷款的数量是有限的，每个客户在第一次申请贷款时要声明完成该项目所需的最大资金量，在满足所有贷款要求时，客户应及时归还。银行家在客户申请的贷款数量不超过自己拥有的最大值时，都应尽量满足客户的需要。在这样的描述中，银行家就好比操作系统，资金就是资源，客户就相当于要申请资源的进程。</p>\n</blockquote>\n<p><strong>银行家算法</strong>的核心思想是：</p>\n<blockquote>\n<p><strong>在满足安全条件的前提下才分配资源，永远确保系统处于“安全状态”——即总能找到一种方式，让所有进程依次完成。</strong></p>\n</blockquote>\n<hr>\n<h2 id=\"算法流程\"><a href=\"#算法流程\" class=\"headerlink\" title=\"算法流程\"></a>算法流程</h2><p><img src=\"https://gitee.com/tanke11223344/imagehost/raw/main/blog/1749361508854CGbfbU3Dyo2pNKxusM6ctBtQnzc.png\" alt=\"1749361508854CGbfbU3Dyo2pNKxusM6ctBtQnzc.png\"></p>\n<h2 id=\"算法需要管理的“账本”\"><a href=\"#算法需要管理的“账本”\" class=\"headerlink\" title=\"算法需要管理的“账本”\"></a>算法需要管理的“账本”</h2><p>银行家算法维护四张表&#x2F;向量，仿佛银行的“账本”：</p>\n<ol>\n<li><strong>Available</strong>（可用资源向量）</li>\n</ol>\n<p>系统当前还剩余多少个各类资源可以分配。</p>\n<ol>\n<li><strong>Max</strong>（最大需求矩阵）</li>\n</ol>\n<p>每个进程一生中最多可能向系统请求多少该类资源，事先必须申报。</p>\n<ol>\n<li><strong>Allocation</strong>（已分配矩阵）</li>\n</ol>\n<p>系统已发给每个进程多少资源。</p>\n<ol>\n<li><strong>Need</strong>（需求矩阵）</li>\n</ol>\n<p>每个进程还“差”多少资源才算满足最大需求，它等于</p>\n<p>$$<br>\\text{Need}[i][j] &#x3D; \\text{Max}[i][j] - \\text{Allocation}[i][j].<br>$$</p>\n<blockquote>\n<p>只有在 <code>Request ≤ Need</code> 且 <code>Request ≤ Available</code> 的条件下，才会尝试分配。更重要的是，真正分配前还要做一次“安全性检查”（Safety Check）。</p>\n</blockquote>\n<hr>\n<h2 id=\"什么是“安全状态”？\"><a href=\"#什么是“安全状态”？\" class=\"headerlink\" title=\"什么是“安全状态”？\"></a>什么是“安全状态”？</h2><p>“安全状态”意味着：<strong>即便所有进程都提出最坏请求，系统依然能保证按某种顺序让它们一个个拿到资源、干完活再归还。</strong></p>\n<p><img src=\"https://gitee.com/tanke11223344/imagehost/raw/main/blog/1749361523852SZ4fbKIHtohXHVxeJyncXATFngN.png\" alt=\"1749361523852SZ4fbKIHtohXHVxeJyncXATFngN.png\"></p>\n<p>要检测这一点，算法会模拟一个“假设执行”过程：</p>\n<ol>\n<li>复制一份可用资源 <code>Work = Available</code>，并标记所有进程 <code>Finish[i] = false</code>。</li>\n<li>找到一个 <code>Finish[i]==false</code> 且其 <code>Need[i] ≤ Work</code> 的进程 $P_i$（说明它现在提出最大需求也能满足）。</li>\n<li>假设让它拿到所需资源并执行完毕：把它手里原本的 <code>Allocation[i]</code> 全部“还给”Work (<code>Work += Allocation[i]</code>)，并把 <code>Finish[i]=true</code>。</li>\n<li>重复第 2、3 步，直到没有可满足的进程为止。</li>\n<li>如果最后所有 <code>Finish[i]</code> 都变成了 <code>true</code>，说明系统处于安全状态；否则，不安全。</li>\n</ol>\n<hr>\n<h2 id=\"分配资源前的“试探”与回滚\"><a href=\"#分配资源前的“试探”与回滚\" class=\"headerlink\" title=\"分配资源前的“试探”与回滚\"></a>分配资源前的“试探”与回滚</h2><p>当某个进程 $P_i$ 发出一笔资源请求 <code>Request[i]</code> 时，银行家算法按照以下步骤执行：</p>\n<h3 id=\"合法性检查\"><a href=\"#合法性检查\" class=\"headerlink\" title=\"合法性检查\"></a><strong>合法性检查</strong></h3><ul>\n<li>若 <code>Request[i][j] &gt; Need[i][j]</code> ——进程请求超过申报最大值，直接报错；</li>\n<li>若 <code>Request[i][j] &gt; Available[j]</code> ——当前可用资源不足，让进程等待。</li>\n</ul>\n<h3 id=\"试探性分配\"><a href=\"#试探性分配\" class=\"headerlink\" title=\"试探性分配\"></a><strong>试探性分配</strong></h3><figure class=\"highlight inform7\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">Available   := Available - Request<span class=\"comment\">[i]</span></span><br><span class=\"line\">Allocation<span class=\"comment\">[i]</span> := Allocation<span class=\"comment\">[i]</span> + Request<span class=\"comment\">[i]</span></span><br><span class=\"line\">Need<span class=\"comment\">[i]</span>      := Need<span class=\"comment\">[i]</span> - Request<span class=\"comment\">[i]</span></span><br></pre></td></tr></table></figure>\n\n<h3 id=\"安全性检测\"><a href=\"#安全性检测\" class=\"headerlink\" title=\"安全性检测\"></a><strong>安全性检测</strong></h3><ul>\n<li>如果“假设执行”后仍处于安全状态，就真正批准这笔分配；</li>\n<li>否则回退到分配前的状态，让进程继续等待。</li>\n</ul>\n<p>这样，系统永远不会进入一个“一旦分配就死锁”的局面。</p>\n<hr>\n<h2 id=\"一步步示例演示\"><a href=\"#一步步示例演示\" class=\"headerlink\" title=\"一步步示例演示\"></a>一步步示例演示</h2><p><img src=\"https://gitee.com/tanke11223344/imagehost/raw/main/blog/1749361538853O7BAb59LFoU6gqxAchUc6gBLnEf.png\" alt=\"1749361538853O7BAb59LFoU6gqxAchUc6gBLnEf.png\"></p>\n<p>假设有 5 个进程 $P_0…P_4$，3 类资源 $A,B,C$，初始数据如下：</p>\n<figure class=\"highlight makefile\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">Available = [3, 3, 2]   // 还空闲的 A、B、C 实例数</span><br><span class=\"line\"></span><br><span class=\"line\">Max =</span><br><span class=\"line\"><span class=\"section\">P0: [7, 5, 3]  </span></span><br><span class=\"line\"><span class=\"section\">P1: [3, 2, 2]</span></span><br><span class=\"line\"><span class=\"section\">P2: [9, 0, 2]</span></span><br><span class=\"line\"><span class=\"section\">P3: [2, 2, 2]</span></span><br><span class=\"line\"><span class=\"section\">P4: [4, 3, 3]</span></span><br><span class=\"line\"></span><br><span class=\"line\">Allocation =</span><br><span class=\"line\"><span class=\"section\">P0: [0, 1, 0]</span></span><br><span class=\"line\"><span class=\"section\">P1: [2, 0, 0]</span></span><br><span class=\"line\"><span class=\"section\">P2: [3, 0, 2]</span></span><br><span class=\"line\"><span class=\"section\">P3: [2, 1, 1]</span></span><br><span class=\"line\"><span class=\"section\">P4: [0, 0, 2]</span></span><br><span class=\"line\"></span><br><span class=\"line\">Need = Max − Allocation =</span><br><span class=\"line\"><span class=\"section\">P0: [7,4,3]</span></span><br><span class=\"line\"><span class=\"section\">P1: [1,2,2]</span></span><br><span class=\"line\"><span class=\"section\">P2: [6,0,0]</span></span><br><span class=\"line\"><span class=\"section\">P3: [0,1,1]</span></span><br><span class=\"line\"><span class=\"section\">P4: [4,3,1]</span></span><br></pre></td></tr></table></figure>\n\n<h3 id=\"安全性检查示例\"><a href=\"#安全性检查示例\" class=\"headerlink\" title=\"安全性检查示例\"></a>安全性检查示例</h3><ol>\n<li><code>Work = [3,3,2]</code></li>\n<li>找到 $P_1$（Need <code>[1,2,2]</code> ≤ Work）→ “假设”它执行并还资源 →</li>\n</ol>\n<figure class=\"highlight inform7\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">Work = <span class=\"comment\">[3,3,2]</span> + Alloc<span class=\"comment\">[P1]</span>=<span class=\"comment\">[2,0,0]</span> = <span class=\"comment\">[5,3,2]</span></span><br><span class=\"line\">Finish<span class=\"comment\">[P1]</span> = true</span><br></pre></td></tr></table></figure>\n\n<ol>\n<li>再找 $P_3$（Need <code>[0,1,1]</code> ≤ <code>[5,3,2]</code>），放行并还：</li>\n</ol>\n<figure class=\"highlight inform7\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">Work = <span class=\"comment\">[5,3,2]</span> + <span class=\"comment\">[2,1,1]</span> = <span class=\"comment\">[7,4,3]</span></span><br><span class=\"line\">Finish<span class=\"comment\">[P3]</span> = true</span><br></pre></td></tr></table></figure>\n\n<ol>\n<li>然后 $P_0$, $P_2$, $P_4$ 依次被发现、安全、放行……最终所有 <code>Finish[]</code> 都是 <code>true</code>，说明系统安全。</li>\n</ol>\n<h3 id=\"进程发请求示例\"><a href=\"#进程发请求示例\" class=\"headerlink\" title=\"进程发请求示例\"></a>进程发请求示例</h3><p>若 $P_1$ 再请求 <code>[1,0,2]</code>：</p>\n<ol>\n<li><code>Request</code> ≤ <code>Need</code> &amp;&amp; ≤ <code>Available</code>（<code>[3,3,2]</code>），合法；</li>\n<li>暂时分配后 <code>Available’=[2,3,0]</code>，<code>Alloc[1]=[3,0,2]</code>，<code>Need[1]=[0,2,0]</code>；</li>\n<li>再用安全性检查，仍找得一条完成序列 → 批准；</li>\n</ol>\n<p>反之，若分配后安全性检查失败，就拒绝这次请求并回滚，保证系统永不死锁。</p>\n<hr>\n<h2 id=\"代码实现\"><a href=\"#代码实现\" class=\"headerlink\" title=\"代码实现\"></a>代码实现</h2><h3 id=\"C-版本\"><a href=\"#C-版本\" class=\"headerlink\" title=\"C++ 版本\"></a>C++ 版本</h3><figure class=\"highlight cpp\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br><span class=\"line\">47</span><br><span class=\"line\">48</span><br><span class=\"line\">49</span><br><span class=\"line\">50</span><br><span class=\"line\">51</span><br><span class=\"line\">52</span><br><span class=\"line\">53</span><br><span class=\"line\">54</span><br><span class=\"line\">55</span><br><span class=\"line\">56</span><br><span class=\"line\">57</span><br><span class=\"line\">58</span><br><span class=\"line\">59</span><br><span class=\"line\">60</span><br><span class=\"line\">61</span><br><span class=\"line\">62</span><br><span class=\"line\">63</span><br><span class=\"line\">64</span><br><span class=\"line\">65</span><br><span class=\"line\">66</span><br><span class=\"line\">67</span><br><span class=\"line\">68</span><br><span class=\"line\">69</span><br><span class=\"line\">70</span><br><span class=\"line\">71</span><br><span class=\"line\">72</span><br><span class=\"line\">73</span><br><span class=\"line\">74</span><br><span class=\"line\">75</span><br><span class=\"line\">76</span><br><span class=\"line\">77</span><br><span class=\"line\">78</span><br><span class=\"line\">79</span><br><span class=\"line\">80</span><br><span class=\"line\">81</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">#<span class=\"keyword\">include</span> <span class=\"string\">&lt;vector&gt;</span></span></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"keyword\">include</span> <span class=\"string\">&lt;iostream&gt;</span></span></span><br><span class=\"line\"><span class=\"keyword\">using</span> <span class=\"keyword\">namespace</span> std;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// 安全性检查</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"type\">bool</span> <span class=\"title\">isSafe</span><span class=\"params\">(vector&lt;<span class=\"type\">int</span>&gt; Available,</span></span></span><br><span class=\"line\"><span class=\"params\"><span class=\"function\">            vector&lt;vector&lt;<span class=\"type\">int</span>&gt;&gt;&amp; Max,</span></span></span><br><span class=\"line\"><span class=\"params\"><span class=\"function\">            vector&lt;vector&lt;<span class=\"type\">int</span>&gt;&gt;&amp; Alloc)</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"type\">int</span> n = Max.<span class=\"built_in\">size</span>(), m = Available.<span class=\"built_in\">size</span>();</span><br><span class=\"line\">    vector&lt;<span class=\"type\">int</span>&gt; Work = Available;</span><br><span class=\"line\">    <span class=\"function\">vector&lt;<span class=\"type\">bool</span>&gt; <span class=\"title\">Finish</span><span class=\"params\">(n, <span class=\"literal\">false</span>)</span></span>;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\">// 计算 Need</span></span><br><span class=\"line\">    vector&lt;vector&lt;<span class=\"type\">int</span>&gt;&gt; <span class=\"built_in\">Need</span>(n, <span class=\"built_in\">vector</span>&lt;<span class=\"type\">int</span>&gt;(m));</span><br><span class=\"line\">    <span class=\"keyword\">for</span> (<span class=\"type\">int</span> i = <span class=\"number\">0</span>; i &lt; n; ++i)</span><br><span class=\"line\">      <span class=\"keyword\">for</span> (<span class=\"type\">int</span> j = <span class=\"number\">0</span>; j &lt; m; ++j)</span><br><span class=\"line\">        Need[i][j] = Max[i][j] - Alloc[i][j];</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\">// 模拟放行</span></span><br><span class=\"line\">    <span class=\"keyword\">for</span> (<span class=\"type\">int</span> k = <span class=\"number\">0</span>; k &lt; n; ++k) &#123;</span><br><span class=\"line\">        <span class=\"type\">bool</span> found = <span class=\"literal\">false</span>;</span><br><span class=\"line\">        <span class=\"keyword\">for</span> (<span class=\"type\">int</span> i = <span class=\"number\">0</span>; i &lt; n; ++i) &#123;</span><br><span class=\"line\">            <span class=\"keyword\">if</span> (!Finish[i]) &#123;</span><br><span class=\"line\">                <span class=\"type\">bool</span> ok = <span class=\"literal\">true</span>;</span><br><span class=\"line\">                <span class=\"keyword\">for</span> (<span class=\"type\">int</span> j = <span class=\"number\">0</span>; j &lt; m; ++j)</span><br><span class=\"line\">                    <span class=\"keyword\">if</span> (Need[i][j] &gt; Work[j]) &#123; ok = <span class=\"literal\">false</span>; <span class=\"keyword\">break</span>; &#125;</span><br><span class=\"line\">                <span class=\"keyword\">if</span> (ok) &#123;</span><br><span class=\"line\">                    <span class=\"keyword\">for</span> (<span class=\"type\">int</span> j = <span class=\"number\">0</span>; j &lt; m; ++j) Work[j] += Alloc[i][j];</span><br><span class=\"line\">                    Finish[i] = <span class=\"literal\">true</span>;</span><br><span class=\"line\">                    found = <span class=\"literal\">true</span>;</span><br><span class=\"line\">                &#125;</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        <span class=\"keyword\">if</span> (!found) <span class=\"keyword\">break</span>;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"comment\">// 全能放行才安全</span></span><br><span class=\"line\">    <span class=\"keyword\">for</span> (<span class=\"type\">bool</span> f : Finish) <span class=\"keyword\">if</span> (!f) <span class=\"keyword\">return</span> <span class=\"literal\">false</span>;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> <span class=\"literal\">true</span>;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// 请求资源接口</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"type\">bool</span> <span class=\"title\">requestResource</span><span class=\"params\">(<span class=\"type\">int</span> pid, vector&lt;<span class=\"type\">int</span>&gt; Request,</span></span></span><br><span class=\"line\"><span class=\"params\"><span class=\"function\">                     vector&lt;<span class=\"type\">int</span>&gt;&amp; Available,</span></span></span><br><span class=\"line\"><span class=\"params\"><span class=\"function\">                     vector&lt;vector&lt;<span class=\"type\">int</span>&gt;&gt;&amp; Max,</span></span></span><br><span class=\"line\"><span class=\"params\"><span class=\"function\">                     vector&lt;vector&lt;<span class=\"type\">int</span>&gt;&gt;&amp; Alloc)</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"type\">int</span> m = Available.<span class=\"built_in\">size</span>();</span><br><span class=\"line\">    <span class=\"comment\">// 合法性检查</span></span><br><span class=\"line\">    <span class=\"keyword\">for</span> (<span class=\"type\">int</span> j = <span class=\"number\">0</span>; j &lt; m; ++j)</span><br><span class=\"line\">        <span class=\"keyword\">if</span> (Request[j] &gt; Max[pid][j] - Alloc[pid][j]</span><br><span class=\"line\">         || Request[j] &gt; Available[j]) <span class=\"keyword\">return</span> <span class=\"literal\">false</span>;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\">// 试探性分配</span></span><br><span class=\"line\">    <span class=\"keyword\">for</span> (<span class=\"type\">int</span> j = <span class=\"number\">0</span>; j &lt; m; ++j) &#123;</span><br><span class=\"line\">        Available[j] -= Request[j];</span><br><span class=\"line\">        Alloc[pid][j]   += Request[j];</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\">// 安全检测：通过就保留，否则回滚</span></span><br><span class=\"line\">    <span class=\"keyword\">if</span> (<span class=\"built_in\">isSafe</span>(Available, Max, Alloc)) <span class=\"keyword\">return</span> <span class=\"literal\">true</span>;</span><br><span class=\"line\">    <span class=\"keyword\">for</span> (<span class=\"type\">int</span> j = <span class=\"number\">0</span>; j &lt; m; ++j) &#123;</span><br><span class=\"line\">        Available[j] += Request[j];</span><br><span class=\"line\">        Alloc[pid][j]   -= Request[j];</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> <span class=\"literal\">false</span>;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"type\">int</span> <span class=\"title\">main</span><span class=\"params\">()</span></span>&#123;</span><br><span class=\"line\">    vector&lt;<span class=\"type\">int</span>&gt; Available&#123;<span class=\"number\">3</span>,<span class=\"number\">3</span>,<span class=\"number\">2</span>&#125;;</span><br><span class=\"line\">    vector&lt;vector&lt;<span class=\"type\">int</span>&gt;&gt; Max&#123;</span><br><span class=\"line\">        &#123;<span class=\"number\">7</span>,<span class=\"number\">5</span>,<span class=\"number\">3</span>&#125;,&#123;<span class=\"number\">3</span>,<span class=\"number\">2</span>,<span class=\"number\">2</span>&#125;,&#123;<span class=\"number\">9</span>,<span class=\"number\">0</span>,<span class=\"number\">2</span>&#125;,&#123;<span class=\"number\">2</span>,<span class=\"number\">2</span>,<span class=\"number\">2</span>&#125;,&#123;<span class=\"number\">4</span>,<span class=\"number\">3</span>,<span class=\"number\">3</span>&#125;</span><br><span class=\"line\">    &#125;;</span><br><span class=\"line\">    vector&lt;vector&lt;<span class=\"type\">int</span>&gt;&gt; Alloc&#123;</span><br><span class=\"line\">        &#123;<span class=\"number\">0</span>,<span class=\"number\">1</span>,<span class=\"number\">0</span>&#125;,&#123;<span class=\"number\">2</span>,<span class=\"number\">0</span>,<span class=\"number\">0</span>&#125;,&#123;<span class=\"number\">3</span>,<span class=\"number\">0</span>,<span class=\"number\">2</span>&#125;,&#123;<span class=\"number\">2</span>,<span class=\"number\">1</span>,<span class=\"number\">1</span>&#125;,&#123;<span class=\"number\">0</span>,<span class=\"number\">0</span>,<span class=\"number\">2</span>&#125;</span><br><span class=\"line\">    &#125;;</span><br><span class=\"line\"></span><br><span class=\"line\">    cout &lt;&lt; <span class=\"string\">&quot;初始安全? &quot;</span> &lt;&lt; (<span class=\"built_in\">isSafe</span>(Available, Max, Alloc) ? <span class=\"string\">&quot;是\\n&quot;</span> : <span class=\"string\">&quot;否\\n&quot;</span>);</span><br><span class=\"line\"></span><br><span class=\"line\">    vector&lt;<span class=\"type\">int</span>&gt; req&#123;<span class=\"number\">1</span>,<span class=\"number\">0</span>,<span class=\"number\">2</span>&#125;;</span><br><span class=\"line\">    cout &lt;&lt; <span class=\"string\">&quot;P1 请求 [1,0,2]: &quot;</span></span><br><span class=\"line\">         &lt;&lt; (<span class=\"built_in\">requestResource</span>(<span class=\"number\">1</span>, req, Available, Max, Alloc) ? <span class=\"string\">&quot;批准\\n&quot;</span>:<span class=\"string\">&quot;拒绝\\n&quot;</span>);</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<h3 id=\"Python-版本\"><a href=\"#Python-版本\" class=\"headerlink\" title=\"Python 版本\"></a>Python 版本</h3><figure class=\"highlight python\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">def</span> <span class=\"title function_\">is_safe</span>(<span class=\"params\">available, max_d, alloc</span>):</span><br><span class=\"line\">    n, m = <span class=\"built_in\">len</span>(max_d), <span class=\"built_in\">len</span>(available)</span><br><span class=\"line\">    work = available[:]</span><br><span class=\"line\">    finish = [<span class=\"literal\">False</span>]*n</span><br><span class=\"line\">    need = [[max_d[i][j]-alloc[i][j] <span class=\"keyword\">for</span> j <span class=\"keyword\">in</span> <span class=\"built_in\">range</span>(m)]</span><br><span class=\"line\">            <span class=\"keyword\">for</span> i <span class=\"keyword\">in</span> <span class=\"built_in\">range</span>(n)]</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">while</span> <span class=\"literal\">True</span>:</span><br><span class=\"line\">        found = <span class=\"literal\">False</span></span><br><span class=\"line\">        <span class=\"keyword\">for</span> i <span class=\"keyword\">in</span> <span class=\"built_in\">range</span>(n):</span><br><span class=\"line\">            <span class=\"keyword\">if</span> <span class=\"keyword\">not</span> finish[i] <span class=\"keyword\">and</span> <span class=\"built_in\">all</span>(need[i][j] &lt;= work[j] <span class=\"keyword\">for</span> j <span class=\"keyword\">in</span> <span class=\"built_in\">range</span>(m)):</span><br><span class=\"line\">                <span class=\"keyword\">for</span> j <span class=\"keyword\">in</span> <span class=\"built_in\">range</span>(m):</span><br><span class=\"line\">                    work[j] += alloc[i][j]</span><br><span class=\"line\">                finish[i] = <span class=\"literal\">True</span></span><br><span class=\"line\">                found = <span class=\"literal\">True</span></span><br><span class=\"line\">        <span class=\"keyword\">if</span> <span class=\"keyword\">not</span> found: <span class=\"keyword\">break</span></span><br><span class=\"line\">    <span class=\"keyword\">return</span> <span class=\"built_in\">all</span>(finish)</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">def</span> <span class=\"title function_\">request_resource</span>(<span class=\"params\">pid, req, available, max_d, alloc</span>):</span><br><span class=\"line\">    m = <span class=\"built_in\">len</span>(available)</span><br><span class=\"line\">    <span class=\"comment\"># 合法性检查</span></span><br><span class=\"line\">    <span class=\"keyword\">for</span> j <span class=\"keyword\">in</span> <span class=\"built_in\">range</span>(m):</span><br><span class=\"line\">        <span class=\"keyword\">if</span> req[j] &gt; max_d[pid][j]-alloc[pid][j] <span class=\"keyword\">or</span> req[j] &gt; available[j]:</span><br><span class=\"line\">            <span class=\"keyword\">return</span> <span class=\"literal\">False</span></span><br><span class=\"line\">    <span class=\"comment\"># 试探分配</span></span><br><span class=\"line\">    <span class=\"keyword\">for</span> j <span class=\"keyword\">in</span> <span class=\"built_in\">range</span>(m):</span><br><span class=\"line\">        available[j] -= req[j]</span><br><span class=\"line\">        alloc[pid][j] += req[j]</span><br><span class=\"line\">    <span class=\"keyword\">if</span> is_safe(available, max_d, alloc):</span><br><span class=\"line\">        <span class=\"keyword\">return</span> <span class=\"literal\">True</span></span><br><span class=\"line\">    <span class=\"comment\"># 回滚</span></span><br><span class=\"line\">    <span class=\"keyword\">for</span> j <span class=\"keyword\">in</span> <span class=\"built_in\">range</span>(m):</span><br><span class=\"line\">        available[j] += req[j]</span><br><span class=\"line\">        alloc[pid][j] -= req[j]</span><br><span class=\"line\">    <span class=\"keyword\">return</span> <span class=\"literal\">False</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">if</span> __name__ == <span class=\"string\">&quot;__main__&quot;</span>:</span><br><span class=\"line\">    avail = [<span class=\"number\">3</span>,<span class=\"number\">3</span>,<span class=\"number\">2</span>]</span><br><span class=\"line\">    max_d = [[<span class=\"number\">7</span>,<span class=\"number\">5</span>,<span class=\"number\">3</span>],[<span class=\"number\">3</span>,<span class=\"number\">2</span>,<span class=\"number\">2</span>],[<span class=\"number\">9</span>,<span class=\"number\">0</span>,<span class=\"number\">2</span>],[<span class=\"number\">2</span>,<span class=\"number\">2</span>,<span class=\"number\">2</span>],[<span class=\"number\">4</span>,<span class=\"number\">3</span>,<span class=\"number\">3</span>]]</span><br><span class=\"line\">    alloc = [[<span class=\"number\">0</span>,<span class=\"number\">1</span>,<span class=\"number\">0</span>],[<span class=\"number\">2</span>,<span class=\"number\">0</span>,<span class=\"number\">0</span>],[<span class=\"number\">3</span>,<span class=\"number\">0</span>,<span class=\"number\">2</span>],[<span class=\"number\">2</span>,<span class=\"number\">1</span>,<span class=\"number\">1</span>],[<span class=\"number\">0</span>,<span class=\"number\">0</span>,<span class=\"number\">2</span>]]</span><br><span class=\"line\">    <span class=\"built_in\">print</span>(<span class=\"string\">&quot;初始安全?&quot;</span>, is_safe(avail, max_d, alloc))</span><br><span class=\"line\">    <span class=\"built_in\">print</span>(<span class=\"string\">&quot;P1 请求 [1,0,2]:&quot;</span>,</span><br><span class=\"line\">          <span class=\"string\">&quot;批准&quot;</span> <span class=\"keyword\">if</span> request_resource(<span class=\"number\">1</span>, [<span class=\"number\">1</span>,<span class=\"number\">0</span>,<span class=\"number\">2</span>], avail, max_d, alloc) <span class=\"keyword\">else</span> <span class=\"string\">&quot;拒绝&quot;</span>)</span><br></pre></td></tr></table></figure>\n\n<h3 id=\"Go-版本\"><a href=\"#Go-版本\" class=\"headerlink\" title=\"Go 版本\"></a>Go 版本</h3><figure class=\"highlight go\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br><span class=\"line\">47</span><br><span class=\"line\">48</span><br><span class=\"line\">49</span><br><span class=\"line\">50</span><br><span class=\"line\">51</span><br><span class=\"line\">52</span><br><span class=\"line\">53</span><br><span class=\"line\">54</span><br><span class=\"line\">55</span><br><span class=\"line\">56</span><br><span class=\"line\">57</span><br><span class=\"line\">58</span><br><span class=\"line\">59</span><br><span class=\"line\">60</span><br><span class=\"line\">61</span><br><span class=\"line\">62</span><br><span class=\"line\">63</span><br><span class=\"line\">64</span><br><span class=\"line\">65</span><br><span class=\"line\">66</span><br><span class=\"line\">67</span><br><span class=\"line\">68</span><br><span class=\"line\">69</span><br><span class=\"line\">70</span><br><span class=\"line\">71</span><br><span class=\"line\">72</span><br><span class=\"line\">73</span><br><span class=\"line\">74</span><br><span class=\"line\">75</span><br><span class=\"line\">76</span><br><span class=\"line\">77</span><br><span class=\"line\">78</span><br><span class=\"line\">79</span><br><span class=\"line\">80</span><br><span class=\"line\">81</span><br><span class=\"line\">82</span><br><span class=\"line\">83</span><br><span class=\"line\">84</span><br><span class=\"line\">85</span><br><span class=\"line\">86</span><br><span class=\"line\">87</span><br><span class=\"line\">88</span><br><span class=\"line\">89</span><br><span class=\"line\">90</span><br><span class=\"line\">91</span><br><span class=\"line\">92</span><br><span class=\"line\">93</span><br><span class=\"line\">94</span><br><span class=\"line\">95</span><br><span class=\"line\">96</span><br><span class=\"line\">97</span><br><span class=\"line\">98</span><br><span class=\"line\">99</span><br><span class=\"line\">100</span><br><span class=\"line\">101</span><br><span class=\"line\">102</span><br><span class=\"line\">103</span><br><span class=\"line\">104</span><br><span class=\"line\">105</span><br><span class=\"line\">106</span><br><span class=\"line\">107</span><br><span class=\"line\">108</span><br><span class=\"line\">109</span><br><span class=\"line\">110</span><br><span class=\"line\">111</span><br><span class=\"line\">112</span><br><span class=\"line\">113</span><br><span class=\"line\">114</span><br><span class=\"line\">115</span><br><span class=\"line\">116</span><br><span class=\"line\">117</span><br><span class=\"line\">118</span><br><span class=\"line\">119</span><br><span class=\"line\">120</span><br><span class=\"line\">121</span><br><span class=\"line\">122</span><br><span class=\"line\">123</span><br><span class=\"line\">124</span><br><span class=\"line\">125</span><br><span class=\"line\">126</span><br><span class=\"line\">127</span><br><span class=\"line\">128</span><br><span class=\"line\">129</span><br><span class=\"line\">130</span><br><span class=\"line\">131</span><br><span class=\"line\">132</span><br><span class=\"line\">133</span><br><span class=\"line\">134</span><br><span class=\"line\">135</span><br><span class=\"line\">136</span><br><span class=\"line\">137</span><br><span class=\"line\">138</span><br><span class=\"line\">139</span><br><span class=\"line\">140</span><br><span class=\"line\">141</span><br><span class=\"line\">142</span><br><span class=\"line\">143</span><br><span class=\"line\">144</span><br><span class=\"line\">145</span><br><span class=\"line\">146</span><br><span class=\"line\">147</span><br><span class=\"line\">148</span><br><span class=\"line\">149</span><br><span class=\"line\">150</span><br><span class=\"line\">151</span><br><span class=\"line\">152</span><br><span class=\"line\">153</span><br><span class=\"line\">154</span><br><span class=\"line\">155</span><br><span class=\"line\">156</span><br><span class=\"line\">157</span><br><span class=\"line\">158</span><br><span class=\"line\">159</span><br><span class=\"line\">160</span><br><span class=\"line\">161</span><br><span class=\"line\">162</span><br><span class=\"line\">163</span><br><span class=\"line\">164</span><br><span class=\"line\">165</span><br><span class=\"line\">166</span><br><span class=\"line\">167</span><br><span class=\"line\">168</span><br><span class=\"line\">169</span><br><span class=\"line\">170</span><br><span class=\"line\">171</span><br><span class=\"line\">172</span><br><span class=\"line\">173</span><br><span class=\"line\">174</span><br><span class=\"line\">175</span><br><span class=\"line\">176</span><br><span class=\"line\">177</span><br><span class=\"line\">178</span><br><span class=\"line\">179</span><br><span class=\"line\">180</span><br><span class=\"line\">181</span><br><span class=\"line\">182</span><br><span class=\"line\">183</span><br><span class=\"line\">184</span><br><span class=\"line\">185</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">package</span> main</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">import</span> <span class=\"string\">&quot;fmt&quot;</span></span><br><span class=\"line\"></span><br><span class=\"line\">_<span class=\"comment\">// BankersAlgorithm 结构体定义了银行家算法所需的数据结构_</span></span><br><span class=\"line\">_<span class=\"comment\">// available: 可用资源向量_</span></span><br><span class=\"line\">_<span class=\"comment\">// max: 最大需求矩阵_</span></span><br><span class=\"line\">_<span class=\"comment\">// allocation: 分配矩阵_</span></span><br><span class=\"line\">_<span class=\"comment\">// need: 需求矩阵_</span></span><br><span class=\"line\"><span class=\"keyword\">type</span> BankersAlgorithm <span class=\"keyword\">struct</span> &#123;</span><br><span class=\"line\"> **available**  []<span class=\"type\">int</span></span><br><span class=\"line\"> **max**        [][]<span class=\"type\">int</span></span><br><span class=\"line\"> **allocation** [][]<span class=\"type\">int</span></span><br><span class=\"line\"> **need**       [][]<span class=\"type\">int</span></span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">_<span class=\"comment\">// NewBankersAlgorithm 初始化银行家算法_</span></span><br><span class=\"line\">_<span class=\"comment\">// 参数:_</span></span><br><span class=\"line\">_<span class=\"comment\">//   - available: 系统可用资源向量_</span></span><br><span class=\"line\">_<span class=\"comment\">//   - max: 进程最大需求矩阵_</span></span><br><span class=\"line\">_<span class=\"comment\">//   - allocation: 当前分配矩阵_</span></span><br><span class=\"line\">_<span class=\"comment\">// 返回: 初始化后的银行家算法实例_</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">func</span> <span class=\"title\">NewBankersAlgorithm</span><span class=\"params\">(available []<span class=\"type\">int</span>, max [][]<span class=\"type\">int</span>, allocation [][]<span class=\"type\">int</span>)</span></span> *BankersAlgorithm &#123;</span><br><span class=\"line\"> _<span class=\"comment\">// 创建新的银行家算法实例_</span></span><br><span class=\"line\"> ba := &amp;BankersAlgorithm&#123;</span><br><span class=\"line\">  **available**:  <span class=\"built_in\">make</span>([]<span class=\"type\">int</span>, <span class=\"built_in\">len</span>(available)),</span><br><span class=\"line\">  **max**:        <span class=\"built_in\">make</span>([][]<span class=\"type\">int</span>, <span class=\"built_in\">len</span>(max)),</span><br><span class=\"line\">  **allocation**: <span class=\"built_in\">make</span>([][]<span class=\"type\">int</span>, <span class=\"built_in\">len</span>(allocation)),</span><br><span class=\"line\">  **need**:       <span class=\"built_in\">make</span>([][]<span class=\"type\">int</span>, <span class=\"built_in\">len</span>(max)),</span><br><span class=\"line\"> &#125;</span><br><span class=\"line\"></span><br><span class=\"line\"> _<span class=\"comment\">// 复制可用资源向量_</span></span><br><span class=\"line\"> <span class=\"built_in\">copy</span>(ba.available, available)</span><br><span class=\"line\"> </span><br><span class=\"line\"> _<span class=\"comment\">// 复制最大需求矩阵_</span></span><br><span class=\"line\"> <span class=\"keyword\">for</span> i := <span class=\"keyword\">range</span> max &#123;</span><br><span class=\"line\">  ba.max[i] = <span class=\"built_in\">make</span>([]<span class=\"type\">int</span>, <span class=\"built_in\">len</span>(max[i]))</span><br><span class=\"line\">  <span class=\"built_in\">copy</span>(ba.max[i], max[i])</span><br><span class=\"line\"> &#125;</span><br><span class=\"line\"> </span><br><span class=\"line\"> _<span class=\"comment\">// 复制分配矩阵_</span></span><br><span class=\"line\"> <span class=\"keyword\">for</span> i := <span class=\"keyword\">range</span> allocation &#123;</span><br><span class=\"line\">  ba.allocation[i] = <span class=\"built_in\">make</span>([]<span class=\"type\">int</span>, <span class=\"built_in\">len</span>(allocation[i]))</span><br><span class=\"line\">  <span class=\"built_in\">copy</span>(ba.allocation[i], allocation[i])</span><br><span class=\"line\"> &#125;</span><br><span class=\"line\"></span><br><span class=\"line\"> _<span class=\"comment\">// 计算需求矩阵 need = max - allocation_</span></span><br><span class=\"line\"> <span class=\"keyword\">for</span> i := <span class=\"keyword\">range</span> max &#123;</span><br><span class=\"line\">  ba.need[i] = <span class=\"built_in\">make</span>([]<span class=\"type\">int</span>, <span class=\"built_in\">len</span>(max[i]))</span><br><span class=\"line\">  <span class=\"keyword\">for</span> j := <span class=\"keyword\">range</span> max[i] &#123;</span><br><span class=\"line\">   ba.need[i][j] = max[i][j] - allocation[i][j]</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\"> &#125;</span><br><span class=\"line\"></span><br><span class=\"line\"> <span class=\"keyword\">return</span> ba</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">_<span class=\"comment\">// RequestResources 处理进程的资源请求_</span></span><br><span class=\"line\">_<span class=\"comment\">// 参数:_</span></span><br><span class=\"line\">_<span class=\"comment\">//   - processID: 请求资源的进程ID_</span></span><br><span class=\"line\">_<span class=\"comment\">//   - request: 请求的资源向量_</span></span><br><span class=\"line\">_<span class=\"comment\">// 返回: 请求是否成功_</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">func</span> <span class=\"params\">(ba *BankersAlgorithm)</span></span> RequestResources(processID <span class=\"type\">int</span>, request []<span class=\"type\">int</span>) <span class=\"type\">bool</span> &#123;</span><br><span class=\"line\"> _<span class=\"comment\">// 检查请求是否超过最大需求_</span></span><br><span class=\"line\"> <span class=\"keyword\">for</span> i := <span class=\"keyword\">range</span> request &#123;</span><br><span class=\"line\">  <span class=\"keyword\">if</span> request[i] &gt; ba.need[processID][i] &#123;</span><br><span class=\"line\">   fmt.Printf(<span class=\"string\">&quot;进程 %d 请求的资源超过最大需求\\n&quot;</span>, processID)</span><br><span class=\"line\">   <span class=\"keyword\">return</span> <span class=\"literal\">false</span></span><br><span class=\"line\">  &#125;</span><br><span class=\"line\"> &#125;</span><br><span class=\"line\"></span><br><span class=\"line\"> _<span class=\"comment\">// 检查系统是否有足够的可用资源_</span></span><br><span class=\"line\"> <span class=\"keyword\">for</span> i := <span class=\"keyword\">range</span> request &#123;</span><br><span class=\"line\">  <span class=\"keyword\">if</span> request[i] &gt; ba.available[i] &#123;</span><br><span class=\"line\">   fmt.Printf(<span class=\"string\">&quot;资源不足，进程 %d 需等待\\n&quot;</span>, processID)</span><br><span class=\"line\">   <span class=\"keyword\">return</span> <span class=\"literal\">false</span></span><br><span class=\"line\">  &#125;</span><br><span class=\"line\"> &#125;</span><br><span class=\"line\"></span><br><span class=\"line\"> _<span class=\"comment\">// 试探性分配资源_</span></span><br><span class=\"line\"> <span class=\"keyword\">for</span> i := <span class=\"keyword\">range</span> request &#123;</span><br><span class=\"line\">  ba.available[i] -= request[i]</span><br><span class=\"line\">  ba.allocation[processID][i] += request[i]</span><br><span class=\"line\">  ba.need[processID][i] -= request[i]</span><br><span class=\"line\"> &#125;</span><br><span class=\"line\"></span><br><span class=\"line\"> _<span class=\"comment\">// 检查分配后系统是否安全_</span></span><br><span class=\"line\"> <span class=\"keyword\">if</span> !ba.isSafe() &#123;</span><br><span class=\"line\">  fmt.Println(<span class=\"string\">&quot;分配后系统处于不安全状态，撤销分配&quot;</span>)</span><br><span class=\"line\">  _<span class=\"comment\">// 撤销分配，恢复原状态_</span></span><br><span class=\"line\">  <span class=\"keyword\">for</span> i := <span class=\"keyword\">range</span> request &#123;</span><br><span class=\"line\">   ba.available[i] += request[i]</span><br><span class=\"line\">   ba.allocation[processID][i] -= request[i]</span><br><span class=\"line\">   ba.need[processID][i] += request[i]</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">  <span class=\"keyword\">return</span> <span class=\"literal\">false</span></span><br><span class=\"line\"> &#125;</span><br><span class=\"line\"></span><br><span class=\"line\"> fmt.Println(<span class=\"string\">&quot;资源分配成功，系统处于安全状态&quot;</span>)</span><br><span class=\"line\"> <span class=\"keyword\">return</span> <span class=\"literal\">true</span></span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">_<span class=\"comment\">// isSafe 检查系统是否处于安全状态_</span></span><br><span class=\"line\">_<span class=\"comment\">// 返回: 系统是否安全_</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">func</span> <span class=\"params\">(ba *BankersAlgorithm)</span></span> isSafe() <span class=\"type\">bool</span> &#123;</span><br><span class=\"line\"> _<span class=\"comment\">// 初始化工作向量和完成向量_</span></span><br><span class=\"line\"> work := <span class=\"built_in\">make</span>([]<span class=\"type\">int</span>, <span class=\"built_in\">len</span>(ba.available))</span><br><span class=\"line\"> <span class=\"built_in\">copy</span>(work, ba.available)</span><br><span class=\"line\"> finish := <span class=\"built_in\">make</span>([]<span class=\"type\">bool</span>, <span class=\"built_in\">len</span>(ba.max))</span><br><span class=\"line\"></span><br><span class=\"line\"> _<span class=\"comment\">// 寻找可以完成的进程_</span></span><br><span class=\"line\"> <span class=\"keyword\">for</span> &#123;</span><br><span class=\"line\">  found := <span class=\"literal\">false</span></span><br><span class=\"line\">  <span class=\"keyword\">for</span> i := <span class=\"keyword\">range</span> ba.max &#123;</span><br><span class=\"line\">   <span class=\"keyword\">if</span> !finish[i] &amp;&amp; ba.canFinish(work, ba.need[i]) &#123;</span><br><span class=\"line\">    _<span class=\"comment\">// 进程i可以完成，释放其资源_</span></span><br><span class=\"line\">    <span class=\"keyword\">for</span> j := <span class=\"keyword\">range</span> work &#123;</span><br><span class=\"line\">     work[j] += ba.allocation[i][j]</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    finish[i] = <span class=\"literal\">true</span></span><br><span class=\"line\">    found = <span class=\"literal\">true</span></span><br><span class=\"line\">   &#125;</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">  <span class=\"keyword\">if</span> !found &#123;</span><br><span class=\"line\">   <span class=\"keyword\">break</span></span><br><span class=\"line\">  &#125;</span><br><span class=\"line\"> &#125;</span><br><span class=\"line\"></span><br><span class=\"line\"> _<span class=\"comment\">// 检查是否所有进程都能完成_</span></span><br><span class=\"line\"> <span class=\"keyword\">for</span> _, f := <span class=\"keyword\">range</span> finish &#123;</span><br><span class=\"line\">  <span class=\"keyword\">if</span> !f &#123;</span><br><span class=\"line\">   <span class=\"keyword\">return</span> <span class=\"literal\">false</span></span><br><span class=\"line\">  &#125;</span><br><span class=\"line\"> &#125;</span><br><span class=\"line\"></span><br><span class=\"line\"> <span class=\"keyword\">return</span> <span class=\"literal\">true</span></span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">_<span class=\"comment\">// canFinish 检查进程是否能够完成_</span></span><br><span class=\"line\">_<span class=\"comment\">// 参数:_</span></span><br><span class=\"line\">_<span class=\"comment\">//   - work: 当前可用资源向量_</span></span><br><span class=\"line\">_<span class=\"comment\">//   - need: 进程需求向量_</span></span><br><span class=\"line\">_<span class=\"comment\">// 返回: 进程是否可以完成_</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">func</span> <span class=\"params\">(ba *BankersAlgorithm)</span></span> canFinish(work []<span class=\"type\">int</span>, need []<span class=\"type\">int</span>) <span class=\"type\">bool</span> &#123;</span><br><span class=\"line\"> <span class=\"keyword\">for</span> i := <span class=\"keyword\">range</span> work &#123;</span><br><span class=\"line\">  <span class=\"keyword\">if</span> need[i] &gt; work[i] &#123;</span><br><span class=\"line\">   <span class=\"keyword\">return</span> <span class=\"literal\">false</span></span><br><span class=\"line\">  &#125;</span><br><span class=\"line\"> &#125;</span><br><span class=\"line\"> <span class=\"keyword\">return</span> <span class=\"literal\">true</span></span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">func</span> <span class=\"title\">main</span><span class=\"params\">()</span></span> &#123;</span><br><span class=\"line\"> _<span class=\"comment\">// 初始化系统资源数据_</span></span><br><span class=\"line\"> available := []<span class=\"type\">int</span>&#123;<span class=\"number\">3</span>, <span class=\"number\">3</span>, <span class=\"number\">2</span>&#125;  _<span class=\"comment\">// 可用资源向量_</span></span><br><span class=\"line\"> max := [][]<span class=\"type\">int</span>&#123;              _<span class=\"comment\">// 最大需求矩阵_</span></span><br><span class=\"line\">  &#123;<span class=\"number\">7</span>, <span class=\"number\">5</span>, <span class=\"number\">3</span>&#125;,</span><br><span class=\"line\">  &#123;<span class=\"number\">3</span>, <span class=\"number\">2</span>, <span class=\"number\">2</span>&#125;,</span><br><span class=\"line\">  &#123;<span class=\"number\">9</span>, <span class=\"number\">0</span>, <span class=\"number\">2</span>&#125;,</span><br><span class=\"line\">  &#123;<span class=\"number\">2</span>, <span class=\"number\">2</span>, <span class=\"number\">2</span>&#125;,</span><br><span class=\"line\">  &#123;<span class=\"number\">4</span>, <span class=\"number\">3</span>, <span class=\"number\">3</span>&#125;,</span><br><span class=\"line\"> &#125;</span><br><span class=\"line\"> allocation := [][]<span class=\"type\">int</span>&#123;       _<span class=\"comment\">// 当前分配矩阵_</span></span><br><span class=\"line\">  &#123;<span class=\"number\">0</span>, <span class=\"number\">1</span>, <span class=\"number\">0</span>&#125;,</span><br><span class=\"line\">  &#123;<span class=\"number\">2</span>, <span class=\"number\">0</span>, <span class=\"number\">0</span>&#125;,</span><br><span class=\"line\">  &#123;<span class=\"number\">3</span>, <span class=\"number\">0</span>, <span class=\"number\">2</span>&#125;,</span><br><span class=\"line\">  &#123;<span class=\"number\">2</span>, <span class=\"number\">1</span>, <span class=\"number\">1</span>&#125;,</span><br><span class=\"line\">  &#123;<span class=\"number\">0</span>, <span class=\"number\">0</span>, <span class=\"number\">2</span>&#125;,</span><br><span class=\"line\"> &#125;</span><br><span class=\"line\"></span><br><span class=\"line\"> _<span class=\"comment\">// 创建银行家算法实例_</span></span><br><span class=\"line\"> ba := NewBankersAlgorithm(available, max, allocation)</span><br><span class=\"line\"></span><br><span class=\"line\"> _<span class=\"comment\">// 模拟进程1请求资源_</span></span><br><span class=\"line\"> processID := <span class=\"number\">1</span></span><br><span class=\"line\"> request := []<span class=\"type\">int</span>&#123;<span class=\"number\">0</span>, <span class=\"number\">2</span>, <span class=\"number\">0</span>&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"> _<span class=\"comment\">// 处理资源请求_</span></span><br><span class=\"line\"> <span class=\"keyword\">if</span> ba.RequestResources(processID, request) &#123;</span><br><span class=\"line\">  fmt.Println(<span class=\"string\">&quot;资源分配成功&quot;</span>)</span><br><span class=\"line\"> &#125; <span class=\"keyword\">else</span> &#123;</span><br><span class=\"line\">  fmt.Println(<span class=\"string\">&quot;资源分配失败&quot;</span>)</span><br><span class=\"line\"> &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<hr>\n<h2 id=\"算法效率与适用场景\"><a href=\"#算法效率与适用场景\" class=\"headerlink\" title=\"算法效率与适用场景\"></a>算法效率与适用场景</h2><ul>\n<li><strong>时间复杂度</strong>：每次请求都要调用一次安全性检查，最坏 $O(n^2 \\times m)$（$n$ 是进程数，$m$ 是资源种类数）。</li>\n<li><strong>优点</strong>：只要需求申报准确，能彻底避免死锁；逻辑清晰，易于理解与实现。</li>\n<li><strong>缺点</strong>：</li>\n</ul>\n<ol>\n<li>计算量较大，不适合大量进程和资源同时在线的场景；</li>\n<li>要求进程提前申报最大需求，有时难以预估；</li>\n<li>如果申报过高就浪费资源，过低又可能限制并发度。</li>\n</ol>\n<p><strong>典型应用</strong>：</p>\n<blockquote>\n<p>嵌入式实时系统、小型操作系统、数据库连接池管理等场景——进程&#x2F;线程数目不多、资源类型有限、死锁成本高，正好适合使用银行家算法来保证系统健康运行。</p>\n</blockquote>\n<hr>\n<h1 id=\"总结\"><a href=\"#总结\" class=\"headerlink\" title=\"总结\"></a>总结</h1><p>银行家算法用“银行发放贷款”这一比喻，把死锁避免转化为“安全性检查 + 试探性分配 + 回滚”三步走。理解它的核心，就是：</p>\n<ol>\n<li><strong>维护 Available&#x2F;Max&#x2F;Allocation&#x2F;Need</strong> 这四张“账本”；</li>\n<li><strong>安全性检测</strong>：模拟最坏情况看系统是否还能让所有进程“还清”资源；</li>\n<li><strong>只在安全状态下正式分配</strong>，否则拒绝并回滚。</li>\n</ol>\n<p>这样的设计保证了系统永不进入死锁，但也带来了计算开销和使用局限。在实际工程中，我们要根据并发规模与实时性要求，权衡是否使用这一经典算法。希望本文的通俗讲解和示例代码，能让你对银行家算法有清晰而深入的理解。</p>\n"},{"title":"2025-05-17-scBridge","date":"2025-05-16T16:00:00.000Z","_content":"# 2025-05-17-scBridge embraces cell heterogeneity in single-cell RNA-seq and ATAC-seq data integration\n\n> # 相关资料\n>\n> [https://www.nature.com/articles/s41467-023-41795-5](https://www.nature.com/articles/s41467-023-41795-5)\n>\n> [scBridge embraces cell heterogeneity in single-cell RNA-seq and ATAC-seq data integration - PubMed](https://pubmed.ncbi.nlm.nih.gov/37770437/)\n>\n> [scBridge 的 Github 仓库](https://github.com/XLearning-SCU/scBridge)\n\n[https://github.com/GreenleafLab/MPAL-Single-Cell-2019](https://github.com/GreenleafLab/MPAL-Single-Cell-2019)\n\n# Motivation:\n\n> 概述:\n> scBridge 是一套面向单细胞多组学数据（scRNA-seq 与 scATAC-seq）整合的半监督异构迁移学习框架。它的核心策略是：先用标注的 scRNA-seq 数据“热身”（warm-up）一个深度编码器和分类器，然后根据每个 scATAC-seq 细胞与 RNA 原型的相似度和分类置信度，评估其在组学整合中的“可靠性”，再借助可靠的 ATAC 细胞对齐 RNA 原型；如此迭代，从“易”到“难”逐步缩小 RNA/ATAC 之间的调制差距。大量 benchmark 测试表明，scBridge 在嵌入质量、标签转移准确性和对注释稀缺、技术噪声的鲁棒性方面，均显著优于六种代表性方法（Harmony、Seurat、scJoint、Portal、GLUE、Conos）([Nature](https://www.nature.com/articles/s41467-023-41795-5))。\n\n![1747738599339BegjbomkVoa7Hpx1yEScx3mRn8f.png](https://tk-pichost-1325224430.cos.ap-chengdu.myqcloud.com/blog/1747738599339BegjbomkVoa7Hpx1yEScx3mRn8f.png)\n\n## 单细胞多组学整合的必要性\n\n- 单细胞 RNA 测序（scRNA-seq）可描绘基因表达全景，揭示细胞类型与状态的多样性；而单细胞 ATAC 测序（scATAC-seq）则刻画染色质可及性，用以探究基因调控机制([Frontiers](https://www.frontiersin.org/journals/genetics/articles/10.3389/fgene.2023.1199087/full?utm_source=chatgpt.com))。\n- 将两种组学 unpaired（非配对）数据整合，可从表达与调控层面构建更全面的细胞图谱，但它们在分布、稀疏性、噪声水平上差异巨大，给算法带来挑战([Nature](https://www.nature.com/articles/s41467-023-41795-5))。\n\n## 现有整合方法\n\n- **Harmony**：通过批次校正，将不同数据集投影到同一低维空间，突出细胞类型聚类而非实验条件([PMC](https://pmc.ncbi.nlm.nih.gov/articles/PMC6884693/?utm_source=chatgpt.com))。\n- **Seurat**：基于互为最近邻的锚点（MNN）和标签转移（Transfer Anchors）实现多模态共嵌入([Satija Lab](https://satijalab.org/seurat/articles/multimodal_vignette?utm_source=chatgpt.com))。\n- **scJoint**：半监督框架并行训练标注（scRNA）与未标注（scATAC）数据，完成标签转移和联合可视化([PMC](https://pmc.ncbi.nlm.nih.gov/articles/PMC9186323/?utm_source=chatgpt.com))。\n- **GLUE**：图模型理念，显式建模不同组学之间的调控网络，构建统一嵌入([Nature](https://www.nature.com/articles/s41587-022-01284-4?utm_source=chatgpt.com))。\n- **Conos**：通过全局图结构将多样本 scRNA 数据联通，突出细胞类型一致性传播([GitHub](https://github.com/kharchenkolab/conos?utm_source=chatgpt.com))。\n- **Portal**：基于对抗学习的半监督多组学整合管线（本文略）。\n\n这些方法多对所有细胞“一视同仁”地整合，未利用组学内部的“异质性”信息来引导模型从“易”到“难”分层对齐。\n\n![](static/BegjbomkVoa7Hpx1yEScx3mRn8f.png)\n\n# Method:\n\n## 异构迁移学习框架概览\n\nscBridge 将标注的 scRNA-seq 与未标注的 scATAC-seq 数据看作源域与目标域，通过迭代的迁移学习流程逐步对齐两种组学的嵌入表示(Nature)。\n\n1. **Warm-up（热身）**\n   使用带标签的 scRNA-seq 数据训练一个深度编码器 $f$ 和分类器 $g$，并计算出初始的 RNA 嵌入及原型（每种细胞类型的平均嵌入）([Nature](https://www.nature.com/articles/s41467-023-41795-5))。\n2. **可靠性建模**\n   对每个 scATAC-seq 细胞，计算其嵌入与 RNA 原型的欧氏距离（可辨识度）及分类器损失（置信度），并用高斯混合模型估计每个细胞的“可靠性”([Nature](https://www.nature.com/articles/s41467-023-41795-5))。\n3. **原型对齐**\n   根据可靠性加权平均选出同类型 ATAC 细胞，构建 ATAC 原型，并将其与对应的 RNA 原型对齐（例如最小化原型间距离）([Nature](https://www.nature.com/articles/s41467-023-41795-5))。\n4. **迭代融合**\n   将本轮最“可靠”的 ATAC 细胞加入标注集中，附带当前预测标签，重复上述热身 → 建模 → 对齐过程，直至所有细胞被整合完毕([Nature](https://www.nature.com/articles/s41467-023-41795-5))。\n\n# Result:\n\n## 黄金 benchmark 验证\n\n- 在三组“金标准”配对数据集（SNARE-seq 脑皮层、SHARE-seq 骨髓、10x Multiome 肾脏）上，虽然未使用配对信息，仅作验证，但 scBridge 在嵌入质量和标签转移上均领先六种基线方法([Nature](https://www.nature.com/articles/s41467-023-41795-5))。\n\n## 与主流方法对比\n\n- **标签转移准确率**：在 PBMC 数据集上，scBridge 平均比第二名 scJoint 提高约 5% 的准确率（p ≤ 1e−3）([Nature](https://www.nature.com/articles/s41467-023-41795-5))。\n- **鲁棒性测试**：在稀缺注释（25%、50%、75%）和不同 dropout 强度下，scBridge 均表现出更稳健的 F1 分数和轮廓系数([Nature](https://www.nature.com/articles/s41467-023-41795-5))。\n- **可扩展性**：由于仅需小批量优化，算法在细胞数量线性增长时占用常数内存，可轻松处理百万级别数据集([Nature](https://www.nature.com/articles/s41467-023-41795-5))。\n\n## 创新\n\n- **细胞异质性利用**：首次将组学内部的“易整合”细胞作为“桥梁”，显著提升跨模态对齐效果([Nature](https://www.nature.com/articles/s41467-023-41795-5))。\n- **从易到难的分层融合**：通过迭代引入可靠细胞，降低了一次性对齐带来的误差累积，可有效应对噪声与注释不足问题([Nature](https://www.nature.com/articles/s41467-023-41795-5))。\n- **通用性强**：框架输入只需保证行（细胞）一致，列（基因、蛋白等）需对齐，可推广到其他单细胞多组学场景([Nature](https://www.nature.com/articles/s41467-023-41795-5))。\n- **开源可复现**：论文随文附带代码与数据，方便社区复现与扩展([Semantic Scholar](https://www.semanticscholar.org/paper/scBridge-embraces-cell-heterogeneity-in-single-cell-Li-Zhang/a9d3933a9902c9e710823df4284a7bf7ab024177?utm_source=chatgpt.com))。\n\n## 未来展望\n\n- **更多模态融合**：可直接应用于蛋白质组、表观组等其他单细胞组学，构建更全面的细胞图谱。\n- **与自动注释工具结合**：可将任何组学注释数据纳入 heterogenous learning 流程，进一步提升新型细胞类型发现能力。\n- **下游分析拓展**：整合后嵌入可无缝接入细胞谱系追踪、调控网络推断等多种后续分析管线，为生物学研究提供新范式。\n\n# **Experiment:**\n\n## 我完成的任务与收获\n\n- 重装服务器的 conda 环境\n\n## 运行结果\n\n### umap_PBMC_CellType\n\n### umap_PBMC_Domain\n\n![](static/YzVibvyJhoS3Cexix0AcdNFDn6d.png)\n\n### umap_PBMC_Reliability\n\n![](static/KgrdbEYNSoTVI1xchbYccC0WnYb.png)![1747738616339KgrdbEYNSoTVI1xchbYccC0WnYb.png](https://tk-pichost-1325224430.cos.ap-chengdu.myqcloud.com/blog/1747738616339KgrdbEYNSoTVI1xchbYccC0WnYb.png)\n","source":"_posts/2025-05-17-scBridge embraces cell heterogeneity in single-cell RNA-seq and ATAC-seq data integration.md","raw":"---\ntitle: 2025-05-17-scBridge\ndate: 2025-05-17\ntags: \n    深度学习\n    论文阅读\n---\n# 2025-05-17-scBridge embraces cell heterogeneity in single-cell RNA-seq and ATAC-seq data integration\n\n> # 相关资料\n>\n> [https://www.nature.com/articles/s41467-023-41795-5](https://www.nature.com/articles/s41467-023-41795-5)\n>\n> [scBridge embraces cell heterogeneity in single-cell RNA-seq and ATAC-seq data integration - PubMed](https://pubmed.ncbi.nlm.nih.gov/37770437/)\n>\n> [scBridge 的 Github 仓库](https://github.com/XLearning-SCU/scBridge)\n\n[https://github.com/GreenleafLab/MPAL-Single-Cell-2019](https://github.com/GreenleafLab/MPAL-Single-Cell-2019)\n\n# Motivation:\n\n> 概述:\n> scBridge 是一套面向单细胞多组学数据（scRNA-seq 与 scATAC-seq）整合的半监督异构迁移学习框架。它的核心策略是：先用标注的 scRNA-seq 数据“热身”（warm-up）一个深度编码器和分类器，然后根据每个 scATAC-seq 细胞与 RNA 原型的相似度和分类置信度，评估其在组学整合中的“可靠性”，再借助可靠的 ATAC 细胞对齐 RNA 原型；如此迭代，从“易”到“难”逐步缩小 RNA/ATAC 之间的调制差距。大量 benchmark 测试表明，scBridge 在嵌入质量、标签转移准确性和对注释稀缺、技术噪声的鲁棒性方面，均显著优于六种代表性方法（Harmony、Seurat、scJoint、Portal、GLUE、Conos）([Nature](https://www.nature.com/articles/s41467-023-41795-5))。\n\n![1747738599339BegjbomkVoa7Hpx1yEScx3mRn8f.png](https://tk-pichost-1325224430.cos.ap-chengdu.myqcloud.com/blog/1747738599339BegjbomkVoa7Hpx1yEScx3mRn8f.png)\n\n## 单细胞多组学整合的必要性\n\n- 单细胞 RNA 测序（scRNA-seq）可描绘基因表达全景，揭示细胞类型与状态的多样性；而单细胞 ATAC 测序（scATAC-seq）则刻画染色质可及性，用以探究基因调控机制([Frontiers](https://www.frontiersin.org/journals/genetics/articles/10.3389/fgene.2023.1199087/full?utm_source=chatgpt.com))。\n- 将两种组学 unpaired（非配对）数据整合，可从表达与调控层面构建更全面的细胞图谱，但它们在分布、稀疏性、噪声水平上差异巨大，给算法带来挑战([Nature](https://www.nature.com/articles/s41467-023-41795-5))。\n\n## 现有整合方法\n\n- **Harmony**：通过批次校正，将不同数据集投影到同一低维空间，突出细胞类型聚类而非实验条件([PMC](https://pmc.ncbi.nlm.nih.gov/articles/PMC6884693/?utm_source=chatgpt.com))。\n- **Seurat**：基于互为最近邻的锚点（MNN）和标签转移（Transfer Anchors）实现多模态共嵌入([Satija Lab](https://satijalab.org/seurat/articles/multimodal_vignette?utm_source=chatgpt.com))。\n- **scJoint**：半监督框架并行训练标注（scRNA）与未标注（scATAC）数据，完成标签转移和联合可视化([PMC](https://pmc.ncbi.nlm.nih.gov/articles/PMC9186323/?utm_source=chatgpt.com))。\n- **GLUE**：图模型理念，显式建模不同组学之间的调控网络，构建统一嵌入([Nature](https://www.nature.com/articles/s41587-022-01284-4?utm_source=chatgpt.com))。\n- **Conos**：通过全局图结构将多样本 scRNA 数据联通，突出细胞类型一致性传播([GitHub](https://github.com/kharchenkolab/conos?utm_source=chatgpt.com))。\n- **Portal**：基于对抗学习的半监督多组学整合管线（本文略）。\n\n这些方法多对所有细胞“一视同仁”地整合，未利用组学内部的“异质性”信息来引导模型从“易”到“难”分层对齐。\n\n![](static/BegjbomkVoa7Hpx1yEScx3mRn8f.png)\n\n# Method:\n\n## 异构迁移学习框架概览\n\nscBridge 将标注的 scRNA-seq 与未标注的 scATAC-seq 数据看作源域与目标域，通过迭代的迁移学习流程逐步对齐两种组学的嵌入表示(Nature)。\n\n1. **Warm-up（热身）**\n   使用带标签的 scRNA-seq 数据训练一个深度编码器 $f$ 和分类器 $g$，并计算出初始的 RNA 嵌入及原型（每种细胞类型的平均嵌入）([Nature](https://www.nature.com/articles/s41467-023-41795-5))。\n2. **可靠性建模**\n   对每个 scATAC-seq 细胞，计算其嵌入与 RNA 原型的欧氏距离（可辨识度）及分类器损失（置信度），并用高斯混合模型估计每个细胞的“可靠性”([Nature](https://www.nature.com/articles/s41467-023-41795-5))。\n3. **原型对齐**\n   根据可靠性加权平均选出同类型 ATAC 细胞，构建 ATAC 原型，并将其与对应的 RNA 原型对齐（例如最小化原型间距离）([Nature](https://www.nature.com/articles/s41467-023-41795-5))。\n4. **迭代融合**\n   将本轮最“可靠”的 ATAC 细胞加入标注集中，附带当前预测标签，重复上述热身 → 建模 → 对齐过程，直至所有细胞被整合完毕([Nature](https://www.nature.com/articles/s41467-023-41795-5))。\n\n# Result:\n\n## 黄金 benchmark 验证\n\n- 在三组“金标准”配对数据集（SNARE-seq 脑皮层、SHARE-seq 骨髓、10x Multiome 肾脏）上，虽然未使用配对信息，仅作验证，但 scBridge 在嵌入质量和标签转移上均领先六种基线方法([Nature](https://www.nature.com/articles/s41467-023-41795-5))。\n\n## 与主流方法对比\n\n- **标签转移准确率**：在 PBMC 数据集上，scBridge 平均比第二名 scJoint 提高约 5% 的准确率（p ≤ 1e−3）([Nature](https://www.nature.com/articles/s41467-023-41795-5))。\n- **鲁棒性测试**：在稀缺注释（25%、50%、75%）和不同 dropout 强度下，scBridge 均表现出更稳健的 F1 分数和轮廓系数([Nature](https://www.nature.com/articles/s41467-023-41795-5))。\n- **可扩展性**：由于仅需小批量优化，算法在细胞数量线性增长时占用常数内存，可轻松处理百万级别数据集([Nature](https://www.nature.com/articles/s41467-023-41795-5))。\n\n## 创新\n\n- **细胞异质性利用**：首次将组学内部的“易整合”细胞作为“桥梁”，显著提升跨模态对齐效果([Nature](https://www.nature.com/articles/s41467-023-41795-5))。\n- **从易到难的分层融合**：通过迭代引入可靠细胞，降低了一次性对齐带来的误差累积，可有效应对噪声与注释不足问题([Nature](https://www.nature.com/articles/s41467-023-41795-5))。\n- **通用性强**：框架输入只需保证行（细胞）一致，列（基因、蛋白等）需对齐，可推广到其他单细胞多组学场景([Nature](https://www.nature.com/articles/s41467-023-41795-5))。\n- **开源可复现**：论文随文附带代码与数据，方便社区复现与扩展([Semantic Scholar](https://www.semanticscholar.org/paper/scBridge-embraces-cell-heterogeneity-in-single-cell-Li-Zhang/a9d3933a9902c9e710823df4284a7bf7ab024177?utm_source=chatgpt.com))。\n\n## 未来展望\n\n- **更多模态融合**：可直接应用于蛋白质组、表观组等其他单细胞组学，构建更全面的细胞图谱。\n- **与自动注释工具结合**：可将任何组学注释数据纳入 heterogenous learning 流程，进一步提升新型细胞类型发现能力。\n- **下游分析拓展**：整合后嵌入可无缝接入细胞谱系追踪、调控网络推断等多种后续分析管线，为生物学研究提供新范式。\n\n# **Experiment:**\n\n## 我完成的任务与收获\n\n- 重装服务器的 conda 环境\n\n## 运行结果\n\n### umap_PBMC_CellType\n\n### umap_PBMC_Domain\n\n![](static/YzVibvyJhoS3Cexix0AcdNFDn6d.png)\n\n### umap_PBMC_Reliability\n\n![](static/KgrdbEYNSoTVI1xchbYccC0WnYb.png)![1747738616339KgrdbEYNSoTVI1xchbYccC0WnYb.png](https://tk-pichost-1325224430.cos.ap-chengdu.myqcloud.com/blog/1747738616339KgrdbEYNSoTVI1xchbYccC0WnYb.png)\n","slug":"2025-05-17-scBridge embraces cell heterogeneity in single-cell RNA-seq and ATAC-seq data integration","published":1,"updated":"2025-09-26T12:17:52.217Z","_id":"cmg0saj4d002bjm8n2twrh7tq","comments":1,"layout":"post","photos":[],"content":"<h1 id=\"2025-05-17-scBridge-embraces-cell-heterogeneity-in-single-cell-RNA-seq-and-ATAC-seq-data-integration\"><a href=\"#2025-05-17-scBridge-embraces-cell-heterogeneity-in-single-cell-RNA-seq-and-ATAC-seq-data-integration\" class=\"headerlink\" title=\"2025-05-17-scBridge embraces cell heterogeneity in single-cell RNA-seq and ATAC-seq data integration\"></a>2025-05-17-scBridge embraces cell heterogeneity in single-cell RNA-seq and ATAC-seq data integration</h1><blockquote>\n<h1 id=\"相关资料\"><a href=\"#相关资料\" class=\"headerlink\" title=\"相关资料\"></a>相关资料</h1><p><a href=\"https://www.nature.com/articles/s41467-023-41795-5\">https://www.nature.com/articles/s41467-023-41795-5</a></p>\n<p><a href=\"https://pubmed.ncbi.nlm.nih.gov/37770437/\">scBridge embraces cell heterogeneity in single-cell RNA-seq and ATAC-seq data integration - PubMed</a></p>\n<p><a href=\"https://github.com/XLearning-SCU/scBridge\">scBridge 的 Github 仓库</a></p>\n</blockquote>\n<p><a href=\"https://github.com/GreenleafLab/MPAL-Single-Cell-2019\">https://github.com/GreenleafLab/MPAL-Single-Cell-2019</a></p>\n<h1 id=\"Motivation\"><a href=\"#Motivation\" class=\"headerlink\" title=\"Motivation:\"></a>Motivation:</h1><blockquote>\n<p>概述:<br>scBridge 是一套面向单细胞多组学数据（scRNA-seq 与 scATAC-seq）整合的半监督异构迁移学习框架。它的核心策略是：先用标注的 scRNA-seq 数据“热身”（warm-up）一个深度编码器和分类器，然后根据每个 scATAC-seq 细胞与 RNA 原型的相似度和分类置信度，评估其在组学整合中的“可靠性”，再借助可靠的 ATAC 细胞对齐 RNA 原型；如此迭代，从“易”到“难”逐步缩小 RNA&#x2F;ATAC 之间的调制差距。大量 benchmark 测试表明，scBridge 在嵌入质量、标签转移准确性和对注释稀缺、技术噪声的鲁棒性方面，均显著优于六种代表性方法（Harmony、Seurat、scJoint、Portal、GLUE、Conos）(<a href=\"https://www.nature.com/articles/s41467-023-41795-5\">Nature</a>)。</p>\n</blockquote>\n<p><img src=\"https://tk-pichost-1325224430.cos.ap-chengdu.myqcloud.com/blog/1747738599339BegjbomkVoa7Hpx1yEScx3mRn8f.png\" alt=\"1747738599339BegjbomkVoa7Hpx1yEScx3mRn8f.png\"></p>\n<h2 id=\"单细胞多组学整合的必要性\"><a href=\"#单细胞多组学整合的必要性\" class=\"headerlink\" title=\"单细胞多组学整合的必要性\"></a>单细胞多组学整合的必要性</h2><ul>\n<li>单细胞 RNA 测序（scRNA-seq）可描绘基因表达全景，揭示细胞类型与状态的多样性；而单细胞 ATAC 测序（scATAC-seq）则刻画染色质可及性，用以探究基因调控机制(<a href=\"https://www.frontiersin.org/journals/genetics/articles/10.3389/fgene.2023.1199087/full?utm_source=chatgpt.com\">Frontiers</a>)。</li>\n<li>将两种组学 unpaired（非配对）数据整合，可从表达与调控层面构建更全面的细胞图谱，但它们在分布、稀疏性、噪声水平上差异巨大，给算法带来挑战(<a href=\"https://www.nature.com/articles/s41467-023-41795-5\">Nature</a>)。</li>\n</ul>\n<h2 id=\"现有整合方法\"><a href=\"#现有整合方法\" class=\"headerlink\" title=\"现有整合方法\"></a>现有整合方法</h2><ul>\n<li><strong>Harmony</strong>：通过批次校正，将不同数据集投影到同一低维空间，突出细胞类型聚类而非实验条件(<a href=\"https://pmc.ncbi.nlm.nih.gov/articles/PMC6884693/?utm_source=chatgpt.com\">PMC</a>)。</li>\n<li><strong>Seurat</strong>：基于互为最近邻的锚点（MNN）和标签转移（Transfer Anchors）实现多模态共嵌入(<a href=\"https://satijalab.org/seurat/articles/multimodal_vignette?utm_source=chatgpt.com\">Satija Lab</a>)。</li>\n<li><strong>scJoint</strong>：半监督框架并行训练标注（scRNA）与未标注（scATAC）数据，完成标签转移和联合可视化(<a href=\"https://pmc.ncbi.nlm.nih.gov/articles/PMC9186323/?utm_source=chatgpt.com\">PMC</a>)。</li>\n<li><strong>GLUE</strong>：图模型理念，显式建模不同组学之间的调控网络，构建统一嵌入(<a href=\"https://www.nature.com/articles/s41587-022-01284-4?utm_source=chatgpt.com\">Nature</a>)。</li>\n<li><strong>Conos</strong>：通过全局图结构将多样本 scRNA 数据联通，突出细胞类型一致性传播(<a href=\"https://github.com/kharchenkolab/conos?utm_source=chatgpt.com\">GitHub</a>)。</li>\n<li><strong>Portal</strong>：基于对抗学习的半监督多组学整合管线（本文略）。</li>\n</ul>\n<p>这些方法多对所有细胞“一视同仁”地整合，未利用组学内部的“异质性”信息来引导模型从“易”到“难”分层对齐。</p>\n<p><img src=\"/static/BegjbomkVoa7Hpx1yEScx3mRn8f.png\"></p>\n<h1 id=\"Method\"><a href=\"#Method\" class=\"headerlink\" title=\"Method:\"></a>Method:</h1><h2 id=\"异构迁移学习框架概览\"><a href=\"#异构迁移学习框架概览\" class=\"headerlink\" title=\"异构迁移学习框架概览\"></a>异构迁移学习框架概览</h2><p>scBridge 将标注的 scRNA-seq 与未标注的 scATAC-seq 数据看作源域与目标域，通过迭代的迁移学习流程逐步对齐两种组学的嵌入表示(Nature)。</p>\n<ol>\n<li><strong>Warm-up（热身）</strong><br>使用带标签的 scRNA-seq 数据训练一个深度编码器 $f$ 和分类器 $g$，并计算出初始的 RNA 嵌入及原型（每种细胞类型的平均嵌入）(<a href=\"https://www.nature.com/articles/s41467-023-41795-5\">Nature</a>)。</li>\n<li><strong>可靠性建模</strong><br>对每个 scATAC-seq 细胞，计算其嵌入与 RNA 原型的欧氏距离（可辨识度）及分类器损失（置信度），并用高斯混合模型估计每个细胞的“可靠性”(<a href=\"https://www.nature.com/articles/s41467-023-41795-5\">Nature</a>)。</li>\n<li><strong>原型对齐</strong><br>根据可靠性加权平均选出同类型 ATAC 细胞，构建 ATAC 原型，并将其与对应的 RNA 原型对齐（例如最小化原型间距离）(<a href=\"https://www.nature.com/articles/s41467-023-41795-5\">Nature</a>)。</li>\n<li><strong>迭代融合</strong><br>将本轮最“可靠”的 ATAC 细胞加入标注集中，附带当前预测标签，重复上述热身 → 建模 → 对齐过程，直至所有细胞被整合完毕(<a href=\"https://www.nature.com/articles/s41467-023-41795-5\">Nature</a>)。</li>\n</ol>\n<h1 id=\"Result\"><a href=\"#Result\" class=\"headerlink\" title=\"Result:\"></a>Result:</h1><h2 id=\"黄金-benchmark-验证\"><a href=\"#黄金-benchmark-验证\" class=\"headerlink\" title=\"黄金 benchmark 验证\"></a>黄金 benchmark 验证</h2><ul>\n<li>在三组“金标准”配对数据集（SNARE-seq 脑皮层、SHARE-seq 骨髓、10x Multiome 肾脏）上，虽然未使用配对信息，仅作验证，但 scBridge 在嵌入质量和标签转移上均领先六种基线方法(<a href=\"https://www.nature.com/articles/s41467-023-41795-5\">Nature</a>)。</li>\n</ul>\n<h2 id=\"与主流方法对比\"><a href=\"#与主流方法对比\" class=\"headerlink\" title=\"与主流方法对比\"></a>与主流方法对比</h2><ul>\n<li><strong>标签转移准确率</strong>：在 PBMC 数据集上，scBridge 平均比第二名 scJoint 提高约 5% 的准确率（p ≤ 1e−3）(<a href=\"https://www.nature.com/articles/s41467-023-41795-5\">Nature</a>)。</li>\n<li><strong>鲁棒性测试</strong>：在稀缺注释（25%、50%、75%）和不同 dropout 强度下，scBridge 均表现出更稳健的 F1 分数和轮廓系数(<a href=\"https://www.nature.com/articles/s41467-023-41795-5\">Nature</a>)。</li>\n<li><strong>可扩展性</strong>：由于仅需小批量优化，算法在细胞数量线性增长时占用常数内存，可轻松处理百万级别数据集(<a href=\"https://www.nature.com/articles/s41467-023-41795-5\">Nature</a>)。</li>\n</ul>\n<h2 id=\"创新\"><a href=\"#创新\" class=\"headerlink\" title=\"创新\"></a>创新</h2><ul>\n<li><strong>细胞异质性利用</strong>：首次将组学内部的“易整合”细胞作为“桥梁”，显著提升跨模态对齐效果(<a href=\"https://www.nature.com/articles/s41467-023-41795-5\">Nature</a>)。</li>\n<li><strong>从易到难的分层融合</strong>：通过迭代引入可靠细胞，降低了一次性对齐带来的误差累积，可有效应对噪声与注释不足问题(<a href=\"https://www.nature.com/articles/s41467-023-41795-5\">Nature</a>)。</li>\n<li><strong>通用性强</strong>：框架输入只需保证行（细胞）一致，列（基因、蛋白等）需对齐，可推广到其他单细胞多组学场景(<a href=\"https://www.nature.com/articles/s41467-023-41795-5\">Nature</a>)。</li>\n<li><strong>开源可复现</strong>：论文随文附带代码与数据，方便社区复现与扩展(<a href=\"https://www.semanticscholar.org/paper/scBridge-embraces-cell-heterogeneity-in-single-cell-Li-Zhang/a9d3933a9902c9e710823df4284a7bf7ab024177?utm_source=chatgpt.com\">Semantic Scholar</a>)。</li>\n</ul>\n<h2 id=\"未来展望\"><a href=\"#未来展望\" class=\"headerlink\" title=\"未来展望\"></a>未来展望</h2><ul>\n<li><strong>更多模态融合</strong>：可直接应用于蛋白质组、表观组等其他单细胞组学，构建更全面的细胞图谱。</li>\n<li><strong>与自动注释工具结合</strong>：可将任何组学注释数据纳入 heterogenous learning 流程，进一步提升新型细胞类型发现能力。</li>\n<li><strong>下游分析拓展</strong>：整合后嵌入可无缝接入细胞谱系追踪、调控网络推断等多种后续分析管线，为生物学研究提供新范式。</li>\n</ul>\n<h1 id=\"Experiment\"><a href=\"#Experiment\" class=\"headerlink\" title=\"Experiment:\"></a><strong>Experiment:</strong></h1><h2 id=\"我完成的任务与收获\"><a href=\"#我完成的任务与收获\" class=\"headerlink\" title=\"我完成的任务与收获\"></a>我完成的任务与收获</h2><ul>\n<li>重装服务器的 conda 环境</li>\n</ul>\n<h2 id=\"运行结果\"><a href=\"#运行结果\" class=\"headerlink\" title=\"运行结果\"></a>运行结果</h2><h3 id=\"umap-PBMC-CellType\"><a href=\"#umap-PBMC-CellType\" class=\"headerlink\" title=\"umap_PBMC_CellType\"></a>umap_PBMC_CellType</h3><h3 id=\"umap-PBMC-Domain\"><a href=\"#umap-PBMC-Domain\" class=\"headerlink\" title=\"umap_PBMC_Domain\"></a>umap_PBMC_Domain</h3><p><img src=\"/static/YzVibvyJhoS3Cexix0AcdNFDn6d.png\"></p>\n<h3 id=\"umap-PBMC-Reliability\"><a href=\"#umap-PBMC-Reliability\" class=\"headerlink\" title=\"umap_PBMC_Reliability\"></a>umap_PBMC_Reliability</h3><p><img src=\"/static/KgrdbEYNSoTVI1xchbYccC0WnYb.png\"><img src=\"https://tk-pichost-1325224430.cos.ap-chengdu.myqcloud.com/blog/1747738616339KgrdbEYNSoTVI1xchbYccC0WnYb.png\" alt=\"1747738616339KgrdbEYNSoTVI1xchbYccC0WnYb.png\"></p>\n","excerpt":"","more":"<h1 id=\"2025-05-17-scBridge-embraces-cell-heterogeneity-in-single-cell-RNA-seq-and-ATAC-seq-data-integration\"><a href=\"#2025-05-17-scBridge-embraces-cell-heterogeneity-in-single-cell-RNA-seq-and-ATAC-seq-data-integration\" class=\"headerlink\" title=\"2025-05-17-scBridge embraces cell heterogeneity in single-cell RNA-seq and ATAC-seq data integration\"></a>2025-05-17-scBridge embraces cell heterogeneity in single-cell RNA-seq and ATAC-seq data integration</h1><blockquote>\n<h1 id=\"相关资料\"><a href=\"#相关资料\" class=\"headerlink\" title=\"相关资料\"></a>相关资料</h1><p><a href=\"https://www.nature.com/articles/s41467-023-41795-5\">https://www.nature.com/articles/s41467-023-41795-5</a></p>\n<p><a href=\"https://pubmed.ncbi.nlm.nih.gov/37770437/\">scBridge embraces cell heterogeneity in single-cell RNA-seq and ATAC-seq data integration - PubMed</a></p>\n<p><a href=\"https://github.com/XLearning-SCU/scBridge\">scBridge 的 Github 仓库</a></p>\n</blockquote>\n<p><a href=\"https://github.com/GreenleafLab/MPAL-Single-Cell-2019\">https://github.com/GreenleafLab/MPAL-Single-Cell-2019</a></p>\n<h1 id=\"Motivation\"><a href=\"#Motivation\" class=\"headerlink\" title=\"Motivation:\"></a>Motivation:</h1><blockquote>\n<p>概述:<br>scBridge 是一套面向单细胞多组学数据（scRNA-seq 与 scATAC-seq）整合的半监督异构迁移学习框架。它的核心策略是：先用标注的 scRNA-seq 数据“热身”（warm-up）一个深度编码器和分类器，然后根据每个 scATAC-seq 细胞与 RNA 原型的相似度和分类置信度，评估其在组学整合中的“可靠性”，再借助可靠的 ATAC 细胞对齐 RNA 原型；如此迭代，从“易”到“难”逐步缩小 RNA&#x2F;ATAC 之间的调制差距。大量 benchmark 测试表明，scBridge 在嵌入质量、标签转移准确性和对注释稀缺、技术噪声的鲁棒性方面，均显著优于六种代表性方法（Harmony、Seurat、scJoint、Portal、GLUE、Conos）(<a href=\"https://www.nature.com/articles/s41467-023-41795-5\">Nature</a>)。</p>\n</blockquote>\n<p><img src=\"https://tk-pichost-1325224430.cos.ap-chengdu.myqcloud.com/blog/1747738599339BegjbomkVoa7Hpx1yEScx3mRn8f.png\" alt=\"1747738599339BegjbomkVoa7Hpx1yEScx3mRn8f.png\"></p>\n<h2 id=\"单细胞多组学整合的必要性\"><a href=\"#单细胞多组学整合的必要性\" class=\"headerlink\" title=\"单细胞多组学整合的必要性\"></a>单细胞多组学整合的必要性</h2><ul>\n<li>单细胞 RNA 测序（scRNA-seq）可描绘基因表达全景，揭示细胞类型与状态的多样性；而单细胞 ATAC 测序（scATAC-seq）则刻画染色质可及性，用以探究基因调控机制(<a href=\"https://www.frontiersin.org/journals/genetics/articles/10.3389/fgene.2023.1199087/full?utm_source=chatgpt.com\">Frontiers</a>)。</li>\n<li>将两种组学 unpaired（非配对）数据整合，可从表达与调控层面构建更全面的细胞图谱，但它们在分布、稀疏性、噪声水平上差异巨大，给算法带来挑战(<a href=\"https://www.nature.com/articles/s41467-023-41795-5\">Nature</a>)。</li>\n</ul>\n<h2 id=\"现有整合方法\"><a href=\"#现有整合方法\" class=\"headerlink\" title=\"现有整合方法\"></a>现有整合方法</h2><ul>\n<li><strong>Harmony</strong>：通过批次校正，将不同数据集投影到同一低维空间，突出细胞类型聚类而非实验条件(<a href=\"https://pmc.ncbi.nlm.nih.gov/articles/PMC6884693/?utm_source=chatgpt.com\">PMC</a>)。</li>\n<li><strong>Seurat</strong>：基于互为最近邻的锚点（MNN）和标签转移（Transfer Anchors）实现多模态共嵌入(<a href=\"https://satijalab.org/seurat/articles/multimodal_vignette?utm_source=chatgpt.com\">Satija Lab</a>)。</li>\n<li><strong>scJoint</strong>：半监督框架并行训练标注（scRNA）与未标注（scATAC）数据，完成标签转移和联合可视化(<a href=\"https://pmc.ncbi.nlm.nih.gov/articles/PMC9186323/?utm_source=chatgpt.com\">PMC</a>)。</li>\n<li><strong>GLUE</strong>：图模型理念，显式建模不同组学之间的调控网络，构建统一嵌入(<a href=\"https://www.nature.com/articles/s41587-022-01284-4?utm_source=chatgpt.com\">Nature</a>)。</li>\n<li><strong>Conos</strong>：通过全局图结构将多样本 scRNA 数据联通，突出细胞类型一致性传播(<a href=\"https://github.com/kharchenkolab/conos?utm_source=chatgpt.com\">GitHub</a>)。</li>\n<li><strong>Portal</strong>：基于对抗学习的半监督多组学整合管线（本文略）。</li>\n</ul>\n<p>这些方法多对所有细胞“一视同仁”地整合，未利用组学内部的“异质性”信息来引导模型从“易”到“难”分层对齐。</p>\n<p><img src=\"/static/BegjbomkVoa7Hpx1yEScx3mRn8f.png\"></p>\n<h1 id=\"Method\"><a href=\"#Method\" class=\"headerlink\" title=\"Method:\"></a>Method:</h1><h2 id=\"异构迁移学习框架概览\"><a href=\"#异构迁移学习框架概览\" class=\"headerlink\" title=\"异构迁移学习框架概览\"></a>异构迁移学习框架概览</h2><p>scBridge 将标注的 scRNA-seq 与未标注的 scATAC-seq 数据看作源域与目标域，通过迭代的迁移学习流程逐步对齐两种组学的嵌入表示(Nature)。</p>\n<ol>\n<li><strong>Warm-up（热身）</strong><br>使用带标签的 scRNA-seq 数据训练一个深度编码器 $f$ 和分类器 $g$，并计算出初始的 RNA 嵌入及原型（每种细胞类型的平均嵌入）(<a href=\"https://www.nature.com/articles/s41467-023-41795-5\">Nature</a>)。</li>\n<li><strong>可靠性建模</strong><br>对每个 scATAC-seq 细胞，计算其嵌入与 RNA 原型的欧氏距离（可辨识度）及分类器损失（置信度），并用高斯混合模型估计每个细胞的“可靠性”(<a href=\"https://www.nature.com/articles/s41467-023-41795-5\">Nature</a>)。</li>\n<li><strong>原型对齐</strong><br>根据可靠性加权平均选出同类型 ATAC 细胞，构建 ATAC 原型，并将其与对应的 RNA 原型对齐（例如最小化原型间距离）(<a href=\"https://www.nature.com/articles/s41467-023-41795-5\">Nature</a>)。</li>\n<li><strong>迭代融合</strong><br>将本轮最“可靠”的 ATAC 细胞加入标注集中，附带当前预测标签，重复上述热身 → 建模 → 对齐过程，直至所有细胞被整合完毕(<a href=\"https://www.nature.com/articles/s41467-023-41795-5\">Nature</a>)。</li>\n</ol>\n<h1 id=\"Result\"><a href=\"#Result\" class=\"headerlink\" title=\"Result:\"></a>Result:</h1><h2 id=\"黄金-benchmark-验证\"><a href=\"#黄金-benchmark-验证\" class=\"headerlink\" title=\"黄金 benchmark 验证\"></a>黄金 benchmark 验证</h2><ul>\n<li>在三组“金标准”配对数据集（SNARE-seq 脑皮层、SHARE-seq 骨髓、10x Multiome 肾脏）上，虽然未使用配对信息，仅作验证，但 scBridge 在嵌入质量和标签转移上均领先六种基线方法(<a href=\"https://www.nature.com/articles/s41467-023-41795-5\">Nature</a>)。</li>\n</ul>\n<h2 id=\"与主流方法对比\"><a href=\"#与主流方法对比\" class=\"headerlink\" title=\"与主流方法对比\"></a>与主流方法对比</h2><ul>\n<li><strong>标签转移准确率</strong>：在 PBMC 数据集上，scBridge 平均比第二名 scJoint 提高约 5% 的准确率（p ≤ 1e−3）(<a href=\"https://www.nature.com/articles/s41467-023-41795-5\">Nature</a>)。</li>\n<li><strong>鲁棒性测试</strong>：在稀缺注释（25%、50%、75%）和不同 dropout 强度下，scBridge 均表现出更稳健的 F1 分数和轮廓系数(<a href=\"https://www.nature.com/articles/s41467-023-41795-5\">Nature</a>)。</li>\n<li><strong>可扩展性</strong>：由于仅需小批量优化，算法在细胞数量线性增长时占用常数内存，可轻松处理百万级别数据集(<a href=\"https://www.nature.com/articles/s41467-023-41795-5\">Nature</a>)。</li>\n</ul>\n<h2 id=\"创新\"><a href=\"#创新\" class=\"headerlink\" title=\"创新\"></a>创新</h2><ul>\n<li><strong>细胞异质性利用</strong>：首次将组学内部的“易整合”细胞作为“桥梁”，显著提升跨模态对齐效果(<a href=\"https://www.nature.com/articles/s41467-023-41795-5\">Nature</a>)。</li>\n<li><strong>从易到难的分层融合</strong>：通过迭代引入可靠细胞，降低了一次性对齐带来的误差累积，可有效应对噪声与注释不足问题(<a href=\"https://www.nature.com/articles/s41467-023-41795-5\">Nature</a>)。</li>\n<li><strong>通用性强</strong>：框架输入只需保证行（细胞）一致，列（基因、蛋白等）需对齐，可推广到其他单细胞多组学场景(<a href=\"https://www.nature.com/articles/s41467-023-41795-5\">Nature</a>)。</li>\n<li><strong>开源可复现</strong>：论文随文附带代码与数据，方便社区复现与扩展(<a href=\"https://www.semanticscholar.org/paper/scBridge-embraces-cell-heterogeneity-in-single-cell-Li-Zhang/a9d3933a9902c9e710823df4284a7bf7ab024177?utm_source=chatgpt.com\">Semantic Scholar</a>)。</li>\n</ul>\n<h2 id=\"未来展望\"><a href=\"#未来展望\" class=\"headerlink\" title=\"未来展望\"></a>未来展望</h2><ul>\n<li><strong>更多模态融合</strong>：可直接应用于蛋白质组、表观组等其他单细胞组学，构建更全面的细胞图谱。</li>\n<li><strong>与自动注释工具结合</strong>：可将任何组学注释数据纳入 heterogenous learning 流程，进一步提升新型细胞类型发现能力。</li>\n<li><strong>下游分析拓展</strong>：整合后嵌入可无缝接入细胞谱系追踪、调控网络推断等多种后续分析管线，为生物学研究提供新范式。</li>\n</ul>\n<h1 id=\"Experiment\"><a href=\"#Experiment\" class=\"headerlink\" title=\"Experiment:\"></a><strong>Experiment:</strong></h1><h2 id=\"我完成的任务与收获\"><a href=\"#我完成的任务与收获\" class=\"headerlink\" title=\"我完成的任务与收获\"></a>我完成的任务与收获</h2><ul>\n<li>重装服务器的 conda 环境</li>\n</ul>\n<h2 id=\"运行结果\"><a href=\"#运行结果\" class=\"headerlink\" title=\"运行结果\"></a>运行结果</h2><h3 id=\"umap-PBMC-CellType\"><a href=\"#umap-PBMC-CellType\" class=\"headerlink\" title=\"umap_PBMC_CellType\"></a>umap_PBMC_CellType</h3><h3 id=\"umap-PBMC-Domain\"><a href=\"#umap-PBMC-Domain\" class=\"headerlink\" title=\"umap_PBMC_Domain\"></a>umap_PBMC_Domain</h3><p><img src=\"/static/YzVibvyJhoS3Cexix0AcdNFDn6d.png\"></p>\n<h3 id=\"umap-PBMC-Reliability\"><a href=\"#umap-PBMC-Reliability\" class=\"headerlink\" title=\"umap_PBMC_Reliability\"></a>umap_PBMC_Reliability</h3><p><img src=\"/static/KgrdbEYNSoTVI1xchbYccC0WnYb.png\"><img src=\"https://tk-pichost-1325224430.cos.ap-chengdu.myqcloud.com/blog/1747738616339KgrdbEYNSoTVI1xchbYccC0WnYb.png\" alt=\"1747738616339KgrdbEYNSoTVI1xchbYccC0WnYb.png\"></p>\n"},{"title":"2025-06-01-Hive 技术及应用介绍","date":"2025-05-31T16:00:00.000Z","_content":"# Hive 技术及应用介绍\n\n# 参考资料\n\n> - [Hive 技术原理](https://cshihong.github.io/2018/05/22/Hive%E6%8A%80%E6%9C%AF%E5%8E%9F%E7%90%86/)\n> - [Hive 架构及应用介绍](http://xiaqunfeng.cc/2018/10/18/Hive/)\n> - [Hive - 小海哥哥 de - 博客园](https://www.cnblogs.com/xiaohaigegede/p/17725025.html)\n> - [https://cwiki.apache.org/confluence/display/Hive/Home](https://cwiki.apache.org/confluence/display/Hive/Home)(官方文档)\n\nApache Hive 是基于 Hadoop 构建的数据仓库工具，它为海量结构化数据提供类 SQL 的查询能力，并将查询翻译为 MapReduce、Tez 或 Spark 作业执行。Hive 简化了大数据批量分析的使用门槛，让熟悉 SQL 的开发者能够在 Hadoop 生态上轻松进行 ETL、OLAP 和 BI 分析。\n\n![1749361719853NEWubQsOsob8hwxG164ce9SWnxe.png](https://gitee.com/tanke11223344/imagehost/raw/main/blog/1749361719853NEWubQsOsob8hwxG164ce9SWnxe.png)\n\nHive 的执行流程\n\n## Hive 的背景与定位\n\n- **背景**：随着大数据时代到来，Hadoop 分布式文件系统（HDFS）与 MapReduce 为存储与计算提供了高吞吐的能力，但原生 MapReduce 编程复杂、开发成本高。\n- **定位**：Hive 通过 HiveQL（类似 SQL 的查询语言）屏蔽 MapReduce/Tez/Spark 的底层细节，将查询语句编译为执行计划并自动运行，适合批量离线分析，主要面向 ETL、数据聚合与多维分析。\n\n### Hive 在 Hadoop 生态系统中的位置\n\n![1749361730854XD25bKuMWocEPtxmRBQc1JaOn6c.png](https://gitee.com/tanke11223344/imagehost/raw/main/blog/1749361730854XD25bKuMWocEPtxmRBQc1JaOn6c.png)\n\nHive 的运行深度依赖于 Hadoop 的核心生态，包括其分布式文件系统 HDFS、计算框架 MapReduce 以及资源调度器 YARN，因此可以将 Hive 理解为一种构建在 Hadoop 之上的 \"SQL on Hadoop\" 应用。其核心工作机制是将用户输入的类 SQL 查询语句转换为底层的 MapReduce 任务来执行，也正是因为多了这一步从 SQL 到 MapReduce 的转化开销，所以在同等条件下，Hive 查询的执行效率通常会低于直接编写原生 MapReduce 程序。\n\n## Hive 体系结构\n\n![1749361740853ZjDRb5l8hozhtExpjCrcgQXFnzd.png](https://gitee.com/tanke11223344/imagehost/raw/main/blog/1749361740853ZjDRb5l8hozhtExpjCrcgQXFnzd.png)\n![1749361749853Rykybe2KzostXMxQrA2cx8pgnWh.png](https://gitee.com/tanke11223344/imagehost/raw/main/blog/1749361749853Rykybe2KzostXMxQrA2cx8pgnWh.png)\n\nHive 的核心组件包括：\n\n1. **Hive 客户端（CLI、Beeline、JDBC/ODBC）**\n\n   - 支持交互式提交 HiveQL，或通过 JDBC/ODBC 接入 BI 工具（如 Tableau、Power BI）。\n2. **Driver**\n\n   - 接收并解析 HiveQL，生成抽象语法树（AST），再进行优化和编译，生成执行计划（Execution Plan）。\n3. **Compiler / Optimizer**\n\n   - 将 AST 转为逻辑计划，应用谓词下推、列裁剪等优化，再生成物理计划，拆分为一个或多个 MapReduce/Tez/Spark 任务。\n4. **Execution Engine**\n\n   - 将物理计划提交给底层执行框架（MapReduce、Tez 或 Spark），监控任务状态并返回结果。\n5. **Metastore**\n\n   - 存储表结构、分区信息、列类型、SerDe、统计信息等元数据，通常使用 MySQL、PostgreSQL 或 Derby。\n\n## 数据模型与存储格式\n\n![1749361758853Z6E0bN8eQofC9kxqkCmcz14ynBg.png](https://gitee.com/tanke11223344/imagehost/raw/main/blog/1749361758853Z6E0bN8eQofC9kxqkCmcz14ynBg.png)\n\n- **表与分区**\n  - Hive 将 HDFS 文件组织为表（Table）、分区（Partition）和桶（Bucket）。分区通常按日期、地域等字段维度存储，减少查询扫描量。\n\n> 数据库：创建表时如果不指定数据库，则默认为 default 数据库。\n> 表：物理概念，实际对应 HDFS 上的一个目录。\n> 分区：对应所在表所在目录下的一个子目录。\n> 桶：对应表或分区所在路径的一个文件\n\n- **文件格式**\n  - 支持文本（Text）、SequenceFile、ORC、Parquet、Avro 等列式与行式格式。列式格式（ORC、Parquet）通过压缩和列裁剪大幅提升查询性能。\n\n```sql\n-- 创建按日期分区的 ORC 表\nCREATE EXTERNAL TABLE logs (\n  user_id BIGINT,\n  action  STRING,\n  ts      TIMESTAMP\n)\nPARTITIONED BY (dt STRING)\nSTORED AS ORC\nLOCATION '/data/logs/';\n```\n\n- **SerDe（序列化/反序列化）**\n  - 通过自定义 SerDe，Hive 能解析任意复杂格式（JSON、CSV、XML 等）。\n\n## HiveQL 基本用法\n\n> - [www.slideshare.net](https://www.slideshare.net/slideshow/hive-quick-start-tutorial/3555281)\n\n### 数据操作\n\n#### 创建表\n\n```sql\nCREATE TABLE IF NOT EXISTS example.employee(\nId INT COMMENT 'employeeid',\nCompany STRING COMMENT 'your company',\nMoney FLOAT COMMENT 'work money',)\nROW FORMAT DELIMITED FIELDS TERMINATED BY ',' STORED AS TEXTFILE;\n```\n\n> 可以发现就是对应的 SQL 语句\n\n#### 查询\n\n```sql\nSELECT id, name FROM employee WHERE salary >= 10000;\nSELECT department, avg(salary) FROM employee GROUP BY department;\nSELECT id, salary, date FROM employee_a UNION ALL\nSELECT id, salary, date FROM employee_b;\n```\n\n```sql\n-- 加载数据到表（分区）\nALTER TABLE logs ADD PARTITION (dt='2025-06-01');\nLOAD DATA INPATH '/raw/logs/2025-06-01/*.log'\nINTO TABLE logs PARTITION (dt='2025-06-01');\n-- 简单查询\nSELECT user_id, COUNT(*) AS cnt\nFROM logs\nWHERE dt='2025-06-01'\nGROUP BY user_id\nORDER BY cnt DESC\nLIMIT 10;\n```\n\n### 窗口函数与高级特性\n\n```sql\n-- 统计每个用户每天的前 3 次操作\nSELECT dt, user_id, action, ts,\n  ROW_NUMBER() OVER (PARTITION BY dt, user_id ORDER BY ts) AS rn\nFROM logs\nWHERE dt >= '2025-06-01' AND dt <= '2025-06-07'\nAND rn <= 3;\n```\n\n### 与 Spark 集成\n\n在 Hive on Spark 模式下，HiveQL 会被提交到 Spark 引擎执行，兼享 Spark 的低延迟与丰富算子。\n\n```bash\n-- 启动 Hive 使用 Spark 执行引擎\nset hive.execution.engine=spark;\n```\n\n## 典型应用场景\n\n1. **ETL 批量处理**\n\n   - 定时从日志系统、关系库导入数据，清洗、聚合后写入 Hive 数据仓库，用于下游 BI 报表。\n2. **多维 OLAP 分析**\n\n   - 基于 Hive 的 HiveCube 或第三方 OLAP 引擎（如 Apache Kylin）实现大规模多维分析。\n3. **数据探索与报表**\n\n   - 数据分析师通过 Beeline 或 BI 工具（Tableau、Power BI）直接查询 Hive 表。\n4. **机器学习特征工程**\n\n   - 使用 HiveQL 快速统计用户行为特征，然后将结果导出到 HDFS，再由 Spark/MLlib 训练模型。\n\n## 性能优化要点\n\n- **合理分区**\n\n  - 按查询高频过滤字段分区（如按日期、地域），减少文件扫描。\n- **使用列式存储**\n\n  - ORC/Parquet 格式支持列裁剪、矢量化读取和压缩。\n- **开启成本模型优化**\n\n```sql\nSET hive.cbo.enable=true;\n```\n\n- **利用 Tez/Spark**\n\n  - 将执行引擎换为 Tez 或 Spark，降低 MapReduce 的启动开销与 I/O 序列化成本。\n- **小文件合并**\n\n  - 小文件过多会导致任务过多，建议合并或使用 HDFS 合并工具。\n\n## 示例：用户次日留存率统计\n\n```sql\n-- 1. 计算用户首次活跃日期\nCREATE TABLE user_first (\n  user_id BIGINT,\n  first_dt STRING\n)\nSTORED AS ORC\nAS\nSELECT user_id, MIN(dt) AS first_dt\nFROM logs\nGROUP BY user_id;\n-- 2. 次日留存：join 当天活跃用户与第一天活跃日期后一天\nSELECT f.first_dt AS reg_dt,\n       l.dt        AS act_dt,\n       COUNT(DISTINCT f.user_id)      AS reg_users,\n       COUNT(DISTINCT l.user_id)      AS retained_users,\n       ROUND(COUNT(DISTINCT l.user_id) / COUNT(DISTINCT f.user_id), 4) AS retention_rate\nFROM user_first f\nJOIN logs l\n  ON f.user_id = l.user_id\n AND l.dt = date_add(f.first_dt, 1)\nGROUP BY f.first_dt, l.dt\nORDER BY f.first_dt;\n```\n\n---\n\n# 优缺点\n\n![1749361767853GqNBbN8ARo70Ijxlv3dcyQ5rn0v.png](https://gitee.com/tanke11223344/imagehost/raw/main/blog/1749361767853GqNBbN8ARo70Ijxlv3dcyQ5rn0v.png)\n\n![1749361778853RwFcbEGI7o1p7cxmwTNcbjjdn7c.png](https://gitee.com/tanke11223344/imagehost/raw/main/blog/1749361778853RwFcbEGI7o1p7cxmwTNcbjjdn7c.png)\n\n# 总结\n\n- **Hive** 以 SQL 友好的方式在 Hadoop 集群上实现批量离线分析，适用于 ETL、OLAP、报表和特征工程。\n- 通过 Metastore 管理元数据，通过多种文件格式和执行引擎（MapReduce/Tez/Spark）兼顾兼容性与性能。\n- 合理分区、列式存储和成本模型优化可显著提升查询性能。\n- Hive 与 Spark、Flink、Presto 等工具生态配合，为大数据平台提供灵活多样的计算选择。\n","source":"_posts/2025-06-01-Hive 技术及应用介绍.md","raw":"---\ntitle:  2025-06-01-Hive 技术及应用介绍\ndate: 2025-06-01\ntags: \n    课程学习\n---\n# Hive 技术及应用介绍\n\n# 参考资料\n\n> - [Hive 技术原理](https://cshihong.github.io/2018/05/22/Hive%E6%8A%80%E6%9C%AF%E5%8E%9F%E7%90%86/)\n> - [Hive 架构及应用介绍](http://xiaqunfeng.cc/2018/10/18/Hive/)\n> - [Hive - 小海哥哥 de - 博客园](https://www.cnblogs.com/xiaohaigegede/p/17725025.html)\n> - [https://cwiki.apache.org/confluence/display/Hive/Home](https://cwiki.apache.org/confluence/display/Hive/Home)(官方文档)\n\nApache Hive 是基于 Hadoop 构建的数据仓库工具，它为海量结构化数据提供类 SQL 的查询能力，并将查询翻译为 MapReduce、Tez 或 Spark 作业执行。Hive 简化了大数据批量分析的使用门槛，让熟悉 SQL 的开发者能够在 Hadoop 生态上轻松进行 ETL、OLAP 和 BI 分析。\n\n![1749361719853NEWubQsOsob8hwxG164ce9SWnxe.png](https://gitee.com/tanke11223344/imagehost/raw/main/blog/1749361719853NEWubQsOsob8hwxG164ce9SWnxe.png)\n\nHive 的执行流程\n\n## Hive 的背景与定位\n\n- **背景**：随着大数据时代到来，Hadoop 分布式文件系统（HDFS）与 MapReduce 为存储与计算提供了高吞吐的能力，但原生 MapReduce 编程复杂、开发成本高。\n- **定位**：Hive 通过 HiveQL（类似 SQL 的查询语言）屏蔽 MapReduce/Tez/Spark 的底层细节，将查询语句编译为执行计划并自动运行，适合批量离线分析，主要面向 ETL、数据聚合与多维分析。\n\n### Hive 在 Hadoop 生态系统中的位置\n\n![1749361730854XD25bKuMWocEPtxmRBQc1JaOn6c.png](https://gitee.com/tanke11223344/imagehost/raw/main/blog/1749361730854XD25bKuMWocEPtxmRBQc1JaOn6c.png)\n\nHive 的运行深度依赖于 Hadoop 的核心生态，包括其分布式文件系统 HDFS、计算框架 MapReduce 以及资源调度器 YARN，因此可以将 Hive 理解为一种构建在 Hadoop 之上的 \"SQL on Hadoop\" 应用。其核心工作机制是将用户输入的类 SQL 查询语句转换为底层的 MapReduce 任务来执行，也正是因为多了这一步从 SQL 到 MapReduce 的转化开销，所以在同等条件下，Hive 查询的执行效率通常会低于直接编写原生 MapReduce 程序。\n\n## Hive 体系结构\n\n![1749361740853ZjDRb5l8hozhtExpjCrcgQXFnzd.png](https://gitee.com/tanke11223344/imagehost/raw/main/blog/1749361740853ZjDRb5l8hozhtExpjCrcgQXFnzd.png)\n![1749361749853Rykybe2KzostXMxQrA2cx8pgnWh.png](https://gitee.com/tanke11223344/imagehost/raw/main/blog/1749361749853Rykybe2KzostXMxQrA2cx8pgnWh.png)\n\nHive 的核心组件包括：\n\n1. **Hive 客户端（CLI、Beeline、JDBC/ODBC）**\n\n   - 支持交互式提交 HiveQL，或通过 JDBC/ODBC 接入 BI 工具（如 Tableau、Power BI）。\n2. **Driver**\n\n   - 接收并解析 HiveQL，生成抽象语法树（AST），再进行优化和编译，生成执行计划（Execution Plan）。\n3. **Compiler / Optimizer**\n\n   - 将 AST 转为逻辑计划，应用谓词下推、列裁剪等优化，再生成物理计划，拆分为一个或多个 MapReduce/Tez/Spark 任务。\n4. **Execution Engine**\n\n   - 将物理计划提交给底层执行框架（MapReduce、Tez 或 Spark），监控任务状态并返回结果。\n5. **Metastore**\n\n   - 存储表结构、分区信息、列类型、SerDe、统计信息等元数据，通常使用 MySQL、PostgreSQL 或 Derby。\n\n## 数据模型与存储格式\n\n![1749361758853Z6E0bN8eQofC9kxqkCmcz14ynBg.png](https://gitee.com/tanke11223344/imagehost/raw/main/blog/1749361758853Z6E0bN8eQofC9kxqkCmcz14ynBg.png)\n\n- **表与分区**\n  - Hive 将 HDFS 文件组织为表（Table）、分区（Partition）和桶（Bucket）。分区通常按日期、地域等字段维度存储，减少查询扫描量。\n\n> 数据库：创建表时如果不指定数据库，则默认为 default 数据库。\n> 表：物理概念，实际对应 HDFS 上的一个目录。\n> 分区：对应所在表所在目录下的一个子目录。\n> 桶：对应表或分区所在路径的一个文件\n\n- **文件格式**\n  - 支持文本（Text）、SequenceFile、ORC、Parquet、Avro 等列式与行式格式。列式格式（ORC、Parquet）通过压缩和列裁剪大幅提升查询性能。\n\n```sql\n-- 创建按日期分区的 ORC 表\nCREATE EXTERNAL TABLE logs (\n  user_id BIGINT,\n  action  STRING,\n  ts      TIMESTAMP\n)\nPARTITIONED BY (dt STRING)\nSTORED AS ORC\nLOCATION '/data/logs/';\n```\n\n- **SerDe（序列化/反序列化）**\n  - 通过自定义 SerDe，Hive 能解析任意复杂格式（JSON、CSV、XML 等）。\n\n## HiveQL 基本用法\n\n> - [www.slideshare.net](https://www.slideshare.net/slideshow/hive-quick-start-tutorial/3555281)\n\n### 数据操作\n\n#### 创建表\n\n```sql\nCREATE TABLE IF NOT EXISTS example.employee(\nId INT COMMENT 'employeeid',\nCompany STRING COMMENT 'your company',\nMoney FLOAT COMMENT 'work money',)\nROW FORMAT DELIMITED FIELDS TERMINATED BY ',' STORED AS TEXTFILE;\n```\n\n> 可以发现就是对应的 SQL 语句\n\n#### 查询\n\n```sql\nSELECT id, name FROM employee WHERE salary >= 10000;\nSELECT department, avg(salary) FROM employee GROUP BY department;\nSELECT id, salary, date FROM employee_a UNION ALL\nSELECT id, salary, date FROM employee_b;\n```\n\n```sql\n-- 加载数据到表（分区）\nALTER TABLE logs ADD PARTITION (dt='2025-06-01');\nLOAD DATA INPATH '/raw/logs/2025-06-01/*.log'\nINTO TABLE logs PARTITION (dt='2025-06-01');\n-- 简单查询\nSELECT user_id, COUNT(*) AS cnt\nFROM logs\nWHERE dt='2025-06-01'\nGROUP BY user_id\nORDER BY cnt DESC\nLIMIT 10;\n```\n\n### 窗口函数与高级特性\n\n```sql\n-- 统计每个用户每天的前 3 次操作\nSELECT dt, user_id, action, ts,\n  ROW_NUMBER() OVER (PARTITION BY dt, user_id ORDER BY ts) AS rn\nFROM logs\nWHERE dt >= '2025-06-01' AND dt <= '2025-06-07'\nAND rn <= 3;\n```\n\n### 与 Spark 集成\n\n在 Hive on Spark 模式下，HiveQL 会被提交到 Spark 引擎执行，兼享 Spark 的低延迟与丰富算子。\n\n```bash\n-- 启动 Hive 使用 Spark 执行引擎\nset hive.execution.engine=spark;\n```\n\n## 典型应用场景\n\n1. **ETL 批量处理**\n\n   - 定时从日志系统、关系库导入数据，清洗、聚合后写入 Hive 数据仓库，用于下游 BI 报表。\n2. **多维 OLAP 分析**\n\n   - 基于 Hive 的 HiveCube 或第三方 OLAP 引擎（如 Apache Kylin）实现大规模多维分析。\n3. **数据探索与报表**\n\n   - 数据分析师通过 Beeline 或 BI 工具（Tableau、Power BI）直接查询 Hive 表。\n4. **机器学习特征工程**\n\n   - 使用 HiveQL 快速统计用户行为特征，然后将结果导出到 HDFS，再由 Spark/MLlib 训练模型。\n\n## 性能优化要点\n\n- **合理分区**\n\n  - 按查询高频过滤字段分区（如按日期、地域），减少文件扫描。\n- **使用列式存储**\n\n  - ORC/Parquet 格式支持列裁剪、矢量化读取和压缩。\n- **开启成本模型优化**\n\n```sql\nSET hive.cbo.enable=true;\n```\n\n- **利用 Tez/Spark**\n\n  - 将执行引擎换为 Tez 或 Spark，降低 MapReduce 的启动开销与 I/O 序列化成本。\n- **小文件合并**\n\n  - 小文件过多会导致任务过多，建议合并或使用 HDFS 合并工具。\n\n## 示例：用户次日留存率统计\n\n```sql\n-- 1. 计算用户首次活跃日期\nCREATE TABLE user_first (\n  user_id BIGINT,\n  first_dt STRING\n)\nSTORED AS ORC\nAS\nSELECT user_id, MIN(dt) AS first_dt\nFROM logs\nGROUP BY user_id;\n-- 2. 次日留存：join 当天活跃用户与第一天活跃日期后一天\nSELECT f.first_dt AS reg_dt,\n       l.dt        AS act_dt,\n       COUNT(DISTINCT f.user_id)      AS reg_users,\n       COUNT(DISTINCT l.user_id)      AS retained_users,\n       ROUND(COUNT(DISTINCT l.user_id) / COUNT(DISTINCT f.user_id), 4) AS retention_rate\nFROM user_first f\nJOIN logs l\n  ON f.user_id = l.user_id\n AND l.dt = date_add(f.first_dt, 1)\nGROUP BY f.first_dt, l.dt\nORDER BY f.first_dt;\n```\n\n---\n\n# 优缺点\n\n![1749361767853GqNBbN8ARo70Ijxlv3dcyQ5rn0v.png](https://gitee.com/tanke11223344/imagehost/raw/main/blog/1749361767853GqNBbN8ARo70Ijxlv3dcyQ5rn0v.png)\n\n![1749361778853RwFcbEGI7o1p7cxmwTNcbjjdn7c.png](https://gitee.com/tanke11223344/imagehost/raw/main/blog/1749361778853RwFcbEGI7o1p7cxmwTNcbjjdn7c.png)\n\n# 总结\n\n- **Hive** 以 SQL 友好的方式在 Hadoop 集群上实现批量离线分析，适用于 ETL、OLAP、报表和特征工程。\n- 通过 Metastore 管理元数据，通过多种文件格式和执行引擎（MapReduce/Tez/Spark）兼顾兼容性与性能。\n- 合理分区、列式存储和成本模型优化可显著提升查询性能。\n- Hive 与 Spark、Flink、Presto 等工具生态配合，为大数据平台提供灵活多样的计算选择。\n","slug":"2025-06-01-Hive 技术及应用介绍","published":1,"updated":"2025-09-26T12:18:00.834Z","_id":"cmg0saj4d002ejm8nfuhi7w15","comments":1,"layout":"post","photos":[],"content":"<h1 id=\"Hive-技术及应用介绍\"><a href=\"#Hive-技术及应用介绍\" class=\"headerlink\" title=\"Hive 技术及应用介绍\"></a>Hive 技术及应用介绍</h1><h1 id=\"参考资料\"><a href=\"#参考资料\" class=\"headerlink\" title=\"参考资料\"></a>参考资料</h1><blockquote>\n<ul>\n<li><a href=\"https://cshihong.github.io/2018/05/22/Hive%E6%8A%80%E6%9C%AF%E5%8E%9F%E7%90%86/\">Hive 技术原理</a></li>\n<li><a href=\"http://xiaqunfeng.cc/2018/10/18/Hive/\">Hive 架构及应用介绍</a></li>\n<li><a href=\"https://www.cnblogs.com/xiaohaigegede/p/17725025.html\">Hive - 小海哥哥 de - 博客园</a></li>\n<li><a href=\"https://cwiki.apache.org/confluence/display/Hive/Home\">https://cwiki.apache.org/confluence/display/Hive/Home</a>(官方文档)</li>\n</ul>\n</blockquote>\n<p>Apache Hive 是基于 Hadoop 构建的数据仓库工具，它为海量结构化数据提供类 SQL 的查询能力，并将查询翻译为 MapReduce、Tez 或 Spark 作业执行。Hive 简化了大数据批量分析的使用门槛，让熟悉 SQL 的开发者能够在 Hadoop 生态上轻松进行 ETL、OLAP 和 BI 分析。</p>\n<p><img src=\"https://gitee.com/tanke11223344/imagehost/raw/main/blog/1749361719853NEWubQsOsob8hwxG164ce9SWnxe.png\" alt=\"1749361719853NEWubQsOsob8hwxG164ce9SWnxe.png\"></p>\n<p>Hive 的执行流程</p>\n<h2 id=\"Hive-的背景与定位\"><a href=\"#Hive-的背景与定位\" class=\"headerlink\" title=\"Hive 的背景与定位\"></a>Hive 的背景与定位</h2><ul>\n<li><strong>背景</strong>：随着大数据时代到来，Hadoop 分布式文件系统（HDFS）与 MapReduce 为存储与计算提供了高吞吐的能力，但原生 MapReduce 编程复杂、开发成本高。</li>\n<li><strong>定位</strong>：Hive 通过 HiveQL（类似 SQL 的查询语言）屏蔽 MapReduce&#x2F;Tez&#x2F;Spark 的底层细节，将查询语句编译为执行计划并自动运行，适合批量离线分析，主要面向 ETL、数据聚合与多维分析。</li>\n</ul>\n<h3 id=\"Hive-在-Hadoop-生态系统中的位置\"><a href=\"#Hive-在-Hadoop-生态系统中的位置\" class=\"headerlink\" title=\"Hive 在 Hadoop 生态系统中的位置\"></a>Hive 在 Hadoop 生态系统中的位置</h3><p><img src=\"https://gitee.com/tanke11223344/imagehost/raw/main/blog/1749361730854XD25bKuMWocEPtxmRBQc1JaOn6c.png\" alt=\"1749361730854XD25bKuMWocEPtxmRBQc1JaOn6c.png\"></p>\n<p>Hive 的运行深度依赖于 Hadoop 的核心生态，包括其分布式文件系统 HDFS、计算框架 MapReduce 以及资源调度器 YARN，因此可以将 Hive 理解为一种构建在 Hadoop 之上的 “SQL on Hadoop” 应用。其核心工作机制是将用户输入的类 SQL 查询语句转换为底层的 MapReduce 任务来执行，也正是因为多了这一步从 SQL 到 MapReduce 的转化开销，所以在同等条件下，Hive 查询的执行效率通常会低于直接编写原生 MapReduce 程序。</p>\n<h2 id=\"Hive-体系结构\"><a href=\"#Hive-体系结构\" class=\"headerlink\" title=\"Hive 体系结构\"></a>Hive 体系结构</h2><p><img src=\"https://gitee.com/tanke11223344/imagehost/raw/main/blog/1749361740853ZjDRb5l8hozhtExpjCrcgQXFnzd.png\" alt=\"1749361740853ZjDRb5l8hozhtExpjCrcgQXFnzd.png\"><br><img src=\"https://gitee.com/tanke11223344/imagehost/raw/main/blog/1749361749853Rykybe2KzostXMxQrA2cx8pgnWh.png\" alt=\"1749361749853Rykybe2KzostXMxQrA2cx8pgnWh.png\"></p>\n<p>Hive 的核心组件包括：</p>\n<ol>\n<li><p><strong>Hive 客户端（CLI、Beeline、JDBC&#x2F;ODBC）</strong></p>\n<ul>\n<li>支持交互式提交 HiveQL，或通过 JDBC&#x2F;ODBC 接入 BI 工具（如 Tableau、Power BI）。</li>\n</ul>\n</li>\n<li><p><strong>Driver</strong></p>\n<ul>\n<li>接收并解析 HiveQL，生成抽象语法树（AST），再进行优化和编译，生成执行计划（Execution Plan）。</li>\n</ul>\n</li>\n<li><p><strong>Compiler &#x2F; Optimizer</strong></p>\n<ul>\n<li>将 AST 转为逻辑计划，应用谓词下推、列裁剪等优化，再生成物理计划，拆分为一个或多个 MapReduce&#x2F;Tez&#x2F;Spark 任务。</li>\n</ul>\n</li>\n<li><p><strong>Execution Engine</strong></p>\n<ul>\n<li>将物理计划提交给底层执行框架（MapReduce、Tez 或 Spark），监控任务状态并返回结果。</li>\n</ul>\n</li>\n<li><p><strong>Metastore</strong></p>\n<ul>\n<li>存储表结构、分区信息、列类型、SerDe、统计信息等元数据，通常使用 MySQL、PostgreSQL 或 Derby。</li>\n</ul>\n</li>\n</ol>\n<h2 id=\"数据模型与存储格式\"><a href=\"#数据模型与存储格式\" class=\"headerlink\" title=\"数据模型与存储格式\"></a>数据模型与存储格式</h2><p><img src=\"https://gitee.com/tanke11223344/imagehost/raw/main/blog/1749361758853Z6E0bN8eQofC9kxqkCmcz14ynBg.png\" alt=\"1749361758853Z6E0bN8eQofC9kxqkCmcz14ynBg.png\"></p>\n<ul>\n<li><strong>表与分区</strong><ul>\n<li>Hive 将 HDFS 文件组织为表（Table）、分区（Partition）和桶（Bucket）。分区通常按日期、地域等字段维度存储，减少查询扫描量。</li>\n</ul>\n</li>\n</ul>\n<blockquote>\n<p>数据库：创建表时如果不指定数据库，则默认为 default 数据库。<br>表：物理概念，实际对应 HDFS 上的一个目录。<br>分区：对应所在表所在目录下的一个子目录。<br>桶：对应表或分区所在路径的一个文件</p>\n</blockquote>\n<ul>\n<li><strong>文件格式</strong><ul>\n<li>支持文本（Text）、SequenceFile、ORC、Parquet、Avro 等列式与行式格式。列式格式（ORC、Parquet）通过压缩和列裁剪大幅提升查询性能。</li>\n</ul>\n</li>\n</ul>\n<figure class=\"highlight sql\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">-- 创建按日期分区的 ORC 表</span></span><br><span class=\"line\"><span class=\"keyword\">CREATE</span> <span class=\"keyword\">EXTERNAL</span> <span class=\"keyword\">TABLE</span> logs (</span><br><span class=\"line\">  user_id <span class=\"type\">BIGINT</span>,</span><br><span class=\"line\">  action  STRING,</span><br><span class=\"line\">  ts      <span class=\"type\">TIMESTAMP</span></span><br><span class=\"line\">)</span><br><span class=\"line\">PARTITIONED <span class=\"keyword\">BY</span> (dt STRING)</span><br><span class=\"line\">STORED <span class=\"keyword\">AS</span> ORC</span><br><span class=\"line\">LOCATION <span class=\"string\">&#x27;/data/logs/&#x27;</span>;</span><br></pre></td></tr></table></figure>\n\n<ul>\n<li><strong>SerDe（序列化&#x2F;反序列化）</strong><ul>\n<li>通过自定义 SerDe，Hive 能解析任意复杂格式（JSON、CSV、XML 等）。</li>\n</ul>\n</li>\n</ul>\n<h2 id=\"HiveQL-基本用法\"><a href=\"#HiveQL-基本用法\" class=\"headerlink\" title=\"HiveQL 基本用法\"></a>HiveQL 基本用法</h2><blockquote>\n<ul>\n<li><a href=\"https://www.slideshare.net/slideshow/hive-quick-start-tutorial/3555281\">www.slideshare.net</a></li>\n</ul>\n</blockquote>\n<h3 id=\"数据操作\"><a href=\"#数据操作\" class=\"headerlink\" title=\"数据操作\"></a>数据操作</h3><h4 id=\"创建表\"><a href=\"#创建表\" class=\"headerlink\" title=\"创建表\"></a>创建表</h4><figure class=\"highlight sql\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">CREATE TABLE</span> IF <span class=\"keyword\">NOT</span> <span class=\"keyword\">EXISTS</span> example.employee(</span><br><span class=\"line\">Id <span class=\"type\">INT</span> COMMENT <span class=\"string\">&#x27;employeeid&#x27;</span>,</span><br><span class=\"line\">Company STRING COMMENT <span class=\"string\">&#x27;your company&#x27;</span>,</span><br><span class=\"line\">Money <span class=\"type\">FLOAT</span> COMMENT <span class=\"string\">&#x27;work money&#x27;</span>,)</span><br><span class=\"line\"><span class=\"type\">ROW</span> FORMAT DELIMITED FIELDS TERMINATED <span class=\"keyword\">BY</span> <span class=\"string\">&#x27;,&#x27;</span> STORED <span class=\"keyword\">AS</span> TEXTFILE;</span><br></pre></td></tr></table></figure>\n\n<blockquote>\n<p>可以发现就是对应的 SQL 语句</p>\n</blockquote>\n<h4 id=\"查询\"><a href=\"#查询\" class=\"headerlink\" title=\"查询\"></a>查询</h4><figure class=\"highlight sql\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">SELECT</span> id, name <span class=\"keyword\">FROM</span> employee <span class=\"keyword\">WHERE</span> salary <span class=\"operator\">&gt;=</span> <span class=\"number\">10000</span>;</span><br><span class=\"line\"><span class=\"keyword\">SELECT</span> department, <span class=\"built_in\">avg</span>(salary) <span class=\"keyword\">FROM</span> employee <span class=\"keyword\">GROUP</span> <span class=\"keyword\">BY</span> department;</span><br><span class=\"line\"><span class=\"keyword\">SELECT</span> id, salary, <span class=\"type\">date</span> <span class=\"keyword\">FROM</span> employee_a <span class=\"keyword\">UNION</span> <span class=\"keyword\">ALL</span></span><br><span class=\"line\"><span class=\"keyword\">SELECT</span> id, salary, <span class=\"type\">date</span> <span class=\"keyword\">FROM</span> employee_b;</span><br></pre></td></tr></table></figure>\n\n<figure class=\"highlight sql\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">-- 加载数据到表（分区）</span></span><br><span class=\"line\"><span class=\"keyword\">ALTER TABLE</span> logs <span class=\"keyword\">ADD</span> <span class=\"keyword\">PARTITION</span> (dt<span class=\"operator\">=</span><span class=\"string\">&#x27;2025-06-01&#x27;</span>);</span><br><span class=\"line\">LOAD DATA INPATH <span class=\"string\">&#x27;/raw/logs/2025-06-01/*.log&#x27;</span></span><br><span class=\"line\"><span class=\"keyword\">INTO</span> <span class=\"keyword\">TABLE</span> logs <span class=\"keyword\">PARTITION</span> (dt<span class=\"operator\">=</span><span class=\"string\">&#x27;2025-06-01&#x27;</span>);</span><br><span class=\"line\"><span class=\"comment\">-- 简单查询</span></span><br><span class=\"line\"><span class=\"keyword\">SELECT</span> user_id, <span class=\"built_in\">COUNT</span>(<span class=\"operator\">*</span>) <span class=\"keyword\">AS</span> cnt</span><br><span class=\"line\"><span class=\"keyword\">FROM</span> logs</span><br><span class=\"line\"><span class=\"keyword\">WHERE</span> dt<span class=\"operator\">=</span><span class=\"string\">&#x27;2025-06-01&#x27;</span></span><br><span class=\"line\"><span class=\"keyword\">GROUP</span> <span class=\"keyword\">BY</span> user_id</span><br><span class=\"line\"><span class=\"keyword\">ORDER</span> <span class=\"keyword\">BY</span> cnt <span class=\"keyword\">DESC</span></span><br><span class=\"line\">LIMIT <span class=\"number\">10</span>;</span><br></pre></td></tr></table></figure>\n\n<h3 id=\"窗口函数与高级特性\"><a href=\"#窗口函数与高级特性\" class=\"headerlink\" title=\"窗口函数与高级特性\"></a>窗口函数与高级特性</h3><figure class=\"highlight sql\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">-- 统计每个用户每天的前 3 次操作</span></span><br><span class=\"line\"><span class=\"keyword\">SELECT</span> dt, user_id, action, ts,</span><br><span class=\"line\">  <span class=\"built_in\">ROW_NUMBER</span>() <span class=\"keyword\">OVER</span> (<span class=\"keyword\">PARTITION</span> <span class=\"keyword\">BY</span> dt, user_id <span class=\"keyword\">ORDER</span> <span class=\"keyword\">BY</span> ts) <span class=\"keyword\">AS</span> rn</span><br><span class=\"line\"><span class=\"keyword\">FROM</span> logs</span><br><span class=\"line\"><span class=\"keyword\">WHERE</span> dt <span class=\"operator\">&gt;=</span> <span class=\"string\">&#x27;2025-06-01&#x27;</span> <span class=\"keyword\">AND</span> dt <span class=\"operator\">&lt;=</span> <span class=\"string\">&#x27;2025-06-07&#x27;</span></span><br><span class=\"line\"><span class=\"keyword\">AND</span> rn <span class=\"operator\">&lt;=</span> <span class=\"number\">3</span>;</span><br></pre></td></tr></table></figure>\n\n<h3 id=\"与-Spark-集成\"><a href=\"#与-Spark-集成\" class=\"headerlink\" title=\"与 Spark 集成\"></a>与 Spark 集成</h3><p>在 Hive on Spark 模式下，HiveQL 会被提交到 Spark 引擎执行，兼享 Spark 的低延迟与丰富算子。</p>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">-- 启动 Hive 使用 Spark 执行引擎</span><br><span class=\"line\"><span class=\"built_in\">set</span> hive.execution.engine=spark;</span><br></pre></td></tr></table></figure>\n\n<h2 id=\"典型应用场景\"><a href=\"#典型应用场景\" class=\"headerlink\" title=\"典型应用场景\"></a>典型应用场景</h2><ol>\n<li><p><strong>ETL 批量处理</strong></p>\n<ul>\n<li>定时从日志系统、关系库导入数据，清洗、聚合后写入 Hive 数据仓库，用于下游 BI 报表。</li>\n</ul>\n</li>\n<li><p><strong>多维 OLAP 分析</strong></p>\n<ul>\n<li>基于 Hive 的 HiveCube 或第三方 OLAP 引擎（如 Apache Kylin）实现大规模多维分析。</li>\n</ul>\n</li>\n<li><p><strong>数据探索与报表</strong></p>\n<ul>\n<li>数据分析师通过 Beeline 或 BI 工具（Tableau、Power BI）直接查询 Hive 表。</li>\n</ul>\n</li>\n<li><p><strong>机器学习特征工程</strong></p>\n<ul>\n<li>使用 HiveQL 快速统计用户行为特征，然后将结果导出到 HDFS，再由 Spark&#x2F;MLlib 训练模型。</li>\n</ul>\n</li>\n</ol>\n<h2 id=\"性能优化要点\"><a href=\"#性能优化要点\" class=\"headerlink\" title=\"性能优化要点\"></a>性能优化要点</h2><ul>\n<li><p><strong>合理分区</strong></p>\n<ul>\n<li>按查询高频过滤字段分区（如按日期、地域），减少文件扫描。</li>\n</ul>\n</li>\n<li><p><strong>使用列式存储</strong></p>\n<ul>\n<li>ORC&#x2F;Parquet 格式支持列裁剪、矢量化读取和压缩。</li>\n</ul>\n</li>\n<li><p><strong>开启成本模型优化</strong></p>\n</li>\n</ul>\n<figure class=\"highlight sql\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">SET</span> hive.cbo.enable<span class=\"operator\">=</span><span class=\"literal\">true</span>;</span><br></pre></td></tr></table></figure>\n\n<ul>\n<li><p><strong>利用 Tez&#x2F;Spark</strong></p>\n<ul>\n<li>将执行引擎换为 Tez 或 Spark，降低 MapReduce 的启动开销与 I&#x2F;O 序列化成本。</li>\n</ul>\n</li>\n<li><p><strong>小文件合并</strong></p>\n<ul>\n<li>小文件过多会导致任务过多，建议合并或使用 HDFS 合并工具。</li>\n</ul>\n</li>\n</ul>\n<h2 id=\"示例：用户次日留存率统计\"><a href=\"#示例：用户次日留存率统计\" class=\"headerlink\" title=\"示例：用户次日留存率统计\"></a>示例：用户次日留存率统计</h2><figure class=\"highlight sql\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">-- 1. 计算用户首次活跃日期</span></span><br><span class=\"line\"><span class=\"keyword\">CREATE TABLE</span> user_first (</span><br><span class=\"line\">  user_id <span class=\"type\">BIGINT</span>,</span><br><span class=\"line\">  first_dt STRING</span><br><span class=\"line\">)</span><br><span class=\"line\">STORED <span class=\"keyword\">AS</span> ORC</span><br><span class=\"line\"><span class=\"keyword\">AS</span></span><br><span class=\"line\"><span class=\"keyword\">SELECT</span> user_id, <span class=\"built_in\">MIN</span>(dt) <span class=\"keyword\">AS</span> first_dt</span><br><span class=\"line\"><span class=\"keyword\">FROM</span> logs</span><br><span class=\"line\"><span class=\"keyword\">GROUP</span> <span class=\"keyword\">BY</span> user_id;</span><br><span class=\"line\"><span class=\"comment\">-- 2. 次日留存：join 当天活跃用户与第一天活跃日期后一天</span></span><br><span class=\"line\"><span class=\"keyword\">SELECT</span> f.first_dt <span class=\"keyword\">AS</span> reg_dt,</span><br><span class=\"line\">       l.dt        <span class=\"keyword\">AS</span> act_dt,</span><br><span class=\"line\">       <span class=\"built_in\">COUNT</span>(<span class=\"keyword\">DISTINCT</span> f.user_id)      <span class=\"keyword\">AS</span> reg_users,</span><br><span class=\"line\">       <span class=\"built_in\">COUNT</span>(<span class=\"keyword\">DISTINCT</span> l.user_id)      <span class=\"keyword\">AS</span> retained_users,</span><br><span class=\"line\">       ROUND(<span class=\"built_in\">COUNT</span>(<span class=\"keyword\">DISTINCT</span> l.user_id) <span class=\"operator\">/</span> <span class=\"built_in\">COUNT</span>(<span class=\"keyword\">DISTINCT</span> f.user_id), <span class=\"number\">4</span>) <span class=\"keyword\">AS</span> retention_rate</span><br><span class=\"line\"><span class=\"keyword\">FROM</span> user_first f</span><br><span class=\"line\"><span class=\"keyword\">JOIN</span> logs l</span><br><span class=\"line\">  <span class=\"keyword\">ON</span> f.user_id <span class=\"operator\">=</span> l.user_id</span><br><span class=\"line\"> <span class=\"keyword\">AND</span> l.dt <span class=\"operator\">=</span> date_add(f.first_dt, <span class=\"number\">1</span>)</span><br><span class=\"line\"><span class=\"keyword\">GROUP</span> <span class=\"keyword\">BY</span> f.first_dt, l.dt</span><br><span class=\"line\"><span class=\"keyword\">ORDER</span> <span class=\"keyword\">BY</span> f.first_dt;</span><br></pre></td></tr></table></figure>\n\n<hr>\n<h1 id=\"优缺点\"><a href=\"#优缺点\" class=\"headerlink\" title=\"优缺点\"></a>优缺点</h1><p><img src=\"https://gitee.com/tanke11223344/imagehost/raw/main/blog/1749361767853GqNBbN8ARo70Ijxlv3dcyQ5rn0v.png\" alt=\"1749361767853GqNBbN8ARo70Ijxlv3dcyQ5rn0v.png\"></p>\n<p><img src=\"https://gitee.com/tanke11223344/imagehost/raw/main/blog/1749361778853RwFcbEGI7o1p7cxmwTNcbjjdn7c.png\" alt=\"1749361778853RwFcbEGI7o1p7cxmwTNcbjjdn7c.png\"></p>\n<h1 id=\"总结\"><a href=\"#总结\" class=\"headerlink\" title=\"总结\"></a>总结</h1><ul>\n<li><strong>Hive</strong> 以 SQL 友好的方式在 Hadoop 集群上实现批量离线分析，适用于 ETL、OLAP、报表和特征工程。</li>\n<li>通过 Metastore 管理元数据，通过多种文件格式和执行引擎（MapReduce&#x2F;Tez&#x2F;Spark）兼顾兼容性与性能。</li>\n<li>合理分区、列式存储和成本模型优化可显著提升查询性能。</li>\n<li>Hive 与 Spark、Flink、Presto 等工具生态配合，为大数据平台提供灵活多样的计算选择。</li>\n</ul>\n","excerpt":"","more":"<h1 id=\"Hive-技术及应用介绍\"><a href=\"#Hive-技术及应用介绍\" class=\"headerlink\" title=\"Hive 技术及应用介绍\"></a>Hive 技术及应用介绍</h1><h1 id=\"参考资料\"><a href=\"#参考资料\" class=\"headerlink\" title=\"参考资料\"></a>参考资料</h1><blockquote>\n<ul>\n<li><a href=\"https://cshihong.github.io/2018/05/22/Hive%E6%8A%80%E6%9C%AF%E5%8E%9F%E7%90%86/\">Hive 技术原理</a></li>\n<li><a href=\"http://xiaqunfeng.cc/2018/10/18/Hive/\">Hive 架构及应用介绍</a></li>\n<li><a href=\"https://www.cnblogs.com/xiaohaigegede/p/17725025.html\">Hive - 小海哥哥 de - 博客园</a></li>\n<li><a href=\"https://cwiki.apache.org/confluence/display/Hive/Home\">https://cwiki.apache.org/confluence/display/Hive/Home</a>(官方文档)</li>\n</ul>\n</blockquote>\n<p>Apache Hive 是基于 Hadoop 构建的数据仓库工具，它为海量结构化数据提供类 SQL 的查询能力，并将查询翻译为 MapReduce、Tez 或 Spark 作业执行。Hive 简化了大数据批量分析的使用门槛，让熟悉 SQL 的开发者能够在 Hadoop 生态上轻松进行 ETL、OLAP 和 BI 分析。</p>\n<p><img src=\"https://gitee.com/tanke11223344/imagehost/raw/main/blog/1749361719853NEWubQsOsob8hwxG164ce9SWnxe.png\" alt=\"1749361719853NEWubQsOsob8hwxG164ce9SWnxe.png\"></p>\n<p>Hive 的执行流程</p>\n<h2 id=\"Hive-的背景与定位\"><a href=\"#Hive-的背景与定位\" class=\"headerlink\" title=\"Hive 的背景与定位\"></a>Hive 的背景与定位</h2><ul>\n<li><strong>背景</strong>：随着大数据时代到来，Hadoop 分布式文件系统（HDFS）与 MapReduce 为存储与计算提供了高吞吐的能力，但原生 MapReduce 编程复杂、开发成本高。</li>\n<li><strong>定位</strong>：Hive 通过 HiveQL（类似 SQL 的查询语言）屏蔽 MapReduce&#x2F;Tez&#x2F;Spark 的底层细节，将查询语句编译为执行计划并自动运行，适合批量离线分析，主要面向 ETL、数据聚合与多维分析。</li>\n</ul>\n<h3 id=\"Hive-在-Hadoop-生态系统中的位置\"><a href=\"#Hive-在-Hadoop-生态系统中的位置\" class=\"headerlink\" title=\"Hive 在 Hadoop 生态系统中的位置\"></a>Hive 在 Hadoop 生态系统中的位置</h3><p><img src=\"https://gitee.com/tanke11223344/imagehost/raw/main/blog/1749361730854XD25bKuMWocEPtxmRBQc1JaOn6c.png\" alt=\"1749361730854XD25bKuMWocEPtxmRBQc1JaOn6c.png\"></p>\n<p>Hive 的运行深度依赖于 Hadoop 的核心生态，包括其分布式文件系统 HDFS、计算框架 MapReduce 以及资源调度器 YARN，因此可以将 Hive 理解为一种构建在 Hadoop 之上的 “SQL on Hadoop” 应用。其核心工作机制是将用户输入的类 SQL 查询语句转换为底层的 MapReduce 任务来执行，也正是因为多了这一步从 SQL 到 MapReduce 的转化开销，所以在同等条件下，Hive 查询的执行效率通常会低于直接编写原生 MapReduce 程序。</p>\n<h2 id=\"Hive-体系结构\"><a href=\"#Hive-体系结构\" class=\"headerlink\" title=\"Hive 体系结构\"></a>Hive 体系结构</h2><p><img src=\"https://gitee.com/tanke11223344/imagehost/raw/main/blog/1749361740853ZjDRb5l8hozhtExpjCrcgQXFnzd.png\" alt=\"1749361740853ZjDRb5l8hozhtExpjCrcgQXFnzd.png\"><br><img src=\"https://gitee.com/tanke11223344/imagehost/raw/main/blog/1749361749853Rykybe2KzostXMxQrA2cx8pgnWh.png\" alt=\"1749361749853Rykybe2KzostXMxQrA2cx8pgnWh.png\"></p>\n<p>Hive 的核心组件包括：</p>\n<ol>\n<li><p><strong>Hive 客户端（CLI、Beeline、JDBC&#x2F;ODBC）</strong></p>\n<ul>\n<li>支持交互式提交 HiveQL，或通过 JDBC&#x2F;ODBC 接入 BI 工具（如 Tableau、Power BI）。</li>\n</ul>\n</li>\n<li><p><strong>Driver</strong></p>\n<ul>\n<li>接收并解析 HiveQL，生成抽象语法树（AST），再进行优化和编译，生成执行计划（Execution Plan）。</li>\n</ul>\n</li>\n<li><p><strong>Compiler &#x2F; Optimizer</strong></p>\n<ul>\n<li>将 AST 转为逻辑计划，应用谓词下推、列裁剪等优化，再生成物理计划，拆分为一个或多个 MapReduce&#x2F;Tez&#x2F;Spark 任务。</li>\n</ul>\n</li>\n<li><p><strong>Execution Engine</strong></p>\n<ul>\n<li>将物理计划提交给底层执行框架（MapReduce、Tez 或 Spark），监控任务状态并返回结果。</li>\n</ul>\n</li>\n<li><p><strong>Metastore</strong></p>\n<ul>\n<li>存储表结构、分区信息、列类型、SerDe、统计信息等元数据，通常使用 MySQL、PostgreSQL 或 Derby。</li>\n</ul>\n</li>\n</ol>\n<h2 id=\"数据模型与存储格式\"><a href=\"#数据模型与存储格式\" class=\"headerlink\" title=\"数据模型与存储格式\"></a>数据模型与存储格式</h2><p><img src=\"https://gitee.com/tanke11223344/imagehost/raw/main/blog/1749361758853Z6E0bN8eQofC9kxqkCmcz14ynBg.png\" alt=\"1749361758853Z6E0bN8eQofC9kxqkCmcz14ynBg.png\"></p>\n<ul>\n<li><strong>表与分区</strong><ul>\n<li>Hive 将 HDFS 文件组织为表（Table）、分区（Partition）和桶（Bucket）。分区通常按日期、地域等字段维度存储，减少查询扫描量。</li>\n</ul>\n</li>\n</ul>\n<blockquote>\n<p>数据库：创建表时如果不指定数据库，则默认为 default 数据库。<br>表：物理概念，实际对应 HDFS 上的一个目录。<br>分区：对应所在表所在目录下的一个子目录。<br>桶：对应表或分区所在路径的一个文件</p>\n</blockquote>\n<ul>\n<li><strong>文件格式</strong><ul>\n<li>支持文本（Text）、SequenceFile、ORC、Parquet、Avro 等列式与行式格式。列式格式（ORC、Parquet）通过压缩和列裁剪大幅提升查询性能。</li>\n</ul>\n</li>\n</ul>\n<figure class=\"highlight sql\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">-- 创建按日期分区的 ORC 表</span></span><br><span class=\"line\"><span class=\"keyword\">CREATE</span> <span class=\"keyword\">EXTERNAL</span> <span class=\"keyword\">TABLE</span> logs (</span><br><span class=\"line\">  user_id <span class=\"type\">BIGINT</span>,</span><br><span class=\"line\">  action  STRING,</span><br><span class=\"line\">  ts      <span class=\"type\">TIMESTAMP</span></span><br><span class=\"line\">)</span><br><span class=\"line\">PARTITIONED <span class=\"keyword\">BY</span> (dt STRING)</span><br><span class=\"line\">STORED <span class=\"keyword\">AS</span> ORC</span><br><span class=\"line\">LOCATION <span class=\"string\">&#x27;/data/logs/&#x27;</span>;</span><br></pre></td></tr></table></figure>\n\n<ul>\n<li><strong>SerDe（序列化&#x2F;反序列化）</strong><ul>\n<li>通过自定义 SerDe，Hive 能解析任意复杂格式（JSON、CSV、XML 等）。</li>\n</ul>\n</li>\n</ul>\n<h2 id=\"HiveQL-基本用法\"><a href=\"#HiveQL-基本用法\" class=\"headerlink\" title=\"HiveQL 基本用法\"></a>HiveQL 基本用法</h2><blockquote>\n<ul>\n<li><a href=\"https://www.slideshare.net/slideshow/hive-quick-start-tutorial/3555281\">www.slideshare.net</a></li>\n</ul>\n</blockquote>\n<h3 id=\"数据操作\"><a href=\"#数据操作\" class=\"headerlink\" title=\"数据操作\"></a>数据操作</h3><h4 id=\"创建表\"><a href=\"#创建表\" class=\"headerlink\" title=\"创建表\"></a>创建表</h4><figure class=\"highlight sql\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">CREATE TABLE</span> IF <span class=\"keyword\">NOT</span> <span class=\"keyword\">EXISTS</span> example.employee(</span><br><span class=\"line\">Id <span class=\"type\">INT</span> COMMENT <span class=\"string\">&#x27;employeeid&#x27;</span>,</span><br><span class=\"line\">Company STRING COMMENT <span class=\"string\">&#x27;your company&#x27;</span>,</span><br><span class=\"line\">Money <span class=\"type\">FLOAT</span> COMMENT <span class=\"string\">&#x27;work money&#x27;</span>,)</span><br><span class=\"line\"><span class=\"type\">ROW</span> FORMAT DELIMITED FIELDS TERMINATED <span class=\"keyword\">BY</span> <span class=\"string\">&#x27;,&#x27;</span> STORED <span class=\"keyword\">AS</span> TEXTFILE;</span><br></pre></td></tr></table></figure>\n\n<blockquote>\n<p>可以发现就是对应的 SQL 语句</p>\n</blockquote>\n<h4 id=\"查询\"><a href=\"#查询\" class=\"headerlink\" title=\"查询\"></a>查询</h4><figure class=\"highlight sql\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">SELECT</span> id, name <span class=\"keyword\">FROM</span> employee <span class=\"keyword\">WHERE</span> salary <span class=\"operator\">&gt;=</span> <span class=\"number\">10000</span>;</span><br><span class=\"line\"><span class=\"keyword\">SELECT</span> department, <span class=\"built_in\">avg</span>(salary) <span class=\"keyword\">FROM</span> employee <span class=\"keyword\">GROUP</span> <span class=\"keyword\">BY</span> department;</span><br><span class=\"line\"><span class=\"keyword\">SELECT</span> id, salary, <span class=\"type\">date</span> <span class=\"keyword\">FROM</span> employee_a <span class=\"keyword\">UNION</span> <span class=\"keyword\">ALL</span></span><br><span class=\"line\"><span class=\"keyword\">SELECT</span> id, salary, <span class=\"type\">date</span> <span class=\"keyword\">FROM</span> employee_b;</span><br></pre></td></tr></table></figure>\n\n<figure class=\"highlight sql\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">-- 加载数据到表（分区）</span></span><br><span class=\"line\"><span class=\"keyword\">ALTER TABLE</span> logs <span class=\"keyword\">ADD</span> <span class=\"keyword\">PARTITION</span> (dt<span class=\"operator\">=</span><span class=\"string\">&#x27;2025-06-01&#x27;</span>);</span><br><span class=\"line\">LOAD DATA INPATH <span class=\"string\">&#x27;/raw/logs/2025-06-01/*.log&#x27;</span></span><br><span class=\"line\"><span class=\"keyword\">INTO</span> <span class=\"keyword\">TABLE</span> logs <span class=\"keyword\">PARTITION</span> (dt<span class=\"operator\">=</span><span class=\"string\">&#x27;2025-06-01&#x27;</span>);</span><br><span class=\"line\"><span class=\"comment\">-- 简单查询</span></span><br><span class=\"line\"><span class=\"keyword\">SELECT</span> user_id, <span class=\"built_in\">COUNT</span>(<span class=\"operator\">*</span>) <span class=\"keyword\">AS</span> cnt</span><br><span class=\"line\"><span class=\"keyword\">FROM</span> logs</span><br><span class=\"line\"><span class=\"keyword\">WHERE</span> dt<span class=\"operator\">=</span><span class=\"string\">&#x27;2025-06-01&#x27;</span></span><br><span class=\"line\"><span class=\"keyword\">GROUP</span> <span class=\"keyword\">BY</span> user_id</span><br><span class=\"line\"><span class=\"keyword\">ORDER</span> <span class=\"keyword\">BY</span> cnt <span class=\"keyword\">DESC</span></span><br><span class=\"line\">LIMIT <span class=\"number\">10</span>;</span><br></pre></td></tr></table></figure>\n\n<h3 id=\"窗口函数与高级特性\"><a href=\"#窗口函数与高级特性\" class=\"headerlink\" title=\"窗口函数与高级特性\"></a>窗口函数与高级特性</h3><figure class=\"highlight sql\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">-- 统计每个用户每天的前 3 次操作</span></span><br><span class=\"line\"><span class=\"keyword\">SELECT</span> dt, user_id, action, ts,</span><br><span class=\"line\">  <span class=\"built_in\">ROW_NUMBER</span>() <span class=\"keyword\">OVER</span> (<span class=\"keyword\">PARTITION</span> <span class=\"keyword\">BY</span> dt, user_id <span class=\"keyword\">ORDER</span> <span class=\"keyword\">BY</span> ts) <span class=\"keyword\">AS</span> rn</span><br><span class=\"line\"><span class=\"keyword\">FROM</span> logs</span><br><span class=\"line\"><span class=\"keyword\">WHERE</span> dt <span class=\"operator\">&gt;=</span> <span class=\"string\">&#x27;2025-06-01&#x27;</span> <span class=\"keyword\">AND</span> dt <span class=\"operator\">&lt;=</span> <span class=\"string\">&#x27;2025-06-07&#x27;</span></span><br><span class=\"line\"><span class=\"keyword\">AND</span> rn <span class=\"operator\">&lt;=</span> <span class=\"number\">3</span>;</span><br></pre></td></tr></table></figure>\n\n<h3 id=\"与-Spark-集成\"><a href=\"#与-Spark-集成\" class=\"headerlink\" title=\"与 Spark 集成\"></a>与 Spark 集成</h3><p>在 Hive on Spark 模式下，HiveQL 会被提交到 Spark 引擎执行，兼享 Spark 的低延迟与丰富算子。</p>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">-- 启动 Hive 使用 Spark 执行引擎</span><br><span class=\"line\"><span class=\"built_in\">set</span> hive.execution.engine=spark;</span><br></pre></td></tr></table></figure>\n\n<h2 id=\"典型应用场景\"><a href=\"#典型应用场景\" class=\"headerlink\" title=\"典型应用场景\"></a>典型应用场景</h2><ol>\n<li><p><strong>ETL 批量处理</strong></p>\n<ul>\n<li>定时从日志系统、关系库导入数据，清洗、聚合后写入 Hive 数据仓库，用于下游 BI 报表。</li>\n</ul>\n</li>\n<li><p><strong>多维 OLAP 分析</strong></p>\n<ul>\n<li>基于 Hive 的 HiveCube 或第三方 OLAP 引擎（如 Apache Kylin）实现大规模多维分析。</li>\n</ul>\n</li>\n<li><p><strong>数据探索与报表</strong></p>\n<ul>\n<li>数据分析师通过 Beeline 或 BI 工具（Tableau、Power BI）直接查询 Hive 表。</li>\n</ul>\n</li>\n<li><p><strong>机器学习特征工程</strong></p>\n<ul>\n<li>使用 HiveQL 快速统计用户行为特征，然后将结果导出到 HDFS，再由 Spark&#x2F;MLlib 训练模型。</li>\n</ul>\n</li>\n</ol>\n<h2 id=\"性能优化要点\"><a href=\"#性能优化要点\" class=\"headerlink\" title=\"性能优化要点\"></a>性能优化要点</h2><ul>\n<li><p><strong>合理分区</strong></p>\n<ul>\n<li>按查询高频过滤字段分区（如按日期、地域），减少文件扫描。</li>\n</ul>\n</li>\n<li><p><strong>使用列式存储</strong></p>\n<ul>\n<li>ORC&#x2F;Parquet 格式支持列裁剪、矢量化读取和压缩。</li>\n</ul>\n</li>\n<li><p><strong>开启成本模型优化</strong></p>\n</li>\n</ul>\n<figure class=\"highlight sql\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">SET</span> hive.cbo.enable<span class=\"operator\">=</span><span class=\"literal\">true</span>;</span><br></pre></td></tr></table></figure>\n\n<ul>\n<li><p><strong>利用 Tez&#x2F;Spark</strong></p>\n<ul>\n<li>将执行引擎换为 Tez 或 Spark，降低 MapReduce 的启动开销与 I&#x2F;O 序列化成本。</li>\n</ul>\n</li>\n<li><p><strong>小文件合并</strong></p>\n<ul>\n<li>小文件过多会导致任务过多，建议合并或使用 HDFS 合并工具。</li>\n</ul>\n</li>\n</ul>\n<h2 id=\"示例：用户次日留存率统计\"><a href=\"#示例：用户次日留存率统计\" class=\"headerlink\" title=\"示例：用户次日留存率统计\"></a>示例：用户次日留存率统计</h2><figure class=\"highlight sql\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">-- 1. 计算用户首次活跃日期</span></span><br><span class=\"line\"><span class=\"keyword\">CREATE TABLE</span> user_first (</span><br><span class=\"line\">  user_id <span class=\"type\">BIGINT</span>,</span><br><span class=\"line\">  first_dt STRING</span><br><span class=\"line\">)</span><br><span class=\"line\">STORED <span class=\"keyword\">AS</span> ORC</span><br><span class=\"line\"><span class=\"keyword\">AS</span></span><br><span class=\"line\"><span class=\"keyword\">SELECT</span> user_id, <span class=\"built_in\">MIN</span>(dt) <span class=\"keyword\">AS</span> first_dt</span><br><span class=\"line\"><span class=\"keyword\">FROM</span> logs</span><br><span class=\"line\"><span class=\"keyword\">GROUP</span> <span class=\"keyword\">BY</span> user_id;</span><br><span class=\"line\"><span class=\"comment\">-- 2. 次日留存：join 当天活跃用户与第一天活跃日期后一天</span></span><br><span class=\"line\"><span class=\"keyword\">SELECT</span> f.first_dt <span class=\"keyword\">AS</span> reg_dt,</span><br><span class=\"line\">       l.dt        <span class=\"keyword\">AS</span> act_dt,</span><br><span class=\"line\">       <span class=\"built_in\">COUNT</span>(<span class=\"keyword\">DISTINCT</span> f.user_id)      <span class=\"keyword\">AS</span> reg_users,</span><br><span class=\"line\">       <span class=\"built_in\">COUNT</span>(<span class=\"keyword\">DISTINCT</span> l.user_id)      <span class=\"keyword\">AS</span> retained_users,</span><br><span class=\"line\">       ROUND(<span class=\"built_in\">COUNT</span>(<span class=\"keyword\">DISTINCT</span> l.user_id) <span class=\"operator\">/</span> <span class=\"built_in\">COUNT</span>(<span class=\"keyword\">DISTINCT</span> f.user_id), <span class=\"number\">4</span>) <span class=\"keyword\">AS</span> retention_rate</span><br><span class=\"line\"><span class=\"keyword\">FROM</span> user_first f</span><br><span class=\"line\"><span class=\"keyword\">JOIN</span> logs l</span><br><span class=\"line\">  <span class=\"keyword\">ON</span> f.user_id <span class=\"operator\">=</span> l.user_id</span><br><span class=\"line\"> <span class=\"keyword\">AND</span> l.dt <span class=\"operator\">=</span> date_add(f.first_dt, <span class=\"number\">1</span>)</span><br><span class=\"line\"><span class=\"keyword\">GROUP</span> <span class=\"keyword\">BY</span> f.first_dt, l.dt</span><br><span class=\"line\"><span class=\"keyword\">ORDER</span> <span class=\"keyword\">BY</span> f.first_dt;</span><br></pre></td></tr></table></figure>\n\n<hr>\n<h1 id=\"优缺点\"><a href=\"#优缺点\" class=\"headerlink\" title=\"优缺点\"></a>优缺点</h1><p><img src=\"https://gitee.com/tanke11223344/imagehost/raw/main/blog/1749361767853GqNBbN8ARo70Ijxlv3dcyQ5rn0v.png\" alt=\"1749361767853GqNBbN8ARo70Ijxlv3dcyQ5rn0v.png\"></p>\n<p><img src=\"https://gitee.com/tanke11223344/imagehost/raw/main/blog/1749361778853RwFcbEGI7o1p7cxmwTNcbjjdn7c.png\" alt=\"1749361778853RwFcbEGI7o1p7cxmwTNcbjjdn7c.png\"></p>\n<h1 id=\"总结\"><a href=\"#总结\" class=\"headerlink\" title=\"总结\"></a>总结</h1><ul>\n<li><strong>Hive</strong> 以 SQL 友好的方式在 Hadoop 集群上实现批量离线分析，适用于 ETL、OLAP、报表和特征工程。</li>\n<li>通过 Metastore 管理元数据，通过多种文件格式和执行引擎（MapReduce&#x2F;Tez&#x2F;Spark）兼顾兼容性与性能。</li>\n<li>合理分区、列式存储和成本模型优化可显著提升查询性能。</li>\n<li>Hive 与 Spark、Flink、Presto 等工具生态配合，为大数据平台提供灵活多样的计算选择。</li>\n</ul>\n"},{"title":"2025-05-21-汇编语言键盘输入输出","date":"2025-05-20T16:00:00.000Z","_content":"# 2025-05-21-汇编语言键盘输入输出\n\n> # 参考博客\n\n# 任务 1\n\n> 把数据段中 1 维数组 AA_1 变量地址中连续 7 个数（1,3,5,7,2,4,6）读出，把每个数加 2 后再存入到数据段中 BB_1 数组开始的标号地址中去，并显示出 BB_1 数组中每个数来（之间用空格分开）\n\n```assembly\nDATA  SEGMENT\n    ORG 0100H\n  AA_1    DB     1,3,5,7,2,4,6\n    ORG 0150H\n  BB_1    DB     7 dup(?) \n  COUNT  DW     7 _;给7设置别名_\nDATA  ENDS\nCSEG  SEGMENT\n      ASSUME CS: CSEG,DS:DATA\nSTART:MOV    AX, DATA\n      MOV    DS, AX\n      MOV    CX, COUNT\n      LEA    SI, AA_1    _;取偏移地址(或者使用offset) _\n      LEA    DI, BB_1   \nLP1:  MOV    AL, [SI]   _;寄存器间接寻址方式可以改成相对寻址方式 _\n      ADD    AL,2   \n      MOV    [DI], AL   \n      INC SI    _;SI+1        _\n      INC DI    _;DI+1           _\n      LOOP  LP1 _;不是0就转到标号LP1_\n      LEA   SI, BB_1  \n      MOV CX, COUNT\nDISP:  MOV  DL, [SI]\nADD  DL, 30H    \nMOV    AH,02    _;显示输出(要背下来)_\nINT    21H   \n      MOV DL,' '   _;每显示输出一个数后，输出一个空格  _\n      MOV AH,2   \n      INT 21H  \n      INC   SI\n      LOOP  DISP   \nMOV    AH,4CH   \n      INT    21H\nCSEG  ENDS\n      END    START\n```\n\n# 任务 2\n\n> 从键盘接收一个小写字母，然后找出它的前导字符和后续字符，再按顺序显示这三个字符。\n\n```assembly\nCSEG SEGMENT\n    ASSUME CS:CSEG\n    ORG 100H\nSTART:\n      ; 从键盘接收一个小写字母\n      MOV AH,1\n      INT 21H\n\n      MOV DL,AL\n      DEC DL\n  \n      ; 设置循环次数\n      MOV CX,3       ; 设置循环次数\n  \nLOOP1:\n      ; 检查输入是否为小写字母\n      CMP DL,'a'\n      JB EXIT        ; 小于'a'就退出\n      CMP DL,'z'\n      JA EXIT        ; 大于'z'就退出\n  \n      MOV AH,2\n      INT 21H\n  \n      ADD DL,1\n\n      LOOP LOOP1     ; CX减1，若不为0则跳转到LOOP1继续循环\n  \nEXIT:\n      MOV AH,4CH\n      INT 21H\n  \nCSEG ENDS\n      END START\n```\n\n## (1) 指令 MOV AH, 02H 中 02H 的含义是？\n\n在 x86 汇编中，`MOV AH, 02H` 指令将立即数 02H 存入 AH 寄存器。在 DOS 中断服务程序中，这个值有特殊含义：**将 AH 设置为 02H 是为了调用 DOS 的 2 号功能 - 显示字符输出功能**。\n\n当执行 `INT 21H` 中断调用时，系统会根据 AH 中的值来确定要执行的 DOS 功能。02H 功能会将 DL 寄存器中的 ASCII 字符显示到标准输出设备（通常是屏幕）上。\n\n## (2) 指令 ADD DL, 30H 的作用是什么？\n\n指令 `ADD DL, 30H` 的作用是**将 DL 寄存器中的数值转换为对应的 ASCII 码字符**。\n\n具体来说：\n\n- 30H 是 ASCII 码中数字'0'的十六进制表示\n- 当 DL 中存储的是一个 0-9 的数值时，加上 30H 后会变成对应数字的 ASCII 码\n- 例如：DL=3，执行 ADD DL,30H 后，DL=33H，这是数字'3'的 ASCII 码\n\n在这个程序中，由于 BB_1 数组中存储的是加 2 后的数值（3,5,7,9,4,6,8），需要将这些数值转换为 ASCII 码才能正确显示，否则会显示为不可见的控制字符。\n\n> 注意：这种转换方法只适用于单个十进制数字（0-9）。对于大于 9 的数字，这种简单的加 30H 方法会产生错误的字符。\n\n## (3) 除了参考程序中用的访问方式，还可以用什么方式访问 AA_1 数组里的元素？\n\n参考程序中使用的是基于寄存器间接寻址方式（使用 SI 作为指针）来访问 AA_1 数组元素。除此之外，还可以使用以下方式：\n\n1. **直接寻址**：\n\n```assembly\nMOV AL, AA_1[0]    ; 访问第一个元素\nMOV AL, AA_1[1]    ; 访问第二个元素\n```\n\n1. **基址寻址**：\n\n```assembly\nMOV BX, OFFSET AA_1\nMOV AL, [BX]       ; 访问第一个元素\nMOV AL, [BX+1]     ; 访问第二个元素\n```\n\n1. **变址寻址**：\n\n```assembly\nMOV SI, 0\nMOV AL, AA_1[SI]   ; 访问第一个元素\nINC SI\nMOV AL, AA_1[SI]   ; 访问第二个元素\n```\n\n1. **基址加变址寻址**：\n\n```assembly\nMOV BX, OFFSET AA_1\nMOV SI, 0\nMOV AL, [BX+SI]    ; 访问第一个元素\nINC SI\nMOV AL, [BX+SI]    ; 访问第二个元素\n```\n\n1. **基址加变址加位移寻址**：\n\n```assembly\nMOV BX, OFFSET AA_1\nMOV SI, 1\nMOV AL, [BX+SI-1]  ; 访问第一个元素\nMOV AL, [BX+SI]    ; 访问第二个元素\n```\n\n# 任务 3\n\n> 已知 DATAX 和 DATAY 单元各存放一个带符号字节数据，从键盘上接收加（＋）、减（－）、乘（*）或除（/）符号，然后完成相应运算，把结果显示在屏幕上。\n\n## 求绝对值(基础模块)\n\n```assembly\nDATA SEGMENT\n    num DB -6         _; 8位有符号数_\n    buf DB 4 DUP(?)   _; 最多3位+1_\nDATA ENDS\n\nCODE SEGMENT\n    ASSUME CS:CODE, DS:DATA\nSTART:\n    MOV AX, DATA\n    MOV DS, AX\n\n    MOV AL, num       _; 取数_\n    CBW               _; 符号扩展到AX_\n\n    CMP AL, 0\n    JGE PRINT_DEC     _; 如果是正数，直接打印_\n    NEG AL            _; 取绝对值_\n    CBW\n\nPRINT_DEC:\n    _; AX中为正数，转十进制_\n    MOV SI, 0\n    MOV BX, 10\n\nCONV_LOOP:\n    XOR DX, DX\n    DIV BX            _; AX / 10, 商->AX, 余数->DX_\n    ADD DL, '0'\n    MOV buf[SI], DL\n    INC SI\n    CMP AX, 0\n    JNZ CONV_LOOP\n\nPRINT_LOOP:\n    DEC SI\n    MOV DL, buf[SI]\n    MOV AH, 2\n    INT 21H\n    CMP SI, 0\n    JNZ PRINT_LOOP\n\n    MOV AH, 4CH\n    INT 21H\nCODE ENDS\n    END START\n```\n\n## 完整代码\n\n```assembly\nDATA SEGMENT\n    DATAX DB 6      _; 带符号字节数据，负数_\n    DATAY DB -2      _; 带符号字节数据，正数_\n    RESULT DB 0\n    BUF DB 4 DUP(?)\nDATA ENDS\n\nCSEG SEGMENT\n    ASSUME CS:CSEG,DS:DATA\nSTART:\n      MOV AX,DATA\n      MOV DS,AX\n\n      _;从键盘接收+,-,*,/_\n      MOV AH,1\n      INT 21H\n\n      CMP AL,'+'\n      JE ADD_OP\n      CMP AL,'-'\n      JE SUB_OP\n      CMP AL,'*'\n      JE MUL_OP\n      CMP AL,'/'\n      JE DIV_OP\n\nADD_OP:\n      MOV AL,DATAX\n      MOV BL,DATAY\n      ADD AL,BL\n      MOV RESULT,AL\n      JMP SHOW_RESULT  \n  \nSUB_OP:\n      MOV AL,DATAX\n      MOV BL,DATAY\n      SUB AL,BL\n      MOV RESULT,AL\n      JMP SHOW_RESULT  \n\nMUL_OP:\n_; 字节乘法： _\n_; （AL）*（OPS8）→AX_\n      MOV AL,DATAX\n      MOV BL,DATAY\n      IMUL BL\n      MOV RESULT,AL\n      JMP SHOW_RESULT  \n\nDIV_OP:\n      MOV AL,DATAX\n      MOV BL,DATAY\n      CBW _;将AL符号扩展到AX_\n      IDIV BL\n      MOV RESULT,AL\n      JMP SHOW_RESULT  \n\n_;难点在打印,将每次除以10,把余数入栈,然后出栈,打印_\nSHOW_RESULT:\n    MOV AL, RESULT\n    CBW\n    CMP AL, 0\n    JGE SHOW\n    PUSH AX           _; 保存原始AL_\n    MOV DL, '-'\n    MOV AH, 2\n    INT 21H\n    POP AX            _; 恢复AL_\n    NEG AL\n    CBW\n\nSHOW:\n    MOV SI,0            _; SI为BUF索引_\n    MOV BX,10\n\nCONV_LOOP:\n    MOV DX,0\n    DIV BX\n    ADD DL,'0'\n    MOV BUF[SI],DL\n    INC SI\n    CMP AX,0\n    JNZ CONV_LOOP\n\nPRINT_LOOP:\n    DEC SI\n    MOV DL,BUF[SI]\n    MOV AH,2\n    INT 21H\n    CMP SI,0\n    JNZ PRINT_LOOP\n    JMP EXIT\n\nEXIT:\n      MOV AH,4CH\n      INT 21H\n  \nCSEG ENDS\n      END START\n```\n\n## 程序逻辑流程图\n\n![17478844701641747884469368.png](https://tk-pichost-1325224430.cos.ap-chengdu.myqcloud.com/blog/17478844701641747884469368.png)\n\n> ### 注意事项\n\n- 当 RESULT 为负数时,我在打印结果的时候我们需要先打印’-’号,INT 21H 会把 AL 的值重新设置\n- 使用 IDIV BX 命令前需要我们将 AX 使用 CBW 命令将 AL 扩展为 AX\n\n## 进一步的修改\n\n```assembly\n_; 简单计算器程序 - 对DATAX和DATAY中的有符号字节数据进行四则运算_\n_; 支持加(+)、减(-)、乘(*)、除(/)四种运算符_\n\n.MODEL SMALL\n.STACK 100H\n\n.DATA\nDATAX   DB  ?           _; 第一个操作数_\nDATAY   DB  ?           _; 第二个操作数_\nMSG1    DB  'Input first number: $'\nMSG2    DB  0DH, 0AH, 'Input second number: $'\nMSG3    DB  0DH, 0AH, 'Input operator (+, -, *, /): $'\nMSG4    DB  0DH, 0AH, 'Result: $'\nMSG5    DB  0DH, 0AH, 'Division by zero! $'\nTEMP    DW  ?           _; 临时存储乘法或除法结果_\nNEG_FLAG DB  0           _; 负数标志 (1表示结果为负)_\nBUF     DB  6 DUP(?)    _; 用于存储结果字符串_\nNEG_INPUT DB 0          _; 输入负号标志_\nVALUE     DB 0          _; 输入值_\n\n.CODE\nMAIN PROC\n    MOV AX, @DATA       _; 初始化数据段_\n    MOV DS, AX\n\n    _; 显示第一条提示消息_\n    LEA DX, MSG1\n    MOV AH, 09H\n    INT 21H\n\n    _; 输入第一个数字_\n    CALL INPUT_SIGNED_BYTE\n    MOV DATAX, AL\n\n    _; 显示第二条提示消息_\n    LEA DX, MSG2\n    MOV AH, 09H\n    INT 21H\n\n    _; 输入第二个数字_\n    CALL INPUT_SIGNED_BYTE\n    MOV DATAY, AL\n\n    _; 显示操作符提示消息_\n    LEA DX, MSG3\n    MOV AH, 09H\n    INT 21H\n\n    _; 输入操作符_\n    MOV AH, 01H\n    INT 21H\n    MOV BL, AL          _; 保存操作符在BL中_\n\n    _; 显示结果提示消息_\n    LEA DX, MSG4\n    MOV AH, 09H\n    INT 21H\n\n    _; 根据操作符执行相应运算_\n    CMP BL, '+'         _; 检查是否为加法_\n    JE  DO_ADD\n    CMP BL, '-'         _; 检查是否为减法_\n    JE  DO_SUB\n    CMP BL, '*'         _; 检查是否为乘法_\n    JE  DO_MUL\n    CMP BL, '/'         _; 检查是否为除法_\n    JE  DO_DIV\n    JMP EXIT            _; 如果不是有效操作符，直接退出_\n\nDO_ADD:\n    MOV AL, DATAX       _; 加法运算_\n    ADD AL, DATAY\n    JMP DISPLAY_RESULT\n\nDO_SUB:\n    MOV AL, DATAX       _; 减法运算_\n    SUB AL, DATAY\n    JMP DISPLAY_RESULT\n\nDO_MUL:\n    MOV AL, DATAX       _; 乘法运算_\n    MOV BL, DATAY\n    CALL SIGNED_MUL\n    JMP DISPLAY_AX\n\nDO_DIV:\n    MOV AL, DATAX       _; 除法运算_\n    MOV BL, DATAY\n    CALL SIGNED_DIV\n    JMP DISPLAY_AX\n\nDISPLAY_RESULT:\n    _; 结果在AL中，转换为字符串并显示_\n    MOV AH, 0           _; 清零AH，结果扩展到AX_\n    CMP AL, 0\n    JGE POSITIVE\n    NEG AL              _; 如果为负，取绝对值_\n    MOV NEG_FLAG, 1     _; 设置负数标志_\n    JMP CONTINUE\nPOSITIVE:\n    MOV NEG_FLAG, 0     _; 清除负数标志_\nCONTINUE:\n    MOV AX, AX          _; AX中现在是结果的绝对值_\n\nDISPLAY_AX:\n    _; 显示AX中的有符号结果_\n    CALL DISPLAY_SIGNED_NUM\n  \nEXIT:\n    _; 程序结束_\n    MOV AH, 4CH\n    INT 21H\nMAIN ENDP\n\n_; 输入有符号字节的过程_\nINPUT_SIGNED_BYTE PROC\n    _; 检查第一个字符是否为负号_\n    MOV AH, 01H\n    INT 21H\n    CMP AL, '-'\n    JNE CHECK_DIGIT1\n    MOV NEG_INPUT, 1    _; 设置负号标志_\n    MOV AH, 01H         _; 再次读取一个字符_\n    INT 21H\n  \nCHECK_DIGIT1:\n    _; 检查输入字符是否为数字_\n    CMP AL, '0'\n    JL EXIT_INPUT       _; 如果小于'0'，不是数字_\n    CMP AL, '9'\n    JG EXIT_INPUT       _; 如果大于'9'，不是数字_\n  \n    _; 转换为数值并保存_\n    SUB AL, '0'\n    MOV VALUE, AL\n  \n    _; 读取可能存在的第二个数字_\n    MOV AH, 01H\n    INT 21H\n  \n    _; 检查第二个字符是否为数字_\n    CMP AL, '0'\n    JL EXIT_INPUT2      _; 如果小于'0'，不是数字_\n    CMP AL, '9'\n    JG EXIT_INPUT2      _; 如果大于'9'，不是数字_\n  \n    _; 处理第二个数字_\n    SUB AL, '0'\n    MOV BL, VALUE       _; 将第一个数字移到BL_\n    MOV BH, 0           _; 清零BH_\n    MOV CX, 10\n    MUL CX              _; 将BX乘以10_\n    ADD BL, AL          _; 加上第二个数字_\n    MOV VALUE, BL\n    JMP EXIT_INPUT\n  \nEXIT_INPUT2:\n    _; 如果第二个字符不是数字，将它放回缓冲区(模拟未读取)_\n    MOV DL, AL\n    MOV AH, 02H\n    INT 21H\n  \nEXIT_INPUT:\n    _; 返回结果_\n    MOV AL, VALUE\n    CMP NEG_INPUT, 1\n    JNE RETURN_INPUT\n    NEG AL              _; 如果有负号标志，取负值_\n  \nRETURN_INPUT:\n    RET\nINPUT_SIGNED_BYTE ENDP\n\n_; 有符号乘法过程 - 结果在AX中_\nSIGNED_MUL PROC\n    _; 保存符号_\n    MOV CL, AL          _; 保存第一个操作数_\n    MOV CH, BL          _; 保存第二个操作数_\n  \n    _; 取绝对值_\n    CMP AL, 0\n    JGE ABS1_DONE\n    NEG AL\nABS1_DONE:\n    CMP BL, 0\n    JGE ABS2_DONE\n    NEG BL\nABS2_DONE:\n  \n    _; 执行无符号乘法_\n    MUL BL              _; AX = AL * BL_\n  \n    _; 确定结果符号_\n    MOV BH, 0           _; 清零BH_\n    MOV BL, 0           _; 假设结果为正_\n  \n    CMP CL, 0           _; 检查第一个操作数符号_\n    JGE CHECK_OP2_MUL\n    XOR BL, 1           _; 翻转符号位_\n  \nCHECK_OP2_MUL:\n    CMP CH, 0           _; 检查第二个操作数符号_\n    JGE APPLY_SIGN_MUL\n    XOR BL, 1           _; 翻转符号位_\n  \nAPPLY_SIGN_MUL:\n    CMP BL, 1           _; 检查是否需要取负_\n    JNE RETURN_MUL\n    NEG AX              _; 对结果取负_\n  \nRETURN_MUL:\n    RET\nSIGNED_MUL ENDP\n\n_; 有符号除法过程 - 结果在AX中_\nSIGNED_DIV PROC\n    _; 检查除数是否为零_\n    CMP BL, 0\n    JNE NOT_ZERO_DIV\n  \n    _; 除数为零处理_\n    LEA DX, MSG5        _; 显示除零错误消息_\n    MOV AH, 09H\n    INT 21H\n    MOV AX, 0           _; 返回0_\n    RET\n  \nNOT_ZERO_DIV:\n    _; 保存符号_\n    MOV CL, AL          _; 保存第一个操作数_\n    MOV CH, BL          _; 保存第二个操作数_\n  \n    _; 取绝对值_\n    CMP AL, 0\n    JGE ABS1_DIV_DONE\n    NEG AL\nABS1_DIV_DONE:\n    CMP BL, 0\n    JGE ABS2_DIV_DONE\n    NEG BL\nABS2_DIV_DONE:\n  \n    _; 执行无符号除法_\n    MOV AH, 0           _; 扩展AL到AX_\n    DIV BL              _; AL = AX / BL, AH = AX % BL_\n    MOV AH, 0           _; 清零AH(我们只关心商)_\n  \n    _; 确定结果符号_\n    MOV BH, 0           _; 清零BH_\n    MOV BL, 0           _; 假设结果为正_\n  \n    CMP CL, 0           _; 检查第一个操作数符号_\n    JGE CHECK_OP2_DIV\n    XOR BL, 1           _; 翻转符号位_\n  \nCHECK_OP2_DIV:\n    CMP CH, 0           _; 检查第二个操作数符号_\n    JGE APPLY_SIGN_DIV\n    XOR BL, 1           _; 翻转符号位_\n  \nAPPLY_SIGN_DIV:\n    CMP BL, 1           _; 检查是否需要取负_\n    JNE RETURN_DIV\n    NEG AX              _; 对结果取负_\n  \nRETURN_DIV:\n    RET\nSIGNED_DIV ENDP\n\n_; 显示有符号数字_\nDISPLAY_SIGNED_NUM PROC\n    _; 检查符号_\n    CMP AX, 0\n    JGE POS_NUM\n  \n    _; 显示负号_\n    MOV DL, '-'\n    MOV AH, 02H\n    INT 21H\n    NEG AX              _; 取绝对值_\n  \nPOS_NUM:\n    _; 将数字转换为字符串并显示_\n    MOV CX, 0           _; 初始化计数器_\n    MOV BX, 10          _; 基数(十进制)_\n  \n    _; 将数字转换为字符串(逆序)_\nCONVERT_LOOP:\n    MOV DX, 0           _; 清零DX_\n    DIV BX              _; AX / 10, 商在AX，余数在DX_\n    PUSH DX             _; 保存余数_\n    INC CX              _; 增加计数器_\n    CMP AX, 0           _; 检查商是否为0_\n    JNE CONVERT_LOOP    _; 如果不是0，继续转换_\n  \n    _; 显示字符串(正序)_\nDISPLAY_LOOP:\n    POP DX              _; 取出一个数字_\n    ADD DL, '0'         _; 转换为ASCII_\n    MOV AH, 02H         _; 显示字符功能_\n    INT 21H\n    LOOP DISPLAY_LOOP   _; 循环直到所有数字显示完毕_\n  \n    RET\nDISPLAY_SIGNED_NUM ENDP\n\nEND MAIN\n```\n","source":"_posts/2025-05-21-汇编语言键盘输入输出.md","raw":"---\ntitle: 2025-05-21-汇编语言键盘输入输出\ndate: 2025-05-21\ntags: \n    课程学习\n---\n# 2025-05-21-汇编语言键盘输入输出\n\n> # 参考博客\n\n# 任务 1\n\n> 把数据段中 1 维数组 AA_1 变量地址中连续 7 个数（1,3,5,7,2,4,6）读出，把每个数加 2 后再存入到数据段中 BB_1 数组开始的标号地址中去，并显示出 BB_1 数组中每个数来（之间用空格分开）\n\n```assembly\nDATA  SEGMENT\n    ORG 0100H\n  AA_1    DB     1,3,5,7,2,4,6\n    ORG 0150H\n  BB_1    DB     7 dup(?) \n  COUNT  DW     7 _;给7设置别名_\nDATA  ENDS\nCSEG  SEGMENT\n      ASSUME CS: CSEG,DS:DATA\nSTART:MOV    AX, DATA\n      MOV    DS, AX\n      MOV    CX, COUNT\n      LEA    SI, AA_1    _;取偏移地址(或者使用offset) _\n      LEA    DI, BB_1   \nLP1:  MOV    AL, [SI]   _;寄存器间接寻址方式可以改成相对寻址方式 _\n      ADD    AL,2   \n      MOV    [DI], AL   \n      INC SI    _;SI+1        _\n      INC DI    _;DI+1           _\n      LOOP  LP1 _;不是0就转到标号LP1_\n      LEA   SI, BB_1  \n      MOV CX, COUNT\nDISP:  MOV  DL, [SI]\nADD  DL, 30H    \nMOV    AH,02    _;显示输出(要背下来)_\nINT    21H   \n      MOV DL,' '   _;每显示输出一个数后，输出一个空格  _\n      MOV AH,2   \n      INT 21H  \n      INC   SI\n      LOOP  DISP   \nMOV    AH,4CH   \n      INT    21H\nCSEG  ENDS\n      END    START\n```\n\n# 任务 2\n\n> 从键盘接收一个小写字母，然后找出它的前导字符和后续字符，再按顺序显示这三个字符。\n\n```assembly\nCSEG SEGMENT\n    ASSUME CS:CSEG\n    ORG 100H\nSTART:\n      ; 从键盘接收一个小写字母\n      MOV AH,1\n      INT 21H\n\n      MOV DL,AL\n      DEC DL\n  \n      ; 设置循环次数\n      MOV CX,3       ; 设置循环次数\n  \nLOOP1:\n      ; 检查输入是否为小写字母\n      CMP DL,'a'\n      JB EXIT        ; 小于'a'就退出\n      CMP DL,'z'\n      JA EXIT        ; 大于'z'就退出\n  \n      MOV AH,2\n      INT 21H\n  \n      ADD DL,1\n\n      LOOP LOOP1     ; CX减1，若不为0则跳转到LOOP1继续循环\n  \nEXIT:\n      MOV AH,4CH\n      INT 21H\n  \nCSEG ENDS\n      END START\n```\n\n## (1) 指令 MOV AH, 02H 中 02H 的含义是？\n\n在 x86 汇编中，`MOV AH, 02H` 指令将立即数 02H 存入 AH 寄存器。在 DOS 中断服务程序中，这个值有特殊含义：**将 AH 设置为 02H 是为了调用 DOS 的 2 号功能 - 显示字符输出功能**。\n\n当执行 `INT 21H` 中断调用时，系统会根据 AH 中的值来确定要执行的 DOS 功能。02H 功能会将 DL 寄存器中的 ASCII 字符显示到标准输出设备（通常是屏幕）上。\n\n## (2) 指令 ADD DL, 30H 的作用是什么？\n\n指令 `ADD DL, 30H` 的作用是**将 DL 寄存器中的数值转换为对应的 ASCII 码字符**。\n\n具体来说：\n\n- 30H 是 ASCII 码中数字'0'的十六进制表示\n- 当 DL 中存储的是一个 0-9 的数值时，加上 30H 后会变成对应数字的 ASCII 码\n- 例如：DL=3，执行 ADD DL,30H 后，DL=33H，这是数字'3'的 ASCII 码\n\n在这个程序中，由于 BB_1 数组中存储的是加 2 后的数值（3,5,7,9,4,6,8），需要将这些数值转换为 ASCII 码才能正确显示，否则会显示为不可见的控制字符。\n\n> 注意：这种转换方法只适用于单个十进制数字（0-9）。对于大于 9 的数字，这种简单的加 30H 方法会产生错误的字符。\n\n## (3) 除了参考程序中用的访问方式，还可以用什么方式访问 AA_1 数组里的元素？\n\n参考程序中使用的是基于寄存器间接寻址方式（使用 SI 作为指针）来访问 AA_1 数组元素。除此之外，还可以使用以下方式：\n\n1. **直接寻址**：\n\n```assembly\nMOV AL, AA_1[0]    ; 访问第一个元素\nMOV AL, AA_1[1]    ; 访问第二个元素\n```\n\n1. **基址寻址**：\n\n```assembly\nMOV BX, OFFSET AA_1\nMOV AL, [BX]       ; 访问第一个元素\nMOV AL, [BX+1]     ; 访问第二个元素\n```\n\n1. **变址寻址**：\n\n```assembly\nMOV SI, 0\nMOV AL, AA_1[SI]   ; 访问第一个元素\nINC SI\nMOV AL, AA_1[SI]   ; 访问第二个元素\n```\n\n1. **基址加变址寻址**：\n\n```assembly\nMOV BX, OFFSET AA_1\nMOV SI, 0\nMOV AL, [BX+SI]    ; 访问第一个元素\nINC SI\nMOV AL, [BX+SI]    ; 访问第二个元素\n```\n\n1. **基址加变址加位移寻址**：\n\n```assembly\nMOV BX, OFFSET AA_1\nMOV SI, 1\nMOV AL, [BX+SI-1]  ; 访问第一个元素\nMOV AL, [BX+SI]    ; 访问第二个元素\n```\n\n# 任务 3\n\n> 已知 DATAX 和 DATAY 单元各存放一个带符号字节数据，从键盘上接收加（＋）、减（－）、乘（*）或除（/）符号，然后完成相应运算，把结果显示在屏幕上。\n\n## 求绝对值(基础模块)\n\n```assembly\nDATA SEGMENT\n    num DB -6         _; 8位有符号数_\n    buf DB 4 DUP(?)   _; 最多3位+1_\nDATA ENDS\n\nCODE SEGMENT\n    ASSUME CS:CODE, DS:DATA\nSTART:\n    MOV AX, DATA\n    MOV DS, AX\n\n    MOV AL, num       _; 取数_\n    CBW               _; 符号扩展到AX_\n\n    CMP AL, 0\n    JGE PRINT_DEC     _; 如果是正数，直接打印_\n    NEG AL            _; 取绝对值_\n    CBW\n\nPRINT_DEC:\n    _; AX中为正数，转十进制_\n    MOV SI, 0\n    MOV BX, 10\n\nCONV_LOOP:\n    XOR DX, DX\n    DIV BX            _; AX / 10, 商->AX, 余数->DX_\n    ADD DL, '0'\n    MOV buf[SI], DL\n    INC SI\n    CMP AX, 0\n    JNZ CONV_LOOP\n\nPRINT_LOOP:\n    DEC SI\n    MOV DL, buf[SI]\n    MOV AH, 2\n    INT 21H\n    CMP SI, 0\n    JNZ PRINT_LOOP\n\n    MOV AH, 4CH\n    INT 21H\nCODE ENDS\n    END START\n```\n\n## 完整代码\n\n```assembly\nDATA SEGMENT\n    DATAX DB 6      _; 带符号字节数据，负数_\n    DATAY DB -2      _; 带符号字节数据，正数_\n    RESULT DB 0\n    BUF DB 4 DUP(?)\nDATA ENDS\n\nCSEG SEGMENT\n    ASSUME CS:CSEG,DS:DATA\nSTART:\n      MOV AX,DATA\n      MOV DS,AX\n\n      _;从键盘接收+,-,*,/_\n      MOV AH,1\n      INT 21H\n\n      CMP AL,'+'\n      JE ADD_OP\n      CMP AL,'-'\n      JE SUB_OP\n      CMP AL,'*'\n      JE MUL_OP\n      CMP AL,'/'\n      JE DIV_OP\n\nADD_OP:\n      MOV AL,DATAX\n      MOV BL,DATAY\n      ADD AL,BL\n      MOV RESULT,AL\n      JMP SHOW_RESULT  \n  \nSUB_OP:\n      MOV AL,DATAX\n      MOV BL,DATAY\n      SUB AL,BL\n      MOV RESULT,AL\n      JMP SHOW_RESULT  \n\nMUL_OP:\n_; 字节乘法： _\n_; （AL）*（OPS8）→AX_\n      MOV AL,DATAX\n      MOV BL,DATAY\n      IMUL BL\n      MOV RESULT,AL\n      JMP SHOW_RESULT  \n\nDIV_OP:\n      MOV AL,DATAX\n      MOV BL,DATAY\n      CBW _;将AL符号扩展到AX_\n      IDIV BL\n      MOV RESULT,AL\n      JMP SHOW_RESULT  \n\n_;难点在打印,将每次除以10,把余数入栈,然后出栈,打印_\nSHOW_RESULT:\n    MOV AL, RESULT\n    CBW\n    CMP AL, 0\n    JGE SHOW\n    PUSH AX           _; 保存原始AL_\n    MOV DL, '-'\n    MOV AH, 2\n    INT 21H\n    POP AX            _; 恢复AL_\n    NEG AL\n    CBW\n\nSHOW:\n    MOV SI,0            _; SI为BUF索引_\n    MOV BX,10\n\nCONV_LOOP:\n    MOV DX,0\n    DIV BX\n    ADD DL,'0'\n    MOV BUF[SI],DL\n    INC SI\n    CMP AX,0\n    JNZ CONV_LOOP\n\nPRINT_LOOP:\n    DEC SI\n    MOV DL,BUF[SI]\n    MOV AH,2\n    INT 21H\n    CMP SI,0\n    JNZ PRINT_LOOP\n    JMP EXIT\n\nEXIT:\n      MOV AH,4CH\n      INT 21H\n  \nCSEG ENDS\n      END START\n```\n\n## 程序逻辑流程图\n\n![17478844701641747884469368.png](https://tk-pichost-1325224430.cos.ap-chengdu.myqcloud.com/blog/17478844701641747884469368.png)\n\n> ### 注意事项\n\n- 当 RESULT 为负数时,我在打印结果的时候我们需要先打印’-’号,INT 21H 会把 AL 的值重新设置\n- 使用 IDIV BX 命令前需要我们将 AX 使用 CBW 命令将 AL 扩展为 AX\n\n## 进一步的修改\n\n```assembly\n_; 简单计算器程序 - 对DATAX和DATAY中的有符号字节数据进行四则运算_\n_; 支持加(+)、减(-)、乘(*)、除(/)四种运算符_\n\n.MODEL SMALL\n.STACK 100H\n\n.DATA\nDATAX   DB  ?           _; 第一个操作数_\nDATAY   DB  ?           _; 第二个操作数_\nMSG1    DB  'Input first number: $'\nMSG2    DB  0DH, 0AH, 'Input second number: $'\nMSG3    DB  0DH, 0AH, 'Input operator (+, -, *, /): $'\nMSG4    DB  0DH, 0AH, 'Result: $'\nMSG5    DB  0DH, 0AH, 'Division by zero! $'\nTEMP    DW  ?           _; 临时存储乘法或除法结果_\nNEG_FLAG DB  0           _; 负数标志 (1表示结果为负)_\nBUF     DB  6 DUP(?)    _; 用于存储结果字符串_\nNEG_INPUT DB 0          _; 输入负号标志_\nVALUE     DB 0          _; 输入值_\n\n.CODE\nMAIN PROC\n    MOV AX, @DATA       _; 初始化数据段_\n    MOV DS, AX\n\n    _; 显示第一条提示消息_\n    LEA DX, MSG1\n    MOV AH, 09H\n    INT 21H\n\n    _; 输入第一个数字_\n    CALL INPUT_SIGNED_BYTE\n    MOV DATAX, AL\n\n    _; 显示第二条提示消息_\n    LEA DX, MSG2\n    MOV AH, 09H\n    INT 21H\n\n    _; 输入第二个数字_\n    CALL INPUT_SIGNED_BYTE\n    MOV DATAY, AL\n\n    _; 显示操作符提示消息_\n    LEA DX, MSG3\n    MOV AH, 09H\n    INT 21H\n\n    _; 输入操作符_\n    MOV AH, 01H\n    INT 21H\n    MOV BL, AL          _; 保存操作符在BL中_\n\n    _; 显示结果提示消息_\n    LEA DX, MSG4\n    MOV AH, 09H\n    INT 21H\n\n    _; 根据操作符执行相应运算_\n    CMP BL, '+'         _; 检查是否为加法_\n    JE  DO_ADD\n    CMP BL, '-'         _; 检查是否为减法_\n    JE  DO_SUB\n    CMP BL, '*'         _; 检查是否为乘法_\n    JE  DO_MUL\n    CMP BL, '/'         _; 检查是否为除法_\n    JE  DO_DIV\n    JMP EXIT            _; 如果不是有效操作符，直接退出_\n\nDO_ADD:\n    MOV AL, DATAX       _; 加法运算_\n    ADD AL, DATAY\n    JMP DISPLAY_RESULT\n\nDO_SUB:\n    MOV AL, DATAX       _; 减法运算_\n    SUB AL, DATAY\n    JMP DISPLAY_RESULT\n\nDO_MUL:\n    MOV AL, DATAX       _; 乘法运算_\n    MOV BL, DATAY\n    CALL SIGNED_MUL\n    JMP DISPLAY_AX\n\nDO_DIV:\n    MOV AL, DATAX       _; 除法运算_\n    MOV BL, DATAY\n    CALL SIGNED_DIV\n    JMP DISPLAY_AX\n\nDISPLAY_RESULT:\n    _; 结果在AL中，转换为字符串并显示_\n    MOV AH, 0           _; 清零AH，结果扩展到AX_\n    CMP AL, 0\n    JGE POSITIVE\n    NEG AL              _; 如果为负，取绝对值_\n    MOV NEG_FLAG, 1     _; 设置负数标志_\n    JMP CONTINUE\nPOSITIVE:\n    MOV NEG_FLAG, 0     _; 清除负数标志_\nCONTINUE:\n    MOV AX, AX          _; AX中现在是结果的绝对值_\n\nDISPLAY_AX:\n    _; 显示AX中的有符号结果_\n    CALL DISPLAY_SIGNED_NUM\n  \nEXIT:\n    _; 程序结束_\n    MOV AH, 4CH\n    INT 21H\nMAIN ENDP\n\n_; 输入有符号字节的过程_\nINPUT_SIGNED_BYTE PROC\n    _; 检查第一个字符是否为负号_\n    MOV AH, 01H\n    INT 21H\n    CMP AL, '-'\n    JNE CHECK_DIGIT1\n    MOV NEG_INPUT, 1    _; 设置负号标志_\n    MOV AH, 01H         _; 再次读取一个字符_\n    INT 21H\n  \nCHECK_DIGIT1:\n    _; 检查输入字符是否为数字_\n    CMP AL, '0'\n    JL EXIT_INPUT       _; 如果小于'0'，不是数字_\n    CMP AL, '9'\n    JG EXIT_INPUT       _; 如果大于'9'，不是数字_\n  \n    _; 转换为数值并保存_\n    SUB AL, '0'\n    MOV VALUE, AL\n  \n    _; 读取可能存在的第二个数字_\n    MOV AH, 01H\n    INT 21H\n  \n    _; 检查第二个字符是否为数字_\n    CMP AL, '0'\n    JL EXIT_INPUT2      _; 如果小于'0'，不是数字_\n    CMP AL, '9'\n    JG EXIT_INPUT2      _; 如果大于'9'，不是数字_\n  \n    _; 处理第二个数字_\n    SUB AL, '0'\n    MOV BL, VALUE       _; 将第一个数字移到BL_\n    MOV BH, 0           _; 清零BH_\n    MOV CX, 10\n    MUL CX              _; 将BX乘以10_\n    ADD BL, AL          _; 加上第二个数字_\n    MOV VALUE, BL\n    JMP EXIT_INPUT\n  \nEXIT_INPUT2:\n    _; 如果第二个字符不是数字，将它放回缓冲区(模拟未读取)_\n    MOV DL, AL\n    MOV AH, 02H\n    INT 21H\n  \nEXIT_INPUT:\n    _; 返回结果_\n    MOV AL, VALUE\n    CMP NEG_INPUT, 1\n    JNE RETURN_INPUT\n    NEG AL              _; 如果有负号标志，取负值_\n  \nRETURN_INPUT:\n    RET\nINPUT_SIGNED_BYTE ENDP\n\n_; 有符号乘法过程 - 结果在AX中_\nSIGNED_MUL PROC\n    _; 保存符号_\n    MOV CL, AL          _; 保存第一个操作数_\n    MOV CH, BL          _; 保存第二个操作数_\n  \n    _; 取绝对值_\n    CMP AL, 0\n    JGE ABS1_DONE\n    NEG AL\nABS1_DONE:\n    CMP BL, 0\n    JGE ABS2_DONE\n    NEG BL\nABS2_DONE:\n  \n    _; 执行无符号乘法_\n    MUL BL              _; AX = AL * BL_\n  \n    _; 确定结果符号_\n    MOV BH, 0           _; 清零BH_\n    MOV BL, 0           _; 假设结果为正_\n  \n    CMP CL, 0           _; 检查第一个操作数符号_\n    JGE CHECK_OP2_MUL\n    XOR BL, 1           _; 翻转符号位_\n  \nCHECK_OP2_MUL:\n    CMP CH, 0           _; 检查第二个操作数符号_\n    JGE APPLY_SIGN_MUL\n    XOR BL, 1           _; 翻转符号位_\n  \nAPPLY_SIGN_MUL:\n    CMP BL, 1           _; 检查是否需要取负_\n    JNE RETURN_MUL\n    NEG AX              _; 对结果取负_\n  \nRETURN_MUL:\n    RET\nSIGNED_MUL ENDP\n\n_; 有符号除法过程 - 结果在AX中_\nSIGNED_DIV PROC\n    _; 检查除数是否为零_\n    CMP BL, 0\n    JNE NOT_ZERO_DIV\n  \n    _; 除数为零处理_\n    LEA DX, MSG5        _; 显示除零错误消息_\n    MOV AH, 09H\n    INT 21H\n    MOV AX, 0           _; 返回0_\n    RET\n  \nNOT_ZERO_DIV:\n    _; 保存符号_\n    MOV CL, AL          _; 保存第一个操作数_\n    MOV CH, BL          _; 保存第二个操作数_\n  \n    _; 取绝对值_\n    CMP AL, 0\n    JGE ABS1_DIV_DONE\n    NEG AL\nABS1_DIV_DONE:\n    CMP BL, 0\n    JGE ABS2_DIV_DONE\n    NEG BL\nABS2_DIV_DONE:\n  \n    _; 执行无符号除法_\n    MOV AH, 0           _; 扩展AL到AX_\n    DIV BL              _; AL = AX / BL, AH = AX % BL_\n    MOV AH, 0           _; 清零AH(我们只关心商)_\n  \n    _; 确定结果符号_\n    MOV BH, 0           _; 清零BH_\n    MOV BL, 0           _; 假设结果为正_\n  \n    CMP CL, 0           _; 检查第一个操作数符号_\n    JGE CHECK_OP2_DIV\n    XOR BL, 1           _; 翻转符号位_\n  \nCHECK_OP2_DIV:\n    CMP CH, 0           _; 检查第二个操作数符号_\n    JGE APPLY_SIGN_DIV\n    XOR BL, 1           _; 翻转符号位_\n  \nAPPLY_SIGN_DIV:\n    CMP BL, 1           _; 检查是否需要取负_\n    JNE RETURN_DIV\n    NEG AX              _; 对结果取负_\n  \nRETURN_DIV:\n    RET\nSIGNED_DIV ENDP\n\n_; 显示有符号数字_\nDISPLAY_SIGNED_NUM PROC\n    _; 检查符号_\n    CMP AX, 0\n    JGE POS_NUM\n  \n    _; 显示负号_\n    MOV DL, '-'\n    MOV AH, 02H\n    INT 21H\n    NEG AX              _; 取绝对值_\n  \nPOS_NUM:\n    _; 将数字转换为字符串并显示_\n    MOV CX, 0           _; 初始化计数器_\n    MOV BX, 10          _; 基数(十进制)_\n  \n    _; 将数字转换为字符串(逆序)_\nCONVERT_LOOP:\n    MOV DX, 0           _; 清零DX_\n    DIV BX              _; AX / 10, 商在AX，余数在DX_\n    PUSH DX             _; 保存余数_\n    INC CX              _; 增加计数器_\n    CMP AX, 0           _; 检查商是否为0_\n    JNE CONVERT_LOOP    _; 如果不是0，继续转换_\n  \n    _; 显示字符串(正序)_\nDISPLAY_LOOP:\n    POP DX              _; 取出一个数字_\n    ADD DL, '0'         _; 转换为ASCII_\n    MOV AH, 02H         _; 显示字符功能_\n    INT 21H\n    LOOP DISPLAY_LOOP   _; 循环直到所有数字显示完毕_\n  \n    RET\nDISPLAY_SIGNED_NUM ENDP\n\nEND MAIN\n```\n","slug":"2025-05-21-汇编语言键盘输入输出","published":1,"updated":"2025-09-26T12:17:57.147Z","_id":"cmg0saj4e002gjm8n8zojhrtk","comments":1,"layout":"post","photos":[],"content":"<h1 id=\"2025-05-21-汇编语言键盘输入输出\"><a href=\"#2025-05-21-汇编语言键盘输入输出\" class=\"headerlink\" title=\"2025-05-21-汇编语言键盘输入输出\"></a>2025-05-21-汇编语言键盘输入输出</h1><blockquote>\n<h1 id=\"参考博客\"><a href=\"#参考博客\" class=\"headerlink\" title=\"参考博客\"></a>参考博客</h1></blockquote>\n<h1 id=\"任务-1\"><a href=\"#任务-1\" class=\"headerlink\" title=\"任务 1\"></a>任务 1</h1><blockquote>\n<p>把数据段中 1 维数组 AA_1 变量地址中连续 7 个数（1,3,5,7,2,4,6）读出，把每个数加 2 后再存入到数据段中 BB_1 数组开始的标号地址中去，并显示出 BB_1 数组中每个数来（之间用空格分开）</p>\n</blockquote>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">DATA  SEGMENT</span><br><span class=\"line\">    ORG 0100H</span><br><span class=\"line\">  AA_1    DB     1,3,5,7,2,4,6</span><br><span class=\"line\">    ORG 0150H</span><br><span class=\"line\">  BB_1    DB     7 dup(?) </span><br><span class=\"line\">  COUNT  DW     7 _;给7设置别名_</span><br><span class=\"line\">DATA  ENDS</span><br><span class=\"line\">CSEG  SEGMENT</span><br><span class=\"line\">      ASSUME CS: CSEG,DS:DATA</span><br><span class=\"line\">START:MOV    AX, DATA</span><br><span class=\"line\">      MOV    DS, AX</span><br><span class=\"line\">      MOV    CX, COUNT</span><br><span class=\"line\">      LEA    SI, AA_1    _;取偏移地址(或者使用offset) _</span><br><span class=\"line\">      LEA    DI, BB_1   </span><br><span class=\"line\">LP1:  MOV    AL, [SI]   _;寄存器间接寻址方式可以改成相对寻址方式 _</span><br><span class=\"line\">      ADD    AL,2   </span><br><span class=\"line\">      MOV    [DI], AL   </span><br><span class=\"line\">      INC SI    _;SI+1        _</span><br><span class=\"line\">      INC DI    _;DI+1           _</span><br><span class=\"line\">      LOOP  LP1 _;不是0就转到标号LP1_</span><br><span class=\"line\">      LEA   SI, BB_1  </span><br><span class=\"line\">      MOV CX, COUNT</span><br><span class=\"line\">DISP:  MOV  DL, [SI]</span><br><span class=\"line\">ADD  DL, 30H    </span><br><span class=\"line\">MOV    AH,02    _;显示输出(要背下来)_</span><br><span class=\"line\">INT    21H   </span><br><span class=\"line\">      MOV DL,&#x27; &#x27;   _;每显示输出一个数后，输出一个空格  _</span><br><span class=\"line\">      MOV AH,2   </span><br><span class=\"line\">      INT 21H  </span><br><span class=\"line\">      INC   SI</span><br><span class=\"line\">      LOOP  DISP   </span><br><span class=\"line\">MOV    AH,4CH   </span><br><span class=\"line\">      INT    21H</span><br><span class=\"line\">CSEG  ENDS</span><br><span class=\"line\">      END    START</span><br></pre></td></tr></table></figure>\n\n<h1 id=\"任务-2\"><a href=\"#任务-2\" class=\"headerlink\" title=\"任务 2\"></a>任务 2</h1><blockquote>\n<p>从键盘接收一个小写字母，然后找出它的前导字符和后续字符，再按顺序显示这三个字符。</p>\n</blockquote>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">CSEG SEGMENT</span><br><span class=\"line\">    ASSUME CS:CSEG</span><br><span class=\"line\">    ORG 100H</span><br><span class=\"line\">START:</span><br><span class=\"line\">      ; 从键盘接收一个小写字母</span><br><span class=\"line\">      MOV AH,1</span><br><span class=\"line\">      INT 21H</span><br><span class=\"line\"></span><br><span class=\"line\">      MOV DL,AL</span><br><span class=\"line\">      DEC DL</span><br><span class=\"line\">  </span><br><span class=\"line\">      ; 设置循环次数</span><br><span class=\"line\">      MOV CX,3       ; 设置循环次数</span><br><span class=\"line\">  </span><br><span class=\"line\">LOOP1:</span><br><span class=\"line\">      ; 检查输入是否为小写字母</span><br><span class=\"line\">      CMP DL,&#x27;a&#x27;</span><br><span class=\"line\">      JB EXIT        ; 小于&#x27;a&#x27;就退出</span><br><span class=\"line\">      CMP DL,&#x27;z&#x27;</span><br><span class=\"line\">      JA EXIT        ; 大于&#x27;z&#x27;就退出</span><br><span class=\"line\">  </span><br><span class=\"line\">      MOV AH,2</span><br><span class=\"line\">      INT 21H</span><br><span class=\"line\">  </span><br><span class=\"line\">      ADD DL,1</span><br><span class=\"line\"></span><br><span class=\"line\">      LOOP LOOP1     ; CX减1，若不为0则跳转到LOOP1继续循环</span><br><span class=\"line\">  </span><br><span class=\"line\">EXIT:</span><br><span class=\"line\">      MOV AH,4CH</span><br><span class=\"line\">      INT 21H</span><br><span class=\"line\">  </span><br><span class=\"line\">CSEG ENDS</span><br><span class=\"line\">      END START</span><br></pre></td></tr></table></figure>\n\n<h2 id=\"1-指令-MOV-AH-02H-中-02H-的含义是？\"><a href=\"#1-指令-MOV-AH-02H-中-02H-的含义是？\" class=\"headerlink\" title=\"(1) 指令 MOV AH, 02H 中 02H 的含义是？\"></a>(1) 指令 MOV AH, 02H 中 02H 的含义是？</h2><p>在 x86 汇编中，<code>MOV AH, 02H</code> 指令将立即数 02H 存入 AH 寄存器。在 DOS 中断服务程序中，这个值有特殊含义：<strong>将 AH 设置为 02H 是为了调用 DOS 的 2 号功能 - 显示字符输出功能</strong>。</p>\n<p>当执行 <code>INT 21H</code> 中断调用时，系统会根据 AH 中的值来确定要执行的 DOS 功能。02H 功能会将 DL 寄存器中的 ASCII 字符显示到标准输出设备（通常是屏幕）上。</p>\n<h2 id=\"2-指令-ADD-DL-30H-的作用是什么？\"><a href=\"#2-指令-ADD-DL-30H-的作用是什么？\" class=\"headerlink\" title=\"(2) 指令 ADD DL, 30H 的作用是什么？\"></a>(2) 指令 ADD DL, 30H 的作用是什么？</h2><p>指令 <code>ADD DL, 30H</code> 的作用是<strong>将 DL 寄存器中的数值转换为对应的 ASCII 码字符</strong>。</p>\n<p>具体来说：</p>\n<ul>\n<li>30H 是 ASCII 码中数字’0’的十六进制表示</li>\n<li>当 DL 中存储的是一个 0-9 的数值时，加上 30H 后会变成对应数字的 ASCII 码</li>\n<li>例如：DL&#x3D;3，执行 ADD DL,30H 后，DL&#x3D;33H，这是数字’3’的 ASCII 码</li>\n</ul>\n<p>在这个程序中，由于 BB_1 数组中存储的是加 2 后的数值（3,5,7,9,4,6,8），需要将这些数值转换为 ASCII 码才能正确显示，否则会显示为不可见的控制字符。</p>\n<blockquote>\n<p>注意：这种转换方法只适用于单个十进制数字（0-9）。对于大于 9 的数字，这种简单的加 30H 方法会产生错误的字符。</p>\n</blockquote>\n<h2 id=\"3-除了参考程序中用的访问方式，还可以用什么方式访问-AA-1-数组里的元素？\"><a href=\"#3-除了参考程序中用的访问方式，还可以用什么方式访问-AA-1-数组里的元素？\" class=\"headerlink\" title=\"(3) 除了参考程序中用的访问方式，还可以用什么方式访问 AA_1 数组里的元素？\"></a>(3) 除了参考程序中用的访问方式，还可以用什么方式访问 AA_1 数组里的元素？</h2><p>参考程序中使用的是基于寄存器间接寻址方式（使用 SI 作为指针）来访问 AA_1 数组元素。除此之外，还可以使用以下方式：</p>\n<ol>\n<li><strong>直接寻址</strong>：</li>\n</ol>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">MOV AL, AA_1[0]    ; 访问第一个元素</span><br><span class=\"line\">MOV AL, AA_1[1]    ; 访问第二个元素</span><br></pre></td></tr></table></figure>\n\n<ol>\n<li><strong>基址寻址</strong>：</li>\n</ol>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">MOV BX, OFFSET AA_1</span><br><span class=\"line\">MOV AL, [BX]       ; 访问第一个元素</span><br><span class=\"line\">MOV AL, [BX+1]     ; 访问第二个元素</span><br></pre></td></tr></table></figure>\n\n<ol>\n<li><strong>变址寻址</strong>：</li>\n</ol>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">MOV SI, 0</span><br><span class=\"line\">MOV AL, AA_1[SI]   ; 访问第一个元素</span><br><span class=\"line\">INC SI</span><br><span class=\"line\">MOV AL, AA_1[SI]   ; 访问第二个元素</span><br></pre></td></tr></table></figure>\n\n<ol>\n<li><strong>基址加变址寻址</strong>：</li>\n</ol>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">MOV BX, OFFSET AA_1</span><br><span class=\"line\">MOV SI, 0</span><br><span class=\"line\">MOV AL, [BX+SI]    ; 访问第一个元素</span><br><span class=\"line\">INC SI</span><br><span class=\"line\">MOV AL, [BX+SI]    ; 访问第二个元素</span><br></pre></td></tr></table></figure>\n\n<ol>\n<li><strong>基址加变址加位移寻址</strong>：</li>\n</ol>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">MOV BX, OFFSET AA_1</span><br><span class=\"line\">MOV SI, 1</span><br><span class=\"line\">MOV AL, [BX+SI-1]  ; 访问第一个元素</span><br><span class=\"line\">MOV AL, [BX+SI]    ; 访问第二个元素</span><br></pre></td></tr></table></figure>\n\n<h1 id=\"任务-3\"><a href=\"#任务-3\" class=\"headerlink\" title=\"任务 3\"></a>任务 3</h1><blockquote>\n<p>已知 DATAX 和 DATAY 单元各存放一个带符号字节数据，从键盘上接收加（＋）、减（－）、乘（*）或除（&#x2F;）符号，然后完成相应运算，把结果显示在屏幕上。</p>\n</blockquote>\n<h2 id=\"求绝对值-基础模块\"><a href=\"#求绝对值-基础模块\" class=\"headerlink\" title=\"求绝对值(基础模块)\"></a>求绝对值(基础模块)</h2><figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">DATA SEGMENT</span><br><span class=\"line\">    num DB -6         _; 8位有符号数_</span><br><span class=\"line\">    buf DB 4 DUP(?)   _; 最多3位+1_</span><br><span class=\"line\">DATA ENDS</span><br><span class=\"line\"></span><br><span class=\"line\">CODE SEGMENT</span><br><span class=\"line\">    ASSUME CS:CODE, DS:DATA</span><br><span class=\"line\">START:</span><br><span class=\"line\">    MOV AX, DATA</span><br><span class=\"line\">    MOV DS, AX</span><br><span class=\"line\"></span><br><span class=\"line\">    MOV AL, num       _; 取数_</span><br><span class=\"line\">    CBW               _; 符号扩展到AX_</span><br><span class=\"line\"></span><br><span class=\"line\">    CMP AL, 0</span><br><span class=\"line\">    JGE PRINT_DEC     _; 如果是正数，直接打印_</span><br><span class=\"line\">    NEG AL            _; 取绝对值_</span><br><span class=\"line\">    CBW</span><br><span class=\"line\"></span><br><span class=\"line\">PRINT_DEC:</span><br><span class=\"line\">    _; AX中为正数，转十进制_</span><br><span class=\"line\">    MOV SI, 0</span><br><span class=\"line\">    MOV BX, 10</span><br><span class=\"line\"></span><br><span class=\"line\">CONV_LOOP:</span><br><span class=\"line\">    XOR DX, DX</span><br><span class=\"line\">    DIV BX            _; AX / 10, 商-&gt;AX, 余数-&gt;DX_</span><br><span class=\"line\">    ADD DL, &#x27;0&#x27;</span><br><span class=\"line\">    MOV buf[SI], DL</span><br><span class=\"line\">    INC SI</span><br><span class=\"line\">    CMP AX, 0</span><br><span class=\"line\">    JNZ CONV_LOOP</span><br><span class=\"line\"></span><br><span class=\"line\">PRINT_LOOP:</span><br><span class=\"line\">    DEC SI</span><br><span class=\"line\">    MOV DL, buf[SI]</span><br><span class=\"line\">    MOV AH, 2</span><br><span class=\"line\">    INT 21H</span><br><span class=\"line\">    CMP SI, 0</span><br><span class=\"line\">    JNZ PRINT_LOOP</span><br><span class=\"line\"></span><br><span class=\"line\">    MOV AH, 4CH</span><br><span class=\"line\">    INT 21H</span><br><span class=\"line\">CODE ENDS</span><br><span class=\"line\">    END START</span><br></pre></td></tr></table></figure>\n\n<h2 id=\"完整代码\"><a href=\"#完整代码\" class=\"headerlink\" title=\"完整代码\"></a>完整代码</h2><figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br><span class=\"line\">47</span><br><span class=\"line\">48</span><br><span class=\"line\">49</span><br><span class=\"line\">50</span><br><span class=\"line\">51</span><br><span class=\"line\">52</span><br><span class=\"line\">53</span><br><span class=\"line\">54</span><br><span class=\"line\">55</span><br><span class=\"line\">56</span><br><span class=\"line\">57</span><br><span class=\"line\">58</span><br><span class=\"line\">59</span><br><span class=\"line\">60</span><br><span class=\"line\">61</span><br><span class=\"line\">62</span><br><span class=\"line\">63</span><br><span class=\"line\">64</span><br><span class=\"line\">65</span><br><span class=\"line\">66</span><br><span class=\"line\">67</span><br><span class=\"line\">68</span><br><span class=\"line\">69</span><br><span class=\"line\">70</span><br><span class=\"line\">71</span><br><span class=\"line\">72</span><br><span class=\"line\">73</span><br><span class=\"line\">74</span><br><span class=\"line\">75</span><br><span class=\"line\">76</span><br><span class=\"line\">77</span><br><span class=\"line\">78</span><br><span class=\"line\">79</span><br><span class=\"line\">80</span><br><span class=\"line\">81</span><br><span class=\"line\">82</span><br><span class=\"line\">83</span><br><span class=\"line\">84</span><br><span class=\"line\">85</span><br><span class=\"line\">86</span><br><span class=\"line\">87</span><br><span class=\"line\">88</span><br><span class=\"line\">89</span><br><span class=\"line\">90</span><br><span class=\"line\">91</span><br><span class=\"line\">92</span><br><span class=\"line\">93</span><br><span class=\"line\">94</span><br><span class=\"line\">95</span><br><span class=\"line\">96</span><br><span class=\"line\">97</span><br><span class=\"line\">98</span><br><span class=\"line\">99</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">DATA SEGMENT</span><br><span class=\"line\">    DATAX DB 6      _; 带符号字节数据，负数_</span><br><span class=\"line\">    DATAY DB -2      _; 带符号字节数据，正数_</span><br><span class=\"line\">    RESULT DB 0</span><br><span class=\"line\">    BUF DB 4 DUP(?)</span><br><span class=\"line\">DATA ENDS</span><br><span class=\"line\"></span><br><span class=\"line\">CSEG SEGMENT</span><br><span class=\"line\">    ASSUME CS:CSEG,DS:DATA</span><br><span class=\"line\">START:</span><br><span class=\"line\">      MOV AX,DATA</span><br><span class=\"line\">      MOV DS,AX</span><br><span class=\"line\"></span><br><span class=\"line\">      _;从键盘接收+,-,*,/_</span><br><span class=\"line\">      MOV AH,1</span><br><span class=\"line\">      INT 21H</span><br><span class=\"line\"></span><br><span class=\"line\">      CMP AL,&#x27;+&#x27;</span><br><span class=\"line\">      JE ADD_OP</span><br><span class=\"line\">      CMP AL,&#x27;-&#x27;</span><br><span class=\"line\">      JE SUB_OP</span><br><span class=\"line\">      CMP AL,&#x27;*&#x27;</span><br><span class=\"line\">      JE MUL_OP</span><br><span class=\"line\">      CMP AL,&#x27;/&#x27;</span><br><span class=\"line\">      JE DIV_OP</span><br><span class=\"line\"></span><br><span class=\"line\">ADD_OP:</span><br><span class=\"line\">      MOV AL,DATAX</span><br><span class=\"line\">      MOV BL,DATAY</span><br><span class=\"line\">      ADD AL,BL</span><br><span class=\"line\">      MOV RESULT,AL</span><br><span class=\"line\">      JMP SHOW_RESULT  </span><br><span class=\"line\">  </span><br><span class=\"line\">SUB_OP:</span><br><span class=\"line\">      MOV AL,DATAX</span><br><span class=\"line\">      MOV BL,DATAY</span><br><span class=\"line\">      SUB AL,BL</span><br><span class=\"line\">      MOV RESULT,AL</span><br><span class=\"line\">      JMP SHOW_RESULT  </span><br><span class=\"line\"></span><br><span class=\"line\">MUL_OP:</span><br><span class=\"line\">_; 字节乘法： _</span><br><span class=\"line\">_; （AL）*（OPS8）→AX_</span><br><span class=\"line\">      MOV AL,DATAX</span><br><span class=\"line\">      MOV BL,DATAY</span><br><span class=\"line\">      IMUL BL</span><br><span class=\"line\">      MOV RESULT,AL</span><br><span class=\"line\">      JMP SHOW_RESULT  </span><br><span class=\"line\"></span><br><span class=\"line\">DIV_OP:</span><br><span class=\"line\">      MOV AL,DATAX</span><br><span class=\"line\">      MOV BL,DATAY</span><br><span class=\"line\">      CBW _;将AL符号扩展到AX_</span><br><span class=\"line\">      IDIV BL</span><br><span class=\"line\">      MOV RESULT,AL</span><br><span class=\"line\">      JMP SHOW_RESULT  </span><br><span class=\"line\"></span><br><span class=\"line\">_;难点在打印,将每次除以10,把余数入栈,然后出栈,打印_</span><br><span class=\"line\">SHOW_RESULT:</span><br><span class=\"line\">    MOV AL, RESULT</span><br><span class=\"line\">    CBW</span><br><span class=\"line\">    CMP AL, 0</span><br><span class=\"line\">    JGE SHOW</span><br><span class=\"line\">    PUSH AX           _; 保存原始AL_</span><br><span class=\"line\">    MOV DL, &#x27;-&#x27;</span><br><span class=\"line\">    MOV AH, 2</span><br><span class=\"line\">    INT 21H</span><br><span class=\"line\">    POP AX            _; 恢复AL_</span><br><span class=\"line\">    NEG AL</span><br><span class=\"line\">    CBW</span><br><span class=\"line\"></span><br><span class=\"line\">SHOW:</span><br><span class=\"line\">    MOV SI,0            _; SI为BUF索引_</span><br><span class=\"line\">    MOV BX,10</span><br><span class=\"line\"></span><br><span class=\"line\">CONV_LOOP:</span><br><span class=\"line\">    MOV DX,0</span><br><span class=\"line\">    DIV BX</span><br><span class=\"line\">    ADD DL,&#x27;0&#x27;</span><br><span class=\"line\">    MOV BUF[SI],DL</span><br><span class=\"line\">    INC SI</span><br><span class=\"line\">    CMP AX,0</span><br><span class=\"line\">    JNZ CONV_LOOP</span><br><span class=\"line\"></span><br><span class=\"line\">PRINT_LOOP:</span><br><span class=\"line\">    DEC SI</span><br><span class=\"line\">    MOV DL,BUF[SI]</span><br><span class=\"line\">    MOV AH,2</span><br><span class=\"line\">    INT 21H</span><br><span class=\"line\">    CMP SI,0</span><br><span class=\"line\">    JNZ PRINT_LOOP</span><br><span class=\"line\">    JMP EXIT</span><br><span class=\"line\"></span><br><span class=\"line\">EXIT:</span><br><span class=\"line\">      MOV AH,4CH</span><br><span class=\"line\">      INT 21H</span><br><span class=\"line\">  </span><br><span class=\"line\">CSEG ENDS</span><br><span class=\"line\">      END START</span><br></pre></td></tr></table></figure>\n\n<h2 id=\"程序逻辑流程图\"><a href=\"#程序逻辑流程图\" class=\"headerlink\" title=\"程序逻辑流程图\"></a>程序逻辑流程图</h2><p><img src=\"https://tk-pichost-1325224430.cos.ap-chengdu.myqcloud.com/blog/17478844701641747884469368.png\" alt=\"17478844701641747884469368.png\"></p>\n<blockquote>\n<h3 id=\"注意事项\"><a href=\"#注意事项\" class=\"headerlink\" title=\"注意事项\"></a>注意事项</h3></blockquote>\n<ul>\n<li>当 RESULT 为负数时,我在打印结果的时候我们需要先打印’-’号,INT 21H 会把 AL 的值重新设置</li>\n<li>使用 IDIV BX 命令前需要我们将 AX 使用 CBW 命令将 AL 扩展为 AX</li>\n</ul>\n<h2 id=\"进一步的修改\"><a href=\"#进一步的修改\" class=\"headerlink\" title=\"进一步的修改\"></a>进一步的修改</h2><figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br><span class=\"line\">47</span><br><span class=\"line\">48</span><br><span class=\"line\">49</span><br><span class=\"line\">50</span><br><span class=\"line\">51</span><br><span class=\"line\">52</span><br><span class=\"line\">53</span><br><span class=\"line\">54</span><br><span class=\"line\">55</span><br><span class=\"line\">56</span><br><span class=\"line\">57</span><br><span class=\"line\">58</span><br><span class=\"line\">59</span><br><span class=\"line\">60</span><br><span class=\"line\">61</span><br><span class=\"line\">62</span><br><span class=\"line\">63</span><br><span class=\"line\">64</span><br><span class=\"line\">65</span><br><span class=\"line\">66</span><br><span class=\"line\">67</span><br><span class=\"line\">68</span><br><span class=\"line\">69</span><br><span class=\"line\">70</span><br><span class=\"line\">71</span><br><span class=\"line\">72</span><br><span class=\"line\">73</span><br><span class=\"line\">74</span><br><span class=\"line\">75</span><br><span class=\"line\">76</span><br><span class=\"line\">77</span><br><span class=\"line\">78</span><br><span class=\"line\">79</span><br><span class=\"line\">80</span><br><span class=\"line\">81</span><br><span class=\"line\">82</span><br><span class=\"line\">83</span><br><span class=\"line\">84</span><br><span class=\"line\">85</span><br><span class=\"line\">86</span><br><span class=\"line\">87</span><br><span class=\"line\">88</span><br><span class=\"line\">89</span><br><span class=\"line\">90</span><br><span class=\"line\">91</span><br><span class=\"line\">92</span><br><span class=\"line\">93</span><br><span class=\"line\">94</span><br><span class=\"line\">95</span><br><span class=\"line\">96</span><br><span class=\"line\">97</span><br><span class=\"line\">98</span><br><span class=\"line\">99</span><br><span class=\"line\">100</span><br><span class=\"line\">101</span><br><span class=\"line\">102</span><br><span class=\"line\">103</span><br><span class=\"line\">104</span><br><span class=\"line\">105</span><br><span class=\"line\">106</span><br><span class=\"line\">107</span><br><span class=\"line\">108</span><br><span class=\"line\">109</span><br><span class=\"line\">110</span><br><span class=\"line\">111</span><br><span class=\"line\">112</span><br><span class=\"line\">113</span><br><span class=\"line\">114</span><br><span class=\"line\">115</span><br><span class=\"line\">116</span><br><span class=\"line\">117</span><br><span class=\"line\">118</span><br><span class=\"line\">119</span><br><span class=\"line\">120</span><br><span class=\"line\">121</span><br><span class=\"line\">122</span><br><span class=\"line\">123</span><br><span class=\"line\">124</span><br><span class=\"line\">125</span><br><span class=\"line\">126</span><br><span class=\"line\">127</span><br><span class=\"line\">128</span><br><span class=\"line\">129</span><br><span class=\"line\">130</span><br><span class=\"line\">131</span><br><span class=\"line\">132</span><br><span class=\"line\">133</span><br><span class=\"line\">134</span><br><span class=\"line\">135</span><br><span class=\"line\">136</span><br><span class=\"line\">137</span><br><span class=\"line\">138</span><br><span class=\"line\">139</span><br><span class=\"line\">140</span><br><span class=\"line\">141</span><br><span class=\"line\">142</span><br><span class=\"line\">143</span><br><span class=\"line\">144</span><br><span class=\"line\">145</span><br><span class=\"line\">146</span><br><span class=\"line\">147</span><br><span class=\"line\">148</span><br><span class=\"line\">149</span><br><span class=\"line\">150</span><br><span class=\"line\">151</span><br><span class=\"line\">152</span><br><span class=\"line\">153</span><br><span class=\"line\">154</span><br><span class=\"line\">155</span><br><span class=\"line\">156</span><br><span class=\"line\">157</span><br><span class=\"line\">158</span><br><span class=\"line\">159</span><br><span class=\"line\">160</span><br><span class=\"line\">161</span><br><span class=\"line\">162</span><br><span class=\"line\">163</span><br><span class=\"line\">164</span><br><span class=\"line\">165</span><br><span class=\"line\">166</span><br><span class=\"line\">167</span><br><span class=\"line\">168</span><br><span class=\"line\">169</span><br><span class=\"line\">170</span><br><span class=\"line\">171</span><br><span class=\"line\">172</span><br><span class=\"line\">173</span><br><span class=\"line\">174</span><br><span class=\"line\">175</span><br><span class=\"line\">176</span><br><span class=\"line\">177</span><br><span class=\"line\">178</span><br><span class=\"line\">179</span><br><span class=\"line\">180</span><br><span class=\"line\">181</span><br><span class=\"line\">182</span><br><span class=\"line\">183</span><br><span class=\"line\">184</span><br><span class=\"line\">185</span><br><span class=\"line\">186</span><br><span class=\"line\">187</span><br><span class=\"line\">188</span><br><span class=\"line\">189</span><br><span class=\"line\">190</span><br><span class=\"line\">191</span><br><span class=\"line\">192</span><br><span class=\"line\">193</span><br><span class=\"line\">194</span><br><span class=\"line\">195</span><br><span class=\"line\">196</span><br><span class=\"line\">197</span><br><span class=\"line\">198</span><br><span class=\"line\">199</span><br><span class=\"line\">200</span><br><span class=\"line\">201</span><br><span class=\"line\">202</span><br><span class=\"line\">203</span><br><span class=\"line\">204</span><br><span class=\"line\">205</span><br><span class=\"line\">206</span><br><span class=\"line\">207</span><br><span class=\"line\">208</span><br><span class=\"line\">209</span><br><span class=\"line\">210</span><br><span class=\"line\">211</span><br><span class=\"line\">212</span><br><span class=\"line\">213</span><br><span class=\"line\">214</span><br><span class=\"line\">215</span><br><span class=\"line\">216</span><br><span class=\"line\">217</span><br><span class=\"line\">218</span><br><span class=\"line\">219</span><br><span class=\"line\">220</span><br><span class=\"line\">221</span><br><span class=\"line\">222</span><br><span class=\"line\">223</span><br><span class=\"line\">224</span><br><span class=\"line\">225</span><br><span class=\"line\">226</span><br><span class=\"line\">227</span><br><span class=\"line\">228</span><br><span class=\"line\">229</span><br><span class=\"line\">230</span><br><span class=\"line\">231</span><br><span class=\"line\">232</span><br><span class=\"line\">233</span><br><span class=\"line\">234</span><br><span class=\"line\">235</span><br><span class=\"line\">236</span><br><span class=\"line\">237</span><br><span class=\"line\">238</span><br><span class=\"line\">239</span><br><span class=\"line\">240</span><br><span class=\"line\">241</span><br><span class=\"line\">242</span><br><span class=\"line\">243</span><br><span class=\"line\">244</span><br><span class=\"line\">245</span><br><span class=\"line\">246</span><br><span class=\"line\">247</span><br><span class=\"line\">248</span><br><span class=\"line\">249</span><br><span class=\"line\">250</span><br><span class=\"line\">251</span><br><span class=\"line\">252</span><br><span class=\"line\">253</span><br><span class=\"line\">254</span><br><span class=\"line\">255</span><br><span class=\"line\">256</span><br><span class=\"line\">257</span><br><span class=\"line\">258</span><br><span class=\"line\">259</span><br><span class=\"line\">260</span><br><span class=\"line\">261</span><br><span class=\"line\">262</span><br><span class=\"line\">263</span><br><span class=\"line\">264</span><br><span class=\"line\">265</span><br><span class=\"line\">266</span><br><span class=\"line\">267</span><br><span class=\"line\">268</span><br><span class=\"line\">269</span><br><span class=\"line\">270</span><br><span class=\"line\">271</span><br><span class=\"line\">272</span><br><span class=\"line\">273</span><br><span class=\"line\">274</span><br><span class=\"line\">275</span><br><span class=\"line\">276</span><br><span class=\"line\">277</span><br><span class=\"line\">278</span><br><span class=\"line\">279</span><br><span class=\"line\">280</span><br><span class=\"line\">281</span><br><span class=\"line\">282</span><br><span class=\"line\">283</span><br><span class=\"line\">284</span><br><span class=\"line\">285</span><br><span class=\"line\">286</span><br><span class=\"line\">287</span><br><span class=\"line\">288</span><br><span class=\"line\">289</span><br><span class=\"line\">290</span><br><span class=\"line\">291</span><br><span class=\"line\">292</span><br><span class=\"line\">293</span><br><span class=\"line\">294</span><br><span class=\"line\">295</span><br><span class=\"line\">296</span><br><span class=\"line\">297</span><br><span class=\"line\">298</span><br><span class=\"line\">299</span><br><span class=\"line\">300</span><br><span class=\"line\">301</span><br><span class=\"line\">302</span><br><span class=\"line\">303</span><br><span class=\"line\">304</span><br><span class=\"line\">305</span><br><span class=\"line\">306</span><br><span class=\"line\">307</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">_; 简单计算器程序 - 对DATAX和DATAY中的有符号字节数据进行四则运算_</span><br><span class=\"line\">_; 支持加(+)、减(-)、乘(*)、除(/)四种运算符_</span><br><span class=\"line\"></span><br><span class=\"line\">.MODEL SMALL</span><br><span class=\"line\">.STACK 100H</span><br><span class=\"line\"></span><br><span class=\"line\">.DATA</span><br><span class=\"line\">DATAX   DB  ?           _; 第一个操作数_</span><br><span class=\"line\">DATAY   DB  ?           _; 第二个操作数_</span><br><span class=\"line\">MSG1    DB  &#x27;Input first number: $&#x27;</span><br><span class=\"line\">MSG2    DB  0DH, 0AH, &#x27;Input second number: $&#x27;</span><br><span class=\"line\">MSG3    DB  0DH, 0AH, &#x27;Input operator (+, -, *, /): $&#x27;</span><br><span class=\"line\">MSG4    DB  0DH, 0AH, &#x27;Result: $&#x27;</span><br><span class=\"line\">MSG5    DB  0DH, 0AH, &#x27;Division by zero! $&#x27;</span><br><span class=\"line\">TEMP    DW  ?           _; 临时存储乘法或除法结果_</span><br><span class=\"line\">NEG_FLAG DB  0           _; 负数标志 (1表示结果为负)_</span><br><span class=\"line\">BUF     DB  6 DUP(?)    _; 用于存储结果字符串_</span><br><span class=\"line\">NEG_INPUT DB 0          _; 输入负号标志_</span><br><span class=\"line\">VALUE     DB 0          _; 输入值_</span><br><span class=\"line\"></span><br><span class=\"line\">.CODE</span><br><span class=\"line\">MAIN PROC</span><br><span class=\"line\">    MOV AX, @DATA       _; 初始化数据段_</span><br><span class=\"line\">    MOV DS, AX</span><br><span class=\"line\"></span><br><span class=\"line\">    _; 显示第一条提示消息_</span><br><span class=\"line\">    LEA DX, MSG1</span><br><span class=\"line\">    MOV AH, 09H</span><br><span class=\"line\">    INT 21H</span><br><span class=\"line\"></span><br><span class=\"line\">    _; 输入第一个数字_</span><br><span class=\"line\">    CALL INPUT_SIGNED_BYTE</span><br><span class=\"line\">    MOV DATAX, AL</span><br><span class=\"line\"></span><br><span class=\"line\">    _; 显示第二条提示消息_</span><br><span class=\"line\">    LEA DX, MSG2</span><br><span class=\"line\">    MOV AH, 09H</span><br><span class=\"line\">    INT 21H</span><br><span class=\"line\"></span><br><span class=\"line\">    _; 输入第二个数字_</span><br><span class=\"line\">    CALL INPUT_SIGNED_BYTE</span><br><span class=\"line\">    MOV DATAY, AL</span><br><span class=\"line\"></span><br><span class=\"line\">    _; 显示操作符提示消息_</span><br><span class=\"line\">    LEA DX, MSG3</span><br><span class=\"line\">    MOV AH, 09H</span><br><span class=\"line\">    INT 21H</span><br><span class=\"line\"></span><br><span class=\"line\">    _; 输入操作符_</span><br><span class=\"line\">    MOV AH, 01H</span><br><span class=\"line\">    INT 21H</span><br><span class=\"line\">    MOV BL, AL          _; 保存操作符在BL中_</span><br><span class=\"line\"></span><br><span class=\"line\">    _; 显示结果提示消息_</span><br><span class=\"line\">    LEA DX, MSG4</span><br><span class=\"line\">    MOV AH, 09H</span><br><span class=\"line\">    INT 21H</span><br><span class=\"line\"></span><br><span class=\"line\">    _; 根据操作符执行相应运算_</span><br><span class=\"line\">    CMP BL, &#x27;+&#x27;         _; 检查是否为加法_</span><br><span class=\"line\">    JE  DO_ADD</span><br><span class=\"line\">    CMP BL, &#x27;-&#x27;         _; 检查是否为减法_</span><br><span class=\"line\">    JE  DO_SUB</span><br><span class=\"line\">    CMP BL, &#x27;*&#x27;         _; 检查是否为乘法_</span><br><span class=\"line\">    JE  DO_MUL</span><br><span class=\"line\">    CMP BL, &#x27;/&#x27;         _; 检查是否为除法_</span><br><span class=\"line\">    JE  DO_DIV</span><br><span class=\"line\">    JMP EXIT            _; 如果不是有效操作符，直接退出_</span><br><span class=\"line\"></span><br><span class=\"line\">DO_ADD:</span><br><span class=\"line\">    MOV AL, DATAX       _; 加法运算_</span><br><span class=\"line\">    ADD AL, DATAY</span><br><span class=\"line\">    JMP DISPLAY_RESULT</span><br><span class=\"line\"></span><br><span class=\"line\">DO_SUB:</span><br><span class=\"line\">    MOV AL, DATAX       _; 减法运算_</span><br><span class=\"line\">    SUB AL, DATAY</span><br><span class=\"line\">    JMP DISPLAY_RESULT</span><br><span class=\"line\"></span><br><span class=\"line\">DO_MUL:</span><br><span class=\"line\">    MOV AL, DATAX       _; 乘法运算_</span><br><span class=\"line\">    MOV BL, DATAY</span><br><span class=\"line\">    CALL SIGNED_MUL</span><br><span class=\"line\">    JMP DISPLAY_AX</span><br><span class=\"line\"></span><br><span class=\"line\">DO_DIV:</span><br><span class=\"line\">    MOV AL, DATAX       _; 除法运算_</span><br><span class=\"line\">    MOV BL, DATAY</span><br><span class=\"line\">    CALL SIGNED_DIV</span><br><span class=\"line\">    JMP DISPLAY_AX</span><br><span class=\"line\"></span><br><span class=\"line\">DISPLAY_RESULT:</span><br><span class=\"line\">    _; 结果在AL中，转换为字符串并显示_</span><br><span class=\"line\">    MOV AH, 0           _; 清零AH，结果扩展到AX_</span><br><span class=\"line\">    CMP AL, 0</span><br><span class=\"line\">    JGE POSITIVE</span><br><span class=\"line\">    NEG AL              _; 如果为负，取绝对值_</span><br><span class=\"line\">    MOV NEG_FLAG, 1     _; 设置负数标志_</span><br><span class=\"line\">    JMP CONTINUE</span><br><span class=\"line\">POSITIVE:</span><br><span class=\"line\">    MOV NEG_FLAG, 0     _; 清除负数标志_</span><br><span class=\"line\">CONTINUE:</span><br><span class=\"line\">    MOV AX, AX          _; AX中现在是结果的绝对值_</span><br><span class=\"line\"></span><br><span class=\"line\">DISPLAY_AX:</span><br><span class=\"line\">    _; 显示AX中的有符号结果_</span><br><span class=\"line\">    CALL DISPLAY_SIGNED_NUM</span><br><span class=\"line\">  </span><br><span class=\"line\">EXIT:</span><br><span class=\"line\">    _; 程序结束_</span><br><span class=\"line\">    MOV AH, 4CH</span><br><span class=\"line\">    INT 21H</span><br><span class=\"line\">MAIN ENDP</span><br><span class=\"line\"></span><br><span class=\"line\">_; 输入有符号字节的过程_</span><br><span class=\"line\">INPUT_SIGNED_BYTE PROC</span><br><span class=\"line\">    _; 检查第一个字符是否为负号_</span><br><span class=\"line\">    MOV AH, 01H</span><br><span class=\"line\">    INT 21H</span><br><span class=\"line\">    CMP AL, &#x27;-&#x27;</span><br><span class=\"line\">    JNE CHECK_DIGIT1</span><br><span class=\"line\">    MOV NEG_INPUT, 1    _; 设置负号标志_</span><br><span class=\"line\">    MOV AH, 01H         _; 再次读取一个字符_</span><br><span class=\"line\">    INT 21H</span><br><span class=\"line\">  </span><br><span class=\"line\">CHECK_DIGIT1:</span><br><span class=\"line\">    _; 检查输入字符是否为数字_</span><br><span class=\"line\">    CMP AL, &#x27;0&#x27;</span><br><span class=\"line\">    JL EXIT_INPUT       _; 如果小于&#x27;0&#x27;，不是数字_</span><br><span class=\"line\">    CMP AL, &#x27;9&#x27;</span><br><span class=\"line\">    JG EXIT_INPUT       _; 如果大于&#x27;9&#x27;，不是数字_</span><br><span class=\"line\">  </span><br><span class=\"line\">    _; 转换为数值并保存_</span><br><span class=\"line\">    SUB AL, &#x27;0&#x27;</span><br><span class=\"line\">    MOV VALUE, AL</span><br><span class=\"line\">  </span><br><span class=\"line\">    _; 读取可能存在的第二个数字_</span><br><span class=\"line\">    MOV AH, 01H</span><br><span class=\"line\">    INT 21H</span><br><span class=\"line\">  </span><br><span class=\"line\">    _; 检查第二个字符是否为数字_</span><br><span class=\"line\">    CMP AL, &#x27;0&#x27;</span><br><span class=\"line\">    JL EXIT_INPUT2      _; 如果小于&#x27;0&#x27;，不是数字_</span><br><span class=\"line\">    CMP AL, &#x27;9&#x27;</span><br><span class=\"line\">    JG EXIT_INPUT2      _; 如果大于&#x27;9&#x27;，不是数字_</span><br><span class=\"line\">  </span><br><span class=\"line\">    _; 处理第二个数字_</span><br><span class=\"line\">    SUB AL, &#x27;0&#x27;</span><br><span class=\"line\">    MOV BL, VALUE       _; 将第一个数字移到BL_</span><br><span class=\"line\">    MOV BH, 0           _; 清零BH_</span><br><span class=\"line\">    MOV CX, 10</span><br><span class=\"line\">    MUL CX              _; 将BX乘以10_</span><br><span class=\"line\">    ADD BL, AL          _; 加上第二个数字_</span><br><span class=\"line\">    MOV VALUE, BL</span><br><span class=\"line\">    JMP EXIT_INPUT</span><br><span class=\"line\">  </span><br><span class=\"line\">EXIT_INPUT2:</span><br><span class=\"line\">    _; 如果第二个字符不是数字，将它放回缓冲区(模拟未读取)_</span><br><span class=\"line\">    MOV DL, AL</span><br><span class=\"line\">    MOV AH, 02H</span><br><span class=\"line\">    INT 21H</span><br><span class=\"line\">  </span><br><span class=\"line\">EXIT_INPUT:</span><br><span class=\"line\">    _; 返回结果_</span><br><span class=\"line\">    MOV AL, VALUE</span><br><span class=\"line\">    CMP NEG_INPUT, 1</span><br><span class=\"line\">    JNE RETURN_INPUT</span><br><span class=\"line\">    NEG AL              _; 如果有负号标志，取负值_</span><br><span class=\"line\">  </span><br><span class=\"line\">RETURN_INPUT:</span><br><span class=\"line\">    RET</span><br><span class=\"line\">INPUT_SIGNED_BYTE ENDP</span><br><span class=\"line\"></span><br><span class=\"line\">_; 有符号乘法过程 - 结果在AX中_</span><br><span class=\"line\">SIGNED_MUL PROC</span><br><span class=\"line\">    _; 保存符号_</span><br><span class=\"line\">    MOV CL, AL          _; 保存第一个操作数_</span><br><span class=\"line\">    MOV CH, BL          _; 保存第二个操作数_</span><br><span class=\"line\">  </span><br><span class=\"line\">    _; 取绝对值_</span><br><span class=\"line\">    CMP AL, 0</span><br><span class=\"line\">    JGE ABS1_DONE</span><br><span class=\"line\">    NEG AL</span><br><span class=\"line\">ABS1_DONE:</span><br><span class=\"line\">    CMP BL, 0</span><br><span class=\"line\">    JGE ABS2_DONE</span><br><span class=\"line\">    NEG BL</span><br><span class=\"line\">ABS2_DONE:</span><br><span class=\"line\">  </span><br><span class=\"line\">    _; 执行无符号乘法_</span><br><span class=\"line\">    MUL BL              _; AX = AL * BL_</span><br><span class=\"line\">  </span><br><span class=\"line\">    _; 确定结果符号_</span><br><span class=\"line\">    MOV BH, 0           _; 清零BH_</span><br><span class=\"line\">    MOV BL, 0           _; 假设结果为正_</span><br><span class=\"line\">  </span><br><span class=\"line\">    CMP CL, 0           _; 检查第一个操作数符号_</span><br><span class=\"line\">    JGE CHECK_OP2_MUL</span><br><span class=\"line\">    XOR BL, 1           _; 翻转符号位_</span><br><span class=\"line\">  </span><br><span class=\"line\">CHECK_OP2_MUL:</span><br><span class=\"line\">    CMP CH, 0           _; 检查第二个操作数符号_</span><br><span class=\"line\">    JGE APPLY_SIGN_MUL</span><br><span class=\"line\">    XOR BL, 1           _; 翻转符号位_</span><br><span class=\"line\">  </span><br><span class=\"line\">APPLY_SIGN_MUL:</span><br><span class=\"line\">    CMP BL, 1           _; 检查是否需要取负_</span><br><span class=\"line\">    JNE RETURN_MUL</span><br><span class=\"line\">    NEG AX              _; 对结果取负_</span><br><span class=\"line\">  </span><br><span class=\"line\">RETURN_MUL:</span><br><span class=\"line\">    RET</span><br><span class=\"line\">SIGNED_MUL ENDP</span><br><span class=\"line\"></span><br><span class=\"line\">_; 有符号除法过程 - 结果在AX中_</span><br><span class=\"line\">SIGNED_DIV PROC</span><br><span class=\"line\">    _; 检查除数是否为零_</span><br><span class=\"line\">    CMP BL, 0</span><br><span class=\"line\">    JNE NOT_ZERO_DIV</span><br><span class=\"line\">  </span><br><span class=\"line\">    _; 除数为零处理_</span><br><span class=\"line\">    LEA DX, MSG5        _; 显示除零错误消息_</span><br><span class=\"line\">    MOV AH, 09H</span><br><span class=\"line\">    INT 21H</span><br><span class=\"line\">    MOV AX, 0           _; 返回0_</span><br><span class=\"line\">    RET</span><br><span class=\"line\">  </span><br><span class=\"line\">NOT_ZERO_DIV:</span><br><span class=\"line\">    _; 保存符号_</span><br><span class=\"line\">    MOV CL, AL          _; 保存第一个操作数_</span><br><span class=\"line\">    MOV CH, BL          _; 保存第二个操作数_</span><br><span class=\"line\">  </span><br><span class=\"line\">    _; 取绝对值_</span><br><span class=\"line\">    CMP AL, 0</span><br><span class=\"line\">    JGE ABS1_DIV_DONE</span><br><span class=\"line\">    NEG AL</span><br><span class=\"line\">ABS1_DIV_DONE:</span><br><span class=\"line\">    CMP BL, 0</span><br><span class=\"line\">    JGE ABS2_DIV_DONE</span><br><span class=\"line\">    NEG BL</span><br><span class=\"line\">ABS2_DIV_DONE:</span><br><span class=\"line\">  </span><br><span class=\"line\">    _; 执行无符号除法_</span><br><span class=\"line\">    MOV AH, 0           _; 扩展AL到AX_</span><br><span class=\"line\">    DIV BL              _; AL = AX / BL, AH = AX % BL_</span><br><span class=\"line\">    MOV AH, 0           _; 清零AH(我们只关心商)_</span><br><span class=\"line\">  </span><br><span class=\"line\">    _; 确定结果符号_</span><br><span class=\"line\">    MOV BH, 0           _; 清零BH_</span><br><span class=\"line\">    MOV BL, 0           _; 假设结果为正_</span><br><span class=\"line\">  </span><br><span class=\"line\">    CMP CL, 0           _; 检查第一个操作数符号_</span><br><span class=\"line\">    JGE CHECK_OP2_DIV</span><br><span class=\"line\">    XOR BL, 1           _; 翻转符号位_</span><br><span class=\"line\">  </span><br><span class=\"line\">CHECK_OP2_DIV:</span><br><span class=\"line\">    CMP CH, 0           _; 检查第二个操作数符号_</span><br><span class=\"line\">    JGE APPLY_SIGN_DIV</span><br><span class=\"line\">    XOR BL, 1           _; 翻转符号位_</span><br><span class=\"line\">  </span><br><span class=\"line\">APPLY_SIGN_DIV:</span><br><span class=\"line\">    CMP BL, 1           _; 检查是否需要取负_</span><br><span class=\"line\">    JNE RETURN_DIV</span><br><span class=\"line\">    NEG AX              _; 对结果取负_</span><br><span class=\"line\">  </span><br><span class=\"line\">RETURN_DIV:</span><br><span class=\"line\">    RET</span><br><span class=\"line\">SIGNED_DIV ENDP</span><br><span class=\"line\"></span><br><span class=\"line\">_; 显示有符号数字_</span><br><span class=\"line\">DISPLAY_SIGNED_NUM PROC</span><br><span class=\"line\">    _; 检查符号_</span><br><span class=\"line\">    CMP AX, 0</span><br><span class=\"line\">    JGE POS_NUM</span><br><span class=\"line\">  </span><br><span class=\"line\">    _; 显示负号_</span><br><span class=\"line\">    MOV DL, &#x27;-&#x27;</span><br><span class=\"line\">    MOV AH, 02H</span><br><span class=\"line\">    INT 21H</span><br><span class=\"line\">    NEG AX              _; 取绝对值_</span><br><span class=\"line\">  </span><br><span class=\"line\">POS_NUM:</span><br><span class=\"line\">    _; 将数字转换为字符串并显示_</span><br><span class=\"line\">    MOV CX, 0           _; 初始化计数器_</span><br><span class=\"line\">    MOV BX, 10          _; 基数(十进制)_</span><br><span class=\"line\">  </span><br><span class=\"line\">    _; 将数字转换为字符串(逆序)_</span><br><span class=\"line\">CONVERT_LOOP:</span><br><span class=\"line\">    MOV DX, 0           _; 清零DX_</span><br><span class=\"line\">    DIV BX              _; AX / 10, 商在AX，余数在DX_</span><br><span class=\"line\">    PUSH DX             _; 保存余数_</span><br><span class=\"line\">    INC CX              _; 增加计数器_</span><br><span class=\"line\">    CMP AX, 0           _; 检查商是否为0_</span><br><span class=\"line\">    JNE CONVERT_LOOP    _; 如果不是0，继续转换_</span><br><span class=\"line\">  </span><br><span class=\"line\">    _; 显示字符串(正序)_</span><br><span class=\"line\">DISPLAY_LOOP:</span><br><span class=\"line\">    POP DX              _; 取出一个数字_</span><br><span class=\"line\">    ADD DL, &#x27;0&#x27;         _; 转换为ASCII_</span><br><span class=\"line\">    MOV AH, 02H         _; 显示字符功能_</span><br><span class=\"line\">    INT 21H</span><br><span class=\"line\">    LOOP DISPLAY_LOOP   _; 循环直到所有数字显示完毕_</span><br><span class=\"line\">  </span><br><span class=\"line\">    RET</span><br><span class=\"line\">DISPLAY_SIGNED_NUM ENDP</span><br><span class=\"line\"></span><br><span class=\"line\">END MAIN</span><br></pre></td></tr></table></figure>\n","excerpt":"","more":"<h1 id=\"2025-05-21-汇编语言键盘输入输出\"><a href=\"#2025-05-21-汇编语言键盘输入输出\" class=\"headerlink\" title=\"2025-05-21-汇编语言键盘输入输出\"></a>2025-05-21-汇编语言键盘输入输出</h1><blockquote>\n<h1 id=\"参考博客\"><a href=\"#参考博客\" class=\"headerlink\" title=\"参考博客\"></a>参考博客</h1></blockquote>\n<h1 id=\"任务-1\"><a href=\"#任务-1\" class=\"headerlink\" title=\"任务 1\"></a>任务 1</h1><blockquote>\n<p>把数据段中 1 维数组 AA_1 变量地址中连续 7 个数（1,3,5,7,2,4,6）读出，把每个数加 2 后再存入到数据段中 BB_1 数组开始的标号地址中去，并显示出 BB_1 数组中每个数来（之间用空格分开）</p>\n</blockquote>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">DATA  SEGMENT</span><br><span class=\"line\">    ORG 0100H</span><br><span class=\"line\">  AA_1    DB     1,3,5,7,2,4,6</span><br><span class=\"line\">    ORG 0150H</span><br><span class=\"line\">  BB_1    DB     7 dup(?) </span><br><span class=\"line\">  COUNT  DW     7 _;给7设置别名_</span><br><span class=\"line\">DATA  ENDS</span><br><span class=\"line\">CSEG  SEGMENT</span><br><span class=\"line\">      ASSUME CS: CSEG,DS:DATA</span><br><span class=\"line\">START:MOV    AX, DATA</span><br><span class=\"line\">      MOV    DS, AX</span><br><span class=\"line\">      MOV    CX, COUNT</span><br><span class=\"line\">      LEA    SI, AA_1    _;取偏移地址(或者使用offset) _</span><br><span class=\"line\">      LEA    DI, BB_1   </span><br><span class=\"line\">LP1:  MOV    AL, [SI]   _;寄存器间接寻址方式可以改成相对寻址方式 _</span><br><span class=\"line\">      ADD    AL,2   </span><br><span class=\"line\">      MOV    [DI], AL   </span><br><span class=\"line\">      INC SI    _;SI+1        _</span><br><span class=\"line\">      INC DI    _;DI+1           _</span><br><span class=\"line\">      LOOP  LP1 _;不是0就转到标号LP1_</span><br><span class=\"line\">      LEA   SI, BB_1  </span><br><span class=\"line\">      MOV CX, COUNT</span><br><span class=\"line\">DISP:  MOV  DL, [SI]</span><br><span class=\"line\">ADD  DL, 30H    </span><br><span class=\"line\">MOV    AH,02    _;显示输出(要背下来)_</span><br><span class=\"line\">INT    21H   </span><br><span class=\"line\">      MOV DL,&#x27; &#x27;   _;每显示输出一个数后，输出一个空格  _</span><br><span class=\"line\">      MOV AH,2   </span><br><span class=\"line\">      INT 21H  </span><br><span class=\"line\">      INC   SI</span><br><span class=\"line\">      LOOP  DISP   </span><br><span class=\"line\">MOV    AH,4CH   </span><br><span class=\"line\">      INT    21H</span><br><span class=\"line\">CSEG  ENDS</span><br><span class=\"line\">      END    START</span><br></pre></td></tr></table></figure>\n\n<h1 id=\"任务-2\"><a href=\"#任务-2\" class=\"headerlink\" title=\"任务 2\"></a>任务 2</h1><blockquote>\n<p>从键盘接收一个小写字母，然后找出它的前导字符和后续字符，再按顺序显示这三个字符。</p>\n</blockquote>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">CSEG SEGMENT</span><br><span class=\"line\">    ASSUME CS:CSEG</span><br><span class=\"line\">    ORG 100H</span><br><span class=\"line\">START:</span><br><span class=\"line\">      ; 从键盘接收一个小写字母</span><br><span class=\"line\">      MOV AH,1</span><br><span class=\"line\">      INT 21H</span><br><span class=\"line\"></span><br><span class=\"line\">      MOV DL,AL</span><br><span class=\"line\">      DEC DL</span><br><span class=\"line\">  </span><br><span class=\"line\">      ; 设置循环次数</span><br><span class=\"line\">      MOV CX,3       ; 设置循环次数</span><br><span class=\"line\">  </span><br><span class=\"line\">LOOP1:</span><br><span class=\"line\">      ; 检查输入是否为小写字母</span><br><span class=\"line\">      CMP DL,&#x27;a&#x27;</span><br><span class=\"line\">      JB EXIT        ; 小于&#x27;a&#x27;就退出</span><br><span class=\"line\">      CMP DL,&#x27;z&#x27;</span><br><span class=\"line\">      JA EXIT        ; 大于&#x27;z&#x27;就退出</span><br><span class=\"line\">  </span><br><span class=\"line\">      MOV AH,2</span><br><span class=\"line\">      INT 21H</span><br><span class=\"line\">  </span><br><span class=\"line\">      ADD DL,1</span><br><span class=\"line\"></span><br><span class=\"line\">      LOOP LOOP1     ; CX减1，若不为0则跳转到LOOP1继续循环</span><br><span class=\"line\">  </span><br><span class=\"line\">EXIT:</span><br><span class=\"line\">      MOV AH,4CH</span><br><span class=\"line\">      INT 21H</span><br><span class=\"line\">  </span><br><span class=\"line\">CSEG ENDS</span><br><span class=\"line\">      END START</span><br></pre></td></tr></table></figure>\n\n<h2 id=\"1-指令-MOV-AH-02H-中-02H-的含义是？\"><a href=\"#1-指令-MOV-AH-02H-中-02H-的含义是？\" class=\"headerlink\" title=\"(1) 指令 MOV AH, 02H 中 02H 的含义是？\"></a>(1) 指令 MOV AH, 02H 中 02H 的含义是？</h2><p>在 x86 汇编中，<code>MOV AH, 02H</code> 指令将立即数 02H 存入 AH 寄存器。在 DOS 中断服务程序中，这个值有特殊含义：<strong>将 AH 设置为 02H 是为了调用 DOS 的 2 号功能 - 显示字符输出功能</strong>。</p>\n<p>当执行 <code>INT 21H</code> 中断调用时，系统会根据 AH 中的值来确定要执行的 DOS 功能。02H 功能会将 DL 寄存器中的 ASCII 字符显示到标准输出设备（通常是屏幕）上。</p>\n<h2 id=\"2-指令-ADD-DL-30H-的作用是什么？\"><a href=\"#2-指令-ADD-DL-30H-的作用是什么？\" class=\"headerlink\" title=\"(2) 指令 ADD DL, 30H 的作用是什么？\"></a>(2) 指令 ADD DL, 30H 的作用是什么？</h2><p>指令 <code>ADD DL, 30H</code> 的作用是<strong>将 DL 寄存器中的数值转换为对应的 ASCII 码字符</strong>。</p>\n<p>具体来说：</p>\n<ul>\n<li>30H 是 ASCII 码中数字’0’的十六进制表示</li>\n<li>当 DL 中存储的是一个 0-9 的数值时，加上 30H 后会变成对应数字的 ASCII 码</li>\n<li>例如：DL&#x3D;3，执行 ADD DL,30H 后，DL&#x3D;33H，这是数字’3’的 ASCII 码</li>\n</ul>\n<p>在这个程序中，由于 BB_1 数组中存储的是加 2 后的数值（3,5,7,9,4,6,8），需要将这些数值转换为 ASCII 码才能正确显示，否则会显示为不可见的控制字符。</p>\n<blockquote>\n<p>注意：这种转换方法只适用于单个十进制数字（0-9）。对于大于 9 的数字，这种简单的加 30H 方法会产生错误的字符。</p>\n</blockquote>\n<h2 id=\"3-除了参考程序中用的访问方式，还可以用什么方式访问-AA-1-数组里的元素？\"><a href=\"#3-除了参考程序中用的访问方式，还可以用什么方式访问-AA-1-数组里的元素？\" class=\"headerlink\" title=\"(3) 除了参考程序中用的访问方式，还可以用什么方式访问 AA_1 数组里的元素？\"></a>(3) 除了参考程序中用的访问方式，还可以用什么方式访问 AA_1 数组里的元素？</h2><p>参考程序中使用的是基于寄存器间接寻址方式（使用 SI 作为指针）来访问 AA_1 数组元素。除此之外，还可以使用以下方式：</p>\n<ol>\n<li><strong>直接寻址</strong>：</li>\n</ol>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">MOV AL, AA_1[0]    ; 访问第一个元素</span><br><span class=\"line\">MOV AL, AA_1[1]    ; 访问第二个元素</span><br></pre></td></tr></table></figure>\n\n<ol>\n<li><strong>基址寻址</strong>：</li>\n</ol>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">MOV BX, OFFSET AA_1</span><br><span class=\"line\">MOV AL, [BX]       ; 访问第一个元素</span><br><span class=\"line\">MOV AL, [BX+1]     ; 访问第二个元素</span><br></pre></td></tr></table></figure>\n\n<ol>\n<li><strong>变址寻址</strong>：</li>\n</ol>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">MOV SI, 0</span><br><span class=\"line\">MOV AL, AA_1[SI]   ; 访问第一个元素</span><br><span class=\"line\">INC SI</span><br><span class=\"line\">MOV AL, AA_1[SI]   ; 访问第二个元素</span><br></pre></td></tr></table></figure>\n\n<ol>\n<li><strong>基址加变址寻址</strong>：</li>\n</ol>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">MOV BX, OFFSET AA_1</span><br><span class=\"line\">MOV SI, 0</span><br><span class=\"line\">MOV AL, [BX+SI]    ; 访问第一个元素</span><br><span class=\"line\">INC SI</span><br><span class=\"line\">MOV AL, [BX+SI]    ; 访问第二个元素</span><br></pre></td></tr></table></figure>\n\n<ol>\n<li><strong>基址加变址加位移寻址</strong>：</li>\n</ol>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">MOV BX, OFFSET AA_1</span><br><span class=\"line\">MOV SI, 1</span><br><span class=\"line\">MOV AL, [BX+SI-1]  ; 访问第一个元素</span><br><span class=\"line\">MOV AL, [BX+SI]    ; 访问第二个元素</span><br></pre></td></tr></table></figure>\n\n<h1 id=\"任务-3\"><a href=\"#任务-3\" class=\"headerlink\" title=\"任务 3\"></a>任务 3</h1><blockquote>\n<p>已知 DATAX 和 DATAY 单元各存放一个带符号字节数据，从键盘上接收加（＋）、减（－）、乘（*）或除（&#x2F;）符号，然后完成相应运算，把结果显示在屏幕上。</p>\n</blockquote>\n<h2 id=\"求绝对值-基础模块\"><a href=\"#求绝对值-基础模块\" class=\"headerlink\" title=\"求绝对值(基础模块)\"></a>求绝对值(基础模块)</h2><figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">DATA SEGMENT</span><br><span class=\"line\">    num DB -6         _; 8位有符号数_</span><br><span class=\"line\">    buf DB 4 DUP(?)   _; 最多3位+1_</span><br><span class=\"line\">DATA ENDS</span><br><span class=\"line\"></span><br><span class=\"line\">CODE SEGMENT</span><br><span class=\"line\">    ASSUME CS:CODE, DS:DATA</span><br><span class=\"line\">START:</span><br><span class=\"line\">    MOV AX, DATA</span><br><span class=\"line\">    MOV DS, AX</span><br><span class=\"line\"></span><br><span class=\"line\">    MOV AL, num       _; 取数_</span><br><span class=\"line\">    CBW               _; 符号扩展到AX_</span><br><span class=\"line\"></span><br><span class=\"line\">    CMP AL, 0</span><br><span class=\"line\">    JGE PRINT_DEC     _; 如果是正数，直接打印_</span><br><span class=\"line\">    NEG AL            _; 取绝对值_</span><br><span class=\"line\">    CBW</span><br><span class=\"line\"></span><br><span class=\"line\">PRINT_DEC:</span><br><span class=\"line\">    _; AX中为正数，转十进制_</span><br><span class=\"line\">    MOV SI, 0</span><br><span class=\"line\">    MOV BX, 10</span><br><span class=\"line\"></span><br><span class=\"line\">CONV_LOOP:</span><br><span class=\"line\">    XOR DX, DX</span><br><span class=\"line\">    DIV BX            _; AX / 10, 商-&gt;AX, 余数-&gt;DX_</span><br><span class=\"line\">    ADD DL, &#x27;0&#x27;</span><br><span class=\"line\">    MOV buf[SI], DL</span><br><span class=\"line\">    INC SI</span><br><span class=\"line\">    CMP AX, 0</span><br><span class=\"line\">    JNZ CONV_LOOP</span><br><span class=\"line\"></span><br><span class=\"line\">PRINT_LOOP:</span><br><span class=\"line\">    DEC SI</span><br><span class=\"line\">    MOV DL, buf[SI]</span><br><span class=\"line\">    MOV AH, 2</span><br><span class=\"line\">    INT 21H</span><br><span class=\"line\">    CMP SI, 0</span><br><span class=\"line\">    JNZ PRINT_LOOP</span><br><span class=\"line\"></span><br><span class=\"line\">    MOV AH, 4CH</span><br><span class=\"line\">    INT 21H</span><br><span class=\"line\">CODE ENDS</span><br><span class=\"line\">    END START</span><br></pre></td></tr></table></figure>\n\n<h2 id=\"完整代码\"><a href=\"#完整代码\" class=\"headerlink\" title=\"完整代码\"></a>完整代码</h2><figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br><span class=\"line\">47</span><br><span class=\"line\">48</span><br><span class=\"line\">49</span><br><span class=\"line\">50</span><br><span class=\"line\">51</span><br><span class=\"line\">52</span><br><span class=\"line\">53</span><br><span class=\"line\">54</span><br><span class=\"line\">55</span><br><span class=\"line\">56</span><br><span class=\"line\">57</span><br><span class=\"line\">58</span><br><span class=\"line\">59</span><br><span class=\"line\">60</span><br><span class=\"line\">61</span><br><span class=\"line\">62</span><br><span class=\"line\">63</span><br><span class=\"line\">64</span><br><span class=\"line\">65</span><br><span class=\"line\">66</span><br><span class=\"line\">67</span><br><span class=\"line\">68</span><br><span class=\"line\">69</span><br><span class=\"line\">70</span><br><span class=\"line\">71</span><br><span class=\"line\">72</span><br><span class=\"line\">73</span><br><span class=\"line\">74</span><br><span class=\"line\">75</span><br><span class=\"line\">76</span><br><span class=\"line\">77</span><br><span class=\"line\">78</span><br><span class=\"line\">79</span><br><span class=\"line\">80</span><br><span class=\"line\">81</span><br><span class=\"line\">82</span><br><span class=\"line\">83</span><br><span class=\"line\">84</span><br><span class=\"line\">85</span><br><span class=\"line\">86</span><br><span class=\"line\">87</span><br><span class=\"line\">88</span><br><span class=\"line\">89</span><br><span class=\"line\">90</span><br><span class=\"line\">91</span><br><span class=\"line\">92</span><br><span class=\"line\">93</span><br><span class=\"line\">94</span><br><span class=\"line\">95</span><br><span class=\"line\">96</span><br><span class=\"line\">97</span><br><span class=\"line\">98</span><br><span class=\"line\">99</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">DATA SEGMENT</span><br><span class=\"line\">    DATAX DB 6      _; 带符号字节数据，负数_</span><br><span class=\"line\">    DATAY DB -2      _; 带符号字节数据，正数_</span><br><span class=\"line\">    RESULT DB 0</span><br><span class=\"line\">    BUF DB 4 DUP(?)</span><br><span class=\"line\">DATA ENDS</span><br><span class=\"line\"></span><br><span class=\"line\">CSEG SEGMENT</span><br><span class=\"line\">    ASSUME CS:CSEG,DS:DATA</span><br><span class=\"line\">START:</span><br><span class=\"line\">      MOV AX,DATA</span><br><span class=\"line\">      MOV DS,AX</span><br><span class=\"line\"></span><br><span class=\"line\">      _;从键盘接收+,-,*,/_</span><br><span class=\"line\">      MOV AH,1</span><br><span class=\"line\">      INT 21H</span><br><span class=\"line\"></span><br><span class=\"line\">      CMP AL,&#x27;+&#x27;</span><br><span class=\"line\">      JE ADD_OP</span><br><span class=\"line\">      CMP AL,&#x27;-&#x27;</span><br><span class=\"line\">      JE SUB_OP</span><br><span class=\"line\">      CMP AL,&#x27;*&#x27;</span><br><span class=\"line\">      JE MUL_OP</span><br><span class=\"line\">      CMP AL,&#x27;/&#x27;</span><br><span class=\"line\">      JE DIV_OP</span><br><span class=\"line\"></span><br><span class=\"line\">ADD_OP:</span><br><span class=\"line\">      MOV AL,DATAX</span><br><span class=\"line\">      MOV BL,DATAY</span><br><span class=\"line\">      ADD AL,BL</span><br><span class=\"line\">      MOV RESULT,AL</span><br><span class=\"line\">      JMP SHOW_RESULT  </span><br><span class=\"line\">  </span><br><span class=\"line\">SUB_OP:</span><br><span class=\"line\">      MOV AL,DATAX</span><br><span class=\"line\">      MOV BL,DATAY</span><br><span class=\"line\">      SUB AL,BL</span><br><span class=\"line\">      MOV RESULT,AL</span><br><span class=\"line\">      JMP SHOW_RESULT  </span><br><span class=\"line\"></span><br><span class=\"line\">MUL_OP:</span><br><span class=\"line\">_; 字节乘法： _</span><br><span class=\"line\">_; （AL）*（OPS8）→AX_</span><br><span class=\"line\">      MOV AL,DATAX</span><br><span class=\"line\">      MOV BL,DATAY</span><br><span class=\"line\">      IMUL BL</span><br><span class=\"line\">      MOV RESULT,AL</span><br><span class=\"line\">      JMP SHOW_RESULT  </span><br><span class=\"line\"></span><br><span class=\"line\">DIV_OP:</span><br><span class=\"line\">      MOV AL,DATAX</span><br><span class=\"line\">      MOV BL,DATAY</span><br><span class=\"line\">      CBW _;将AL符号扩展到AX_</span><br><span class=\"line\">      IDIV BL</span><br><span class=\"line\">      MOV RESULT,AL</span><br><span class=\"line\">      JMP SHOW_RESULT  </span><br><span class=\"line\"></span><br><span class=\"line\">_;难点在打印,将每次除以10,把余数入栈,然后出栈,打印_</span><br><span class=\"line\">SHOW_RESULT:</span><br><span class=\"line\">    MOV AL, RESULT</span><br><span class=\"line\">    CBW</span><br><span class=\"line\">    CMP AL, 0</span><br><span class=\"line\">    JGE SHOW</span><br><span class=\"line\">    PUSH AX           _; 保存原始AL_</span><br><span class=\"line\">    MOV DL, &#x27;-&#x27;</span><br><span class=\"line\">    MOV AH, 2</span><br><span class=\"line\">    INT 21H</span><br><span class=\"line\">    POP AX            _; 恢复AL_</span><br><span class=\"line\">    NEG AL</span><br><span class=\"line\">    CBW</span><br><span class=\"line\"></span><br><span class=\"line\">SHOW:</span><br><span class=\"line\">    MOV SI,0            _; SI为BUF索引_</span><br><span class=\"line\">    MOV BX,10</span><br><span class=\"line\"></span><br><span class=\"line\">CONV_LOOP:</span><br><span class=\"line\">    MOV DX,0</span><br><span class=\"line\">    DIV BX</span><br><span class=\"line\">    ADD DL,&#x27;0&#x27;</span><br><span class=\"line\">    MOV BUF[SI],DL</span><br><span class=\"line\">    INC SI</span><br><span class=\"line\">    CMP AX,0</span><br><span class=\"line\">    JNZ CONV_LOOP</span><br><span class=\"line\"></span><br><span class=\"line\">PRINT_LOOP:</span><br><span class=\"line\">    DEC SI</span><br><span class=\"line\">    MOV DL,BUF[SI]</span><br><span class=\"line\">    MOV AH,2</span><br><span class=\"line\">    INT 21H</span><br><span class=\"line\">    CMP SI,0</span><br><span class=\"line\">    JNZ PRINT_LOOP</span><br><span class=\"line\">    JMP EXIT</span><br><span class=\"line\"></span><br><span class=\"line\">EXIT:</span><br><span class=\"line\">      MOV AH,4CH</span><br><span class=\"line\">      INT 21H</span><br><span class=\"line\">  </span><br><span class=\"line\">CSEG ENDS</span><br><span class=\"line\">      END START</span><br></pre></td></tr></table></figure>\n\n<h2 id=\"程序逻辑流程图\"><a href=\"#程序逻辑流程图\" class=\"headerlink\" title=\"程序逻辑流程图\"></a>程序逻辑流程图</h2><p><img src=\"https://tk-pichost-1325224430.cos.ap-chengdu.myqcloud.com/blog/17478844701641747884469368.png\" alt=\"17478844701641747884469368.png\"></p>\n<blockquote>\n<h3 id=\"注意事项\"><a href=\"#注意事项\" class=\"headerlink\" title=\"注意事项\"></a>注意事项</h3></blockquote>\n<ul>\n<li>当 RESULT 为负数时,我在打印结果的时候我们需要先打印’-’号,INT 21H 会把 AL 的值重新设置</li>\n<li>使用 IDIV BX 命令前需要我们将 AX 使用 CBW 命令将 AL 扩展为 AX</li>\n</ul>\n<h2 id=\"进一步的修改\"><a href=\"#进一步的修改\" class=\"headerlink\" title=\"进一步的修改\"></a>进一步的修改</h2><figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br><span class=\"line\">47</span><br><span class=\"line\">48</span><br><span class=\"line\">49</span><br><span class=\"line\">50</span><br><span class=\"line\">51</span><br><span class=\"line\">52</span><br><span class=\"line\">53</span><br><span class=\"line\">54</span><br><span class=\"line\">55</span><br><span class=\"line\">56</span><br><span class=\"line\">57</span><br><span class=\"line\">58</span><br><span class=\"line\">59</span><br><span class=\"line\">60</span><br><span class=\"line\">61</span><br><span class=\"line\">62</span><br><span class=\"line\">63</span><br><span class=\"line\">64</span><br><span class=\"line\">65</span><br><span class=\"line\">66</span><br><span class=\"line\">67</span><br><span class=\"line\">68</span><br><span class=\"line\">69</span><br><span class=\"line\">70</span><br><span class=\"line\">71</span><br><span class=\"line\">72</span><br><span class=\"line\">73</span><br><span class=\"line\">74</span><br><span class=\"line\">75</span><br><span class=\"line\">76</span><br><span class=\"line\">77</span><br><span class=\"line\">78</span><br><span class=\"line\">79</span><br><span class=\"line\">80</span><br><span class=\"line\">81</span><br><span class=\"line\">82</span><br><span class=\"line\">83</span><br><span class=\"line\">84</span><br><span class=\"line\">85</span><br><span class=\"line\">86</span><br><span class=\"line\">87</span><br><span class=\"line\">88</span><br><span class=\"line\">89</span><br><span class=\"line\">90</span><br><span class=\"line\">91</span><br><span class=\"line\">92</span><br><span class=\"line\">93</span><br><span class=\"line\">94</span><br><span class=\"line\">95</span><br><span class=\"line\">96</span><br><span class=\"line\">97</span><br><span class=\"line\">98</span><br><span class=\"line\">99</span><br><span class=\"line\">100</span><br><span class=\"line\">101</span><br><span class=\"line\">102</span><br><span class=\"line\">103</span><br><span class=\"line\">104</span><br><span class=\"line\">105</span><br><span class=\"line\">106</span><br><span class=\"line\">107</span><br><span class=\"line\">108</span><br><span class=\"line\">109</span><br><span class=\"line\">110</span><br><span class=\"line\">111</span><br><span class=\"line\">112</span><br><span class=\"line\">113</span><br><span class=\"line\">114</span><br><span class=\"line\">115</span><br><span class=\"line\">116</span><br><span class=\"line\">117</span><br><span class=\"line\">118</span><br><span class=\"line\">119</span><br><span class=\"line\">120</span><br><span class=\"line\">121</span><br><span class=\"line\">122</span><br><span class=\"line\">123</span><br><span class=\"line\">124</span><br><span class=\"line\">125</span><br><span class=\"line\">126</span><br><span class=\"line\">127</span><br><span class=\"line\">128</span><br><span class=\"line\">129</span><br><span class=\"line\">130</span><br><span class=\"line\">131</span><br><span class=\"line\">132</span><br><span class=\"line\">133</span><br><span class=\"line\">134</span><br><span class=\"line\">135</span><br><span class=\"line\">136</span><br><span class=\"line\">137</span><br><span class=\"line\">138</span><br><span class=\"line\">139</span><br><span class=\"line\">140</span><br><span class=\"line\">141</span><br><span class=\"line\">142</span><br><span class=\"line\">143</span><br><span class=\"line\">144</span><br><span class=\"line\">145</span><br><span class=\"line\">146</span><br><span class=\"line\">147</span><br><span class=\"line\">148</span><br><span class=\"line\">149</span><br><span class=\"line\">150</span><br><span class=\"line\">151</span><br><span class=\"line\">152</span><br><span class=\"line\">153</span><br><span class=\"line\">154</span><br><span class=\"line\">155</span><br><span class=\"line\">156</span><br><span class=\"line\">157</span><br><span class=\"line\">158</span><br><span class=\"line\">159</span><br><span class=\"line\">160</span><br><span class=\"line\">161</span><br><span class=\"line\">162</span><br><span class=\"line\">163</span><br><span class=\"line\">164</span><br><span class=\"line\">165</span><br><span class=\"line\">166</span><br><span class=\"line\">167</span><br><span class=\"line\">168</span><br><span class=\"line\">169</span><br><span class=\"line\">170</span><br><span class=\"line\">171</span><br><span class=\"line\">172</span><br><span class=\"line\">173</span><br><span class=\"line\">174</span><br><span class=\"line\">175</span><br><span class=\"line\">176</span><br><span class=\"line\">177</span><br><span class=\"line\">178</span><br><span class=\"line\">179</span><br><span class=\"line\">180</span><br><span class=\"line\">181</span><br><span class=\"line\">182</span><br><span class=\"line\">183</span><br><span class=\"line\">184</span><br><span class=\"line\">185</span><br><span class=\"line\">186</span><br><span class=\"line\">187</span><br><span class=\"line\">188</span><br><span class=\"line\">189</span><br><span class=\"line\">190</span><br><span class=\"line\">191</span><br><span class=\"line\">192</span><br><span class=\"line\">193</span><br><span class=\"line\">194</span><br><span class=\"line\">195</span><br><span class=\"line\">196</span><br><span class=\"line\">197</span><br><span class=\"line\">198</span><br><span class=\"line\">199</span><br><span class=\"line\">200</span><br><span class=\"line\">201</span><br><span class=\"line\">202</span><br><span class=\"line\">203</span><br><span class=\"line\">204</span><br><span class=\"line\">205</span><br><span class=\"line\">206</span><br><span class=\"line\">207</span><br><span class=\"line\">208</span><br><span class=\"line\">209</span><br><span class=\"line\">210</span><br><span class=\"line\">211</span><br><span class=\"line\">212</span><br><span class=\"line\">213</span><br><span class=\"line\">214</span><br><span class=\"line\">215</span><br><span class=\"line\">216</span><br><span class=\"line\">217</span><br><span class=\"line\">218</span><br><span class=\"line\">219</span><br><span class=\"line\">220</span><br><span class=\"line\">221</span><br><span class=\"line\">222</span><br><span class=\"line\">223</span><br><span class=\"line\">224</span><br><span class=\"line\">225</span><br><span class=\"line\">226</span><br><span class=\"line\">227</span><br><span class=\"line\">228</span><br><span class=\"line\">229</span><br><span class=\"line\">230</span><br><span class=\"line\">231</span><br><span class=\"line\">232</span><br><span class=\"line\">233</span><br><span class=\"line\">234</span><br><span class=\"line\">235</span><br><span class=\"line\">236</span><br><span class=\"line\">237</span><br><span class=\"line\">238</span><br><span class=\"line\">239</span><br><span class=\"line\">240</span><br><span class=\"line\">241</span><br><span class=\"line\">242</span><br><span class=\"line\">243</span><br><span class=\"line\">244</span><br><span class=\"line\">245</span><br><span class=\"line\">246</span><br><span class=\"line\">247</span><br><span class=\"line\">248</span><br><span class=\"line\">249</span><br><span class=\"line\">250</span><br><span class=\"line\">251</span><br><span class=\"line\">252</span><br><span class=\"line\">253</span><br><span class=\"line\">254</span><br><span class=\"line\">255</span><br><span class=\"line\">256</span><br><span class=\"line\">257</span><br><span class=\"line\">258</span><br><span class=\"line\">259</span><br><span class=\"line\">260</span><br><span class=\"line\">261</span><br><span class=\"line\">262</span><br><span class=\"line\">263</span><br><span class=\"line\">264</span><br><span class=\"line\">265</span><br><span class=\"line\">266</span><br><span class=\"line\">267</span><br><span class=\"line\">268</span><br><span class=\"line\">269</span><br><span class=\"line\">270</span><br><span class=\"line\">271</span><br><span class=\"line\">272</span><br><span class=\"line\">273</span><br><span class=\"line\">274</span><br><span class=\"line\">275</span><br><span class=\"line\">276</span><br><span class=\"line\">277</span><br><span class=\"line\">278</span><br><span class=\"line\">279</span><br><span class=\"line\">280</span><br><span class=\"line\">281</span><br><span class=\"line\">282</span><br><span class=\"line\">283</span><br><span class=\"line\">284</span><br><span class=\"line\">285</span><br><span class=\"line\">286</span><br><span class=\"line\">287</span><br><span class=\"line\">288</span><br><span class=\"line\">289</span><br><span class=\"line\">290</span><br><span class=\"line\">291</span><br><span class=\"line\">292</span><br><span class=\"line\">293</span><br><span class=\"line\">294</span><br><span class=\"line\">295</span><br><span class=\"line\">296</span><br><span class=\"line\">297</span><br><span class=\"line\">298</span><br><span class=\"line\">299</span><br><span class=\"line\">300</span><br><span class=\"line\">301</span><br><span class=\"line\">302</span><br><span class=\"line\">303</span><br><span class=\"line\">304</span><br><span class=\"line\">305</span><br><span class=\"line\">306</span><br><span class=\"line\">307</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">_; 简单计算器程序 - 对DATAX和DATAY中的有符号字节数据进行四则运算_</span><br><span class=\"line\">_; 支持加(+)、减(-)、乘(*)、除(/)四种运算符_</span><br><span class=\"line\"></span><br><span class=\"line\">.MODEL SMALL</span><br><span class=\"line\">.STACK 100H</span><br><span class=\"line\"></span><br><span class=\"line\">.DATA</span><br><span class=\"line\">DATAX   DB  ?           _; 第一个操作数_</span><br><span class=\"line\">DATAY   DB  ?           _; 第二个操作数_</span><br><span class=\"line\">MSG1    DB  &#x27;Input first number: $&#x27;</span><br><span class=\"line\">MSG2    DB  0DH, 0AH, &#x27;Input second number: $&#x27;</span><br><span class=\"line\">MSG3    DB  0DH, 0AH, &#x27;Input operator (+, -, *, /): $&#x27;</span><br><span class=\"line\">MSG4    DB  0DH, 0AH, &#x27;Result: $&#x27;</span><br><span class=\"line\">MSG5    DB  0DH, 0AH, &#x27;Division by zero! $&#x27;</span><br><span class=\"line\">TEMP    DW  ?           _; 临时存储乘法或除法结果_</span><br><span class=\"line\">NEG_FLAG DB  0           _; 负数标志 (1表示结果为负)_</span><br><span class=\"line\">BUF     DB  6 DUP(?)    _; 用于存储结果字符串_</span><br><span class=\"line\">NEG_INPUT DB 0          _; 输入负号标志_</span><br><span class=\"line\">VALUE     DB 0          _; 输入值_</span><br><span class=\"line\"></span><br><span class=\"line\">.CODE</span><br><span class=\"line\">MAIN PROC</span><br><span class=\"line\">    MOV AX, @DATA       _; 初始化数据段_</span><br><span class=\"line\">    MOV DS, AX</span><br><span class=\"line\"></span><br><span class=\"line\">    _; 显示第一条提示消息_</span><br><span class=\"line\">    LEA DX, MSG1</span><br><span class=\"line\">    MOV AH, 09H</span><br><span class=\"line\">    INT 21H</span><br><span class=\"line\"></span><br><span class=\"line\">    _; 输入第一个数字_</span><br><span class=\"line\">    CALL INPUT_SIGNED_BYTE</span><br><span class=\"line\">    MOV DATAX, AL</span><br><span class=\"line\"></span><br><span class=\"line\">    _; 显示第二条提示消息_</span><br><span class=\"line\">    LEA DX, MSG2</span><br><span class=\"line\">    MOV AH, 09H</span><br><span class=\"line\">    INT 21H</span><br><span class=\"line\"></span><br><span class=\"line\">    _; 输入第二个数字_</span><br><span class=\"line\">    CALL INPUT_SIGNED_BYTE</span><br><span class=\"line\">    MOV DATAY, AL</span><br><span class=\"line\"></span><br><span class=\"line\">    _; 显示操作符提示消息_</span><br><span class=\"line\">    LEA DX, MSG3</span><br><span class=\"line\">    MOV AH, 09H</span><br><span class=\"line\">    INT 21H</span><br><span class=\"line\"></span><br><span class=\"line\">    _; 输入操作符_</span><br><span class=\"line\">    MOV AH, 01H</span><br><span class=\"line\">    INT 21H</span><br><span class=\"line\">    MOV BL, AL          _; 保存操作符在BL中_</span><br><span class=\"line\"></span><br><span class=\"line\">    _; 显示结果提示消息_</span><br><span class=\"line\">    LEA DX, MSG4</span><br><span class=\"line\">    MOV AH, 09H</span><br><span class=\"line\">    INT 21H</span><br><span class=\"line\"></span><br><span class=\"line\">    _; 根据操作符执行相应运算_</span><br><span class=\"line\">    CMP BL, &#x27;+&#x27;         _; 检查是否为加法_</span><br><span class=\"line\">    JE  DO_ADD</span><br><span class=\"line\">    CMP BL, &#x27;-&#x27;         _; 检查是否为减法_</span><br><span class=\"line\">    JE  DO_SUB</span><br><span class=\"line\">    CMP BL, &#x27;*&#x27;         _; 检查是否为乘法_</span><br><span class=\"line\">    JE  DO_MUL</span><br><span class=\"line\">    CMP BL, &#x27;/&#x27;         _; 检查是否为除法_</span><br><span class=\"line\">    JE  DO_DIV</span><br><span class=\"line\">    JMP EXIT            _; 如果不是有效操作符，直接退出_</span><br><span class=\"line\"></span><br><span class=\"line\">DO_ADD:</span><br><span class=\"line\">    MOV AL, DATAX       _; 加法运算_</span><br><span class=\"line\">    ADD AL, DATAY</span><br><span class=\"line\">    JMP DISPLAY_RESULT</span><br><span class=\"line\"></span><br><span class=\"line\">DO_SUB:</span><br><span class=\"line\">    MOV AL, DATAX       _; 减法运算_</span><br><span class=\"line\">    SUB AL, DATAY</span><br><span class=\"line\">    JMP DISPLAY_RESULT</span><br><span class=\"line\"></span><br><span class=\"line\">DO_MUL:</span><br><span class=\"line\">    MOV AL, DATAX       _; 乘法运算_</span><br><span class=\"line\">    MOV BL, DATAY</span><br><span class=\"line\">    CALL SIGNED_MUL</span><br><span class=\"line\">    JMP DISPLAY_AX</span><br><span class=\"line\"></span><br><span class=\"line\">DO_DIV:</span><br><span class=\"line\">    MOV AL, DATAX       _; 除法运算_</span><br><span class=\"line\">    MOV BL, DATAY</span><br><span class=\"line\">    CALL SIGNED_DIV</span><br><span class=\"line\">    JMP DISPLAY_AX</span><br><span class=\"line\"></span><br><span class=\"line\">DISPLAY_RESULT:</span><br><span class=\"line\">    _; 结果在AL中，转换为字符串并显示_</span><br><span class=\"line\">    MOV AH, 0           _; 清零AH，结果扩展到AX_</span><br><span class=\"line\">    CMP AL, 0</span><br><span class=\"line\">    JGE POSITIVE</span><br><span class=\"line\">    NEG AL              _; 如果为负，取绝对值_</span><br><span class=\"line\">    MOV NEG_FLAG, 1     _; 设置负数标志_</span><br><span class=\"line\">    JMP CONTINUE</span><br><span class=\"line\">POSITIVE:</span><br><span class=\"line\">    MOV NEG_FLAG, 0     _; 清除负数标志_</span><br><span class=\"line\">CONTINUE:</span><br><span class=\"line\">    MOV AX, AX          _; AX中现在是结果的绝对值_</span><br><span class=\"line\"></span><br><span class=\"line\">DISPLAY_AX:</span><br><span class=\"line\">    _; 显示AX中的有符号结果_</span><br><span class=\"line\">    CALL DISPLAY_SIGNED_NUM</span><br><span class=\"line\">  </span><br><span class=\"line\">EXIT:</span><br><span class=\"line\">    _; 程序结束_</span><br><span class=\"line\">    MOV AH, 4CH</span><br><span class=\"line\">    INT 21H</span><br><span class=\"line\">MAIN ENDP</span><br><span class=\"line\"></span><br><span class=\"line\">_; 输入有符号字节的过程_</span><br><span class=\"line\">INPUT_SIGNED_BYTE PROC</span><br><span class=\"line\">    _; 检查第一个字符是否为负号_</span><br><span class=\"line\">    MOV AH, 01H</span><br><span class=\"line\">    INT 21H</span><br><span class=\"line\">    CMP AL, &#x27;-&#x27;</span><br><span class=\"line\">    JNE CHECK_DIGIT1</span><br><span class=\"line\">    MOV NEG_INPUT, 1    _; 设置负号标志_</span><br><span class=\"line\">    MOV AH, 01H         _; 再次读取一个字符_</span><br><span class=\"line\">    INT 21H</span><br><span class=\"line\">  </span><br><span class=\"line\">CHECK_DIGIT1:</span><br><span class=\"line\">    _; 检查输入字符是否为数字_</span><br><span class=\"line\">    CMP AL, &#x27;0&#x27;</span><br><span class=\"line\">    JL EXIT_INPUT       _; 如果小于&#x27;0&#x27;，不是数字_</span><br><span class=\"line\">    CMP AL, &#x27;9&#x27;</span><br><span class=\"line\">    JG EXIT_INPUT       _; 如果大于&#x27;9&#x27;，不是数字_</span><br><span class=\"line\">  </span><br><span class=\"line\">    _; 转换为数值并保存_</span><br><span class=\"line\">    SUB AL, &#x27;0&#x27;</span><br><span class=\"line\">    MOV VALUE, AL</span><br><span class=\"line\">  </span><br><span class=\"line\">    _; 读取可能存在的第二个数字_</span><br><span class=\"line\">    MOV AH, 01H</span><br><span class=\"line\">    INT 21H</span><br><span class=\"line\">  </span><br><span class=\"line\">    _; 检查第二个字符是否为数字_</span><br><span class=\"line\">    CMP AL, &#x27;0&#x27;</span><br><span class=\"line\">    JL EXIT_INPUT2      _; 如果小于&#x27;0&#x27;，不是数字_</span><br><span class=\"line\">    CMP AL, &#x27;9&#x27;</span><br><span class=\"line\">    JG EXIT_INPUT2      _; 如果大于&#x27;9&#x27;，不是数字_</span><br><span class=\"line\">  </span><br><span class=\"line\">    _; 处理第二个数字_</span><br><span class=\"line\">    SUB AL, &#x27;0&#x27;</span><br><span class=\"line\">    MOV BL, VALUE       _; 将第一个数字移到BL_</span><br><span class=\"line\">    MOV BH, 0           _; 清零BH_</span><br><span class=\"line\">    MOV CX, 10</span><br><span class=\"line\">    MUL CX              _; 将BX乘以10_</span><br><span class=\"line\">    ADD BL, AL          _; 加上第二个数字_</span><br><span class=\"line\">    MOV VALUE, BL</span><br><span class=\"line\">    JMP EXIT_INPUT</span><br><span class=\"line\">  </span><br><span class=\"line\">EXIT_INPUT2:</span><br><span class=\"line\">    _; 如果第二个字符不是数字，将它放回缓冲区(模拟未读取)_</span><br><span class=\"line\">    MOV DL, AL</span><br><span class=\"line\">    MOV AH, 02H</span><br><span class=\"line\">    INT 21H</span><br><span class=\"line\">  </span><br><span class=\"line\">EXIT_INPUT:</span><br><span class=\"line\">    _; 返回结果_</span><br><span class=\"line\">    MOV AL, VALUE</span><br><span class=\"line\">    CMP NEG_INPUT, 1</span><br><span class=\"line\">    JNE RETURN_INPUT</span><br><span class=\"line\">    NEG AL              _; 如果有负号标志，取负值_</span><br><span class=\"line\">  </span><br><span class=\"line\">RETURN_INPUT:</span><br><span class=\"line\">    RET</span><br><span class=\"line\">INPUT_SIGNED_BYTE ENDP</span><br><span class=\"line\"></span><br><span class=\"line\">_; 有符号乘法过程 - 结果在AX中_</span><br><span class=\"line\">SIGNED_MUL PROC</span><br><span class=\"line\">    _; 保存符号_</span><br><span class=\"line\">    MOV CL, AL          _; 保存第一个操作数_</span><br><span class=\"line\">    MOV CH, BL          _; 保存第二个操作数_</span><br><span class=\"line\">  </span><br><span class=\"line\">    _; 取绝对值_</span><br><span class=\"line\">    CMP AL, 0</span><br><span class=\"line\">    JGE ABS1_DONE</span><br><span class=\"line\">    NEG AL</span><br><span class=\"line\">ABS1_DONE:</span><br><span class=\"line\">    CMP BL, 0</span><br><span class=\"line\">    JGE ABS2_DONE</span><br><span class=\"line\">    NEG BL</span><br><span class=\"line\">ABS2_DONE:</span><br><span class=\"line\">  </span><br><span class=\"line\">    _; 执行无符号乘法_</span><br><span class=\"line\">    MUL BL              _; AX = AL * BL_</span><br><span class=\"line\">  </span><br><span class=\"line\">    _; 确定结果符号_</span><br><span class=\"line\">    MOV BH, 0           _; 清零BH_</span><br><span class=\"line\">    MOV BL, 0           _; 假设结果为正_</span><br><span class=\"line\">  </span><br><span class=\"line\">    CMP CL, 0           _; 检查第一个操作数符号_</span><br><span class=\"line\">    JGE CHECK_OP2_MUL</span><br><span class=\"line\">    XOR BL, 1           _; 翻转符号位_</span><br><span class=\"line\">  </span><br><span class=\"line\">CHECK_OP2_MUL:</span><br><span class=\"line\">    CMP CH, 0           _; 检查第二个操作数符号_</span><br><span class=\"line\">    JGE APPLY_SIGN_MUL</span><br><span class=\"line\">    XOR BL, 1           _; 翻转符号位_</span><br><span class=\"line\">  </span><br><span class=\"line\">APPLY_SIGN_MUL:</span><br><span class=\"line\">    CMP BL, 1           _; 检查是否需要取负_</span><br><span class=\"line\">    JNE RETURN_MUL</span><br><span class=\"line\">    NEG AX              _; 对结果取负_</span><br><span class=\"line\">  </span><br><span class=\"line\">RETURN_MUL:</span><br><span class=\"line\">    RET</span><br><span class=\"line\">SIGNED_MUL ENDP</span><br><span class=\"line\"></span><br><span class=\"line\">_; 有符号除法过程 - 结果在AX中_</span><br><span class=\"line\">SIGNED_DIV PROC</span><br><span class=\"line\">    _; 检查除数是否为零_</span><br><span class=\"line\">    CMP BL, 0</span><br><span class=\"line\">    JNE NOT_ZERO_DIV</span><br><span class=\"line\">  </span><br><span class=\"line\">    _; 除数为零处理_</span><br><span class=\"line\">    LEA DX, MSG5        _; 显示除零错误消息_</span><br><span class=\"line\">    MOV AH, 09H</span><br><span class=\"line\">    INT 21H</span><br><span class=\"line\">    MOV AX, 0           _; 返回0_</span><br><span class=\"line\">    RET</span><br><span class=\"line\">  </span><br><span class=\"line\">NOT_ZERO_DIV:</span><br><span class=\"line\">    _; 保存符号_</span><br><span class=\"line\">    MOV CL, AL          _; 保存第一个操作数_</span><br><span class=\"line\">    MOV CH, BL          _; 保存第二个操作数_</span><br><span class=\"line\">  </span><br><span class=\"line\">    _; 取绝对值_</span><br><span class=\"line\">    CMP AL, 0</span><br><span class=\"line\">    JGE ABS1_DIV_DONE</span><br><span class=\"line\">    NEG AL</span><br><span class=\"line\">ABS1_DIV_DONE:</span><br><span class=\"line\">    CMP BL, 0</span><br><span class=\"line\">    JGE ABS2_DIV_DONE</span><br><span class=\"line\">    NEG BL</span><br><span class=\"line\">ABS2_DIV_DONE:</span><br><span class=\"line\">  </span><br><span class=\"line\">    _; 执行无符号除法_</span><br><span class=\"line\">    MOV AH, 0           _; 扩展AL到AX_</span><br><span class=\"line\">    DIV BL              _; AL = AX / BL, AH = AX % BL_</span><br><span class=\"line\">    MOV AH, 0           _; 清零AH(我们只关心商)_</span><br><span class=\"line\">  </span><br><span class=\"line\">    _; 确定结果符号_</span><br><span class=\"line\">    MOV BH, 0           _; 清零BH_</span><br><span class=\"line\">    MOV BL, 0           _; 假设结果为正_</span><br><span class=\"line\">  </span><br><span class=\"line\">    CMP CL, 0           _; 检查第一个操作数符号_</span><br><span class=\"line\">    JGE CHECK_OP2_DIV</span><br><span class=\"line\">    XOR BL, 1           _; 翻转符号位_</span><br><span class=\"line\">  </span><br><span class=\"line\">CHECK_OP2_DIV:</span><br><span class=\"line\">    CMP CH, 0           _; 检查第二个操作数符号_</span><br><span class=\"line\">    JGE APPLY_SIGN_DIV</span><br><span class=\"line\">    XOR BL, 1           _; 翻转符号位_</span><br><span class=\"line\">  </span><br><span class=\"line\">APPLY_SIGN_DIV:</span><br><span class=\"line\">    CMP BL, 1           _; 检查是否需要取负_</span><br><span class=\"line\">    JNE RETURN_DIV</span><br><span class=\"line\">    NEG AX              _; 对结果取负_</span><br><span class=\"line\">  </span><br><span class=\"line\">RETURN_DIV:</span><br><span class=\"line\">    RET</span><br><span class=\"line\">SIGNED_DIV ENDP</span><br><span class=\"line\"></span><br><span class=\"line\">_; 显示有符号数字_</span><br><span class=\"line\">DISPLAY_SIGNED_NUM PROC</span><br><span class=\"line\">    _; 检查符号_</span><br><span class=\"line\">    CMP AX, 0</span><br><span class=\"line\">    JGE POS_NUM</span><br><span class=\"line\">  </span><br><span class=\"line\">    _; 显示负号_</span><br><span class=\"line\">    MOV DL, &#x27;-&#x27;</span><br><span class=\"line\">    MOV AH, 02H</span><br><span class=\"line\">    INT 21H</span><br><span class=\"line\">    NEG AX              _; 取绝对值_</span><br><span class=\"line\">  </span><br><span class=\"line\">POS_NUM:</span><br><span class=\"line\">    _; 将数字转换为字符串并显示_</span><br><span class=\"line\">    MOV CX, 0           _; 初始化计数器_</span><br><span class=\"line\">    MOV BX, 10          _; 基数(十进制)_</span><br><span class=\"line\">  </span><br><span class=\"line\">    _; 将数字转换为字符串(逆序)_</span><br><span class=\"line\">CONVERT_LOOP:</span><br><span class=\"line\">    MOV DX, 0           _; 清零DX_</span><br><span class=\"line\">    DIV BX              _; AX / 10, 商在AX，余数在DX_</span><br><span class=\"line\">    PUSH DX             _; 保存余数_</span><br><span class=\"line\">    INC CX              _; 增加计数器_</span><br><span class=\"line\">    CMP AX, 0           _; 检查商是否为0_</span><br><span class=\"line\">    JNE CONVERT_LOOP    _; 如果不是0，继续转换_</span><br><span class=\"line\">  </span><br><span class=\"line\">    _; 显示字符串(正序)_</span><br><span class=\"line\">DISPLAY_LOOP:</span><br><span class=\"line\">    POP DX              _; 取出一个数字_</span><br><span class=\"line\">    ADD DL, &#x27;0&#x27;         _; 转换为ASCII_</span><br><span class=\"line\">    MOV AH, 02H         _; 显示字符功能_</span><br><span class=\"line\">    INT 21H</span><br><span class=\"line\">    LOOP DISPLAY_LOOP   _; 循环直到所有数字显示完毕_</span><br><span class=\"line\">  </span><br><span class=\"line\">    RET</span><br><span class=\"line\">DISPLAY_SIGNED_NUM ENDP</span><br><span class=\"line\"></span><br><span class=\"line\">END MAIN</span><br></pre></td></tr></table></figure>\n"},{"title":"2025-06-03-微信小程序开发框架详解","date":"2025-06-02T16:00:00.000Z","_content":"# 微信小程序开发框架详解\n\n# 参考资料\n\n> - [微信小程序技术原理分析 | 匠心博客](https://zhaomenghuan.js.org/blog/wechat-miniprogram-principle-analysis.html)\n> - [Everything You Would Like to Know About WeChat Mini Program](https://ianwith.github.io/2020/02/12/everything-you-would-like-to-know-about-wechat-mini-program/?utm_source=chatgpt.com)\n> - [developers.weixin.qq.com](https://developers.weixin.qq.com/miniprogram/dev/reference/)\n> - [GitHub - justjavac/awesome-wechat-weapp: 微信小程序开发资源汇总 ](https://github.com/justjavac/awesome-wechat-weapp?tab=readme-ov-file)\n\n# 概述\n\n互联网生态演进：超级 APP + 小程序成为「轻应用时代」下的新生态。\n\n![1749364131854QUV7bVLfOoZdmix4JoJcT4utnCb.png](https://gitee.com/tanke11223344/imagehost/raw/main/blog/1749364131854QUV7bVLfOoZdmix4JoJcT4utnCb.png)\n\n小程序方式构建应用是大趋势，被越来越多的企业用户看到其中的优势，构建一个跨多端平台的小程序开发平台是一种思路，帮助企业用户构建一个具备小程序能力的“移动门户”也是一种思路。本文主要调研微信小程序运行时的基本原理，从而构建一个适合我们自己平台的小程序运行框架。\n\n微信小程序开发可分为**官方原生框架（MINA）与多种第三方跨端开发框架**两大类。官方 MINA 框架提供了 WXML/WXSS/JS 三层模型，以及基于双线程的渲染与逻辑分离机制，适合对微信生态深度依赖的项目；第三方框架则通过封装、编译等手段让 Vue、React、Web 原生等技术栈在小程序中复用，覆盖从单一微信端到多端（小程序 +H5+App）的多种场景。\n在众多跨端方案中，**uni-app** 与 **Taro** 拥有最活跃的社区和最完善的生态，分别代表 Vue 与 React 技术栈；**Remax** 针对纯 React 而生，适合对 React 语法和生态依赖度极高的团队；**MPVue**、**WePY** 等 Vue 方案已逐步被 uni-app 或 Taro 取代；**Chameleon**、**kbone** 则聚焦于将 Web 应用“原封不动”移植到小程序。下面将从架构原理、技术栈、优缺点、适用场景及选型建议等方面，逐一详解主流框架。\n\n---\n\n## 官方原生框架：MINA\n\n微信团队自 2016 年推出的 **MINA**（Mobile Instant Application）是小程序的底层运行时与原生开发框架，核心特点包括：\n\n![1749364140851U8zbbm8B1onhwfxWR7Rc1X2Anvq.png](https://gitee.com/tanke11223344/imagehost/raw/main/blog/1749364140851U8zbbm8B1onhwfxWR7Rc1X2Anvq.png)\n\n- **双线程模型**：渲染与逻辑各自运行在 WebView 线程和 JsCore 线程，数据同步通过 IPC 方式完成，显著提升 UI 响应。\n- **四文件结构**：每个小程序由 `app.json`（全局配置）、`app.js`（应用逻辑）、`app.wxss`（全局样式）及若干对应 `*.wxml`/`*.js`/`*.wxss` 的页面文件组成。\n- **原生 API 丰富**：提供扫码、支付、位置、媒体、网络等数百种接口，适合深度依赖微信生态、追求性能和稳定性的项目。\n- **数据绑定与事件**：简化视图层与逻辑层交互，开发者可快速上手。\n\n**优点**：官方支持、性能最优、API 齐全\n**缺点**：仅限微信端、不支持跨端复用\n\n---\n\n## 跨端开发框架对比\n\n主流跨端框架可按技术栈分为 **Vue 系** 与 **React 系**，并包含 Web 应用迁移方案。\n\n| **框架**      | **技术栈**     | **多端支持**                     | **社区活跃度**   | **状态**  |\n| ------------------- | -------------------- | -------------------------------------- | ---------------------- | --------------- |\n| **uni-app**   | Vue                  | 微信/支付宝/百度/字节/QQ/快应用/H5/APP | ⭐⭐⭐⭐ (36.5k Stars) | 维护中          |\n| **Taro**      | React                | 微信/支付宝/百度/字节/QQ/快应用/H5/RN  | ⭐⭐⭐⭐ (31k Stars)   | 维护中          |\n| **Remax**     | React                | 微信/支付宝/百度等小程序               | ⭐⭐⭐ (4.3k Stars)    | 维护中          |\n| **MPVue**     | Vue                  | 微信/百度等小程序                      | ⭐⭐⭐ (20k Stars)     | 停止维护        |\n| **WePY**      | Vue                  | 微信小程序                             | ⭐ (少量维护)          | alpha, 更新缓慢 |\n| **Chameleon** | Vue/React/小程序原生 | 微信/支付宝/百度/抖音/快应用           | ⭐⭐                   | 维护中          |\n| **kbone**     | Web                  | 将任意 Web 应用\"原样\"编译到微信小程序  | ⭐⭐                   | 维护中          |\n\n> 数据来源：CSDN、GitHub、社区活跃度对比\n\n### uni-app\n\n> - [uni-app 官网](https://zh.uniapp.dcloud.io/resource.html)\n> - HBuilderX：[官方 IDE 下载地址](https://www.dcloud.io/hbuilderx.html)\n\n![1749364151852KAz5bUGAtoOAQ6xv5FscdRFTnph.png](https://gitee.com/tanke11223344/imagehost/raw/main/blog/1749364151852KAz5bUGAtoOAQ6xv5FscdRFTnph.png)\n\n- **核心**：使用 Vue 语法、单文件组件（`.vue`），通过 HBuilderX 或 CLI 编译到多端。\n- **优势**：\n\n  - 真正“一套代码，多端运行” ；\n  - 丰富插件与 UI 库（如 uView、Vant Weapp）；\n  - 社区活跃，文档完善。\n- **劣势**：运行时体积相对较大、对 Vue 特性支持需关注版本兼容。\n\n### Taro\n\n> - [Taro 介绍 | Taro 文档](https://docs.taro.zone/docs/)\n> - [github.com](https://github.com/NervJS/taro)\n> - [Taro | 多端统一开发解决方案](https://taro.zone/)\n\n- **核心**：使用 React/JSX 语法，多端编译，支持 React Hooks、TypeScript。\n- **优势**：\n\n  - React 团队更易上手，编译速度快 ；\n  - 支持多端：小程序、H5、React Native。\n- **劣势**：\n\n  - 部分原生小程序能力需插件或手动配置；\n  - 轻度偏离纯 React 生态，对兼容性需关注。\n\n### Remax\n\n- **核心**：由阿里团队开发，几乎不封装 React API，保持与 React Web 最大一致性 。\n- **优势**：\n\n  - 纯 React 生态，组件迁移成本最低；\n  - 支持 TypeScript。\n- **劣势**：\n\n  - 功能覆盖不如 Taro 全面；\n  - 社区相对小。\n\n### MPVue & WePY\n\n> - [使用手册 | mpvue.com](http://mpvue.com/mpvue/#-html)\n\n- **MPVue**：Vue 2.x 驱动，早期多端方案，已停止维护。\n- **WePY**：官方第一代组件化框架，alpha 长期无更新，社区废弃度高。\n\n### Chameleon\n\n- **特点**：阿里开源，统一多端 API，组件可复用，支持多种端（微信/支付宝/字节/IOS/Android）。\n- **关注点**：学习曲线、社区活跃度一般。\n\n### kbone\n\n- **特点**：Web 应用快速迁移，模拟 WebView 环境，支持 DOM/BOM，可“零改造”接入热门前端库（Vue/React）。\n- **使用场景**：已有成熟 Web 产品，希望快速在微信内复用。\n\n---\n\n## UI 组件库推荐\n\n- **WeUI**（官方）\n- **Vant Weapp**（有赞）\n- **Wux Weapp**\n- **Color UI**（轻量视觉）\n\n---\n\n## 选型建议\n\n1. **单微信小程序、无跨端需求** → 推荐使用 **原生 MINA**，直接调用官方 API。\n2. **Vue 团队、多端（含 App/H5）** → **uni-app** 最佳；\n3. **React 团队、多端（含 RN/H5）** → **Taro** 或 **Remax**；\n4. **已有 Web 应用** → **kbone** 零改造迁移；\n5. **轻量化需求** → 可选 **Chameleon**；\n6. **老项目、需维护** → Vue 生态可留用 **MPVue**；React 生态留用 **Remax**。\n","source":"_posts/2025-06-03-微信小程序开发框架详解.md","raw":"---\ntitle:  2025-06-03-微信小程序开发框架详解\ndate: 2025-06-03\ntags: \n    课程学习\n---\n# 微信小程序开发框架详解\n\n# 参考资料\n\n> - [微信小程序技术原理分析 | 匠心博客](https://zhaomenghuan.js.org/blog/wechat-miniprogram-principle-analysis.html)\n> - [Everything You Would Like to Know About WeChat Mini Program](https://ianwith.github.io/2020/02/12/everything-you-would-like-to-know-about-wechat-mini-program/?utm_source=chatgpt.com)\n> - [developers.weixin.qq.com](https://developers.weixin.qq.com/miniprogram/dev/reference/)\n> - [GitHub - justjavac/awesome-wechat-weapp: 微信小程序开发资源汇总 ](https://github.com/justjavac/awesome-wechat-weapp?tab=readme-ov-file)\n\n# 概述\n\n互联网生态演进：超级 APP + 小程序成为「轻应用时代」下的新生态。\n\n![1749364131854QUV7bVLfOoZdmix4JoJcT4utnCb.png](https://gitee.com/tanke11223344/imagehost/raw/main/blog/1749364131854QUV7bVLfOoZdmix4JoJcT4utnCb.png)\n\n小程序方式构建应用是大趋势，被越来越多的企业用户看到其中的优势，构建一个跨多端平台的小程序开发平台是一种思路，帮助企业用户构建一个具备小程序能力的“移动门户”也是一种思路。本文主要调研微信小程序运行时的基本原理，从而构建一个适合我们自己平台的小程序运行框架。\n\n微信小程序开发可分为**官方原生框架（MINA）与多种第三方跨端开发框架**两大类。官方 MINA 框架提供了 WXML/WXSS/JS 三层模型，以及基于双线程的渲染与逻辑分离机制，适合对微信生态深度依赖的项目；第三方框架则通过封装、编译等手段让 Vue、React、Web 原生等技术栈在小程序中复用，覆盖从单一微信端到多端（小程序 +H5+App）的多种场景。\n在众多跨端方案中，**uni-app** 与 **Taro** 拥有最活跃的社区和最完善的生态，分别代表 Vue 与 React 技术栈；**Remax** 针对纯 React 而生，适合对 React 语法和生态依赖度极高的团队；**MPVue**、**WePY** 等 Vue 方案已逐步被 uni-app 或 Taro 取代；**Chameleon**、**kbone** 则聚焦于将 Web 应用“原封不动”移植到小程序。下面将从架构原理、技术栈、优缺点、适用场景及选型建议等方面，逐一详解主流框架。\n\n---\n\n## 官方原生框架：MINA\n\n微信团队自 2016 年推出的 **MINA**（Mobile Instant Application）是小程序的底层运行时与原生开发框架，核心特点包括：\n\n![1749364140851U8zbbm8B1onhwfxWR7Rc1X2Anvq.png](https://gitee.com/tanke11223344/imagehost/raw/main/blog/1749364140851U8zbbm8B1onhwfxWR7Rc1X2Anvq.png)\n\n- **双线程模型**：渲染与逻辑各自运行在 WebView 线程和 JsCore 线程，数据同步通过 IPC 方式完成，显著提升 UI 响应。\n- **四文件结构**：每个小程序由 `app.json`（全局配置）、`app.js`（应用逻辑）、`app.wxss`（全局样式）及若干对应 `*.wxml`/`*.js`/`*.wxss` 的页面文件组成。\n- **原生 API 丰富**：提供扫码、支付、位置、媒体、网络等数百种接口，适合深度依赖微信生态、追求性能和稳定性的项目。\n- **数据绑定与事件**：简化视图层与逻辑层交互，开发者可快速上手。\n\n**优点**：官方支持、性能最优、API 齐全\n**缺点**：仅限微信端、不支持跨端复用\n\n---\n\n## 跨端开发框架对比\n\n主流跨端框架可按技术栈分为 **Vue 系** 与 **React 系**，并包含 Web 应用迁移方案。\n\n| **框架**      | **技术栈**     | **多端支持**                     | **社区活跃度**   | **状态**  |\n| ------------------- | -------------------- | -------------------------------------- | ---------------------- | --------------- |\n| **uni-app**   | Vue                  | 微信/支付宝/百度/字节/QQ/快应用/H5/APP | ⭐⭐⭐⭐ (36.5k Stars) | 维护中          |\n| **Taro**      | React                | 微信/支付宝/百度/字节/QQ/快应用/H5/RN  | ⭐⭐⭐⭐ (31k Stars)   | 维护中          |\n| **Remax**     | React                | 微信/支付宝/百度等小程序               | ⭐⭐⭐ (4.3k Stars)    | 维护中          |\n| **MPVue**     | Vue                  | 微信/百度等小程序                      | ⭐⭐⭐ (20k Stars)     | 停止维护        |\n| **WePY**      | Vue                  | 微信小程序                             | ⭐ (少量维护)          | alpha, 更新缓慢 |\n| **Chameleon** | Vue/React/小程序原生 | 微信/支付宝/百度/抖音/快应用           | ⭐⭐                   | 维护中          |\n| **kbone**     | Web                  | 将任意 Web 应用\"原样\"编译到微信小程序  | ⭐⭐                   | 维护中          |\n\n> 数据来源：CSDN、GitHub、社区活跃度对比\n\n### uni-app\n\n> - [uni-app 官网](https://zh.uniapp.dcloud.io/resource.html)\n> - HBuilderX：[官方 IDE 下载地址](https://www.dcloud.io/hbuilderx.html)\n\n![1749364151852KAz5bUGAtoOAQ6xv5FscdRFTnph.png](https://gitee.com/tanke11223344/imagehost/raw/main/blog/1749364151852KAz5bUGAtoOAQ6xv5FscdRFTnph.png)\n\n- **核心**：使用 Vue 语法、单文件组件（`.vue`），通过 HBuilderX 或 CLI 编译到多端。\n- **优势**：\n\n  - 真正“一套代码，多端运行” ；\n  - 丰富插件与 UI 库（如 uView、Vant Weapp）；\n  - 社区活跃，文档完善。\n- **劣势**：运行时体积相对较大、对 Vue 特性支持需关注版本兼容。\n\n### Taro\n\n> - [Taro 介绍 | Taro 文档](https://docs.taro.zone/docs/)\n> - [github.com](https://github.com/NervJS/taro)\n> - [Taro | 多端统一开发解决方案](https://taro.zone/)\n\n- **核心**：使用 React/JSX 语法，多端编译，支持 React Hooks、TypeScript。\n- **优势**：\n\n  - React 团队更易上手，编译速度快 ；\n  - 支持多端：小程序、H5、React Native。\n- **劣势**：\n\n  - 部分原生小程序能力需插件或手动配置；\n  - 轻度偏离纯 React 生态，对兼容性需关注。\n\n### Remax\n\n- **核心**：由阿里团队开发，几乎不封装 React API，保持与 React Web 最大一致性 。\n- **优势**：\n\n  - 纯 React 生态，组件迁移成本最低；\n  - 支持 TypeScript。\n- **劣势**：\n\n  - 功能覆盖不如 Taro 全面；\n  - 社区相对小。\n\n### MPVue & WePY\n\n> - [使用手册 | mpvue.com](http://mpvue.com/mpvue/#-html)\n\n- **MPVue**：Vue 2.x 驱动，早期多端方案，已停止维护。\n- **WePY**：官方第一代组件化框架，alpha 长期无更新，社区废弃度高。\n\n### Chameleon\n\n- **特点**：阿里开源，统一多端 API，组件可复用，支持多种端（微信/支付宝/字节/IOS/Android）。\n- **关注点**：学习曲线、社区活跃度一般。\n\n### kbone\n\n- **特点**：Web 应用快速迁移，模拟 WebView 环境，支持 DOM/BOM，可“零改造”接入热门前端库（Vue/React）。\n- **使用场景**：已有成熟 Web 产品，希望快速在微信内复用。\n\n---\n\n## UI 组件库推荐\n\n- **WeUI**（官方）\n- **Vant Weapp**（有赞）\n- **Wux Weapp**\n- **Color UI**（轻量视觉）\n\n---\n\n## 选型建议\n\n1. **单微信小程序、无跨端需求** → 推荐使用 **原生 MINA**，直接调用官方 API。\n2. **Vue 团队、多端（含 App/H5）** → **uni-app** 最佳；\n3. **React 团队、多端（含 RN/H5）** → **Taro** 或 **Remax**；\n4. **已有 Web 应用** → **kbone** 零改造迁移；\n5. **轻量化需求** → 可选 **Chameleon**；\n6. **老项目、需维护** → Vue 生态可留用 **MPVue**；React 生态留用 **Remax**。\n","slug":"2025-06-03-微信小程序开发框架详解","published":1,"updated":"2025-09-26T12:18:11.650Z","_id":"cmg0saj4e002jjm8n2u8c20bb","comments":1,"layout":"post","photos":[],"content":"<h1 id=\"微信小程序开发框架详解\"><a href=\"#微信小程序开发框架详解\" class=\"headerlink\" title=\"微信小程序开发框架详解\"></a>微信小程序开发框架详解</h1><h1 id=\"参考资料\"><a href=\"#参考资料\" class=\"headerlink\" title=\"参考资料\"></a>参考资料</h1><blockquote>\n<ul>\n<li><a href=\"https://zhaomenghuan.js.org/blog/wechat-miniprogram-principle-analysis.html\">微信小程序技术原理分析 | 匠心博客</a></li>\n<li><a href=\"https://ianwith.github.io/2020/02/12/everything-you-would-like-to-know-about-wechat-mini-program/?utm_source=chatgpt.com\">Everything You Would Like to Know About WeChat Mini Program</a></li>\n<li><a href=\"https://developers.weixin.qq.com/miniprogram/dev/reference/\">developers.weixin.qq.com</a></li>\n<li><a href=\"https://github.com/justjavac/awesome-wechat-weapp?tab=readme-ov-file\">GitHub - justjavac&#x2F;awesome-wechat-weapp: 微信小程序开发资源汇总 </a></li>\n</ul>\n</blockquote>\n<h1 id=\"概述\"><a href=\"#概述\" class=\"headerlink\" title=\"概述\"></a>概述</h1><p>互联网生态演进：超级 APP + 小程序成为「轻应用时代」下的新生态。</p>\n<p><img src=\"https://gitee.com/tanke11223344/imagehost/raw/main/blog/1749364131854QUV7bVLfOoZdmix4JoJcT4utnCb.png\" alt=\"1749364131854QUV7bVLfOoZdmix4JoJcT4utnCb.png\"></p>\n<p>小程序方式构建应用是大趋势，被越来越多的企业用户看到其中的优势，构建一个跨多端平台的小程序开发平台是一种思路，帮助企业用户构建一个具备小程序能力的“移动门户”也是一种思路。本文主要调研微信小程序运行时的基本原理，从而构建一个适合我们自己平台的小程序运行框架。</p>\n<p>微信小程序开发可分为<strong>官方原生框架（MINA）与多种第三方跨端开发框架</strong>两大类。官方 MINA 框架提供了 WXML&#x2F;WXSS&#x2F;JS 三层模型，以及基于双线程的渲染与逻辑分离机制，适合对微信生态深度依赖的项目；第三方框架则通过封装、编译等手段让 Vue、React、Web 原生等技术栈在小程序中复用，覆盖从单一微信端到多端（小程序 +H5+App）的多种场景。<br>在众多跨端方案中，<strong>uni-app</strong> 与 <strong>Taro</strong> 拥有最活跃的社区和最完善的生态，分别代表 Vue 与 React 技术栈；<strong>Remax</strong> 针对纯 React 而生，适合对 React 语法和生态依赖度极高的团队；<strong>MPVue</strong>、<strong>WePY</strong> 等 Vue 方案已逐步被 uni-app 或 Taro 取代；<strong>Chameleon</strong>、<strong>kbone</strong> 则聚焦于将 Web 应用“原封不动”移植到小程序。下面将从架构原理、技术栈、优缺点、适用场景及选型建议等方面，逐一详解主流框架。</p>\n<hr>\n<h2 id=\"官方原生框架：MINA\"><a href=\"#官方原生框架：MINA\" class=\"headerlink\" title=\"官方原生框架：MINA\"></a>官方原生框架：MINA</h2><p>微信团队自 2016 年推出的 <strong>MINA</strong>（Mobile Instant Application）是小程序的底层运行时与原生开发框架，核心特点包括：</p>\n<p><img src=\"https://gitee.com/tanke11223344/imagehost/raw/main/blog/1749364140851U8zbbm8B1onhwfxWR7Rc1X2Anvq.png\" alt=\"1749364140851U8zbbm8B1onhwfxWR7Rc1X2Anvq.png\"></p>\n<ul>\n<li><strong>双线程模型</strong>：渲染与逻辑各自运行在 WebView 线程和 JsCore 线程，数据同步通过 IPC 方式完成，显著提升 UI 响应。</li>\n<li><strong>四文件结构</strong>：每个小程序由 <code>app.json</code>（全局配置）、<code>app.js</code>（应用逻辑）、<code>app.wxss</code>（全局样式）及若干对应 <code>*.wxml</code>&#x2F;<code>*.js</code>&#x2F;<code>*.wxss</code> 的页面文件组成。</li>\n<li><strong>原生 API 丰富</strong>：提供扫码、支付、位置、媒体、网络等数百种接口，适合深度依赖微信生态、追求性能和稳定性的项目。</li>\n<li><strong>数据绑定与事件</strong>：简化视图层与逻辑层交互，开发者可快速上手。</li>\n</ul>\n<p><strong>优点</strong>：官方支持、性能最优、API 齐全<br><strong>缺点</strong>：仅限微信端、不支持跨端复用</p>\n<hr>\n<h2 id=\"跨端开发框架对比\"><a href=\"#跨端开发框架对比\" class=\"headerlink\" title=\"跨端开发框架对比\"></a>跨端开发框架对比</h2><p>主流跨端框架可按技术栈分为 <strong>Vue 系</strong> 与 <strong>React 系</strong>，并包含 Web 应用迁移方案。</p>\n<table>\n<thead>\n<tr>\n<th><strong>框架</strong></th>\n<th><strong>技术栈</strong></th>\n<th><strong>多端支持</strong></th>\n<th><strong>社区活跃度</strong></th>\n<th><strong>状态</strong></th>\n</tr>\n</thead>\n<tbody><tr>\n<td><strong>uni-app</strong></td>\n<td>Vue</td>\n<td>微信&#x2F;支付宝&#x2F;百度&#x2F;字节&#x2F;QQ&#x2F;快应用&#x2F;H5&#x2F;APP</td>\n<td>⭐⭐⭐⭐ (36.5k Stars)</td>\n<td>维护中</td>\n</tr>\n<tr>\n<td><strong>Taro</strong></td>\n<td>React</td>\n<td>微信&#x2F;支付宝&#x2F;百度&#x2F;字节&#x2F;QQ&#x2F;快应用&#x2F;H5&#x2F;RN</td>\n<td>⭐⭐⭐⭐ (31k Stars)</td>\n<td>维护中</td>\n</tr>\n<tr>\n<td><strong>Remax</strong></td>\n<td>React</td>\n<td>微信&#x2F;支付宝&#x2F;百度等小程序</td>\n<td>⭐⭐⭐ (4.3k Stars)</td>\n<td>维护中</td>\n</tr>\n<tr>\n<td><strong>MPVue</strong></td>\n<td>Vue</td>\n<td>微信&#x2F;百度等小程序</td>\n<td>⭐⭐⭐ (20k Stars)</td>\n<td>停止维护</td>\n</tr>\n<tr>\n<td><strong>WePY</strong></td>\n<td>Vue</td>\n<td>微信小程序</td>\n<td>⭐ (少量维护)</td>\n<td>alpha, 更新缓慢</td>\n</tr>\n<tr>\n<td><strong>Chameleon</strong></td>\n<td>Vue&#x2F;React&#x2F;小程序原生</td>\n<td>微信&#x2F;支付宝&#x2F;百度&#x2F;抖音&#x2F;快应用</td>\n<td>⭐⭐</td>\n<td>维护中</td>\n</tr>\n<tr>\n<td><strong>kbone</strong></td>\n<td>Web</td>\n<td>将任意 Web 应用”原样”编译到微信小程序</td>\n<td>⭐⭐</td>\n<td>维护中</td>\n</tr>\n</tbody></table>\n<blockquote>\n<p>数据来源：CSDN、GitHub、社区活跃度对比</p>\n</blockquote>\n<h3 id=\"uni-app\"><a href=\"#uni-app\" class=\"headerlink\" title=\"uni-app\"></a>uni-app</h3><blockquote>\n<ul>\n<li><a href=\"https://zh.uniapp.dcloud.io/resource.html\">uni-app 官网</a></li>\n<li>HBuilderX：<a href=\"https://www.dcloud.io/hbuilderx.html\">官方 IDE 下载地址</a></li>\n</ul>\n</blockquote>\n<p><img src=\"https://gitee.com/tanke11223344/imagehost/raw/main/blog/1749364151852KAz5bUGAtoOAQ6xv5FscdRFTnph.png\" alt=\"1749364151852KAz5bUGAtoOAQ6xv5FscdRFTnph.png\"></p>\n<ul>\n<li><p><strong>核心</strong>：使用 Vue 语法、单文件组件（<code>.vue</code>），通过 HBuilderX 或 CLI 编译到多端。</p>\n</li>\n<li><p><strong>优势</strong>：</p>\n<ul>\n<li>真正“一套代码，多端运行” ；</li>\n<li>丰富插件与 UI 库（如 uView、Vant Weapp）；</li>\n<li>社区活跃，文档完善。</li>\n</ul>\n</li>\n<li><p><strong>劣势</strong>：运行时体积相对较大、对 Vue 特性支持需关注版本兼容。</p>\n</li>\n</ul>\n<h3 id=\"Taro\"><a href=\"#Taro\" class=\"headerlink\" title=\"Taro\"></a>Taro</h3><blockquote>\n<ul>\n<li><a href=\"https://docs.taro.zone/docs/\">Taro 介绍 | Taro 文档</a></li>\n<li><a href=\"https://github.com/NervJS/taro\">github.com</a></li>\n<li><a href=\"https://taro.zone/\">Taro | 多端统一开发解决方案</a></li>\n</ul>\n</blockquote>\n<ul>\n<li><p><strong>核心</strong>：使用 React&#x2F;JSX 语法，多端编译，支持 React Hooks、TypeScript。</p>\n</li>\n<li><p><strong>优势</strong>：</p>\n<ul>\n<li>React 团队更易上手，编译速度快 ；</li>\n<li>支持多端：小程序、H5、React Native。</li>\n</ul>\n</li>\n<li><p><strong>劣势</strong>：</p>\n<ul>\n<li>部分原生小程序能力需插件或手动配置；</li>\n<li>轻度偏离纯 React 生态，对兼容性需关注。</li>\n</ul>\n</li>\n</ul>\n<h3 id=\"Remax\"><a href=\"#Remax\" class=\"headerlink\" title=\"Remax\"></a>Remax</h3><ul>\n<li><p><strong>核心</strong>：由阿里团队开发，几乎不封装 React API，保持与 React Web 最大一致性 。</p>\n</li>\n<li><p><strong>优势</strong>：</p>\n<ul>\n<li>纯 React 生态，组件迁移成本最低；</li>\n<li>支持 TypeScript。</li>\n</ul>\n</li>\n<li><p><strong>劣势</strong>：</p>\n<ul>\n<li>功能覆盖不如 Taro 全面；</li>\n<li>社区相对小。</li>\n</ul>\n</li>\n</ul>\n<h3 id=\"MPVue-WePY\"><a href=\"#MPVue-WePY\" class=\"headerlink\" title=\"MPVue &amp; WePY\"></a>MPVue &amp; WePY</h3><blockquote>\n<ul>\n<li><a href=\"http://mpvue.com/mpvue/#-html\">使用手册 | mpvue.com</a></li>\n</ul>\n</blockquote>\n<ul>\n<li><strong>MPVue</strong>：Vue 2.x 驱动，早期多端方案，已停止维护。</li>\n<li><strong>WePY</strong>：官方第一代组件化框架，alpha 长期无更新，社区废弃度高。</li>\n</ul>\n<h3 id=\"Chameleon\"><a href=\"#Chameleon\" class=\"headerlink\" title=\"Chameleon\"></a>Chameleon</h3><ul>\n<li><strong>特点</strong>：阿里开源，统一多端 API，组件可复用，支持多种端（微信&#x2F;支付宝&#x2F;字节&#x2F;IOS&#x2F;Android）。</li>\n<li><strong>关注点</strong>：学习曲线、社区活跃度一般。</li>\n</ul>\n<h3 id=\"kbone\"><a href=\"#kbone\" class=\"headerlink\" title=\"kbone\"></a>kbone</h3><ul>\n<li><strong>特点</strong>：Web 应用快速迁移，模拟 WebView 环境，支持 DOM&#x2F;BOM，可“零改造”接入热门前端库（Vue&#x2F;React）。</li>\n<li><strong>使用场景</strong>：已有成熟 Web 产品，希望快速在微信内复用。</li>\n</ul>\n<hr>\n<h2 id=\"UI-组件库推荐\"><a href=\"#UI-组件库推荐\" class=\"headerlink\" title=\"UI 组件库推荐\"></a>UI 组件库推荐</h2><ul>\n<li><strong>WeUI</strong>（官方）</li>\n<li><strong>Vant Weapp</strong>（有赞）</li>\n<li><strong>Wux Weapp</strong></li>\n<li><strong>Color UI</strong>（轻量视觉）</li>\n</ul>\n<hr>\n<h2 id=\"选型建议\"><a href=\"#选型建议\" class=\"headerlink\" title=\"选型建议\"></a>选型建议</h2><ol>\n<li><strong>单微信小程序、无跨端需求</strong> → 推荐使用 <strong>原生 MINA</strong>，直接调用官方 API。</li>\n<li><strong>Vue 团队、多端（含 App&#x2F;H5）</strong> → <strong>uni-app</strong> 最佳；</li>\n<li><strong>React 团队、多端（含 RN&#x2F;H5）</strong> → <strong>Taro</strong> 或 <strong>Remax</strong>；</li>\n<li><strong>已有 Web 应用</strong> → <strong>kbone</strong> 零改造迁移；</li>\n<li><strong>轻量化需求</strong> → 可选 <strong>Chameleon</strong>；</li>\n<li><strong>老项目、需维护</strong> → Vue 生态可留用 <strong>MPVue</strong>；React 生态留用 <strong>Remax</strong>。</li>\n</ol>\n","excerpt":"","more":"<h1 id=\"微信小程序开发框架详解\"><a href=\"#微信小程序开发框架详解\" class=\"headerlink\" title=\"微信小程序开发框架详解\"></a>微信小程序开发框架详解</h1><h1 id=\"参考资料\"><a href=\"#参考资料\" class=\"headerlink\" title=\"参考资料\"></a>参考资料</h1><blockquote>\n<ul>\n<li><a href=\"https://zhaomenghuan.js.org/blog/wechat-miniprogram-principle-analysis.html\">微信小程序技术原理分析 | 匠心博客</a></li>\n<li><a href=\"https://ianwith.github.io/2020/02/12/everything-you-would-like-to-know-about-wechat-mini-program/?utm_source=chatgpt.com\">Everything You Would Like to Know About WeChat Mini Program</a></li>\n<li><a href=\"https://developers.weixin.qq.com/miniprogram/dev/reference/\">developers.weixin.qq.com</a></li>\n<li><a href=\"https://github.com/justjavac/awesome-wechat-weapp?tab=readme-ov-file\">GitHub - justjavac&#x2F;awesome-wechat-weapp: 微信小程序开发资源汇总 </a></li>\n</ul>\n</blockquote>\n<h1 id=\"概述\"><a href=\"#概述\" class=\"headerlink\" title=\"概述\"></a>概述</h1><p>互联网生态演进：超级 APP + 小程序成为「轻应用时代」下的新生态。</p>\n<p><img src=\"https://gitee.com/tanke11223344/imagehost/raw/main/blog/1749364131854QUV7bVLfOoZdmix4JoJcT4utnCb.png\" alt=\"1749364131854QUV7bVLfOoZdmix4JoJcT4utnCb.png\"></p>\n<p>小程序方式构建应用是大趋势，被越来越多的企业用户看到其中的优势，构建一个跨多端平台的小程序开发平台是一种思路，帮助企业用户构建一个具备小程序能力的“移动门户”也是一种思路。本文主要调研微信小程序运行时的基本原理，从而构建一个适合我们自己平台的小程序运行框架。</p>\n<p>微信小程序开发可分为<strong>官方原生框架（MINA）与多种第三方跨端开发框架</strong>两大类。官方 MINA 框架提供了 WXML&#x2F;WXSS&#x2F;JS 三层模型，以及基于双线程的渲染与逻辑分离机制，适合对微信生态深度依赖的项目；第三方框架则通过封装、编译等手段让 Vue、React、Web 原生等技术栈在小程序中复用，覆盖从单一微信端到多端（小程序 +H5+App）的多种场景。<br>在众多跨端方案中，<strong>uni-app</strong> 与 <strong>Taro</strong> 拥有最活跃的社区和最完善的生态，分别代表 Vue 与 React 技术栈；<strong>Remax</strong> 针对纯 React 而生，适合对 React 语法和生态依赖度极高的团队；<strong>MPVue</strong>、<strong>WePY</strong> 等 Vue 方案已逐步被 uni-app 或 Taro 取代；<strong>Chameleon</strong>、<strong>kbone</strong> 则聚焦于将 Web 应用“原封不动”移植到小程序。下面将从架构原理、技术栈、优缺点、适用场景及选型建议等方面，逐一详解主流框架。</p>\n<hr>\n<h2 id=\"官方原生框架：MINA\"><a href=\"#官方原生框架：MINA\" class=\"headerlink\" title=\"官方原生框架：MINA\"></a>官方原生框架：MINA</h2><p>微信团队自 2016 年推出的 <strong>MINA</strong>（Mobile Instant Application）是小程序的底层运行时与原生开发框架，核心特点包括：</p>\n<p><img src=\"https://gitee.com/tanke11223344/imagehost/raw/main/blog/1749364140851U8zbbm8B1onhwfxWR7Rc1X2Anvq.png\" alt=\"1749364140851U8zbbm8B1onhwfxWR7Rc1X2Anvq.png\"></p>\n<ul>\n<li><strong>双线程模型</strong>：渲染与逻辑各自运行在 WebView 线程和 JsCore 线程，数据同步通过 IPC 方式完成，显著提升 UI 响应。</li>\n<li><strong>四文件结构</strong>：每个小程序由 <code>app.json</code>（全局配置）、<code>app.js</code>（应用逻辑）、<code>app.wxss</code>（全局样式）及若干对应 <code>*.wxml</code>&#x2F;<code>*.js</code>&#x2F;<code>*.wxss</code> 的页面文件组成。</li>\n<li><strong>原生 API 丰富</strong>：提供扫码、支付、位置、媒体、网络等数百种接口，适合深度依赖微信生态、追求性能和稳定性的项目。</li>\n<li><strong>数据绑定与事件</strong>：简化视图层与逻辑层交互，开发者可快速上手。</li>\n</ul>\n<p><strong>优点</strong>：官方支持、性能最优、API 齐全<br><strong>缺点</strong>：仅限微信端、不支持跨端复用</p>\n<hr>\n<h2 id=\"跨端开发框架对比\"><a href=\"#跨端开发框架对比\" class=\"headerlink\" title=\"跨端开发框架对比\"></a>跨端开发框架对比</h2><p>主流跨端框架可按技术栈分为 <strong>Vue 系</strong> 与 <strong>React 系</strong>，并包含 Web 应用迁移方案。</p>\n<table>\n<thead>\n<tr>\n<th><strong>框架</strong></th>\n<th><strong>技术栈</strong></th>\n<th><strong>多端支持</strong></th>\n<th><strong>社区活跃度</strong></th>\n<th><strong>状态</strong></th>\n</tr>\n</thead>\n<tbody><tr>\n<td><strong>uni-app</strong></td>\n<td>Vue</td>\n<td>微信&#x2F;支付宝&#x2F;百度&#x2F;字节&#x2F;QQ&#x2F;快应用&#x2F;H5&#x2F;APP</td>\n<td>⭐⭐⭐⭐ (36.5k Stars)</td>\n<td>维护中</td>\n</tr>\n<tr>\n<td><strong>Taro</strong></td>\n<td>React</td>\n<td>微信&#x2F;支付宝&#x2F;百度&#x2F;字节&#x2F;QQ&#x2F;快应用&#x2F;H5&#x2F;RN</td>\n<td>⭐⭐⭐⭐ (31k Stars)</td>\n<td>维护中</td>\n</tr>\n<tr>\n<td><strong>Remax</strong></td>\n<td>React</td>\n<td>微信&#x2F;支付宝&#x2F;百度等小程序</td>\n<td>⭐⭐⭐ (4.3k Stars)</td>\n<td>维护中</td>\n</tr>\n<tr>\n<td><strong>MPVue</strong></td>\n<td>Vue</td>\n<td>微信&#x2F;百度等小程序</td>\n<td>⭐⭐⭐ (20k Stars)</td>\n<td>停止维护</td>\n</tr>\n<tr>\n<td><strong>WePY</strong></td>\n<td>Vue</td>\n<td>微信小程序</td>\n<td>⭐ (少量维护)</td>\n<td>alpha, 更新缓慢</td>\n</tr>\n<tr>\n<td><strong>Chameleon</strong></td>\n<td>Vue&#x2F;React&#x2F;小程序原生</td>\n<td>微信&#x2F;支付宝&#x2F;百度&#x2F;抖音&#x2F;快应用</td>\n<td>⭐⭐</td>\n<td>维护中</td>\n</tr>\n<tr>\n<td><strong>kbone</strong></td>\n<td>Web</td>\n<td>将任意 Web 应用”原样”编译到微信小程序</td>\n<td>⭐⭐</td>\n<td>维护中</td>\n</tr>\n</tbody></table>\n<blockquote>\n<p>数据来源：CSDN、GitHub、社区活跃度对比</p>\n</blockquote>\n<h3 id=\"uni-app\"><a href=\"#uni-app\" class=\"headerlink\" title=\"uni-app\"></a>uni-app</h3><blockquote>\n<ul>\n<li><a href=\"https://zh.uniapp.dcloud.io/resource.html\">uni-app 官网</a></li>\n<li>HBuilderX：<a href=\"https://www.dcloud.io/hbuilderx.html\">官方 IDE 下载地址</a></li>\n</ul>\n</blockquote>\n<p><img src=\"https://gitee.com/tanke11223344/imagehost/raw/main/blog/1749364151852KAz5bUGAtoOAQ6xv5FscdRFTnph.png\" alt=\"1749364151852KAz5bUGAtoOAQ6xv5FscdRFTnph.png\"></p>\n<ul>\n<li><p><strong>核心</strong>：使用 Vue 语法、单文件组件（<code>.vue</code>），通过 HBuilderX 或 CLI 编译到多端。</p>\n</li>\n<li><p><strong>优势</strong>：</p>\n<ul>\n<li>真正“一套代码，多端运行” ；</li>\n<li>丰富插件与 UI 库（如 uView、Vant Weapp）；</li>\n<li>社区活跃，文档完善。</li>\n</ul>\n</li>\n<li><p><strong>劣势</strong>：运行时体积相对较大、对 Vue 特性支持需关注版本兼容。</p>\n</li>\n</ul>\n<h3 id=\"Taro\"><a href=\"#Taro\" class=\"headerlink\" title=\"Taro\"></a>Taro</h3><blockquote>\n<ul>\n<li><a href=\"https://docs.taro.zone/docs/\">Taro 介绍 | Taro 文档</a></li>\n<li><a href=\"https://github.com/NervJS/taro\">github.com</a></li>\n<li><a href=\"https://taro.zone/\">Taro | 多端统一开发解决方案</a></li>\n</ul>\n</blockquote>\n<ul>\n<li><p><strong>核心</strong>：使用 React&#x2F;JSX 语法，多端编译，支持 React Hooks、TypeScript。</p>\n</li>\n<li><p><strong>优势</strong>：</p>\n<ul>\n<li>React 团队更易上手，编译速度快 ；</li>\n<li>支持多端：小程序、H5、React Native。</li>\n</ul>\n</li>\n<li><p><strong>劣势</strong>：</p>\n<ul>\n<li>部分原生小程序能力需插件或手动配置；</li>\n<li>轻度偏离纯 React 生态，对兼容性需关注。</li>\n</ul>\n</li>\n</ul>\n<h3 id=\"Remax\"><a href=\"#Remax\" class=\"headerlink\" title=\"Remax\"></a>Remax</h3><ul>\n<li><p><strong>核心</strong>：由阿里团队开发，几乎不封装 React API，保持与 React Web 最大一致性 。</p>\n</li>\n<li><p><strong>优势</strong>：</p>\n<ul>\n<li>纯 React 生态，组件迁移成本最低；</li>\n<li>支持 TypeScript。</li>\n</ul>\n</li>\n<li><p><strong>劣势</strong>：</p>\n<ul>\n<li>功能覆盖不如 Taro 全面；</li>\n<li>社区相对小。</li>\n</ul>\n</li>\n</ul>\n<h3 id=\"MPVue-WePY\"><a href=\"#MPVue-WePY\" class=\"headerlink\" title=\"MPVue &amp; WePY\"></a>MPVue &amp; WePY</h3><blockquote>\n<ul>\n<li><a href=\"http://mpvue.com/mpvue/#-html\">使用手册 | mpvue.com</a></li>\n</ul>\n</blockquote>\n<ul>\n<li><strong>MPVue</strong>：Vue 2.x 驱动，早期多端方案，已停止维护。</li>\n<li><strong>WePY</strong>：官方第一代组件化框架，alpha 长期无更新，社区废弃度高。</li>\n</ul>\n<h3 id=\"Chameleon\"><a href=\"#Chameleon\" class=\"headerlink\" title=\"Chameleon\"></a>Chameleon</h3><ul>\n<li><strong>特点</strong>：阿里开源，统一多端 API，组件可复用，支持多种端（微信&#x2F;支付宝&#x2F;字节&#x2F;IOS&#x2F;Android）。</li>\n<li><strong>关注点</strong>：学习曲线、社区活跃度一般。</li>\n</ul>\n<h3 id=\"kbone\"><a href=\"#kbone\" class=\"headerlink\" title=\"kbone\"></a>kbone</h3><ul>\n<li><strong>特点</strong>：Web 应用快速迁移，模拟 WebView 环境，支持 DOM&#x2F;BOM，可“零改造”接入热门前端库（Vue&#x2F;React）。</li>\n<li><strong>使用场景</strong>：已有成熟 Web 产品，希望快速在微信内复用。</li>\n</ul>\n<hr>\n<h2 id=\"UI-组件库推荐\"><a href=\"#UI-组件库推荐\" class=\"headerlink\" title=\"UI 组件库推荐\"></a>UI 组件库推荐</h2><ul>\n<li><strong>WeUI</strong>（官方）</li>\n<li><strong>Vant Weapp</strong>（有赞）</li>\n<li><strong>Wux Weapp</strong></li>\n<li><strong>Color UI</strong>（轻量视觉）</li>\n</ul>\n<hr>\n<h2 id=\"选型建议\"><a href=\"#选型建议\" class=\"headerlink\" title=\"选型建议\"></a>选型建议</h2><ol>\n<li><strong>单微信小程序、无跨端需求</strong> → 推荐使用 <strong>原生 MINA</strong>，直接调用官方 API。</li>\n<li><strong>Vue 团队、多端（含 App&#x2F;H5）</strong> → <strong>uni-app</strong> 最佳；</li>\n<li><strong>React 团队、多端（含 RN&#x2F;H5）</strong> → <strong>Taro</strong> 或 <strong>Remax</strong>；</li>\n<li><strong>已有 Web 应用</strong> → <strong>kbone</strong> 零改造迁移；</li>\n<li><strong>轻量化需求</strong> → 可选 <strong>Chameleon</strong>；</li>\n<li><strong>老项目、需维护</strong> → Vue 生态可留用 <strong>MPVue</strong>；React 生态留用 <strong>Remax</strong>。</li>\n</ol>\n"},{"title":"2025-06-02-数据库的分类和应用","date":"2025-06-01T16:00:00.000Z","_content":"# 数据库的分类和应用\n\n# 参考资料\n\n> - [数据库介绍与分类 - 随心朝阳 - 博客园](https://www.cnblogs.com/zhaojingyu/p/8873991.html?utm_source=chatgpt.com)\n> - [众多的数据库类型，你该怎么选择？ | Amazon Web Services](https://aws.amazon.com/cn/blogs/china/how-to-choose-among-different-database-categories/?utm_source=chatgpt.com)\n> - [数据库类型：2025 年需要了解的一切 | Astera](https://www.astera.com/zh-CN/type/blog/a-quick-overview-of-different-types-of-databases/?utm_source=chatgpt.com)\n> - [面向对象数据库详解:概念、设计与优化-CSDN 博客](https://blog.csdn.net/m0_72410588/article/details/131230227?utm_source=chatgpt.com)\n> - [面向对象数据库解析-CSDN 博客](https://blog.csdn.net/ypluo/article/details/104641730?utm_source=chatgpt.com)\n> - [www.cnblogs.com](https://www.cnblogs.com/myshowtime/p/16489514.html)\n\n# 概述\n\n数据库就是一个存放数据的仓库，这个仓库按照一定的数据结构（数据结构是指数据的组织形式或数据之间的联系）来组织存储的，我们可以通过数据库提供的多种方法来管理数据库里的数据。\n\n　　我们的程序都是在内存中运行的，一旦程序运行结束或者计算机断电，程序运行中的数据都会丢失,所以我们就需要将一些程序运行的数据持久化到硬盘之中，以确保数据的安全性。说白了，数据库就是存储数据的仓库。\n\n> 下面是数据库引擎的实时排名网站\n\n> - [DB-Engines Ranking](https://db-engines.com/en/ranking)\n\n![1749363632854DIYJbWTVbodBoBxVMgLclkiTnKh.png](https://gitee.com/tanke11223344/imagehost/raw/main/blog/1749363632854DIYJbWTVbodBoBxVMgLclkiTnKh.png)\n\n## 关系型数据库（RDBMS）\n\n关系型数据库以**表—行—列**结构存储数据，通过外键管理实体间关联，支持复杂联表和事务处理，是最成熟的数据库类型 。它使用 ANSI SQL 作为标准查询语言，可执行多表 JOIN、子查询和存储过程等操作，满足 OLTP（联机事务处理）场景需求 。\n\n### 架构与事务\n\n主流 RDBMS 如 MySQL（InnoDB 引擎）和 PostgreSQL 采用**多版本并发控制（MVCC）实现高并发读写，同时提供行级锁、两阶段锁等机制保证隔离性 。在分布式部署中，一般通过主从复制**、**读写分离**、**分库分表**或中间件 ShardingSphere 实现水平扩展，解决单机性能瓶颈。\n\n### 性能优化\n\n- **索引设计**：B+ 树、哈希索引和全文索引，各有取舍；\n- **查询优化**：执行计划（EXPLAIN）、覆盖索引、分区表减少 I/O；\n- **缓存机制**：如 MySQL Query Cache（已弃用）与 Buffer Pool；\n- **物理架构**：SSD 替换 HDD、NUMA 拆分及内存调优 。\n\n### 典型应用\n\n- **电商订单系统**：保证库存扣减的强一致性与事务原子性；\n- **金融支付场景**：对账、清分要求 ACID 特性；\n- **企业级 CRM/ERP**：多表联动，复杂报表生成 。\n\n---\n\n## NoSQL 数据库\n\n![1749363644852Vbg5bEP8gorZu8xdFGzcvskhn4e.png](https://gitee.com/tanke11223344/imagehost/raw/main/blog/1749363644852Vbg5bEP8gorZu8xdFGzcvskhn4e.png)\n\nNoSQL 数据库借助灵活的数据模型和可线性扩展架构，应对大数据、高并发与非结构化场景。主要分为以下几类：\n\n### 键值存储（Key–Value）\n\n![1749363668852Nb0IbN0C2oIFKqxLYXvcB6uTnvf.png](https://gitee.com/tanke11223344/imagehost/raw/main/blog/1749363668852Nb0IbN0C2oIFKqxLYXvcB6uTnvf.png)\n![1749363676852HnxhbGx8kofa7uxydEEcpm5Ynrd.png](https://gitee.com/tanke11223344/imagehost/raw/main/blog/1749363676852HnxhbGx8kofa7uxydEEcpm5Ynrd.png)\n\n键值数据库以唯一键（Key）直接定位值（Value），最典型产品是 Redis 与 Memcached 。\n\n- **Redis** 支持字符串、列表、集合、有序集合及哈希等多种数据类型，并提供持久化（RDB/AOF）与主从复制功能，可用作缓存、分布式锁、消息队列等 。\n- **Memcached** 轻量且高性能，专注内存缓存，适合对持久化需求不高的场景 。\n\n### 文档存储（Document）\n\n![1749363690852HH52bVf6RoelESxNCobcq4PonBe.png](https://gitee.com/tanke11223344/imagehost/raw/main/blog/1749363690852HH52bVf6RoelESxNCobcq4PonBe.png)\n\n文档数据库以 JSON/BSON 形式存储半结构化数据，Collections 与 Documents 对应 RDBMS 的表与行。\n\n- **MongoDB** 提供二级索引、聚合框架与复制集、分片集群，可动态 Schema、轻松存储嵌套对象，常用于内容管理、用户画像和配置中心 。\n- **Amazon DocumentDB**（兼容 MongoDB）则是托管型服务，简化集群管理 。\n\n### 列族存储（Column-Family）\n\n![1749363699853GUOMbxwMAoXTgSxByxRcA69xnpc.png](https://gitee.com/tanke11223344/imagehost/raw/main/blog/1749363699853GUOMbxwMAoXTgSxByxRcA69xnpc.png)\n\n列族数据库以列簇方式存储行数据，适合宽表和稀疏表场景 。\n\n- **Apache Cassandra** 采用去中心化 P2P 架构，利用 Gossip 协议和一致性哈希分布数据，支持跨 DC 多活部署；\n- **Apache HBase** 构建于 HDFS 之上，通过 RegionServer 管理数据分片，擅长大规模时序和日志数据存储 。\n\n这两者广泛应用于**物联网指标存储**、**用户行为日志**及**大规模特征库**等场景 。\n\n### 图数据库（Graph）\n\n![1749363706852RdqubF5YqoW6I7xaDbxcUGmQnug.png](https://gitee.com/tanke11223344/imagehost/raw/main/blog/1749363706852RdqubF5YqoW6I7xaDbxcUGmQnug.png)\n\n图数据库基于**属性图模型**，节点（Node）和边（Edge）存储实体及其关系，擅长多跳遍历与图算法。\n\n- **Neo4j** 原生支持 ACID 图事务和 Cypher 查询语言，适合**社交网络**、**知识图谱**及**欺诈检测**场景 。\n- **JanusGraph** 支持后端 Cassandra、HBase 存储，可结合 Gremlin 实现分布式图计算 。\n\n### 面向对象数据库（OODBMS）\n\n> - [ORM 实例教程 - 阮一峰的网络日志](https://www.ruanyifeng.com/blog/2019/02/orm-tutorial.html?utm_source=chatgpt.com)\n\n### ORM 实例\n\n![1749363723088H85CbxxlqoFbC2xvZDxc3roZnXc.png](https://gitee.com/tanke11223344/imagehost/raw/main/blog/1749363723088H85CbxxlqoFbC2xvZDxc3roZnXc.png)\n\n**简单说，ORM 就是通过实例对象的语法，完成关系型数据库的操作的技术，是\"对象-关系映射\"（Object/Relational Mapping） 的缩写。**\n\nORM 把数据库映射成对象。\n\n![1749363730852LJKCbJUiPoMluPxXMtOcAHb1nQd.png](https://gitee.com/tanke11223344/imagehost/raw/main/blog/1749363730852LJKCbJUiPoMluPxXMtOcAHb1nQd.png)\n\n面向对象数据库将 OOP 对象直接存储于数据库，支持类、继承与方法 。它适用于 **CAD/CAE**、**嵌入式系统**与 **GIS** 等复杂对象场景，避免了 ORM 带来的映射开销。\n\n### 层次式与网状数据库\n\n- **层次式数据库**（IMS、Windows 注册表）使用父子一对多结构，检索效率高但缺乏灵活性 。\n- **网状数据库** 允许多对多父子关系，曾用于大型主机系统，如 IDMS，但因查询复杂逐步被关系型数据库取代 。\n\n---\n\n## NewSQL：ACID + 分布式扩展\n\nNewSQL 兼顾了关系型 SQL 事务和 NoSQL 的水平扩展能力，通常基于 Raft、Paxos 或 Google TrueTime 协议实现分布式一致性 。\n\n- **TiDB** 通过 PD+TiKV 自动分片、调度，兼容 MySQL 协议，适用于流量大、节点众多的 OLTP 场景 。\n- **CockroachDB** 利用 Raft 保证多副本强一致，支持多活部署；\n- **Google Spanner** 则借助硬件时钟同步提供全球一致性 。\n\nNewSQL 常见于**互联网金融**、**全链路电商订单**等要求强一致且海量扩展的场景 。\n\n---\n\n## 专用型数据库\n\n### 时序数据库\n\n针对**时间序列**做了专门优化，包括写密集、压缩、高效时间窗口查询 。\n\n- **InfluxDB** 的 TSM 引擎和 TICK Stack 生态；\n- **TimescaleDB** 基于 PostgreSQL 分区表实现，兼容 SQL 与生态 。\n\n### 地理空间数据库\n\n- **PostGIS** 在 PostgreSQL 上提供 GiST 空间索引；\n- **MongoDB 2dsphere** 支持 GeoJSON 查询 。\n\n### 全文搜索与分析引擎\n\n- **Elasticsearch** 基于 Lucene，支持倒排索引、聚合分析及 Near Real-Time（NRT）搜索 。\n- 常与 **Logstash/Beats/Kibana** 构建 ELK 堆栈，用于日志收集、处理与可视化 。\n\n---\n\n## 混合架构与选型指南\n\n大型系统普遍采用 **Polyglot Persistence**，不同业务模块选用最合适的存储引擎：\n\n- **缓存层**：Redis/Memcached 提升读写性能 。\n- **核心事务**：MySQL/PostgreSQL 或 TiDB/CockroachDB 保证 ACID 。\n- **流式处理**：Kafka、RabbitMQ 解耦异步；\n- **实时 BI**：Elasticsearch/ClickHouse 提供快速聚合 。\n\n### 选型建议\n\n1. **强一致事务** → 关系型/NewSQL\n2. **超高并发缓存** → Redis/Memcached\n3. **半结构化文档** → MongoDB/DocumentDB\n4. **宽表稀疏存储** → Cassandra/HBase\n5. **复杂关系分析** → Neo4j/JanusGraph\n6. **时序数据** → InfluxDB/TimescaleDB\n7. **全文检索** → Elasticsearch\n","source":"_posts/2025-06-02-数据库的分类和应用.md","raw":"---\ntitle:  2025-06-02-数据库的分类和应用\ndate: 2025-06-02\ntags: \n    课程学习\n---\n# 数据库的分类和应用\n\n# 参考资料\n\n> - [数据库介绍与分类 - 随心朝阳 - 博客园](https://www.cnblogs.com/zhaojingyu/p/8873991.html?utm_source=chatgpt.com)\n> - [众多的数据库类型，你该怎么选择？ | Amazon Web Services](https://aws.amazon.com/cn/blogs/china/how-to-choose-among-different-database-categories/?utm_source=chatgpt.com)\n> - [数据库类型：2025 年需要了解的一切 | Astera](https://www.astera.com/zh-CN/type/blog/a-quick-overview-of-different-types-of-databases/?utm_source=chatgpt.com)\n> - [面向对象数据库详解:概念、设计与优化-CSDN 博客](https://blog.csdn.net/m0_72410588/article/details/131230227?utm_source=chatgpt.com)\n> - [面向对象数据库解析-CSDN 博客](https://blog.csdn.net/ypluo/article/details/104641730?utm_source=chatgpt.com)\n> - [www.cnblogs.com](https://www.cnblogs.com/myshowtime/p/16489514.html)\n\n# 概述\n\n数据库就是一个存放数据的仓库，这个仓库按照一定的数据结构（数据结构是指数据的组织形式或数据之间的联系）来组织存储的，我们可以通过数据库提供的多种方法来管理数据库里的数据。\n\n　　我们的程序都是在内存中运行的，一旦程序运行结束或者计算机断电，程序运行中的数据都会丢失,所以我们就需要将一些程序运行的数据持久化到硬盘之中，以确保数据的安全性。说白了，数据库就是存储数据的仓库。\n\n> 下面是数据库引擎的实时排名网站\n\n> - [DB-Engines Ranking](https://db-engines.com/en/ranking)\n\n![1749363632854DIYJbWTVbodBoBxVMgLclkiTnKh.png](https://gitee.com/tanke11223344/imagehost/raw/main/blog/1749363632854DIYJbWTVbodBoBxVMgLclkiTnKh.png)\n\n## 关系型数据库（RDBMS）\n\n关系型数据库以**表—行—列**结构存储数据，通过外键管理实体间关联，支持复杂联表和事务处理，是最成熟的数据库类型 。它使用 ANSI SQL 作为标准查询语言，可执行多表 JOIN、子查询和存储过程等操作，满足 OLTP（联机事务处理）场景需求 。\n\n### 架构与事务\n\n主流 RDBMS 如 MySQL（InnoDB 引擎）和 PostgreSQL 采用**多版本并发控制（MVCC）实现高并发读写，同时提供行级锁、两阶段锁等机制保证隔离性 。在分布式部署中，一般通过主从复制**、**读写分离**、**分库分表**或中间件 ShardingSphere 实现水平扩展，解决单机性能瓶颈。\n\n### 性能优化\n\n- **索引设计**：B+ 树、哈希索引和全文索引，各有取舍；\n- **查询优化**：执行计划（EXPLAIN）、覆盖索引、分区表减少 I/O；\n- **缓存机制**：如 MySQL Query Cache（已弃用）与 Buffer Pool；\n- **物理架构**：SSD 替换 HDD、NUMA 拆分及内存调优 。\n\n### 典型应用\n\n- **电商订单系统**：保证库存扣减的强一致性与事务原子性；\n- **金融支付场景**：对账、清分要求 ACID 特性；\n- **企业级 CRM/ERP**：多表联动，复杂报表生成 。\n\n---\n\n## NoSQL 数据库\n\n![1749363644852Vbg5bEP8gorZu8xdFGzcvskhn4e.png](https://gitee.com/tanke11223344/imagehost/raw/main/blog/1749363644852Vbg5bEP8gorZu8xdFGzcvskhn4e.png)\n\nNoSQL 数据库借助灵活的数据模型和可线性扩展架构，应对大数据、高并发与非结构化场景。主要分为以下几类：\n\n### 键值存储（Key–Value）\n\n![1749363668852Nb0IbN0C2oIFKqxLYXvcB6uTnvf.png](https://gitee.com/tanke11223344/imagehost/raw/main/blog/1749363668852Nb0IbN0C2oIFKqxLYXvcB6uTnvf.png)\n![1749363676852HnxhbGx8kofa7uxydEEcpm5Ynrd.png](https://gitee.com/tanke11223344/imagehost/raw/main/blog/1749363676852HnxhbGx8kofa7uxydEEcpm5Ynrd.png)\n\n键值数据库以唯一键（Key）直接定位值（Value），最典型产品是 Redis 与 Memcached 。\n\n- **Redis** 支持字符串、列表、集合、有序集合及哈希等多种数据类型，并提供持久化（RDB/AOF）与主从复制功能，可用作缓存、分布式锁、消息队列等 。\n- **Memcached** 轻量且高性能，专注内存缓存，适合对持久化需求不高的场景 。\n\n### 文档存储（Document）\n\n![1749363690852HH52bVf6RoelESxNCobcq4PonBe.png](https://gitee.com/tanke11223344/imagehost/raw/main/blog/1749363690852HH52bVf6RoelESxNCobcq4PonBe.png)\n\n文档数据库以 JSON/BSON 形式存储半结构化数据，Collections 与 Documents 对应 RDBMS 的表与行。\n\n- **MongoDB** 提供二级索引、聚合框架与复制集、分片集群，可动态 Schema、轻松存储嵌套对象，常用于内容管理、用户画像和配置中心 。\n- **Amazon DocumentDB**（兼容 MongoDB）则是托管型服务，简化集群管理 。\n\n### 列族存储（Column-Family）\n\n![1749363699853GUOMbxwMAoXTgSxByxRcA69xnpc.png](https://gitee.com/tanke11223344/imagehost/raw/main/blog/1749363699853GUOMbxwMAoXTgSxByxRcA69xnpc.png)\n\n列族数据库以列簇方式存储行数据，适合宽表和稀疏表场景 。\n\n- **Apache Cassandra** 采用去中心化 P2P 架构，利用 Gossip 协议和一致性哈希分布数据，支持跨 DC 多活部署；\n- **Apache HBase** 构建于 HDFS 之上，通过 RegionServer 管理数据分片，擅长大规模时序和日志数据存储 。\n\n这两者广泛应用于**物联网指标存储**、**用户行为日志**及**大规模特征库**等场景 。\n\n### 图数据库（Graph）\n\n![1749363706852RdqubF5YqoW6I7xaDbxcUGmQnug.png](https://gitee.com/tanke11223344/imagehost/raw/main/blog/1749363706852RdqubF5YqoW6I7xaDbxcUGmQnug.png)\n\n图数据库基于**属性图模型**，节点（Node）和边（Edge）存储实体及其关系，擅长多跳遍历与图算法。\n\n- **Neo4j** 原生支持 ACID 图事务和 Cypher 查询语言，适合**社交网络**、**知识图谱**及**欺诈检测**场景 。\n- **JanusGraph** 支持后端 Cassandra、HBase 存储，可结合 Gremlin 实现分布式图计算 。\n\n### 面向对象数据库（OODBMS）\n\n> - [ORM 实例教程 - 阮一峰的网络日志](https://www.ruanyifeng.com/blog/2019/02/orm-tutorial.html?utm_source=chatgpt.com)\n\n### ORM 实例\n\n![1749363723088H85CbxxlqoFbC2xvZDxc3roZnXc.png](https://gitee.com/tanke11223344/imagehost/raw/main/blog/1749363723088H85CbxxlqoFbC2xvZDxc3roZnXc.png)\n\n**简单说，ORM 就是通过实例对象的语法，完成关系型数据库的操作的技术，是\"对象-关系映射\"（Object/Relational Mapping） 的缩写。**\n\nORM 把数据库映射成对象。\n\n![1749363730852LJKCbJUiPoMluPxXMtOcAHb1nQd.png](https://gitee.com/tanke11223344/imagehost/raw/main/blog/1749363730852LJKCbJUiPoMluPxXMtOcAHb1nQd.png)\n\n面向对象数据库将 OOP 对象直接存储于数据库，支持类、继承与方法 。它适用于 **CAD/CAE**、**嵌入式系统**与 **GIS** 等复杂对象场景，避免了 ORM 带来的映射开销。\n\n### 层次式与网状数据库\n\n- **层次式数据库**（IMS、Windows 注册表）使用父子一对多结构，检索效率高但缺乏灵活性 。\n- **网状数据库** 允许多对多父子关系，曾用于大型主机系统，如 IDMS，但因查询复杂逐步被关系型数据库取代 。\n\n---\n\n## NewSQL：ACID + 分布式扩展\n\nNewSQL 兼顾了关系型 SQL 事务和 NoSQL 的水平扩展能力，通常基于 Raft、Paxos 或 Google TrueTime 协议实现分布式一致性 。\n\n- **TiDB** 通过 PD+TiKV 自动分片、调度，兼容 MySQL 协议，适用于流量大、节点众多的 OLTP 场景 。\n- **CockroachDB** 利用 Raft 保证多副本强一致，支持多活部署；\n- **Google Spanner** 则借助硬件时钟同步提供全球一致性 。\n\nNewSQL 常见于**互联网金融**、**全链路电商订单**等要求强一致且海量扩展的场景 。\n\n---\n\n## 专用型数据库\n\n### 时序数据库\n\n针对**时间序列**做了专门优化，包括写密集、压缩、高效时间窗口查询 。\n\n- **InfluxDB** 的 TSM 引擎和 TICK Stack 生态；\n- **TimescaleDB** 基于 PostgreSQL 分区表实现，兼容 SQL 与生态 。\n\n### 地理空间数据库\n\n- **PostGIS** 在 PostgreSQL 上提供 GiST 空间索引；\n- **MongoDB 2dsphere** 支持 GeoJSON 查询 。\n\n### 全文搜索与分析引擎\n\n- **Elasticsearch** 基于 Lucene，支持倒排索引、聚合分析及 Near Real-Time（NRT）搜索 。\n- 常与 **Logstash/Beats/Kibana** 构建 ELK 堆栈，用于日志收集、处理与可视化 。\n\n---\n\n## 混合架构与选型指南\n\n大型系统普遍采用 **Polyglot Persistence**，不同业务模块选用最合适的存储引擎：\n\n- **缓存层**：Redis/Memcached 提升读写性能 。\n- **核心事务**：MySQL/PostgreSQL 或 TiDB/CockroachDB 保证 ACID 。\n- **流式处理**：Kafka、RabbitMQ 解耦异步；\n- **实时 BI**：Elasticsearch/ClickHouse 提供快速聚合 。\n\n### 选型建议\n\n1. **强一致事务** → 关系型/NewSQL\n2. **超高并发缓存** → Redis/Memcached\n3. **半结构化文档** → MongoDB/DocumentDB\n4. **宽表稀疏存储** → Cassandra/HBase\n5. **复杂关系分析** → Neo4j/JanusGraph\n6. **时序数据** → InfluxDB/TimescaleDB\n7. **全文检索** → Elasticsearch\n","slug":"2025-06-02-数据库的分类和应用","published":1,"updated":"2025-09-26T12:18:04.926Z","_id":"cmg0saj4e002ljm8ndsa89eff","comments":1,"layout":"post","photos":[],"content":"<h1 id=\"数据库的分类和应用\"><a href=\"#数据库的分类和应用\" class=\"headerlink\" title=\"数据库的分类和应用\"></a>数据库的分类和应用</h1><h1 id=\"参考资料\"><a href=\"#参考资料\" class=\"headerlink\" title=\"参考资料\"></a>参考资料</h1><blockquote>\n<ul>\n<li><a href=\"https://www.cnblogs.com/zhaojingyu/p/8873991.html?utm_source=chatgpt.com\">数据库介绍与分类 - 随心朝阳 - 博客园</a></li>\n<li><a href=\"https://aws.amazon.com/cn/blogs/china/how-to-choose-among-different-database-categories/?utm_source=chatgpt.com\">众多的数据库类型，你该怎么选择？ | Amazon Web Services</a></li>\n<li><a href=\"https://www.astera.com/zh-CN/type/blog/a-quick-overview-of-different-types-of-databases/?utm_source=chatgpt.com\">数据库类型：2025 年需要了解的一切 | Astera</a></li>\n<li><a href=\"https://blog.csdn.net/m0_72410588/article/details/131230227?utm_source=chatgpt.com\">面向对象数据库详解:概念、设计与优化-CSDN 博客</a></li>\n<li><a href=\"https://blog.csdn.net/ypluo/article/details/104641730?utm_source=chatgpt.com\">面向对象数据库解析-CSDN 博客</a></li>\n<li><a href=\"https://www.cnblogs.com/myshowtime/p/16489514.html\">www.cnblogs.com</a></li>\n</ul>\n</blockquote>\n<h1 id=\"概述\"><a href=\"#概述\" class=\"headerlink\" title=\"概述\"></a>概述</h1><p>数据库就是一个存放数据的仓库，这个仓库按照一定的数据结构（数据结构是指数据的组织形式或数据之间的联系）来组织存储的，我们可以通过数据库提供的多种方法来管理数据库里的数据。</p>\n<p>　　我们的程序都是在内存中运行的，一旦程序运行结束或者计算机断电，程序运行中的数据都会丢失,所以我们就需要将一些程序运行的数据持久化到硬盘之中，以确保数据的安全性。说白了，数据库就是存储数据的仓库。</p>\n<blockquote>\n<p>下面是数据库引擎的实时排名网站</p>\n</blockquote>\n<blockquote>\n<ul>\n<li><a href=\"https://db-engines.com/en/ranking\">DB-Engines Ranking</a></li>\n</ul>\n</blockquote>\n<p><img src=\"https://gitee.com/tanke11223344/imagehost/raw/main/blog/1749363632854DIYJbWTVbodBoBxVMgLclkiTnKh.png\" alt=\"1749363632854DIYJbWTVbodBoBxVMgLclkiTnKh.png\"></p>\n<h2 id=\"关系型数据库（RDBMS）\"><a href=\"#关系型数据库（RDBMS）\" class=\"headerlink\" title=\"关系型数据库（RDBMS）\"></a>关系型数据库（RDBMS）</h2><p>关系型数据库以<strong>表—行—列</strong>结构存储数据，通过外键管理实体间关联，支持复杂联表和事务处理，是最成熟的数据库类型 。它使用 ANSI SQL 作为标准查询语言，可执行多表 JOIN、子查询和存储过程等操作，满足 OLTP（联机事务处理）场景需求 。</p>\n<h3 id=\"架构与事务\"><a href=\"#架构与事务\" class=\"headerlink\" title=\"架构与事务\"></a>架构与事务</h3><p>主流 RDBMS 如 MySQL（InnoDB 引擎）和 PostgreSQL 采用<strong>多版本并发控制（MVCC）实现高并发读写，同时提供行级锁、两阶段锁等机制保证隔离性 。在分布式部署中，一般通过主从复制</strong>、<strong>读写分离</strong>、<strong>分库分表</strong>或中间件 ShardingSphere 实现水平扩展，解决单机性能瓶颈。</p>\n<h3 id=\"性能优化\"><a href=\"#性能优化\" class=\"headerlink\" title=\"性能优化\"></a>性能优化</h3><ul>\n<li><strong>索引设计</strong>：B+ 树、哈希索引和全文索引，各有取舍；</li>\n<li><strong>查询优化</strong>：执行计划（EXPLAIN）、覆盖索引、分区表减少 I&#x2F;O；</li>\n<li><strong>缓存机制</strong>：如 MySQL Query Cache（已弃用）与 Buffer Pool；</li>\n<li><strong>物理架构</strong>：SSD 替换 HDD、NUMA 拆分及内存调优 。</li>\n</ul>\n<h3 id=\"典型应用\"><a href=\"#典型应用\" class=\"headerlink\" title=\"典型应用\"></a>典型应用</h3><ul>\n<li><strong>电商订单系统</strong>：保证库存扣减的强一致性与事务原子性；</li>\n<li><strong>金融支付场景</strong>：对账、清分要求 ACID 特性；</li>\n<li><strong>企业级 CRM&#x2F;ERP</strong>：多表联动，复杂报表生成 。</li>\n</ul>\n<hr>\n<h2 id=\"NoSQL-数据库\"><a href=\"#NoSQL-数据库\" class=\"headerlink\" title=\"NoSQL 数据库\"></a>NoSQL 数据库</h2><p><img src=\"https://gitee.com/tanke11223344/imagehost/raw/main/blog/1749363644852Vbg5bEP8gorZu8xdFGzcvskhn4e.png\" alt=\"1749363644852Vbg5bEP8gorZu8xdFGzcvskhn4e.png\"></p>\n<p>NoSQL 数据库借助灵活的数据模型和可线性扩展架构，应对大数据、高并发与非结构化场景。主要分为以下几类：</p>\n<h3 id=\"键值存储（Key–Value）\"><a href=\"#键值存储（Key–Value）\" class=\"headerlink\" title=\"键值存储（Key–Value）\"></a>键值存储（Key–Value）</h3><p><img src=\"https://gitee.com/tanke11223344/imagehost/raw/main/blog/1749363668852Nb0IbN0C2oIFKqxLYXvcB6uTnvf.png\" alt=\"1749363668852Nb0IbN0C2oIFKqxLYXvcB6uTnvf.png\"><br><img src=\"https://gitee.com/tanke11223344/imagehost/raw/main/blog/1749363676852HnxhbGx8kofa7uxydEEcpm5Ynrd.png\" alt=\"1749363676852HnxhbGx8kofa7uxydEEcpm5Ynrd.png\"></p>\n<p>键值数据库以唯一键（Key）直接定位值（Value），最典型产品是 Redis 与 Memcached 。</p>\n<ul>\n<li><strong>Redis</strong> 支持字符串、列表、集合、有序集合及哈希等多种数据类型，并提供持久化（RDB&#x2F;AOF）与主从复制功能，可用作缓存、分布式锁、消息队列等 。</li>\n<li><strong>Memcached</strong> 轻量且高性能，专注内存缓存，适合对持久化需求不高的场景 。</li>\n</ul>\n<h3 id=\"文档存储（Document）\"><a href=\"#文档存储（Document）\" class=\"headerlink\" title=\"文档存储（Document）\"></a>文档存储（Document）</h3><p><img src=\"https://gitee.com/tanke11223344/imagehost/raw/main/blog/1749363690852HH52bVf6RoelESxNCobcq4PonBe.png\" alt=\"1749363690852HH52bVf6RoelESxNCobcq4PonBe.png\"></p>\n<p>文档数据库以 JSON&#x2F;BSON 形式存储半结构化数据，Collections 与 Documents 对应 RDBMS 的表与行。</p>\n<ul>\n<li><strong>MongoDB</strong> 提供二级索引、聚合框架与复制集、分片集群，可动态 Schema、轻松存储嵌套对象，常用于内容管理、用户画像和配置中心 。</li>\n<li><strong>Amazon DocumentDB</strong>（兼容 MongoDB）则是托管型服务，简化集群管理 。</li>\n</ul>\n<h3 id=\"列族存储（Column-Family）\"><a href=\"#列族存储（Column-Family）\" class=\"headerlink\" title=\"列族存储（Column-Family）\"></a>列族存储（Column-Family）</h3><p><img src=\"https://gitee.com/tanke11223344/imagehost/raw/main/blog/1749363699853GUOMbxwMAoXTgSxByxRcA69xnpc.png\" alt=\"1749363699853GUOMbxwMAoXTgSxByxRcA69xnpc.png\"></p>\n<p>列族数据库以列簇方式存储行数据，适合宽表和稀疏表场景 。</p>\n<ul>\n<li><strong>Apache Cassandra</strong> 采用去中心化 P2P 架构，利用 Gossip 协议和一致性哈希分布数据，支持跨 DC 多活部署；</li>\n<li><strong>Apache HBase</strong> 构建于 HDFS 之上，通过 RegionServer 管理数据分片，擅长大规模时序和日志数据存储 。</li>\n</ul>\n<p>这两者广泛应用于<strong>物联网指标存储</strong>、<strong>用户行为日志</strong>及<strong>大规模特征库</strong>等场景 。</p>\n<h3 id=\"图数据库（Graph）\"><a href=\"#图数据库（Graph）\" class=\"headerlink\" title=\"图数据库（Graph）\"></a>图数据库（Graph）</h3><p><img src=\"https://gitee.com/tanke11223344/imagehost/raw/main/blog/1749363706852RdqubF5YqoW6I7xaDbxcUGmQnug.png\" alt=\"1749363706852RdqubF5YqoW6I7xaDbxcUGmQnug.png\"></p>\n<p>图数据库基于<strong>属性图模型</strong>，节点（Node）和边（Edge）存储实体及其关系，擅长多跳遍历与图算法。</p>\n<ul>\n<li><strong>Neo4j</strong> 原生支持 ACID 图事务和 Cypher 查询语言，适合<strong>社交网络</strong>、<strong>知识图谱</strong>及<strong>欺诈检测</strong>场景 。</li>\n<li><strong>JanusGraph</strong> 支持后端 Cassandra、HBase 存储，可结合 Gremlin 实现分布式图计算 。</li>\n</ul>\n<h3 id=\"面向对象数据库（OODBMS）\"><a href=\"#面向对象数据库（OODBMS）\" class=\"headerlink\" title=\"面向对象数据库（OODBMS）\"></a>面向对象数据库（OODBMS）</h3><blockquote>\n<ul>\n<li><a href=\"https://www.ruanyifeng.com/blog/2019/02/orm-tutorial.html?utm_source=chatgpt.com\">ORM 实例教程 - 阮一峰的网络日志</a></li>\n</ul>\n</blockquote>\n<h3 id=\"ORM-实例\"><a href=\"#ORM-实例\" class=\"headerlink\" title=\"ORM 实例\"></a>ORM 实例</h3><p><img src=\"https://gitee.com/tanke11223344/imagehost/raw/main/blog/1749363723088H85CbxxlqoFbC2xvZDxc3roZnXc.png\" alt=\"1749363723088H85CbxxlqoFbC2xvZDxc3roZnXc.png\"></p>\n<p><strong>简单说，ORM 就是通过实例对象的语法，完成关系型数据库的操作的技术，是”对象-关系映射”（Object&#x2F;Relational Mapping） 的缩写。</strong></p>\n<p>ORM 把数据库映射成对象。</p>\n<p><img src=\"https://gitee.com/tanke11223344/imagehost/raw/main/blog/1749363730852LJKCbJUiPoMluPxXMtOcAHb1nQd.png\" alt=\"1749363730852LJKCbJUiPoMluPxXMtOcAHb1nQd.png\"></p>\n<p>面向对象数据库将 OOP 对象直接存储于数据库，支持类、继承与方法 。它适用于 <strong>CAD&#x2F;CAE</strong>、<strong>嵌入式系统</strong>与 <strong>GIS</strong> 等复杂对象场景，避免了 ORM 带来的映射开销。</p>\n<h3 id=\"层次式与网状数据库\"><a href=\"#层次式与网状数据库\" class=\"headerlink\" title=\"层次式与网状数据库\"></a>层次式与网状数据库</h3><ul>\n<li><strong>层次式数据库</strong>（IMS、Windows 注册表）使用父子一对多结构，检索效率高但缺乏灵活性 。</li>\n<li><strong>网状数据库</strong> 允许多对多父子关系，曾用于大型主机系统，如 IDMS，但因查询复杂逐步被关系型数据库取代 。</li>\n</ul>\n<hr>\n<h2 id=\"NewSQL：ACID-分布式扩展\"><a href=\"#NewSQL：ACID-分布式扩展\" class=\"headerlink\" title=\"NewSQL：ACID + 分布式扩展\"></a>NewSQL：ACID + 分布式扩展</h2><p>NewSQL 兼顾了关系型 SQL 事务和 NoSQL 的水平扩展能力，通常基于 Raft、Paxos 或 Google TrueTime 协议实现分布式一致性 。</p>\n<ul>\n<li><strong>TiDB</strong> 通过 PD+TiKV 自动分片、调度，兼容 MySQL 协议，适用于流量大、节点众多的 OLTP 场景 。</li>\n<li><strong>CockroachDB</strong> 利用 Raft 保证多副本强一致，支持多活部署；</li>\n<li><strong>Google Spanner</strong> 则借助硬件时钟同步提供全球一致性 。</li>\n</ul>\n<p>NewSQL 常见于<strong>互联网金融</strong>、<strong>全链路电商订单</strong>等要求强一致且海量扩展的场景 。</p>\n<hr>\n<h2 id=\"专用型数据库\"><a href=\"#专用型数据库\" class=\"headerlink\" title=\"专用型数据库\"></a>专用型数据库</h2><h3 id=\"时序数据库\"><a href=\"#时序数据库\" class=\"headerlink\" title=\"时序数据库\"></a>时序数据库</h3><p>针对<strong>时间序列</strong>做了专门优化，包括写密集、压缩、高效时间窗口查询 。</p>\n<ul>\n<li><strong>InfluxDB</strong> 的 TSM 引擎和 TICK Stack 生态；</li>\n<li><strong>TimescaleDB</strong> 基于 PostgreSQL 分区表实现，兼容 SQL 与生态 。</li>\n</ul>\n<h3 id=\"地理空间数据库\"><a href=\"#地理空间数据库\" class=\"headerlink\" title=\"地理空间数据库\"></a>地理空间数据库</h3><ul>\n<li><strong>PostGIS</strong> 在 PostgreSQL 上提供 GiST 空间索引；</li>\n<li><strong>MongoDB 2dsphere</strong> 支持 GeoJSON 查询 。</li>\n</ul>\n<h3 id=\"全文搜索与分析引擎\"><a href=\"#全文搜索与分析引擎\" class=\"headerlink\" title=\"全文搜索与分析引擎\"></a>全文搜索与分析引擎</h3><ul>\n<li><strong>Elasticsearch</strong> 基于 Lucene，支持倒排索引、聚合分析及 Near Real-Time（NRT）搜索 。</li>\n<li>常与 <strong>Logstash&#x2F;Beats&#x2F;Kibana</strong> 构建 ELK 堆栈，用于日志收集、处理与可视化 。</li>\n</ul>\n<hr>\n<h2 id=\"混合架构与选型指南\"><a href=\"#混合架构与选型指南\" class=\"headerlink\" title=\"混合架构与选型指南\"></a>混合架构与选型指南</h2><p>大型系统普遍采用 <strong>Polyglot Persistence</strong>，不同业务模块选用最合适的存储引擎：</p>\n<ul>\n<li><strong>缓存层</strong>：Redis&#x2F;Memcached 提升读写性能 。</li>\n<li><strong>核心事务</strong>：MySQL&#x2F;PostgreSQL 或 TiDB&#x2F;CockroachDB 保证 ACID 。</li>\n<li><strong>流式处理</strong>：Kafka、RabbitMQ 解耦异步；</li>\n<li><strong>实时 BI</strong>：Elasticsearch&#x2F;ClickHouse 提供快速聚合 。</li>\n</ul>\n<h3 id=\"选型建议\"><a href=\"#选型建议\" class=\"headerlink\" title=\"选型建议\"></a>选型建议</h3><ol>\n<li><strong>强一致事务</strong> → 关系型&#x2F;NewSQL</li>\n<li><strong>超高并发缓存</strong> → Redis&#x2F;Memcached</li>\n<li><strong>半结构化文档</strong> → MongoDB&#x2F;DocumentDB</li>\n<li><strong>宽表稀疏存储</strong> → Cassandra&#x2F;HBase</li>\n<li><strong>复杂关系分析</strong> → Neo4j&#x2F;JanusGraph</li>\n<li><strong>时序数据</strong> → InfluxDB&#x2F;TimescaleDB</li>\n<li><strong>全文检索</strong> → Elasticsearch</li>\n</ol>\n","excerpt":"","more":"<h1 id=\"数据库的分类和应用\"><a href=\"#数据库的分类和应用\" class=\"headerlink\" title=\"数据库的分类和应用\"></a>数据库的分类和应用</h1><h1 id=\"参考资料\"><a href=\"#参考资料\" class=\"headerlink\" title=\"参考资料\"></a>参考资料</h1><blockquote>\n<ul>\n<li><a href=\"https://www.cnblogs.com/zhaojingyu/p/8873991.html?utm_source=chatgpt.com\">数据库介绍与分类 - 随心朝阳 - 博客园</a></li>\n<li><a href=\"https://aws.amazon.com/cn/blogs/china/how-to-choose-among-different-database-categories/?utm_source=chatgpt.com\">众多的数据库类型，你该怎么选择？ | Amazon Web Services</a></li>\n<li><a href=\"https://www.astera.com/zh-CN/type/blog/a-quick-overview-of-different-types-of-databases/?utm_source=chatgpt.com\">数据库类型：2025 年需要了解的一切 | Astera</a></li>\n<li><a href=\"https://blog.csdn.net/m0_72410588/article/details/131230227?utm_source=chatgpt.com\">面向对象数据库详解:概念、设计与优化-CSDN 博客</a></li>\n<li><a href=\"https://blog.csdn.net/ypluo/article/details/104641730?utm_source=chatgpt.com\">面向对象数据库解析-CSDN 博客</a></li>\n<li><a href=\"https://www.cnblogs.com/myshowtime/p/16489514.html\">www.cnblogs.com</a></li>\n</ul>\n</blockquote>\n<h1 id=\"概述\"><a href=\"#概述\" class=\"headerlink\" title=\"概述\"></a>概述</h1><p>数据库就是一个存放数据的仓库，这个仓库按照一定的数据结构（数据结构是指数据的组织形式或数据之间的联系）来组织存储的，我们可以通过数据库提供的多种方法来管理数据库里的数据。</p>\n<p>　　我们的程序都是在内存中运行的，一旦程序运行结束或者计算机断电，程序运行中的数据都会丢失,所以我们就需要将一些程序运行的数据持久化到硬盘之中，以确保数据的安全性。说白了，数据库就是存储数据的仓库。</p>\n<blockquote>\n<p>下面是数据库引擎的实时排名网站</p>\n</blockquote>\n<blockquote>\n<ul>\n<li><a href=\"https://db-engines.com/en/ranking\">DB-Engines Ranking</a></li>\n</ul>\n</blockquote>\n<p><img src=\"https://gitee.com/tanke11223344/imagehost/raw/main/blog/1749363632854DIYJbWTVbodBoBxVMgLclkiTnKh.png\" alt=\"1749363632854DIYJbWTVbodBoBxVMgLclkiTnKh.png\"></p>\n<h2 id=\"关系型数据库（RDBMS）\"><a href=\"#关系型数据库（RDBMS）\" class=\"headerlink\" title=\"关系型数据库（RDBMS）\"></a>关系型数据库（RDBMS）</h2><p>关系型数据库以<strong>表—行—列</strong>结构存储数据，通过外键管理实体间关联，支持复杂联表和事务处理，是最成熟的数据库类型 。它使用 ANSI SQL 作为标准查询语言，可执行多表 JOIN、子查询和存储过程等操作，满足 OLTP（联机事务处理）场景需求 。</p>\n<h3 id=\"架构与事务\"><a href=\"#架构与事务\" class=\"headerlink\" title=\"架构与事务\"></a>架构与事务</h3><p>主流 RDBMS 如 MySQL（InnoDB 引擎）和 PostgreSQL 采用<strong>多版本并发控制（MVCC）实现高并发读写，同时提供行级锁、两阶段锁等机制保证隔离性 。在分布式部署中，一般通过主从复制</strong>、<strong>读写分离</strong>、<strong>分库分表</strong>或中间件 ShardingSphere 实现水平扩展，解决单机性能瓶颈。</p>\n<h3 id=\"性能优化\"><a href=\"#性能优化\" class=\"headerlink\" title=\"性能优化\"></a>性能优化</h3><ul>\n<li><strong>索引设计</strong>：B+ 树、哈希索引和全文索引，各有取舍；</li>\n<li><strong>查询优化</strong>：执行计划（EXPLAIN）、覆盖索引、分区表减少 I&#x2F;O；</li>\n<li><strong>缓存机制</strong>：如 MySQL Query Cache（已弃用）与 Buffer Pool；</li>\n<li><strong>物理架构</strong>：SSD 替换 HDD、NUMA 拆分及内存调优 。</li>\n</ul>\n<h3 id=\"典型应用\"><a href=\"#典型应用\" class=\"headerlink\" title=\"典型应用\"></a>典型应用</h3><ul>\n<li><strong>电商订单系统</strong>：保证库存扣减的强一致性与事务原子性；</li>\n<li><strong>金融支付场景</strong>：对账、清分要求 ACID 特性；</li>\n<li><strong>企业级 CRM&#x2F;ERP</strong>：多表联动，复杂报表生成 。</li>\n</ul>\n<hr>\n<h2 id=\"NoSQL-数据库\"><a href=\"#NoSQL-数据库\" class=\"headerlink\" title=\"NoSQL 数据库\"></a>NoSQL 数据库</h2><p><img src=\"https://gitee.com/tanke11223344/imagehost/raw/main/blog/1749363644852Vbg5bEP8gorZu8xdFGzcvskhn4e.png\" alt=\"1749363644852Vbg5bEP8gorZu8xdFGzcvskhn4e.png\"></p>\n<p>NoSQL 数据库借助灵活的数据模型和可线性扩展架构，应对大数据、高并发与非结构化场景。主要分为以下几类：</p>\n<h3 id=\"键值存储（Key–Value）\"><a href=\"#键值存储（Key–Value）\" class=\"headerlink\" title=\"键值存储（Key–Value）\"></a>键值存储（Key–Value）</h3><p><img src=\"https://gitee.com/tanke11223344/imagehost/raw/main/blog/1749363668852Nb0IbN0C2oIFKqxLYXvcB6uTnvf.png\" alt=\"1749363668852Nb0IbN0C2oIFKqxLYXvcB6uTnvf.png\"><br><img src=\"https://gitee.com/tanke11223344/imagehost/raw/main/blog/1749363676852HnxhbGx8kofa7uxydEEcpm5Ynrd.png\" alt=\"1749363676852HnxhbGx8kofa7uxydEEcpm5Ynrd.png\"></p>\n<p>键值数据库以唯一键（Key）直接定位值（Value），最典型产品是 Redis 与 Memcached 。</p>\n<ul>\n<li><strong>Redis</strong> 支持字符串、列表、集合、有序集合及哈希等多种数据类型，并提供持久化（RDB&#x2F;AOF）与主从复制功能，可用作缓存、分布式锁、消息队列等 。</li>\n<li><strong>Memcached</strong> 轻量且高性能，专注内存缓存，适合对持久化需求不高的场景 。</li>\n</ul>\n<h3 id=\"文档存储（Document）\"><a href=\"#文档存储（Document）\" class=\"headerlink\" title=\"文档存储（Document）\"></a>文档存储（Document）</h3><p><img src=\"https://gitee.com/tanke11223344/imagehost/raw/main/blog/1749363690852HH52bVf6RoelESxNCobcq4PonBe.png\" alt=\"1749363690852HH52bVf6RoelESxNCobcq4PonBe.png\"></p>\n<p>文档数据库以 JSON&#x2F;BSON 形式存储半结构化数据，Collections 与 Documents 对应 RDBMS 的表与行。</p>\n<ul>\n<li><strong>MongoDB</strong> 提供二级索引、聚合框架与复制集、分片集群，可动态 Schema、轻松存储嵌套对象，常用于内容管理、用户画像和配置中心 。</li>\n<li><strong>Amazon DocumentDB</strong>（兼容 MongoDB）则是托管型服务，简化集群管理 。</li>\n</ul>\n<h3 id=\"列族存储（Column-Family）\"><a href=\"#列族存储（Column-Family）\" class=\"headerlink\" title=\"列族存储（Column-Family）\"></a>列族存储（Column-Family）</h3><p><img src=\"https://gitee.com/tanke11223344/imagehost/raw/main/blog/1749363699853GUOMbxwMAoXTgSxByxRcA69xnpc.png\" alt=\"1749363699853GUOMbxwMAoXTgSxByxRcA69xnpc.png\"></p>\n<p>列族数据库以列簇方式存储行数据，适合宽表和稀疏表场景 。</p>\n<ul>\n<li><strong>Apache Cassandra</strong> 采用去中心化 P2P 架构，利用 Gossip 协议和一致性哈希分布数据，支持跨 DC 多活部署；</li>\n<li><strong>Apache HBase</strong> 构建于 HDFS 之上，通过 RegionServer 管理数据分片，擅长大规模时序和日志数据存储 。</li>\n</ul>\n<p>这两者广泛应用于<strong>物联网指标存储</strong>、<strong>用户行为日志</strong>及<strong>大规模特征库</strong>等场景 。</p>\n<h3 id=\"图数据库（Graph）\"><a href=\"#图数据库（Graph）\" class=\"headerlink\" title=\"图数据库（Graph）\"></a>图数据库（Graph）</h3><p><img src=\"https://gitee.com/tanke11223344/imagehost/raw/main/blog/1749363706852RdqubF5YqoW6I7xaDbxcUGmQnug.png\" alt=\"1749363706852RdqubF5YqoW6I7xaDbxcUGmQnug.png\"></p>\n<p>图数据库基于<strong>属性图模型</strong>，节点（Node）和边（Edge）存储实体及其关系，擅长多跳遍历与图算法。</p>\n<ul>\n<li><strong>Neo4j</strong> 原生支持 ACID 图事务和 Cypher 查询语言，适合<strong>社交网络</strong>、<strong>知识图谱</strong>及<strong>欺诈检测</strong>场景 。</li>\n<li><strong>JanusGraph</strong> 支持后端 Cassandra、HBase 存储，可结合 Gremlin 实现分布式图计算 。</li>\n</ul>\n<h3 id=\"面向对象数据库（OODBMS）\"><a href=\"#面向对象数据库（OODBMS）\" class=\"headerlink\" title=\"面向对象数据库（OODBMS）\"></a>面向对象数据库（OODBMS）</h3><blockquote>\n<ul>\n<li><a href=\"https://www.ruanyifeng.com/blog/2019/02/orm-tutorial.html?utm_source=chatgpt.com\">ORM 实例教程 - 阮一峰的网络日志</a></li>\n</ul>\n</blockquote>\n<h3 id=\"ORM-实例\"><a href=\"#ORM-实例\" class=\"headerlink\" title=\"ORM 实例\"></a>ORM 实例</h3><p><img src=\"https://gitee.com/tanke11223344/imagehost/raw/main/blog/1749363723088H85CbxxlqoFbC2xvZDxc3roZnXc.png\" alt=\"1749363723088H85CbxxlqoFbC2xvZDxc3roZnXc.png\"></p>\n<p><strong>简单说，ORM 就是通过实例对象的语法，完成关系型数据库的操作的技术，是”对象-关系映射”（Object&#x2F;Relational Mapping） 的缩写。</strong></p>\n<p>ORM 把数据库映射成对象。</p>\n<p><img src=\"https://gitee.com/tanke11223344/imagehost/raw/main/blog/1749363730852LJKCbJUiPoMluPxXMtOcAHb1nQd.png\" alt=\"1749363730852LJKCbJUiPoMluPxXMtOcAHb1nQd.png\"></p>\n<p>面向对象数据库将 OOP 对象直接存储于数据库，支持类、继承与方法 。它适用于 <strong>CAD&#x2F;CAE</strong>、<strong>嵌入式系统</strong>与 <strong>GIS</strong> 等复杂对象场景，避免了 ORM 带来的映射开销。</p>\n<h3 id=\"层次式与网状数据库\"><a href=\"#层次式与网状数据库\" class=\"headerlink\" title=\"层次式与网状数据库\"></a>层次式与网状数据库</h3><ul>\n<li><strong>层次式数据库</strong>（IMS、Windows 注册表）使用父子一对多结构，检索效率高但缺乏灵活性 。</li>\n<li><strong>网状数据库</strong> 允许多对多父子关系，曾用于大型主机系统，如 IDMS，但因查询复杂逐步被关系型数据库取代 。</li>\n</ul>\n<hr>\n<h2 id=\"NewSQL：ACID-分布式扩展\"><a href=\"#NewSQL：ACID-分布式扩展\" class=\"headerlink\" title=\"NewSQL：ACID + 分布式扩展\"></a>NewSQL：ACID + 分布式扩展</h2><p>NewSQL 兼顾了关系型 SQL 事务和 NoSQL 的水平扩展能力，通常基于 Raft、Paxos 或 Google TrueTime 协议实现分布式一致性 。</p>\n<ul>\n<li><strong>TiDB</strong> 通过 PD+TiKV 自动分片、调度，兼容 MySQL 协议，适用于流量大、节点众多的 OLTP 场景 。</li>\n<li><strong>CockroachDB</strong> 利用 Raft 保证多副本强一致，支持多活部署；</li>\n<li><strong>Google Spanner</strong> 则借助硬件时钟同步提供全球一致性 。</li>\n</ul>\n<p>NewSQL 常见于<strong>互联网金融</strong>、<strong>全链路电商订单</strong>等要求强一致且海量扩展的场景 。</p>\n<hr>\n<h2 id=\"专用型数据库\"><a href=\"#专用型数据库\" class=\"headerlink\" title=\"专用型数据库\"></a>专用型数据库</h2><h3 id=\"时序数据库\"><a href=\"#时序数据库\" class=\"headerlink\" title=\"时序数据库\"></a>时序数据库</h3><p>针对<strong>时间序列</strong>做了专门优化，包括写密集、压缩、高效时间窗口查询 。</p>\n<ul>\n<li><strong>InfluxDB</strong> 的 TSM 引擎和 TICK Stack 生态；</li>\n<li><strong>TimescaleDB</strong> 基于 PostgreSQL 分区表实现，兼容 SQL 与生态 。</li>\n</ul>\n<h3 id=\"地理空间数据库\"><a href=\"#地理空间数据库\" class=\"headerlink\" title=\"地理空间数据库\"></a>地理空间数据库</h3><ul>\n<li><strong>PostGIS</strong> 在 PostgreSQL 上提供 GiST 空间索引；</li>\n<li><strong>MongoDB 2dsphere</strong> 支持 GeoJSON 查询 。</li>\n</ul>\n<h3 id=\"全文搜索与分析引擎\"><a href=\"#全文搜索与分析引擎\" class=\"headerlink\" title=\"全文搜索与分析引擎\"></a>全文搜索与分析引擎</h3><ul>\n<li><strong>Elasticsearch</strong> 基于 Lucene，支持倒排索引、聚合分析及 Near Real-Time（NRT）搜索 。</li>\n<li>常与 <strong>Logstash&#x2F;Beats&#x2F;Kibana</strong> 构建 ELK 堆栈，用于日志收集、处理与可视化 。</li>\n</ul>\n<hr>\n<h2 id=\"混合架构与选型指南\"><a href=\"#混合架构与选型指南\" class=\"headerlink\" title=\"混合架构与选型指南\"></a>混合架构与选型指南</h2><p>大型系统普遍采用 <strong>Polyglot Persistence</strong>，不同业务模块选用最合适的存储引擎：</p>\n<ul>\n<li><strong>缓存层</strong>：Redis&#x2F;Memcached 提升读写性能 。</li>\n<li><strong>核心事务</strong>：MySQL&#x2F;PostgreSQL 或 TiDB&#x2F;CockroachDB 保证 ACID 。</li>\n<li><strong>流式处理</strong>：Kafka、RabbitMQ 解耦异步；</li>\n<li><strong>实时 BI</strong>：Elasticsearch&#x2F;ClickHouse 提供快速聚合 。</li>\n</ul>\n<h3 id=\"选型建议\"><a href=\"#选型建议\" class=\"headerlink\" title=\"选型建议\"></a>选型建议</h3><ol>\n<li><strong>强一致事务</strong> → 关系型&#x2F;NewSQL</li>\n<li><strong>超高并发缓存</strong> → Redis&#x2F;Memcached</li>\n<li><strong>半结构化文档</strong> → MongoDB&#x2F;DocumentDB</li>\n<li><strong>宽表稀疏存储</strong> → Cassandra&#x2F;HBase</li>\n<li><strong>复杂关系分析</strong> → Neo4j&#x2F;JanusGraph</li>\n<li><strong>时序数据</strong> → InfluxDB&#x2F;TimescaleDB</li>\n<li><strong>全文检索</strong> → Elasticsearch</li>\n</ol>\n"},{"title":"2025-06-02-IP 地址规划及案例分析","date":"2025-06-01T16:00:00.000Z","_content":"# IP 地址规划及案例分析\n\n# 参考资料\n\n> - [Plan for IP addressing - Cloud Adoption Framework](https://learn.microsoft.com/en-us/azure/cloud-adoption-framework/ready/azure-best-practices/plan-for-ip-addressing?utm_source=chatgpt.com)\n> - [www.cnblogs.com](https://www.cnblogs.com/zhchoutai/p/6932604.html)\n> - [image-hosting/articles at master · jonsam-ng/image-hosting](https://github.com/jonsam-ng/image-hosting/tree/master/articles)\n\n# 概述\n\n在网络通信中，**MAC 地址**与 **IP 地址**分别位于 OSI 模型的数据链路层和网络层，二者协同完成从局域到广域的可靠互联。MAC 地址由 IEEE 分配的 OUI（组织唯一标识符）和厂商自定义部分构成，对应真实硬件；IP 地址则分为网络号与主机号，用以逻辑上定位主机并实现跨网段路由。\n\nIP 地址（Internet Protocol Address），缩写为 IP Adress，是一种在 Internet 上的给主机统一编址的地址格式，也称为网络协议（IP 协议）地址。它为互联网上的每一个网络和每一台主机分配一个逻辑地址，常见的 IP 地址，分为 IPv4 与 IPv6 两大类，当前广泛应用的是 IPv4，目前 IPv4 几乎耗尽，下一阶段必然会进行版本升级到 IPv6；如无特别注明，一般我们讲的的 IP 地址所指的是 IPv4。\n\n![1749363873852HlvKbpXGzoKjxBxn7Zoclw6Knjf.png](https://gitee.com/tanke11223344/imagehost/raw/main/blog/1749363873852HlvKbpXGzoKjxBxn7Zoclw6Knjf.png)\n\n## 进制转换回顾\n\n在理解 IP 地址（二进制）与点分十进制表示之前，必须熟练掌握二进制与十进制互转。\n\n![1749363883851MwwKbhLFVoIeQzxsXQUcS9TSnjh.png](https://gitee.com/tanke11223344/imagehost/raw/main/blog/1749363883851MwwKbhLFVoIeQzxsXQUcS9TSnjh.png)\n\n- **二进制权值**：第 n 位表示 2ⁿ。八位二进制可表示 0–255，共 2⁸ 种状态。\n- **示例**：`11010010₂ = 1·2⁷ +1·2⁶+0·2⁵+1·2⁴+0·2³+0·2²+1·2¹+0·2⁰ = 128+64+16+2 = 210`。\n  掌握“相邻位权值相差两倍”规律，可快速记忆 2⁰–2⁷ 的所有幂值。\n\n## MAC 地址（数据链路层）\n\n### 组成与格式\n\n- **长度**：48 位（二进制），通常写作 6 个字节的十六进制，用冒号或中划线分隔，如 `AC:DE:48:23:45:67`。\n- **结构**：前 24 位为 OUI（Organizationally Unique Identifier），由 IEEE 分配，标识厂家；后 24 位是厂商自行分配的扩展标识符，用以唯一定位网卡。\n- **示例**：OUI `AC-DE-48` 可能对应某厂商生产的设备，其余 24 位由该厂商自由定义。\n\n### 功能与用途\n\n- **帧转发**：交换机根据数据帧头部的目标 MAC 地址在 CAM 表中查找对应端口，实现二层转发。\n- **设备识别**：在安全和取证场景，可通过 OUI 识别厂商及设备类型。\n\n## IP 地址（网络层）\n\n### IPv4 格式与点分十进制\n\n![1749363894091BwTFbPQc1oFOhKxYbGwcq5RmnGf.png](https://gitee.com/tanke11223344/imagehost/raw/main/blog/1749363894091BwTFbPQc1oFOhKxYbGwcq5RmnGf.png)\n\n- **32 位地址**由四段 8 位二进制组成，每段转换为 0–255 的十进制，使用“点”分隔，如 `192.168.1.1`。\n- **网/主分界**：通过子网掩码（如 `255.255.255.0` 或 `/24`）区分网络号与主机号。\n\n![1749363900852GyfsbRbmGojzzwxUYr9ca4OVnEg.png](https://gitee.com/tanke11223344/imagehost/raw/main/blog/1749363900852GyfsbRbmGojzzwxUYr9ca4OVnEg.png)\n\n### IP 与 MAC 的协作\n\n- **ARP** 协议：主机先判断目标 IP 是否与自身在同一子网；若不同，则将下一跳路由器的 MAC 用于帧封装；若相同，则直接将目标主机 MAC 用于帧封装。\n\n![1749363908852I8SCbAE7WoWf71xo1sBcUdNGndf.png](https://gitee.com/tanke11223344/imagehost/raw/main/blog/1749363908852I8SCbAE7WoWf71xo1sBcUdNGndf.png)\n\n- **过程**：\n  1. 网络层生成包含源/目标 IP 的数据包；\n  2. 数据链路层封装源/目标 MAC，并在局域内通信；\n  3. 路由器根据 IP 决定下一跳，MAC 则由 ARP 动态解析。\n\n---\n\n## IPv4 地址分类\n\nIPv4 按首字节前缀分为五类：A/B/C 类用于主机寻址，D 类用于多播，E 类保留。\n\n![1749363916852LDaWb0dWrojXS8xdRK0cMcQOnNb.png](https://gitee.com/tanke11223344/imagehost/raw/main/blog/1749363916852LDaWb0dWrojXS8xdRK0cMcQOnNb.png)\n\n- **网络地址**：主机 ID 全 0（如 `192.168.1.0`）。\n- **广播地址**：主机 ID 全 1（如 `192.168.1.255`）。\n- **环回地址**：`127.0.0.1`，测试本机网络堆栈。\n- **自动私有 IP**：`169.254.0.0–169.254.255.255`，DHCP 失败时自动生成。\n- **全 0/全 1**：`0.0.0.0`、`255.255.255.255` 用于内部通信及本地广播。\n\n### A 类地址\n\nA 类地址的网络号（net-id）占 8 位，且其二进制第一位固定为 `0`，因此 A 类网络的网络号范围为 0 至 127，共计 128 个网络。\n\n- **网络号 0**（地址范围 `0.0.0.0` ~ `0.255.255.255`）被保留，用于表示“本网络”。\n- **网络号 127**（地址范围 `127.0.0.0` ~ `127.255.255.255`）被保留，用作环回测试地址。\n- **网络号 10**（地址范围 `10.0.0.0` ~ `10.255.255.255`）被指定为私有地址，用于内部网络。\n\n除去这些特殊用途的网络，实际可公开分配的 A 类网络共有 125 个（从网络号 1 到 126，再除去网络号 10）。每一个 A 类网络的主机号（host-id）占 24 位，理论上可分配 `2^24` 个主机地址。但由于主机号全为 `0` 的地址代表网络本身，全为 `1` 的地址代表网络广播地址，这两个地址需被保留，因此每个 A 类网络实际可用的主机数量为 `2^24 - 2 = 16,777,214` 个。\n\n### B 类地址\n\nB 类地址的网络号占 16 位，且其二进制前两位固定为 `10`，这使得 B 类网络的数量为 `2^(16-2) = 2^14 = 16,384` 个。B 类地址的主机号同样占 16 位，因此每个 B 类网络理论上可拥有 `2^16 = 65,536` 个主机地址。同样，除去代表网络本身（主机号全 `0`）和广播（主机号全 `1`）的两个保留地址，每个 B 类网络实际可分配的主机数量为 `65,536 - 2 = 65,534` 个。\n\n### C 类地址\n\nC 类地址的网络号占 24 位，其二进制前三位固定为 `110`，因此可用的 C 类网络总数高达 `2^(24-3) = 2^21 = 2,097,152` 个。C 类地址的主机号仅占 8 位，每个网络最多可容纳 `2^8 = 256` 个主机地址。在扣除用于网络标识和广播的两个保留地址后，每个 C 类网络实际上允许分配的主机数量为 `256 - 2 = 254` 个。\n\n### 特殊地址形式\n\n特殊的 IP 地址主要包括以下几种：\n\n- **直接广播地址 (Directed Broadcast)**\n\n直接广播地址是指主机号（host-id）部分全为 1 的地址。它用于向特定远程网络上的所有主机发送广播数据包。例如，若要向网络 201.161.20.0 上的所有主机广播，发送方需要将数据包的目的地址设置为该网络的直接广播地址 201.161.20.255。路由器在接收到此数据包后，会将其转发到目标网络进行广播。\n\n- **受限广播地址 (Limited Broadcast)**\n\n受限广播地址是一个固定的地址 255.255.255.255。它用于向主机所在的本地物理网络（即同一广播域内）的所有设备发送广播。与直接广播不同，路由器绝不会转发目的地址为 255.255.255.255 的数据包，从而将广播范围严格限制在本地网段内。\n\n- **“本网络上的特定主机”地址**\n\n这是一个网络号（net-id）部分全为 0 的地址，格式为 0.0.0.x。这种地址格式用于指代“本网络”上的某个特定主机。它通常在设备的启动阶段（如使用 BOOTP 或 DHCP 协议获取 IP 地址时）被使用，此时设备可能还不知道自己所在网络的网络号，但需要与本地网络上的某个服务器（如 DHCP 服务器）进行通信。\n\n- **回环地址 (Loopback Address)**\n\nA 类网络中的 127.0.0.0/8 网段被保留为回环地址。这类地址主要用于网络软件的测试以及同一台主机上不同进程间的通信。根据 TCP/IP 协议规定，任何目的地址为 127.0.0.0/8 的数据包都不会被发送到任何网络上，而是在操作系统内核的网络协议栈中被“环回”，直接发送给本机。最常用的回环地址是 127.0.0.1，通常被赋予主机名 localhost。\n\n## **专用 ip 地址与内部网络地址规划方法 **\n\n### 全局 IP 地址与专用 IP 地址\n\n- 全局 IP 地址与专用 IP 地址的区别：\n\n（1）使用 IP 地址的网络可以分为两种情况：一种是要将网络之间连到 Internet；另一种是也需要运行 TCP/IP 协议，但是它是内部网络，并不直接连接到 Internet，但网络内部用户访问 Internet 是受到严格控制的。\n\n（2）使用全局 IP 地址是需要申请的，而专用 IP 地址是不需要申请的。\n\n（3）全局 IP 地址必须保证在 Internet 上是唯一的；专用 IP 地址在某一个网络内部是唯一 的，但是在 Internet 中并不是唯一的。\n\n- 专用 IP 地址(私有地址)\n\nA 类：**10**.0.0.0～10.255.255.255\n\nB 类：**172.16**.0.0～**172.31**.255.255\n\nC 类：**192.168**.0.0～192.168.255.255\n\n## 公网 vs 私网\n\n![1749363931852LjYIbYN3Uo4ED1xRWxGcyqnanQh.png](https://gitee.com/tanke11223344/imagehost/raw/main/blog/1749363931852LjYIbYN3Uo4ED1xRWxGcyqnanQh.png)\n\n### 私有地址空间\n\nRFC 1918 定义三大私有网段，供企业/家庭网络内部使用，不在公网路由表中出现：\n\n- A 类：`10.0.0.0/8`（16,777,216 主机）\n- B 类：`172.16.0.0/12`（1,048,576 主机）\n- C 类：`192.168.0.0/16`（65,536 主机）\n\n### NAT 与 PAT\n\n私网访问互联网需通过 **NAT**（网络地址转换）或 **PAT**（端口地址转换）映射到公网 IP，保证内部地址不被外部路由学习 。\n\n- **静态 NAT**：一对一映射，适合服务器发布服务。\n- **动态 PAT**：多对一映射，使用端口区分，适合大量终端访问。\n\n### IPv4 与私有地址\n\nIPv4 地址由 32 位二进制构成，通常用点分十进制（如 192.168.1.0/24）表示 。\n\nRFC 1918 规定了三大私有地址块：10.0.0.0/8、172.16.0.0/12、192.168.0.0/16，仅限内部网络使用，不可在互联网上路由。\n\n在实际规划中，应优先采用私有网段以降低公开地址成本，并在边界路由器或 NAT 设备处做地址转换 。\n\n### IPv6 过渡考虑\n\n随着地址耗尽问题加剧，IPv6（128 位地址）正在逐步部署。常见做法是在新业务或数据中心网段使用 IPv6，同时保留 IPv4 私网以兼容旧设备 。\n\n规划 IPv6 前缀（/48、/56）时，也需考虑区域汇总与自治系统号分配，以免碎片化 。\n\n---\n\n## 设计原则\n\n### 层次化与路由聚合\n\n将地址空间按 **区域-楼层-部门** 分层划分，确保上层分配连续大块前缀可在骨干路由中做 **supernet** 汇总 。\n例如：校园网中，可将 10.10.0.0/16 划为 10.10.0.0/18（教学楼）、10.10.64.0/18（宿舍区）等，然后按楼层再细分 /24 子网 。\n\n### 可扩展性与预留\n\n在每个子网中预留至少 **25%–50%** 的地址池用于未来增长或临时接入 。\n对大型站点，应采用 **VLSM**（可变长子网掩码）精细分配，既节约地址又保持灵活性 。\n\n### 易管理与可识别\n\n子网编号应具有业务含义，如 10.1.10.0/24 代表“1 号楼 10 层”。\n\n文档化至关重要，建议使用 IPAM 工具记录子网、VLAN、DHCP 范围与分配策略，以便审计与冲突检测 。\n\n---\n\n## 规划方法\n\n1. 需求调研\n\n- 收集各办公区/数据中心/访客网的 **物理位置**、**设备数量**、**未来三年增长**预测和 **服务类型** 。\n- 按区域汇总并记录到表格，做子网大小初步估算。\n\n1. 地址池选择\n\n- **公网场景**：向 RIR（APNIC/ARIN 等）或云厂商（Azure、AWS）申请适当大小的 IPv4/IPv6 前缀 。\n- **私网场景**：优先使用 RFC 1918 地址，并在边界 NAT 设备上管理公网出口。\n\n1. 子网划分\n\n- 按每个区域/部门所需 **主机数** 选定合适掩码：\n\n  - ≤ 254 台 → /24，\n  - ≤ 510 台 → /23；\n  - ≥ 1000 台 → /22 或更大。\n- 使用 VLSM 将大块地址细分为多级子网，避免过度浪费 。\n\n1. 静态 vs 动态分配\n\n- **静态**：核心路由器、交换机管理接口、服务器、链路（/30）等关键设备使用固定 IP 。\n- **动态**：普通终端、打印机、访客等设备通过 DHCP 自动获取，减少人工配置出错 。\n\n1. 路由汇总与策略\n\n- 在骨干路由器上对区域前缀（如 10.10.0.0/18）做汇总，减少全网路由表项 。\n- 设置静态或 BGP 聚合路由，避免过细前缀被外部路由器学习。\n\n---\n\n## IPAM 工具与自动化\n\n1. 开源 IPAM\n\n- **phpIPAM**：内置扫描工具可发现并维持实际分配状态，适合小到中型网络 。\n- **NetBox**：强调“源自真相”，通过 API 驱动自动化分配，推荐作为“网络源型”工具。\n\n1. 云厂商托管 IPAM\n\n- **Azure IPAM**：集成在 Azure Portal，可跨订阅/区域跟踪私有前缀和公共地址 。\n- **AWS VPC IPAM**：支持多 VPC 地址池管理、配额警报与自动化调整 。\n\n1. 审计与报告\n\n- 定期使用 IPAM 工具生成地址使用率、冲突检测与过期租约报告，确保地址库健康 。\n\n---\n\n## 案例分析\n\n### 案例 1：高校园区网划分\n\n- **需求**：四栋教学楼（共 1200 台设备）、两栋宿舍楼（共 800 台设备）、数据中心及访客 WLAN。\n- **方案**：\n\n  1. 整体地址块 10.10.0.0/16；\n  2. 教学楼按楼层划分为 10.10.(1–4).0/20，每栋留 4 个 /22 子网；\n  3. 宿舍楼 10.10.64.0/21；\n  4. 数据中心 10.10.96.0/26；\n  5. 访客 WLAN 10.10.96.64/26，专用 DHCP 池每日回收。\n- **效果**：大区汇总为 10.10.0.0/16，仅需一条骨干路由 。\n\n### 案例 2：中型企业 IP 冲突整治\n\n- **背景**：静态分配与零散 DHCP 池导致频繁冲突，影响办公网络可用性。\n- **整改**：\n\n  1. 部署 **中央 DHCP** + 地址保留；\n  2. 使用 InterLIR 审计脚本扫描旧表并清理未用地址 ；\n  3. 核心/交换管理接口迁移至独立 /29 静态段。\n- **结果**：冲突率降至 0，网络可用率提升至 99.99%。\n\n### 案例 3：政府专网混合使用\n\n- **需求**：公网地址 59.223.0.0/16 用于骨干与边界，内网使用 10.0.0.0/8。\n- **方案**：\n\n  1. 骨干与边界服务：59.223.0.0/24；\n  2. 各部门办公：10.1.0.0/16，再细分 10.1.X.0/24；\n  3. 预留 3 个 /24 子网，支持未来扩容 。\n- **优势**：公网/私网隔离，NAT 配置集中，简化内部路由表并增强安全性。\n\n---\n\n# 总结\n\n1. **进制转换**是理解 IP 表示与子网划分的基础；\n2. **MAC 地址**由 IEEE 分配的 OUI 与厂商自定义部分构成，为二层交换提供通信标识；\n3. **IP 地址**分网络号与主机号，通过子网掩码确定可用主机范围；\n4. **IP 分类**（A/B/C/D/E 类）与**特殊地址**（广播、环回、APIPA）保证了网络分段与管理；\n5. **私网地址**结合 **NAT/PAT** 实现内外网互通，同时保持内部地址安全；\n6. 理解二层 MAC 与三层 IP 的**协作**（ARP 流程）是网络故障排查与优化的关键。\n","source":"_posts/2025-06-02-IP 地址规划及案例分析.md","raw":"---\ntitle:  2025-06-02-IP 地址规划及案例分析\ndate: 2025-06-02\ntags: \n    课程学习\n---\n# IP 地址规划及案例分析\n\n# 参考资料\n\n> - [Plan for IP addressing - Cloud Adoption Framework](https://learn.microsoft.com/en-us/azure/cloud-adoption-framework/ready/azure-best-practices/plan-for-ip-addressing?utm_source=chatgpt.com)\n> - [www.cnblogs.com](https://www.cnblogs.com/zhchoutai/p/6932604.html)\n> - [image-hosting/articles at master · jonsam-ng/image-hosting](https://github.com/jonsam-ng/image-hosting/tree/master/articles)\n\n# 概述\n\n在网络通信中，**MAC 地址**与 **IP 地址**分别位于 OSI 模型的数据链路层和网络层，二者协同完成从局域到广域的可靠互联。MAC 地址由 IEEE 分配的 OUI（组织唯一标识符）和厂商自定义部分构成，对应真实硬件；IP 地址则分为网络号与主机号，用以逻辑上定位主机并实现跨网段路由。\n\nIP 地址（Internet Protocol Address），缩写为 IP Adress，是一种在 Internet 上的给主机统一编址的地址格式，也称为网络协议（IP 协议）地址。它为互联网上的每一个网络和每一台主机分配一个逻辑地址，常见的 IP 地址，分为 IPv4 与 IPv6 两大类，当前广泛应用的是 IPv4，目前 IPv4 几乎耗尽，下一阶段必然会进行版本升级到 IPv6；如无特别注明，一般我们讲的的 IP 地址所指的是 IPv4。\n\n![1749363873852HlvKbpXGzoKjxBxn7Zoclw6Knjf.png](https://gitee.com/tanke11223344/imagehost/raw/main/blog/1749363873852HlvKbpXGzoKjxBxn7Zoclw6Knjf.png)\n\n## 进制转换回顾\n\n在理解 IP 地址（二进制）与点分十进制表示之前，必须熟练掌握二进制与十进制互转。\n\n![1749363883851MwwKbhLFVoIeQzxsXQUcS9TSnjh.png](https://gitee.com/tanke11223344/imagehost/raw/main/blog/1749363883851MwwKbhLFVoIeQzxsXQUcS9TSnjh.png)\n\n- **二进制权值**：第 n 位表示 2ⁿ。八位二进制可表示 0–255，共 2⁸ 种状态。\n- **示例**：`11010010₂ = 1·2⁷ +1·2⁶+0·2⁵+1·2⁴+0·2³+0·2²+1·2¹+0·2⁰ = 128+64+16+2 = 210`。\n  掌握“相邻位权值相差两倍”规律，可快速记忆 2⁰–2⁷ 的所有幂值。\n\n## MAC 地址（数据链路层）\n\n### 组成与格式\n\n- **长度**：48 位（二进制），通常写作 6 个字节的十六进制，用冒号或中划线分隔，如 `AC:DE:48:23:45:67`。\n- **结构**：前 24 位为 OUI（Organizationally Unique Identifier），由 IEEE 分配，标识厂家；后 24 位是厂商自行分配的扩展标识符，用以唯一定位网卡。\n- **示例**：OUI `AC-DE-48` 可能对应某厂商生产的设备，其余 24 位由该厂商自由定义。\n\n### 功能与用途\n\n- **帧转发**：交换机根据数据帧头部的目标 MAC 地址在 CAM 表中查找对应端口，实现二层转发。\n- **设备识别**：在安全和取证场景，可通过 OUI 识别厂商及设备类型。\n\n## IP 地址（网络层）\n\n### IPv4 格式与点分十进制\n\n![1749363894091BwTFbPQc1oFOhKxYbGwcq5RmnGf.png](https://gitee.com/tanke11223344/imagehost/raw/main/blog/1749363894091BwTFbPQc1oFOhKxYbGwcq5RmnGf.png)\n\n- **32 位地址**由四段 8 位二进制组成，每段转换为 0–255 的十进制，使用“点”分隔，如 `192.168.1.1`。\n- **网/主分界**：通过子网掩码（如 `255.255.255.0` 或 `/24`）区分网络号与主机号。\n\n![1749363900852GyfsbRbmGojzzwxUYr9ca4OVnEg.png](https://gitee.com/tanke11223344/imagehost/raw/main/blog/1749363900852GyfsbRbmGojzzwxUYr9ca4OVnEg.png)\n\n### IP 与 MAC 的协作\n\n- **ARP** 协议：主机先判断目标 IP 是否与自身在同一子网；若不同，则将下一跳路由器的 MAC 用于帧封装；若相同，则直接将目标主机 MAC 用于帧封装。\n\n![1749363908852I8SCbAE7WoWf71xo1sBcUdNGndf.png](https://gitee.com/tanke11223344/imagehost/raw/main/blog/1749363908852I8SCbAE7WoWf71xo1sBcUdNGndf.png)\n\n- **过程**：\n  1. 网络层生成包含源/目标 IP 的数据包；\n  2. 数据链路层封装源/目标 MAC，并在局域内通信；\n  3. 路由器根据 IP 决定下一跳，MAC 则由 ARP 动态解析。\n\n---\n\n## IPv4 地址分类\n\nIPv4 按首字节前缀分为五类：A/B/C 类用于主机寻址，D 类用于多播，E 类保留。\n\n![1749363916852LDaWb0dWrojXS8xdRK0cMcQOnNb.png](https://gitee.com/tanke11223344/imagehost/raw/main/blog/1749363916852LDaWb0dWrojXS8xdRK0cMcQOnNb.png)\n\n- **网络地址**：主机 ID 全 0（如 `192.168.1.0`）。\n- **广播地址**：主机 ID 全 1（如 `192.168.1.255`）。\n- **环回地址**：`127.0.0.1`，测试本机网络堆栈。\n- **自动私有 IP**：`169.254.0.0–169.254.255.255`，DHCP 失败时自动生成。\n- **全 0/全 1**：`0.0.0.0`、`255.255.255.255` 用于内部通信及本地广播。\n\n### A 类地址\n\nA 类地址的网络号（net-id）占 8 位，且其二进制第一位固定为 `0`，因此 A 类网络的网络号范围为 0 至 127，共计 128 个网络。\n\n- **网络号 0**（地址范围 `0.0.0.0` ~ `0.255.255.255`）被保留，用于表示“本网络”。\n- **网络号 127**（地址范围 `127.0.0.0` ~ `127.255.255.255`）被保留，用作环回测试地址。\n- **网络号 10**（地址范围 `10.0.0.0` ~ `10.255.255.255`）被指定为私有地址，用于内部网络。\n\n除去这些特殊用途的网络，实际可公开分配的 A 类网络共有 125 个（从网络号 1 到 126，再除去网络号 10）。每一个 A 类网络的主机号（host-id）占 24 位，理论上可分配 `2^24` 个主机地址。但由于主机号全为 `0` 的地址代表网络本身，全为 `1` 的地址代表网络广播地址，这两个地址需被保留，因此每个 A 类网络实际可用的主机数量为 `2^24 - 2 = 16,777,214` 个。\n\n### B 类地址\n\nB 类地址的网络号占 16 位，且其二进制前两位固定为 `10`，这使得 B 类网络的数量为 `2^(16-2) = 2^14 = 16,384` 个。B 类地址的主机号同样占 16 位，因此每个 B 类网络理论上可拥有 `2^16 = 65,536` 个主机地址。同样，除去代表网络本身（主机号全 `0`）和广播（主机号全 `1`）的两个保留地址，每个 B 类网络实际可分配的主机数量为 `65,536 - 2 = 65,534` 个。\n\n### C 类地址\n\nC 类地址的网络号占 24 位，其二进制前三位固定为 `110`，因此可用的 C 类网络总数高达 `2^(24-3) = 2^21 = 2,097,152` 个。C 类地址的主机号仅占 8 位，每个网络最多可容纳 `2^8 = 256` 个主机地址。在扣除用于网络标识和广播的两个保留地址后，每个 C 类网络实际上允许分配的主机数量为 `256 - 2 = 254` 个。\n\n### 特殊地址形式\n\n特殊的 IP 地址主要包括以下几种：\n\n- **直接广播地址 (Directed Broadcast)**\n\n直接广播地址是指主机号（host-id）部分全为 1 的地址。它用于向特定远程网络上的所有主机发送广播数据包。例如，若要向网络 201.161.20.0 上的所有主机广播，发送方需要将数据包的目的地址设置为该网络的直接广播地址 201.161.20.255。路由器在接收到此数据包后，会将其转发到目标网络进行广播。\n\n- **受限广播地址 (Limited Broadcast)**\n\n受限广播地址是一个固定的地址 255.255.255.255。它用于向主机所在的本地物理网络（即同一广播域内）的所有设备发送广播。与直接广播不同，路由器绝不会转发目的地址为 255.255.255.255 的数据包，从而将广播范围严格限制在本地网段内。\n\n- **“本网络上的特定主机”地址**\n\n这是一个网络号（net-id）部分全为 0 的地址，格式为 0.0.0.x。这种地址格式用于指代“本网络”上的某个特定主机。它通常在设备的启动阶段（如使用 BOOTP 或 DHCP 协议获取 IP 地址时）被使用，此时设备可能还不知道自己所在网络的网络号，但需要与本地网络上的某个服务器（如 DHCP 服务器）进行通信。\n\n- **回环地址 (Loopback Address)**\n\nA 类网络中的 127.0.0.0/8 网段被保留为回环地址。这类地址主要用于网络软件的测试以及同一台主机上不同进程间的通信。根据 TCP/IP 协议规定，任何目的地址为 127.0.0.0/8 的数据包都不会被发送到任何网络上，而是在操作系统内核的网络协议栈中被“环回”，直接发送给本机。最常用的回环地址是 127.0.0.1，通常被赋予主机名 localhost。\n\n## **专用 ip 地址与内部网络地址规划方法 **\n\n### 全局 IP 地址与专用 IP 地址\n\n- 全局 IP 地址与专用 IP 地址的区别：\n\n（1）使用 IP 地址的网络可以分为两种情况：一种是要将网络之间连到 Internet；另一种是也需要运行 TCP/IP 协议，但是它是内部网络，并不直接连接到 Internet，但网络内部用户访问 Internet 是受到严格控制的。\n\n（2）使用全局 IP 地址是需要申请的，而专用 IP 地址是不需要申请的。\n\n（3）全局 IP 地址必须保证在 Internet 上是唯一的；专用 IP 地址在某一个网络内部是唯一 的，但是在 Internet 中并不是唯一的。\n\n- 专用 IP 地址(私有地址)\n\nA 类：**10**.0.0.0～10.255.255.255\n\nB 类：**172.16**.0.0～**172.31**.255.255\n\nC 类：**192.168**.0.0～192.168.255.255\n\n## 公网 vs 私网\n\n![1749363931852LjYIbYN3Uo4ED1xRWxGcyqnanQh.png](https://gitee.com/tanke11223344/imagehost/raw/main/blog/1749363931852LjYIbYN3Uo4ED1xRWxGcyqnanQh.png)\n\n### 私有地址空间\n\nRFC 1918 定义三大私有网段，供企业/家庭网络内部使用，不在公网路由表中出现：\n\n- A 类：`10.0.0.0/8`（16,777,216 主机）\n- B 类：`172.16.0.0/12`（1,048,576 主机）\n- C 类：`192.168.0.0/16`（65,536 主机）\n\n### NAT 与 PAT\n\n私网访问互联网需通过 **NAT**（网络地址转换）或 **PAT**（端口地址转换）映射到公网 IP，保证内部地址不被外部路由学习 。\n\n- **静态 NAT**：一对一映射，适合服务器发布服务。\n- **动态 PAT**：多对一映射，使用端口区分，适合大量终端访问。\n\n### IPv4 与私有地址\n\nIPv4 地址由 32 位二进制构成，通常用点分十进制（如 192.168.1.0/24）表示 。\n\nRFC 1918 规定了三大私有地址块：10.0.0.0/8、172.16.0.0/12、192.168.0.0/16，仅限内部网络使用，不可在互联网上路由。\n\n在实际规划中，应优先采用私有网段以降低公开地址成本，并在边界路由器或 NAT 设备处做地址转换 。\n\n### IPv6 过渡考虑\n\n随着地址耗尽问题加剧，IPv6（128 位地址）正在逐步部署。常见做法是在新业务或数据中心网段使用 IPv6，同时保留 IPv4 私网以兼容旧设备 。\n\n规划 IPv6 前缀（/48、/56）时，也需考虑区域汇总与自治系统号分配，以免碎片化 。\n\n---\n\n## 设计原则\n\n### 层次化与路由聚合\n\n将地址空间按 **区域-楼层-部门** 分层划分，确保上层分配连续大块前缀可在骨干路由中做 **supernet** 汇总 。\n例如：校园网中，可将 10.10.0.0/16 划为 10.10.0.0/18（教学楼）、10.10.64.0/18（宿舍区）等，然后按楼层再细分 /24 子网 。\n\n### 可扩展性与预留\n\n在每个子网中预留至少 **25%–50%** 的地址池用于未来增长或临时接入 。\n对大型站点，应采用 **VLSM**（可变长子网掩码）精细分配，既节约地址又保持灵活性 。\n\n### 易管理与可识别\n\n子网编号应具有业务含义，如 10.1.10.0/24 代表“1 号楼 10 层”。\n\n文档化至关重要，建议使用 IPAM 工具记录子网、VLAN、DHCP 范围与分配策略，以便审计与冲突检测 。\n\n---\n\n## 规划方法\n\n1. 需求调研\n\n- 收集各办公区/数据中心/访客网的 **物理位置**、**设备数量**、**未来三年增长**预测和 **服务类型** 。\n- 按区域汇总并记录到表格，做子网大小初步估算。\n\n1. 地址池选择\n\n- **公网场景**：向 RIR（APNIC/ARIN 等）或云厂商（Azure、AWS）申请适当大小的 IPv4/IPv6 前缀 。\n- **私网场景**：优先使用 RFC 1918 地址，并在边界 NAT 设备上管理公网出口。\n\n1. 子网划分\n\n- 按每个区域/部门所需 **主机数** 选定合适掩码：\n\n  - ≤ 254 台 → /24，\n  - ≤ 510 台 → /23；\n  - ≥ 1000 台 → /22 或更大。\n- 使用 VLSM 将大块地址细分为多级子网，避免过度浪费 。\n\n1. 静态 vs 动态分配\n\n- **静态**：核心路由器、交换机管理接口、服务器、链路（/30）等关键设备使用固定 IP 。\n- **动态**：普通终端、打印机、访客等设备通过 DHCP 自动获取，减少人工配置出错 。\n\n1. 路由汇总与策略\n\n- 在骨干路由器上对区域前缀（如 10.10.0.0/18）做汇总，减少全网路由表项 。\n- 设置静态或 BGP 聚合路由，避免过细前缀被外部路由器学习。\n\n---\n\n## IPAM 工具与自动化\n\n1. 开源 IPAM\n\n- **phpIPAM**：内置扫描工具可发现并维持实际分配状态，适合小到中型网络 。\n- **NetBox**：强调“源自真相”，通过 API 驱动自动化分配，推荐作为“网络源型”工具。\n\n1. 云厂商托管 IPAM\n\n- **Azure IPAM**：集成在 Azure Portal，可跨订阅/区域跟踪私有前缀和公共地址 。\n- **AWS VPC IPAM**：支持多 VPC 地址池管理、配额警报与自动化调整 。\n\n1. 审计与报告\n\n- 定期使用 IPAM 工具生成地址使用率、冲突检测与过期租约报告，确保地址库健康 。\n\n---\n\n## 案例分析\n\n### 案例 1：高校园区网划分\n\n- **需求**：四栋教学楼（共 1200 台设备）、两栋宿舍楼（共 800 台设备）、数据中心及访客 WLAN。\n- **方案**：\n\n  1. 整体地址块 10.10.0.0/16；\n  2. 教学楼按楼层划分为 10.10.(1–4).0/20，每栋留 4 个 /22 子网；\n  3. 宿舍楼 10.10.64.0/21；\n  4. 数据中心 10.10.96.0/26；\n  5. 访客 WLAN 10.10.96.64/26，专用 DHCP 池每日回收。\n- **效果**：大区汇总为 10.10.0.0/16，仅需一条骨干路由 。\n\n### 案例 2：中型企业 IP 冲突整治\n\n- **背景**：静态分配与零散 DHCP 池导致频繁冲突，影响办公网络可用性。\n- **整改**：\n\n  1. 部署 **中央 DHCP** + 地址保留；\n  2. 使用 InterLIR 审计脚本扫描旧表并清理未用地址 ；\n  3. 核心/交换管理接口迁移至独立 /29 静态段。\n- **结果**：冲突率降至 0，网络可用率提升至 99.99%。\n\n### 案例 3：政府专网混合使用\n\n- **需求**：公网地址 59.223.0.0/16 用于骨干与边界，内网使用 10.0.0.0/8。\n- **方案**：\n\n  1. 骨干与边界服务：59.223.0.0/24；\n  2. 各部门办公：10.1.0.0/16，再细分 10.1.X.0/24；\n  3. 预留 3 个 /24 子网，支持未来扩容 。\n- **优势**：公网/私网隔离，NAT 配置集中，简化内部路由表并增强安全性。\n\n---\n\n# 总结\n\n1. **进制转换**是理解 IP 表示与子网划分的基础；\n2. **MAC 地址**由 IEEE 分配的 OUI 与厂商自定义部分构成，为二层交换提供通信标识；\n3. **IP 地址**分网络号与主机号，通过子网掩码确定可用主机范围；\n4. **IP 分类**（A/B/C/D/E 类）与**特殊地址**（广播、环回、APIPA）保证了网络分段与管理；\n5. **私网地址**结合 **NAT/PAT** 实现内外网互通，同时保持内部地址安全；\n6. 理解二层 MAC 与三层 IP 的**协作**（ARP 流程）是网络故障排查与优化的关键。\n","slug":"2025-06-02-IP 地址规划及案例分析","published":1,"updated":"2025-09-26T12:18:08.131Z","_id":"cmg0saj4f002ojm8n0a1pabro","comments":1,"layout":"post","photos":[],"content":"<h1 id=\"IP-地址规划及案例分析\"><a href=\"#IP-地址规划及案例分析\" class=\"headerlink\" title=\"IP 地址规划及案例分析\"></a>IP 地址规划及案例分析</h1><h1 id=\"参考资料\"><a href=\"#参考资料\" class=\"headerlink\" title=\"参考资料\"></a>参考资料</h1><blockquote>\n<ul>\n<li><a href=\"https://learn.microsoft.com/en-us/azure/cloud-adoption-framework/ready/azure-best-practices/plan-for-ip-addressing?utm_source=chatgpt.com\">Plan for IP addressing - Cloud Adoption Framework</a></li>\n<li><a href=\"https://www.cnblogs.com/zhchoutai/p/6932604.html\">www.cnblogs.com</a></li>\n<li><a href=\"https://github.com/jonsam-ng/image-hosting/tree/master/articles\">image-hosting&#x2F;articles at master · jonsam-ng&#x2F;image-hosting</a></li>\n</ul>\n</blockquote>\n<h1 id=\"概述\"><a href=\"#概述\" class=\"headerlink\" title=\"概述\"></a>概述</h1><p>在网络通信中，<strong>MAC 地址</strong>与 <strong>IP 地址</strong>分别位于 OSI 模型的数据链路层和网络层，二者协同完成从局域到广域的可靠互联。MAC 地址由 IEEE 分配的 OUI（组织唯一标识符）和厂商自定义部分构成，对应真实硬件；IP 地址则分为网络号与主机号，用以逻辑上定位主机并实现跨网段路由。</p>\n<p>IP 地址（Internet Protocol Address），缩写为 IP Adress，是一种在 Internet 上的给主机统一编址的地址格式，也称为网络协议（IP 协议）地址。它为互联网上的每一个网络和每一台主机分配一个逻辑地址，常见的 IP 地址，分为 IPv4 与 IPv6 两大类，当前广泛应用的是 IPv4，目前 IPv4 几乎耗尽，下一阶段必然会进行版本升级到 IPv6；如无特别注明，一般我们讲的的 IP 地址所指的是 IPv4。</p>\n<p><img src=\"https://gitee.com/tanke11223344/imagehost/raw/main/blog/1749363873852HlvKbpXGzoKjxBxn7Zoclw6Knjf.png\" alt=\"1749363873852HlvKbpXGzoKjxBxn7Zoclw6Knjf.png\"></p>\n<h2 id=\"进制转换回顾\"><a href=\"#进制转换回顾\" class=\"headerlink\" title=\"进制转换回顾\"></a>进制转换回顾</h2><p>在理解 IP 地址（二进制）与点分十进制表示之前，必须熟练掌握二进制与十进制互转。</p>\n<p><img src=\"https://gitee.com/tanke11223344/imagehost/raw/main/blog/1749363883851MwwKbhLFVoIeQzxsXQUcS9TSnjh.png\" alt=\"1749363883851MwwKbhLFVoIeQzxsXQUcS9TSnjh.png\"></p>\n<ul>\n<li><strong>二进制权值</strong>：第 n 位表示 2ⁿ。八位二进制可表示 0–255，共 2⁸ 种状态。</li>\n<li><strong>示例</strong>：<code>11010010₂ = 1·2⁷ +1·2⁶+0·2⁵+1·2⁴+0·2³+0·2²+1·2¹+0·2⁰ = 128+64+16+2 = 210</code>。<br>掌握“相邻位权值相差两倍”规律，可快速记忆 2⁰–2⁷ 的所有幂值。</li>\n</ul>\n<h2 id=\"MAC-地址（数据链路层）\"><a href=\"#MAC-地址（数据链路层）\" class=\"headerlink\" title=\"MAC 地址（数据链路层）\"></a>MAC 地址（数据链路层）</h2><h3 id=\"组成与格式\"><a href=\"#组成与格式\" class=\"headerlink\" title=\"组成与格式\"></a>组成与格式</h3><ul>\n<li><strong>长度</strong>：48 位（二进制），通常写作 6 个字节的十六进制，用冒号或中划线分隔，如 <code>AC:DE:48:23:45:67</code>。</li>\n<li><strong>结构</strong>：前 24 位为 OUI（Organizationally Unique Identifier），由 IEEE 分配，标识厂家；后 24 位是厂商自行分配的扩展标识符，用以唯一定位网卡。</li>\n<li><strong>示例</strong>：OUI <code>AC-DE-48</code> 可能对应某厂商生产的设备，其余 24 位由该厂商自由定义。</li>\n</ul>\n<h3 id=\"功能与用途\"><a href=\"#功能与用途\" class=\"headerlink\" title=\"功能与用途\"></a>功能与用途</h3><ul>\n<li><strong>帧转发</strong>：交换机根据数据帧头部的目标 MAC 地址在 CAM 表中查找对应端口，实现二层转发。</li>\n<li><strong>设备识别</strong>：在安全和取证场景，可通过 OUI 识别厂商及设备类型。</li>\n</ul>\n<h2 id=\"IP-地址（网络层）\"><a href=\"#IP-地址（网络层）\" class=\"headerlink\" title=\"IP 地址（网络层）\"></a>IP 地址（网络层）</h2><h3 id=\"IPv4-格式与点分十进制\"><a href=\"#IPv4-格式与点分十进制\" class=\"headerlink\" title=\"IPv4 格式与点分十进制\"></a>IPv4 格式与点分十进制</h3><p><img src=\"https://gitee.com/tanke11223344/imagehost/raw/main/blog/1749363894091BwTFbPQc1oFOhKxYbGwcq5RmnGf.png\" alt=\"1749363894091BwTFbPQc1oFOhKxYbGwcq5RmnGf.png\"></p>\n<ul>\n<li><strong>32 位地址</strong>由四段 8 位二进制组成，每段转换为 0–255 的十进制，使用“点”分隔，如 <code>192.168.1.1</code>。</li>\n<li><strong>网&#x2F;主分界</strong>：通过子网掩码（如 <code>255.255.255.0</code> 或 <code>/24</code>）区分网络号与主机号。</li>\n</ul>\n<p><img src=\"https://gitee.com/tanke11223344/imagehost/raw/main/blog/1749363900852GyfsbRbmGojzzwxUYr9ca4OVnEg.png\" alt=\"1749363900852GyfsbRbmGojzzwxUYr9ca4OVnEg.png\"></p>\n<h3 id=\"IP-与-MAC-的协作\"><a href=\"#IP-与-MAC-的协作\" class=\"headerlink\" title=\"IP 与 MAC 的协作\"></a>IP 与 MAC 的协作</h3><ul>\n<li><strong>ARP</strong> 协议：主机先判断目标 IP 是否与自身在同一子网；若不同，则将下一跳路由器的 MAC 用于帧封装；若相同，则直接将目标主机 MAC 用于帧封装。</li>\n</ul>\n<p><img src=\"https://gitee.com/tanke11223344/imagehost/raw/main/blog/1749363908852I8SCbAE7WoWf71xo1sBcUdNGndf.png\" alt=\"1749363908852I8SCbAE7WoWf71xo1sBcUdNGndf.png\"></p>\n<ul>\n<li><strong>过程</strong>：<ol>\n<li>网络层生成包含源&#x2F;目标 IP 的数据包；</li>\n<li>数据链路层封装源&#x2F;目标 MAC，并在局域内通信；</li>\n<li>路由器根据 IP 决定下一跳，MAC 则由 ARP 动态解析。</li>\n</ol>\n</li>\n</ul>\n<hr>\n<h2 id=\"IPv4-地址分类\"><a href=\"#IPv4-地址分类\" class=\"headerlink\" title=\"IPv4 地址分类\"></a>IPv4 地址分类</h2><p>IPv4 按首字节前缀分为五类：A&#x2F;B&#x2F;C 类用于主机寻址，D 类用于多播，E 类保留。</p>\n<p><img src=\"https://gitee.com/tanke11223344/imagehost/raw/main/blog/1749363916852LDaWb0dWrojXS8xdRK0cMcQOnNb.png\" alt=\"1749363916852LDaWb0dWrojXS8xdRK0cMcQOnNb.png\"></p>\n<ul>\n<li><strong>网络地址</strong>：主机 ID 全 0（如 <code>192.168.1.0</code>）。</li>\n<li><strong>广播地址</strong>：主机 ID 全 1（如 <code>192.168.1.255</code>）。</li>\n<li><strong>环回地址</strong>：<code>127.0.0.1</code>，测试本机网络堆栈。</li>\n<li><strong>自动私有 IP</strong>：<code>169.254.0.0–169.254.255.255</code>，DHCP 失败时自动生成。</li>\n<li><strong>全 0&#x2F;全 1</strong>：<code>0.0.0.0</code>、<code>255.255.255.255</code> 用于内部通信及本地广播。</li>\n</ul>\n<h3 id=\"A-类地址\"><a href=\"#A-类地址\" class=\"headerlink\" title=\"A 类地址\"></a>A 类地址</h3><p>A 类地址的网络号（net-id）占 8 位，且其二进制第一位固定为 <code>0</code>，因此 A 类网络的网络号范围为 0 至 127，共计 128 个网络。</p>\n<ul>\n<li><strong>网络号 0</strong>（地址范围 <code>0.0.0.0</code> ~ <code>0.255.255.255</code>）被保留，用于表示“本网络”。</li>\n<li><strong>网络号 127</strong>（地址范围 <code>127.0.0.0</code> ~ <code>127.255.255.255</code>）被保留，用作环回测试地址。</li>\n<li><strong>网络号 10</strong>（地址范围 <code>10.0.0.0</code> ~ <code>10.255.255.255</code>）被指定为私有地址，用于内部网络。</li>\n</ul>\n<p>除去这些特殊用途的网络，实际可公开分配的 A 类网络共有 125 个（从网络号 1 到 126，再除去网络号 10）。每一个 A 类网络的主机号（host-id）占 24 位，理论上可分配 <code>2^24</code> 个主机地址。但由于主机号全为 <code>0</code> 的地址代表网络本身，全为 <code>1</code> 的地址代表网络广播地址，这两个地址需被保留，因此每个 A 类网络实际可用的主机数量为 <code>2^24 - 2 = 16,777,214</code> 个。</p>\n<h3 id=\"B-类地址\"><a href=\"#B-类地址\" class=\"headerlink\" title=\"B 类地址\"></a>B 类地址</h3><p>B 类地址的网络号占 16 位，且其二进制前两位固定为 <code>10</code>，这使得 B 类网络的数量为 <code>2^(16-2) = 2^14 = 16,384</code> 个。B 类地址的主机号同样占 16 位，因此每个 B 类网络理论上可拥有 <code>2^16 = 65,536</code> 个主机地址。同样，除去代表网络本身（主机号全 <code>0</code>）和广播（主机号全 <code>1</code>）的两个保留地址，每个 B 类网络实际可分配的主机数量为 <code>65,536 - 2 = 65,534</code> 个。</p>\n<h3 id=\"C-类地址\"><a href=\"#C-类地址\" class=\"headerlink\" title=\"C 类地址\"></a>C 类地址</h3><p>C 类地址的网络号占 24 位，其二进制前三位固定为 <code>110</code>，因此可用的 C 类网络总数高达 <code>2^(24-3) = 2^21 = 2,097,152</code> 个。C 类地址的主机号仅占 8 位，每个网络最多可容纳 <code>2^8 = 256</code> 个主机地址。在扣除用于网络标识和广播的两个保留地址后，每个 C 类网络实际上允许分配的主机数量为 <code>256 - 2 = 254</code> 个。</p>\n<h3 id=\"特殊地址形式\"><a href=\"#特殊地址形式\" class=\"headerlink\" title=\"特殊地址形式\"></a>特殊地址形式</h3><p>特殊的 IP 地址主要包括以下几种：</p>\n<ul>\n<li><strong>直接广播地址 (Directed Broadcast)</strong></li>\n</ul>\n<p>直接广播地址是指主机号（host-id）部分全为 1 的地址。它用于向特定远程网络上的所有主机发送广播数据包。例如，若要向网络 201.161.20.0 上的所有主机广播，发送方需要将数据包的目的地址设置为该网络的直接广播地址 201.161.20.255。路由器在接收到此数据包后，会将其转发到目标网络进行广播。</p>\n<ul>\n<li><strong>受限广播地址 (Limited Broadcast)</strong></li>\n</ul>\n<p>受限广播地址是一个固定的地址 255.255.255.255。它用于向主机所在的本地物理网络（即同一广播域内）的所有设备发送广播。与直接广播不同，路由器绝不会转发目的地址为 255.255.255.255 的数据包，从而将广播范围严格限制在本地网段内。</p>\n<ul>\n<li><strong>“本网络上的特定主机”地址</strong></li>\n</ul>\n<p>这是一个网络号（net-id）部分全为 0 的地址，格式为 0.0.0.x。这种地址格式用于指代“本网络”上的某个特定主机。它通常在设备的启动阶段（如使用 BOOTP 或 DHCP 协议获取 IP 地址时）被使用，此时设备可能还不知道自己所在网络的网络号，但需要与本地网络上的某个服务器（如 DHCP 服务器）进行通信。</p>\n<ul>\n<li><strong>回环地址 (Loopback Address)</strong></li>\n</ul>\n<p>A 类网络中的 127.0.0.0&#x2F;8 网段被保留为回环地址。这类地址主要用于网络软件的测试以及同一台主机上不同进程间的通信。根据 TCP&#x2F;IP 协议规定，任何目的地址为 127.0.0.0&#x2F;8 的数据包都不会被发送到任何网络上，而是在操作系统内核的网络协议栈中被“环回”，直接发送给本机。最常用的回环地址是 127.0.0.1，通常被赋予主机名 localhost。</p>\n<h2 id=\"专用-ip-地址与内部网络地址规划方法\"><a href=\"#专用-ip-地址与内部网络地址规划方法\" class=\"headerlink\" title=\"**专用 ip 地址与内部网络地址规划方法 **\"></a>**专用 ip 地址与内部网络地址规划方法 **</h2><h3 id=\"全局-IP-地址与专用-IP-地址\"><a href=\"#全局-IP-地址与专用-IP-地址\" class=\"headerlink\" title=\"全局 IP 地址与专用 IP 地址\"></a>全局 IP 地址与专用 IP 地址</h3><ul>\n<li>全局 IP 地址与专用 IP 地址的区别：</li>\n</ul>\n<p>（1）使用 IP 地址的网络可以分为两种情况：一种是要将网络之间连到 Internet；另一种是也需要运行 TCP&#x2F;IP 协议，但是它是内部网络，并不直接连接到 Internet，但网络内部用户访问 Internet 是受到严格控制的。</p>\n<p>（2）使用全局 IP 地址是需要申请的，而专用 IP 地址是不需要申请的。</p>\n<p>（3）全局 IP 地址必须保证在 Internet 上是唯一的；专用 IP 地址在某一个网络内部是唯一 的，但是在 Internet 中并不是唯一的。</p>\n<ul>\n<li>专用 IP 地址(私有地址)</li>\n</ul>\n<p>A 类：<strong>10</strong>.0.0.0～10.255.255.255</p>\n<p>B 类：<strong>172.16</strong>.0.0～<strong>172.31</strong>.255.255</p>\n<p>C 类：<strong>192.168</strong>.0.0～192.168.255.255</p>\n<h2 id=\"公网-vs-私网\"><a href=\"#公网-vs-私网\" class=\"headerlink\" title=\"公网 vs 私网\"></a>公网 vs 私网</h2><p><img src=\"https://gitee.com/tanke11223344/imagehost/raw/main/blog/1749363931852LjYIbYN3Uo4ED1xRWxGcyqnanQh.png\" alt=\"1749363931852LjYIbYN3Uo4ED1xRWxGcyqnanQh.png\"></p>\n<h3 id=\"私有地址空间\"><a href=\"#私有地址空间\" class=\"headerlink\" title=\"私有地址空间\"></a>私有地址空间</h3><p>RFC 1918 定义三大私有网段，供企业&#x2F;家庭网络内部使用，不在公网路由表中出现：</p>\n<ul>\n<li>A 类：<code>10.0.0.0/8</code>（16,777,216 主机）</li>\n<li>B 类：<code>172.16.0.0/12</code>（1,048,576 主机）</li>\n<li>C 类：<code>192.168.0.0/16</code>（65,536 主机）</li>\n</ul>\n<h3 id=\"NAT-与-PAT\"><a href=\"#NAT-与-PAT\" class=\"headerlink\" title=\"NAT 与 PAT\"></a>NAT 与 PAT</h3><p>私网访问互联网需通过 <strong>NAT</strong>（网络地址转换）或 <strong>PAT</strong>（端口地址转换）映射到公网 IP，保证内部地址不被外部路由学习 。</p>\n<ul>\n<li><strong>静态 NAT</strong>：一对一映射，适合服务器发布服务。</li>\n<li><strong>动态 PAT</strong>：多对一映射，使用端口区分，适合大量终端访问。</li>\n</ul>\n<h3 id=\"IPv4-与私有地址\"><a href=\"#IPv4-与私有地址\" class=\"headerlink\" title=\"IPv4 与私有地址\"></a>IPv4 与私有地址</h3><p>IPv4 地址由 32 位二进制构成，通常用点分十进制（如 192.168.1.0&#x2F;24）表示 。</p>\n<p>RFC 1918 规定了三大私有地址块：10.0.0.0&#x2F;8、172.16.0.0&#x2F;12、192.168.0.0&#x2F;16，仅限内部网络使用，不可在互联网上路由。</p>\n<p>在实际规划中，应优先采用私有网段以降低公开地址成本，并在边界路由器或 NAT 设备处做地址转换 。</p>\n<h3 id=\"IPv6-过渡考虑\"><a href=\"#IPv6-过渡考虑\" class=\"headerlink\" title=\"IPv6 过渡考虑\"></a>IPv6 过渡考虑</h3><p>随着地址耗尽问题加剧，IPv6（128 位地址）正在逐步部署。常见做法是在新业务或数据中心网段使用 IPv6，同时保留 IPv4 私网以兼容旧设备 。</p>\n<p>规划 IPv6 前缀（&#x2F;48、&#x2F;56）时，也需考虑区域汇总与自治系统号分配，以免碎片化 。</p>\n<hr>\n<h2 id=\"设计原则\"><a href=\"#设计原则\" class=\"headerlink\" title=\"设计原则\"></a>设计原则</h2><h3 id=\"层次化与路由聚合\"><a href=\"#层次化与路由聚合\" class=\"headerlink\" title=\"层次化与路由聚合\"></a>层次化与路由聚合</h3><p>将地址空间按 <strong>区域-楼层-部门</strong> 分层划分，确保上层分配连续大块前缀可在骨干路由中做 <strong>supernet</strong> 汇总 。<br>例如：校园网中，可将 10.10.0.0&#x2F;16 划为 10.10.0.0&#x2F;18（教学楼）、10.10.64.0&#x2F;18（宿舍区）等，然后按楼层再细分 &#x2F;24 子网 。</p>\n<h3 id=\"可扩展性与预留\"><a href=\"#可扩展性与预留\" class=\"headerlink\" title=\"可扩展性与预留\"></a>可扩展性与预留</h3><p>在每个子网中预留至少 <strong>25%–50%</strong> 的地址池用于未来增长或临时接入 。<br>对大型站点，应采用 <strong>VLSM</strong>（可变长子网掩码）精细分配，既节约地址又保持灵活性 。</p>\n<h3 id=\"易管理与可识别\"><a href=\"#易管理与可识别\" class=\"headerlink\" title=\"易管理与可识别\"></a>易管理与可识别</h3><p>子网编号应具有业务含义，如 10.1.10.0&#x2F;24 代表“1 号楼 10 层”。</p>\n<p>文档化至关重要，建议使用 IPAM 工具记录子网、VLAN、DHCP 范围与分配策略，以便审计与冲突检测 。</p>\n<hr>\n<h2 id=\"规划方法\"><a href=\"#规划方法\" class=\"headerlink\" title=\"规划方法\"></a>规划方法</h2><ol>\n<li>需求调研</li>\n</ol>\n<ul>\n<li>收集各办公区&#x2F;数据中心&#x2F;访客网的 <strong>物理位置</strong>、<strong>设备数量</strong>、<strong>未来三年增长</strong>预测和 <strong>服务类型</strong> 。</li>\n<li>按区域汇总并记录到表格，做子网大小初步估算。</li>\n</ul>\n<ol>\n<li>地址池选择</li>\n</ol>\n<ul>\n<li><strong>公网场景</strong>：向 RIR（APNIC&#x2F;ARIN 等）或云厂商（Azure、AWS）申请适当大小的 IPv4&#x2F;IPv6 前缀 。</li>\n<li><strong>私网场景</strong>：优先使用 RFC 1918 地址，并在边界 NAT 设备上管理公网出口。</li>\n</ul>\n<ol>\n<li>子网划分</li>\n</ol>\n<ul>\n<li><p>按每个区域&#x2F;部门所需 <strong>主机数</strong> 选定合适掩码：</p>\n<ul>\n<li>≤ 254 台 → &#x2F;24，</li>\n<li>≤ 510 台 → &#x2F;23；</li>\n<li>≥ 1000 台 → &#x2F;22 或更大。</li>\n</ul>\n</li>\n<li><p>使用 VLSM 将大块地址细分为多级子网，避免过度浪费 。</p>\n</li>\n</ul>\n<ol>\n<li>静态 vs 动态分配</li>\n</ol>\n<ul>\n<li><strong>静态</strong>：核心路由器、交换机管理接口、服务器、链路（&#x2F;30）等关键设备使用固定 IP 。</li>\n<li><strong>动态</strong>：普通终端、打印机、访客等设备通过 DHCP 自动获取，减少人工配置出错 。</li>\n</ul>\n<ol>\n<li>路由汇总与策略</li>\n</ol>\n<ul>\n<li>在骨干路由器上对区域前缀（如 10.10.0.0&#x2F;18）做汇总，减少全网路由表项 。</li>\n<li>设置静态或 BGP 聚合路由，避免过细前缀被外部路由器学习。</li>\n</ul>\n<hr>\n<h2 id=\"IPAM-工具与自动化\"><a href=\"#IPAM-工具与自动化\" class=\"headerlink\" title=\"IPAM 工具与自动化\"></a>IPAM 工具与自动化</h2><ol>\n<li>开源 IPAM</li>\n</ol>\n<ul>\n<li><strong>phpIPAM</strong>：内置扫描工具可发现并维持实际分配状态，适合小到中型网络 。</li>\n<li><strong>NetBox</strong>：强调“源自真相”，通过 API 驱动自动化分配，推荐作为“网络源型”工具。</li>\n</ul>\n<ol>\n<li>云厂商托管 IPAM</li>\n</ol>\n<ul>\n<li><strong>Azure IPAM</strong>：集成在 Azure Portal，可跨订阅&#x2F;区域跟踪私有前缀和公共地址 。</li>\n<li><strong>AWS VPC IPAM</strong>：支持多 VPC 地址池管理、配额警报与自动化调整 。</li>\n</ul>\n<ol>\n<li>审计与报告</li>\n</ol>\n<ul>\n<li>定期使用 IPAM 工具生成地址使用率、冲突检测与过期租约报告，确保地址库健康 。</li>\n</ul>\n<hr>\n<h2 id=\"案例分析\"><a href=\"#案例分析\" class=\"headerlink\" title=\"案例分析\"></a>案例分析</h2><h3 id=\"案例-1：高校园区网划分\"><a href=\"#案例-1：高校园区网划分\" class=\"headerlink\" title=\"案例 1：高校园区网划分\"></a>案例 1：高校园区网划分</h3><ul>\n<li><p><strong>需求</strong>：四栋教学楼（共 1200 台设备）、两栋宿舍楼（共 800 台设备）、数据中心及访客 WLAN。</p>\n</li>\n<li><p><strong>方案</strong>：</p>\n<ol>\n<li>整体地址块 10.10.0.0&#x2F;16；</li>\n<li>教学楼按楼层划分为 10.10.(1–4).0&#x2F;20，每栋留 4 个 &#x2F;22 子网；</li>\n<li>宿舍楼 10.10.64.0&#x2F;21；</li>\n<li>数据中心 10.10.96.0&#x2F;26；</li>\n<li>访客 WLAN 10.10.96.64&#x2F;26，专用 DHCP 池每日回收。</li>\n</ol>\n</li>\n<li><p><strong>效果</strong>：大区汇总为 10.10.0.0&#x2F;16，仅需一条骨干路由 。</p>\n</li>\n</ul>\n<h3 id=\"案例-2：中型企业-IP-冲突整治\"><a href=\"#案例-2：中型企业-IP-冲突整治\" class=\"headerlink\" title=\"案例 2：中型企业 IP 冲突整治\"></a>案例 2：中型企业 IP 冲突整治</h3><ul>\n<li><p><strong>背景</strong>：静态分配与零散 DHCP 池导致频繁冲突，影响办公网络可用性。</p>\n</li>\n<li><p><strong>整改</strong>：</p>\n<ol>\n<li>部署 <strong>中央 DHCP</strong> + 地址保留；</li>\n<li>使用 InterLIR 审计脚本扫描旧表并清理未用地址 ；</li>\n<li>核心&#x2F;交换管理接口迁移至独立 &#x2F;29 静态段。</li>\n</ol>\n</li>\n<li><p><strong>结果</strong>：冲突率降至 0，网络可用率提升至 99.99%。</p>\n</li>\n</ul>\n<h3 id=\"案例-3：政府专网混合使用\"><a href=\"#案例-3：政府专网混合使用\" class=\"headerlink\" title=\"案例 3：政府专网混合使用\"></a>案例 3：政府专网混合使用</h3><ul>\n<li><p><strong>需求</strong>：公网地址 59.223.0.0&#x2F;16 用于骨干与边界，内网使用 10.0.0.0&#x2F;8。</p>\n</li>\n<li><p><strong>方案</strong>：</p>\n<ol>\n<li>骨干与边界服务：59.223.0.0&#x2F;24；</li>\n<li>各部门办公：10.1.0.0&#x2F;16，再细分 10.1.X.0&#x2F;24；</li>\n<li>预留 3 个 &#x2F;24 子网，支持未来扩容 。</li>\n</ol>\n</li>\n<li><p><strong>优势</strong>：公网&#x2F;私网隔离，NAT 配置集中，简化内部路由表并增强安全性。</p>\n</li>\n</ul>\n<hr>\n<h1 id=\"总结\"><a href=\"#总结\" class=\"headerlink\" title=\"总结\"></a>总结</h1><ol>\n<li><strong>进制转换</strong>是理解 IP 表示与子网划分的基础；</li>\n<li><strong>MAC 地址</strong>由 IEEE 分配的 OUI 与厂商自定义部分构成，为二层交换提供通信标识；</li>\n<li><strong>IP 地址</strong>分网络号与主机号，通过子网掩码确定可用主机范围；</li>\n<li><strong>IP 分类</strong>（A&#x2F;B&#x2F;C&#x2F;D&#x2F;E 类）与<strong>特殊地址</strong>（广播、环回、APIPA）保证了网络分段与管理；</li>\n<li><strong>私网地址</strong>结合 <strong>NAT&#x2F;PAT</strong> 实现内外网互通，同时保持内部地址安全；</li>\n<li>理解二层 MAC 与三层 IP 的<strong>协作</strong>（ARP 流程）是网络故障排查与优化的关键。</li>\n</ol>\n","excerpt":"","more":"<h1 id=\"IP-地址规划及案例分析\"><a href=\"#IP-地址规划及案例分析\" class=\"headerlink\" title=\"IP 地址规划及案例分析\"></a>IP 地址规划及案例分析</h1><h1 id=\"参考资料\"><a href=\"#参考资料\" class=\"headerlink\" title=\"参考资料\"></a>参考资料</h1><blockquote>\n<ul>\n<li><a href=\"https://learn.microsoft.com/en-us/azure/cloud-adoption-framework/ready/azure-best-practices/plan-for-ip-addressing?utm_source=chatgpt.com\">Plan for IP addressing - Cloud Adoption Framework</a></li>\n<li><a href=\"https://www.cnblogs.com/zhchoutai/p/6932604.html\">www.cnblogs.com</a></li>\n<li><a href=\"https://github.com/jonsam-ng/image-hosting/tree/master/articles\">image-hosting&#x2F;articles at master · jonsam-ng&#x2F;image-hosting</a></li>\n</ul>\n</blockquote>\n<h1 id=\"概述\"><a href=\"#概述\" class=\"headerlink\" title=\"概述\"></a>概述</h1><p>在网络通信中，<strong>MAC 地址</strong>与 <strong>IP 地址</strong>分别位于 OSI 模型的数据链路层和网络层，二者协同完成从局域到广域的可靠互联。MAC 地址由 IEEE 分配的 OUI（组织唯一标识符）和厂商自定义部分构成，对应真实硬件；IP 地址则分为网络号与主机号，用以逻辑上定位主机并实现跨网段路由。</p>\n<p>IP 地址（Internet Protocol Address），缩写为 IP Adress，是一种在 Internet 上的给主机统一编址的地址格式，也称为网络协议（IP 协议）地址。它为互联网上的每一个网络和每一台主机分配一个逻辑地址，常见的 IP 地址，分为 IPv4 与 IPv6 两大类，当前广泛应用的是 IPv4，目前 IPv4 几乎耗尽，下一阶段必然会进行版本升级到 IPv6；如无特别注明，一般我们讲的的 IP 地址所指的是 IPv4。</p>\n<p><img src=\"https://gitee.com/tanke11223344/imagehost/raw/main/blog/1749363873852HlvKbpXGzoKjxBxn7Zoclw6Knjf.png\" alt=\"1749363873852HlvKbpXGzoKjxBxn7Zoclw6Knjf.png\"></p>\n<h2 id=\"进制转换回顾\"><a href=\"#进制转换回顾\" class=\"headerlink\" title=\"进制转换回顾\"></a>进制转换回顾</h2><p>在理解 IP 地址（二进制）与点分十进制表示之前，必须熟练掌握二进制与十进制互转。</p>\n<p><img src=\"https://gitee.com/tanke11223344/imagehost/raw/main/blog/1749363883851MwwKbhLFVoIeQzxsXQUcS9TSnjh.png\" alt=\"1749363883851MwwKbhLFVoIeQzxsXQUcS9TSnjh.png\"></p>\n<ul>\n<li><strong>二进制权值</strong>：第 n 位表示 2ⁿ。八位二进制可表示 0–255，共 2⁸ 种状态。</li>\n<li><strong>示例</strong>：<code>11010010₂ = 1·2⁷ +1·2⁶+0·2⁵+1·2⁴+0·2³+0·2²+1·2¹+0·2⁰ = 128+64+16+2 = 210</code>。<br>掌握“相邻位权值相差两倍”规律，可快速记忆 2⁰–2⁷ 的所有幂值。</li>\n</ul>\n<h2 id=\"MAC-地址（数据链路层）\"><a href=\"#MAC-地址（数据链路层）\" class=\"headerlink\" title=\"MAC 地址（数据链路层）\"></a>MAC 地址（数据链路层）</h2><h3 id=\"组成与格式\"><a href=\"#组成与格式\" class=\"headerlink\" title=\"组成与格式\"></a>组成与格式</h3><ul>\n<li><strong>长度</strong>：48 位（二进制），通常写作 6 个字节的十六进制，用冒号或中划线分隔，如 <code>AC:DE:48:23:45:67</code>。</li>\n<li><strong>结构</strong>：前 24 位为 OUI（Organizationally Unique Identifier），由 IEEE 分配，标识厂家；后 24 位是厂商自行分配的扩展标识符，用以唯一定位网卡。</li>\n<li><strong>示例</strong>：OUI <code>AC-DE-48</code> 可能对应某厂商生产的设备，其余 24 位由该厂商自由定义。</li>\n</ul>\n<h3 id=\"功能与用途\"><a href=\"#功能与用途\" class=\"headerlink\" title=\"功能与用途\"></a>功能与用途</h3><ul>\n<li><strong>帧转发</strong>：交换机根据数据帧头部的目标 MAC 地址在 CAM 表中查找对应端口，实现二层转发。</li>\n<li><strong>设备识别</strong>：在安全和取证场景，可通过 OUI 识别厂商及设备类型。</li>\n</ul>\n<h2 id=\"IP-地址（网络层）\"><a href=\"#IP-地址（网络层）\" class=\"headerlink\" title=\"IP 地址（网络层）\"></a>IP 地址（网络层）</h2><h3 id=\"IPv4-格式与点分十进制\"><a href=\"#IPv4-格式与点分十进制\" class=\"headerlink\" title=\"IPv4 格式与点分十进制\"></a>IPv4 格式与点分十进制</h3><p><img src=\"https://gitee.com/tanke11223344/imagehost/raw/main/blog/1749363894091BwTFbPQc1oFOhKxYbGwcq5RmnGf.png\" alt=\"1749363894091BwTFbPQc1oFOhKxYbGwcq5RmnGf.png\"></p>\n<ul>\n<li><strong>32 位地址</strong>由四段 8 位二进制组成，每段转换为 0–255 的十进制，使用“点”分隔，如 <code>192.168.1.1</code>。</li>\n<li><strong>网&#x2F;主分界</strong>：通过子网掩码（如 <code>255.255.255.0</code> 或 <code>/24</code>）区分网络号与主机号。</li>\n</ul>\n<p><img src=\"https://gitee.com/tanke11223344/imagehost/raw/main/blog/1749363900852GyfsbRbmGojzzwxUYr9ca4OVnEg.png\" alt=\"1749363900852GyfsbRbmGojzzwxUYr9ca4OVnEg.png\"></p>\n<h3 id=\"IP-与-MAC-的协作\"><a href=\"#IP-与-MAC-的协作\" class=\"headerlink\" title=\"IP 与 MAC 的协作\"></a>IP 与 MAC 的协作</h3><ul>\n<li><strong>ARP</strong> 协议：主机先判断目标 IP 是否与自身在同一子网；若不同，则将下一跳路由器的 MAC 用于帧封装；若相同，则直接将目标主机 MAC 用于帧封装。</li>\n</ul>\n<p><img src=\"https://gitee.com/tanke11223344/imagehost/raw/main/blog/1749363908852I8SCbAE7WoWf71xo1sBcUdNGndf.png\" alt=\"1749363908852I8SCbAE7WoWf71xo1sBcUdNGndf.png\"></p>\n<ul>\n<li><strong>过程</strong>：<ol>\n<li>网络层生成包含源&#x2F;目标 IP 的数据包；</li>\n<li>数据链路层封装源&#x2F;目标 MAC，并在局域内通信；</li>\n<li>路由器根据 IP 决定下一跳，MAC 则由 ARP 动态解析。</li>\n</ol>\n</li>\n</ul>\n<hr>\n<h2 id=\"IPv4-地址分类\"><a href=\"#IPv4-地址分类\" class=\"headerlink\" title=\"IPv4 地址分类\"></a>IPv4 地址分类</h2><p>IPv4 按首字节前缀分为五类：A&#x2F;B&#x2F;C 类用于主机寻址，D 类用于多播，E 类保留。</p>\n<p><img src=\"https://gitee.com/tanke11223344/imagehost/raw/main/blog/1749363916852LDaWb0dWrojXS8xdRK0cMcQOnNb.png\" alt=\"1749363916852LDaWb0dWrojXS8xdRK0cMcQOnNb.png\"></p>\n<ul>\n<li><strong>网络地址</strong>：主机 ID 全 0（如 <code>192.168.1.0</code>）。</li>\n<li><strong>广播地址</strong>：主机 ID 全 1（如 <code>192.168.1.255</code>）。</li>\n<li><strong>环回地址</strong>：<code>127.0.0.1</code>，测试本机网络堆栈。</li>\n<li><strong>自动私有 IP</strong>：<code>169.254.0.0–169.254.255.255</code>，DHCP 失败时自动生成。</li>\n<li><strong>全 0&#x2F;全 1</strong>：<code>0.0.0.0</code>、<code>255.255.255.255</code> 用于内部通信及本地广播。</li>\n</ul>\n<h3 id=\"A-类地址\"><a href=\"#A-类地址\" class=\"headerlink\" title=\"A 类地址\"></a>A 类地址</h3><p>A 类地址的网络号（net-id）占 8 位，且其二进制第一位固定为 <code>0</code>，因此 A 类网络的网络号范围为 0 至 127，共计 128 个网络。</p>\n<ul>\n<li><strong>网络号 0</strong>（地址范围 <code>0.0.0.0</code> ~ <code>0.255.255.255</code>）被保留，用于表示“本网络”。</li>\n<li><strong>网络号 127</strong>（地址范围 <code>127.0.0.0</code> ~ <code>127.255.255.255</code>）被保留，用作环回测试地址。</li>\n<li><strong>网络号 10</strong>（地址范围 <code>10.0.0.0</code> ~ <code>10.255.255.255</code>）被指定为私有地址，用于内部网络。</li>\n</ul>\n<p>除去这些特殊用途的网络，实际可公开分配的 A 类网络共有 125 个（从网络号 1 到 126，再除去网络号 10）。每一个 A 类网络的主机号（host-id）占 24 位，理论上可分配 <code>2^24</code> 个主机地址。但由于主机号全为 <code>0</code> 的地址代表网络本身，全为 <code>1</code> 的地址代表网络广播地址，这两个地址需被保留，因此每个 A 类网络实际可用的主机数量为 <code>2^24 - 2 = 16,777,214</code> 个。</p>\n<h3 id=\"B-类地址\"><a href=\"#B-类地址\" class=\"headerlink\" title=\"B 类地址\"></a>B 类地址</h3><p>B 类地址的网络号占 16 位，且其二进制前两位固定为 <code>10</code>，这使得 B 类网络的数量为 <code>2^(16-2) = 2^14 = 16,384</code> 个。B 类地址的主机号同样占 16 位，因此每个 B 类网络理论上可拥有 <code>2^16 = 65,536</code> 个主机地址。同样，除去代表网络本身（主机号全 <code>0</code>）和广播（主机号全 <code>1</code>）的两个保留地址，每个 B 类网络实际可分配的主机数量为 <code>65,536 - 2 = 65,534</code> 个。</p>\n<h3 id=\"C-类地址\"><a href=\"#C-类地址\" class=\"headerlink\" title=\"C 类地址\"></a>C 类地址</h3><p>C 类地址的网络号占 24 位，其二进制前三位固定为 <code>110</code>，因此可用的 C 类网络总数高达 <code>2^(24-3) = 2^21 = 2,097,152</code> 个。C 类地址的主机号仅占 8 位，每个网络最多可容纳 <code>2^8 = 256</code> 个主机地址。在扣除用于网络标识和广播的两个保留地址后，每个 C 类网络实际上允许分配的主机数量为 <code>256 - 2 = 254</code> 个。</p>\n<h3 id=\"特殊地址形式\"><a href=\"#特殊地址形式\" class=\"headerlink\" title=\"特殊地址形式\"></a>特殊地址形式</h3><p>特殊的 IP 地址主要包括以下几种：</p>\n<ul>\n<li><strong>直接广播地址 (Directed Broadcast)</strong></li>\n</ul>\n<p>直接广播地址是指主机号（host-id）部分全为 1 的地址。它用于向特定远程网络上的所有主机发送广播数据包。例如，若要向网络 201.161.20.0 上的所有主机广播，发送方需要将数据包的目的地址设置为该网络的直接广播地址 201.161.20.255。路由器在接收到此数据包后，会将其转发到目标网络进行广播。</p>\n<ul>\n<li><strong>受限广播地址 (Limited Broadcast)</strong></li>\n</ul>\n<p>受限广播地址是一个固定的地址 255.255.255.255。它用于向主机所在的本地物理网络（即同一广播域内）的所有设备发送广播。与直接广播不同，路由器绝不会转发目的地址为 255.255.255.255 的数据包，从而将广播范围严格限制在本地网段内。</p>\n<ul>\n<li><strong>“本网络上的特定主机”地址</strong></li>\n</ul>\n<p>这是一个网络号（net-id）部分全为 0 的地址，格式为 0.0.0.x。这种地址格式用于指代“本网络”上的某个特定主机。它通常在设备的启动阶段（如使用 BOOTP 或 DHCP 协议获取 IP 地址时）被使用，此时设备可能还不知道自己所在网络的网络号，但需要与本地网络上的某个服务器（如 DHCP 服务器）进行通信。</p>\n<ul>\n<li><strong>回环地址 (Loopback Address)</strong></li>\n</ul>\n<p>A 类网络中的 127.0.0.0&#x2F;8 网段被保留为回环地址。这类地址主要用于网络软件的测试以及同一台主机上不同进程间的通信。根据 TCP&#x2F;IP 协议规定，任何目的地址为 127.0.0.0&#x2F;8 的数据包都不会被发送到任何网络上，而是在操作系统内核的网络协议栈中被“环回”，直接发送给本机。最常用的回环地址是 127.0.0.1，通常被赋予主机名 localhost。</p>\n<h2 id=\"专用-ip-地址与内部网络地址规划方法\"><a href=\"#专用-ip-地址与内部网络地址规划方法\" class=\"headerlink\" title=\"**专用 ip 地址与内部网络地址规划方法 **\"></a>**专用 ip 地址与内部网络地址规划方法 **</h2><h3 id=\"全局-IP-地址与专用-IP-地址\"><a href=\"#全局-IP-地址与专用-IP-地址\" class=\"headerlink\" title=\"全局 IP 地址与专用 IP 地址\"></a>全局 IP 地址与专用 IP 地址</h3><ul>\n<li>全局 IP 地址与专用 IP 地址的区别：</li>\n</ul>\n<p>（1）使用 IP 地址的网络可以分为两种情况：一种是要将网络之间连到 Internet；另一种是也需要运行 TCP&#x2F;IP 协议，但是它是内部网络，并不直接连接到 Internet，但网络内部用户访问 Internet 是受到严格控制的。</p>\n<p>（2）使用全局 IP 地址是需要申请的，而专用 IP 地址是不需要申请的。</p>\n<p>（3）全局 IP 地址必须保证在 Internet 上是唯一的；专用 IP 地址在某一个网络内部是唯一 的，但是在 Internet 中并不是唯一的。</p>\n<ul>\n<li>专用 IP 地址(私有地址)</li>\n</ul>\n<p>A 类：<strong>10</strong>.0.0.0～10.255.255.255</p>\n<p>B 类：<strong>172.16</strong>.0.0～<strong>172.31</strong>.255.255</p>\n<p>C 类：<strong>192.168</strong>.0.0～192.168.255.255</p>\n<h2 id=\"公网-vs-私网\"><a href=\"#公网-vs-私网\" class=\"headerlink\" title=\"公网 vs 私网\"></a>公网 vs 私网</h2><p><img src=\"https://gitee.com/tanke11223344/imagehost/raw/main/blog/1749363931852LjYIbYN3Uo4ED1xRWxGcyqnanQh.png\" alt=\"1749363931852LjYIbYN3Uo4ED1xRWxGcyqnanQh.png\"></p>\n<h3 id=\"私有地址空间\"><a href=\"#私有地址空间\" class=\"headerlink\" title=\"私有地址空间\"></a>私有地址空间</h3><p>RFC 1918 定义三大私有网段，供企业&#x2F;家庭网络内部使用，不在公网路由表中出现：</p>\n<ul>\n<li>A 类：<code>10.0.0.0/8</code>（16,777,216 主机）</li>\n<li>B 类：<code>172.16.0.0/12</code>（1,048,576 主机）</li>\n<li>C 类：<code>192.168.0.0/16</code>（65,536 主机）</li>\n</ul>\n<h3 id=\"NAT-与-PAT\"><a href=\"#NAT-与-PAT\" class=\"headerlink\" title=\"NAT 与 PAT\"></a>NAT 与 PAT</h3><p>私网访问互联网需通过 <strong>NAT</strong>（网络地址转换）或 <strong>PAT</strong>（端口地址转换）映射到公网 IP，保证内部地址不被外部路由学习 。</p>\n<ul>\n<li><strong>静态 NAT</strong>：一对一映射，适合服务器发布服务。</li>\n<li><strong>动态 PAT</strong>：多对一映射，使用端口区分，适合大量终端访问。</li>\n</ul>\n<h3 id=\"IPv4-与私有地址\"><a href=\"#IPv4-与私有地址\" class=\"headerlink\" title=\"IPv4 与私有地址\"></a>IPv4 与私有地址</h3><p>IPv4 地址由 32 位二进制构成，通常用点分十进制（如 192.168.1.0&#x2F;24）表示 。</p>\n<p>RFC 1918 规定了三大私有地址块：10.0.0.0&#x2F;8、172.16.0.0&#x2F;12、192.168.0.0&#x2F;16，仅限内部网络使用，不可在互联网上路由。</p>\n<p>在实际规划中，应优先采用私有网段以降低公开地址成本，并在边界路由器或 NAT 设备处做地址转换 。</p>\n<h3 id=\"IPv6-过渡考虑\"><a href=\"#IPv6-过渡考虑\" class=\"headerlink\" title=\"IPv6 过渡考虑\"></a>IPv6 过渡考虑</h3><p>随着地址耗尽问题加剧，IPv6（128 位地址）正在逐步部署。常见做法是在新业务或数据中心网段使用 IPv6，同时保留 IPv4 私网以兼容旧设备 。</p>\n<p>规划 IPv6 前缀（&#x2F;48、&#x2F;56）时，也需考虑区域汇总与自治系统号分配，以免碎片化 。</p>\n<hr>\n<h2 id=\"设计原则\"><a href=\"#设计原则\" class=\"headerlink\" title=\"设计原则\"></a>设计原则</h2><h3 id=\"层次化与路由聚合\"><a href=\"#层次化与路由聚合\" class=\"headerlink\" title=\"层次化与路由聚合\"></a>层次化与路由聚合</h3><p>将地址空间按 <strong>区域-楼层-部门</strong> 分层划分，确保上层分配连续大块前缀可在骨干路由中做 <strong>supernet</strong> 汇总 。<br>例如：校园网中，可将 10.10.0.0&#x2F;16 划为 10.10.0.0&#x2F;18（教学楼）、10.10.64.0&#x2F;18（宿舍区）等，然后按楼层再细分 &#x2F;24 子网 。</p>\n<h3 id=\"可扩展性与预留\"><a href=\"#可扩展性与预留\" class=\"headerlink\" title=\"可扩展性与预留\"></a>可扩展性与预留</h3><p>在每个子网中预留至少 <strong>25%–50%</strong> 的地址池用于未来增长或临时接入 。<br>对大型站点，应采用 <strong>VLSM</strong>（可变长子网掩码）精细分配，既节约地址又保持灵活性 。</p>\n<h3 id=\"易管理与可识别\"><a href=\"#易管理与可识别\" class=\"headerlink\" title=\"易管理与可识别\"></a>易管理与可识别</h3><p>子网编号应具有业务含义，如 10.1.10.0&#x2F;24 代表“1 号楼 10 层”。</p>\n<p>文档化至关重要，建议使用 IPAM 工具记录子网、VLAN、DHCP 范围与分配策略，以便审计与冲突检测 。</p>\n<hr>\n<h2 id=\"规划方法\"><a href=\"#规划方法\" class=\"headerlink\" title=\"规划方法\"></a>规划方法</h2><ol>\n<li>需求调研</li>\n</ol>\n<ul>\n<li>收集各办公区&#x2F;数据中心&#x2F;访客网的 <strong>物理位置</strong>、<strong>设备数量</strong>、<strong>未来三年增长</strong>预测和 <strong>服务类型</strong> 。</li>\n<li>按区域汇总并记录到表格，做子网大小初步估算。</li>\n</ul>\n<ol>\n<li>地址池选择</li>\n</ol>\n<ul>\n<li><strong>公网场景</strong>：向 RIR（APNIC&#x2F;ARIN 等）或云厂商（Azure、AWS）申请适当大小的 IPv4&#x2F;IPv6 前缀 。</li>\n<li><strong>私网场景</strong>：优先使用 RFC 1918 地址，并在边界 NAT 设备上管理公网出口。</li>\n</ul>\n<ol>\n<li>子网划分</li>\n</ol>\n<ul>\n<li><p>按每个区域&#x2F;部门所需 <strong>主机数</strong> 选定合适掩码：</p>\n<ul>\n<li>≤ 254 台 → &#x2F;24，</li>\n<li>≤ 510 台 → &#x2F;23；</li>\n<li>≥ 1000 台 → &#x2F;22 或更大。</li>\n</ul>\n</li>\n<li><p>使用 VLSM 将大块地址细分为多级子网，避免过度浪费 。</p>\n</li>\n</ul>\n<ol>\n<li>静态 vs 动态分配</li>\n</ol>\n<ul>\n<li><strong>静态</strong>：核心路由器、交换机管理接口、服务器、链路（&#x2F;30）等关键设备使用固定 IP 。</li>\n<li><strong>动态</strong>：普通终端、打印机、访客等设备通过 DHCP 自动获取，减少人工配置出错 。</li>\n</ul>\n<ol>\n<li>路由汇总与策略</li>\n</ol>\n<ul>\n<li>在骨干路由器上对区域前缀（如 10.10.0.0&#x2F;18）做汇总，减少全网路由表项 。</li>\n<li>设置静态或 BGP 聚合路由，避免过细前缀被外部路由器学习。</li>\n</ul>\n<hr>\n<h2 id=\"IPAM-工具与自动化\"><a href=\"#IPAM-工具与自动化\" class=\"headerlink\" title=\"IPAM 工具与自动化\"></a>IPAM 工具与自动化</h2><ol>\n<li>开源 IPAM</li>\n</ol>\n<ul>\n<li><strong>phpIPAM</strong>：内置扫描工具可发现并维持实际分配状态，适合小到中型网络 。</li>\n<li><strong>NetBox</strong>：强调“源自真相”，通过 API 驱动自动化分配，推荐作为“网络源型”工具。</li>\n</ul>\n<ol>\n<li>云厂商托管 IPAM</li>\n</ol>\n<ul>\n<li><strong>Azure IPAM</strong>：集成在 Azure Portal，可跨订阅&#x2F;区域跟踪私有前缀和公共地址 。</li>\n<li><strong>AWS VPC IPAM</strong>：支持多 VPC 地址池管理、配额警报与自动化调整 。</li>\n</ul>\n<ol>\n<li>审计与报告</li>\n</ol>\n<ul>\n<li>定期使用 IPAM 工具生成地址使用率、冲突检测与过期租约报告，确保地址库健康 。</li>\n</ul>\n<hr>\n<h2 id=\"案例分析\"><a href=\"#案例分析\" class=\"headerlink\" title=\"案例分析\"></a>案例分析</h2><h3 id=\"案例-1：高校园区网划分\"><a href=\"#案例-1：高校园区网划分\" class=\"headerlink\" title=\"案例 1：高校园区网划分\"></a>案例 1：高校园区网划分</h3><ul>\n<li><p><strong>需求</strong>：四栋教学楼（共 1200 台设备）、两栋宿舍楼（共 800 台设备）、数据中心及访客 WLAN。</p>\n</li>\n<li><p><strong>方案</strong>：</p>\n<ol>\n<li>整体地址块 10.10.0.0&#x2F;16；</li>\n<li>教学楼按楼层划分为 10.10.(1–4).0&#x2F;20，每栋留 4 个 &#x2F;22 子网；</li>\n<li>宿舍楼 10.10.64.0&#x2F;21；</li>\n<li>数据中心 10.10.96.0&#x2F;26；</li>\n<li>访客 WLAN 10.10.96.64&#x2F;26，专用 DHCP 池每日回收。</li>\n</ol>\n</li>\n<li><p><strong>效果</strong>：大区汇总为 10.10.0.0&#x2F;16，仅需一条骨干路由 。</p>\n</li>\n</ul>\n<h3 id=\"案例-2：中型企业-IP-冲突整治\"><a href=\"#案例-2：中型企业-IP-冲突整治\" class=\"headerlink\" title=\"案例 2：中型企业 IP 冲突整治\"></a>案例 2：中型企业 IP 冲突整治</h3><ul>\n<li><p><strong>背景</strong>：静态分配与零散 DHCP 池导致频繁冲突，影响办公网络可用性。</p>\n</li>\n<li><p><strong>整改</strong>：</p>\n<ol>\n<li>部署 <strong>中央 DHCP</strong> + 地址保留；</li>\n<li>使用 InterLIR 审计脚本扫描旧表并清理未用地址 ；</li>\n<li>核心&#x2F;交换管理接口迁移至独立 &#x2F;29 静态段。</li>\n</ol>\n</li>\n<li><p><strong>结果</strong>：冲突率降至 0，网络可用率提升至 99.99%。</p>\n</li>\n</ul>\n<h3 id=\"案例-3：政府专网混合使用\"><a href=\"#案例-3：政府专网混合使用\" class=\"headerlink\" title=\"案例 3：政府专网混合使用\"></a>案例 3：政府专网混合使用</h3><ul>\n<li><p><strong>需求</strong>：公网地址 59.223.0.0&#x2F;16 用于骨干与边界，内网使用 10.0.0.0&#x2F;8。</p>\n</li>\n<li><p><strong>方案</strong>：</p>\n<ol>\n<li>骨干与边界服务：59.223.0.0&#x2F;24；</li>\n<li>各部门办公：10.1.0.0&#x2F;16，再细分 10.1.X.0&#x2F;24；</li>\n<li>预留 3 个 &#x2F;24 子网，支持未来扩容 。</li>\n</ol>\n</li>\n<li><p><strong>优势</strong>：公网&#x2F;私网隔离，NAT 配置集中，简化内部路由表并增强安全性。</p>\n</li>\n</ul>\n<hr>\n<h1 id=\"总结\"><a href=\"#总结\" class=\"headerlink\" title=\"总结\"></a>总结</h1><ol>\n<li><strong>进制转换</strong>是理解 IP 表示与子网划分的基础；</li>\n<li><strong>MAC 地址</strong>由 IEEE 分配的 OUI 与厂商自定义部分构成，为二层交换提供通信标识；</li>\n<li><strong>IP 地址</strong>分网络号与主机号，通过子网掩码确定可用主机范围；</li>\n<li><strong>IP 分类</strong>（A&#x2F;B&#x2F;C&#x2F;D&#x2F;E 类）与<strong>特殊地址</strong>（广播、环回、APIPA）保证了网络分段与管理；</li>\n<li><strong>私网地址</strong>结合 <strong>NAT&#x2F;PAT</strong> 实现内外网互通，同时保持内部地址安全；</li>\n<li>理解二层 MAC 与三层 IP 的<strong>协作</strong>（ARP 流程）是网络故障排查与优化的关键。</li>\n</ol>\n"},{"title":"2025-07-29-九格通用基础大模型环境配置","date":"2025-07-28T16:00:00.000Z","_content":"# [九格通用基础大模型](https://www.osredm.com/jiuyuan/CPM-9G-8B \"九格通用基础大模型\")环境配置\n\n# 模型介绍\n\n启元九格大模型是由启元实验室联合清华大学、哈尔滨工业大学、中国科学院计算技术研究所、北京大学、南开大学等顶尖科研单位共同研发的高效模型。具备高效训练与推理、高效适配与部署的特点，支持多种自然语言处理（NLP）和多模态任务，包括文本问答、文本分类、机器翻译、文本摘要、图文理解等。模型有4B、7B、70B三种不同尺寸的基础语言模型，适配Nvidia GPU和昇腾NPU。环境配置方法和离线批量推理/在线多轮对话的示例代码均已开源。九格模型已经适配到910B npu，支持vllm离线推理和openai api访问。\n\n# 我的环境配置\n\n- python 3.10.16\n- cuda11.8\n\n# 流程\n\n## 配置环境\n\n```jsx\nconda create -n fm9g4bv python=3.10.16\n\nconda activate fm9g4bv\n\npip3 install torch torchvision torchaudio --index-url https://download.pytorch.org/whl/cu118\n```\n\n## 克隆项目\n\n> 这里克隆的是main分支,没有克隆-V后缀的分支，-V后缀的分支\n> 有对应的推理和微调的代码以及requirements.txt文件\n> [-V分支的链接](https://www.osredm.com/jiuyuan/CPM-9G-8B/tree/FM9G-V/FM9G4B-V)\n\n```jsx\ngit clone https://osredm.com/p49102387/CPM-9G-8B.git\ncd CPM-9G-8B\n\nwget https://github.com/vllm-project/vllm/releases/download/v0.10.0/vllm-0.10.0+cu118-cp38-abi3-manylinux1_x86_64.whl\n\n```\n\n创建 requirements.txt文件\n\n```jsx\npackaging==23.2\naddict==2.4.0\neditdistance==0.6.2\neinops==0.8.0\nfairscale==0.4.0\njsonlines==4.0.0\nmarkdown2==2.4.10\nmatplotlib==3.7.4\nmore_itertools==10.1.0\nnltk==3.8.1\nnumpy==1.24.4\nopencv_python_headless==4.5.5.64\nopenpyxl==3.1.2\nPillow==10.1.0\nsacrebleu==2.3.2\nseaborn==0.13.0\nshortuuid==1.0.11\nspacy==3.7.2\ntorch==2.2.0\ntorchaudio==2.2.0\ntorchvision==0.17.0\ntimm==0.9.10\ntqdm==4.66.1\nprotobuf==4.25.0\ntyping_extensions==4.8.0\nuvicorn==0.24.0.post1\n#xformers==0.0.22.post7\n#flash_attn==2.3.4\nsentencepiece==0.1.99\naccelerate==0.30.1\nsocksio==1.0.0\ngradio\ngradio_client\n<http://thunlp.oss-cn-qingdao.aliyuncs.com/multi_modal/never_delete/modelscope_studio-0.4.0.9-py3-none-any.whl>\ndecord\naiosignal\ntensorboard\ndeepspeed==0.12.3\ntransformers==4.44.2\nlibrosa==0.9.0\nsoundfile==0.12.1\nvector-quantize-pytorch==1.18.5\nvocos==0.1.0\npeft==0.14.0\nninja==1.11.1.1\nmoviepy \n```\n\n```jsx\npip install -r requirements.txt\n\npip install vllm-0.10.0+cu118-cp38-abi3-manylinux1_x86_64.whl\n```\n\n![1753762025700image.png](https://tk-pichost-1325224430.cos.ap-chengdu.myqcloud.com/blog/1753762025700image.png)\n\n![17537624515762025729.png](https://tk-pichost-1325224430.cos.ap-chengdu.myqcloud.com/blog/17537624515762025729.png)\n\n```jsx\nmkdir ckpt\ncd cpkt\nwget https://thunlp-model.oss-cn-wulanchabu.aliyuncs.com/FM9G4B-V.tar.gz\ntar -xzf FM9G4B-V.tar.gz\n```\n\n# 放置推理文件\n\n> 后面可以尝试微调的，这里只试了推理的\n> [所有分支-启元实验室/九格通用基础大模型](https://www.osredm.com/jiuyuan/CPM-9G-8B/tree/FM9G-V/FM9G4B-V/inference)\n\n```jsx\ncd ..\n创建chat.py文件\n```\n\n```jsx\n\"\"\"\nName chat.py\nDate 2025/5/6 11:20\nVersion 1.0\nTODO:\n\"\"\"\n\nimport torch\nfrom PIL import Image\nfrom transformers import AutoModel, AutoTokenizer\n\nif __name__ == '__main__':\n    prompt = f\"\"\"### 背景 ###\n        您需要对图片中的内容进行识别。\n        ### 输出格式 ### \n        您的输出由以下两部分组成，确保您的输出包含这两部分:\n        ### 思考 ###\n        考虑饮料外的标识，辨别饮料的种类，饮料容器。并且识别饮料为'有糖'或者'无糖'，给出你的思考过程。\n        ### 识别结果 ### \n        若图中出现了饮料，请以json形式从左到右对他们进行描述，包括饮料：种类，是否有糖，饮料容器。\n    \"\"\"\n\n    model_file = 'ckpt/FM9G4B-V' ### 这里要改成你的bin文件对应的*目录*\n    model = AutoModel.from_pretrained(model_file, trust_remote_code=True,\n        attn_implementation='sdpa', torch_dtype=torch.bfloat16)\n    model = model.eval().cuda()\n    tokenizer = AutoTokenizer.from_pretrained(model_file, trust_remote_code=True)\n\n    image = Image.open('step.jpg').convert('RGB')\n\n    msgs = [{'role': 'user', 'content': [image, prompt]}]\n\n    res = model.chat(\n        image=None,\n        msgs=msgs,\n        tokenizer=tokenizer\n    )\n    print(\"\\n\", \"=\"*100, \"\\n\")\n    print(res)\n\n    # 第二轮聊天，传递多轮对话的历史信息\n    msgs.append({\"role\": \"assistant\", \"content\": [res]})\n    msgs.append({\"role\": \"user\", \"content\": [\"图中有几个箱子?\"]})\n\n    answer = model.chat(\n        image=None,\n        msgs=msgs,\n        tokenizer=tokenizer\n    )\n    print(\"\\n\", \"=\"*100, \"\\n\")\n    print(answer)\n\n    ## 流式输出，设置：\n    # sampling=True\n    # stream=True\n    ## 返回一个生成器\n    msgs = [{'role': 'user', 'content': [image, prompt]}]\n    res = model.chat(\n        image=None,\n        msgs=msgs,\n        tokenizer=tokenizer,\n        sampling=True,\n        stream=True\n    )\n    print(\"\\n\", \"=\"*100, \"\\n\")\n    generated_text = \"\"\n    for new_text in res:\n        generated_text += new_text\n        print(new_text, flush=True, end='')\n```\n\n加入setup.jpg文件\n\n![175376247066220257292.png](https://tk-pichost-1325224430.cos.ap-chengdu.myqcloud.com/blog/175376247066220257292.png)\n\n运行推理\n\n```jsx\npython chat.py\n```\n\n# 推理结果\n\n![1753763153738981067d09c329dc48c5077992a5067e4.png](https://tk-pichost-1325224430.cos.ap-chengdu.myqcloud.com/blog/1753763153738981067d09c329dc48c5077992a5067e4.png)\n","source":"_posts/2025-07-29-九格通用基础大模型环境配置.md","raw":"---\ntitle:  2025-07-29-九格通用基础大模型环境配置\ndate: 2025-07-29\ntags: \n    问题解决\n---\n# [九格通用基础大模型](https://www.osredm.com/jiuyuan/CPM-9G-8B \"九格通用基础大模型\")环境配置\n\n# 模型介绍\n\n启元九格大模型是由启元实验室联合清华大学、哈尔滨工业大学、中国科学院计算技术研究所、北京大学、南开大学等顶尖科研单位共同研发的高效模型。具备高效训练与推理、高效适配与部署的特点，支持多种自然语言处理（NLP）和多模态任务，包括文本问答、文本分类、机器翻译、文本摘要、图文理解等。模型有4B、7B、70B三种不同尺寸的基础语言模型，适配Nvidia GPU和昇腾NPU。环境配置方法和离线批量推理/在线多轮对话的示例代码均已开源。九格模型已经适配到910B npu，支持vllm离线推理和openai api访问。\n\n# 我的环境配置\n\n- python 3.10.16\n- cuda11.8\n\n# 流程\n\n## 配置环境\n\n```jsx\nconda create -n fm9g4bv python=3.10.16\n\nconda activate fm9g4bv\n\npip3 install torch torchvision torchaudio --index-url https://download.pytorch.org/whl/cu118\n```\n\n## 克隆项目\n\n> 这里克隆的是main分支,没有克隆-V后缀的分支，-V后缀的分支\n> 有对应的推理和微调的代码以及requirements.txt文件\n> [-V分支的链接](https://www.osredm.com/jiuyuan/CPM-9G-8B/tree/FM9G-V/FM9G4B-V)\n\n```jsx\ngit clone https://osredm.com/p49102387/CPM-9G-8B.git\ncd CPM-9G-8B\n\nwget https://github.com/vllm-project/vllm/releases/download/v0.10.0/vllm-0.10.0+cu118-cp38-abi3-manylinux1_x86_64.whl\n\n```\n\n创建 requirements.txt文件\n\n```jsx\npackaging==23.2\naddict==2.4.0\neditdistance==0.6.2\neinops==0.8.0\nfairscale==0.4.0\njsonlines==4.0.0\nmarkdown2==2.4.10\nmatplotlib==3.7.4\nmore_itertools==10.1.0\nnltk==3.8.1\nnumpy==1.24.4\nopencv_python_headless==4.5.5.64\nopenpyxl==3.1.2\nPillow==10.1.0\nsacrebleu==2.3.2\nseaborn==0.13.0\nshortuuid==1.0.11\nspacy==3.7.2\ntorch==2.2.0\ntorchaudio==2.2.0\ntorchvision==0.17.0\ntimm==0.9.10\ntqdm==4.66.1\nprotobuf==4.25.0\ntyping_extensions==4.8.0\nuvicorn==0.24.0.post1\n#xformers==0.0.22.post7\n#flash_attn==2.3.4\nsentencepiece==0.1.99\naccelerate==0.30.1\nsocksio==1.0.0\ngradio\ngradio_client\n<http://thunlp.oss-cn-qingdao.aliyuncs.com/multi_modal/never_delete/modelscope_studio-0.4.0.9-py3-none-any.whl>\ndecord\naiosignal\ntensorboard\ndeepspeed==0.12.3\ntransformers==4.44.2\nlibrosa==0.9.0\nsoundfile==0.12.1\nvector-quantize-pytorch==1.18.5\nvocos==0.1.0\npeft==0.14.0\nninja==1.11.1.1\nmoviepy \n```\n\n```jsx\npip install -r requirements.txt\n\npip install vllm-0.10.0+cu118-cp38-abi3-manylinux1_x86_64.whl\n```\n\n![1753762025700image.png](https://tk-pichost-1325224430.cos.ap-chengdu.myqcloud.com/blog/1753762025700image.png)\n\n![17537624515762025729.png](https://tk-pichost-1325224430.cos.ap-chengdu.myqcloud.com/blog/17537624515762025729.png)\n\n```jsx\nmkdir ckpt\ncd cpkt\nwget https://thunlp-model.oss-cn-wulanchabu.aliyuncs.com/FM9G4B-V.tar.gz\ntar -xzf FM9G4B-V.tar.gz\n```\n\n# 放置推理文件\n\n> 后面可以尝试微调的，这里只试了推理的\n> [所有分支-启元实验室/九格通用基础大模型](https://www.osredm.com/jiuyuan/CPM-9G-8B/tree/FM9G-V/FM9G4B-V/inference)\n\n```jsx\ncd ..\n创建chat.py文件\n```\n\n```jsx\n\"\"\"\nName chat.py\nDate 2025/5/6 11:20\nVersion 1.0\nTODO:\n\"\"\"\n\nimport torch\nfrom PIL import Image\nfrom transformers import AutoModel, AutoTokenizer\n\nif __name__ == '__main__':\n    prompt = f\"\"\"### 背景 ###\n        您需要对图片中的内容进行识别。\n        ### 输出格式 ### \n        您的输出由以下两部分组成，确保您的输出包含这两部分:\n        ### 思考 ###\n        考虑饮料外的标识，辨别饮料的种类，饮料容器。并且识别饮料为'有糖'或者'无糖'，给出你的思考过程。\n        ### 识别结果 ### \n        若图中出现了饮料，请以json形式从左到右对他们进行描述，包括饮料：种类，是否有糖，饮料容器。\n    \"\"\"\n\n    model_file = 'ckpt/FM9G4B-V' ### 这里要改成你的bin文件对应的*目录*\n    model = AutoModel.from_pretrained(model_file, trust_remote_code=True,\n        attn_implementation='sdpa', torch_dtype=torch.bfloat16)\n    model = model.eval().cuda()\n    tokenizer = AutoTokenizer.from_pretrained(model_file, trust_remote_code=True)\n\n    image = Image.open('step.jpg').convert('RGB')\n\n    msgs = [{'role': 'user', 'content': [image, prompt]}]\n\n    res = model.chat(\n        image=None,\n        msgs=msgs,\n        tokenizer=tokenizer\n    )\n    print(\"\\n\", \"=\"*100, \"\\n\")\n    print(res)\n\n    # 第二轮聊天，传递多轮对话的历史信息\n    msgs.append({\"role\": \"assistant\", \"content\": [res]})\n    msgs.append({\"role\": \"user\", \"content\": [\"图中有几个箱子?\"]})\n\n    answer = model.chat(\n        image=None,\n        msgs=msgs,\n        tokenizer=tokenizer\n    )\n    print(\"\\n\", \"=\"*100, \"\\n\")\n    print(answer)\n\n    ## 流式输出，设置：\n    # sampling=True\n    # stream=True\n    ## 返回一个生成器\n    msgs = [{'role': 'user', 'content': [image, prompt]}]\n    res = model.chat(\n        image=None,\n        msgs=msgs,\n        tokenizer=tokenizer,\n        sampling=True,\n        stream=True\n    )\n    print(\"\\n\", \"=\"*100, \"\\n\")\n    generated_text = \"\"\n    for new_text in res:\n        generated_text += new_text\n        print(new_text, flush=True, end='')\n```\n\n加入setup.jpg文件\n\n![175376247066220257292.png](https://tk-pichost-1325224430.cos.ap-chengdu.myqcloud.com/blog/175376247066220257292.png)\n\n运行推理\n\n```jsx\npython chat.py\n```\n\n# 推理结果\n\n![1753763153738981067d09c329dc48c5077992a5067e4.png](https://tk-pichost-1325224430.cos.ap-chengdu.myqcloud.com/blog/1753763153738981067d09c329dc48c5077992a5067e4.png)\n","slug":"2025-07-29-九格通用基础大模型环境配置","published":1,"updated":"2025-09-26T12:18:29.302Z","_id":"cmg0saj4f002qjm8n1gjhcb58","comments":1,"layout":"post","photos":[],"content":"<h1 id=\"九格通用基础大模型环境配置\"><a href=\"#九格通用基础大模型环境配置\" class=\"headerlink\" title=\"九格通用基础大模型环境配置\"></a><a href=\"https://www.osredm.com/jiuyuan/CPM-9G-8B\" title=\"九格通用基础大模型\">九格通用基础大模型</a>环境配置</h1><h1 id=\"模型介绍\"><a href=\"#模型介绍\" class=\"headerlink\" title=\"模型介绍\"></a>模型介绍</h1><p>启元九格大模型是由启元实验室联合清华大学、哈尔滨工业大学、中国科学院计算技术研究所、北京大学、南开大学等顶尖科研单位共同研发的高效模型。具备高效训练与推理、高效适配与部署的特点，支持多种自然语言处理（NLP）和多模态任务，包括文本问答、文本分类、机器翻译、文本摘要、图文理解等。模型有4B、7B、70B三种不同尺寸的基础语言模型，适配Nvidia GPU和昇腾NPU。环境配置方法和离线批量推理&#x2F;在线多轮对话的示例代码均已开源。九格模型已经适配到910B npu，支持vllm离线推理和openai api访问。</p>\n<h1 id=\"我的环境配置\"><a href=\"#我的环境配置\" class=\"headerlink\" title=\"我的环境配置\"></a>我的环境配置</h1><ul>\n<li>python 3.10.16</li>\n<li>cuda11.8</li>\n</ul>\n<h1 id=\"流程\"><a href=\"#流程\" class=\"headerlink\" title=\"流程\"></a>流程</h1><h2 id=\"配置环境\"><a href=\"#配置环境\" class=\"headerlink\" title=\"配置环境\"></a>配置环境</h2><figure class=\"highlight jsx\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">conda create -n fm9g4bv python=<span class=\"number\">3.10</span><span class=\"number\">.16</span></span><br><span class=\"line\"></span><br><span class=\"line\">conda activate fm9g4bv</span><br><span class=\"line\"></span><br><span class=\"line\">pip3 install torch torchvision torchaudio --index-url <span class=\"attr\">https</span>:<span class=\"comment\">//download.pytorch.org/whl/cu118</span></span><br></pre></td></tr></table></figure>\n\n<h2 id=\"克隆项目\"><a href=\"#克隆项目\" class=\"headerlink\" title=\"克隆项目\"></a>克隆项目</h2><blockquote>\n<p>这里克隆的是main分支,没有克隆-V后缀的分支，-V后缀的分支<br>有对应的推理和微调的代码以及requirements.txt文件<br><a href=\"https://www.osredm.com/jiuyuan/CPM-9G-8B/tree/FM9G-V/FM9G4B-V\">-V分支的链接</a></p>\n</blockquote>\n<figure class=\"highlight jsx\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">git clone <span class=\"attr\">https</span>:<span class=\"comment\">//osredm.com/p49102387/CPM-9G-8B.git</span></span><br><span class=\"line\">cd <span class=\"variable constant_\">CPM</span>-9G-8B</span><br><span class=\"line\"></span><br><span class=\"line\">wget <span class=\"attr\">https</span>:<span class=\"comment\">//github.com/vllm-project/vllm/releases/download/v0.10.0/vllm-0.10.0+cu118-cp38-abi3-manylinux1_x86_64.whl</span></span><br><span class=\"line\"></span><br></pre></td></tr></table></figure>\n\n<p>创建 requirements.txt文件</p>\n<figure class=\"highlight jsx\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">packaging==<span class=\"number\">23.2</span></span><br><span class=\"line\">addict==<span class=\"number\">2.4</span><span class=\"number\">.0</span></span><br><span class=\"line\">editdistance==<span class=\"number\">0.6</span><span class=\"number\">.2</span></span><br><span class=\"line\">einops==<span class=\"number\">0.8</span><span class=\"number\">.0</span></span><br><span class=\"line\">fairscale==<span class=\"number\">0.4</span><span class=\"number\">.0</span></span><br><span class=\"line\">jsonlines==<span class=\"number\">4.0</span><span class=\"number\">.0</span></span><br><span class=\"line\">markdown2==<span class=\"number\">2.4</span><span class=\"number\">.10</span></span><br><span class=\"line\">matplotlib==<span class=\"number\">3.7</span><span class=\"number\">.4</span></span><br><span class=\"line\">more_itertools==<span class=\"number\">10.1</span><span class=\"number\">.0</span></span><br><span class=\"line\">nltk==<span class=\"number\">3.8</span><span class=\"number\">.1</span></span><br><span class=\"line\">numpy==<span class=\"number\">1.24</span><span class=\"number\">.4</span></span><br><span class=\"line\">opencv_python_headless==<span class=\"number\">4.5</span><span class=\"number\">.5</span><span class=\"number\">.64</span></span><br><span class=\"line\">openpyxl==<span class=\"number\">3.1</span><span class=\"number\">.2</span></span><br><span class=\"line\"><span class=\"title class_\">Pillow</span>==<span class=\"number\">10.1</span><span class=\"number\">.0</span></span><br><span class=\"line\">sacrebleu==<span class=\"number\">2.3</span><span class=\"number\">.2</span></span><br><span class=\"line\">seaborn==<span class=\"number\">0.13</span><span class=\"number\">.0</span></span><br><span class=\"line\">shortuuid==<span class=\"number\">1.0</span><span class=\"number\">.11</span></span><br><span class=\"line\">spacy==<span class=\"number\">3.7</span><span class=\"number\">.2</span></span><br><span class=\"line\">torch==<span class=\"number\">2.2</span><span class=\"number\">.0</span></span><br><span class=\"line\">torchaudio==<span class=\"number\">2.2</span><span class=\"number\">.0</span></span><br><span class=\"line\">torchvision==<span class=\"number\">0.17</span><span class=\"number\">.0</span></span><br><span class=\"line\">timm==<span class=\"number\">0.9</span><span class=\"number\">.10</span></span><br><span class=\"line\">tqdm==<span class=\"number\">4.66</span><span class=\"number\">.1</span></span><br><span class=\"line\">protobuf==<span class=\"number\">4.25</span><span class=\"number\">.0</span></span><br><span class=\"line\">typing_extensions==<span class=\"number\">4.8</span><span class=\"number\">.0</span></span><br><span class=\"line\">uvicorn==<span class=\"number\">0.24</span><span class=\"number\">.0</span>.<span class=\"property\">post1</span></span><br><span class=\"line\">#xformers==<span class=\"number\">0.0</span><span class=\"number\">.22</span>.<span class=\"property\">post7</span></span><br><span class=\"line\">#flash_attn==<span class=\"number\">2.3</span><span class=\"number\">.4</span></span><br><span class=\"line\">sentencepiece==<span class=\"number\">0.1</span><span class=\"number\">.99</span></span><br><span class=\"line\">accelerate==<span class=\"number\">0.30</span><span class=\"number\">.1</span></span><br><span class=\"line\">socksio==<span class=\"number\">1.0</span><span class=\"number\">.0</span></span><br><span class=\"line\">gradio</span><br><span class=\"line\">gradio_client</span><br><span class=\"line\">&lt;<span class=\"attr\">http</span>:<span class=\"comment\">//thunlp.oss-cn-qingdao.aliyuncs.com/multi_modal/never_delete/modelscope_studio-0.4.0.9-py3-none-any.whl&gt;</span></span><br><span class=\"line\">decord</span><br><span class=\"line\">aiosignal</span><br><span class=\"line\">tensorboard</span><br><span class=\"line\">deepspeed==<span class=\"number\">0.12</span><span class=\"number\">.3</span></span><br><span class=\"line\">transformers==<span class=\"number\">4.44</span><span class=\"number\">.2</span></span><br><span class=\"line\">librosa==<span class=\"number\">0.9</span><span class=\"number\">.0</span></span><br><span class=\"line\">soundfile==<span class=\"number\">0.12</span><span class=\"number\">.1</span></span><br><span class=\"line\">vector-quantize-pytorch==<span class=\"number\">1.18</span><span class=\"number\">.5</span></span><br><span class=\"line\">vocos==<span class=\"number\">0.1</span><span class=\"number\">.0</span></span><br><span class=\"line\">peft==<span class=\"number\">0.14</span><span class=\"number\">.0</span></span><br><span class=\"line\">ninja==<span class=\"number\">1.11</span><span class=\"number\">.1</span><span class=\"number\">.1</span></span><br><span class=\"line\">moviepy </span><br></pre></td></tr></table></figure>\n\n<figure class=\"highlight jsx\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">pip install -r requirements.<span class=\"property\">txt</span></span><br><span class=\"line\"></span><br><span class=\"line\">pip install vllm-<span class=\"number\">0.10</span><span class=\"number\">.0</span>+cu118-cp38-abi3-manylinux1_x86_64.<span class=\"property\">whl</span></span><br></pre></td></tr></table></figure>\n\n<p><img src=\"https://tk-pichost-1325224430.cos.ap-chengdu.myqcloud.com/blog/1753762025700image.png\" alt=\"1753762025700image.png\"></p>\n<p><img src=\"https://tk-pichost-1325224430.cos.ap-chengdu.myqcloud.com/blog/17537624515762025729.png\" alt=\"17537624515762025729.png\"></p>\n<figure class=\"highlight jsx\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">mkdir ckpt</span><br><span class=\"line\">cd cpkt</span><br><span class=\"line\">wget <span class=\"attr\">https</span>:<span class=\"comment\">//thunlp-model.oss-cn-wulanchabu.aliyuncs.com/FM9G4B-V.tar.gz</span></span><br><span class=\"line\">tar -xzf <span class=\"title class_\">FM9G</span>4B-V.<span class=\"property\">tar</span>.<span class=\"property\">gz</span></span><br></pre></td></tr></table></figure>\n\n<h1 id=\"放置推理文件\"><a href=\"#放置推理文件\" class=\"headerlink\" title=\"放置推理文件\"></a>放置推理文件</h1><blockquote>\n<p>后面可以尝试微调的，这里只试了推理的<br><a href=\"https://www.osredm.com/jiuyuan/CPM-9G-8B/tree/FM9G-V/FM9G4B-V/inference\">所有分支-启元实验室&#x2F;九格通用基础大模型</a></p>\n</blockquote>\n<figure class=\"highlight jsx\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">cd ..</span><br><span class=\"line\">创建chat.<span class=\"property\">py</span>文件</span><br></pre></td></tr></table></figure>\n\n<figure class=\"highlight jsx\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br><span class=\"line\">47</span><br><span class=\"line\">48</span><br><span class=\"line\">49</span><br><span class=\"line\">50</span><br><span class=\"line\">51</span><br><span class=\"line\">52</span><br><span class=\"line\">53</span><br><span class=\"line\">54</span><br><span class=\"line\">55</span><br><span class=\"line\">56</span><br><span class=\"line\">57</span><br><span class=\"line\">58</span><br><span class=\"line\">59</span><br><span class=\"line\">60</span><br><span class=\"line\">61</span><br><span class=\"line\">62</span><br><span class=\"line\">63</span><br><span class=\"line\">64</span><br><span class=\"line\">65</span><br><span class=\"line\">66</span><br><span class=\"line\">67</span><br><span class=\"line\">68</span><br><span class=\"line\">69</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"string\">&quot;&quot;</span><span class=\"string\">&quot;</span></span><br><span class=\"line\"><span class=\"string\">Name chat.py</span></span><br><span class=\"line\"><span class=\"string\">Date 2025/5/6 11:20</span></span><br><span class=\"line\"><span class=\"string\">Version 1.0</span></span><br><span class=\"line\"><span class=\"string\">TODO:</span></span><br><span class=\"line\"><span class=\"string\">&quot;</span><span class=\"string\">&quot;&quot;</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">import</span> torch</span><br><span class=\"line\"><span class=\"keyword\">from</span> <span class=\"variable constant_\">PIL</span> <span class=\"keyword\">import</span> <span class=\"title class_\">Image</span></span><br><span class=\"line\"><span class=\"keyword\">from</span> transformers <span class=\"keyword\">import</span> <span class=\"title class_\">AutoModel</span>, <span class=\"title class_\">AutoTokenizer</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">if</span> __name__ == <span class=\"string\">&#x27;__main__&#x27;</span>:</span><br><span class=\"line\">    prompt = f<span class=\"string\">&quot;&quot;</span><span class=\"string\">&quot;### 背景 ###</span></span><br><span class=\"line\"><span class=\"string\">        您需要对图片中的内容进行识别。</span></span><br><span class=\"line\"><span class=\"string\">        ### 输出格式 ### </span></span><br><span class=\"line\"><span class=\"string\">        您的输出由以下两部分组成，确保您的输出包含这两部分:</span></span><br><span class=\"line\"><span class=\"string\">        ### 思考 ###</span></span><br><span class=\"line\"><span class=\"string\">        考虑饮料外的标识，辨别饮料的种类，饮料容器。并且识别饮料为&#x27;有糖&#x27;或者&#x27;无糖&#x27;，给出你的思考过程。</span></span><br><span class=\"line\"><span class=\"string\">        ### 识别结果 ### </span></span><br><span class=\"line\"><span class=\"string\">        若图中出现了饮料，请以json形式从左到右对他们进行描述，包括饮料：种类，是否有糖，饮料容器。</span></span><br><span class=\"line\"><span class=\"string\">    &quot;</span><span class=\"string\">&quot;&quot;</span></span><br><span class=\"line\"></span><br><span class=\"line\">    model_file = <span class=\"string\">&#x27;ckpt/FM9G4B-V&#x27;</span> ### 这里要改成你的bin文件对应的*目录*</span><br><span class=\"line\">    model = <span class=\"title class_\">AutoModel</span>.<span class=\"title function_\">from_pretrained</span>(model_file, trust_remote_code=<span class=\"title class_\">True</span>,</span><br><span class=\"line\">        attn_implementation=<span class=\"string\">&#x27;sdpa&#x27;</span>, torch_dtype=torch.<span class=\"property\">bfloat16</span>)</span><br><span class=\"line\">    model = model.<span class=\"built_in\">eval</span>().<span class=\"title function_\">cuda</span>()</span><br><span class=\"line\">    tokenizer = <span class=\"title class_\">AutoTokenizer</span>.<span class=\"title function_\">from_pretrained</span>(model_file, trust_remote_code=<span class=\"title class_\">True</span>)</span><br><span class=\"line\"></span><br><span class=\"line\">    image = <span class=\"title class_\">Image</span>.<span class=\"title function_\">open</span>(<span class=\"string\">&#x27;step.jpg&#x27;</span>).<span class=\"title function_\">convert</span>(<span class=\"string\">&#x27;RGB&#x27;</span>)</span><br><span class=\"line\"></span><br><span class=\"line\">    msgs = [&#123;<span class=\"string\">&#x27;role&#x27;</span>: <span class=\"string\">&#x27;user&#x27;</span>, <span class=\"string\">&#x27;content&#x27;</span>: [image, prompt]&#125;]</span><br><span class=\"line\"></span><br><span class=\"line\">    res = model.<span class=\"title function_\">chat</span>(</span><br><span class=\"line\">        image=<span class=\"title class_\">None</span>,</span><br><span class=\"line\">        msgs=msgs,</span><br><span class=\"line\">        tokenizer=tokenizer</span><br><span class=\"line\">    )</span><br><span class=\"line\">    <span class=\"title function_\">print</span>(<span class=\"string\">&quot;\\n&quot;</span>, <span class=\"string\">&quot;=&quot;</span>*<span class=\"number\">100</span>, <span class=\"string\">&quot;\\n&quot;</span>)</span><br><span class=\"line\">    <span class=\"title function_\">print</span>(res)</span><br><span class=\"line\"></span><br><span class=\"line\">    # 第二轮聊天，传递多轮对话的历史信息</span><br><span class=\"line\">    msgs.<span class=\"title function_\">append</span>(&#123;<span class=\"string\">&quot;role&quot;</span>: <span class=\"string\">&quot;assistant&quot;</span>, <span class=\"string\">&quot;content&quot;</span>: [res]&#125;)</span><br><span class=\"line\">    msgs.<span class=\"title function_\">append</span>(&#123;<span class=\"string\">&quot;role&quot;</span>: <span class=\"string\">&quot;user&quot;</span>, <span class=\"string\">&quot;content&quot;</span>: [<span class=\"string\">&quot;图中有几个箱子?&quot;</span>]&#125;)</span><br><span class=\"line\"></span><br><span class=\"line\">    answer = model.<span class=\"title function_\">chat</span>(</span><br><span class=\"line\">        image=<span class=\"title class_\">None</span>,</span><br><span class=\"line\">        msgs=msgs,</span><br><span class=\"line\">        tokenizer=tokenizer</span><br><span class=\"line\">    )</span><br><span class=\"line\">    <span class=\"title function_\">print</span>(<span class=\"string\">&quot;\\n&quot;</span>, <span class=\"string\">&quot;=&quot;</span>*<span class=\"number\">100</span>, <span class=\"string\">&quot;\\n&quot;</span>)</span><br><span class=\"line\">    <span class=\"title function_\">print</span>(answer)</span><br><span class=\"line\"></span><br><span class=\"line\">    ## 流式输出，设置：</span><br><span class=\"line\">    # sampling=<span class=\"title class_\">True</span></span><br><span class=\"line\">    # stream=<span class=\"title class_\">True</span></span><br><span class=\"line\">    ## 返回一个生成器</span><br><span class=\"line\">    msgs = [&#123;<span class=\"string\">&#x27;role&#x27;</span>: <span class=\"string\">&#x27;user&#x27;</span>, <span class=\"string\">&#x27;content&#x27;</span>: [image, prompt]&#125;]</span><br><span class=\"line\">    res = model.<span class=\"title function_\">chat</span>(</span><br><span class=\"line\">        image=<span class=\"title class_\">None</span>,</span><br><span class=\"line\">        msgs=msgs,</span><br><span class=\"line\">        tokenizer=tokenizer,</span><br><span class=\"line\">        sampling=<span class=\"title class_\">True</span>,</span><br><span class=\"line\">        stream=<span class=\"title class_\">True</span></span><br><span class=\"line\">    )</span><br><span class=\"line\">    <span class=\"title function_\">print</span>(<span class=\"string\">&quot;\\n&quot;</span>, <span class=\"string\">&quot;=&quot;</span>*<span class=\"number\">100</span>, <span class=\"string\">&quot;\\n&quot;</span>)</span><br><span class=\"line\">    generated_text = <span class=\"string\">&quot;&quot;</span></span><br><span class=\"line\">    <span class=\"keyword\">for</span> new_text <span class=\"keyword\">in</span> <span class=\"attr\">res</span>:</span><br><span class=\"line\">        generated_text += new_text</span><br><span class=\"line\">        <span class=\"title function_\">print</span>(new_text, flush=<span class=\"title class_\">True</span>, end=<span class=\"string\">&#x27;&#x27;</span>)</span><br></pre></td></tr></table></figure>\n\n<p>加入setup.jpg文件</p>\n<p><img src=\"https://tk-pichost-1325224430.cos.ap-chengdu.myqcloud.com/blog/175376247066220257292.png\" alt=\"175376247066220257292.png\"></p>\n<p>运行推理</p>\n<figure class=\"highlight jsx\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">python chat.<span class=\"property\">py</span></span><br></pre></td></tr></table></figure>\n\n<h1 id=\"推理结果\"><a href=\"#推理结果\" class=\"headerlink\" title=\"推理结果\"></a>推理结果</h1><p><img src=\"https://tk-pichost-1325224430.cos.ap-chengdu.myqcloud.com/blog/1753763153738981067d09c329dc48c5077992a5067e4.png\" alt=\"1753763153738981067d09c329dc48c5077992a5067e4.png\"></p>\n","excerpt":"","more":"<h1 id=\"九格通用基础大模型环境配置\"><a href=\"#九格通用基础大模型环境配置\" class=\"headerlink\" title=\"九格通用基础大模型环境配置\"></a><a href=\"https://www.osredm.com/jiuyuan/CPM-9G-8B\" title=\"九格通用基础大模型\">九格通用基础大模型</a>环境配置</h1><h1 id=\"模型介绍\"><a href=\"#模型介绍\" class=\"headerlink\" title=\"模型介绍\"></a>模型介绍</h1><p>启元九格大模型是由启元实验室联合清华大学、哈尔滨工业大学、中国科学院计算技术研究所、北京大学、南开大学等顶尖科研单位共同研发的高效模型。具备高效训练与推理、高效适配与部署的特点，支持多种自然语言处理（NLP）和多模态任务，包括文本问答、文本分类、机器翻译、文本摘要、图文理解等。模型有4B、7B、70B三种不同尺寸的基础语言模型，适配Nvidia GPU和昇腾NPU。环境配置方法和离线批量推理&#x2F;在线多轮对话的示例代码均已开源。九格模型已经适配到910B npu，支持vllm离线推理和openai api访问。</p>\n<h1 id=\"我的环境配置\"><a href=\"#我的环境配置\" class=\"headerlink\" title=\"我的环境配置\"></a>我的环境配置</h1><ul>\n<li>python 3.10.16</li>\n<li>cuda11.8</li>\n</ul>\n<h1 id=\"流程\"><a href=\"#流程\" class=\"headerlink\" title=\"流程\"></a>流程</h1><h2 id=\"配置环境\"><a href=\"#配置环境\" class=\"headerlink\" title=\"配置环境\"></a>配置环境</h2><figure class=\"highlight jsx\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">conda create -n fm9g4bv python=<span class=\"number\">3.10</span><span class=\"number\">.16</span></span><br><span class=\"line\"></span><br><span class=\"line\">conda activate fm9g4bv</span><br><span class=\"line\"></span><br><span class=\"line\">pip3 install torch torchvision torchaudio --index-url <span class=\"attr\">https</span>:<span class=\"comment\">//download.pytorch.org/whl/cu118</span></span><br></pre></td></tr></table></figure>\n\n<h2 id=\"克隆项目\"><a href=\"#克隆项目\" class=\"headerlink\" title=\"克隆项目\"></a>克隆项目</h2><blockquote>\n<p>这里克隆的是main分支,没有克隆-V后缀的分支，-V后缀的分支<br>有对应的推理和微调的代码以及requirements.txt文件<br><a href=\"https://www.osredm.com/jiuyuan/CPM-9G-8B/tree/FM9G-V/FM9G4B-V\">-V分支的链接</a></p>\n</blockquote>\n<figure class=\"highlight jsx\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">git clone <span class=\"attr\">https</span>:<span class=\"comment\">//osredm.com/p49102387/CPM-9G-8B.git</span></span><br><span class=\"line\">cd <span class=\"variable constant_\">CPM</span>-9G-8B</span><br><span class=\"line\"></span><br><span class=\"line\">wget <span class=\"attr\">https</span>:<span class=\"comment\">//github.com/vllm-project/vllm/releases/download/v0.10.0/vllm-0.10.0+cu118-cp38-abi3-manylinux1_x86_64.whl</span></span><br><span class=\"line\"></span><br></pre></td></tr></table></figure>\n\n<p>创建 requirements.txt文件</p>\n<figure class=\"highlight jsx\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">packaging==<span class=\"number\">23.2</span></span><br><span class=\"line\">addict==<span class=\"number\">2.4</span><span class=\"number\">.0</span></span><br><span class=\"line\">editdistance==<span class=\"number\">0.6</span><span class=\"number\">.2</span></span><br><span class=\"line\">einops==<span class=\"number\">0.8</span><span class=\"number\">.0</span></span><br><span class=\"line\">fairscale==<span class=\"number\">0.4</span><span class=\"number\">.0</span></span><br><span class=\"line\">jsonlines==<span class=\"number\">4.0</span><span class=\"number\">.0</span></span><br><span class=\"line\">markdown2==<span class=\"number\">2.4</span><span class=\"number\">.10</span></span><br><span class=\"line\">matplotlib==<span class=\"number\">3.7</span><span class=\"number\">.4</span></span><br><span class=\"line\">more_itertools==<span class=\"number\">10.1</span><span class=\"number\">.0</span></span><br><span class=\"line\">nltk==<span class=\"number\">3.8</span><span class=\"number\">.1</span></span><br><span class=\"line\">numpy==<span class=\"number\">1.24</span><span class=\"number\">.4</span></span><br><span class=\"line\">opencv_python_headless==<span class=\"number\">4.5</span><span class=\"number\">.5</span><span class=\"number\">.64</span></span><br><span class=\"line\">openpyxl==<span class=\"number\">3.1</span><span class=\"number\">.2</span></span><br><span class=\"line\"><span class=\"title class_\">Pillow</span>==<span class=\"number\">10.1</span><span class=\"number\">.0</span></span><br><span class=\"line\">sacrebleu==<span class=\"number\">2.3</span><span class=\"number\">.2</span></span><br><span class=\"line\">seaborn==<span class=\"number\">0.13</span><span class=\"number\">.0</span></span><br><span class=\"line\">shortuuid==<span class=\"number\">1.0</span><span class=\"number\">.11</span></span><br><span class=\"line\">spacy==<span class=\"number\">3.7</span><span class=\"number\">.2</span></span><br><span class=\"line\">torch==<span class=\"number\">2.2</span><span class=\"number\">.0</span></span><br><span class=\"line\">torchaudio==<span class=\"number\">2.2</span><span class=\"number\">.0</span></span><br><span class=\"line\">torchvision==<span class=\"number\">0.17</span><span class=\"number\">.0</span></span><br><span class=\"line\">timm==<span class=\"number\">0.9</span><span class=\"number\">.10</span></span><br><span class=\"line\">tqdm==<span class=\"number\">4.66</span><span class=\"number\">.1</span></span><br><span class=\"line\">protobuf==<span class=\"number\">4.25</span><span class=\"number\">.0</span></span><br><span class=\"line\">typing_extensions==<span class=\"number\">4.8</span><span class=\"number\">.0</span></span><br><span class=\"line\">uvicorn==<span class=\"number\">0.24</span><span class=\"number\">.0</span>.<span class=\"property\">post1</span></span><br><span class=\"line\">#xformers==<span class=\"number\">0.0</span><span class=\"number\">.22</span>.<span class=\"property\">post7</span></span><br><span class=\"line\">#flash_attn==<span class=\"number\">2.3</span><span class=\"number\">.4</span></span><br><span class=\"line\">sentencepiece==<span class=\"number\">0.1</span><span class=\"number\">.99</span></span><br><span class=\"line\">accelerate==<span class=\"number\">0.30</span><span class=\"number\">.1</span></span><br><span class=\"line\">socksio==<span class=\"number\">1.0</span><span class=\"number\">.0</span></span><br><span class=\"line\">gradio</span><br><span class=\"line\">gradio_client</span><br><span class=\"line\">&lt;<span class=\"attr\">http</span>:<span class=\"comment\">//thunlp.oss-cn-qingdao.aliyuncs.com/multi_modal/never_delete/modelscope_studio-0.4.0.9-py3-none-any.whl&gt;</span></span><br><span class=\"line\">decord</span><br><span class=\"line\">aiosignal</span><br><span class=\"line\">tensorboard</span><br><span class=\"line\">deepspeed==<span class=\"number\">0.12</span><span class=\"number\">.3</span></span><br><span class=\"line\">transformers==<span class=\"number\">4.44</span><span class=\"number\">.2</span></span><br><span class=\"line\">librosa==<span class=\"number\">0.9</span><span class=\"number\">.0</span></span><br><span class=\"line\">soundfile==<span class=\"number\">0.12</span><span class=\"number\">.1</span></span><br><span class=\"line\">vector-quantize-pytorch==<span class=\"number\">1.18</span><span class=\"number\">.5</span></span><br><span class=\"line\">vocos==<span class=\"number\">0.1</span><span class=\"number\">.0</span></span><br><span class=\"line\">peft==<span class=\"number\">0.14</span><span class=\"number\">.0</span></span><br><span class=\"line\">ninja==<span class=\"number\">1.11</span><span class=\"number\">.1</span><span class=\"number\">.1</span></span><br><span class=\"line\">moviepy </span><br></pre></td></tr></table></figure>\n\n<figure class=\"highlight jsx\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">pip install -r requirements.<span class=\"property\">txt</span></span><br><span class=\"line\"></span><br><span class=\"line\">pip install vllm-<span class=\"number\">0.10</span><span class=\"number\">.0</span>+cu118-cp38-abi3-manylinux1_x86_64.<span class=\"property\">whl</span></span><br></pre></td></tr></table></figure>\n\n<p><img src=\"https://tk-pichost-1325224430.cos.ap-chengdu.myqcloud.com/blog/1753762025700image.png\" alt=\"1753762025700image.png\"></p>\n<p><img src=\"https://tk-pichost-1325224430.cos.ap-chengdu.myqcloud.com/blog/17537624515762025729.png\" alt=\"17537624515762025729.png\"></p>\n<figure class=\"highlight jsx\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">mkdir ckpt</span><br><span class=\"line\">cd cpkt</span><br><span class=\"line\">wget <span class=\"attr\">https</span>:<span class=\"comment\">//thunlp-model.oss-cn-wulanchabu.aliyuncs.com/FM9G4B-V.tar.gz</span></span><br><span class=\"line\">tar -xzf <span class=\"title class_\">FM9G</span>4B-V.<span class=\"property\">tar</span>.<span class=\"property\">gz</span></span><br></pre></td></tr></table></figure>\n\n<h1 id=\"放置推理文件\"><a href=\"#放置推理文件\" class=\"headerlink\" title=\"放置推理文件\"></a>放置推理文件</h1><blockquote>\n<p>后面可以尝试微调的，这里只试了推理的<br><a href=\"https://www.osredm.com/jiuyuan/CPM-9G-8B/tree/FM9G-V/FM9G4B-V/inference\">所有分支-启元实验室&#x2F;九格通用基础大模型</a></p>\n</blockquote>\n<figure class=\"highlight jsx\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">cd ..</span><br><span class=\"line\">创建chat.<span class=\"property\">py</span>文件</span><br></pre></td></tr></table></figure>\n\n<figure class=\"highlight jsx\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br><span class=\"line\">47</span><br><span class=\"line\">48</span><br><span class=\"line\">49</span><br><span class=\"line\">50</span><br><span class=\"line\">51</span><br><span class=\"line\">52</span><br><span class=\"line\">53</span><br><span class=\"line\">54</span><br><span class=\"line\">55</span><br><span class=\"line\">56</span><br><span class=\"line\">57</span><br><span class=\"line\">58</span><br><span class=\"line\">59</span><br><span class=\"line\">60</span><br><span class=\"line\">61</span><br><span class=\"line\">62</span><br><span class=\"line\">63</span><br><span class=\"line\">64</span><br><span class=\"line\">65</span><br><span class=\"line\">66</span><br><span class=\"line\">67</span><br><span class=\"line\">68</span><br><span class=\"line\">69</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"string\">&quot;&quot;</span><span class=\"string\">&quot;</span></span><br><span class=\"line\"><span class=\"string\">Name chat.py</span></span><br><span class=\"line\"><span class=\"string\">Date 2025/5/6 11:20</span></span><br><span class=\"line\"><span class=\"string\">Version 1.0</span></span><br><span class=\"line\"><span class=\"string\">TODO:</span></span><br><span class=\"line\"><span class=\"string\">&quot;</span><span class=\"string\">&quot;&quot;</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">import</span> torch</span><br><span class=\"line\"><span class=\"keyword\">from</span> <span class=\"variable constant_\">PIL</span> <span class=\"keyword\">import</span> <span class=\"title class_\">Image</span></span><br><span class=\"line\"><span class=\"keyword\">from</span> transformers <span class=\"keyword\">import</span> <span class=\"title class_\">AutoModel</span>, <span class=\"title class_\">AutoTokenizer</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">if</span> __name__ == <span class=\"string\">&#x27;__main__&#x27;</span>:</span><br><span class=\"line\">    prompt = f<span class=\"string\">&quot;&quot;</span><span class=\"string\">&quot;### 背景 ###</span></span><br><span class=\"line\"><span class=\"string\">        您需要对图片中的内容进行识别。</span></span><br><span class=\"line\"><span class=\"string\">        ### 输出格式 ### </span></span><br><span class=\"line\"><span class=\"string\">        您的输出由以下两部分组成，确保您的输出包含这两部分:</span></span><br><span class=\"line\"><span class=\"string\">        ### 思考 ###</span></span><br><span class=\"line\"><span class=\"string\">        考虑饮料外的标识，辨别饮料的种类，饮料容器。并且识别饮料为&#x27;有糖&#x27;或者&#x27;无糖&#x27;，给出你的思考过程。</span></span><br><span class=\"line\"><span class=\"string\">        ### 识别结果 ### </span></span><br><span class=\"line\"><span class=\"string\">        若图中出现了饮料，请以json形式从左到右对他们进行描述，包括饮料：种类，是否有糖，饮料容器。</span></span><br><span class=\"line\"><span class=\"string\">    &quot;</span><span class=\"string\">&quot;&quot;</span></span><br><span class=\"line\"></span><br><span class=\"line\">    model_file = <span class=\"string\">&#x27;ckpt/FM9G4B-V&#x27;</span> ### 这里要改成你的bin文件对应的*目录*</span><br><span class=\"line\">    model = <span class=\"title class_\">AutoModel</span>.<span class=\"title function_\">from_pretrained</span>(model_file, trust_remote_code=<span class=\"title class_\">True</span>,</span><br><span class=\"line\">        attn_implementation=<span class=\"string\">&#x27;sdpa&#x27;</span>, torch_dtype=torch.<span class=\"property\">bfloat16</span>)</span><br><span class=\"line\">    model = model.<span class=\"built_in\">eval</span>().<span class=\"title function_\">cuda</span>()</span><br><span class=\"line\">    tokenizer = <span class=\"title class_\">AutoTokenizer</span>.<span class=\"title function_\">from_pretrained</span>(model_file, trust_remote_code=<span class=\"title class_\">True</span>)</span><br><span class=\"line\"></span><br><span class=\"line\">    image = <span class=\"title class_\">Image</span>.<span class=\"title function_\">open</span>(<span class=\"string\">&#x27;step.jpg&#x27;</span>).<span class=\"title function_\">convert</span>(<span class=\"string\">&#x27;RGB&#x27;</span>)</span><br><span class=\"line\"></span><br><span class=\"line\">    msgs = [&#123;<span class=\"string\">&#x27;role&#x27;</span>: <span class=\"string\">&#x27;user&#x27;</span>, <span class=\"string\">&#x27;content&#x27;</span>: [image, prompt]&#125;]</span><br><span class=\"line\"></span><br><span class=\"line\">    res = model.<span class=\"title function_\">chat</span>(</span><br><span class=\"line\">        image=<span class=\"title class_\">None</span>,</span><br><span class=\"line\">        msgs=msgs,</span><br><span class=\"line\">        tokenizer=tokenizer</span><br><span class=\"line\">    )</span><br><span class=\"line\">    <span class=\"title function_\">print</span>(<span class=\"string\">&quot;\\n&quot;</span>, <span class=\"string\">&quot;=&quot;</span>*<span class=\"number\">100</span>, <span class=\"string\">&quot;\\n&quot;</span>)</span><br><span class=\"line\">    <span class=\"title function_\">print</span>(res)</span><br><span class=\"line\"></span><br><span class=\"line\">    # 第二轮聊天，传递多轮对话的历史信息</span><br><span class=\"line\">    msgs.<span class=\"title function_\">append</span>(&#123;<span class=\"string\">&quot;role&quot;</span>: <span class=\"string\">&quot;assistant&quot;</span>, <span class=\"string\">&quot;content&quot;</span>: [res]&#125;)</span><br><span class=\"line\">    msgs.<span class=\"title function_\">append</span>(&#123;<span class=\"string\">&quot;role&quot;</span>: <span class=\"string\">&quot;user&quot;</span>, <span class=\"string\">&quot;content&quot;</span>: [<span class=\"string\">&quot;图中有几个箱子?&quot;</span>]&#125;)</span><br><span class=\"line\"></span><br><span class=\"line\">    answer = model.<span class=\"title function_\">chat</span>(</span><br><span class=\"line\">        image=<span class=\"title class_\">None</span>,</span><br><span class=\"line\">        msgs=msgs,</span><br><span class=\"line\">        tokenizer=tokenizer</span><br><span class=\"line\">    )</span><br><span class=\"line\">    <span class=\"title function_\">print</span>(<span class=\"string\">&quot;\\n&quot;</span>, <span class=\"string\">&quot;=&quot;</span>*<span class=\"number\">100</span>, <span class=\"string\">&quot;\\n&quot;</span>)</span><br><span class=\"line\">    <span class=\"title function_\">print</span>(answer)</span><br><span class=\"line\"></span><br><span class=\"line\">    ## 流式输出，设置：</span><br><span class=\"line\">    # sampling=<span class=\"title class_\">True</span></span><br><span class=\"line\">    # stream=<span class=\"title class_\">True</span></span><br><span class=\"line\">    ## 返回一个生成器</span><br><span class=\"line\">    msgs = [&#123;<span class=\"string\">&#x27;role&#x27;</span>: <span class=\"string\">&#x27;user&#x27;</span>, <span class=\"string\">&#x27;content&#x27;</span>: [image, prompt]&#125;]</span><br><span class=\"line\">    res = model.<span class=\"title function_\">chat</span>(</span><br><span class=\"line\">        image=<span class=\"title class_\">None</span>,</span><br><span class=\"line\">        msgs=msgs,</span><br><span class=\"line\">        tokenizer=tokenizer,</span><br><span class=\"line\">        sampling=<span class=\"title class_\">True</span>,</span><br><span class=\"line\">        stream=<span class=\"title class_\">True</span></span><br><span class=\"line\">    )</span><br><span class=\"line\">    <span class=\"title function_\">print</span>(<span class=\"string\">&quot;\\n&quot;</span>, <span class=\"string\">&quot;=&quot;</span>*<span class=\"number\">100</span>, <span class=\"string\">&quot;\\n&quot;</span>)</span><br><span class=\"line\">    generated_text = <span class=\"string\">&quot;&quot;</span></span><br><span class=\"line\">    <span class=\"keyword\">for</span> new_text <span class=\"keyword\">in</span> <span class=\"attr\">res</span>:</span><br><span class=\"line\">        generated_text += new_text</span><br><span class=\"line\">        <span class=\"title function_\">print</span>(new_text, flush=<span class=\"title class_\">True</span>, end=<span class=\"string\">&#x27;&#x27;</span>)</span><br></pre></td></tr></table></figure>\n\n<p>加入setup.jpg文件</p>\n<p><img src=\"https://tk-pichost-1325224430.cos.ap-chengdu.myqcloud.com/blog/175376247066220257292.png\" alt=\"175376247066220257292.png\"></p>\n<p>运行推理</p>\n<figure class=\"highlight jsx\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">python chat.<span class=\"property\">py</span></span><br></pre></td></tr></table></figure>\n\n<h1 id=\"推理结果\"><a href=\"#推理结果\" class=\"headerlink\" title=\"推理结果\"></a>推理结果</h1><p><img src=\"https://tk-pichost-1325224430.cos.ap-chengdu.myqcloud.com/blog/1753763153738981067d09c329dc48c5077992a5067e4.png\" alt=\"1753763153738981067d09c329dc48c5077992a5067e4.png\"></p>\n"},{"title":"2025-06-08-大模型底层技术分析","date":"2025-06-07T16:00:00.000Z","_content":"# 大模型底层技术分析\n\n# 参考资料\n\n> - [Understanding LLM Decoding Strategies](https://medium.com/@lmpo/mastering-llms-a-guide-to-decoding-algorithms-c90a48fd167b)\n> - [最新「大模型简史」整理！从 Transformer（2017）到 DeepSeek-R1（2025）](https://segmentfault.com/a/1190000046177208)\n> - [大语言模型简史](https://medium.com/@lmpo/%E5%A4%A7%E5%9E%8B%E8%AF%AD%E8%A8%80%E6%A8%A1%E5%9E%8B%E7%AE%80%E5%8F%B2-%E4%BB%8Etransformer-2017-%E5%88%B0deepseek-r1-2025-cc54d658fb43)\n\n# 2025年大语言模型综述论文推荐\n\n> * [Awesome Agent Papers GitHub Repository](https://github.com/luo-junyu/Awesome-Agent-Papers)\n\n以下是三篇 2025 年关于大语言模型的综述论文：\n\n1. ## [A Survey on Large Language Models with some Insights on their Capabilities and Limitations](https://arxiv.org/abs/2501.04040)\n\n* **链接** : [arXiv:2501.04040](https://arxiv.org/abs/2501.04040)\n* **内容概述** :\n  该论文深入探讨 LLMs 的能力，包括文本生成、问答、翻译、摘要、常识推理、代码生成和数学计算，强调其接近人类水平的理解能力。研究分析了基于 Transformer 架构的模型（如 GPT、LLaMA），探讨了数据和计算规模的指数增长对性能的影响。论文还讨论了扩展机制（如参数量增加、上下文长度扩展）和架构策略（如多头注意力、层归一化）。此外，分析了 LLMs 的局限性，如高计算成本、事实错误（hallucination）和伦理问题。应用领域包括医疗（诊断辅助）、金融（风险评估）、教育（智能辅导）和法律（合同分析）。论文还探讨了链式推理（Chain-of-Thought, CoT）和路径推理（Path-of-Thought, PoT）能力，以及 LLM-modulo 框架的泛化性。\n* **贡献** :\n* 提供 LLMs 的全面能力与局限性分析，适合理解技术边界。\n* 覆盖多领域应用，适合跨行业参考。\n* 174 页的详尽内容，计划提交期刊的精简版，信息量丰富。\n\n2. ## [Large Language Models: A Survey](https://arxiv.org/abs/2402.06196)\n\n* **链接** : [arXiv:2402.06196](https://arxiv.org/abs/2402.06196)\n* **内容概述** :\n  该论文是 2024 年初版的更新版本，综述了主流 LLMs（如 GPT、LLaMA、PaLM）的特性、贡献和局限性。研究讨论了构建和增强 LLMs 的技术，包括预训练、微调、分布式训练和高效推理。论文调研了用于训练、微调和评估的热门数据集（如 Common Crawl、The Pile），并回顾了广泛使用的评估指标（如 BLEU、ROUGE、Perplexity）。通过代表性基准测试（如 MMLU、GLUE）比较了多个 LLMs 的性能，分析了其在不同任务上的表现。论文还探讨了开放挑战，如计算效率、数据偏见和模型可解释性，以及未来研究方向（如多模态 LLMs、能源优化）。\n* **贡献** :\n* 提供 LLMs 的技术全景，涵盖架构、数据集和评估。\n* 更新至 2025 年，包含最新模型和优化技术。\n* 强调未来方向，适合预测技术趋势。\n\n3. ## [Large Language Model Agent: A Survey on Methodology, Applications and Challenges](https://arxiv.org/abs/2503.21460)\n\n* **链接** : [arXiv:2503.21460](https://arxiv.org/abs/2503.21460)\n* **内容概述** :\n  该论文聚焦 LLM 智能体，分析其方法论、应用和挑战，涵盖 329 篇相关研究。论文提出了以方法论为中心的分类法，连接架构基础、协作机制和演化路径，统一了智能体设计的研究碎片。讨论了智能体的目标驱动行为和动态适应能力，探索其在复杂环境中的表现。应用场景包括自动化任务分解、协作工作流和多智能体系统。挑战包括计算资源需求、协作效率和评估方法的标准化。论文提供资源库（[GitHub](https://github.com/luo-junyu/Awesome-Agent-Papers)），便于进一步研究。\n* **贡献** :\n* 提供 LLM 智能体的系统性分类，适合深入研究智能体应用。\n* 覆盖广泛应用场景，强调协作机制。\n* 提供开源资源，方便开发者实践。\n\n# 概述\n\n## 什么是语言模型 (Language Models)？\n\n![1749366089085BNAubDynsogt1bxoYrPcAnBlnvh.png](https://gitee.com/tanke11223344/imagehost/raw/main/blog/1749366089085BNAubDynsogt1bxoYrPcAnBlnvh.png)\n\n「语言模型」是一种「人工智能系统」，旨在处理、理解和生成类似人类的语言。它们从大型数据集中学习模式和结构，使得能够产生连贯且上下文相关的文本，应用于翻译、摘要、聊天机器人和内容生成等领域。\n\n### 大型语言模型（LLMs）\n\n「语言模型」（LMs）和「大型语言模型」（LLMs）这两个术语虽然经常被互换使用，但实际上它们基于规模、架构、训练数据和能力指代不同的概念。LLMs 是 LMs 的一个子集，其规模显著更大，通常包含数十亿个参数（例如，GPT-3 拥有 1750 亿个参数）。这种更大的规模使 LLMs 能够在广泛的任务中表现出卓越的性能。“LLM”这一术语在 2018 至 2019 年间随着基于 Transformer 架构的模型（如 BERT 和 GPT-1）的出现开始受到关注。然而，在 2020 年 GPT-3 发布后，这个词才被广泛使用，展示了这些大规模模型的重大影响力和强大能力。\n\n### [自回归语言模型](https://zhida.zhihu.com/search?content_id=255912486&content_type=Article&match_order=1&q=%E8%87%AA%E5%9B%9E%E5%BD%92%E8%AF%AD%E8%A8%80%E6%A8%A1%E5%9E%8B&zhida_source=entity) （Autoregressive Language Models）\n\n大多数 LLMs 以「自回归方式」(Autoregressive)操作，这意味着它们根据前面的「文本」预测下一个「字」（或 token／sub-word）的「概率分布」(propability distribution)。这种自回归特性使模型能够学习复杂的语言模式和依赖关系，从而善于「文本生成」。\n\n$$\n(\\begin{array}{cc}w_1,w_2&,\\ldots,w_{n-1}\\end{array})\\left(w_{n}\\right)P(w_{n}|w_1,w_2,\\ldots,w_{n-1},\\ldots,w_{n-1})\n$$\n\n在文本生成任时，LLM 通过解码算法(Decoding Algorithm)来确定下一个输出的字。\n\n这一过程可以采用不同的策略：既可以选择概率最高的下个字（即贪婪搜索），也可以从预测的概率分布中随机采样一个字。后一种方法使得每次生成的文本都可能有所不同，这种特性与人类语言的多样性和随机性颇为相似。\n\n![1749366102088NG49bUAoXomHelxiq2ZckdIlnpb.png](https://gitee.com/tanke11223344/imagehost/raw/main/blog/1749366102088NG49bUAoXomHelxiq2ZckdIlnpb.png)\n![1749366116880KWu3bn2W2oethdxLzqAcm6xBnWC.png](https://gitee.com/tanke11223344/imagehost/raw/main/blog/1749366116880KWu3bn2W2oethdxLzqAcm6xBnWC.png)\n\n### 生成能力\n\nLLMs 的自回归特性使其能够基于前文提供的上下文逐词生成文本。从「提示」(prompt)开始，如下图，模型通过迭代预测下一个词，直到生成完整的序列或达到预定的停止条件。为了生成对提示的完整回答，LLM 通过将先前选择的标记添加到输入中进行迭代生成，尤如「文字接龙」游戏。\n\n![1749366127852Do7ybXLnFoU5QmxRFcrcML6Lnpf.png](https://gitee.com/tanke11223344/imagehost/raw/main/blog/1749366127852Do7ybXLnFoU5QmxRFcrcML6Lnpf.png)\n\n## Transformer 革命 (2017)\n\n> - [Attention Is All You Need](https://arxiv.org/abs/1706.03762)\n\nVaswani 等人在 2017 年通过其开创性论文“Attention is All You Need”引入了 Transformer 架构，标志着 NLP 的一个分水岭时刻。它解决了早期模型如循环神经网络（RNNs）和长短期记忆网络（LSTMs）的关键限制，这些模型在长程依赖性和顺序处理方面存在困难。这些问题使得使用 RNN 或 LSTM 实现有效的语言模型变得困难，因为它们计算效率低下且容易出现梯度消失等问题。另一方面，Transformers 克服了这些障碍，彻底改变了这一领域，并为现代大型语言模型奠定了基础。\n\n![1749366139852ZnJWbnoMCojKUExcNMZcJaV4nod.png](https://gitee.com/tanke11223344/imagehost/raw/main/blog/1749366139852ZnJWbnoMCojKUExcNMZcJaV4nod.png)\n\n### Transformer 架构的关键创新\n\n自注意力机制 (Self-Attention)：与按顺序处理标记并难以应对长程依赖性的 RNN 不同，Transformers 使用自注意力来权衡每个标记相对于其他标记的重要性。这使得模型能够动态关注输入的相关部分。数学上：\n\n$$\n\\mathrm{Attention}(\\mathbf{Q},\\mathbf{K},\\mathbf{V})=\\mathrm{Softmax}\\left(\\frac{\\mathbf{QK^T}}{\\sqrt{d_k}}\\right)\\mathrm{V}\n$$\n\n这里，Q、K、V 是查询(query)、键(key)和值(value)矩阵，dₖ 是键的维度。自注意力允许并行计算，加快训练速度，同时提高全局上下文理解。\n\n![1749366152088YWvebIv6soDVh2xSALYc4m2vnoc.png](https://gitee.com/tanke11223344/imagehost/raw/main/blog/1749366152088YWvebIv6soDVh2xSALYc4m2vnoc.png)\n\n多头注意力：多个注意力头并行操作，每个头专注于输入的不同方面。它们的输出被连接并转换，从而实现更丰富的上下文表示。\n\n![1749366160852M4bYbd1axoJPw5xY8TzcBDn4n4b.png](https://gitee.com/tanke11223344/imagehost/raw/main/blog/1749366160852M4bYbd1axoJPw5xY8TzcBDn4n4b.png)\n\n前馈网络(FFN)和层归一化(Layer Norm)：每个 Transformer 层包括应用于每个标记的前馈网络，以及层归一化和残差连接。这些稳定了训练并支持更深的架构。\n\n位置编码：由于 Transformers 本身不编码标记顺序，因此添加了位置编码（位置和频率的正弦函数）以表示词序，在不牺牲并行化的情况下保留顺序信息。\n\n![1749366172089We3mbXuFDomJfSxxrwFchohkn3d.png](https://gitee.com/tanke11223344/imagehost/raw/main/blog/1749366172089We3mbXuFDomJfSxxrwFchohkn3d.png)\n\n#### 对语言建模的影响\n\n- 可扩展性：Transformers 实现了完全并行化的计算，使得在大型数据集上训练大规模模型成为可能。\n- 上下文理解：自注意力捕捉局部和全局依赖关系，提高了连贯性和上下文意识。\n\nTransformer 架构的引入为构建能够以前所未有的精确性和灵活性处理复杂任务的大规模高效语言模型奠定了基础。\n\n## **预训练 Transformer 模型时代 (2018–2020)**\n\n2017 年 Transformer 架构的引入为 NLP 的新时代铺平了道路，其特点是预训练模型的兴起和对扩展的前所未有的关注。这一时期见证了两个有影响力的模型家族的出现：BERT 和 GPT，它们展示了大规模预训练和微调范式的强大功能。\n\n### **BERT：双向上下文理解 (2018)**\n\n2018 年，谷歌推出了 BERT（Bidirectional Encoder Representations from Transformers），这是一种使用 Transformer 编码器(Encoder)的突破性模型，在广泛的 NLP 任务中取得了最先进的性能。\n\n与之前单向处理文本（从左到右或从右到左）的模型不同，BERT 采用了双向训练方法，使其能够同时从两个方向捕获上下文。通过生成深层次的、上下文丰富的文本表示，BERT 在文本分类、命名实体识别（NER）、情感分析等语言理解任务中表现出色。\n\n![1749366186892IyVobGCISoulBexHp23ckNjrnpd.png](https://gitee.com/tanke11223344/imagehost/raw/main/blog/1749366186892IyVobGCISoulBexHp23ckNjrnpd.png)\n\nBERT 的关键创新包括：\n\n- 掩码语言建模（Masker Language Modeling — MLM）：BERT 不是预测序列中的下一个词，而是被训练预测句子中随机掩码的标记。这迫使模型在进行预测时考虑整个句子的上下文 — — 包括前后词语。例如，给定句子“The cat sat on the [MASK] mat”，BERT 会学习根据周围上下文预测“soft”。\n- 下一句预测（Next Sentence Prediction — NSP）：除了 MLM 之外，BERT 还接受了称为下一句预测的次要任务训练，其中模型学习预测两个句子是否在文档中连续。这帮助 BERT 在需要理解句子之间关系的任务中表现出色，例如问答和自然语言推理。\n\nBERT 的影响：BERT 的双向训练使其在 GLUE（通用语言理解评估）和 SQuAD（斯坦福问答数据集）等基准测试中取得了突破性的表现。它的成功证明了上下文嵌入的重要性 — — 这些表示根据周围词语动态变化 — — 并为新一代预训练模型铺平了道路。\n\n### **GPT：生成式预训练和自回归文本生成（2018–2020）**\n\n虽然 BERT 优先考虑双向上下文理解，但 OpenAI 的 GPT 系列采用了不同的策略，专注于通过自回归预训练实现生成能力。通过利用 Transformer 的解码器(Decoder)，GPT 模型在自回归语言模型和文本生成方面表现出色。\n\n![1749366197851NG9rbQKhOoiyU8xFnjzcE6dnnVb.png](https://gitee.com/tanke11223344/imagehost/raw/main/blog/1749366197851NG9rbQKhOoiyU8xFnjzcE6dnnVb.png)\n\nGPT (2018)GPT 的第一个版本于 2018 年发布，是一个大规模的 Transformer 模型，经过训练以预测序列中的下一个词，类似于传统语言模型。\n\n- 单向自回归训练：GPT 使用因果语言建模目标进行训练，其中模型仅基于前面的标记预测下一个标记。这使得它特别适合于生成任务，如文本补全、摘要生成和对话生成。\n- 下游任务的微调：GPT 的一个关键贡献是它能够在不需要特定任务架构的情况下针对特定下游任务进行微调。只需添加一个分类头或修改输入格式，GPT 就可以适应诸如情感分析、机器翻译和问答等任务。\n\nGPT-2 (2019)在原版 GPT 的成功基础上，OpenAI 发布了 GPT-2，这是一个参数量达 15 亿的更大模型。GPT-2 展示了令人印象深刻的零样本(Zero-shot)能力，意味着它可以在没有任何特定任务微调的情况下执行任务。例如，它可以生成连贯的文章、回答问题，甚至在语言之间翻译文本，尽管没有明确针对这些任务进行训练。\n\n![1749366209087ZZYMb63vmoBszCxVyMFcGqQXnnf.png](https://gitee.com/tanke11223344/imagehost/raw/main/blog/1749366209087ZZYMb63vmoBszCxVyMFcGqQXnnf.png)\n\nGPT-3 (2020)GPT-3 的发布标志着语言模型规模扩展的一个转折点。凭借惊人的 1750 亿参数(175B parameters)，GPT-3 突破了大规模预训练的可能性界限。它展示了显著的少样本(Few-short)和零样本(Zero-short)学习能力，在推理时只需提供最少或无需示例即可执行任务。GPT-3 的生成能力扩展到了创意写作、编程和复杂推理任务，展示了超大模型的潜力。\n\n![1749366215856SDbBbzF1Go4u1TxVTbjczhGtnze.png](https://gitee.com/tanke11223344/imagehost/raw/main/blog/1749366215856SDbBbzF1Go4u1TxVTbjczhGtnze.png)\n\n![1749366222852FIYObGa7BoUFd8xnGLPcBRdqnPb.png](https://gitee.com/tanke11223344/imagehost/raw/main/blog/1749366222852FIYObGa7BoUFd8xnGLPcBRdqnPb.png)\n\n#### GPT 的影响及规模的作用\n\nGPT 模型的引入，特别是 GPT-3，标志着 AI 的一个变革时代，展示了自回归架构和生成能力的强大功能。这些模型为内容创作、对话代理和自动推理等应用开辟了新的可能性，在广泛的任务中达到了接近人类的表现。GPT-3 凭借其 1750 亿参数证明了规模的深远影响，表明在大规模数据集上训练的更大模型可以树立新的 AI 能力标杆。\n\n![1749366235853QJZ3b7F2Coy8CUxlx7pcDmmhnOb.png](https://gitee.com/tanke11223344/imagehost/raw/main/blog/1749366235853QJZ3b7F2Coy8CUxlx7pcDmmhnOb.png)\n\n> 语言建模性能随着模型大小、数据集大小和训练使用的计算量的增加而平稳提升。\n> [Scaling Laws for Neural Language Models](https://arxiv.org/abs/2001.08361)\n\n在 2018 年至 2020 年间，该领域由对规模的不懈追求驱动。研究人员发现，随着模型规模的增长 — — 从数百万到数十亿参数 — — 它们在捕捉复杂模式和泛化到新任务方面变得更好。这种规模效应得到了三个关键因素的支持：\n\n- 数据集大小：更大的模型需要庞大的数据集进行预训练。例如，GPT-3 是在大量互联网文本语料库上进行训练的，使其能够学习多样化的语言模式和知识领域。\n- 计算资源：强大的硬件（如 GPU 和 TPU）的可用性以及分布式训练技术，使得高效训练具有数十亿参数的模型成为可能。\n- 高效架构：混合精度训练和梯度检查点等创新降低了计算成本，使得在合理的时间和预算内进行大规模训练更加实际。\n\n这个规模扩展的时代不仅提升了语言模型的性能，还为未来的 AI 突破奠定了基础，强调了规模、数据和计算在实现最先进结果中的重要性。\n\n## **后训练对齐：弥合 AI 与人类价值观之间的差距 (2021–2022)**\n\nGPT-3（一个拥有 1750 亿参数的 LLM）生成几乎无法与人类写作区分的文本的能力引发了关于 AI 生成内容的真实性和可信度的重大担忧。\n\n尽管这一成就标志着 AI 发展的一个重要里程碑，但也突显了确保这些模型与人类价值观、偏好和期望保持一致的关键挑战。一个主要问题是「幻觉」（Hallucination），即 LLM 生成与事实不符、无意义或与输入提示矛盾的内容，给人一种「一本正经地胡说八道」的印象。\n\n为了解决这些挑战，2021 年和 2022 年的研究人员专注于改善与人类意图的一致性并减少幻觉，导致了监督微调（SFT）和基于人类反馈的强化学习（RLHF）等技术的发展。\n\n### **监督微调 (SFT)**\n\n增强 GPT-3 对齐能力的第一步是监督微调（SFT），这是 RLHF 框架的基础组成部分。SFT 类似于指令调优，涉及在高质量的输入-输出对或演示上训练模型，以教它如何遵循指令并生成所需的输出。\n\n![1749366280852MfpwbkcnioN5lXxMOPgc4gyhnld.png](https://gitee.com/tanke11223344/imagehost/raw/main/blog/1749366280852MfpwbkcnioN5lXxMOPgc4gyhnld.png)\n\n这些演示经过精心策划，以反映预期的行为和结果，确保模型学会生成准确且符合上下文的响应。\n\n![1749366299852Y3fRbjJ0OoOLhVxvXBwcQkp7nti.png](https://gitee.com/tanke11223344/imagehost/raw/main/blog/1749366299852Y3fRbjJ0OoOLhVxvXBwcQkp7nti.png)\n\n然而，SFT 本身有局限性：\n\n1. 可扩展性：收集人类演示是劳动密集型且耗时的，尤其是对于复杂或小众任务。\n2. 性能：简单模仿人类行为并不能保证模型会超越人类表现或在未见过的任务上很好地泛化。\n\n为了克服这些挑战，需要一种更具可扩展性和效率的方法，为下一步铺平了道路：基于人类反馈的强化学习（Reinforcement Learning from Human Feedback — RLHF）。\n\n### **基于人类反馈的强化学习 (RLHF)**\n\nOpenAI 在 2022 年引入的 RLHF 解决了 SFT 的可扩展性和性能限制。与需要人类编写完整输出的 SFT 不同，RLHF 涉及根据质量对多个模型生成的输出进行排名。这种方法允许更高效的数据收集和标注，显著增强了可扩展性。\n\nRLHF 过程包括两个关键阶段：\n\n1. 训练奖励模型：人类注释者对模型生成的多个输出进行排名，创建一个偏好数据集。这些数据用于训练一个奖励模型，该模型学习根据人类反馈评估输出的质量。\n2. 使用强化学习微调 LLM：奖励模型使用近端策略优化（Proximal Policy Optimization - PPO）（一种强化学习算法）指导 LLM 的微调。通过迭代更新，模型学会了生成更符合人类偏好和期望的输出。\n\n这个两阶段过程 — — 结合 SFT 和 RLHF — — 使模型不仅能够准确遵循指令，还能适应新任务并持续改进。通过将人类反馈整合到训练循环中，RLHF 显著增强了模型生成可靠、符合人类输出的能力，为 AI 对齐和性能设定了新标准。\n\n### **ChatGPT：推进对话式 AI (2022)**\n\n![1749366311853KsazbV5PJoA6qqxaf11cKTLSnDc.png](https://gitee.com/tanke11223344/imagehost/raw/main/blog/1749366311853KsazbV5PJoA6qqxaf11cKTLSnDc.png)\n\n2022 年 3 月，OpenAI 推出了 GPT-3.5，这是 GPT-3 的升级版，架构相同但训练和微调有所改进。关键增强包括通过改进数据更好地遵循指令，减少了幻觉（尽管未完全消除），以及更多样化、更新的数据集，以生成更相关、上下文感知的响应。\n\n- 对话聚焦的微调：在大量对话数据集上进行训练，ChatGPT 擅长维持对话的上下文和连贯性，实现更引人入胜和类似人类的互动。\n- RLHF：通过整合 RLHF，ChatGPT 学会了生成不仅有用而且诚实和无害的响应。人类培训师根据质量对响应进行排名，使模型能够逐步改进其表现。\n\nChatGPT 的推出标志着 AI 的一个关键时刻，通常被称为「ChatGPT 时刻」(ChatGPT moment)，因为它展示了对话式 AI 改变人机交互的潜力。\n\n## **多模态模型：连接文本、图像及其他 (2023–2024)**\n\n在 2023 年至 2024 年间，像 GPT-4V 和 GPT-4o 这样的多模态大型语言模型（MLLMs）通过将文本、图像、音频和视频整合到统一系统中重新定义了 AI。这些模型扩展了传统语言模型的能力，实现了更丰富的交互和更复杂的问题解决。\n\n### **GPT-4V：视觉遇见语言**\n\n2023 年，OpenAI 推出了 GPT-4V，将 GPT-4 的语言能力与先进的计算机视觉相结合。它可以解释图像、生成标题、回答视觉问题，并推断视觉中的上下文关系。其跨模态注意力机制允许文本和图像数据的无缝集成，使其在医疗保健（如分析医学图像）和教育（如互动学习工具）等领域具有价值。\n\n![1749366321852Qf1nb3g94oVLqFx4n6xcdS7Yntt.png](https://gitee.com/tanke11223344/imagehost/raw/main/blog/1749366321852Qf1nb3g94oVLqFx4n6xcdS7Yntt.png)\n\n### **GPT-4o：全模态前沿**\n\n到 2024 年初，GPT-4o 通过整合音频和视频输入进一步推进了多模态。它在一个统一的表示空间中运行，可以转录音频、描述视频或将文本合成音频。实时交互和增强的创造力 — — 如生成多媒体内容 — — 使其成为娱乐和设计等行业的多功能工具。\n\n现实世界的影响: MLLMs 革新了医疗保健（诊断）、教育（互动学习）和创意产业（多媒体制作）等领域。它们处理多种模态的能力解锁了创新的新可能性。\n\n## **推理模型：从「系统 1」到「系统 2」思维的转变 (2024)**\n\n2024 年，AI 开发开始强调增强「推理」(Reasoning)，从简单的模式识别转向更逻辑化和结构化的思维过程。这一转变受到认知心理学双重过程理论的影响，区分了「系统 1」（快速、直觉）和「系统 2」（缓慢、分析）思维。虽然像 GPT-3 和 GPT-4 这样的早期模型在生成文本等「系统 1」任务上表现出色，但在深度推理和问题解决方面却有所欠缺。\n\n![1749366332852KqgYbfsQdoAjgcxwSSTcTGHsnsd.png](https://gitee.com/tanke11223344/imagehost/raw/main/blog/1749366332852KqgYbfsQdoAjgcxwSSTcTGHsnsd.png)\n\n### **OpenAI-o1：推理能力的一大飞跃(2024)**\n\n2024 年 9 月 12 日，OpenAI 发布的 o1-preview 标志着人工智能能力的重大飞跃，尤其是在解决复杂推理任务（如数学和编程）方面。与传统 LLMs 不同，推理模型采用了「长链思维」（Long CoT） — — 即内部的推理轨迹，使模型能够通过分解问题、批判自己的解决方案并探索替代方案来“思考”问题。这些 CoTs 对用户是隐藏的，用户看到的是一个总结性的输出。\n\n**推理模型的关键特性包括：**\n\n- 长链思维（Long CoT） ：使模型能够将复杂问题分解为更小的部分，批判性地评估其解决方案，并探索多种方法，类似于搜索算法。\n- 推理时计算控制 ：对于更复杂的问题，可以生成更长的 CoTs；而对于较简单的问题，则使用较短的 CoTs 以节省计算资源。\n- 增强的推理能力 ：尽管像 o1-preview 这样的初始推理模型在某些领域的能力不如标准 LLMs，但在推理任务中，它们的表现远远超越了后者，常常能与人类专家媲美。例如，o1-preview 在数学（AIME 2024）、编程（CodeForces）和博士级别的科学问题上均超越了 GPT-4o。\n\n![1749366342083VcEfbjllyoLSeCxGQvLcJEPBnSe.png](https://gitee.com/tanke11223344/imagehost/raw/main/blog/1749366342083VcEfbjllyoLSeCxGQvLcJEPBnSe.png)\n\n**OpenAI-o1：**\n\n2024 年 12 月 5 日，OpenAI 的完整版 o1 模型进一步提升了性能，在美国 AIME 2024 数学考试中排名前 500 名学生之列，并显著超越了 GPT-4o（解决了 74%-93% 的 AIME 问题，而 GPT-4o 仅为 12%）。此外，o1-mini 作为更便宜且更快的版本，在编码任务中表现出色，尽管其成本仅为完整版 o1 的 20%。\n\n**OpenAI-o3：**\n\n2025 年 1 月 31 日，OpenAI 发布了 o3，这是其推理模型系列的最新突破，建立在 o1 模型成功的基础之上。尽管完整的 o3 模型尚未发布，但其在关键基准测试中的表现被描述为具有开创性。\n\n- ARC-AGI ：达到 87.5% 的准确率，超过了人类水平的 85%，远超 GPT-4o 的 5%。\n- 编程 ：在 SWE-Bench Verified 上得分 71.7%，并在 Codeforces 上获得 2727 的 Elo 评分，跻身全球前 200 名竞争性程序员之列。\n- 数学 ：在 EpochAI 的 FrontierMath 基准测试中达到 25.2% 的准确率，相比之前的最先进水平（2.0%）有了显著提升。\n\n![1749366352852CSmybKboboZFwUxlGddcKw08n4d.png](https://gitee.com/tanke11223344/imagehost/raw/main/blog/1749366352852CSmybKboboZFwUxlGddcKw08n4d.png)\n\nOpenAI-o1 和 OpenAI-o3 推理模型的发布代表了人工智能领域的重大进步，通过结构化的内部推理过程提供了卓越的问题解决能力，并在复杂数学和编程任务中树立了新的标杆。\n\n## **成本高效的推理模型：DeepSeek-R1 (2025)**\n\nLLMs 通常需要极其庞大的计算资源来进行训练和推理。像 GPT-4o 和 OpenAI-o1 这样的最先进 LLM 模型的闭源性质限制了对尖端 AI 的「普及化」。\n\n#### DeepSeek-V3 (2024–12)\n\n2024 年 12 月下旬，「深度求索-V3」(DeepSeek-V3)作为一种成本高效的开放权重 LLM 出现，为 AI 的可访问性设定了新标准。DeepSeek-V3 与 OpenAI 的 ChatGPT 等顶级解决方案相媲美，但开发成本显著降低，估计约为 560 万美元，仅为西方公司投资的一小部分。\n\n该模型最多包含 6710 亿个参数，其中 370 亿个活跃参数，并采用专家混合（MoE）架构，将模型划分为专门处理数学和编码等任务的组件，以减轻训练负担。DeepSeek-V3 采用了工程效率，例如改进 Key-Value 缓存管理和进一步推动专家混合方法。该模型引入了三个关键架构：\n\n- 多头潜在注意力（Multi-head Latent Attention — MLA）：通过压缩注意力键和值来减少内存使用，同时保持性能，并通过旋转位置嵌入（RoPE）增强位置信息。\n- DeepSeek 专家混合（DeepSeekMoE）：在前馈网络（FFNs）中采用共享和路由专家的混合，以提高效率并平衡专家利用率。\n- 多标记预测 (Multi-Token Prediction — MTP)：增强模型生成连贯且上下文相关的输出的能力，特别是对于需要复杂序列生成的任务。\n\n![1749366364852VqXxb4bC3o4zcdxZ2IfcCiBTn8f.png](https://gitee.com/tanke11223344/imagehost/raw/main/blog/1749366364852VqXxb4bC3o4zcdxZ2IfcCiBTn8f.png)\n\nDeepSeek-V3 的发布引发了全球科技抛售，危及 1 万亿美元的市值，并导致英伟达股票盘前下跌 13%。DeepSeek-V3 的价格为每百万输出标记 2.19 美元，约为 OpenAI 类似模型成本的 1/30。\n\n#### DeepSeek-R1-Zero 和 DeepSeek-R1 (2025–01)\n\n仅仅一个月后，2025 年 1 月下旬，DeepSeek 通过发布 DeepSeek-R1-Zero 和 DeepSeek-R1 再次引起轰动，这些模型展示了卓越的推理能力，训练成本极低。\n\n利用先进的强化学习技术，这些模型证明了高性能推理可以在没有通常与尖端 AI 相关的巨额计算费用的情况下实现。这一突破巩固了 DeepSeek 作为高效和可扩展 AI 创新领导者的地位。\n\n- DeepSeek-R1-Zero：一种基于 DeepSeek-V3 的推理模型，通过强化学习（RL）增强其推理能力。它完全消除了「监督微调」(SFT)阶段，直接从名为 DeepSeek-V3-Base 的预训练模型开始。\n- 它采用了一种基于「规则的强化学习方法」(Rule-based Reinforcement Learning)，称为「组相对策略优化」（Group Relative Policy Optimization — GRPO），根据预定义规则计算奖励，使训练过程更简单且更具可扩展性。\n\n![1749366374853P4GgbfXdCosRNaxVs9UcgPZJnrh.png](https://gitee.com/tanke11223344/imagehost/raw/main/blog/1749366374853P4GgbfXdCosRNaxVs9UcgPZJnrh.png)\n\nDeepSeek-R1：为了解决 DeepSeek-R1-Zero 的局限性，如低可读性和语言混杂，DeepSeek-R1 纳入了一组有限的高质量冷启动数据和额外的 RL 训练。该模型经历了多个微调和 RL 阶段，包括拒绝采样和第二轮 RL 训练，以提高其通用能力和与人类偏好的一致性。\n\n![1749366389092T1wubPqY6oxXXFxd0qzcJ2glncg.png](https://gitee.com/tanke11223344/imagehost/raw/main/blog/1749366389092T1wubPqY6oxXXFxd0qzcJ2glncg.png)\n\n蒸馏 DeepSeek 模型：DeepSeek 开发了较小的、蒸馏版的 DeepSeek-R1，参数范围从 15 亿到 700 亿，将先进的推理能力带到较弱的硬件上。这些模型使用原始 DeepSeek-R1 生成的合成数据进行微调，确保在推理任务中表现出色，同时足够轻量化以便本地部署。\n\n![1749366397854N4nzbC2KTorOW5xuYnzcufyenNe.png](https://gitee.com/tanke11223344/imagehost/raw/main/blog/1749366397854N4nzbC2KTorOW5xuYnzcufyenNe.png)\n\nDeepSeek-R1 在各种基准测试中表现出竞争力，包括数学、编码、常识和写作。根据使用模式，它相比 OpenAI 的 o1 模型等竞争对手提供了显著的成本节省，使用成本便宜 20 到 50 倍。\n\n![1749366406080JB7LbnJZUoOrhzxuPW6cI1Z9nEb.png](https://gitee.com/tanke11223344/imagehost/raw/main/blog/1749366406080JB7LbnJZUoOrhzxuPW6cI1Z9nEb.png)\n\n# **结论**\n\n![1749366416855UwLGbPxkwoY8EExcZAXcdmNtncC.png](https://gitee.com/tanke11223344/imagehost/raw/main/blog/1749366416855UwLGbPxkwoY8EExcZAXcdmNtncC.png)\n\n从 2017 年 Transformer 架构的引入到 2025 年 DeepSeek-R1 的发展，大型语言模型（LLMs）的演变标志着人工智能领域的一个革命性篇章。LLMs 的崛起由四个里程碑式的成就标示：\n\n- Transformers (2017)：Transformer 架构的引入为构建能够以前所未有的精确性和灵活性处理复杂任务的大规模高效模型奠定了基础。\n- GPT-3 (2020)：该模型展示了规模在 AI 中的变革力量，证明了在大规模数据集上训练的巨大模型可以在广泛的应用中实现接近人类的表现，为 AI 所能完成的任务设立了新的基准。\n- ChatGPT (2022)：通过将对话式 AI 带入主流，ChatGPT 使高级 AI 对普通用户来说更加可访问和互动。它还引发了关于广泛采用 AI 的伦理和社会影响的关键讨论。\n- DeepSeek-R1 (2025)：代表了成本效率的一大飞跃，DeepSeek-R1 利用专家混合架构(MoE)和优化算法，与许多美国模型相比，运营成本降低了多达 50 倍。其开源性质加速尖端 AI 应用的普及化，赋予各行业创新者权力，并强调了可扩展性、对齐性和可访问性在塑造 AI 未来中的重要性。\n\nLLMs 正逐步演变为多功能、多模态的推理系统，能够同时满足普通用户和特定需求。这一演变得益于突破性技术创新，以及在规模、易用性和成本效益上的显著提升，推动人工智能朝着更加包容和影响力深远的方向迈进。\n","source":"_posts/2025-06-08-大模型底层技术分析.md","raw":"---\ntitle:  2025-06-08-大模型底层技术分析\ndate: 2025-06-08\ntags: \n    课程学习\n---\n# 大模型底层技术分析\n\n# 参考资料\n\n> - [Understanding LLM Decoding Strategies](https://medium.com/@lmpo/mastering-llms-a-guide-to-decoding-algorithms-c90a48fd167b)\n> - [最新「大模型简史」整理！从 Transformer（2017）到 DeepSeek-R1（2025）](https://segmentfault.com/a/1190000046177208)\n> - [大语言模型简史](https://medium.com/@lmpo/%E5%A4%A7%E5%9E%8B%E8%AF%AD%E8%A8%80%E6%A8%A1%E5%9E%8B%E7%AE%80%E5%8F%B2-%E4%BB%8Etransformer-2017-%E5%88%B0deepseek-r1-2025-cc54d658fb43)\n\n# 2025年大语言模型综述论文推荐\n\n> * [Awesome Agent Papers GitHub Repository](https://github.com/luo-junyu/Awesome-Agent-Papers)\n\n以下是三篇 2025 年关于大语言模型的综述论文：\n\n1. ## [A Survey on Large Language Models with some Insights on their Capabilities and Limitations](https://arxiv.org/abs/2501.04040)\n\n* **链接** : [arXiv:2501.04040](https://arxiv.org/abs/2501.04040)\n* **内容概述** :\n  该论文深入探讨 LLMs 的能力，包括文本生成、问答、翻译、摘要、常识推理、代码生成和数学计算，强调其接近人类水平的理解能力。研究分析了基于 Transformer 架构的模型（如 GPT、LLaMA），探讨了数据和计算规模的指数增长对性能的影响。论文还讨论了扩展机制（如参数量增加、上下文长度扩展）和架构策略（如多头注意力、层归一化）。此外，分析了 LLMs 的局限性，如高计算成本、事实错误（hallucination）和伦理问题。应用领域包括医疗（诊断辅助）、金融（风险评估）、教育（智能辅导）和法律（合同分析）。论文还探讨了链式推理（Chain-of-Thought, CoT）和路径推理（Path-of-Thought, PoT）能力，以及 LLM-modulo 框架的泛化性。\n* **贡献** :\n* 提供 LLMs 的全面能力与局限性分析，适合理解技术边界。\n* 覆盖多领域应用，适合跨行业参考。\n* 174 页的详尽内容，计划提交期刊的精简版，信息量丰富。\n\n2. ## [Large Language Models: A Survey](https://arxiv.org/abs/2402.06196)\n\n* **链接** : [arXiv:2402.06196](https://arxiv.org/abs/2402.06196)\n* **内容概述** :\n  该论文是 2024 年初版的更新版本，综述了主流 LLMs（如 GPT、LLaMA、PaLM）的特性、贡献和局限性。研究讨论了构建和增强 LLMs 的技术，包括预训练、微调、分布式训练和高效推理。论文调研了用于训练、微调和评估的热门数据集（如 Common Crawl、The Pile），并回顾了广泛使用的评估指标（如 BLEU、ROUGE、Perplexity）。通过代表性基准测试（如 MMLU、GLUE）比较了多个 LLMs 的性能，分析了其在不同任务上的表现。论文还探讨了开放挑战，如计算效率、数据偏见和模型可解释性，以及未来研究方向（如多模态 LLMs、能源优化）。\n* **贡献** :\n* 提供 LLMs 的技术全景，涵盖架构、数据集和评估。\n* 更新至 2025 年，包含最新模型和优化技术。\n* 强调未来方向，适合预测技术趋势。\n\n3. ## [Large Language Model Agent: A Survey on Methodology, Applications and Challenges](https://arxiv.org/abs/2503.21460)\n\n* **链接** : [arXiv:2503.21460](https://arxiv.org/abs/2503.21460)\n* **内容概述** :\n  该论文聚焦 LLM 智能体，分析其方法论、应用和挑战，涵盖 329 篇相关研究。论文提出了以方法论为中心的分类法，连接架构基础、协作机制和演化路径，统一了智能体设计的研究碎片。讨论了智能体的目标驱动行为和动态适应能力，探索其在复杂环境中的表现。应用场景包括自动化任务分解、协作工作流和多智能体系统。挑战包括计算资源需求、协作效率和评估方法的标准化。论文提供资源库（[GitHub](https://github.com/luo-junyu/Awesome-Agent-Papers)），便于进一步研究。\n* **贡献** :\n* 提供 LLM 智能体的系统性分类，适合深入研究智能体应用。\n* 覆盖广泛应用场景，强调协作机制。\n* 提供开源资源，方便开发者实践。\n\n# 概述\n\n## 什么是语言模型 (Language Models)？\n\n![1749366089085BNAubDynsogt1bxoYrPcAnBlnvh.png](https://gitee.com/tanke11223344/imagehost/raw/main/blog/1749366089085BNAubDynsogt1bxoYrPcAnBlnvh.png)\n\n「语言模型」是一种「人工智能系统」，旨在处理、理解和生成类似人类的语言。它们从大型数据集中学习模式和结构，使得能够产生连贯且上下文相关的文本，应用于翻译、摘要、聊天机器人和内容生成等领域。\n\n### 大型语言模型（LLMs）\n\n「语言模型」（LMs）和「大型语言模型」（LLMs）这两个术语虽然经常被互换使用，但实际上它们基于规模、架构、训练数据和能力指代不同的概念。LLMs 是 LMs 的一个子集，其规模显著更大，通常包含数十亿个参数（例如，GPT-3 拥有 1750 亿个参数）。这种更大的规模使 LLMs 能够在广泛的任务中表现出卓越的性能。“LLM”这一术语在 2018 至 2019 年间随着基于 Transformer 架构的模型（如 BERT 和 GPT-1）的出现开始受到关注。然而，在 2020 年 GPT-3 发布后，这个词才被广泛使用，展示了这些大规模模型的重大影响力和强大能力。\n\n### [自回归语言模型](https://zhida.zhihu.com/search?content_id=255912486&content_type=Article&match_order=1&q=%E8%87%AA%E5%9B%9E%E5%BD%92%E8%AF%AD%E8%A8%80%E6%A8%A1%E5%9E%8B&zhida_source=entity) （Autoregressive Language Models）\n\n大多数 LLMs 以「自回归方式」(Autoregressive)操作，这意味着它们根据前面的「文本」预测下一个「字」（或 token／sub-word）的「概率分布」(propability distribution)。这种自回归特性使模型能够学习复杂的语言模式和依赖关系，从而善于「文本生成」。\n\n$$\n(\\begin{array}{cc}w_1,w_2&,\\ldots,w_{n-1}\\end{array})\\left(w_{n}\\right)P(w_{n}|w_1,w_2,\\ldots,w_{n-1},\\ldots,w_{n-1})\n$$\n\n在文本生成任时，LLM 通过解码算法(Decoding Algorithm)来确定下一个输出的字。\n\n这一过程可以采用不同的策略：既可以选择概率最高的下个字（即贪婪搜索），也可以从预测的概率分布中随机采样一个字。后一种方法使得每次生成的文本都可能有所不同，这种特性与人类语言的多样性和随机性颇为相似。\n\n![1749366102088NG49bUAoXomHelxiq2ZckdIlnpb.png](https://gitee.com/tanke11223344/imagehost/raw/main/blog/1749366102088NG49bUAoXomHelxiq2ZckdIlnpb.png)\n![1749366116880KWu3bn2W2oethdxLzqAcm6xBnWC.png](https://gitee.com/tanke11223344/imagehost/raw/main/blog/1749366116880KWu3bn2W2oethdxLzqAcm6xBnWC.png)\n\n### 生成能力\n\nLLMs 的自回归特性使其能够基于前文提供的上下文逐词生成文本。从「提示」(prompt)开始，如下图，模型通过迭代预测下一个词，直到生成完整的序列或达到预定的停止条件。为了生成对提示的完整回答，LLM 通过将先前选择的标记添加到输入中进行迭代生成，尤如「文字接龙」游戏。\n\n![1749366127852Do7ybXLnFoU5QmxRFcrcML6Lnpf.png](https://gitee.com/tanke11223344/imagehost/raw/main/blog/1749366127852Do7ybXLnFoU5QmxRFcrcML6Lnpf.png)\n\n## Transformer 革命 (2017)\n\n> - [Attention Is All You Need](https://arxiv.org/abs/1706.03762)\n\nVaswani 等人在 2017 年通过其开创性论文“Attention is All You Need”引入了 Transformer 架构，标志着 NLP 的一个分水岭时刻。它解决了早期模型如循环神经网络（RNNs）和长短期记忆网络（LSTMs）的关键限制，这些模型在长程依赖性和顺序处理方面存在困难。这些问题使得使用 RNN 或 LSTM 实现有效的语言模型变得困难，因为它们计算效率低下且容易出现梯度消失等问题。另一方面，Transformers 克服了这些障碍，彻底改变了这一领域，并为现代大型语言模型奠定了基础。\n\n![1749366139852ZnJWbnoMCojKUExcNMZcJaV4nod.png](https://gitee.com/tanke11223344/imagehost/raw/main/blog/1749366139852ZnJWbnoMCojKUExcNMZcJaV4nod.png)\n\n### Transformer 架构的关键创新\n\n自注意力机制 (Self-Attention)：与按顺序处理标记并难以应对长程依赖性的 RNN 不同，Transformers 使用自注意力来权衡每个标记相对于其他标记的重要性。这使得模型能够动态关注输入的相关部分。数学上：\n\n$$\n\\mathrm{Attention}(\\mathbf{Q},\\mathbf{K},\\mathbf{V})=\\mathrm{Softmax}\\left(\\frac{\\mathbf{QK^T}}{\\sqrt{d_k}}\\right)\\mathrm{V}\n$$\n\n这里，Q、K、V 是查询(query)、键(key)和值(value)矩阵，dₖ 是键的维度。自注意力允许并行计算，加快训练速度，同时提高全局上下文理解。\n\n![1749366152088YWvebIv6soDVh2xSALYc4m2vnoc.png](https://gitee.com/tanke11223344/imagehost/raw/main/blog/1749366152088YWvebIv6soDVh2xSALYc4m2vnoc.png)\n\n多头注意力：多个注意力头并行操作，每个头专注于输入的不同方面。它们的输出被连接并转换，从而实现更丰富的上下文表示。\n\n![1749366160852M4bYbd1axoJPw5xY8TzcBDn4n4b.png](https://gitee.com/tanke11223344/imagehost/raw/main/blog/1749366160852M4bYbd1axoJPw5xY8TzcBDn4n4b.png)\n\n前馈网络(FFN)和层归一化(Layer Norm)：每个 Transformer 层包括应用于每个标记的前馈网络，以及层归一化和残差连接。这些稳定了训练并支持更深的架构。\n\n位置编码：由于 Transformers 本身不编码标记顺序，因此添加了位置编码（位置和频率的正弦函数）以表示词序，在不牺牲并行化的情况下保留顺序信息。\n\n![1749366172089We3mbXuFDomJfSxxrwFchohkn3d.png](https://gitee.com/tanke11223344/imagehost/raw/main/blog/1749366172089We3mbXuFDomJfSxxrwFchohkn3d.png)\n\n#### 对语言建模的影响\n\n- 可扩展性：Transformers 实现了完全并行化的计算，使得在大型数据集上训练大规模模型成为可能。\n- 上下文理解：自注意力捕捉局部和全局依赖关系，提高了连贯性和上下文意识。\n\nTransformer 架构的引入为构建能够以前所未有的精确性和灵活性处理复杂任务的大规模高效语言模型奠定了基础。\n\n## **预训练 Transformer 模型时代 (2018–2020)**\n\n2017 年 Transformer 架构的引入为 NLP 的新时代铺平了道路，其特点是预训练模型的兴起和对扩展的前所未有的关注。这一时期见证了两个有影响力的模型家族的出现：BERT 和 GPT，它们展示了大规模预训练和微调范式的强大功能。\n\n### **BERT：双向上下文理解 (2018)**\n\n2018 年，谷歌推出了 BERT（Bidirectional Encoder Representations from Transformers），这是一种使用 Transformer 编码器(Encoder)的突破性模型，在广泛的 NLP 任务中取得了最先进的性能。\n\n与之前单向处理文本（从左到右或从右到左）的模型不同，BERT 采用了双向训练方法，使其能够同时从两个方向捕获上下文。通过生成深层次的、上下文丰富的文本表示，BERT 在文本分类、命名实体识别（NER）、情感分析等语言理解任务中表现出色。\n\n![1749366186892IyVobGCISoulBexHp23ckNjrnpd.png](https://gitee.com/tanke11223344/imagehost/raw/main/blog/1749366186892IyVobGCISoulBexHp23ckNjrnpd.png)\n\nBERT 的关键创新包括：\n\n- 掩码语言建模（Masker Language Modeling — MLM）：BERT 不是预测序列中的下一个词，而是被训练预测句子中随机掩码的标记。这迫使模型在进行预测时考虑整个句子的上下文 — — 包括前后词语。例如，给定句子“The cat sat on the [MASK] mat”，BERT 会学习根据周围上下文预测“soft”。\n- 下一句预测（Next Sentence Prediction — NSP）：除了 MLM 之外，BERT 还接受了称为下一句预测的次要任务训练，其中模型学习预测两个句子是否在文档中连续。这帮助 BERT 在需要理解句子之间关系的任务中表现出色，例如问答和自然语言推理。\n\nBERT 的影响：BERT 的双向训练使其在 GLUE（通用语言理解评估）和 SQuAD（斯坦福问答数据集）等基准测试中取得了突破性的表现。它的成功证明了上下文嵌入的重要性 — — 这些表示根据周围词语动态变化 — — 并为新一代预训练模型铺平了道路。\n\n### **GPT：生成式预训练和自回归文本生成（2018–2020）**\n\n虽然 BERT 优先考虑双向上下文理解，但 OpenAI 的 GPT 系列采用了不同的策略，专注于通过自回归预训练实现生成能力。通过利用 Transformer 的解码器(Decoder)，GPT 模型在自回归语言模型和文本生成方面表现出色。\n\n![1749366197851NG9rbQKhOoiyU8xFnjzcE6dnnVb.png](https://gitee.com/tanke11223344/imagehost/raw/main/blog/1749366197851NG9rbQKhOoiyU8xFnjzcE6dnnVb.png)\n\nGPT (2018)GPT 的第一个版本于 2018 年发布，是一个大规模的 Transformer 模型，经过训练以预测序列中的下一个词，类似于传统语言模型。\n\n- 单向自回归训练：GPT 使用因果语言建模目标进行训练，其中模型仅基于前面的标记预测下一个标记。这使得它特别适合于生成任务，如文本补全、摘要生成和对话生成。\n- 下游任务的微调：GPT 的一个关键贡献是它能够在不需要特定任务架构的情况下针对特定下游任务进行微调。只需添加一个分类头或修改输入格式，GPT 就可以适应诸如情感分析、机器翻译和问答等任务。\n\nGPT-2 (2019)在原版 GPT 的成功基础上，OpenAI 发布了 GPT-2，这是一个参数量达 15 亿的更大模型。GPT-2 展示了令人印象深刻的零样本(Zero-shot)能力，意味着它可以在没有任何特定任务微调的情况下执行任务。例如，它可以生成连贯的文章、回答问题，甚至在语言之间翻译文本，尽管没有明确针对这些任务进行训练。\n\n![1749366209087ZZYMb63vmoBszCxVyMFcGqQXnnf.png](https://gitee.com/tanke11223344/imagehost/raw/main/blog/1749366209087ZZYMb63vmoBszCxVyMFcGqQXnnf.png)\n\nGPT-3 (2020)GPT-3 的发布标志着语言模型规模扩展的一个转折点。凭借惊人的 1750 亿参数(175B parameters)，GPT-3 突破了大规模预训练的可能性界限。它展示了显著的少样本(Few-short)和零样本(Zero-short)学习能力，在推理时只需提供最少或无需示例即可执行任务。GPT-3 的生成能力扩展到了创意写作、编程和复杂推理任务，展示了超大模型的潜力。\n\n![1749366215856SDbBbzF1Go4u1TxVTbjczhGtnze.png](https://gitee.com/tanke11223344/imagehost/raw/main/blog/1749366215856SDbBbzF1Go4u1TxVTbjczhGtnze.png)\n\n![1749366222852FIYObGa7BoUFd8xnGLPcBRdqnPb.png](https://gitee.com/tanke11223344/imagehost/raw/main/blog/1749366222852FIYObGa7BoUFd8xnGLPcBRdqnPb.png)\n\n#### GPT 的影响及规模的作用\n\nGPT 模型的引入，特别是 GPT-3，标志着 AI 的一个变革时代，展示了自回归架构和生成能力的强大功能。这些模型为内容创作、对话代理和自动推理等应用开辟了新的可能性，在广泛的任务中达到了接近人类的表现。GPT-3 凭借其 1750 亿参数证明了规模的深远影响，表明在大规模数据集上训练的更大模型可以树立新的 AI 能力标杆。\n\n![1749366235853QJZ3b7F2Coy8CUxlx7pcDmmhnOb.png](https://gitee.com/tanke11223344/imagehost/raw/main/blog/1749366235853QJZ3b7F2Coy8CUxlx7pcDmmhnOb.png)\n\n> 语言建模性能随着模型大小、数据集大小和训练使用的计算量的增加而平稳提升。\n> [Scaling Laws for Neural Language Models](https://arxiv.org/abs/2001.08361)\n\n在 2018 年至 2020 年间，该领域由对规模的不懈追求驱动。研究人员发现，随着模型规模的增长 — — 从数百万到数十亿参数 — — 它们在捕捉复杂模式和泛化到新任务方面变得更好。这种规模效应得到了三个关键因素的支持：\n\n- 数据集大小：更大的模型需要庞大的数据集进行预训练。例如，GPT-3 是在大量互联网文本语料库上进行训练的，使其能够学习多样化的语言模式和知识领域。\n- 计算资源：强大的硬件（如 GPU 和 TPU）的可用性以及分布式训练技术，使得高效训练具有数十亿参数的模型成为可能。\n- 高效架构：混合精度训练和梯度检查点等创新降低了计算成本，使得在合理的时间和预算内进行大规模训练更加实际。\n\n这个规模扩展的时代不仅提升了语言模型的性能，还为未来的 AI 突破奠定了基础，强调了规模、数据和计算在实现最先进结果中的重要性。\n\n## **后训练对齐：弥合 AI 与人类价值观之间的差距 (2021–2022)**\n\nGPT-3（一个拥有 1750 亿参数的 LLM）生成几乎无法与人类写作区分的文本的能力引发了关于 AI 生成内容的真实性和可信度的重大担忧。\n\n尽管这一成就标志着 AI 发展的一个重要里程碑，但也突显了确保这些模型与人类价值观、偏好和期望保持一致的关键挑战。一个主要问题是「幻觉」（Hallucination），即 LLM 生成与事实不符、无意义或与输入提示矛盾的内容，给人一种「一本正经地胡说八道」的印象。\n\n为了解决这些挑战，2021 年和 2022 年的研究人员专注于改善与人类意图的一致性并减少幻觉，导致了监督微调（SFT）和基于人类反馈的强化学习（RLHF）等技术的发展。\n\n### **监督微调 (SFT)**\n\n增强 GPT-3 对齐能力的第一步是监督微调（SFT），这是 RLHF 框架的基础组成部分。SFT 类似于指令调优，涉及在高质量的输入-输出对或演示上训练模型，以教它如何遵循指令并生成所需的输出。\n\n![1749366280852MfpwbkcnioN5lXxMOPgc4gyhnld.png](https://gitee.com/tanke11223344/imagehost/raw/main/blog/1749366280852MfpwbkcnioN5lXxMOPgc4gyhnld.png)\n\n这些演示经过精心策划，以反映预期的行为和结果，确保模型学会生成准确且符合上下文的响应。\n\n![1749366299852Y3fRbjJ0OoOLhVxvXBwcQkp7nti.png](https://gitee.com/tanke11223344/imagehost/raw/main/blog/1749366299852Y3fRbjJ0OoOLhVxvXBwcQkp7nti.png)\n\n然而，SFT 本身有局限性：\n\n1. 可扩展性：收集人类演示是劳动密集型且耗时的，尤其是对于复杂或小众任务。\n2. 性能：简单模仿人类行为并不能保证模型会超越人类表现或在未见过的任务上很好地泛化。\n\n为了克服这些挑战，需要一种更具可扩展性和效率的方法，为下一步铺平了道路：基于人类反馈的强化学习（Reinforcement Learning from Human Feedback — RLHF）。\n\n### **基于人类反馈的强化学习 (RLHF)**\n\nOpenAI 在 2022 年引入的 RLHF 解决了 SFT 的可扩展性和性能限制。与需要人类编写完整输出的 SFT 不同，RLHF 涉及根据质量对多个模型生成的输出进行排名。这种方法允许更高效的数据收集和标注，显著增强了可扩展性。\n\nRLHF 过程包括两个关键阶段：\n\n1. 训练奖励模型：人类注释者对模型生成的多个输出进行排名，创建一个偏好数据集。这些数据用于训练一个奖励模型，该模型学习根据人类反馈评估输出的质量。\n2. 使用强化学习微调 LLM：奖励模型使用近端策略优化（Proximal Policy Optimization - PPO）（一种强化学习算法）指导 LLM 的微调。通过迭代更新，模型学会了生成更符合人类偏好和期望的输出。\n\n这个两阶段过程 — — 结合 SFT 和 RLHF — — 使模型不仅能够准确遵循指令，还能适应新任务并持续改进。通过将人类反馈整合到训练循环中，RLHF 显著增强了模型生成可靠、符合人类输出的能力，为 AI 对齐和性能设定了新标准。\n\n### **ChatGPT：推进对话式 AI (2022)**\n\n![1749366311853KsazbV5PJoA6qqxaf11cKTLSnDc.png](https://gitee.com/tanke11223344/imagehost/raw/main/blog/1749366311853KsazbV5PJoA6qqxaf11cKTLSnDc.png)\n\n2022 年 3 月，OpenAI 推出了 GPT-3.5，这是 GPT-3 的升级版，架构相同但训练和微调有所改进。关键增强包括通过改进数据更好地遵循指令，减少了幻觉（尽管未完全消除），以及更多样化、更新的数据集，以生成更相关、上下文感知的响应。\n\n- 对话聚焦的微调：在大量对话数据集上进行训练，ChatGPT 擅长维持对话的上下文和连贯性，实现更引人入胜和类似人类的互动。\n- RLHF：通过整合 RLHF，ChatGPT 学会了生成不仅有用而且诚实和无害的响应。人类培训师根据质量对响应进行排名，使模型能够逐步改进其表现。\n\nChatGPT 的推出标志着 AI 的一个关键时刻，通常被称为「ChatGPT 时刻」(ChatGPT moment)，因为它展示了对话式 AI 改变人机交互的潜力。\n\n## **多模态模型：连接文本、图像及其他 (2023–2024)**\n\n在 2023 年至 2024 年间，像 GPT-4V 和 GPT-4o 这样的多模态大型语言模型（MLLMs）通过将文本、图像、音频和视频整合到统一系统中重新定义了 AI。这些模型扩展了传统语言模型的能力，实现了更丰富的交互和更复杂的问题解决。\n\n### **GPT-4V：视觉遇见语言**\n\n2023 年，OpenAI 推出了 GPT-4V，将 GPT-4 的语言能力与先进的计算机视觉相结合。它可以解释图像、生成标题、回答视觉问题，并推断视觉中的上下文关系。其跨模态注意力机制允许文本和图像数据的无缝集成，使其在医疗保健（如分析医学图像）和教育（如互动学习工具）等领域具有价值。\n\n![1749366321852Qf1nb3g94oVLqFx4n6xcdS7Yntt.png](https://gitee.com/tanke11223344/imagehost/raw/main/blog/1749366321852Qf1nb3g94oVLqFx4n6xcdS7Yntt.png)\n\n### **GPT-4o：全模态前沿**\n\n到 2024 年初，GPT-4o 通过整合音频和视频输入进一步推进了多模态。它在一个统一的表示空间中运行，可以转录音频、描述视频或将文本合成音频。实时交互和增强的创造力 — — 如生成多媒体内容 — — 使其成为娱乐和设计等行业的多功能工具。\n\n现实世界的影响: MLLMs 革新了医疗保健（诊断）、教育（互动学习）和创意产业（多媒体制作）等领域。它们处理多种模态的能力解锁了创新的新可能性。\n\n## **推理模型：从「系统 1」到「系统 2」思维的转变 (2024)**\n\n2024 年，AI 开发开始强调增强「推理」(Reasoning)，从简单的模式识别转向更逻辑化和结构化的思维过程。这一转变受到认知心理学双重过程理论的影响，区分了「系统 1」（快速、直觉）和「系统 2」（缓慢、分析）思维。虽然像 GPT-3 和 GPT-4 这样的早期模型在生成文本等「系统 1」任务上表现出色，但在深度推理和问题解决方面却有所欠缺。\n\n![1749366332852KqgYbfsQdoAjgcxwSSTcTGHsnsd.png](https://gitee.com/tanke11223344/imagehost/raw/main/blog/1749366332852KqgYbfsQdoAjgcxwSSTcTGHsnsd.png)\n\n### **OpenAI-o1：推理能力的一大飞跃(2024)**\n\n2024 年 9 月 12 日，OpenAI 发布的 o1-preview 标志着人工智能能力的重大飞跃，尤其是在解决复杂推理任务（如数学和编程）方面。与传统 LLMs 不同，推理模型采用了「长链思维」（Long CoT） — — 即内部的推理轨迹，使模型能够通过分解问题、批判自己的解决方案并探索替代方案来“思考”问题。这些 CoTs 对用户是隐藏的，用户看到的是一个总结性的输出。\n\n**推理模型的关键特性包括：**\n\n- 长链思维（Long CoT） ：使模型能够将复杂问题分解为更小的部分，批判性地评估其解决方案，并探索多种方法，类似于搜索算法。\n- 推理时计算控制 ：对于更复杂的问题，可以生成更长的 CoTs；而对于较简单的问题，则使用较短的 CoTs 以节省计算资源。\n- 增强的推理能力 ：尽管像 o1-preview 这样的初始推理模型在某些领域的能力不如标准 LLMs，但在推理任务中，它们的表现远远超越了后者，常常能与人类专家媲美。例如，o1-preview 在数学（AIME 2024）、编程（CodeForces）和博士级别的科学问题上均超越了 GPT-4o。\n\n![1749366342083VcEfbjllyoLSeCxGQvLcJEPBnSe.png](https://gitee.com/tanke11223344/imagehost/raw/main/blog/1749366342083VcEfbjllyoLSeCxGQvLcJEPBnSe.png)\n\n**OpenAI-o1：**\n\n2024 年 12 月 5 日，OpenAI 的完整版 o1 模型进一步提升了性能，在美国 AIME 2024 数学考试中排名前 500 名学生之列，并显著超越了 GPT-4o（解决了 74%-93% 的 AIME 问题，而 GPT-4o 仅为 12%）。此外，o1-mini 作为更便宜且更快的版本，在编码任务中表现出色，尽管其成本仅为完整版 o1 的 20%。\n\n**OpenAI-o3：**\n\n2025 年 1 月 31 日，OpenAI 发布了 o3，这是其推理模型系列的最新突破，建立在 o1 模型成功的基础之上。尽管完整的 o3 模型尚未发布，但其在关键基准测试中的表现被描述为具有开创性。\n\n- ARC-AGI ：达到 87.5% 的准确率，超过了人类水平的 85%，远超 GPT-4o 的 5%。\n- 编程 ：在 SWE-Bench Verified 上得分 71.7%，并在 Codeforces 上获得 2727 的 Elo 评分，跻身全球前 200 名竞争性程序员之列。\n- 数学 ：在 EpochAI 的 FrontierMath 基准测试中达到 25.2% 的准确率，相比之前的最先进水平（2.0%）有了显著提升。\n\n![1749366352852CSmybKboboZFwUxlGddcKw08n4d.png](https://gitee.com/tanke11223344/imagehost/raw/main/blog/1749366352852CSmybKboboZFwUxlGddcKw08n4d.png)\n\nOpenAI-o1 和 OpenAI-o3 推理模型的发布代表了人工智能领域的重大进步，通过结构化的内部推理过程提供了卓越的问题解决能力，并在复杂数学和编程任务中树立了新的标杆。\n\n## **成本高效的推理模型：DeepSeek-R1 (2025)**\n\nLLMs 通常需要极其庞大的计算资源来进行训练和推理。像 GPT-4o 和 OpenAI-o1 这样的最先进 LLM 模型的闭源性质限制了对尖端 AI 的「普及化」。\n\n#### DeepSeek-V3 (2024–12)\n\n2024 年 12 月下旬，「深度求索-V3」(DeepSeek-V3)作为一种成本高效的开放权重 LLM 出现，为 AI 的可访问性设定了新标准。DeepSeek-V3 与 OpenAI 的 ChatGPT 等顶级解决方案相媲美，但开发成本显著降低，估计约为 560 万美元，仅为西方公司投资的一小部分。\n\n该模型最多包含 6710 亿个参数，其中 370 亿个活跃参数，并采用专家混合（MoE）架构，将模型划分为专门处理数学和编码等任务的组件，以减轻训练负担。DeepSeek-V3 采用了工程效率，例如改进 Key-Value 缓存管理和进一步推动专家混合方法。该模型引入了三个关键架构：\n\n- 多头潜在注意力（Multi-head Latent Attention — MLA）：通过压缩注意力键和值来减少内存使用，同时保持性能，并通过旋转位置嵌入（RoPE）增强位置信息。\n- DeepSeek 专家混合（DeepSeekMoE）：在前馈网络（FFNs）中采用共享和路由专家的混合，以提高效率并平衡专家利用率。\n- 多标记预测 (Multi-Token Prediction — MTP)：增强模型生成连贯且上下文相关的输出的能力，特别是对于需要复杂序列生成的任务。\n\n![1749366364852VqXxb4bC3o4zcdxZ2IfcCiBTn8f.png](https://gitee.com/tanke11223344/imagehost/raw/main/blog/1749366364852VqXxb4bC3o4zcdxZ2IfcCiBTn8f.png)\n\nDeepSeek-V3 的发布引发了全球科技抛售，危及 1 万亿美元的市值，并导致英伟达股票盘前下跌 13%。DeepSeek-V3 的价格为每百万输出标记 2.19 美元，约为 OpenAI 类似模型成本的 1/30。\n\n#### DeepSeek-R1-Zero 和 DeepSeek-R1 (2025–01)\n\n仅仅一个月后，2025 年 1 月下旬，DeepSeek 通过发布 DeepSeek-R1-Zero 和 DeepSeek-R1 再次引起轰动，这些模型展示了卓越的推理能力，训练成本极低。\n\n利用先进的强化学习技术，这些模型证明了高性能推理可以在没有通常与尖端 AI 相关的巨额计算费用的情况下实现。这一突破巩固了 DeepSeek 作为高效和可扩展 AI 创新领导者的地位。\n\n- DeepSeek-R1-Zero：一种基于 DeepSeek-V3 的推理模型，通过强化学习（RL）增强其推理能力。它完全消除了「监督微调」(SFT)阶段，直接从名为 DeepSeek-V3-Base 的预训练模型开始。\n- 它采用了一种基于「规则的强化学习方法」(Rule-based Reinforcement Learning)，称为「组相对策略优化」（Group Relative Policy Optimization — GRPO），根据预定义规则计算奖励，使训练过程更简单且更具可扩展性。\n\n![1749366374853P4GgbfXdCosRNaxVs9UcgPZJnrh.png](https://gitee.com/tanke11223344/imagehost/raw/main/blog/1749366374853P4GgbfXdCosRNaxVs9UcgPZJnrh.png)\n\nDeepSeek-R1：为了解决 DeepSeek-R1-Zero 的局限性，如低可读性和语言混杂，DeepSeek-R1 纳入了一组有限的高质量冷启动数据和额外的 RL 训练。该模型经历了多个微调和 RL 阶段，包括拒绝采样和第二轮 RL 训练，以提高其通用能力和与人类偏好的一致性。\n\n![1749366389092T1wubPqY6oxXXFxd0qzcJ2glncg.png](https://gitee.com/tanke11223344/imagehost/raw/main/blog/1749366389092T1wubPqY6oxXXFxd0qzcJ2glncg.png)\n\n蒸馏 DeepSeek 模型：DeepSeek 开发了较小的、蒸馏版的 DeepSeek-R1，参数范围从 15 亿到 700 亿，将先进的推理能力带到较弱的硬件上。这些模型使用原始 DeepSeek-R1 生成的合成数据进行微调，确保在推理任务中表现出色，同时足够轻量化以便本地部署。\n\n![1749366397854N4nzbC2KTorOW5xuYnzcufyenNe.png](https://gitee.com/tanke11223344/imagehost/raw/main/blog/1749366397854N4nzbC2KTorOW5xuYnzcufyenNe.png)\n\nDeepSeek-R1 在各种基准测试中表现出竞争力，包括数学、编码、常识和写作。根据使用模式，它相比 OpenAI 的 o1 模型等竞争对手提供了显著的成本节省，使用成本便宜 20 到 50 倍。\n\n![1749366406080JB7LbnJZUoOrhzxuPW6cI1Z9nEb.png](https://gitee.com/tanke11223344/imagehost/raw/main/blog/1749366406080JB7LbnJZUoOrhzxuPW6cI1Z9nEb.png)\n\n# **结论**\n\n![1749366416855UwLGbPxkwoY8EExcZAXcdmNtncC.png](https://gitee.com/tanke11223344/imagehost/raw/main/blog/1749366416855UwLGbPxkwoY8EExcZAXcdmNtncC.png)\n\n从 2017 年 Transformer 架构的引入到 2025 年 DeepSeek-R1 的发展，大型语言模型（LLMs）的演变标志着人工智能领域的一个革命性篇章。LLMs 的崛起由四个里程碑式的成就标示：\n\n- Transformers (2017)：Transformer 架构的引入为构建能够以前所未有的精确性和灵活性处理复杂任务的大规模高效模型奠定了基础。\n- GPT-3 (2020)：该模型展示了规模在 AI 中的变革力量，证明了在大规模数据集上训练的巨大模型可以在广泛的应用中实现接近人类的表现，为 AI 所能完成的任务设立了新的基准。\n- ChatGPT (2022)：通过将对话式 AI 带入主流，ChatGPT 使高级 AI 对普通用户来说更加可访问和互动。它还引发了关于广泛采用 AI 的伦理和社会影响的关键讨论。\n- DeepSeek-R1 (2025)：代表了成本效率的一大飞跃，DeepSeek-R1 利用专家混合架构(MoE)和优化算法，与许多美国模型相比，运营成本降低了多达 50 倍。其开源性质加速尖端 AI 应用的普及化，赋予各行业创新者权力，并强调了可扩展性、对齐性和可访问性在塑造 AI 未来中的重要性。\n\nLLMs 正逐步演变为多功能、多模态的推理系统，能够同时满足普通用户和特定需求。这一演变得益于突破性技术创新，以及在规模、易用性和成本效益上的显著提升，推动人工智能朝着更加包容和影响力深远的方向迈进。\n","slug":"2025-06-08-大模型底层技术分析","published":1,"updated":"2025-09-26T12:18:23.194Z","_id":"cmg0saj4g002tjm8n4yhwarji","comments":1,"layout":"post","photos":[],"content":"<h1 id=\"大模型底层技术分析\"><a href=\"#大模型底层技术分析\" class=\"headerlink\" title=\"大模型底层技术分析\"></a>大模型底层技术分析</h1><h1 id=\"参考资料\"><a href=\"#参考资料\" class=\"headerlink\" title=\"参考资料\"></a>参考资料</h1><blockquote>\n<ul>\n<li><a href=\"https://medium.com/@lmpo/mastering-llms-a-guide-to-decoding-algorithms-c90a48fd167b\">Understanding LLM Decoding Strategies</a></li>\n<li><a href=\"https://segmentfault.com/a/1190000046177208\">最新「大模型简史」整理！从 Transformer（2017）到 DeepSeek-R1（2025）</a></li>\n<li><a href=\"https://medium.com/@lmpo/%E5%A4%A7%E5%9E%8B%E8%AF%AD%E8%A8%80%E6%A8%A1%E5%9E%8B%E7%AE%80%E5%8F%B2-%E4%BB%8Etransformer-2017-%E5%88%B0deepseek-r1-2025-cc54d658fb43\">大语言模型简史</a></li>\n</ul>\n</blockquote>\n<h1 id=\"2025年大语言模型综述论文推荐\"><a href=\"#2025年大语言模型综述论文推荐\" class=\"headerlink\" title=\"2025年大语言模型综述论文推荐\"></a>2025年大语言模型综述论文推荐</h1><blockquote>\n<ul>\n<li><a href=\"https://github.com/luo-junyu/Awesome-Agent-Papers\">Awesome Agent Papers GitHub Repository</a></li>\n</ul>\n</blockquote>\n<p>以下是三篇 2025 年关于大语言模型的综述论文：</p>\n<ol>\n<li><h2 id=\"A-Survey-on-Large-Language-Models-with-some-Insights-on-their-Capabilities-and-Limitations\"><a href=\"#A-Survey-on-Large-Language-Models-with-some-Insights-on-their-Capabilities-and-Limitations\" class=\"headerlink\" title=\"A Survey on Large Language Models with some Insights on their Capabilities and Limitations\"></a><a href=\"https://arxiv.org/abs/2501.04040\">A Survey on Large Language Models with some Insights on their Capabilities and Limitations</a></h2></li>\n</ol>\n<ul>\n<li><strong>链接</strong> : <a href=\"https://arxiv.org/abs/2501.04040\">arXiv:2501.04040</a></li>\n<li><strong>内容概述</strong> :<br>该论文深入探讨 LLMs 的能力，包括文本生成、问答、翻译、摘要、常识推理、代码生成和数学计算，强调其接近人类水平的理解能力。研究分析了基于 Transformer 架构的模型（如 GPT、LLaMA），探讨了数据和计算规模的指数增长对性能的影响。论文还讨论了扩展机制（如参数量增加、上下文长度扩展）和架构策略（如多头注意力、层归一化）。此外，分析了 LLMs 的局限性，如高计算成本、事实错误（hallucination）和伦理问题。应用领域包括医疗（诊断辅助）、金融（风险评估）、教育（智能辅导）和法律（合同分析）。论文还探讨了链式推理（Chain-of-Thought, CoT）和路径推理（Path-of-Thought, PoT）能力，以及 LLM-modulo 框架的泛化性。</li>\n<li><strong>贡献</strong> :</li>\n<li>提供 LLMs 的全面能力与局限性分析，适合理解技术边界。</li>\n<li>覆盖多领域应用，适合跨行业参考。</li>\n<li>174 页的详尽内容，计划提交期刊的精简版，信息量丰富。</li>\n</ul>\n<ol start=\"2\">\n<li><h2 id=\"Large-Language-Models-A-Survey\"><a href=\"#Large-Language-Models-A-Survey\" class=\"headerlink\" title=\"Large Language Models: A Survey\"></a><a href=\"https://arxiv.org/abs/2402.06196\">Large Language Models: A Survey</a></h2></li>\n</ol>\n<ul>\n<li><strong>链接</strong> : <a href=\"https://arxiv.org/abs/2402.06196\">arXiv:2402.06196</a></li>\n<li><strong>内容概述</strong> :<br>该论文是 2024 年初版的更新版本，综述了主流 LLMs（如 GPT、LLaMA、PaLM）的特性、贡献和局限性。研究讨论了构建和增强 LLMs 的技术，包括预训练、微调、分布式训练和高效推理。论文调研了用于训练、微调和评估的热门数据集（如 Common Crawl、The Pile），并回顾了广泛使用的评估指标（如 BLEU、ROUGE、Perplexity）。通过代表性基准测试（如 MMLU、GLUE）比较了多个 LLMs 的性能，分析了其在不同任务上的表现。论文还探讨了开放挑战，如计算效率、数据偏见和模型可解释性，以及未来研究方向（如多模态 LLMs、能源优化）。</li>\n<li><strong>贡献</strong> :</li>\n<li>提供 LLMs 的技术全景，涵盖架构、数据集和评估。</li>\n<li>更新至 2025 年，包含最新模型和优化技术。</li>\n<li>强调未来方向，适合预测技术趋势。</li>\n</ul>\n<ol start=\"3\">\n<li><h2 id=\"Large-Language-Model-Agent-A-Survey-on-Methodology-Applications-and-Challenges\"><a href=\"#Large-Language-Model-Agent-A-Survey-on-Methodology-Applications-and-Challenges\" class=\"headerlink\" title=\"Large Language Model Agent: A Survey on Methodology, Applications and Challenges\"></a><a href=\"https://arxiv.org/abs/2503.21460\">Large Language Model Agent: A Survey on Methodology, Applications and Challenges</a></h2></li>\n</ol>\n<ul>\n<li><strong>链接</strong> : <a href=\"https://arxiv.org/abs/2503.21460\">arXiv:2503.21460</a></li>\n<li><strong>内容概述</strong> :<br>该论文聚焦 LLM 智能体，分析其方法论、应用和挑战，涵盖 329 篇相关研究。论文提出了以方法论为中心的分类法，连接架构基础、协作机制和演化路径，统一了智能体设计的研究碎片。讨论了智能体的目标驱动行为和动态适应能力，探索其在复杂环境中的表现。应用场景包括自动化任务分解、协作工作流和多智能体系统。挑战包括计算资源需求、协作效率和评估方法的标准化。论文提供资源库（<a href=\"https://github.com/luo-junyu/Awesome-Agent-Papers\">GitHub</a>），便于进一步研究。</li>\n<li><strong>贡献</strong> :</li>\n<li>提供 LLM 智能体的系统性分类，适合深入研究智能体应用。</li>\n<li>覆盖广泛应用场景，强调协作机制。</li>\n<li>提供开源资源，方便开发者实践。</li>\n</ul>\n<h1 id=\"概述\"><a href=\"#概述\" class=\"headerlink\" title=\"概述\"></a>概述</h1><h2 id=\"什么是语言模型-Language-Models-？\"><a href=\"#什么是语言模型-Language-Models-？\" class=\"headerlink\" title=\"什么是语言模型 (Language Models)？\"></a>什么是语言模型 (Language Models)？</h2><p><img src=\"https://gitee.com/tanke11223344/imagehost/raw/main/blog/1749366089085BNAubDynsogt1bxoYrPcAnBlnvh.png\" alt=\"1749366089085BNAubDynsogt1bxoYrPcAnBlnvh.png\"></p>\n<p>「语言模型」是一种「人工智能系统」，旨在处理、理解和生成类似人类的语言。它们从大型数据集中学习模式和结构，使得能够产生连贯且上下文相关的文本，应用于翻译、摘要、聊天机器人和内容生成等领域。</p>\n<h3 id=\"大型语言模型（LLMs）\"><a href=\"#大型语言模型（LLMs）\" class=\"headerlink\" title=\"大型语言模型（LLMs）\"></a>大型语言模型（LLMs）</h3><p>「语言模型」（LMs）和「大型语言模型」（LLMs）这两个术语虽然经常被互换使用，但实际上它们基于规模、架构、训练数据和能力指代不同的概念。LLMs 是 LMs 的一个子集，其规模显著更大，通常包含数十亿个参数（例如，GPT-3 拥有 1750 亿个参数）。这种更大的规模使 LLMs 能够在广泛的任务中表现出卓越的性能。“LLM”这一术语在 2018 至 2019 年间随着基于 Transformer 架构的模型（如 BERT 和 GPT-1）的出现开始受到关注。然而，在 2020 年 GPT-3 发布后，这个词才被广泛使用，展示了这些大规模模型的重大影响力和强大能力。</p>\n<h3 id=\"自回归语言模型-（Autoregressive-Language-Models）\"><a href=\"#自回归语言模型-（Autoregressive-Language-Models）\" class=\"headerlink\" title=\"自回归语言模型 （Autoregressive Language Models）\"></a><a href=\"https://zhida.zhihu.com/search?content_id=255912486&content_type=Article&match_order=1&q=%E8%87%AA%E5%9B%9E%E5%BD%92%E8%AF%AD%E8%A8%80%E6%A8%A1%E5%9E%8B&zhida_source=entity\">自回归语言模型</a> （Autoregressive Language Models）</h3><p>大多数 LLMs 以「自回归方式」(Autoregressive)操作，这意味着它们根据前面的「文本」预测下一个「字」（或 token／sub-word）的「概率分布」(propability distribution)。这种自回归特性使模型能够学习复杂的语言模式和依赖关系，从而善于「文本生成」。</p>\n<p>$$<br>(\\begin{array}{cc}w_1,w_2&amp;,\\ldots,w_{n-1}\\end{array})\\left(w_{n}\\right)P(w_{n}|w_1,w_2,\\ldots,w_{n-1},\\ldots,w_{n-1})<br>$$</p>\n<p>在文本生成任时，LLM 通过解码算法(Decoding Algorithm)来确定下一个输出的字。</p>\n<p>这一过程可以采用不同的策略：既可以选择概率最高的下个字（即贪婪搜索），也可以从预测的概率分布中随机采样一个字。后一种方法使得每次生成的文本都可能有所不同，这种特性与人类语言的多样性和随机性颇为相似。</p>\n<p><img src=\"https://gitee.com/tanke11223344/imagehost/raw/main/blog/1749366102088NG49bUAoXomHelxiq2ZckdIlnpb.png\" alt=\"1749366102088NG49bUAoXomHelxiq2ZckdIlnpb.png\"><br><img src=\"https://gitee.com/tanke11223344/imagehost/raw/main/blog/1749366116880KWu3bn2W2oethdxLzqAcm6xBnWC.png\" alt=\"1749366116880KWu3bn2W2oethdxLzqAcm6xBnWC.png\"></p>\n<h3 id=\"生成能力\"><a href=\"#生成能力\" class=\"headerlink\" title=\"生成能力\"></a>生成能力</h3><p>LLMs 的自回归特性使其能够基于前文提供的上下文逐词生成文本。从「提示」(prompt)开始，如下图，模型通过迭代预测下一个词，直到生成完整的序列或达到预定的停止条件。为了生成对提示的完整回答，LLM 通过将先前选择的标记添加到输入中进行迭代生成，尤如「文字接龙」游戏。</p>\n<p><img src=\"https://gitee.com/tanke11223344/imagehost/raw/main/blog/1749366127852Do7ybXLnFoU5QmxRFcrcML6Lnpf.png\" alt=\"1749366127852Do7ybXLnFoU5QmxRFcrcML6Lnpf.png\"></p>\n<h2 id=\"Transformer-革命-2017\"><a href=\"#Transformer-革命-2017\" class=\"headerlink\" title=\"Transformer 革命 (2017)\"></a>Transformer 革命 (2017)</h2><blockquote>\n<ul>\n<li><a href=\"https://arxiv.org/abs/1706.03762\">Attention Is All You Need</a></li>\n</ul>\n</blockquote>\n<p>Vaswani 等人在 2017 年通过其开创性论文“Attention is All You Need”引入了 Transformer 架构，标志着 NLP 的一个分水岭时刻。它解决了早期模型如循环神经网络（RNNs）和长短期记忆网络（LSTMs）的关键限制，这些模型在长程依赖性和顺序处理方面存在困难。这些问题使得使用 RNN 或 LSTM 实现有效的语言模型变得困难，因为它们计算效率低下且容易出现梯度消失等问题。另一方面，Transformers 克服了这些障碍，彻底改变了这一领域，并为现代大型语言模型奠定了基础。</p>\n<p><img src=\"https://gitee.com/tanke11223344/imagehost/raw/main/blog/1749366139852ZnJWbnoMCojKUExcNMZcJaV4nod.png\" alt=\"1749366139852ZnJWbnoMCojKUExcNMZcJaV4nod.png\"></p>\n<h3 id=\"Transformer-架构的关键创新\"><a href=\"#Transformer-架构的关键创新\" class=\"headerlink\" title=\"Transformer 架构的关键创新\"></a>Transformer 架构的关键创新</h3><p>自注意力机制 (Self-Attention)：与按顺序处理标记并难以应对长程依赖性的 RNN 不同，Transformers 使用自注意力来权衡每个标记相对于其他标记的重要性。这使得模型能够动态关注输入的相关部分。数学上：</p>\n<p>$$<br>\\mathrm{Attention}(\\mathbf{Q},\\mathbf{K},\\mathbf{V})&#x3D;\\mathrm{Softmax}\\left(\\frac{\\mathbf{QK^T}}{\\sqrt{d_k}}\\right)\\mathrm{V}<br>$$</p>\n<p>这里，Q、K、V 是查询(query)、键(key)和值(value)矩阵，dₖ 是键的维度。自注意力允许并行计算，加快训练速度，同时提高全局上下文理解。</p>\n<p><img src=\"https://gitee.com/tanke11223344/imagehost/raw/main/blog/1749366152088YWvebIv6soDVh2xSALYc4m2vnoc.png\" alt=\"1749366152088YWvebIv6soDVh2xSALYc4m2vnoc.png\"></p>\n<p>多头注意力：多个注意力头并行操作，每个头专注于输入的不同方面。它们的输出被连接并转换，从而实现更丰富的上下文表示。</p>\n<p><img src=\"https://gitee.com/tanke11223344/imagehost/raw/main/blog/1749366160852M4bYbd1axoJPw5xY8TzcBDn4n4b.png\" alt=\"1749366160852M4bYbd1axoJPw5xY8TzcBDn4n4b.png\"></p>\n<p>前馈网络(FFN)和层归一化(Layer Norm)：每个 Transformer 层包括应用于每个标记的前馈网络，以及层归一化和残差连接。这些稳定了训练并支持更深的架构。</p>\n<p>位置编码：由于 Transformers 本身不编码标记顺序，因此添加了位置编码（位置和频率的正弦函数）以表示词序，在不牺牲并行化的情况下保留顺序信息。</p>\n<p><img src=\"https://gitee.com/tanke11223344/imagehost/raw/main/blog/1749366172089We3mbXuFDomJfSxxrwFchohkn3d.png\" alt=\"1749366172089We3mbXuFDomJfSxxrwFchohkn3d.png\"></p>\n<h4 id=\"对语言建模的影响\"><a href=\"#对语言建模的影响\" class=\"headerlink\" title=\"对语言建模的影响\"></a>对语言建模的影响</h4><ul>\n<li>可扩展性：Transformers 实现了完全并行化的计算，使得在大型数据集上训练大规模模型成为可能。</li>\n<li>上下文理解：自注意力捕捉局部和全局依赖关系，提高了连贯性和上下文意识。</li>\n</ul>\n<p>Transformer 架构的引入为构建能够以前所未有的精确性和灵活性处理复杂任务的大规模高效语言模型奠定了基础。</p>\n<h2 id=\"预训练-Transformer-模型时代-2018–2020\"><a href=\"#预训练-Transformer-模型时代-2018–2020\" class=\"headerlink\" title=\"预训练 Transformer 模型时代 (2018–2020)\"></a><strong>预训练 Transformer 模型时代 (2018–2020)</strong></h2><p>2017 年 Transformer 架构的引入为 NLP 的新时代铺平了道路，其特点是预训练模型的兴起和对扩展的前所未有的关注。这一时期见证了两个有影响力的模型家族的出现：BERT 和 GPT，它们展示了大规模预训练和微调范式的强大功能。</p>\n<h3 id=\"BERT：双向上下文理解-2018\"><a href=\"#BERT：双向上下文理解-2018\" class=\"headerlink\" title=\"BERT：双向上下文理解 (2018)\"></a><strong>BERT：双向上下文理解 (2018)</strong></h3><p>2018 年，谷歌推出了 BERT（Bidirectional Encoder Representations from Transformers），这是一种使用 Transformer 编码器(Encoder)的突破性模型，在广泛的 NLP 任务中取得了最先进的性能。</p>\n<p>与之前单向处理文本（从左到右或从右到左）的模型不同，BERT 采用了双向训练方法，使其能够同时从两个方向捕获上下文。通过生成深层次的、上下文丰富的文本表示，BERT 在文本分类、命名实体识别（NER）、情感分析等语言理解任务中表现出色。</p>\n<p><img src=\"https://gitee.com/tanke11223344/imagehost/raw/main/blog/1749366186892IyVobGCISoulBexHp23ckNjrnpd.png\" alt=\"1749366186892IyVobGCISoulBexHp23ckNjrnpd.png\"></p>\n<p>BERT 的关键创新包括：</p>\n<ul>\n<li>掩码语言建模（Masker Language Modeling — MLM）：BERT 不是预测序列中的下一个词，而是被训练预测句子中随机掩码的标记。这迫使模型在进行预测时考虑整个句子的上下文 — — 包括前后词语。例如，给定句子“The cat sat on the [MASK] mat”，BERT 会学习根据周围上下文预测“soft”。</li>\n<li>下一句预测（Next Sentence Prediction — NSP）：除了 MLM 之外，BERT 还接受了称为下一句预测的次要任务训练，其中模型学习预测两个句子是否在文档中连续。这帮助 BERT 在需要理解句子之间关系的任务中表现出色，例如问答和自然语言推理。</li>\n</ul>\n<p>BERT 的影响：BERT 的双向训练使其在 GLUE（通用语言理解评估）和 SQuAD（斯坦福问答数据集）等基准测试中取得了突破性的表现。它的成功证明了上下文嵌入的重要性 — — 这些表示根据周围词语动态变化 — — 并为新一代预训练模型铺平了道路。</p>\n<h3 id=\"GPT：生成式预训练和自回归文本生成（2018–2020）\"><a href=\"#GPT：生成式预训练和自回归文本生成（2018–2020）\" class=\"headerlink\" title=\"GPT：生成式预训练和自回归文本生成（2018–2020）\"></a><strong>GPT：生成式预训练和自回归文本生成（2018–2020）</strong></h3><p>虽然 BERT 优先考虑双向上下文理解，但 OpenAI 的 GPT 系列采用了不同的策略，专注于通过自回归预训练实现生成能力。通过利用 Transformer 的解码器(Decoder)，GPT 模型在自回归语言模型和文本生成方面表现出色。</p>\n<p><img src=\"https://gitee.com/tanke11223344/imagehost/raw/main/blog/1749366197851NG9rbQKhOoiyU8xFnjzcE6dnnVb.png\" alt=\"1749366197851NG9rbQKhOoiyU8xFnjzcE6dnnVb.png\"></p>\n<p>GPT (2018)GPT 的第一个版本于 2018 年发布，是一个大规模的 Transformer 模型，经过训练以预测序列中的下一个词，类似于传统语言模型。</p>\n<ul>\n<li>单向自回归训练：GPT 使用因果语言建模目标进行训练，其中模型仅基于前面的标记预测下一个标记。这使得它特别适合于生成任务，如文本补全、摘要生成和对话生成。</li>\n<li>下游任务的微调：GPT 的一个关键贡献是它能够在不需要特定任务架构的情况下针对特定下游任务进行微调。只需添加一个分类头或修改输入格式，GPT 就可以适应诸如情感分析、机器翻译和问答等任务。</li>\n</ul>\n<p>GPT-2 (2019)在原版 GPT 的成功基础上，OpenAI 发布了 GPT-2，这是一个参数量达 15 亿的更大模型。GPT-2 展示了令人印象深刻的零样本(Zero-shot)能力，意味着它可以在没有任何特定任务微调的情况下执行任务。例如，它可以生成连贯的文章、回答问题，甚至在语言之间翻译文本，尽管没有明确针对这些任务进行训练。</p>\n<p><img src=\"https://gitee.com/tanke11223344/imagehost/raw/main/blog/1749366209087ZZYMb63vmoBszCxVyMFcGqQXnnf.png\" alt=\"1749366209087ZZYMb63vmoBszCxVyMFcGqQXnnf.png\"></p>\n<p>GPT-3 (2020)GPT-3 的发布标志着语言模型规模扩展的一个转折点。凭借惊人的 1750 亿参数(175B parameters)，GPT-3 突破了大规模预训练的可能性界限。它展示了显著的少样本(Few-short)和零样本(Zero-short)学习能力，在推理时只需提供最少或无需示例即可执行任务。GPT-3 的生成能力扩展到了创意写作、编程和复杂推理任务，展示了超大模型的潜力。</p>\n<p><img src=\"https://gitee.com/tanke11223344/imagehost/raw/main/blog/1749366215856SDbBbzF1Go4u1TxVTbjczhGtnze.png\" alt=\"1749366215856SDbBbzF1Go4u1TxVTbjczhGtnze.png\"></p>\n<p><img src=\"https://gitee.com/tanke11223344/imagehost/raw/main/blog/1749366222852FIYObGa7BoUFd8xnGLPcBRdqnPb.png\" alt=\"1749366222852FIYObGa7BoUFd8xnGLPcBRdqnPb.png\"></p>\n<h4 id=\"GPT-的影响及规模的作用\"><a href=\"#GPT-的影响及规模的作用\" class=\"headerlink\" title=\"GPT 的影响及规模的作用\"></a>GPT 的影响及规模的作用</h4><p>GPT 模型的引入，特别是 GPT-3，标志着 AI 的一个变革时代，展示了自回归架构和生成能力的强大功能。这些模型为内容创作、对话代理和自动推理等应用开辟了新的可能性，在广泛的任务中达到了接近人类的表现。GPT-3 凭借其 1750 亿参数证明了规模的深远影响，表明在大规模数据集上训练的更大模型可以树立新的 AI 能力标杆。</p>\n<p><img src=\"https://gitee.com/tanke11223344/imagehost/raw/main/blog/1749366235853QJZ3b7F2Coy8CUxlx7pcDmmhnOb.png\" alt=\"1749366235853QJZ3b7F2Coy8CUxlx7pcDmmhnOb.png\"></p>\n<blockquote>\n<p>语言建模性能随着模型大小、数据集大小和训练使用的计算量的增加而平稳提升。<br><a href=\"https://arxiv.org/abs/2001.08361\">Scaling Laws for Neural Language Models</a></p>\n</blockquote>\n<p>在 2018 年至 2020 年间，该领域由对规模的不懈追求驱动。研究人员发现，随着模型规模的增长 — — 从数百万到数十亿参数 — — 它们在捕捉复杂模式和泛化到新任务方面变得更好。这种规模效应得到了三个关键因素的支持：</p>\n<ul>\n<li>数据集大小：更大的模型需要庞大的数据集进行预训练。例如，GPT-3 是在大量互联网文本语料库上进行训练的，使其能够学习多样化的语言模式和知识领域。</li>\n<li>计算资源：强大的硬件（如 GPU 和 TPU）的可用性以及分布式训练技术，使得高效训练具有数十亿参数的模型成为可能。</li>\n<li>高效架构：混合精度训练和梯度检查点等创新降低了计算成本，使得在合理的时间和预算内进行大规模训练更加实际。</li>\n</ul>\n<p>这个规模扩展的时代不仅提升了语言模型的性能，还为未来的 AI 突破奠定了基础，强调了规模、数据和计算在实现最先进结果中的重要性。</p>\n<h2 id=\"后训练对齐：弥合-AI-与人类价值观之间的差距-2021–2022\"><a href=\"#后训练对齐：弥合-AI-与人类价值观之间的差距-2021–2022\" class=\"headerlink\" title=\"后训练对齐：弥合 AI 与人类价值观之间的差距 (2021–2022)\"></a><strong>后训练对齐：弥合 AI 与人类价值观之间的差距 (2021–2022)</strong></h2><p>GPT-3（一个拥有 1750 亿参数的 LLM）生成几乎无法与人类写作区分的文本的能力引发了关于 AI 生成内容的真实性和可信度的重大担忧。</p>\n<p>尽管这一成就标志着 AI 发展的一个重要里程碑，但也突显了确保这些模型与人类价值观、偏好和期望保持一致的关键挑战。一个主要问题是「幻觉」（Hallucination），即 LLM 生成与事实不符、无意义或与输入提示矛盾的内容，给人一种「一本正经地胡说八道」的印象。</p>\n<p>为了解决这些挑战，2021 年和 2022 年的研究人员专注于改善与人类意图的一致性并减少幻觉，导致了监督微调（SFT）和基于人类反馈的强化学习（RLHF）等技术的发展。</p>\n<h3 id=\"监督微调-SFT\"><a href=\"#监督微调-SFT\" class=\"headerlink\" title=\"监督微调 (SFT)\"></a><strong>监督微调 (SFT)</strong></h3><p>增强 GPT-3 对齐能力的第一步是监督微调（SFT），这是 RLHF 框架的基础组成部分。SFT 类似于指令调优，涉及在高质量的输入-输出对或演示上训练模型，以教它如何遵循指令并生成所需的输出。</p>\n<p><img src=\"https://gitee.com/tanke11223344/imagehost/raw/main/blog/1749366280852MfpwbkcnioN5lXxMOPgc4gyhnld.png\" alt=\"1749366280852MfpwbkcnioN5lXxMOPgc4gyhnld.png\"></p>\n<p>这些演示经过精心策划，以反映预期的行为和结果，确保模型学会生成准确且符合上下文的响应。</p>\n<p><img src=\"https://gitee.com/tanke11223344/imagehost/raw/main/blog/1749366299852Y3fRbjJ0OoOLhVxvXBwcQkp7nti.png\" alt=\"1749366299852Y3fRbjJ0OoOLhVxvXBwcQkp7nti.png\"></p>\n<p>然而，SFT 本身有局限性：</p>\n<ol>\n<li>可扩展性：收集人类演示是劳动密集型且耗时的，尤其是对于复杂或小众任务。</li>\n<li>性能：简单模仿人类行为并不能保证模型会超越人类表现或在未见过的任务上很好地泛化。</li>\n</ol>\n<p>为了克服这些挑战，需要一种更具可扩展性和效率的方法，为下一步铺平了道路：基于人类反馈的强化学习（Reinforcement Learning from Human Feedback — RLHF）。</p>\n<h3 id=\"基于人类反馈的强化学习-RLHF\"><a href=\"#基于人类反馈的强化学习-RLHF\" class=\"headerlink\" title=\"基于人类反馈的强化学习 (RLHF)\"></a><strong>基于人类反馈的强化学习 (RLHF)</strong></h3><p>OpenAI 在 2022 年引入的 RLHF 解决了 SFT 的可扩展性和性能限制。与需要人类编写完整输出的 SFT 不同，RLHF 涉及根据质量对多个模型生成的输出进行排名。这种方法允许更高效的数据收集和标注，显著增强了可扩展性。</p>\n<p>RLHF 过程包括两个关键阶段：</p>\n<ol>\n<li>训练奖励模型：人类注释者对模型生成的多个输出进行排名，创建一个偏好数据集。这些数据用于训练一个奖励模型，该模型学习根据人类反馈评估输出的质量。</li>\n<li>使用强化学习微调 LLM：奖励模型使用近端策略优化（Proximal Policy Optimization - PPO）（一种强化学习算法）指导 LLM 的微调。通过迭代更新，模型学会了生成更符合人类偏好和期望的输出。</li>\n</ol>\n<p>这个两阶段过程 — — 结合 SFT 和 RLHF — — 使模型不仅能够准确遵循指令，还能适应新任务并持续改进。通过将人类反馈整合到训练循环中，RLHF 显著增强了模型生成可靠、符合人类输出的能力，为 AI 对齐和性能设定了新标准。</p>\n<h3 id=\"ChatGPT：推进对话式-AI-2022\"><a href=\"#ChatGPT：推进对话式-AI-2022\" class=\"headerlink\" title=\"ChatGPT：推进对话式 AI (2022)\"></a><strong>ChatGPT：推进对话式 AI (2022)</strong></h3><p><img src=\"https://gitee.com/tanke11223344/imagehost/raw/main/blog/1749366311853KsazbV5PJoA6qqxaf11cKTLSnDc.png\" alt=\"1749366311853KsazbV5PJoA6qqxaf11cKTLSnDc.png\"></p>\n<p>2022 年 3 月，OpenAI 推出了 GPT-3.5，这是 GPT-3 的升级版，架构相同但训练和微调有所改进。关键增强包括通过改进数据更好地遵循指令，减少了幻觉（尽管未完全消除），以及更多样化、更新的数据集，以生成更相关、上下文感知的响应。</p>\n<ul>\n<li>对话聚焦的微调：在大量对话数据集上进行训练，ChatGPT 擅长维持对话的上下文和连贯性，实现更引人入胜和类似人类的互动。</li>\n<li>RLHF：通过整合 RLHF，ChatGPT 学会了生成不仅有用而且诚实和无害的响应。人类培训师根据质量对响应进行排名，使模型能够逐步改进其表现。</li>\n</ul>\n<p>ChatGPT 的推出标志着 AI 的一个关键时刻，通常被称为「ChatGPT 时刻」(ChatGPT moment)，因为它展示了对话式 AI 改变人机交互的潜力。</p>\n<h2 id=\"多模态模型：连接文本、图像及其他-2023–2024\"><a href=\"#多模态模型：连接文本、图像及其他-2023–2024\" class=\"headerlink\" title=\"多模态模型：连接文本、图像及其他 (2023–2024)\"></a><strong>多模态模型：连接文本、图像及其他 (2023–2024)</strong></h2><p>在 2023 年至 2024 年间，像 GPT-4V 和 GPT-4o 这样的多模态大型语言模型（MLLMs）通过将文本、图像、音频和视频整合到统一系统中重新定义了 AI。这些模型扩展了传统语言模型的能力，实现了更丰富的交互和更复杂的问题解决。</p>\n<h3 id=\"GPT-4V：视觉遇见语言\"><a href=\"#GPT-4V：视觉遇见语言\" class=\"headerlink\" title=\"GPT-4V：视觉遇见语言\"></a><strong>GPT-4V：视觉遇见语言</strong></h3><p>2023 年，OpenAI 推出了 GPT-4V，将 GPT-4 的语言能力与先进的计算机视觉相结合。它可以解释图像、生成标题、回答视觉问题，并推断视觉中的上下文关系。其跨模态注意力机制允许文本和图像数据的无缝集成，使其在医疗保健（如分析医学图像）和教育（如互动学习工具）等领域具有价值。</p>\n<p><img src=\"https://gitee.com/tanke11223344/imagehost/raw/main/blog/1749366321852Qf1nb3g94oVLqFx4n6xcdS7Yntt.png\" alt=\"1749366321852Qf1nb3g94oVLqFx4n6xcdS7Yntt.png\"></p>\n<h3 id=\"GPT-4o：全模态前沿\"><a href=\"#GPT-4o：全模态前沿\" class=\"headerlink\" title=\"GPT-4o：全模态前沿\"></a><strong>GPT-4o：全模态前沿</strong></h3><p>到 2024 年初，GPT-4o 通过整合音频和视频输入进一步推进了多模态。它在一个统一的表示空间中运行，可以转录音频、描述视频或将文本合成音频。实时交互和增强的创造力 — — 如生成多媒体内容 — — 使其成为娱乐和设计等行业的多功能工具。</p>\n<p>现实世界的影响: MLLMs 革新了医疗保健（诊断）、教育（互动学习）和创意产业（多媒体制作）等领域。它们处理多种模态的能力解锁了创新的新可能性。</p>\n<h2 id=\"推理模型：从「系统-1」到「系统-2」思维的转变-2024\"><a href=\"#推理模型：从「系统-1」到「系统-2」思维的转变-2024\" class=\"headerlink\" title=\"推理模型：从「系统 1」到「系统 2」思维的转变 (2024)\"></a><strong>推理模型：从「系统 1」到「系统 2」思维的转变 (2024)</strong></h2><p>2024 年，AI 开发开始强调增强「推理」(Reasoning)，从简单的模式识别转向更逻辑化和结构化的思维过程。这一转变受到认知心理学双重过程理论的影响，区分了「系统 1」（快速、直觉）和「系统 2」（缓慢、分析）思维。虽然像 GPT-3 和 GPT-4 这样的早期模型在生成文本等「系统 1」任务上表现出色，但在深度推理和问题解决方面却有所欠缺。</p>\n<p><img src=\"https://gitee.com/tanke11223344/imagehost/raw/main/blog/1749366332852KqgYbfsQdoAjgcxwSSTcTGHsnsd.png\" alt=\"1749366332852KqgYbfsQdoAjgcxwSSTcTGHsnsd.png\"></p>\n<h3 id=\"OpenAI-o1：推理能力的一大飞跃-2024\"><a href=\"#OpenAI-o1：推理能力的一大飞跃-2024\" class=\"headerlink\" title=\"OpenAI-o1：推理能力的一大飞跃(2024)\"></a><strong>OpenAI-o1：推理能力的一大飞跃(2024)</strong></h3><p>2024 年 9 月 12 日，OpenAI 发布的 o1-preview 标志着人工智能能力的重大飞跃，尤其是在解决复杂推理任务（如数学和编程）方面。与传统 LLMs 不同，推理模型采用了「长链思维」（Long CoT） — — 即内部的推理轨迹，使模型能够通过分解问题、批判自己的解决方案并探索替代方案来“思考”问题。这些 CoTs 对用户是隐藏的，用户看到的是一个总结性的输出。</p>\n<p><strong>推理模型的关键特性包括：</strong></p>\n<ul>\n<li>长链思维（Long CoT） ：使模型能够将复杂问题分解为更小的部分，批判性地评估其解决方案，并探索多种方法，类似于搜索算法。</li>\n<li>推理时计算控制 ：对于更复杂的问题，可以生成更长的 CoTs；而对于较简单的问题，则使用较短的 CoTs 以节省计算资源。</li>\n<li>增强的推理能力 ：尽管像 o1-preview 这样的初始推理模型在某些领域的能力不如标准 LLMs，但在推理任务中，它们的表现远远超越了后者，常常能与人类专家媲美。例如，o1-preview 在数学（AIME 2024）、编程（CodeForces）和博士级别的科学问题上均超越了 GPT-4o。</li>\n</ul>\n<p><img src=\"https://gitee.com/tanke11223344/imagehost/raw/main/blog/1749366342083VcEfbjllyoLSeCxGQvLcJEPBnSe.png\" alt=\"1749366342083VcEfbjllyoLSeCxGQvLcJEPBnSe.png\"></p>\n<p><strong>OpenAI-o1：</strong></p>\n<p>2024 年 12 月 5 日，OpenAI 的完整版 o1 模型进一步提升了性能，在美国 AIME 2024 数学考试中排名前 500 名学生之列，并显著超越了 GPT-4o（解决了 74%-93% 的 AIME 问题，而 GPT-4o 仅为 12%）。此外，o1-mini 作为更便宜且更快的版本，在编码任务中表现出色，尽管其成本仅为完整版 o1 的 20%。</p>\n<p><strong>OpenAI-o3：</strong></p>\n<p>2025 年 1 月 31 日，OpenAI 发布了 o3，这是其推理模型系列的最新突破，建立在 o1 模型成功的基础之上。尽管完整的 o3 模型尚未发布，但其在关键基准测试中的表现被描述为具有开创性。</p>\n<ul>\n<li>ARC-AGI ：达到 87.5% 的准确率，超过了人类水平的 85%，远超 GPT-4o 的 5%。</li>\n<li>编程 ：在 SWE-Bench Verified 上得分 71.7%，并在 Codeforces 上获得 2727 的 Elo 评分，跻身全球前 200 名竞争性程序员之列。</li>\n<li>数学 ：在 EpochAI 的 FrontierMath 基准测试中达到 25.2% 的准确率，相比之前的最先进水平（2.0%）有了显著提升。</li>\n</ul>\n<p><img src=\"https://gitee.com/tanke11223344/imagehost/raw/main/blog/1749366352852CSmybKboboZFwUxlGddcKw08n4d.png\" alt=\"1749366352852CSmybKboboZFwUxlGddcKw08n4d.png\"></p>\n<p>OpenAI-o1 和 OpenAI-o3 推理模型的发布代表了人工智能领域的重大进步，通过结构化的内部推理过程提供了卓越的问题解决能力，并在复杂数学和编程任务中树立了新的标杆。</p>\n<h2 id=\"成本高效的推理模型：DeepSeek-R1-2025\"><a href=\"#成本高效的推理模型：DeepSeek-R1-2025\" class=\"headerlink\" title=\"成本高效的推理模型：DeepSeek-R1 (2025)\"></a><strong>成本高效的推理模型：DeepSeek-R1 (2025)</strong></h2><p>LLMs 通常需要极其庞大的计算资源来进行训练和推理。像 GPT-4o 和 OpenAI-o1 这样的最先进 LLM 模型的闭源性质限制了对尖端 AI 的「普及化」。</p>\n<h4 id=\"DeepSeek-V3-2024–12\"><a href=\"#DeepSeek-V3-2024–12\" class=\"headerlink\" title=\"DeepSeek-V3 (2024–12)\"></a>DeepSeek-V3 (2024–12)</h4><p>2024 年 12 月下旬，「深度求索-V3」(DeepSeek-V3)作为一种成本高效的开放权重 LLM 出现，为 AI 的可访问性设定了新标准。DeepSeek-V3 与 OpenAI 的 ChatGPT 等顶级解决方案相媲美，但开发成本显著降低，估计约为 560 万美元，仅为西方公司投资的一小部分。</p>\n<p>该模型最多包含 6710 亿个参数，其中 370 亿个活跃参数，并采用专家混合（MoE）架构，将模型划分为专门处理数学和编码等任务的组件，以减轻训练负担。DeepSeek-V3 采用了工程效率，例如改进 Key-Value 缓存管理和进一步推动专家混合方法。该模型引入了三个关键架构：</p>\n<ul>\n<li>多头潜在注意力（Multi-head Latent Attention — MLA）：通过压缩注意力键和值来减少内存使用，同时保持性能，并通过旋转位置嵌入（RoPE）增强位置信息。</li>\n<li>DeepSeek 专家混合（DeepSeekMoE）：在前馈网络（FFNs）中采用共享和路由专家的混合，以提高效率并平衡专家利用率。</li>\n<li>多标记预测 (Multi-Token Prediction — MTP)：增强模型生成连贯且上下文相关的输出的能力，特别是对于需要复杂序列生成的任务。</li>\n</ul>\n<p><img src=\"https://gitee.com/tanke11223344/imagehost/raw/main/blog/1749366364852VqXxb4bC3o4zcdxZ2IfcCiBTn8f.png\" alt=\"1749366364852VqXxb4bC3o4zcdxZ2IfcCiBTn8f.png\"></p>\n<p>DeepSeek-V3 的发布引发了全球科技抛售，危及 1 万亿美元的市值，并导致英伟达股票盘前下跌 13%。DeepSeek-V3 的价格为每百万输出标记 2.19 美元，约为 OpenAI 类似模型成本的 1&#x2F;30。</p>\n<h4 id=\"DeepSeek-R1-Zero-和-DeepSeek-R1-2025–01\"><a href=\"#DeepSeek-R1-Zero-和-DeepSeek-R1-2025–01\" class=\"headerlink\" title=\"DeepSeek-R1-Zero 和 DeepSeek-R1 (2025–01)\"></a>DeepSeek-R1-Zero 和 DeepSeek-R1 (2025–01)</h4><p>仅仅一个月后，2025 年 1 月下旬，DeepSeek 通过发布 DeepSeek-R1-Zero 和 DeepSeek-R1 再次引起轰动，这些模型展示了卓越的推理能力，训练成本极低。</p>\n<p>利用先进的强化学习技术，这些模型证明了高性能推理可以在没有通常与尖端 AI 相关的巨额计算费用的情况下实现。这一突破巩固了 DeepSeek 作为高效和可扩展 AI 创新领导者的地位。</p>\n<ul>\n<li>DeepSeek-R1-Zero：一种基于 DeepSeek-V3 的推理模型，通过强化学习（RL）增强其推理能力。它完全消除了「监督微调」(SFT)阶段，直接从名为 DeepSeek-V3-Base 的预训练模型开始。</li>\n<li>它采用了一种基于「规则的强化学习方法」(Rule-based Reinforcement Learning)，称为「组相对策略优化」（Group Relative Policy Optimization — GRPO），根据预定义规则计算奖励，使训练过程更简单且更具可扩展性。</li>\n</ul>\n<p><img src=\"https://gitee.com/tanke11223344/imagehost/raw/main/blog/1749366374853P4GgbfXdCosRNaxVs9UcgPZJnrh.png\" alt=\"1749366374853P4GgbfXdCosRNaxVs9UcgPZJnrh.png\"></p>\n<p>DeepSeek-R1：为了解决 DeepSeek-R1-Zero 的局限性，如低可读性和语言混杂，DeepSeek-R1 纳入了一组有限的高质量冷启动数据和额外的 RL 训练。该模型经历了多个微调和 RL 阶段，包括拒绝采样和第二轮 RL 训练，以提高其通用能力和与人类偏好的一致性。</p>\n<p><img src=\"https://gitee.com/tanke11223344/imagehost/raw/main/blog/1749366389092T1wubPqY6oxXXFxd0qzcJ2glncg.png\" alt=\"1749366389092T1wubPqY6oxXXFxd0qzcJ2glncg.png\"></p>\n<p>蒸馏 DeepSeek 模型：DeepSeek 开发了较小的、蒸馏版的 DeepSeek-R1，参数范围从 15 亿到 700 亿，将先进的推理能力带到较弱的硬件上。这些模型使用原始 DeepSeek-R1 生成的合成数据进行微调，确保在推理任务中表现出色，同时足够轻量化以便本地部署。</p>\n<p><img src=\"https://gitee.com/tanke11223344/imagehost/raw/main/blog/1749366397854N4nzbC2KTorOW5xuYnzcufyenNe.png\" alt=\"1749366397854N4nzbC2KTorOW5xuYnzcufyenNe.png\"></p>\n<p>DeepSeek-R1 在各种基准测试中表现出竞争力，包括数学、编码、常识和写作。根据使用模式，它相比 OpenAI 的 o1 模型等竞争对手提供了显著的成本节省，使用成本便宜 20 到 50 倍。</p>\n<p><img src=\"https://gitee.com/tanke11223344/imagehost/raw/main/blog/1749366406080JB7LbnJZUoOrhzxuPW6cI1Z9nEb.png\" alt=\"1749366406080JB7LbnJZUoOrhzxuPW6cI1Z9nEb.png\"></p>\n<h1 id=\"结论\"><a href=\"#结论\" class=\"headerlink\" title=\"结论\"></a><strong>结论</strong></h1><p><img src=\"https://gitee.com/tanke11223344/imagehost/raw/main/blog/1749366416855UwLGbPxkwoY8EExcZAXcdmNtncC.png\" alt=\"1749366416855UwLGbPxkwoY8EExcZAXcdmNtncC.png\"></p>\n<p>从 2017 年 Transformer 架构的引入到 2025 年 DeepSeek-R1 的发展，大型语言模型（LLMs）的演变标志着人工智能领域的一个革命性篇章。LLMs 的崛起由四个里程碑式的成就标示：</p>\n<ul>\n<li>Transformers (2017)：Transformer 架构的引入为构建能够以前所未有的精确性和灵活性处理复杂任务的大规模高效模型奠定了基础。</li>\n<li>GPT-3 (2020)：该模型展示了规模在 AI 中的变革力量，证明了在大规模数据集上训练的巨大模型可以在广泛的应用中实现接近人类的表现，为 AI 所能完成的任务设立了新的基准。</li>\n<li>ChatGPT (2022)：通过将对话式 AI 带入主流，ChatGPT 使高级 AI 对普通用户来说更加可访问和互动。它还引发了关于广泛采用 AI 的伦理和社会影响的关键讨论。</li>\n<li>DeepSeek-R1 (2025)：代表了成本效率的一大飞跃，DeepSeek-R1 利用专家混合架构(MoE)和优化算法，与许多美国模型相比，运营成本降低了多达 50 倍。其开源性质加速尖端 AI 应用的普及化，赋予各行业创新者权力，并强调了可扩展性、对齐性和可访问性在塑造 AI 未来中的重要性。</li>\n</ul>\n<p>LLMs 正逐步演变为多功能、多模态的推理系统，能够同时满足普通用户和特定需求。这一演变得益于突破性技术创新，以及在规模、易用性和成本效益上的显著提升，推动人工智能朝着更加包容和影响力深远的方向迈进。</p>\n","excerpt":"","more":"<h1 id=\"大模型底层技术分析\"><a href=\"#大模型底层技术分析\" class=\"headerlink\" title=\"大模型底层技术分析\"></a>大模型底层技术分析</h1><h1 id=\"参考资料\"><a href=\"#参考资料\" class=\"headerlink\" title=\"参考资料\"></a>参考资料</h1><blockquote>\n<ul>\n<li><a href=\"https://medium.com/@lmpo/mastering-llms-a-guide-to-decoding-algorithms-c90a48fd167b\">Understanding LLM Decoding Strategies</a></li>\n<li><a href=\"https://segmentfault.com/a/1190000046177208\">最新「大模型简史」整理！从 Transformer（2017）到 DeepSeek-R1（2025）</a></li>\n<li><a href=\"https://medium.com/@lmpo/%E5%A4%A7%E5%9E%8B%E8%AF%AD%E8%A8%80%E6%A8%A1%E5%9E%8B%E7%AE%80%E5%8F%B2-%E4%BB%8Etransformer-2017-%E5%88%B0deepseek-r1-2025-cc54d658fb43\">大语言模型简史</a></li>\n</ul>\n</blockquote>\n<h1 id=\"2025年大语言模型综述论文推荐\"><a href=\"#2025年大语言模型综述论文推荐\" class=\"headerlink\" title=\"2025年大语言模型综述论文推荐\"></a>2025年大语言模型综述论文推荐</h1><blockquote>\n<ul>\n<li><a href=\"https://github.com/luo-junyu/Awesome-Agent-Papers\">Awesome Agent Papers GitHub Repository</a></li>\n</ul>\n</blockquote>\n<p>以下是三篇 2025 年关于大语言模型的综述论文：</p>\n<ol>\n<li><h2 id=\"A-Survey-on-Large-Language-Models-with-some-Insights-on-their-Capabilities-and-Limitations\"><a href=\"#A-Survey-on-Large-Language-Models-with-some-Insights-on-their-Capabilities-and-Limitations\" class=\"headerlink\" title=\"A Survey on Large Language Models with some Insights on their Capabilities and Limitations\"></a><a href=\"https://arxiv.org/abs/2501.04040\">A Survey on Large Language Models with some Insights on their Capabilities and Limitations</a></h2></li>\n</ol>\n<ul>\n<li><strong>链接</strong> : <a href=\"https://arxiv.org/abs/2501.04040\">arXiv:2501.04040</a></li>\n<li><strong>内容概述</strong> :<br>该论文深入探讨 LLMs 的能力，包括文本生成、问答、翻译、摘要、常识推理、代码生成和数学计算，强调其接近人类水平的理解能力。研究分析了基于 Transformer 架构的模型（如 GPT、LLaMA），探讨了数据和计算规模的指数增长对性能的影响。论文还讨论了扩展机制（如参数量增加、上下文长度扩展）和架构策略（如多头注意力、层归一化）。此外，分析了 LLMs 的局限性，如高计算成本、事实错误（hallucination）和伦理问题。应用领域包括医疗（诊断辅助）、金融（风险评估）、教育（智能辅导）和法律（合同分析）。论文还探讨了链式推理（Chain-of-Thought, CoT）和路径推理（Path-of-Thought, PoT）能力，以及 LLM-modulo 框架的泛化性。</li>\n<li><strong>贡献</strong> :</li>\n<li>提供 LLMs 的全面能力与局限性分析，适合理解技术边界。</li>\n<li>覆盖多领域应用，适合跨行业参考。</li>\n<li>174 页的详尽内容，计划提交期刊的精简版，信息量丰富。</li>\n</ul>\n<ol start=\"2\">\n<li><h2 id=\"Large-Language-Models-A-Survey\"><a href=\"#Large-Language-Models-A-Survey\" class=\"headerlink\" title=\"Large Language Models: A Survey\"></a><a href=\"https://arxiv.org/abs/2402.06196\">Large Language Models: A Survey</a></h2></li>\n</ol>\n<ul>\n<li><strong>链接</strong> : <a href=\"https://arxiv.org/abs/2402.06196\">arXiv:2402.06196</a></li>\n<li><strong>内容概述</strong> :<br>该论文是 2024 年初版的更新版本，综述了主流 LLMs（如 GPT、LLaMA、PaLM）的特性、贡献和局限性。研究讨论了构建和增强 LLMs 的技术，包括预训练、微调、分布式训练和高效推理。论文调研了用于训练、微调和评估的热门数据集（如 Common Crawl、The Pile），并回顾了广泛使用的评估指标（如 BLEU、ROUGE、Perplexity）。通过代表性基准测试（如 MMLU、GLUE）比较了多个 LLMs 的性能，分析了其在不同任务上的表现。论文还探讨了开放挑战，如计算效率、数据偏见和模型可解释性，以及未来研究方向（如多模态 LLMs、能源优化）。</li>\n<li><strong>贡献</strong> :</li>\n<li>提供 LLMs 的技术全景，涵盖架构、数据集和评估。</li>\n<li>更新至 2025 年，包含最新模型和优化技术。</li>\n<li>强调未来方向，适合预测技术趋势。</li>\n</ul>\n<ol start=\"3\">\n<li><h2 id=\"Large-Language-Model-Agent-A-Survey-on-Methodology-Applications-and-Challenges\"><a href=\"#Large-Language-Model-Agent-A-Survey-on-Methodology-Applications-and-Challenges\" class=\"headerlink\" title=\"Large Language Model Agent: A Survey on Methodology, Applications and Challenges\"></a><a href=\"https://arxiv.org/abs/2503.21460\">Large Language Model Agent: A Survey on Methodology, Applications and Challenges</a></h2></li>\n</ol>\n<ul>\n<li><strong>链接</strong> : <a href=\"https://arxiv.org/abs/2503.21460\">arXiv:2503.21460</a></li>\n<li><strong>内容概述</strong> :<br>该论文聚焦 LLM 智能体，分析其方法论、应用和挑战，涵盖 329 篇相关研究。论文提出了以方法论为中心的分类法，连接架构基础、协作机制和演化路径，统一了智能体设计的研究碎片。讨论了智能体的目标驱动行为和动态适应能力，探索其在复杂环境中的表现。应用场景包括自动化任务分解、协作工作流和多智能体系统。挑战包括计算资源需求、协作效率和评估方法的标准化。论文提供资源库（<a href=\"https://github.com/luo-junyu/Awesome-Agent-Papers\">GitHub</a>），便于进一步研究。</li>\n<li><strong>贡献</strong> :</li>\n<li>提供 LLM 智能体的系统性分类，适合深入研究智能体应用。</li>\n<li>覆盖广泛应用场景，强调协作机制。</li>\n<li>提供开源资源，方便开发者实践。</li>\n</ul>\n<h1 id=\"概述\"><a href=\"#概述\" class=\"headerlink\" title=\"概述\"></a>概述</h1><h2 id=\"什么是语言模型-Language-Models-？\"><a href=\"#什么是语言模型-Language-Models-？\" class=\"headerlink\" title=\"什么是语言模型 (Language Models)？\"></a>什么是语言模型 (Language Models)？</h2><p><img src=\"https://gitee.com/tanke11223344/imagehost/raw/main/blog/1749366089085BNAubDynsogt1bxoYrPcAnBlnvh.png\" alt=\"1749366089085BNAubDynsogt1bxoYrPcAnBlnvh.png\"></p>\n<p>「语言模型」是一种「人工智能系统」，旨在处理、理解和生成类似人类的语言。它们从大型数据集中学习模式和结构，使得能够产生连贯且上下文相关的文本，应用于翻译、摘要、聊天机器人和内容生成等领域。</p>\n<h3 id=\"大型语言模型（LLMs）\"><a href=\"#大型语言模型（LLMs）\" class=\"headerlink\" title=\"大型语言模型（LLMs）\"></a>大型语言模型（LLMs）</h3><p>「语言模型」（LMs）和「大型语言模型」（LLMs）这两个术语虽然经常被互换使用，但实际上它们基于规模、架构、训练数据和能力指代不同的概念。LLMs 是 LMs 的一个子集，其规模显著更大，通常包含数十亿个参数（例如，GPT-3 拥有 1750 亿个参数）。这种更大的规模使 LLMs 能够在广泛的任务中表现出卓越的性能。“LLM”这一术语在 2018 至 2019 年间随着基于 Transformer 架构的模型（如 BERT 和 GPT-1）的出现开始受到关注。然而，在 2020 年 GPT-3 发布后，这个词才被广泛使用，展示了这些大规模模型的重大影响力和强大能力。</p>\n<h3 id=\"自回归语言模型-（Autoregressive-Language-Models）\"><a href=\"#自回归语言模型-（Autoregressive-Language-Models）\" class=\"headerlink\" title=\"自回归语言模型 （Autoregressive Language Models）\"></a><a href=\"https://zhida.zhihu.com/search?content_id=255912486&content_type=Article&match_order=1&q=%E8%87%AA%E5%9B%9E%E5%BD%92%E8%AF%AD%E8%A8%80%E6%A8%A1%E5%9E%8B&zhida_source=entity\">自回归语言模型</a> （Autoregressive Language Models）</h3><p>大多数 LLMs 以「自回归方式」(Autoregressive)操作，这意味着它们根据前面的「文本」预测下一个「字」（或 token／sub-word）的「概率分布」(propability distribution)。这种自回归特性使模型能够学习复杂的语言模式和依赖关系，从而善于「文本生成」。</p>\n<p>$$<br>(\\begin{array}{cc}w_1,w_2&amp;,\\ldots,w_{n-1}\\end{array})\\left(w_{n}\\right)P(w_{n}|w_1,w_2,\\ldots,w_{n-1},\\ldots,w_{n-1})<br>$$</p>\n<p>在文本生成任时，LLM 通过解码算法(Decoding Algorithm)来确定下一个输出的字。</p>\n<p>这一过程可以采用不同的策略：既可以选择概率最高的下个字（即贪婪搜索），也可以从预测的概率分布中随机采样一个字。后一种方法使得每次生成的文本都可能有所不同，这种特性与人类语言的多样性和随机性颇为相似。</p>\n<p><img src=\"https://gitee.com/tanke11223344/imagehost/raw/main/blog/1749366102088NG49bUAoXomHelxiq2ZckdIlnpb.png\" alt=\"1749366102088NG49bUAoXomHelxiq2ZckdIlnpb.png\"><br><img src=\"https://gitee.com/tanke11223344/imagehost/raw/main/blog/1749366116880KWu3bn2W2oethdxLzqAcm6xBnWC.png\" alt=\"1749366116880KWu3bn2W2oethdxLzqAcm6xBnWC.png\"></p>\n<h3 id=\"生成能力\"><a href=\"#生成能力\" class=\"headerlink\" title=\"生成能力\"></a>生成能力</h3><p>LLMs 的自回归特性使其能够基于前文提供的上下文逐词生成文本。从「提示」(prompt)开始，如下图，模型通过迭代预测下一个词，直到生成完整的序列或达到预定的停止条件。为了生成对提示的完整回答，LLM 通过将先前选择的标记添加到输入中进行迭代生成，尤如「文字接龙」游戏。</p>\n<p><img src=\"https://gitee.com/tanke11223344/imagehost/raw/main/blog/1749366127852Do7ybXLnFoU5QmxRFcrcML6Lnpf.png\" alt=\"1749366127852Do7ybXLnFoU5QmxRFcrcML6Lnpf.png\"></p>\n<h2 id=\"Transformer-革命-2017\"><a href=\"#Transformer-革命-2017\" class=\"headerlink\" title=\"Transformer 革命 (2017)\"></a>Transformer 革命 (2017)</h2><blockquote>\n<ul>\n<li><a href=\"https://arxiv.org/abs/1706.03762\">Attention Is All You Need</a></li>\n</ul>\n</blockquote>\n<p>Vaswani 等人在 2017 年通过其开创性论文“Attention is All You Need”引入了 Transformer 架构，标志着 NLP 的一个分水岭时刻。它解决了早期模型如循环神经网络（RNNs）和长短期记忆网络（LSTMs）的关键限制，这些模型在长程依赖性和顺序处理方面存在困难。这些问题使得使用 RNN 或 LSTM 实现有效的语言模型变得困难，因为它们计算效率低下且容易出现梯度消失等问题。另一方面，Transformers 克服了这些障碍，彻底改变了这一领域，并为现代大型语言模型奠定了基础。</p>\n<p><img src=\"https://gitee.com/tanke11223344/imagehost/raw/main/blog/1749366139852ZnJWbnoMCojKUExcNMZcJaV4nod.png\" alt=\"1749366139852ZnJWbnoMCojKUExcNMZcJaV4nod.png\"></p>\n<h3 id=\"Transformer-架构的关键创新\"><a href=\"#Transformer-架构的关键创新\" class=\"headerlink\" title=\"Transformer 架构的关键创新\"></a>Transformer 架构的关键创新</h3><p>自注意力机制 (Self-Attention)：与按顺序处理标记并难以应对长程依赖性的 RNN 不同，Transformers 使用自注意力来权衡每个标记相对于其他标记的重要性。这使得模型能够动态关注输入的相关部分。数学上：</p>\n<p>$$<br>\\mathrm{Attention}(\\mathbf{Q},\\mathbf{K},\\mathbf{V})&#x3D;\\mathrm{Softmax}\\left(\\frac{\\mathbf{QK^T}}{\\sqrt{d_k}}\\right)\\mathrm{V}<br>$$</p>\n<p>这里，Q、K、V 是查询(query)、键(key)和值(value)矩阵，dₖ 是键的维度。自注意力允许并行计算，加快训练速度，同时提高全局上下文理解。</p>\n<p><img src=\"https://gitee.com/tanke11223344/imagehost/raw/main/blog/1749366152088YWvebIv6soDVh2xSALYc4m2vnoc.png\" alt=\"1749366152088YWvebIv6soDVh2xSALYc4m2vnoc.png\"></p>\n<p>多头注意力：多个注意力头并行操作，每个头专注于输入的不同方面。它们的输出被连接并转换，从而实现更丰富的上下文表示。</p>\n<p><img src=\"https://gitee.com/tanke11223344/imagehost/raw/main/blog/1749366160852M4bYbd1axoJPw5xY8TzcBDn4n4b.png\" alt=\"1749366160852M4bYbd1axoJPw5xY8TzcBDn4n4b.png\"></p>\n<p>前馈网络(FFN)和层归一化(Layer Norm)：每个 Transformer 层包括应用于每个标记的前馈网络，以及层归一化和残差连接。这些稳定了训练并支持更深的架构。</p>\n<p>位置编码：由于 Transformers 本身不编码标记顺序，因此添加了位置编码（位置和频率的正弦函数）以表示词序，在不牺牲并行化的情况下保留顺序信息。</p>\n<p><img src=\"https://gitee.com/tanke11223344/imagehost/raw/main/blog/1749366172089We3mbXuFDomJfSxxrwFchohkn3d.png\" alt=\"1749366172089We3mbXuFDomJfSxxrwFchohkn3d.png\"></p>\n<h4 id=\"对语言建模的影响\"><a href=\"#对语言建模的影响\" class=\"headerlink\" title=\"对语言建模的影响\"></a>对语言建模的影响</h4><ul>\n<li>可扩展性：Transformers 实现了完全并行化的计算，使得在大型数据集上训练大规模模型成为可能。</li>\n<li>上下文理解：自注意力捕捉局部和全局依赖关系，提高了连贯性和上下文意识。</li>\n</ul>\n<p>Transformer 架构的引入为构建能够以前所未有的精确性和灵活性处理复杂任务的大规模高效语言模型奠定了基础。</p>\n<h2 id=\"预训练-Transformer-模型时代-2018–2020\"><a href=\"#预训练-Transformer-模型时代-2018–2020\" class=\"headerlink\" title=\"预训练 Transformer 模型时代 (2018–2020)\"></a><strong>预训练 Transformer 模型时代 (2018–2020)</strong></h2><p>2017 年 Transformer 架构的引入为 NLP 的新时代铺平了道路，其特点是预训练模型的兴起和对扩展的前所未有的关注。这一时期见证了两个有影响力的模型家族的出现：BERT 和 GPT，它们展示了大规模预训练和微调范式的强大功能。</p>\n<h3 id=\"BERT：双向上下文理解-2018\"><a href=\"#BERT：双向上下文理解-2018\" class=\"headerlink\" title=\"BERT：双向上下文理解 (2018)\"></a><strong>BERT：双向上下文理解 (2018)</strong></h3><p>2018 年，谷歌推出了 BERT（Bidirectional Encoder Representations from Transformers），这是一种使用 Transformer 编码器(Encoder)的突破性模型，在广泛的 NLP 任务中取得了最先进的性能。</p>\n<p>与之前单向处理文本（从左到右或从右到左）的模型不同，BERT 采用了双向训练方法，使其能够同时从两个方向捕获上下文。通过生成深层次的、上下文丰富的文本表示，BERT 在文本分类、命名实体识别（NER）、情感分析等语言理解任务中表现出色。</p>\n<p><img src=\"https://gitee.com/tanke11223344/imagehost/raw/main/blog/1749366186892IyVobGCISoulBexHp23ckNjrnpd.png\" alt=\"1749366186892IyVobGCISoulBexHp23ckNjrnpd.png\"></p>\n<p>BERT 的关键创新包括：</p>\n<ul>\n<li>掩码语言建模（Masker Language Modeling — MLM）：BERT 不是预测序列中的下一个词，而是被训练预测句子中随机掩码的标记。这迫使模型在进行预测时考虑整个句子的上下文 — — 包括前后词语。例如，给定句子“The cat sat on the [MASK] mat”，BERT 会学习根据周围上下文预测“soft”。</li>\n<li>下一句预测（Next Sentence Prediction — NSP）：除了 MLM 之外，BERT 还接受了称为下一句预测的次要任务训练，其中模型学习预测两个句子是否在文档中连续。这帮助 BERT 在需要理解句子之间关系的任务中表现出色，例如问答和自然语言推理。</li>\n</ul>\n<p>BERT 的影响：BERT 的双向训练使其在 GLUE（通用语言理解评估）和 SQuAD（斯坦福问答数据集）等基准测试中取得了突破性的表现。它的成功证明了上下文嵌入的重要性 — — 这些表示根据周围词语动态变化 — — 并为新一代预训练模型铺平了道路。</p>\n<h3 id=\"GPT：生成式预训练和自回归文本生成（2018–2020）\"><a href=\"#GPT：生成式预训练和自回归文本生成（2018–2020）\" class=\"headerlink\" title=\"GPT：生成式预训练和自回归文本生成（2018–2020）\"></a><strong>GPT：生成式预训练和自回归文本生成（2018–2020）</strong></h3><p>虽然 BERT 优先考虑双向上下文理解，但 OpenAI 的 GPT 系列采用了不同的策略，专注于通过自回归预训练实现生成能力。通过利用 Transformer 的解码器(Decoder)，GPT 模型在自回归语言模型和文本生成方面表现出色。</p>\n<p><img src=\"https://gitee.com/tanke11223344/imagehost/raw/main/blog/1749366197851NG9rbQKhOoiyU8xFnjzcE6dnnVb.png\" alt=\"1749366197851NG9rbQKhOoiyU8xFnjzcE6dnnVb.png\"></p>\n<p>GPT (2018)GPT 的第一个版本于 2018 年发布，是一个大规模的 Transformer 模型，经过训练以预测序列中的下一个词，类似于传统语言模型。</p>\n<ul>\n<li>单向自回归训练：GPT 使用因果语言建模目标进行训练，其中模型仅基于前面的标记预测下一个标记。这使得它特别适合于生成任务，如文本补全、摘要生成和对话生成。</li>\n<li>下游任务的微调：GPT 的一个关键贡献是它能够在不需要特定任务架构的情况下针对特定下游任务进行微调。只需添加一个分类头或修改输入格式，GPT 就可以适应诸如情感分析、机器翻译和问答等任务。</li>\n</ul>\n<p>GPT-2 (2019)在原版 GPT 的成功基础上，OpenAI 发布了 GPT-2，这是一个参数量达 15 亿的更大模型。GPT-2 展示了令人印象深刻的零样本(Zero-shot)能力，意味着它可以在没有任何特定任务微调的情况下执行任务。例如，它可以生成连贯的文章、回答问题，甚至在语言之间翻译文本，尽管没有明确针对这些任务进行训练。</p>\n<p><img src=\"https://gitee.com/tanke11223344/imagehost/raw/main/blog/1749366209087ZZYMb63vmoBszCxVyMFcGqQXnnf.png\" alt=\"1749366209087ZZYMb63vmoBszCxVyMFcGqQXnnf.png\"></p>\n<p>GPT-3 (2020)GPT-3 的发布标志着语言模型规模扩展的一个转折点。凭借惊人的 1750 亿参数(175B parameters)，GPT-3 突破了大规模预训练的可能性界限。它展示了显著的少样本(Few-short)和零样本(Zero-short)学习能力，在推理时只需提供最少或无需示例即可执行任务。GPT-3 的生成能力扩展到了创意写作、编程和复杂推理任务，展示了超大模型的潜力。</p>\n<p><img src=\"https://gitee.com/tanke11223344/imagehost/raw/main/blog/1749366215856SDbBbzF1Go4u1TxVTbjczhGtnze.png\" alt=\"1749366215856SDbBbzF1Go4u1TxVTbjczhGtnze.png\"></p>\n<p><img src=\"https://gitee.com/tanke11223344/imagehost/raw/main/blog/1749366222852FIYObGa7BoUFd8xnGLPcBRdqnPb.png\" alt=\"1749366222852FIYObGa7BoUFd8xnGLPcBRdqnPb.png\"></p>\n<h4 id=\"GPT-的影响及规模的作用\"><a href=\"#GPT-的影响及规模的作用\" class=\"headerlink\" title=\"GPT 的影响及规模的作用\"></a>GPT 的影响及规模的作用</h4><p>GPT 模型的引入，特别是 GPT-3，标志着 AI 的一个变革时代，展示了自回归架构和生成能力的强大功能。这些模型为内容创作、对话代理和自动推理等应用开辟了新的可能性，在广泛的任务中达到了接近人类的表现。GPT-3 凭借其 1750 亿参数证明了规模的深远影响，表明在大规模数据集上训练的更大模型可以树立新的 AI 能力标杆。</p>\n<p><img src=\"https://gitee.com/tanke11223344/imagehost/raw/main/blog/1749366235853QJZ3b7F2Coy8CUxlx7pcDmmhnOb.png\" alt=\"1749366235853QJZ3b7F2Coy8CUxlx7pcDmmhnOb.png\"></p>\n<blockquote>\n<p>语言建模性能随着模型大小、数据集大小和训练使用的计算量的增加而平稳提升。<br><a href=\"https://arxiv.org/abs/2001.08361\">Scaling Laws for Neural Language Models</a></p>\n</blockquote>\n<p>在 2018 年至 2020 年间，该领域由对规模的不懈追求驱动。研究人员发现，随着模型规模的增长 — — 从数百万到数十亿参数 — — 它们在捕捉复杂模式和泛化到新任务方面变得更好。这种规模效应得到了三个关键因素的支持：</p>\n<ul>\n<li>数据集大小：更大的模型需要庞大的数据集进行预训练。例如，GPT-3 是在大量互联网文本语料库上进行训练的，使其能够学习多样化的语言模式和知识领域。</li>\n<li>计算资源：强大的硬件（如 GPU 和 TPU）的可用性以及分布式训练技术，使得高效训练具有数十亿参数的模型成为可能。</li>\n<li>高效架构：混合精度训练和梯度检查点等创新降低了计算成本，使得在合理的时间和预算内进行大规模训练更加实际。</li>\n</ul>\n<p>这个规模扩展的时代不仅提升了语言模型的性能，还为未来的 AI 突破奠定了基础，强调了规模、数据和计算在实现最先进结果中的重要性。</p>\n<h2 id=\"后训练对齐：弥合-AI-与人类价值观之间的差距-2021–2022\"><a href=\"#后训练对齐：弥合-AI-与人类价值观之间的差距-2021–2022\" class=\"headerlink\" title=\"后训练对齐：弥合 AI 与人类价值观之间的差距 (2021–2022)\"></a><strong>后训练对齐：弥合 AI 与人类价值观之间的差距 (2021–2022)</strong></h2><p>GPT-3（一个拥有 1750 亿参数的 LLM）生成几乎无法与人类写作区分的文本的能力引发了关于 AI 生成内容的真实性和可信度的重大担忧。</p>\n<p>尽管这一成就标志着 AI 发展的一个重要里程碑，但也突显了确保这些模型与人类价值观、偏好和期望保持一致的关键挑战。一个主要问题是「幻觉」（Hallucination），即 LLM 生成与事实不符、无意义或与输入提示矛盾的内容，给人一种「一本正经地胡说八道」的印象。</p>\n<p>为了解决这些挑战，2021 年和 2022 年的研究人员专注于改善与人类意图的一致性并减少幻觉，导致了监督微调（SFT）和基于人类反馈的强化学习（RLHF）等技术的发展。</p>\n<h3 id=\"监督微调-SFT\"><a href=\"#监督微调-SFT\" class=\"headerlink\" title=\"监督微调 (SFT)\"></a><strong>监督微调 (SFT)</strong></h3><p>增强 GPT-3 对齐能力的第一步是监督微调（SFT），这是 RLHF 框架的基础组成部分。SFT 类似于指令调优，涉及在高质量的输入-输出对或演示上训练模型，以教它如何遵循指令并生成所需的输出。</p>\n<p><img src=\"https://gitee.com/tanke11223344/imagehost/raw/main/blog/1749366280852MfpwbkcnioN5lXxMOPgc4gyhnld.png\" alt=\"1749366280852MfpwbkcnioN5lXxMOPgc4gyhnld.png\"></p>\n<p>这些演示经过精心策划，以反映预期的行为和结果，确保模型学会生成准确且符合上下文的响应。</p>\n<p><img src=\"https://gitee.com/tanke11223344/imagehost/raw/main/blog/1749366299852Y3fRbjJ0OoOLhVxvXBwcQkp7nti.png\" alt=\"1749366299852Y3fRbjJ0OoOLhVxvXBwcQkp7nti.png\"></p>\n<p>然而，SFT 本身有局限性：</p>\n<ol>\n<li>可扩展性：收集人类演示是劳动密集型且耗时的，尤其是对于复杂或小众任务。</li>\n<li>性能：简单模仿人类行为并不能保证模型会超越人类表现或在未见过的任务上很好地泛化。</li>\n</ol>\n<p>为了克服这些挑战，需要一种更具可扩展性和效率的方法，为下一步铺平了道路：基于人类反馈的强化学习（Reinforcement Learning from Human Feedback — RLHF）。</p>\n<h3 id=\"基于人类反馈的强化学习-RLHF\"><a href=\"#基于人类反馈的强化学习-RLHF\" class=\"headerlink\" title=\"基于人类反馈的强化学习 (RLHF)\"></a><strong>基于人类反馈的强化学习 (RLHF)</strong></h3><p>OpenAI 在 2022 年引入的 RLHF 解决了 SFT 的可扩展性和性能限制。与需要人类编写完整输出的 SFT 不同，RLHF 涉及根据质量对多个模型生成的输出进行排名。这种方法允许更高效的数据收集和标注，显著增强了可扩展性。</p>\n<p>RLHF 过程包括两个关键阶段：</p>\n<ol>\n<li>训练奖励模型：人类注释者对模型生成的多个输出进行排名，创建一个偏好数据集。这些数据用于训练一个奖励模型，该模型学习根据人类反馈评估输出的质量。</li>\n<li>使用强化学习微调 LLM：奖励模型使用近端策略优化（Proximal Policy Optimization - PPO）（一种强化学习算法）指导 LLM 的微调。通过迭代更新，模型学会了生成更符合人类偏好和期望的输出。</li>\n</ol>\n<p>这个两阶段过程 — — 结合 SFT 和 RLHF — — 使模型不仅能够准确遵循指令，还能适应新任务并持续改进。通过将人类反馈整合到训练循环中，RLHF 显著增强了模型生成可靠、符合人类输出的能力，为 AI 对齐和性能设定了新标准。</p>\n<h3 id=\"ChatGPT：推进对话式-AI-2022\"><a href=\"#ChatGPT：推进对话式-AI-2022\" class=\"headerlink\" title=\"ChatGPT：推进对话式 AI (2022)\"></a><strong>ChatGPT：推进对话式 AI (2022)</strong></h3><p><img src=\"https://gitee.com/tanke11223344/imagehost/raw/main/blog/1749366311853KsazbV5PJoA6qqxaf11cKTLSnDc.png\" alt=\"1749366311853KsazbV5PJoA6qqxaf11cKTLSnDc.png\"></p>\n<p>2022 年 3 月，OpenAI 推出了 GPT-3.5，这是 GPT-3 的升级版，架构相同但训练和微调有所改进。关键增强包括通过改进数据更好地遵循指令，减少了幻觉（尽管未完全消除），以及更多样化、更新的数据集，以生成更相关、上下文感知的响应。</p>\n<ul>\n<li>对话聚焦的微调：在大量对话数据集上进行训练，ChatGPT 擅长维持对话的上下文和连贯性，实现更引人入胜和类似人类的互动。</li>\n<li>RLHF：通过整合 RLHF，ChatGPT 学会了生成不仅有用而且诚实和无害的响应。人类培训师根据质量对响应进行排名，使模型能够逐步改进其表现。</li>\n</ul>\n<p>ChatGPT 的推出标志着 AI 的一个关键时刻，通常被称为「ChatGPT 时刻」(ChatGPT moment)，因为它展示了对话式 AI 改变人机交互的潜力。</p>\n<h2 id=\"多模态模型：连接文本、图像及其他-2023–2024\"><a href=\"#多模态模型：连接文本、图像及其他-2023–2024\" class=\"headerlink\" title=\"多模态模型：连接文本、图像及其他 (2023–2024)\"></a><strong>多模态模型：连接文本、图像及其他 (2023–2024)</strong></h2><p>在 2023 年至 2024 年间，像 GPT-4V 和 GPT-4o 这样的多模态大型语言模型（MLLMs）通过将文本、图像、音频和视频整合到统一系统中重新定义了 AI。这些模型扩展了传统语言模型的能力，实现了更丰富的交互和更复杂的问题解决。</p>\n<h3 id=\"GPT-4V：视觉遇见语言\"><a href=\"#GPT-4V：视觉遇见语言\" class=\"headerlink\" title=\"GPT-4V：视觉遇见语言\"></a><strong>GPT-4V：视觉遇见语言</strong></h3><p>2023 年，OpenAI 推出了 GPT-4V，将 GPT-4 的语言能力与先进的计算机视觉相结合。它可以解释图像、生成标题、回答视觉问题，并推断视觉中的上下文关系。其跨模态注意力机制允许文本和图像数据的无缝集成，使其在医疗保健（如分析医学图像）和教育（如互动学习工具）等领域具有价值。</p>\n<p><img src=\"https://gitee.com/tanke11223344/imagehost/raw/main/blog/1749366321852Qf1nb3g94oVLqFx4n6xcdS7Yntt.png\" alt=\"1749366321852Qf1nb3g94oVLqFx4n6xcdS7Yntt.png\"></p>\n<h3 id=\"GPT-4o：全模态前沿\"><a href=\"#GPT-4o：全模态前沿\" class=\"headerlink\" title=\"GPT-4o：全模态前沿\"></a><strong>GPT-4o：全模态前沿</strong></h3><p>到 2024 年初，GPT-4o 通过整合音频和视频输入进一步推进了多模态。它在一个统一的表示空间中运行，可以转录音频、描述视频或将文本合成音频。实时交互和增强的创造力 — — 如生成多媒体内容 — — 使其成为娱乐和设计等行业的多功能工具。</p>\n<p>现实世界的影响: MLLMs 革新了医疗保健（诊断）、教育（互动学习）和创意产业（多媒体制作）等领域。它们处理多种模态的能力解锁了创新的新可能性。</p>\n<h2 id=\"推理模型：从「系统-1」到「系统-2」思维的转变-2024\"><a href=\"#推理模型：从「系统-1」到「系统-2」思维的转变-2024\" class=\"headerlink\" title=\"推理模型：从「系统 1」到「系统 2」思维的转变 (2024)\"></a><strong>推理模型：从「系统 1」到「系统 2」思维的转变 (2024)</strong></h2><p>2024 年，AI 开发开始强调增强「推理」(Reasoning)，从简单的模式识别转向更逻辑化和结构化的思维过程。这一转变受到认知心理学双重过程理论的影响，区分了「系统 1」（快速、直觉）和「系统 2」（缓慢、分析）思维。虽然像 GPT-3 和 GPT-4 这样的早期模型在生成文本等「系统 1」任务上表现出色，但在深度推理和问题解决方面却有所欠缺。</p>\n<p><img src=\"https://gitee.com/tanke11223344/imagehost/raw/main/blog/1749366332852KqgYbfsQdoAjgcxwSSTcTGHsnsd.png\" alt=\"1749366332852KqgYbfsQdoAjgcxwSSTcTGHsnsd.png\"></p>\n<h3 id=\"OpenAI-o1：推理能力的一大飞跃-2024\"><a href=\"#OpenAI-o1：推理能力的一大飞跃-2024\" class=\"headerlink\" title=\"OpenAI-o1：推理能力的一大飞跃(2024)\"></a><strong>OpenAI-o1：推理能力的一大飞跃(2024)</strong></h3><p>2024 年 9 月 12 日，OpenAI 发布的 o1-preview 标志着人工智能能力的重大飞跃，尤其是在解决复杂推理任务（如数学和编程）方面。与传统 LLMs 不同，推理模型采用了「长链思维」（Long CoT） — — 即内部的推理轨迹，使模型能够通过分解问题、批判自己的解决方案并探索替代方案来“思考”问题。这些 CoTs 对用户是隐藏的，用户看到的是一个总结性的输出。</p>\n<p><strong>推理模型的关键特性包括：</strong></p>\n<ul>\n<li>长链思维（Long CoT） ：使模型能够将复杂问题分解为更小的部分，批判性地评估其解决方案，并探索多种方法，类似于搜索算法。</li>\n<li>推理时计算控制 ：对于更复杂的问题，可以生成更长的 CoTs；而对于较简单的问题，则使用较短的 CoTs 以节省计算资源。</li>\n<li>增强的推理能力 ：尽管像 o1-preview 这样的初始推理模型在某些领域的能力不如标准 LLMs，但在推理任务中，它们的表现远远超越了后者，常常能与人类专家媲美。例如，o1-preview 在数学（AIME 2024）、编程（CodeForces）和博士级别的科学问题上均超越了 GPT-4o。</li>\n</ul>\n<p><img src=\"https://gitee.com/tanke11223344/imagehost/raw/main/blog/1749366342083VcEfbjllyoLSeCxGQvLcJEPBnSe.png\" alt=\"1749366342083VcEfbjllyoLSeCxGQvLcJEPBnSe.png\"></p>\n<p><strong>OpenAI-o1：</strong></p>\n<p>2024 年 12 月 5 日，OpenAI 的完整版 o1 模型进一步提升了性能，在美国 AIME 2024 数学考试中排名前 500 名学生之列，并显著超越了 GPT-4o（解决了 74%-93% 的 AIME 问题，而 GPT-4o 仅为 12%）。此外，o1-mini 作为更便宜且更快的版本，在编码任务中表现出色，尽管其成本仅为完整版 o1 的 20%。</p>\n<p><strong>OpenAI-o3：</strong></p>\n<p>2025 年 1 月 31 日，OpenAI 发布了 o3，这是其推理模型系列的最新突破，建立在 o1 模型成功的基础之上。尽管完整的 o3 模型尚未发布，但其在关键基准测试中的表现被描述为具有开创性。</p>\n<ul>\n<li>ARC-AGI ：达到 87.5% 的准确率，超过了人类水平的 85%，远超 GPT-4o 的 5%。</li>\n<li>编程 ：在 SWE-Bench Verified 上得分 71.7%，并在 Codeforces 上获得 2727 的 Elo 评分，跻身全球前 200 名竞争性程序员之列。</li>\n<li>数学 ：在 EpochAI 的 FrontierMath 基准测试中达到 25.2% 的准确率，相比之前的最先进水平（2.0%）有了显著提升。</li>\n</ul>\n<p><img src=\"https://gitee.com/tanke11223344/imagehost/raw/main/blog/1749366352852CSmybKboboZFwUxlGddcKw08n4d.png\" alt=\"1749366352852CSmybKboboZFwUxlGddcKw08n4d.png\"></p>\n<p>OpenAI-o1 和 OpenAI-o3 推理模型的发布代表了人工智能领域的重大进步，通过结构化的内部推理过程提供了卓越的问题解决能力，并在复杂数学和编程任务中树立了新的标杆。</p>\n<h2 id=\"成本高效的推理模型：DeepSeek-R1-2025\"><a href=\"#成本高效的推理模型：DeepSeek-R1-2025\" class=\"headerlink\" title=\"成本高效的推理模型：DeepSeek-R1 (2025)\"></a><strong>成本高效的推理模型：DeepSeek-R1 (2025)</strong></h2><p>LLMs 通常需要极其庞大的计算资源来进行训练和推理。像 GPT-4o 和 OpenAI-o1 这样的最先进 LLM 模型的闭源性质限制了对尖端 AI 的「普及化」。</p>\n<h4 id=\"DeepSeek-V3-2024–12\"><a href=\"#DeepSeek-V3-2024–12\" class=\"headerlink\" title=\"DeepSeek-V3 (2024–12)\"></a>DeepSeek-V3 (2024–12)</h4><p>2024 年 12 月下旬，「深度求索-V3」(DeepSeek-V3)作为一种成本高效的开放权重 LLM 出现，为 AI 的可访问性设定了新标准。DeepSeek-V3 与 OpenAI 的 ChatGPT 等顶级解决方案相媲美，但开发成本显著降低，估计约为 560 万美元，仅为西方公司投资的一小部分。</p>\n<p>该模型最多包含 6710 亿个参数，其中 370 亿个活跃参数，并采用专家混合（MoE）架构，将模型划分为专门处理数学和编码等任务的组件，以减轻训练负担。DeepSeek-V3 采用了工程效率，例如改进 Key-Value 缓存管理和进一步推动专家混合方法。该模型引入了三个关键架构：</p>\n<ul>\n<li>多头潜在注意力（Multi-head Latent Attention — MLA）：通过压缩注意力键和值来减少内存使用，同时保持性能，并通过旋转位置嵌入（RoPE）增强位置信息。</li>\n<li>DeepSeek 专家混合（DeepSeekMoE）：在前馈网络（FFNs）中采用共享和路由专家的混合，以提高效率并平衡专家利用率。</li>\n<li>多标记预测 (Multi-Token Prediction — MTP)：增强模型生成连贯且上下文相关的输出的能力，特别是对于需要复杂序列生成的任务。</li>\n</ul>\n<p><img src=\"https://gitee.com/tanke11223344/imagehost/raw/main/blog/1749366364852VqXxb4bC3o4zcdxZ2IfcCiBTn8f.png\" alt=\"1749366364852VqXxb4bC3o4zcdxZ2IfcCiBTn8f.png\"></p>\n<p>DeepSeek-V3 的发布引发了全球科技抛售，危及 1 万亿美元的市值，并导致英伟达股票盘前下跌 13%。DeepSeek-V3 的价格为每百万输出标记 2.19 美元，约为 OpenAI 类似模型成本的 1&#x2F;30。</p>\n<h4 id=\"DeepSeek-R1-Zero-和-DeepSeek-R1-2025–01\"><a href=\"#DeepSeek-R1-Zero-和-DeepSeek-R1-2025–01\" class=\"headerlink\" title=\"DeepSeek-R1-Zero 和 DeepSeek-R1 (2025–01)\"></a>DeepSeek-R1-Zero 和 DeepSeek-R1 (2025–01)</h4><p>仅仅一个月后，2025 年 1 月下旬，DeepSeek 通过发布 DeepSeek-R1-Zero 和 DeepSeek-R1 再次引起轰动，这些模型展示了卓越的推理能力，训练成本极低。</p>\n<p>利用先进的强化学习技术，这些模型证明了高性能推理可以在没有通常与尖端 AI 相关的巨额计算费用的情况下实现。这一突破巩固了 DeepSeek 作为高效和可扩展 AI 创新领导者的地位。</p>\n<ul>\n<li>DeepSeek-R1-Zero：一种基于 DeepSeek-V3 的推理模型，通过强化学习（RL）增强其推理能力。它完全消除了「监督微调」(SFT)阶段，直接从名为 DeepSeek-V3-Base 的预训练模型开始。</li>\n<li>它采用了一种基于「规则的强化学习方法」(Rule-based Reinforcement Learning)，称为「组相对策略优化」（Group Relative Policy Optimization — GRPO），根据预定义规则计算奖励，使训练过程更简单且更具可扩展性。</li>\n</ul>\n<p><img src=\"https://gitee.com/tanke11223344/imagehost/raw/main/blog/1749366374853P4GgbfXdCosRNaxVs9UcgPZJnrh.png\" alt=\"1749366374853P4GgbfXdCosRNaxVs9UcgPZJnrh.png\"></p>\n<p>DeepSeek-R1：为了解决 DeepSeek-R1-Zero 的局限性，如低可读性和语言混杂，DeepSeek-R1 纳入了一组有限的高质量冷启动数据和额外的 RL 训练。该模型经历了多个微调和 RL 阶段，包括拒绝采样和第二轮 RL 训练，以提高其通用能力和与人类偏好的一致性。</p>\n<p><img src=\"https://gitee.com/tanke11223344/imagehost/raw/main/blog/1749366389092T1wubPqY6oxXXFxd0qzcJ2glncg.png\" alt=\"1749366389092T1wubPqY6oxXXFxd0qzcJ2glncg.png\"></p>\n<p>蒸馏 DeepSeek 模型：DeepSeek 开发了较小的、蒸馏版的 DeepSeek-R1，参数范围从 15 亿到 700 亿，将先进的推理能力带到较弱的硬件上。这些模型使用原始 DeepSeek-R1 生成的合成数据进行微调，确保在推理任务中表现出色，同时足够轻量化以便本地部署。</p>\n<p><img src=\"https://gitee.com/tanke11223344/imagehost/raw/main/blog/1749366397854N4nzbC2KTorOW5xuYnzcufyenNe.png\" alt=\"1749366397854N4nzbC2KTorOW5xuYnzcufyenNe.png\"></p>\n<p>DeepSeek-R1 在各种基准测试中表现出竞争力，包括数学、编码、常识和写作。根据使用模式，它相比 OpenAI 的 o1 模型等竞争对手提供了显著的成本节省，使用成本便宜 20 到 50 倍。</p>\n<p><img src=\"https://gitee.com/tanke11223344/imagehost/raw/main/blog/1749366406080JB7LbnJZUoOrhzxuPW6cI1Z9nEb.png\" alt=\"1749366406080JB7LbnJZUoOrhzxuPW6cI1Z9nEb.png\"></p>\n<h1 id=\"结论\"><a href=\"#结论\" class=\"headerlink\" title=\"结论\"></a><strong>结论</strong></h1><p><img src=\"https://gitee.com/tanke11223344/imagehost/raw/main/blog/1749366416855UwLGbPxkwoY8EExcZAXcdmNtncC.png\" alt=\"1749366416855UwLGbPxkwoY8EExcZAXcdmNtncC.png\"></p>\n<p>从 2017 年 Transformer 架构的引入到 2025 年 DeepSeek-R1 的发展，大型语言模型（LLMs）的演变标志着人工智能领域的一个革命性篇章。LLMs 的崛起由四个里程碑式的成就标示：</p>\n<ul>\n<li>Transformers (2017)：Transformer 架构的引入为构建能够以前所未有的精确性和灵活性处理复杂任务的大规模高效模型奠定了基础。</li>\n<li>GPT-3 (2020)：该模型展示了规模在 AI 中的变革力量，证明了在大规模数据集上训练的巨大模型可以在广泛的应用中实现接近人类的表现，为 AI 所能完成的任务设立了新的基准。</li>\n<li>ChatGPT (2022)：通过将对话式 AI 带入主流，ChatGPT 使高级 AI 对普通用户来说更加可访问和互动。它还引发了关于广泛采用 AI 的伦理和社会影响的关键讨论。</li>\n<li>DeepSeek-R1 (2025)：代表了成本效率的一大飞跃，DeepSeek-R1 利用专家混合架构(MoE)和优化算法，与许多美国模型相比，运营成本降低了多达 50 倍。其开源性质加速尖端 AI 应用的普及化，赋予各行业创新者权力，并强调了可扩展性、对齐性和可访问性在塑造 AI 未来中的重要性。</li>\n</ul>\n<p>LLMs 正逐步演变为多功能、多模态的推理系统，能够同时满足普通用户和特定需求。这一演变得益于突破性技术创新，以及在规模、易用性和成本效益上的显著提升，推动人工智能朝着更加包容和影响力深远的方向迈进。</p>\n"},{"title":"2025-06-04-低代码平台及相关技术介绍应用","date":"2025-06-03T16:00:00.000Z","_content":"# 低代码平台及相关技术介绍\n\n# 参考资料\n\n> - [低代码平台的技术原理 - 低代码技术 - 葡萄城产品文档中心](https://www.grapecity.com.cn/lowcode/low-code-introduction/core-ability-tech-principle/lowcode-tech-principle)\n> - [从实现原理看低代码](https://zhuanlan.zhihu.com/p/451340998)\n> - [什么是低代码开发？| Mendix](https://www.mendix.com/zh-CN/%E4%BD%8E%E4%BB%A3%E7%A0%81%E6%8C%87%E5%8D%97/)\n\n# 核心概念与技术原理\n\n## 何为低代码平台\n\n低代码平台是一种可视化软件开发方法，提供拖拽式组件、模型驱动逻辑和少量脚本，旨在最小化手写代码的需求，加速应用交付。\n\n![1749364800087EByXb7hZeo5Eaxxa6V3ctMObnXh.png](https://gitee.com/tanke11223344/imagehost/raw/main/blog/1749364800087EByXb7hZeo5Eaxxa6V3ctMObnXh.png)\n\n低代码是高级语言开发技术发展到一定阶段的产物，以覆盖软件全生命周期的可视化为主要特征。其核心原理是将开发者的可视化设计保存为对应的元数据，通过解析元数据，形成可运行的软件。元数据通常隐藏在可视化开发环境和服务器运行时之下，低代码平台的使用者可不必关心其技术细节，能将更多精力聚焦在业务逻辑的实现和技术创新落地上。\n\n## 技术原理\n\n### 系统架构\n\n在系统架构上，低代码开发平台可以分为两层：设计器（开发环境）和服务器（运行时）。服务器通常表现为低代码平台定制的 Web 服务器。在设计器方面，部分厂商沿用传统开发的方式，提供桌面端设计器，部分厂商则将以 Web 页面的形式提供在线设计器。前者的优势在于无需联网和更强的性能；后者则大幅节省了开发环境的搭建时间。\n\n1. **元数据驱动**：平台通过元数据定义 UI 元素、数据模型和业务逻辑，运行时引擎根据这些元数据渲染应用界面与行为，无需手写模板或控制器。\n2. **可视化建模**：利用拖拽画布和属性面板，让用户通过图形化界面定义流程图、表单布局和数据关系，后台自动生成相应的代码或配置。\n3. **模块化扩展**：为满足复杂场景，平台通常支持以插件或脚本方式插入自定义逻辑，例如 JavaScript、Java、C# 等，可在可视化组件之外进行深度定制。\n4. **全生命周期管理**：集成需求管理、版本控制、测试与部署流水线，使低代码项目在从原型到生产的各个阶段均可监控与协作。\n\n#### 代码生成器\n\n早期的低代码开发平台大多采用代码生成器的技术方案。低代码平台将可视化操作直接翻译成对应的可执行语言（如 Java）。这种做法开发难度低，曾经一度成为低代码的主流。\n\n但随着应用的深入，人们发现这种方式存在封装程度低、开发效率提升有效、可维护性弱等技术问题。更重要的是，一旦开发者使用其他开发工具对这些编译后的源代码进行修改后，往往无法再同步回低代码开发平台的可视化开发环境，致使无法持续使用可视化的方式对应用进行开发和维护，让低代码平台成为了“一次性工具”。这显然违背了低代码开发平台的初衷。\n\n#### 元数据驱动\n\n目前主流的低代码平台已经从生成可直接执行的程序代码（如 Java、C#），逐步切换为生成特定格式的元数据（格式为 XML、JSON）。这些元数据无法脱离平台运行，就像 Java 无法脱离 JRE/JDK 一样。\n\n> 但 JSON 的优点就是它的缺点，因为它的用途是数据交换而不是人工编写，导致基于 JSON 构建 DSL 不方便编辑，会有以下 3 个问题：\n>\n> - 不支持注释\n> - 不支持多行字符串\n> - 语法过于严格，比如不支持单引号，不能在最后多写一个逗号\n\n在开发阶段，平台使用者（即开发者）通过设计器，可视化构建页面、业务逻辑和数据结构，设计器会将这些操作的结果以元数据的形式保存成中间文件（也称 Project、工程文件，通常由大量 json、xml 等描述性语言的文件打包而成）；部署阶段，开发者通过设计器将中间文件进行预处理（包含但不限于有效性检查、压缩、加密等），并打包发布到服务器上。而服务器则充当了运行时（Runtime）的角色，自动解析中间文件里的元数据，最终形成应用，提供给最终用户使用。这个过程可以类比于使用 Visual Studio（开发环境）开发 ASP.NET MVC 应用，编译成程序集后，发布到启用.NET 的 IIS（服务器），以 Web 应用的形式提供给用户使用。\n\n![1749364830851Ajn3b2WMhoFLOTx0aqAcyM6cn4d.png](https://gitee.com/tanke11223344/imagehost/raw/main/blog/1749364830851Ajn3b2WMhoFLOTx0aqAcyM6cn4d.png)\n\n借助元数据驱动的技术方案，平台厂商将更多能力封装成开发者能在可视化设计器中使用的元数据类型（也成平台元数据），持续扩大低代码平台的应用场景，提升使用者的开发效率。一定程度上讲，低代码内置平台元数据的覆盖范围，决定了该平台可视化开发的能力边界。\n\n### 数据库\n\n低代码平台的数据建模可分为表结构设计和查询视图设计两部分，使用者在界面上通过可视化的方式，构建出表结构和视图，而平台将其自动转义为对应数据库的 SQL 语句。目前，大多数模型驱动的低代码平台支持可视化的表结构设计，部分平台支持可视化设计查询视图。\n\n数据建模是可视化开发技术最早的应用场景之一，技术相对成熟。低代码厂商通常会借鉴主流数据库管理软件的操作体验。\n\n![1749364840875PNDfbej74oEUKQxkIZqcPJM8nkh.png](https://gitee.com/tanke11223344/imagehost/raw/main/blog/1749364840875PNDfbej74oEUKQxkIZqcPJM8nkh.png)\n\n#### 表结构\n\n表结构设计的可视化由来已久，从中大型的分布式数据库 Microsoft SQL Server，到小型的单机数据库 Access，都提供有可视化的结构设计和数据编辑能力。绝大多数低代码平台延续了这些数据库软件的做法，以 SQL 语句直接操作数据库，而省略了生成元数据和解析元数据的环节。开发者在设计器上对表结构进行的调整，被翻译成了对应的 SQL 语句，在数据库上执行。与此同时，设计器可以通过数据库提供的结构（Schema）查询能力，实时获取数据库中的表结构，并展示在设计器中。\n\n在此基础上，面向企业级应用开发的低代码平台则需要将不同厂商、不同版本的数据库设计能力进行统一化，以确保使用低代码开发的应用可以在数据层面和第三方软件无缝集成。这通常意味着低代码平台需要针对各种数据库分别开发数据结构和数据的存取机制，为开发者“抹平”数据库间在数据类型、查询操作等领域的差异。\n\n#### 表关联\n\n主流数据库通常推荐使用外键约束描述表与表的关联关系，如主从表、业务实体与主数据等。早期的低代码平台也将表关联关系直接翻译成了外键。但是，随着多源数据整合需求的增加，这种在数据库层面为多张表建立“硬链接”的方式，面临了无法建立跨数据库、跨数据源的表关联的挑战。所以，越来越多的 ORM（对象关系映射）框架开始将表关联从数据库提升到业务服务器中，即在业务服务器上，以元数据的形式记录表与表的关联关系。\n\n于是，部分低代码平台开始迎合这一趋势，在用户建立表关联的时候，设计器不再生成创建外键的 SQL 语句，而是在元数据中描述这一关联，并提供给设计器和运行时使用。如在设计器中可以直接绑定子表或主数据的字段，在运行时实现级联删除等。\n\n#### 查询视图\n\n查询视图可以在数据表的基础上封装常用的数据能力。相比于在业务逻辑层做数据处理，运行在数据库上的视图性能更高。视图中新增的字段主要有两种类型：基于当前行中其他字段的值进行计算得出的计算字段，以及基于外键关系，对子表进行统计计算得出的聚合字段。\n\n值得一提的是，为了降低开发者的工作量，部分低代码开发平台会将查询视图的设计能力整合到表结构设计中，当用户在表结构设计器中创建计算字段或聚合字段时，平台会为该表创建一个查询视图，用户设置的公式会被转义成视图中的查询语句。在业务逻辑层对该表进行查询操作时，平台会自动寻找对应的视图，让开发者可以像读取表中其他字段一样，查询计算字段或聚合字段的值。\n\n### WebAPI / 业务逻辑\n\n业务处理逻辑的可视化设计是低代码开发平台的技术难点之一。在传统编码开发中，可视化的应用范围通常不会涉及这一部分。所以，各低代码厂商在业务逻辑的可视化设计领域采用了不同的设计思想，为开发者提供了差异化的设计体验，同样实现了基于可视化设计的结果自动化生成代码的效果。低代码平台通常将可视化设计的业务逻辑存储为 Meta 元数据，常见的形式有 JSON 和 XML。在服务器程序启动时，运行时会读取元数据，在内存中构建业务逻辑的执行路径，监听对应的端口，准备响应来自客户端的 HTTP 请求。\n\n#### 可视化设计\n\n在可视化设计层面，低代码平台通常会在“图”和“树”中选择一个实现方案。\n\n- **图**：使用流程图的形式描述业务逻辑的历史可以追溯到软件行业诞生之初。直到今天，依然有大量需求方采用 Microsoft Visio 等软件绘制业务处理流程图，并将其提交给开发方作为核心需求文件。所以，在低代码开发平台中提供类似于流程图的设计体验就成了部分低代码厂商的首选方案。在节点较少、判断和循环规则简单的应用场景中，这种开发体验产出的结果更直观，非常适合开发方与需求方基于该结果进行讨论和确认。采用该方案的典型产品有：Mendix、轻流\n- **树**：树是计算机中最常见的数据结构之一，也是高级语言在集成开发环境中的呈现方式：每一行可执行的语句都是一个叶子节点，而 if 等语句构成的代码块则是父节点。在编写代码时，程序员通过换行、缩进或花括号等符号来表达这种层次关系。执行时，语句会严格按照开发者的要求，从根节点向下，逐层、逐个遍历执行各个节点的语句。这种方式已经广泛应用于绝大多数高级语言中，充分证明了对不同应用场景的适应性。所以，致力于在现有软件开发工具的基础上进一步扩大可视化的覆盖范围，最终实现低代码的厂商，通常会选择树的方式构建业务逻辑设计体验。采用该方案的典型产品有：活字格、爱速搭\n\n两种方案没有优劣之分，图的方案更适合没受过专业编程训练的人学习和使用；树的方案对编码开发人员向低代码转型更友好。\n\n#### 用来描述业务处理逻辑的元数据\n\n首先，低代码平台会根据自身的能力边界和封装粒度，将用来承载业务逻辑的要件（也称业务能力）抽象成元数据定义，如数据库操作、判断、循环、文件处理、钉钉推送等。开发者在设计器上编排和操作对这些要件；设计器将这些要件的顺序、配置信息等保存为元数据；运行时通过加载这些元数据，还原出业务逻辑处理的规则和实现方式，并最终形成可执行的程序。\n\n![1749364849852NCzGbmsjxoreJoxDVqac9FwDnPg.png](https://gitee.com/tanke11223344/imagehost/raw/main/blog/1749364849852NCzGbmsjxoreJoxDVqac9FwDnPg.png)\n\n具体而言，低代码平台用来描述业务逻辑的元数据通常由若干有顺序的“操作”构成，每个操作中包含操作类型、配置参数、输入参数、输出参数等。如从向数据库中特定表插入数据的操作，在元数据中可描述为：\n\n```javascript\n{\n    \"$type\": \"Forguncy.Model.UpdateDataTableCommand, ServerDesignerCommon\",\n    \"TableName\": \"表名\",\n    \"UpdateType\": \"add\",\n    \"UpdateValues\": [\n        {\n            \"ColumnName\": \"字段名\",\n            \"Value\": \"=arg0\"\n        }\n    ],\n}\n```\n\n### 页面\n\n不同的低代码平台大多采用类似的技术原理，即使用 JSON/XML 格式的元数据描述前端组件的属性和页面布局。在设计体验上，低代码平台大多在固定布局和栅格布局两种方案中进行选择，少数低代码平台选择融合两者布局方案的网格布局（Grid Layout）。\n\n#### 从可执行代码到元数据\n\n页面设计的可视化与数据库可视化设计的历史类似，可以追溯到 1990 年代，随着 Visual Basic 的火热，传统编码开发领域涌现出了大量以拖拽的方式构建程序界面的开发工具。直至今日，很多开发者在提及可视化开发时，第一反应还是那个时代的 Visual Basic、Visual C++、PowerBuilder 等工具。这一阶段的页面设计以固定布局为主，开发者通过拖拽的方式摆放和配置页面元素，开发工具则根据这些信息自动生成可执行的程序代码，包含创建控件等页面元素、设置元素的位置、调整元素的样式等。在程序运行时，这些程序代码会被调用，逐步还原开发者的拖拽操作，最终展示出应用的界面。\n\n随着技术的进步，标记型语言和解释引擎的技术方案从 Web 页面走向更多终端。除了 Android 和 iOS 两个新的终端类型，Windows 上也出现了采用标记型语言设计页面的 WPF 技术，开发者拖拽生成后的页面，在编译时不再转义为顺序执行的程序语言，而是描述最终显示结果的标记型语言。同样是将可视化设计的结果转换为代码，标记型语言比顺序执行的代码语言更直观地展示页面中元素的层次和样式，开发工具需要处理的复杂度更低，可以给开发者开放更多能力，设计出更丰富的布局和样式，产出的质量也更加稳定；与之对应的代价则是相比于直接执行程序代码，通过解析引擎分析和展示标记型语言会带来额外的性能开销。在终端性能过剩的当下，程序代码方案的优势已经不在。在此背景下，诞生于 2010 年代以后的低代码开发平台绝大多数选择了生成标记型语言的技术方案，生成的格式主要为 XML 和 JSON。与上文中介绍的业务逻辑开发类似，界面交互开发也从生成程序代码走上了生成元数据的道路。\n\n#### 元数据，不只是 HTML\n\n绝大多数低代码开发平台都诞生于 2010 年之后，所以，元数据成了他们承载页面设计的不二之选。这导致了低代码平台在页面层的技术原理大同小异。与业务逻辑的可视化开发类似，低代码平台厂商为了帮助提升开发效率，也提供了大量前端交互组件，这些组件基于 HTML，但封装粒度更粗，如部分低代码平台将“表格”作为一个前端组件，开发者在设计器上为页面添加一个表格，就可以得到由大量 HTML 元素和 JavaScript 脚本实现的数据展示、分页、列头过滤器、Excel 数据复制粘贴等功能。这就意味着低代码平台需要定义一套与 HTML 不同的元数据标准，来描述这些封装好的组件。\n\n开发者在设计器中对这些组件进行的操作，会被设计器保存为页面元数据，包含元素的布局、样式、内容和行为；当页面被浏览器渲染时，低代码平台运行时提供的类库将加载这些元数据，在页面中完成绘制和交互，还原开发者在设计器中构建的页面。\n\n![1749364864091NuxxbmTVZouXHQxx3NAcSroVnwf.png](https://gitee.com/tanke11223344/imagehost/raw/main/blog/1749364864091NuxxbmTVZouXHQxx3NAcSroVnwf.png)\n\n## 平台分类\n\n### 按用户群体\n\n- **公民开发者平台**：面向业务分析师与项目经理，强调零代码特性，只需最少脚本即可完成常见应用。\n- **专业开发者平台**：提供丰富的 API 和 SDK，支持深度定制与集成，适合复杂企业级应用开发。\n\n### 按部署模式\n\n- **云端 SaaS**：如 Mendix、OutSystems 等，通过云服务模式提供开发与运维托管，便于快速上线与自动扩展。\n- **企业私有部署**：适用于对数据安全与合规要求较高的行业，可在本地或私有云中安装低代码平台。\n\n### 按技术栈\n\n- **Web 前端驱动**：大多数低代码平台以前端框架（如 React、Vue）为基础，生成富交互单页应用。\n- **后端无缝集成**：通过内置数据库模型和微服务框架，自动生成 REST/GraphQL 接口，同时支持与第三方系统（ERP、CRM）的接口联动。\n\n## 平台功能模块\n\n### 可视化开发\n\n- 拖拽式表单设计器、流程设计器和仪表盘构建器。\n- 实时预览功能，提交配置后可立即查看效果。\n\n### 数据与模型管理\n\n- 元数据建模：通过图形化或 DSL 定义实体、属性与关系。\n- 自动生成数据库表、API 接口和数据验证规则。\n\n### 业务流程引擎\n\n- 提供 BPEL/RBAC 流程引擎，支持审批流、定时任务与分支逻辑。\n- 支持多租户和权限精细化控制。\n\n### 部署与运维\n\n- 一键发布至测试、预生产与生产环境。\n- 集成 CI/CD、日志监控和性能分析，保障应用稳定运行。\n\n## 主流低代码平台对比\n\n> - [GitHub Star 数量前 15 的开源低代码项目 - NocoBase](https://www.nocobase.com/cn/blog/top-15-open-source-low-code-projects-with-the-most-github-Stars)\n\n## 发展趋势与挑战\n\n### 趋势\n\n1. **AI 辅助开发**：结合 GPT、Copilot 等技术，实现自动生成 UI 布局、业务逻辑建议与代码片段。\n2. **多端统一**：从单页面 Web、移动端到 IoT 设备，低代码平台趋向“一次设计，多端运行”。\n3. **行业化解决方案**：针对金融、制造、医疗等行业推出预置模板与符合行业规范的组件。\n\n### 挑战\n\n- **可维护性**：平台生成代码的可读性和扩展性常受质疑，需要专业团队保驾护航。\n- **安全与合规**：如何在自动化生成与迭代中保证代码质量与数据安全，是企业关注重点。\n- **供应商锁定**：低代码平台生态闭环，定制化开发后难以迁移，需谨慎评估供应商稳定性。\n\n---\n\n## 小结\n\n低代码平台通过可视化与元数据驱动技术，极大降低了应用开发门槛，加速了企业数字化转型。不同部署与技术栈的产品满足从公民开发者到专业开发团队的多样需求。未来，随着 AI 辅助与多端一体化的发展，低代码平台将更加智能与灵活，同时也需解决可维护性、安全与供应商锁定等挑战，才能持续赋能各行业的创新与效率提升。\n","source":"_posts/2025-06-04-低代码平台及相关技术介绍.md","raw":"---\ntitle:  2025-06-04-低代码平台及相关技术介绍应用\ndate: 2025-06-04\ntags: \n    课程学习\n---\n# 低代码平台及相关技术介绍\n\n# 参考资料\n\n> - [低代码平台的技术原理 - 低代码技术 - 葡萄城产品文档中心](https://www.grapecity.com.cn/lowcode/low-code-introduction/core-ability-tech-principle/lowcode-tech-principle)\n> - [从实现原理看低代码](https://zhuanlan.zhihu.com/p/451340998)\n> - [什么是低代码开发？| Mendix](https://www.mendix.com/zh-CN/%E4%BD%8E%E4%BB%A3%E7%A0%81%E6%8C%87%E5%8D%97/)\n\n# 核心概念与技术原理\n\n## 何为低代码平台\n\n低代码平台是一种可视化软件开发方法，提供拖拽式组件、模型驱动逻辑和少量脚本，旨在最小化手写代码的需求，加速应用交付。\n\n![1749364800087EByXb7hZeo5Eaxxa6V3ctMObnXh.png](https://gitee.com/tanke11223344/imagehost/raw/main/blog/1749364800087EByXb7hZeo5Eaxxa6V3ctMObnXh.png)\n\n低代码是高级语言开发技术发展到一定阶段的产物，以覆盖软件全生命周期的可视化为主要特征。其核心原理是将开发者的可视化设计保存为对应的元数据，通过解析元数据，形成可运行的软件。元数据通常隐藏在可视化开发环境和服务器运行时之下，低代码平台的使用者可不必关心其技术细节，能将更多精力聚焦在业务逻辑的实现和技术创新落地上。\n\n## 技术原理\n\n### 系统架构\n\n在系统架构上，低代码开发平台可以分为两层：设计器（开发环境）和服务器（运行时）。服务器通常表现为低代码平台定制的 Web 服务器。在设计器方面，部分厂商沿用传统开发的方式，提供桌面端设计器，部分厂商则将以 Web 页面的形式提供在线设计器。前者的优势在于无需联网和更强的性能；后者则大幅节省了开发环境的搭建时间。\n\n1. **元数据驱动**：平台通过元数据定义 UI 元素、数据模型和业务逻辑，运行时引擎根据这些元数据渲染应用界面与行为，无需手写模板或控制器。\n2. **可视化建模**：利用拖拽画布和属性面板，让用户通过图形化界面定义流程图、表单布局和数据关系，后台自动生成相应的代码或配置。\n3. **模块化扩展**：为满足复杂场景，平台通常支持以插件或脚本方式插入自定义逻辑，例如 JavaScript、Java、C# 等，可在可视化组件之外进行深度定制。\n4. **全生命周期管理**：集成需求管理、版本控制、测试与部署流水线，使低代码项目在从原型到生产的各个阶段均可监控与协作。\n\n#### 代码生成器\n\n早期的低代码开发平台大多采用代码生成器的技术方案。低代码平台将可视化操作直接翻译成对应的可执行语言（如 Java）。这种做法开发难度低，曾经一度成为低代码的主流。\n\n但随着应用的深入，人们发现这种方式存在封装程度低、开发效率提升有效、可维护性弱等技术问题。更重要的是，一旦开发者使用其他开发工具对这些编译后的源代码进行修改后，往往无法再同步回低代码开发平台的可视化开发环境，致使无法持续使用可视化的方式对应用进行开发和维护，让低代码平台成为了“一次性工具”。这显然违背了低代码开发平台的初衷。\n\n#### 元数据驱动\n\n目前主流的低代码平台已经从生成可直接执行的程序代码（如 Java、C#），逐步切换为生成特定格式的元数据（格式为 XML、JSON）。这些元数据无法脱离平台运行，就像 Java 无法脱离 JRE/JDK 一样。\n\n> 但 JSON 的优点就是它的缺点，因为它的用途是数据交换而不是人工编写，导致基于 JSON 构建 DSL 不方便编辑，会有以下 3 个问题：\n>\n> - 不支持注释\n> - 不支持多行字符串\n> - 语法过于严格，比如不支持单引号，不能在最后多写一个逗号\n\n在开发阶段，平台使用者（即开发者）通过设计器，可视化构建页面、业务逻辑和数据结构，设计器会将这些操作的结果以元数据的形式保存成中间文件（也称 Project、工程文件，通常由大量 json、xml 等描述性语言的文件打包而成）；部署阶段，开发者通过设计器将中间文件进行预处理（包含但不限于有效性检查、压缩、加密等），并打包发布到服务器上。而服务器则充当了运行时（Runtime）的角色，自动解析中间文件里的元数据，最终形成应用，提供给最终用户使用。这个过程可以类比于使用 Visual Studio（开发环境）开发 ASP.NET MVC 应用，编译成程序集后，发布到启用.NET 的 IIS（服务器），以 Web 应用的形式提供给用户使用。\n\n![1749364830851Ajn3b2WMhoFLOTx0aqAcyM6cn4d.png](https://gitee.com/tanke11223344/imagehost/raw/main/blog/1749364830851Ajn3b2WMhoFLOTx0aqAcyM6cn4d.png)\n\n借助元数据驱动的技术方案，平台厂商将更多能力封装成开发者能在可视化设计器中使用的元数据类型（也成平台元数据），持续扩大低代码平台的应用场景，提升使用者的开发效率。一定程度上讲，低代码内置平台元数据的覆盖范围，决定了该平台可视化开发的能力边界。\n\n### 数据库\n\n低代码平台的数据建模可分为表结构设计和查询视图设计两部分，使用者在界面上通过可视化的方式，构建出表结构和视图，而平台将其自动转义为对应数据库的 SQL 语句。目前，大多数模型驱动的低代码平台支持可视化的表结构设计，部分平台支持可视化设计查询视图。\n\n数据建模是可视化开发技术最早的应用场景之一，技术相对成熟。低代码厂商通常会借鉴主流数据库管理软件的操作体验。\n\n![1749364840875PNDfbej74oEUKQxkIZqcPJM8nkh.png](https://gitee.com/tanke11223344/imagehost/raw/main/blog/1749364840875PNDfbej74oEUKQxkIZqcPJM8nkh.png)\n\n#### 表结构\n\n表结构设计的可视化由来已久，从中大型的分布式数据库 Microsoft SQL Server，到小型的单机数据库 Access，都提供有可视化的结构设计和数据编辑能力。绝大多数低代码平台延续了这些数据库软件的做法，以 SQL 语句直接操作数据库，而省略了生成元数据和解析元数据的环节。开发者在设计器上对表结构进行的调整，被翻译成了对应的 SQL 语句，在数据库上执行。与此同时，设计器可以通过数据库提供的结构（Schema）查询能力，实时获取数据库中的表结构，并展示在设计器中。\n\n在此基础上，面向企业级应用开发的低代码平台则需要将不同厂商、不同版本的数据库设计能力进行统一化，以确保使用低代码开发的应用可以在数据层面和第三方软件无缝集成。这通常意味着低代码平台需要针对各种数据库分别开发数据结构和数据的存取机制，为开发者“抹平”数据库间在数据类型、查询操作等领域的差异。\n\n#### 表关联\n\n主流数据库通常推荐使用外键约束描述表与表的关联关系，如主从表、业务实体与主数据等。早期的低代码平台也将表关联关系直接翻译成了外键。但是，随着多源数据整合需求的增加，这种在数据库层面为多张表建立“硬链接”的方式，面临了无法建立跨数据库、跨数据源的表关联的挑战。所以，越来越多的 ORM（对象关系映射）框架开始将表关联从数据库提升到业务服务器中，即在业务服务器上，以元数据的形式记录表与表的关联关系。\n\n于是，部分低代码平台开始迎合这一趋势，在用户建立表关联的时候，设计器不再生成创建外键的 SQL 语句，而是在元数据中描述这一关联，并提供给设计器和运行时使用。如在设计器中可以直接绑定子表或主数据的字段，在运行时实现级联删除等。\n\n#### 查询视图\n\n查询视图可以在数据表的基础上封装常用的数据能力。相比于在业务逻辑层做数据处理，运行在数据库上的视图性能更高。视图中新增的字段主要有两种类型：基于当前行中其他字段的值进行计算得出的计算字段，以及基于外键关系，对子表进行统计计算得出的聚合字段。\n\n值得一提的是，为了降低开发者的工作量，部分低代码开发平台会将查询视图的设计能力整合到表结构设计中，当用户在表结构设计器中创建计算字段或聚合字段时，平台会为该表创建一个查询视图，用户设置的公式会被转义成视图中的查询语句。在业务逻辑层对该表进行查询操作时，平台会自动寻找对应的视图，让开发者可以像读取表中其他字段一样，查询计算字段或聚合字段的值。\n\n### WebAPI / 业务逻辑\n\n业务处理逻辑的可视化设计是低代码开发平台的技术难点之一。在传统编码开发中，可视化的应用范围通常不会涉及这一部分。所以，各低代码厂商在业务逻辑的可视化设计领域采用了不同的设计思想，为开发者提供了差异化的设计体验，同样实现了基于可视化设计的结果自动化生成代码的效果。低代码平台通常将可视化设计的业务逻辑存储为 Meta 元数据，常见的形式有 JSON 和 XML。在服务器程序启动时，运行时会读取元数据，在内存中构建业务逻辑的执行路径，监听对应的端口，准备响应来自客户端的 HTTP 请求。\n\n#### 可视化设计\n\n在可视化设计层面，低代码平台通常会在“图”和“树”中选择一个实现方案。\n\n- **图**：使用流程图的形式描述业务逻辑的历史可以追溯到软件行业诞生之初。直到今天，依然有大量需求方采用 Microsoft Visio 等软件绘制业务处理流程图，并将其提交给开发方作为核心需求文件。所以，在低代码开发平台中提供类似于流程图的设计体验就成了部分低代码厂商的首选方案。在节点较少、判断和循环规则简单的应用场景中，这种开发体验产出的结果更直观，非常适合开发方与需求方基于该结果进行讨论和确认。采用该方案的典型产品有：Mendix、轻流\n- **树**：树是计算机中最常见的数据结构之一，也是高级语言在集成开发环境中的呈现方式：每一行可执行的语句都是一个叶子节点，而 if 等语句构成的代码块则是父节点。在编写代码时，程序员通过换行、缩进或花括号等符号来表达这种层次关系。执行时，语句会严格按照开发者的要求，从根节点向下，逐层、逐个遍历执行各个节点的语句。这种方式已经广泛应用于绝大多数高级语言中，充分证明了对不同应用场景的适应性。所以，致力于在现有软件开发工具的基础上进一步扩大可视化的覆盖范围，最终实现低代码的厂商，通常会选择树的方式构建业务逻辑设计体验。采用该方案的典型产品有：活字格、爱速搭\n\n两种方案没有优劣之分，图的方案更适合没受过专业编程训练的人学习和使用；树的方案对编码开发人员向低代码转型更友好。\n\n#### 用来描述业务处理逻辑的元数据\n\n首先，低代码平台会根据自身的能力边界和封装粒度，将用来承载业务逻辑的要件（也称业务能力）抽象成元数据定义，如数据库操作、判断、循环、文件处理、钉钉推送等。开发者在设计器上编排和操作对这些要件；设计器将这些要件的顺序、配置信息等保存为元数据；运行时通过加载这些元数据，还原出业务逻辑处理的规则和实现方式，并最终形成可执行的程序。\n\n![1749364849852NCzGbmsjxoreJoxDVqac9FwDnPg.png](https://gitee.com/tanke11223344/imagehost/raw/main/blog/1749364849852NCzGbmsjxoreJoxDVqac9FwDnPg.png)\n\n具体而言，低代码平台用来描述业务逻辑的元数据通常由若干有顺序的“操作”构成，每个操作中包含操作类型、配置参数、输入参数、输出参数等。如从向数据库中特定表插入数据的操作，在元数据中可描述为：\n\n```javascript\n{\n    \"$type\": \"Forguncy.Model.UpdateDataTableCommand, ServerDesignerCommon\",\n    \"TableName\": \"表名\",\n    \"UpdateType\": \"add\",\n    \"UpdateValues\": [\n        {\n            \"ColumnName\": \"字段名\",\n            \"Value\": \"=arg0\"\n        }\n    ],\n}\n```\n\n### 页面\n\n不同的低代码平台大多采用类似的技术原理，即使用 JSON/XML 格式的元数据描述前端组件的属性和页面布局。在设计体验上，低代码平台大多在固定布局和栅格布局两种方案中进行选择，少数低代码平台选择融合两者布局方案的网格布局（Grid Layout）。\n\n#### 从可执行代码到元数据\n\n页面设计的可视化与数据库可视化设计的历史类似，可以追溯到 1990 年代，随着 Visual Basic 的火热，传统编码开发领域涌现出了大量以拖拽的方式构建程序界面的开发工具。直至今日，很多开发者在提及可视化开发时，第一反应还是那个时代的 Visual Basic、Visual C++、PowerBuilder 等工具。这一阶段的页面设计以固定布局为主，开发者通过拖拽的方式摆放和配置页面元素，开发工具则根据这些信息自动生成可执行的程序代码，包含创建控件等页面元素、设置元素的位置、调整元素的样式等。在程序运行时，这些程序代码会被调用，逐步还原开发者的拖拽操作，最终展示出应用的界面。\n\n随着技术的进步，标记型语言和解释引擎的技术方案从 Web 页面走向更多终端。除了 Android 和 iOS 两个新的终端类型，Windows 上也出现了采用标记型语言设计页面的 WPF 技术，开发者拖拽生成后的页面，在编译时不再转义为顺序执行的程序语言，而是描述最终显示结果的标记型语言。同样是将可视化设计的结果转换为代码，标记型语言比顺序执行的代码语言更直观地展示页面中元素的层次和样式，开发工具需要处理的复杂度更低，可以给开发者开放更多能力，设计出更丰富的布局和样式，产出的质量也更加稳定；与之对应的代价则是相比于直接执行程序代码，通过解析引擎分析和展示标记型语言会带来额外的性能开销。在终端性能过剩的当下，程序代码方案的优势已经不在。在此背景下，诞生于 2010 年代以后的低代码开发平台绝大多数选择了生成标记型语言的技术方案，生成的格式主要为 XML 和 JSON。与上文中介绍的业务逻辑开发类似，界面交互开发也从生成程序代码走上了生成元数据的道路。\n\n#### 元数据，不只是 HTML\n\n绝大多数低代码开发平台都诞生于 2010 年之后，所以，元数据成了他们承载页面设计的不二之选。这导致了低代码平台在页面层的技术原理大同小异。与业务逻辑的可视化开发类似，低代码平台厂商为了帮助提升开发效率，也提供了大量前端交互组件，这些组件基于 HTML，但封装粒度更粗，如部分低代码平台将“表格”作为一个前端组件，开发者在设计器上为页面添加一个表格，就可以得到由大量 HTML 元素和 JavaScript 脚本实现的数据展示、分页、列头过滤器、Excel 数据复制粘贴等功能。这就意味着低代码平台需要定义一套与 HTML 不同的元数据标准，来描述这些封装好的组件。\n\n开发者在设计器中对这些组件进行的操作，会被设计器保存为页面元数据，包含元素的布局、样式、内容和行为；当页面被浏览器渲染时，低代码平台运行时提供的类库将加载这些元数据，在页面中完成绘制和交互，还原开发者在设计器中构建的页面。\n\n![1749364864091NuxxbmTVZouXHQxx3NAcSroVnwf.png](https://gitee.com/tanke11223344/imagehost/raw/main/blog/1749364864091NuxxbmTVZouXHQxx3NAcSroVnwf.png)\n\n## 平台分类\n\n### 按用户群体\n\n- **公民开发者平台**：面向业务分析师与项目经理，强调零代码特性，只需最少脚本即可完成常见应用。\n- **专业开发者平台**：提供丰富的 API 和 SDK，支持深度定制与集成，适合复杂企业级应用开发。\n\n### 按部署模式\n\n- **云端 SaaS**：如 Mendix、OutSystems 等，通过云服务模式提供开发与运维托管，便于快速上线与自动扩展。\n- **企业私有部署**：适用于对数据安全与合规要求较高的行业，可在本地或私有云中安装低代码平台。\n\n### 按技术栈\n\n- **Web 前端驱动**：大多数低代码平台以前端框架（如 React、Vue）为基础，生成富交互单页应用。\n- **后端无缝集成**：通过内置数据库模型和微服务框架，自动生成 REST/GraphQL 接口，同时支持与第三方系统（ERP、CRM）的接口联动。\n\n## 平台功能模块\n\n### 可视化开发\n\n- 拖拽式表单设计器、流程设计器和仪表盘构建器。\n- 实时预览功能，提交配置后可立即查看效果。\n\n### 数据与模型管理\n\n- 元数据建模：通过图形化或 DSL 定义实体、属性与关系。\n- 自动生成数据库表、API 接口和数据验证规则。\n\n### 业务流程引擎\n\n- 提供 BPEL/RBAC 流程引擎，支持审批流、定时任务与分支逻辑。\n- 支持多租户和权限精细化控制。\n\n### 部署与运维\n\n- 一键发布至测试、预生产与生产环境。\n- 集成 CI/CD、日志监控和性能分析，保障应用稳定运行。\n\n## 主流低代码平台对比\n\n> - [GitHub Star 数量前 15 的开源低代码项目 - NocoBase](https://www.nocobase.com/cn/blog/top-15-open-source-low-code-projects-with-the-most-github-Stars)\n\n## 发展趋势与挑战\n\n### 趋势\n\n1. **AI 辅助开发**：结合 GPT、Copilot 等技术，实现自动生成 UI 布局、业务逻辑建议与代码片段。\n2. **多端统一**：从单页面 Web、移动端到 IoT 设备，低代码平台趋向“一次设计，多端运行”。\n3. **行业化解决方案**：针对金融、制造、医疗等行业推出预置模板与符合行业规范的组件。\n\n### 挑战\n\n- **可维护性**：平台生成代码的可读性和扩展性常受质疑，需要专业团队保驾护航。\n- **安全与合规**：如何在自动化生成与迭代中保证代码质量与数据安全，是企业关注重点。\n- **供应商锁定**：低代码平台生态闭环，定制化开发后难以迁移，需谨慎评估供应商稳定性。\n\n---\n\n## 小结\n\n低代码平台通过可视化与元数据驱动技术，极大降低了应用开发门槛，加速了企业数字化转型。不同部署与技术栈的产品满足从公民开发者到专业开发团队的多样需求。未来，随着 AI 辅助与多端一体化的发展，低代码平台将更加智能与灵活，同时也需解决可维护性、安全与供应商锁定等挑战，才能持续赋能各行业的创新与效率提升。\n","slug":"2025-06-04-低代码平台及相关技术介绍","published":1,"updated":"2025-09-26T12:18:15.241Z","_id":"cmg0saj4g002vjm8ndtvg7ye1","comments":1,"layout":"post","photos":[],"content":"<h1 id=\"低代码平台及相关技术介绍\"><a href=\"#低代码平台及相关技术介绍\" class=\"headerlink\" title=\"低代码平台及相关技术介绍\"></a>低代码平台及相关技术介绍</h1><h1 id=\"参考资料\"><a href=\"#参考资料\" class=\"headerlink\" title=\"参考资料\"></a>参考资料</h1><blockquote>\n<ul>\n<li><a href=\"https://www.grapecity.com.cn/lowcode/low-code-introduction/core-ability-tech-principle/lowcode-tech-principle\">低代码平台的技术原理 - 低代码技术 - 葡萄城产品文档中心</a></li>\n<li><a href=\"https://zhuanlan.zhihu.com/p/451340998\">从实现原理看低代码</a></li>\n<li><a href=\"https://www.mendix.com/zh-CN/%E4%BD%8E%E4%BB%A3%E7%A0%81%E6%8C%87%E5%8D%97/\">什么是低代码开发？| Mendix</a></li>\n</ul>\n</blockquote>\n<h1 id=\"核心概念与技术原理\"><a href=\"#核心概念与技术原理\" class=\"headerlink\" title=\"核心概念与技术原理\"></a>核心概念与技术原理</h1><h2 id=\"何为低代码平台\"><a href=\"#何为低代码平台\" class=\"headerlink\" title=\"何为低代码平台\"></a>何为低代码平台</h2><p>低代码平台是一种可视化软件开发方法，提供拖拽式组件、模型驱动逻辑和少量脚本，旨在最小化手写代码的需求，加速应用交付。</p>\n<p><img src=\"https://gitee.com/tanke11223344/imagehost/raw/main/blog/1749364800087EByXb7hZeo5Eaxxa6V3ctMObnXh.png\" alt=\"1749364800087EByXb7hZeo5Eaxxa6V3ctMObnXh.png\"></p>\n<p>低代码是高级语言开发技术发展到一定阶段的产物，以覆盖软件全生命周期的可视化为主要特征。其核心原理是将开发者的可视化设计保存为对应的元数据，通过解析元数据，形成可运行的软件。元数据通常隐藏在可视化开发环境和服务器运行时之下，低代码平台的使用者可不必关心其技术细节，能将更多精力聚焦在业务逻辑的实现和技术创新落地上。</p>\n<h2 id=\"技术原理\"><a href=\"#技术原理\" class=\"headerlink\" title=\"技术原理\"></a>技术原理</h2><h3 id=\"系统架构\"><a href=\"#系统架构\" class=\"headerlink\" title=\"系统架构\"></a>系统架构</h3><p>在系统架构上，低代码开发平台可以分为两层：设计器（开发环境）和服务器（运行时）。服务器通常表现为低代码平台定制的 Web 服务器。在设计器方面，部分厂商沿用传统开发的方式，提供桌面端设计器，部分厂商则将以 Web 页面的形式提供在线设计器。前者的优势在于无需联网和更强的性能；后者则大幅节省了开发环境的搭建时间。</p>\n<ol>\n<li><strong>元数据驱动</strong>：平台通过元数据定义 UI 元素、数据模型和业务逻辑，运行时引擎根据这些元数据渲染应用界面与行为，无需手写模板或控制器。</li>\n<li><strong>可视化建模</strong>：利用拖拽画布和属性面板，让用户通过图形化界面定义流程图、表单布局和数据关系，后台自动生成相应的代码或配置。</li>\n<li><strong>模块化扩展</strong>：为满足复杂场景，平台通常支持以插件或脚本方式插入自定义逻辑，例如 JavaScript、Java、C# 等，可在可视化组件之外进行深度定制。</li>\n<li><strong>全生命周期管理</strong>：集成需求管理、版本控制、测试与部署流水线，使低代码项目在从原型到生产的各个阶段均可监控与协作。</li>\n</ol>\n<h4 id=\"代码生成器\"><a href=\"#代码生成器\" class=\"headerlink\" title=\"代码生成器\"></a>代码生成器</h4><p>早期的低代码开发平台大多采用代码生成器的技术方案。低代码平台将可视化操作直接翻译成对应的可执行语言（如 Java）。这种做法开发难度低，曾经一度成为低代码的主流。</p>\n<p>但随着应用的深入，人们发现这种方式存在封装程度低、开发效率提升有效、可维护性弱等技术问题。更重要的是，一旦开发者使用其他开发工具对这些编译后的源代码进行修改后，往往无法再同步回低代码开发平台的可视化开发环境，致使无法持续使用可视化的方式对应用进行开发和维护，让低代码平台成为了“一次性工具”。这显然违背了低代码开发平台的初衷。</p>\n<h4 id=\"元数据驱动\"><a href=\"#元数据驱动\" class=\"headerlink\" title=\"元数据驱动\"></a>元数据驱动</h4><p>目前主流的低代码平台已经从生成可直接执行的程序代码（如 Java、C#），逐步切换为生成特定格式的元数据（格式为 XML、JSON）。这些元数据无法脱离平台运行，就像 Java 无法脱离 JRE&#x2F;JDK 一样。</p>\n<blockquote>\n<p>但 JSON 的优点就是它的缺点，因为它的用途是数据交换而不是人工编写，导致基于 JSON 构建 DSL 不方便编辑，会有以下 3 个问题：</p>\n<ul>\n<li>不支持注释</li>\n<li>不支持多行字符串</li>\n<li>语法过于严格，比如不支持单引号，不能在最后多写一个逗号</li>\n</ul>\n</blockquote>\n<p>在开发阶段，平台使用者（即开发者）通过设计器，可视化构建页面、业务逻辑和数据结构，设计器会将这些操作的结果以元数据的形式保存成中间文件（也称 Project、工程文件，通常由大量 json、xml 等描述性语言的文件打包而成）；部署阶段，开发者通过设计器将中间文件进行预处理（包含但不限于有效性检查、压缩、加密等），并打包发布到服务器上。而服务器则充当了运行时（Runtime）的角色，自动解析中间文件里的元数据，最终形成应用，提供给最终用户使用。这个过程可以类比于使用 Visual Studio（开发环境）开发 ASP.NET MVC 应用，编译成程序集后，发布到启用.NET 的 IIS（服务器），以 Web 应用的形式提供给用户使用。</p>\n<p><img src=\"https://gitee.com/tanke11223344/imagehost/raw/main/blog/1749364830851Ajn3b2WMhoFLOTx0aqAcyM6cn4d.png\" alt=\"1749364830851Ajn3b2WMhoFLOTx0aqAcyM6cn4d.png\"></p>\n<p>借助元数据驱动的技术方案，平台厂商将更多能力封装成开发者能在可视化设计器中使用的元数据类型（也成平台元数据），持续扩大低代码平台的应用场景，提升使用者的开发效率。一定程度上讲，低代码内置平台元数据的覆盖范围，决定了该平台可视化开发的能力边界。</p>\n<h3 id=\"数据库\"><a href=\"#数据库\" class=\"headerlink\" title=\"数据库\"></a>数据库</h3><p>低代码平台的数据建模可分为表结构设计和查询视图设计两部分，使用者在界面上通过可视化的方式，构建出表结构和视图，而平台将其自动转义为对应数据库的 SQL 语句。目前，大多数模型驱动的低代码平台支持可视化的表结构设计，部分平台支持可视化设计查询视图。</p>\n<p>数据建模是可视化开发技术最早的应用场景之一，技术相对成熟。低代码厂商通常会借鉴主流数据库管理软件的操作体验。</p>\n<p><img src=\"https://gitee.com/tanke11223344/imagehost/raw/main/blog/1749364840875PNDfbej74oEUKQxkIZqcPJM8nkh.png\" alt=\"1749364840875PNDfbej74oEUKQxkIZqcPJM8nkh.png\"></p>\n<h4 id=\"表结构\"><a href=\"#表结构\" class=\"headerlink\" title=\"表结构\"></a>表结构</h4><p>表结构设计的可视化由来已久，从中大型的分布式数据库 Microsoft SQL Server，到小型的单机数据库 Access，都提供有可视化的结构设计和数据编辑能力。绝大多数低代码平台延续了这些数据库软件的做法，以 SQL 语句直接操作数据库，而省略了生成元数据和解析元数据的环节。开发者在设计器上对表结构进行的调整，被翻译成了对应的 SQL 语句，在数据库上执行。与此同时，设计器可以通过数据库提供的结构（Schema）查询能力，实时获取数据库中的表结构，并展示在设计器中。</p>\n<p>在此基础上，面向企业级应用开发的低代码平台则需要将不同厂商、不同版本的数据库设计能力进行统一化，以确保使用低代码开发的应用可以在数据层面和第三方软件无缝集成。这通常意味着低代码平台需要针对各种数据库分别开发数据结构和数据的存取机制，为开发者“抹平”数据库间在数据类型、查询操作等领域的差异。</p>\n<h4 id=\"表关联\"><a href=\"#表关联\" class=\"headerlink\" title=\"表关联\"></a>表关联</h4><p>主流数据库通常推荐使用外键约束描述表与表的关联关系，如主从表、业务实体与主数据等。早期的低代码平台也将表关联关系直接翻译成了外键。但是，随着多源数据整合需求的增加，这种在数据库层面为多张表建立“硬链接”的方式，面临了无法建立跨数据库、跨数据源的表关联的挑战。所以，越来越多的 ORM（对象关系映射）框架开始将表关联从数据库提升到业务服务器中，即在业务服务器上，以元数据的形式记录表与表的关联关系。</p>\n<p>于是，部分低代码平台开始迎合这一趋势，在用户建立表关联的时候，设计器不再生成创建外键的 SQL 语句，而是在元数据中描述这一关联，并提供给设计器和运行时使用。如在设计器中可以直接绑定子表或主数据的字段，在运行时实现级联删除等。</p>\n<h4 id=\"查询视图\"><a href=\"#查询视图\" class=\"headerlink\" title=\"查询视图\"></a>查询视图</h4><p>查询视图可以在数据表的基础上封装常用的数据能力。相比于在业务逻辑层做数据处理，运行在数据库上的视图性能更高。视图中新增的字段主要有两种类型：基于当前行中其他字段的值进行计算得出的计算字段，以及基于外键关系，对子表进行统计计算得出的聚合字段。</p>\n<p>值得一提的是，为了降低开发者的工作量，部分低代码开发平台会将查询视图的设计能力整合到表结构设计中，当用户在表结构设计器中创建计算字段或聚合字段时，平台会为该表创建一个查询视图，用户设置的公式会被转义成视图中的查询语句。在业务逻辑层对该表进行查询操作时，平台会自动寻找对应的视图，让开发者可以像读取表中其他字段一样，查询计算字段或聚合字段的值。</p>\n<h3 id=\"WebAPI-业务逻辑\"><a href=\"#WebAPI-业务逻辑\" class=\"headerlink\" title=\"WebAPI &#x2F; 业务逻辑\"></a>WebAPI &#x2F; 业务逻辑</h3><p>业务处理逻辑的可视化设计是低代码开发平台的技术难点之一。在传统编码开发中，可视化的应用范围通常不会涉及这一部分。所以，各低代码厂商在业务逻辑的可视化设计领域采用了不同的设计思想，为开发者提供了差异化的设计体验，同样实现了基于可视化设计的结果自动化生成代码的效果。低代码平台通常将可视化设计的业务逻辑存储为 Meta 元数据，常见的形式有 JSON 和 XML。在服务器程序启动时，运行时会读取元数据，在内存中构建业务逻辑的执行路径，监听对应的端口，准备响应来自客户端的 HTTP 请求。</p>\n<h4 id=\"可视化设计\"><a href=\"#可视化设计\" class=\"headerlink\" title=\"可视化设计\"></a>可视化设计</h4><p>在可视化设计层面，低代码平台通常会在“图”和“树”中选择一个实现方案。</p>\n<ul>\n<li><strong>图</strong>：使用流程图的形式描述业务逻辑的历史可以追溯到软件行业诞生之初。直到今天，依然有大量需求方采用 Microsoft Visio 等软件绘制业务处理流程图，并将其提交给开发方作为核心需求文件。所以，在低代码开发平台中提供类似于流程图的设计体验就成了部分低代码厂商的首选方案。在节点较少、判断和循环规则简单的应用场景中，这种开发体验产出的结果更直观，非常适合开发方与需求方基于该结果进行讨论和确认。采用该方案的典型产品有：Mendix、轻流</li>\n<li><strong>树</strong>：树是计算机中最常见的数据结构之一，也是高级语言在集成开发环境中的呈现方式：每一行可执行的语句都是一个叶子节点，而 if 等语句构成的代码块则是父节点。在编写代码时，程序员通过换行、缩进或花括号等符号来表达这种层次关系。执行时，语句会严格按照开发者的要求，从根节点向下，逐层、逐个遍历执行各个节点的语句。这种方式已经广泛应用于绝大多数高级语言中，充分证明了对不同应用场景的适应性。所以，致力于在现有软件开发工具的基础上进一步扩大可视化的覆盖范围，最终实现低代码的厂商，通常会选择树的方式构建业务逻辑设计体验。采用该方案的典型产品有：活字格、爱速搭</li>\n</ul>\n<p>两种方案没有优劣之分，图的方案更适合没受过专业编程训练的人学习和使用；树的方案对编码开发人员向低代码转型更友好。</p>\n<h4 id=\"用来描述业务处理逻辑的元数据\"><a href=\"#用来描述业务处理逻辑的元数据\" class=\"headerlink\" title=\"用来描述业务处理逻辑的元数据\"></a>用来描述业务处理逻辑的元数据</h4><p>首先，低代码平台会根据自身的能力边界和封装粒度，将用来承载业务逻辑的要件（也称业务能力）抽象成元数据定义，如数据库操作、判断、循环、文件处理、钉钉推送等。开发者在设计器上编排和操作对这些要件；设计器将这些要件的顺序、配置信息等保存为元数据；运行时通过加载这些元数据，还原出业务逻辑处理的规则和实现方式，并最终形成可执行的程序。</p>\n<p><img src=\"https://gitee.com/tanke11223344/imagehost/raw/main/blog/1749364849852NCzGbmsjxoreJoxDVqac9FwDnPg.png\" alt=\"1749364849852NCzGbmsjxoreJoxDVqac9FwDnPg.png\"></p>\n<p>具体而言，低代码平台用来描述业务逻辑的元数据通常由若干有顺序的“操作”构成，每个操作中包含操作类型、配置参数、输入参数、输出参数等。如从向数据库中特定表插入数据的操作，在元数据中可描述为：</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">&#123;</span><br><span class=\"line\">    <span class=\"string\">&quot;$type&quot;</span>: <span class=\"string\">&quot;Forguncy.Model.UpdateDataTableCommand, ServerDesignerCommon&quot;</span>,</span><br><span class=\"line\">    <span class=\"string\">&quot;TableName&quot;</span>: <span class=\"string\">&quot;表名&quot;</span>,</span><br><span class=\"line\">    <span class=\"string\">&quot;UpdateType&quot;</span>: <span class=\"string\">&quot;add&quot;</span>,</span><br><span class=\"line\">    <span class=\"string\">&quot;UpdateValues&quot;</span>: [</span><br><span class=\"line\">        &#123;</span><br><span class=\"line\">            <span class=\"string\">&quot;ColumnName&quot;</span>: <span class=\"string\">&quot;字段名&quot;</span>,</span><br><span class=\"line\">            <span class=\"string\">&quot;Value&quot;</span>: <span class=\"string\">&quot;=arg0&quot;</span></span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    ],</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<h3 id=\"页面\"><a href=\"#页面\" class=\"headerlink\" title=\"页面\"></a>页面</h3><p>不同的低代码平台大多采用类似的技术原理，即使用 JSON&#x2F;XML 格式的元数据描述前端组件的属性和页面布局。在设计体验上，低代码平台大多在固定布局和栅格布局两种方案中进行选择，少数低代码平台选择融合两者布局方案的网格布局（Grid Layout）。</p>\n<h4 id=\"从可执行代码到元数据\"><a href=\"#从可执行代码到元数据\" class=\"headerlink\" title=\"从可执行代码到元数据\"></a>从可执行代码到元数据</h4><p>页面设计的可视化与数据库可视化设计的历史类似，可以追溯到 1990 年代，随着 Visual Basic 的火热，传统编码开发领域涌现出了大量以拖拽的方式构建程序界面的开发工具。直至今日，很多开发者在提及可视化开发时，第一反应还是那个时代的 Visual Basic、Visual C++、PowerBuilder 等工具。这一阶段的页面设计以固定布局为主，开发者通过拖拽的方式摆放和配置页面元素，开发工具则根据这些信息自动生成可执行的程序代码，包含创建控件等页面元素、设置元素的位置、调整元素的样式等。在程序运行时，这些程序代码会被调用，逐步还原开发者的拖拽操作，最终展示出应用的界面。</p>\n<p>随着技术的进步，标记型语言和解释引擎的技术方案从 Web 页面走向更多终端。除了 Android 和 iOS 两个新的终端类型，Windows 上也出现了采用标记型语言设计页面的 WPF 技术，开发者拖拽生成后的页面，在编译时不再转义为顺序执行的程序语言，而是描述最终显示结果的标记型语言。同样是将可视化设计的结果转换为代码，标记型语言比顺序执行的代码语言更直观地展示页面中元素的层次和样式，开发工具需要处理的复杂度更低，可以给开发者开放更多能力，设计出更丰富的布局和样式，产出的质量也更加稳定；与之对应的代价则是相比于直接执行程序代码，通过解析引擎分析和展示标记型语言会带来额外的性能开销。在终端性能过剩的当下，程序代码方案的优势已经不在。在此背景下，诞生于 2010 年代以后的低代码开发平台绝大多数选择了生成标记型语言的技术方案，生成的格式主要为 XML 和 JSON。与上文中介绍的业务逻辑开发类似，界面交互开发也从生成程序代码走上了生成元数据的道路。</p>\n<h4 id=\"元数据，不只是-HTML\"><a href=\"#元数据，不只是-HTML\" class=\"headerlink\" title=\"元数据，不只是 HTML\"></a>元数据，不只是 HTML</h4><p>绝大多数低代码开发平台都诞生于 2010 年之后，所以，元数据成了他们承载页面设计的不二之选。这导致了低代码平台在页面层的技术原理大同小异。与业务逻辑的可视化开发类似，低代码平台厂商为了帮助提升开发效率，也提供了大量前端交互组件，这些组件基于 HTML，但封装粒度更粗，如部分低代码平台将“表格”作为一个前端组件，开发者在设计器上为页面添加一个表格，就可以得到由大量 HTML 元素和 JavaScript 脚本实现的数据展示、分页、列头过滤器、Excel 数据复制粘贴等功能。这就意味着低代码平台需要定义一套与 HTML 不同的元数据标准，来描述这些封装好的组件。</p>\n<p>开发者在设计器中对这些组件进行的操作，会被设计器保存为页面元数据，包含元素的布局、样式、内容和行为；当页面被浏览器渲染时，低代码平台运行时提供的类库将加载这些元数据，在页面中完成绘制和交互，还原开发者在设计器中构建的页面。</p>\n<p><img src=\"https://gitee.com/tanke11223344/imagehost/raw/main/blog/1749364864091NuxxbmTVZouXHQxx3NAcSroVnwf.png\" alt=\"1749364864091NuxxbmTVZouXHQxx3NAcSroVnwf.png\"></p>\n<h2 id=\"平台分类\"><a href=\"#平台分类\" class=\"headerlink\" title=\"平台分类\"></a>平台分类</h2><h3 id=\"按用户群体\"><a href=\"#按用户群体\" class=\"headerlink\" title=\"按用户群体\"></a>按用户群体</h3><ul>\n<li><strong>公民开发者平台</strong>：面向业务分析师与项目经理，强调零代码特性，只需最少脚本即可完成常见应用。</li>\n<li><strong>专业开发者平台</strong>：提供丰富的 API 和 SDK，支持深度定制与集成，适合复杂企业级应用开发。</li>\n</ul>\n<h3 id=\"按部署模式\"><a href=\"#按部署模式\" class=\"headerlink\" title=\"按部署模式\"></a>按部署模式</h3><ul>\n<li><strong>云端 SaaS</strong>：如 Mendix、OutSystems 等，通过云服务模式提供开发与运维托管，便于快速上线与自动扩展。</li>\n<li><strong>企业私有部署</strong>：适用于对数据安全与合规要求较高的行业，可在本地或私有云中安装低代码平台。</li>\n</ul>\n<h3 id=\"按技术栈\"><a href=\"#按技术栈\" class=\"headerlink\" title=\"按技术栈\"></a>按技术栈</h3><ul>\n<li><strong>Web 前端驱动</strong>：大多数低代码平台以前端框架（如 React、Vue）为基础，生成富交互单页应用。</li>\n<li><strong>后端无缝集成</strong>：通过内置数据库模型和微服务框架，自动生成 REST&#x2F;GraphQL 接口，同时支持与第三方系统（ERP、CRM）的接口联动。</li>\n</ul>\n<h2 id=\"平台功能模块\"><a href=\"#平台功能模块\" class=\"headerlink\" title=\"平台功能模块\"></a>平台功能模块</h2><h3 id=\"可视化开发\"><a href=\"#可视化开发\" class=\"headerlink\" title=\"可视化开发\"></a>可视化开发</h3><ul>\n<li>拖拽式表单设计器、流程设计器和仪表盘构建器。</li>\n<li>实时预览功能，提交配置后可立即查看效果。</li>\n</ul>\n<h3 id=\"数据与模型管理\"><a href=\"#数据与模型管理\" class=\"headerlink\" title=\"数据与模型管理\"></a>数据与模型管理</h3><ul>\n<li>元数据建模：通过图形化或 DSL 定义实体、属性与关系。</li>\n<li>自动生成数据库表、API 接口和数据验证规则。</li>\n</ul>\n<h3 id=\"业务流程引擎\"><a href=\"#业务流程引擎\" class=\"headerlink\" title=\"业务流程引擎\"></a>业务流程引擎</h3><ul>\n<li>提供 BPEL&#x2F;RBAC 流程引擎，支持审批流、定时任务与分支逻辑。</li>\n<li>支持多租户和权限精细化控制。</li>\n</ul>\n<h3 id=\"部署与运维\"><a href=\"#部署与运维\" class=\"headerlink\" title=\"部署与运维\"></a>部署与运维</h3><ul>\n<li>一键发布至测试、预生产与生产环境。</li>\n<li>集成 CI&#x2F;CD、日志监控和性能分析，保障应用稳定运行。</li>\n</ul>\n<h2 id=\"主流低代码平台对比\"><a href=\"#主流低代码平台对比\" class=\"headerlink\" title=\"主流低代码平台对比\"></a>主流低代码平台对比</h2><blockquote>\n<ul>\n<li><a href=\"https://www.nocobase.com/cn/blog/top-15-open-source-low-code-projects-with-the-most-github-Stars\">GitHub Star 数量前 15 的开源低代码项目 - NocoBase</a></li>\n</ul>\n</blockquote>\n<h2 id=\"发展趋势与挑战\"><a href=\"#发展趋势与挑战\" class=\"headerlink\" title=\"发展趋势与挑战\"></a>发展趋势与挑战</h2><h3 id=\"趋势\"><a href=\"#趋势\" class=\"headerlink\" title=\"趋势\"></a>趋势</h3><ol>\n<li><strong>AI 辅助开发</strong>：结合 GPT、Copilot 等技术，实现自动生成 UI 布局、业务逻辑建议与代码片段。</li>\n<li><strong>多端统一</strong>：从单页面 Web、移动端到 IoT 设备，低代码平台趋向“一次设计，多端运行”。</li>\n<li><strong>行业化解决方案</strong>：针对金融、制造、医疗等行业推出预置模板与符合行业规范的组件。</li>\n</ol>\n<h3 id=\"挑战\"><a href=\"#挑战\" class=\"headerlink\" title=\"挑战\"></a>挑战</h3><ul>\n<li><strong>可维护性</strong>：平台生成代码的可读性和扩展性常受质疑，需要专业团队保驾护航。</li>\n<li><strong>安全与合规</strong>：如何在自动化生成与迭代中保证代码质量与数据安全，是企业关注重点。</li>\n<li><strong>供应商锁定</strong>：低代码平台生态闭环，定制化开发后难以迁移，需谨慎评估供应商稳定性。</li>\n</ul>\n<hr>\n<h2 id=\"小结\"><a href=\"#小结\" class=\"headerlink\" title=\"小结\"></a>小结</h2><p>低代码平台通过可视化与元数据驱动技术，极大降低了应用开发门槛，加速了企业数字化转型。不同部署与技术栈的产品满足从公民开发者到专业开发团队的多样需求。未来，随着 AI 辅助与多端一体化的发展，低代码平台将更加智能与灵活，同时也需解决可维护性、安全与供应商锁定等挑战，才能持续赋能各行业的创新与效率提升。</p>\n","excerpt":"","more":"<h1 id=\"低代码平台及相关技术介绍\"><a href=\"#低代码平台及相关技术介绍\" class=\"headerlink\" title=\"低代码平台及相关技术介绍\"></a>低代码平台及相关技术介绍</h1><h1 id=\"参考资料\"><a href=\"#参考资料\" class=\"headerlink\" title=\"参考资料\"></a>参考资料</h1><blockquote>\n<ul>\n<li><a href=\"https://www.grapecity.com.cn/lowcode/low-code-introduction/core-ability-tech-principle/lowcode-tech-principle\">低代码平台的技术原理 - 低代码技术 - 葡萄城产品文档中心</a></li>\n<li><a href=\"https://zhuanlan.zhihu.com/p/451340998\">从实现原理看低代码</a></li>\n<li><a href=\"https://www.mendix.com/zh-CN/%E4%BD%8E%E4%BB%A3%E7%A0%81%E6%8C%87%E5%8D%97/\">什么是低代码开发？| Mendix</a></li>\n</ul>\n</blockquote>\n<h1 id=\"核心概念与技术原理\"><a href=\"#核心概念与技术原理\" class=\"headerlink\" title=\"核心概念与技术原理\"></a>核心概念与技术原理</h1><h2 id=\"何为低代码平台\"><a href=\"#何为低代码平台\" class=\"headerlink\" title=\"何为低代码平台\"></a>何为低代码平台</h2><p>低代码平台是一种可视化软件开发方法，提供拖拽式组件、模型驱动逻辑和少量脚本，旨在最小化手写代码的需求，加速应用交付。</p>\n<p><img src=\"https://gitee.com/tanke11223344/imagehost/raw/main/blog/1749364800087EByXb7hZeo5Eaxxa6V3ctMObnXh.png\" alt=\"1749364800087EByXb7hZeo5Eaxxa6V3ctMObnXh.png\"></p>\n<p>低代码是高级语言开发技术发展到一定阶段的产物，以覆盖软件全生命周期的可视化为主要特征。其核心原理是将开发者的可视化设计保存为对应的元数据，通过解析元数据，形成可运行的软件。元数据通常隐藏在可视化开发环境和服务器运行时之下，低代码平台的使用者可不必关心其技术细节，能将更多精力聚焦在业务逻辑的实现和技术创新落地上。</p>\n<h2 id=\"技术原理\"><a href=\"#技术原理\" class=\"headerlink\" title=\"技术原理\"></a>技术原理</h2><h3 id=\"系统架构\"><a href=\"#系统架构\" class=\"headerlink\" title=\"系统架构\"></a>系统架构</h3><p>在系统架构上，低代码开发平台可以分为两层：设计器（开发环境）和服务器（运行时）。服务器通常表现为低代码平台定制的 Web 服务器。在设计器方面，部分厂商沿用传统开发的方式，提供桌面端设计器，部分厂商则将以 Web 页面的形式提供在线设计器。前者的优势在于无需联网和更强的性能；后者则大幅节省了开发环境的搭建时间。</p>\n<ol>\n<li><strong>元数据驱动</strong>：平台通过元数据定义 UI 元素、数据模型和业务逻辑，运行时引擎根据这些元数据渲染应用界面与行为，无需手写模板或控制器。</li>\n<li><strong>可视化建模</strong>：利用拖拽画布和属性面板，让用户通过图形化界面定义流程图、表单布局和数据关系，后台自动生成相应的代码或配置。</li>\n<li><strong>模块化扩展</strong>：为满足复杂场景，平台通常支持以插件或脚本方式插入自定义逻辑，例如 JavaScript、Java、C# 等，可在可视化组件之外进行深度定制。</li>\n<li><strong>全生命周期管理</strong>：集成需求管理、版本控制、测试与部署流水线，使低代码项目在从原型到生产的各个阶段均可监控与协作。</li>\n</ol>\n<h4 id=\"代码生成器\"><a href=\"#代码生成器\" class=\"headerlink\" title=\"代码生成器\"></a>代码生成器</h4><p>早期的低代码开发平台大多采用代码生成器的技术方案。低代码平台将可视化操作直接翻译成对应的可执行语言（如 Java）。这种做法开发难度低，曾经一度成为低代码的主流。</p>\n<p>但随着应用的深入，人们发现这种方式存在封装程度低、开发效率提升有效、可维护性弱等技术问题。更重要的是，一旦开发者使用其他开发工具对这些编译后的源代码进行修改后，往往无法再同步回低代码开发平台的可视化开发环境，致使无法持续使用可视化的方式对应用进行开发和维护，让低代码平台成为了“一次性工具”。这显然违背了低代码开发平台的初衷。</p>\n<h4 id=\"元数据驱动\"><a href=\"#元数据驱动\" class=\"headerlink\" title=\"元数据驱动\"></a>元数据驱动</h4><p>目前主流的低代码平台已经从生成可直接执行的程序代码（如 Java、C#），逐步切换为生成特定格式的元数据（格式为 XML、JSON）。这些元数据无法脱离平台运行，就像 Java 无法脱离 JRE&#x2F;JDK 一样。</p>\n<blockquote>\n<p>但 JSON 的优点就是它的缺点，因为它的用途是数据交换而不是人工编写，导致基于 JSON 构建 DSL 不方便编辑，会有以下 3 个问题：</p>\n<ul>\n<li>不支持注释</li>\n<li>不支持多行字符串</li>\n<li>语法过于严格，比如不支持单引号，不能在最后多写一个逗号</li>\n</ul>\n</blockquote>\n<p>在开发阶段，平台使用者（即开发者）通过设计器，可视化构建页面、业务逻辑和数据结构，设计器会将这些操作的结果以元数据的形式保存成中间文件（也称 Project、工程文件，通常由大量 json、xml 等描述性语言的文件打包而成）；部署阶段，开发者通过设计器将中间文件进行预处理（包含但不限于有效性检查、压缩、加密等），并打包发布到服务器上。而服务器则充当了运行时（Runtime）的角色，自动解析中间文件里的元数据，最终形成应用，提供给最终用户使用。这个过程可以类比于使用 Visual Studio（开发环境）开发 ASP.NET MVC 应用，编译成程序集后，发布到启用.NET 的 IIS（服务器），以 Web 应用的形式提供给用户使用。</p>\n<p><img src=\"https://gitee.com/tanke11223344/imagehost/raw/main/blog/1749364830851Ajn3b2WMhoFLOTx0aqAcyM6cn4d.png\" alt=\"1749364830851Ajn3b2WMhoFLOTx0aqAcyM6cn4d.png\"></p>\n<p>借助元数据驱动的技术方案，平台厂商将更多能力封装成开发者能在可视化设计器中使用的元数据类型（也成平台元数据），持续扩大低代码平台的应用场景，提升使用者的开发效率。一定程度上讲，低代码内置平台元数据的覆盖范围，决定了该平台可视化开发的能力边界。</p>\n<h3 id=\"数据库\"><a href=\"#数据库\" class=\"headerlink\" title=\"数据库\"></a>数据库</h3><p>低代码平台的数据建模可分为表结构设计和查询视图设计两部分，使用者在界面上通过可视化的方式，构建出表结构和视图，而平台将其自动转义为对应数据库的 SQL 语句。目前，大多数模型驱动的低代码平台支持可视化的表结构设计，部分平台支持可视化设计查询视图。</p>\n<p>数据建模是可视化开发技术最早的应用场景之一，技术相对成熟。低代码厂商通常会借鉴主流数据库管理软件的操作体验。</p>\n<p><img src=\"https://gitee.com/tanke11223344/imagehost/raw/main/blog/1749364840875PNDfbej74oEUKQxkIZqcPJM8nkh.png\" alt=\"1749364840875PNDfbej74oEUKQxkIZqcPJM8nkh.png\"></p>\n<h4 id=\"表结构\"><a href=\"#表结构\" class=\"headerlink\" title=\"表结构\"></a>表结构</h4><p>表结构设计的可视化由来已久，从中大型的分布式数据库 Microsoft SQL Server，到小型的单机数据库 Access，都提供有可视化的结构设计和数据编辑能力。绝大多数低代码平台延续了这些数据库软件的做法，以 SQL 语句直接操作数据库，而省略了生成元数据和解析元数据的环节。开发者在设计器上对表结构进行的调整，被翻译成了对应的 SQL 语句，在数据库上执行。与此同时，设计器可以通过数据库提供的结构（Schema）查询能力，实时获取数据库中的表结构，并展示在设计器中。</p>\n<p>在此基础上，面向企业级应用开发的低代码平台则需要将不同厂商、不同版本的数据库设计能力进行统一化，以确保使用低代码开发的应用可以在数据层面和第三方软件无缝集成。这通常意味着低代码平台需要针对各种数据库分别开发数据结构和数据的存取机制，为开发者“抹平”数据库间在数据类型、查询操作等领域的差异。</p>\n<h4 id=\"表关联\"><a href=\"#表关联\" class=\"headerlink\" title=\"表关联\"></a>表关联</h4><p>主流数据库通常推荐使用外键约束描述表与表的关联关系，如主从表、业务实体与主数据等。早期的低代码平台也将表关联关系直接翻译成了外键。但是，随着多源数据整合需求的增加，这种在数据库层面为多张表建立“硬链接”的方式，面临了无法建立跨数据库、跨数据源的表关联的挑战。所以，越来越多的 ORM（对象关系映射）框架开始将表关联从数据库提升到业务服务器中，即在业务服务器上，以元数据的形式记录表与表的关联关系。</p>\n<p>于是，部分低代码平台开始迎合这一趋势，在用户建立表关联的时候，设计器不再生成创建外键的 SQL 语句，而是在元数据中描述这一关联，并提供给设计器和运行时使用。如在设计器中可以直接绑定子表或主数据的字段，在运行时实现级联删除等。</p>\n<h4 id=\"查询视图\"><a href=\"#查询视图\" class=\"headerlink\" title=\"查询视图\"></a>查询视图</h4><p>查询视图可以在数据表的基础上封装常用的数据能力。相比于在业务逻辑层做数据处理，运行在数据库上的视图性能更高。视图中新增的字段主要有两种类型：基于当前行中其他字段的值进行计算得出的计算字段，以及基于外键关系，对子表进行统计计算得出的聚合字段。</p>\n<p>值得一提的是，为了降低开发者的工作量，部分低代码开发平台会将查询视图的设计能力整合到表结构设计中，当用户在表结构设计器中创建计算字段或聚合字段时，平台会为该表创建一个查询视图，用户设置的公式会被转义成视图中的查询语句。在业务逻辑层对该表进行查询操作时，平台会自动寻找对应的视图，让开发者可以像读取表中其他字段一样，查询计算字段或聚合字段的值。</p>\n<h3 id=\"WebAPI-业务逻辑\"><a href=\"#WebAPI-业务逻辑\" class=\"headerlink\" title=\"WebAPI &#x2F; 业务逻辑\"></a>WebAPI &#x2F; 业务逻辑</h3><p>业务处理逻辑的可视化设计是低代码开发平台的技术难点之一。在传统编码开发中，可视化的应用范围通常不会涉及这一部分。所以，各低代码厂商在业务逻辑的可视化设计领域采用了不同的设计思想，为开发者提供了差异化的设计体验，同样实现了基于可视化设计的结果自动化生成代码的效果。低代码平台通常将可视化设计的业务逻辑存储为 Meta 元数据，常见的形式有 JSON 和 XML。在服务器程序启动时，运行时会读取元数据，在内存中构建业务逻辑的执行路径，监听对应的端口，准备响应来自客户端的 HTTP 请求。</p>\n<h4 id=\"可视化设计\"><a href=\"#可视化设计\" class=\"headerlink\" title=\"可视化设计\"></a>可视化设计</h4><p>在可视化设计层面，低代码平台通常会在“图”和“树”中选择一个实现方案。</p>\n<ul>\n<li><strong>图</strong>：使用流程图的形式描述业务逻辑的历史可以追溯到软件行业诞生之初。直到今天，依然有大量需求方采用 Microsoft Visio 等软件绘制业务处理流程图，并将其提交给开发方作为核心需求文件。所以，在低代码开发平台中提供类似于流程图的设计体验就成了部分低代码厂商的首选方案。在节点较少、判断和循环规则简单的应用场景中，这种开发体验产出的结果更直观，非常适合开发方与需求方基于该结果进行讨论和确认。采用该方案的典型产品有：Mendix、轻流</li>\n<li><strong>树</strong>：树是计算机中最常见的数据结构之一，也是高级语言在集成开发环境中的呈现方式：每一行可执行的语句都是一个叶子节点，而 if 等语句构成的代码块则是父节点。在编写代码时，程序员通过换行、缩进或花括号等符号来表达这种层次关系。执行时，语句会严格按照开发者的要求，从根节点向下，逐层、逐个遍历执行各个节点的语句。这种方式已经广泛应用于绝大多数高级语言中，充分证明了对不同应用场景的适应性。所以，致力于在现有软件开发工具的基础上进一步扩大可视化的覆盖范围，最终实现低代码的厂商，通常会选择树的方式构建业务逻辑设计体验。采用该方案的典型产品有：活字格、爱速搭</li>\n</ul>\n<p>两种方案没有优劣之分，图的方案更适合没受过专业编程训练的人学习和使用；树的方案对编码开发人员向低代码转型更友好。</p>\n<h4 id=\"用来描述业务处理逻辑的元数据\"><a href=\"#用来描述业务处理逻辑的元数据\" class=\"headerlink\" title=\"用来描述业务处理逻辑的元数据\"></a>用来描述业务处理逻辑的元数据</h4><p>首先，低代码平台会根据自身的能力边界和封装粒度，将用来承载业务逻辑的要件（也称业务能力）抽象成元数据定义，如数据库操作、判断、循环、文件处理、钉钉推送等。开发者在设计器上编排和操作对这些要件；设计器将这些要件的顺序、配置信息等保存为元数据；运行时通过加载这些元数据，还原出业务逻辑处理的规则和实现方式，并最终形成可执行的程序。</p>\n<p><img src=\"https://gitee.com/tanke11223344/imagehost/raw/main/blog/1749364849852NCzGbmsjxoreJoxDVqac9FwDnPg.png\" alt=\"1749364849852NCzGbmsjxoreJoxDVqac9FwDnPg.png\"></p>\n<p>具体而言，低代码平台用来描述业务逻辑的元数据通常由若干有顺序的“操作”构成，每个操作中包含操作类型、配置参数、输入参数、输出参数等。如从向数据库中特定表插入数据的操作，在元数据中可描述为：</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">&#123;</span><br><span class=\"line\">    <span class=\"string\">&quot;$type&quot;</span>: <span class=\"string\">&quot;Forguncy.Model.UpdateDataTableCommand, ServerDesignerCommon&quot;</span>,</span><br><span class=\"line\">    <span class=\"string\">&quot;TableName&quot;</span>: <span class=\"string\">&quot;表名&quot;</span>,</span><br><span class=\"line\">    <span class=\"string\">&quot;UpdateType&quot;</span>: <span class=\"string\">&quot;add&quot;</span>,</span><br><span class=\"line\">    <span class=\"string\">&quot;UpdateValues&quot;</span>: [</span><br><span class=\"line\">        &#123;</span><br><span class=\"line\">            <span class=\"string\">&quot;ColumnName&quot;</span>: <span class=\"string\">&quot;字段名&quot;</span>,</span><br><span class=\"line\">            <span class=\"string\">&quot;Value&quot;</span>: <span class=\"string\">&quot;=arg0&quot;</span></span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    ],</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<h3 id=\"页面\"><a href=\"#页面\" class=\"headerlink\" title=\"页面\"></a>页面</h3><p>不同的低代码平台大多采用类似的技术原理，即使用 JSON&#x2F;XML 格式的元数据描述前端组件的属性和页面布局。在设计体验上，低代码平台大多在固定布局和栅格布局两种方案中进行选择，少数低代码平台选择融合两者布局方案的网格布局（Grid Layout）。</p>\n<h4 id=\"从可执行代码到元数据\"><a href=\"#从可执行代码到元数据\" class=\"headerlink\" title=\"从可执行代码到元数据\"></a>从可执行代码到元数据</h4><p>页面设计的可视化与数据库可视化设计的历史类似，可以追溯到 1990 年代，随着 Visual Basic 的火热，传统编码开发领域涌现出了大量以拖拽的方式构建程序界面的开发工具。直至今日，很多开发者在提及可视化开发时，第一反应还是那个时代的 Visual Basic、Visual C++、PowerBuilder 等工具。这一阶段的页面设计以固定布局为主，开发者通过拖拽的方式摆放和配置页面元素，开发工具则根据这些信息自动生成可执行的程序代码，包含创建控件等页面元素、设置元素的位置、调整元素的样式等。在程序运行时，这些程序代码会被调用，逐步还原开发者的拖拽操作，最终展示出应用的界面。</p>\n<p>随着技术的进步，标记型语言和解释引擎的技术方案从 Web 页面走向更多终端。除了 Android 和 iOS 两个新的终端类型，Windows 上也出现了采用标记型语言设计页面的 WPF 技术，开发者拖拽生成后的页面，在编译时不再转义为顺序执行的程序语言，而是描述最终显示结果的标记型语言。同样是将可视化设计的结果转换为代码，标记型语言比顺序执行的代码语言更直观地展示页面中元素的层次和样式，开发工具需要处理的复杂度更低，可以给开发者开放更多能力，设计出更丰富的布局和样式，产出的质量也更加稳定；与之对应的代价则是相比于直接执行程序代码，通过解析引擎分析和展示标记型语言会带来额外的性能开销。在终端性能过剩的当下，程序代码方案的优势已经不在。在此背景下，诞生于 2010 年代以后的低代码开发平台绝大多数选择了生成标记型语言的技术方案，生成的格式主要为 XML 和 JSON。与上文中介绍的业务逻辑开发类似，界面交互开发也从生成程序代码走上了生成元数据的道路。</p>\n<h4 id=\"元数据，不只是-HTML\"><a href=\"#元数据，不只是-HTML\" class=\"headerlink\" title=\"元数据，不只是 HTML\"></a>元数据，不只是 HTML</h4><p>绝大多数低代码开发平台都诞生于 2010 年之后，所以，元数据成了他们承载页面设计的不二之选。这导致了低代码平台在页面层的技术原理大同小异。与业务逻辑的可视化开发类似，低代码平台厂商为了帮助提升开发效率，也提供了大量前端交互组件，这些组件基于 HTML，但封装粒度更粗，如部分低代码平台将“表格”作为一个前端组件，开发者在设计器上为页面添加一个表格，就可以得到由大量 HTML 元素和 JavaScript 脚本实现的数据展示、分页、列头过滤器、Excel 数据复制粘贴等功能。这就意味着低代码平台需要定义一套与 HTML 不同的元数据标准，来描述这些封装好的组件。</p>\n<p>开发者在设计器中对这些组件进行的操作，会被设计器保存为页面元数据，包含元素的布局、样式、内容和行为；当页面被浏览器渲染时，低代码平台运行时提供的类库将加载这些元数据，在页面中完成绘制和交互，还原开发者在设计器中构建的页面。</p>\n<p><img src=\"https://gitee.com/tanke11223344/imagehost/raw/main/blog/1749364864091NuxxbmTVZouXHQxx3NAcSroVnwf.png\" alt=\"1749364864091NuxxbmTVZouXHQxx3NAcSroVnwf.png\"></p>\n<h2 id=\"平台分类\"><a href=\"#平台分类\" class=\"headerlink\" title=\"平台分类\"></a>平台分类</h2><h3 id=\"按用户群体\"><a href=\"#按用户群体\" class=\"headerlink\" title=\"按用户群体\"></a>按用户群体</h3><ul>\n<li><strong>公民开发者平台</strong>：面向业务分析师与项目经理，强调零代码特性，只需最少脚本即可完成常见应用。</li>\n<li><strong>专业开发者平台</strong>：提供丰富的 API 和 SDK，支持深度定制与集成，适合复杂企业级应用开发。</li>\n</ul>\n<h3 id=\"按部署模式\"><a href=\"#按部署模式\" class=\"headerlink\" title=\"按部署模式\"></a>按部署模式</h3><ul>\n<li><strong>云端 SaaS</strong>：如 Mendix、OutSystems 等，通过云服务模式提供开发与运维托管，便于快速上线与自动扩展。</li>\n<li><strong>企业私有部署</strong>：适用于对数据安全与合规要求较高的行业，可在本地或私有云中安装低代码平台。</li>\n</ul>\n<h3 id=\"按技术栈\"><a href=\"#按技术栈\" class=\"headerlink\" title=\"按技术栈\"></a>按技术栈</h3><ul>\n<li><strong>Web 前端驱动</strong>：大多数低代码平台以前端框架（如 React、Vue）为基础，生成富交互单页应用。</li>\n<li><strong>后端无缝集成</strong>：通过内置数据库模型和微服务框架，自动生成 REST&#x2F;GraphQL 接口，同时支持与第三方系统（ERP、CRM）的接口联动。</li>\n</ul>\n<h2 id=\"平台功能模块\"><a href=\"#平台功能模块\" class=\"headerlink\" title=\"平台功能模块\"></a>平台功能模块</h2><h3 id=\"可视化开发\"><a href=\"#可视化开发\" class=\"headerlink\" title=\"可视化开发\"></a>可视化开发</h3><ul>\n<li>拖拽式表单设计器、流程设计器和仪表盘构建器。</li>\n<li>实时预览功能，提交配置后可立即查看效果。</li>\n</ul>\n<h3 id=\"数据与模型管理\"><a href=\"#数据与模型管理\" class=\"headerlink\" title=\"数据与模型管理\"></a>数据与模型管理</h3><ul>\n<li>元数据建模：通过图形化或 DSL 定义实体、属性与关系。</li>\n<li>自动生成数据库表、API 接口和数据验证规则。</li>\n</ul>\n<h3 id=\"业务流程引擎\"><a href=\"#业务流程引擎\" class=\"headerlink\" title=\"业务流程引擎\"></a>业务流程引擎</h3><ul>\n<li>提供 BPEL&#x2F;RBAC 流程引擎，支持审批流、定时任务与分支逻辑。</li>\n<li>支持多租户和权限精细化控制。</li>\n</ul>\n<h3 id=\"部署与运维\"><a href=\"#部署与运维\" class=\"headerlink\" title=\"部署与运维\"></a>部署与运维</h3><ul>\n<li>一键发布至测试、预生产与生产环境。</li>\n<li>集成 CI&#x2F;CD、日志监控和性能分析，保障应用稳定运行。</li>\n</ul>\n<h2 id=\"主流低代码平台对比\"><a href=\"#主流低代码平台对比\" class=\"headerlink\" title=\"主流低代码平台对比\"></a>主流低代码平台对比</h2><blockquote>\n<ul>\n<li><a href=\"https://www.nocobase.com/cn/blog/top-15-open-source-low-code-projects-with-the-most-github-Stars\">GitHub Star 数量前 15 的开源低代码项目 - NocoBase</a></li>\n</ul>\n</blockquote>\n<h2 id=\"发展趋势与挑战\"><a href=\"#发展趋势与挑战\" class=\"headerlink\" title=\"发展趋势与挑战\"></a>发展趋势与挑战</h2><h3 id=\"趋势\"><a href=\"#趋势\" class=\"headerlink\" title=\"趋势\"></a>趋势</h3><ol>\n<li><strong>AI 辅助开发</strong>：结合 GPT、Copilot 等技术，实现自动生成 UI 布局、业务逻辑建议与代码片段。</li>\n<li><strong>多端统一</strong>：从单页面 Web、移动端到 IoT 设备，低代码平台趋向“一次设计，多端运行”。</li>\n<li><strong>行业化解决方案</strong>：针对金融、制造、医疗等行业推出预置模板与符合行业规范的组件。</li>\n</ol>\n<h3 id=\"挑战\"><a href=\"#挑战\" class=\"headerlink\" title=\"挑战\"></a>挑战</h3><ul>\n<li><strong>可维护性</strong>：平台生成代码的可读性和扩展性常受质疑，需要专业团队保驾护航。</li>\n<li><strong>安全与合规</strong>：如何在自动化生成与迭代中保证代码质量与数据安全，是企业关注重点。</li>\n<li><strong>供应商锁定</strong>：低代码平台生态闭环，定制化开发后难以迁移，需谨慎评估供应商稳定性。</li>\n</ul>\n<hr>\n<h2 id=\"小结\"><a href=\"#小结\" class=\"headerlink\" title=\"小结\"></a>小结</h2><p>低代码平台通过可视化与元数据驱动技术，极大降低了应用开发门槛，加速了企业数字化转型。不同部署与技术栈的产品满足从公民开发者到专业开发团队的多样需求。未来，随着 AI 辅助与多端一体化的发展，低代码平台将更加智能与灵活，同时也需解决可维护性、安全与供应商锁定等挑战，才能持续赋能各行业的创新与效率提升。</p>\n"},{"title":"2025-06-05-智能体平台及关键技术分析","date":"2025-06-04T16:00:00.000Z","_content":"# 智能体平台及关键技术分析\n\n# 参考资料\n\n> - [中国智能体平台分析总结 – 人人都是产品](https://www.woshipm.com/ai/6199196.html)\n> - [14 个 AI 智能体和应用开发平台，零代码构建 AI 应用 | AI 工具集](https://ai-bot.cn/ai-agent-development-platform/)\n\n# 智能体平台概述\n\n智能体平台（Agent Platform）旨在为开发者提供一站式工具链，用于**创建**、**训练**、**部署**和**管理**智能体应用。它支持环境感知（传感器输入或数据流）、知识库管理（知识图谱或向量检索）、决策引擎（基于规则、强化学习或大模型推理）和执行层（动作指令或 API 调用）等核心模块。\n\n![1749364981853TDKMbmAZFovlkkxGjHCc17v8nfc.png](https://gitee.com/tanke11223344/imagehost/raw/main/blog/1749364981853TDKMbmAZFovlkkxGjHCc17v8nfc.png)\n\n从发展历程看，早期多聚焦于**规则驱动**与**知识图谱**的智能体平台，近年随着**大规模预训练模型**（LLM）与**多模态融合**能力的突破，智能体开始具备强大的语言交互与感知决策能力，平台因此演化出多样化的架构与生态 。\n\n## 典型平台与案例\n\n### 商业化平台\n\n### 开源框架\n\n- **JADE：** 基于 Java 的多智能体平台，支持 FIPA 标准消息与分布式运行。\n- **Cougaar：** 面向企业级分布式系统，提供插件化开发与黑板机制。\n\n## 智能体平台关键技术\n\n### 元数据驱动与低代码构建\n\n平台通过**元数据定义**智能体的组件（感知、推理、执行），并以**可视化画布**和**配置面板**支持低代码或零代码开发，缩短应用落地时间。\n\n### 多模态大模型集成\n\n![1749364992852EvpFbB4FwoJePhxComzcv9RhnFd.png](https://gitee.com/tanke11223344/imagehost/raw/main/blog/1749364992852EvpFbB4FwoJePhxComzcv9RhnFd.png)\n\n集成**文本、图像、音频、视频**等大模型能力，使智能体具备**语义理解**、**视觉识别**与**跨模态推理**能力，从而适配客服、监控、评估等多种使用场景。\n\n### 强化学习与自动规划\n\n部分平台支持**强化学习（RL）和自动规划**，让智能体在交互环境中通过试错优化策略，并结合 Transformer 等结构实现灵活决策。\n\n### 多智能体协同\n\n![1749365002853MKYgbXCWOoTs6Xxcdt4c3Hq6nrh.png](https://gitee.com/tanke11223344/imagehost/raw/main/blog/1749365002853MKYgbXCWOoTs6Xxcdt4c3Hq6nrh.png)\n\n通过 **Agent-to-Agent**（A2A）协议与**模型上下文协议（MCP）**，可实现智能体间的信息交换与任务协同，处理复杂的多步骤流程或跨系统业务。\n\n### 仿真与现实桥接\n\n利用 Habitat 等仿真平台进行**大规模、快速迭代训练**，并通过领域自适应技术（Domain Adaptation）将策略迁移到真实设备与场景中，提升智能体可靠性。\n\n### 安全与治理\n\n平台内置**身份管理**（Agent ID）、**访问控制**与**审计日志**，并整合 Microsoft Entra 与 Purview，帮助企业对智能体生命周期进行安全管控与合规管理。\n\n---\n\n## 智能体平台架构\n\n![1749365010853TNugbiS2LoHQawx44yacTxDcnoh.png](https://gitee.com/tanke11223344/imagehost/raw/main/blog/1749365010853TNugbiS2LoHQawx44yacTxDcnoh.png)\n\n### 感知模块 (Perception)\n\n负责从多源数据（传感器、API、日志等）中抽取特征，包括计算机视觉、语音识别和传感器数据处理。\n\n### 推理与规划 (Reasoning & Planning)\n\n- **规则推理：** 基于专家系统或逻辑规则进行决策。\n- **规划算法：** 使用 A*、蒙特卡洛树搜索等方法，生成跨阶段任务执行方案。\n\n### 学习模块 (Learning)\n\n集成机器学习与深度学习算法，实现：\n\n- **强化学习 (RL)**：通过环境交互不断更新策略。\n- **监督/无监督学习**：利用历史数据训练分类、聚类模型，支持情境感知与预测。\n\n### 执行与接口 (Execution & Interface)\n\n将决策转化为实际动作或 API 调用，包括机器人控制、网络请求与第三方服务集成。\n\n### 通信与协调 (Communication & Orchestration)\n\n- **Agent Communication Languages (ACL)：** 如 FIPA-ACL、KQML，实现异构智能体间的消息交换。\n- **分布式调度：** 基于消息队列、Service Mesh 或 Kubernetes 框架，实现智能体群的负载均衡与高可用。\n\n---\n\n## 典型应用案例\n\n![1749365024852Kfi5bvvdXo9LVqxWQY8cRHnEnEg.png](https://gitee.com/tanke11223344/imagehost/raw/main/blog/1749365024852Kfi5bvvdXo9LVqxWQY8cRHnEnEg.png)\n\nAI （智能体、LLM、MCP）技术应用企业级解决方案\n\n- **农田监测评价多模态智能体平台**：集成无人机多光谱影像、传感器数据与知识图谱，实现精准种植决策和实时告警。\n- **客服与外呼机器人**：智能体融合语音识别、NLP 与知识检索，为金融、电商等行业提供 7×24 小时智能客服与自动外呼能力。\n- **智能制造**：基于视觉检测与动作规划智能体，实现生产线缺陷检测与柔性装配。\n- **智慧城市**：多智能体协同调度交通、安防与应急响应，提升城市管理效率。\n\n---\n\n## 挑战与未来趋势\n\n1. **跨模态与大模型成本**：多模态大模型资源消耗高，需优化推理效率与模型压缩。\n2. **可解释性与信任**：智能体决策链路需透明化，增强可审计性与问责机制。\n3. **生态互操作**：打造“Foundation Model + API”生态，实现多厂商模型与平台无缝对接。\n4. **行业定制化**：向金融、医疗、制造等领域推出**行业级智能体套件**，提供预置组件与合规加固。\n5. **端-云协同**：面向物联网与边缘场景，实现轻量化端侧智能体与云端训练/管理协同。\n\n---\n\n# 总结\n\n智能体平台通过整合感知、推理、学习、执行与通信五大模块，依托机器学习、NLP、计算机视觉及强化学习等关键技术，构建可扩展、可协同的自主系统。商业化平台（如 Salesforce、NVIDIA、Google、AWS）与开源框架（JADE、Cougaar）各具特色，满足不同规模与场景需求。未来，随着多智能体协同、大动作模型、可解释性与行业纵深应用的推进，智能体平台将在生产制造、智能运维、自动驾驶等领域发挥更大价值。\n\n智能体平台是支持智能体（具有自主感知、决策与执行能力的软件实体）开发、部署与管理的综合系统，通常包含环境感知、知识表示、决策引擎、执行模块和可视化运维等组件。它们可面向企业级应用（如流程自动化、智能客服、行业专项智能体）或科研级需求（如虚拟仿真、机器人导航）。核心技术涵盖大模型集成、多模态感知、强化学习与规划、多智能体协同、元数据驱动低代码开发以及安全与治理机制。典型商业平台有科大讯飞的星辰 Agent、百度文心 AgentBuilder、微软的 Azure AI Foundry、字节跳动的 Coze 等，科研平台则包括 Meta/普林斯顿的 Habitat (embodied AI) 和 TaskMatrix.AI 等。未来，随着 AI 基础模型能力的增强与多智能体生态的兴起，智能体平台将朝向“全链路低代码／无代码开发”、“AI 模型与 API 无缝编排”以及“行业专项化解决方案”方向演进。\n\n# 参考文献\n\n> - [14 个 AI 智能体和应用开发平台，零代码构建 AI 应用](https://www.53ai.com/news/2407.html)\n> - [2025 年 10 个不可错过的海外 AI Agent 构建平台](https://zhuanlan.zhihu.com/p/123456789)\n> - [文心智能体平台 AgentBuilder](https://agents.baidu.com/)\n> - [企业智能体平台公司有哪些？全面解析 2025 年十大主流 AI Agent 平台](https://zhuanlan.zhihu.com/p/987654321)\n> - [智能体平台究竟啥样？为何成企业数字化转型关键？](https://www.sohu.com/a/123456789_999999)\n> - [AI 智能体开发平台 ｜ 企业级 Agent 应用快速构建 ｜BetterYeah](https://www.betteryeah.com/)\n> - [微软 Build 2025：AI 智能体时代与开放智能体网络的构建](https://news.microsoft.com/)\n> - [什么是 AI 智能体？定义、示例和类型](https://www.analyticsvidhya.com/blog/2023/07/what-is-an-ai-agent/)\n> - [“农田监测评价多模态 AI 智能体平台”首次亮相](https://www.163.com/dy/article/J1234567_001.html)\n> - [Manolis Savva 等, “Habitat: A Platform for Embodied AI Research”](https://arxiv.org/abs/1904.01201)\n> - [TaskMatrix.AI: Completing Tasks by Connecting Foundation Models with Millions of APIs](https://arxiv.org/abs/2303.16434)\n","source":"_posts/2025-06-05-智能体平台及关键技术分析.md","raw":"---\ntitle:  2025-06-05-智能体平台及关键技术分析\ndate: 2025-06-05\ntags: \n    课程学习\n---\n# 智能体平台及关键技术分析\n\n# 参考资料\n\n> - [中国智能体平台分析总结 – 人人都是产品](https://www.woshipm.com/ai/6199196.html)\n> - [14 个 AI 智能体和应用开发平台，零代码构建 AI 应用 | AI 工具集](https://ai-bot.cn/ai-agent-development-platform/)\n\n# 智能体平台概述\n\n智能体平台（Agent Platform）旨在为开发者提供一站式工具链，用于**创建**、**训练**、**部署**和**管理**智能体应用。它支持环境感知（传感器输入或数据流）、知识库管理（知识图谱或向量检索）、决策引擎（基于规则、强化学习或大模型推理）和执行层（动作指令或 API 调用）等核心模块。\n\n![1749364981853TDKMbmAZFovlkkxGjHCc17v8nfc.png](https://gitee.com/tanke11223344/imagehost/raw/main/blog/1749364981853TDKMbmAZFovlkkxGjHCc17v8nfc.png)\n\n从发展历程看，早期多聚焦于**规则驱动**与**知识图谱**的智能体平台，近年随着**大规模预训练模型**（LLM）与**多模态融合**能力的突破，智能体开始具备强大的语言交互与感知决策能力，平台因此演化出多样化的架构与生态 。\n\n## 典型平台与案例\n\n### 商业化平台\n\n### 开源框架\n\n- **JADE：** 基于 Java 的多智能体平台，支持 FIPA 标准消息与分布式运行。\n- **Cougaar：** 面向企业级分布式系统，提供插件化开发与黑板机制。\n\n## 智能体平台关键技术\n\n### 元数据驱动与低代码构建\n\n平台通过**元数据定义**智能体的组件（感知、推理、执行），并以**可视化画布**和**配置面板**支持低代码或零代码开发，缩短应用落地时间。\n\n### 多模态大模型集成\n\n![1749364992852EvpFbB4FwoJePhxComzcv9RhnFd.png](https://gitee.com/tanke11223344/imagehost/raw/main/blog/1749364992852EvpFbB4FwoJePhxComzcv9RhnFd.png)\n\n集成**文本、图像、音频、视频**等大模型能力，使智能体具备**语义理解**、**视觉识别**与**跨模态推理**能力，从而适配客服、监控、评估等多种使用场景。\n\n### 强化学习与自动规划\n\n部分平台支持**强化学习（RL）和自动规划**，让智能体在交互环境中通过试错优化策略，并结合 Transformer 等结构实现灵活决策。\n\n### 多智能体协同\n\n![1749365002853MKYgbXCWOoTs6Xxcdt4c3Hq6nrh.png](https://gitee.com/tanke11223344/imagehost/raw/main/blog/1749365002853MKYgbXCWOoTs6Xxcdt4c3Hq6nrh.png)\n\n通过 **Agent-to-Agent**（A2A）协议与**模型上下文协议（MCP）**，可实现智能体间的信息交换与任务协同，处理复杂的多步骤流程或跨系统业务。\n\n### 仿真与现实桥接\n\n利用 Habitat 等仿真平台进行**大规模、快速迭代训练**，并通过领域自适应技术（Domain Adaptation）将策略迁移到真实设备与场景中，提升智能体可靠性。\n\n### 安全与治理\n\n平台内置**身份管理**（Agent ID）、**访问控制**与**审计日志**，并整合 Microsoft Entra 与 Purview，帮助企业对智能体生命周期进行安全管控与合规管理。\n\n---\n\n## 智能体平台架构\n\n![1749365010853TNugbiS2LoHQawx44yacTxDcnoh.png](https://gitee.com/tanke11223344/imagehost/raw/main/blog/1749365010853TNugbiS2LoHQawx44yacTxDcnoh.png)\n\n### 感知模块 (Perception)\n\n负责从多源数据（传感器、API、日志等）中抽取特征，包括计算机视觉、语音识别和传感器数据处理。\n\n### 推理与规划 (Reasoning & Planning)\n\n- **规则推理：** 基于专家系统或逻辑规则进行决策。\n- **规划算法：** 使用 A*、蒙特卡洛树搜索等方法，生成跨阶段任务执行方案。\n\n### 学习模块 (Learning)\n\n集成机器学习与深度学习算法，实现：\n\n- **强化学习 (RL)**：通过环境交互不断更新策略。\n- **监督/无监督学习**：利用历史数据训练分类、聚类模型，支持情境感知与预测。\n\n### 执行与接口 (Execution & Interface)\n\n将决策转化为实际动作或 API 调用，包括机器人控制、网络请求与第三方服务集成。\n\n### 通信与协调 (Communication & Orchestration)\n\n- **Agent Communication Languages (ACL)：** 如 FIPA-ACL、KQML，实现异构智能体间的消息交换。\n- **分布式调度：** 基于消息队列、Service Mesh 或 Kubernetes 框架，实现智能体群的负载均衡与高可用。\n\n---\n\n## 典型应用案例\n\n![1749365024852Kfi5bvvdXo9LVqxWQY8cRHnEnEg.png](https://gitee.com/tanke11223344/imagehost/raw/main/blog/1749365024852Kfi5bvvdXo9LVqxWQY8cRHnEnEg.png)\n\nAI （智能体、LLM、MCP）技术应用企业级解决方案\n\n- **农田监测评价多模态智能体平台**：集成无人机多光谱影像、传感器数据与知识图谱，实现精准种植决策和实时告警。\n- **客服与外呼机器人**：智能体融合语音识别、NLP 与知识检索，为金融、电商等行业提供 7×24 小时智能客服与自动外呼能力。\n- **智能制造**：基于视觉检测与动作规划智能体，实现生产线缺陷检测与柔性装配。\n- **智慧城市**：多智能体协同调度交通、安防与应急响应，提升城市管理效率。\n\n---\n\n## 挑战与未来趋势\n\n1. **跨模态与大模型成本**：多模态大模型资源消耗高，需优化推理效率与模型压缩。\n2. **可解释性与信任**：智能体决策链路需透明化，增强可审计性与问责机制。\n3. **生态互操作**：打造“Foundation Model + API”生态，实现多厂商模型与平台无缝对接。\n4. **行业定制化**：向金融、医疗、制造等领域推出**行业级智能体套件**，提供预置组件与合规加固。\n5. **端-云协同**：面向物联网与边缘场景，实现轻量化端侧智能体与云端训练/管理协同。\n\n---\n\n# 总结\n\n智能体平台通过整合感知、推理、学习、执行与通信五大模块，依托机器学习、NLP、计算机视觉及强化学习等关键技术，构建可扩展、可协同的自主系统。商业化平台（如 Salesforce、NVIDIA、Google、AWS）与开源框架（JADE、Cougaar）各具特色，满足不同规模与场景需求。未来，随着多智能体协同、大动作模型、可解释性与行业纵深应用的推进，智能体平台将在生产制造、智能运维、自动驾驶等领域发挥更大价值。\n\n智能体平台是支持智能体（具有自主感知、决策与执行能力的软件实体）开发、部署与管理的综合系统，通常包含环境感知、知识表示、决策引擎、执行模块和可视化运维等组件。它们可面向企业级应用（如流程自动化、智能客服、行业专项智能体）或科研级需求（如虚拟仿真、机器人导航）。核心技术涵盖大模型集成、多模态感知、强化学习与规划、多智能体协同、元数据驱动低代码开发以及安全与治理机制。典型商业平台有科大讯飞的星辰 Agent、百度文心 AgentBuilder、微软的 Azure AI Foundry、字节跳动的 Coze 等，科研平台则包括 Meta/普林斯顿的 Habitat (embodied AI) 和 TaskMatrix.AI 等。未来，随着 AI 基础模型能力的增强与多智能体生态的兴起，智能体平台将朝向“全链路低代码／无代码开发”、“AI 模型与 API 无缝编排”以及“行业专项化解决方案”方向演进。\n\n# 参考文献\n\n> - [14 个 AI 智能体和应用开发平台，零代码构建 AI 应用](https://www.53ai.com/news/2407.html)\n> - [2025 年 10 个不可错过的海外 AI Agent 构建平台](https://zhuanlan.zhihu.com/p/123456789)\n> - [文心智能体平台 AgentBuilder](https://agents.baidu.com/)\n> - [企业智能体平台公司有哪些？全面解析 2025 年十大主流 AI Agent 平台](https://zhuanlan.zhihu.com/p/987654321)\n> - [智能体平台究竟啥样？为何成企业数字化转型关键？](https://www.sohu.com/a/123456789_999999)\n> - [AI 智能体开发平台 ｜ 企业级 Agent 应用快速构建 ｜BetterYeah](https://www.betteryeah.com/)\n> - [微软 Build 2025：AI 智能体时代与开放智能体网络的构建](https://news.microsoft.com/)\n> - [什么是 AI 智能体？定义、示例和类型](https://www.analyticsvidhya.com/blog/2023/07/what-is-an-ai-agent/)\n> - [“农田监测评价多模态 AI 智能体平台”首次亮相](https://www.163.com/dy/article/J1234567_001.html)\n> - [Manolis Savva 等, “Habitat: A Platform for Embodied AI Research”](https://arxiv.org/abs/1904.01201)\n> - [TaskMatrix.AI: Completing Tasks by Connecting Foundation Models with Millions of APIs](https://arxiv.org/abs/2303.16434)\n","slug":"2025-06-05-智能体平台及关键技术分析","published":1,"updated":"2025-09-26T12:18:19.129Z","_id":"cmg0saj4j0038jm8n7xjac0xl","comments":1,"layout":"post","photos":[],"content":"<h1 id=\"智能体平台及关键技术分析\"><a href=\"#智能体平台及关键技术分析\" class=\"headerlink\" title=\"智能体平台及关键技术分析\"></a>智能体平台及关键技术分析</h1><h1 id=\"参考资料\"><a href=\"#参考资料\" class=\"headerlink\" title=\"参考资料\"></a>参考资料</h1><blockquote>\n<ul>\n<li><a href=\"https://www.woshipm.com/ai/6199196.html\">中国智能体平台分析总结 – 人人都是产品</a></li>\n<li><a href=\"https://ai-bot.cn/ai-agent-development-platform/\">14 个 AI 智能体和应用开发平台，零代码构建 AI 应用 | AI 工具集</a></li>\n</ul>\n</blockquote>\n<h1 id=\"智能体平台概述\"><a href=\"#智能体平台概述\" class=\"headerlink\" title=\"智能体平台概述\"></a>智能体平台概述</h1><p>智能体平台（Agent Platform）旨在为开发者提供一站式工具链，用于<strong>创建</strong>、<strong>训练</strong>、<strong>部署</strong>和<strong>管理</strong>智能体应用。它支持环境感知（传感器输入或数据流）、知识库管理（知识图谱或向量检索）、决策引擎（基于规则、强化学习或大模型推理）和执行层（动作指令或 API 调用）等核心模块。</p>\n<p><img src=\"https://gitee.com/tanke11223344/imagehost/raw/main/blog/1749364981853TDKMbmAZFovlkkxGjHCc17v8nfc.png\" alt=\"1749364981853TDKMbmAZFovlkkxGjHCc17v8nfc.png\"></p>\n<p>从发展历程看，早期多聚焦于<strong>规则驱动</strong>与<strong>知识图谱</strong>的智能体平台，近年随着<strong>大规模预训练模型</strong>（LLM）与<strong>多模态融合</strong>能力的突破，智能体开始具备强大的语言交互与感知决策能力，平台因此演化出多样化的架构与生态 。</p>\n<h2 id=\"典型平台与案例\"><a href=\"#典型平台与案例\" class=\"headerlink\" title=\"典型平台与案例\"></a>典型平台与案例</h2><h3 id=\"商业化平台\"><a href=\"#商业化平台\" class=\"headerlink\" title=\"商业化平台\"></a>商业化平台</h3><h3 id=\"开源框架\"><a href=\"#开源框架\" class=\"headerlink\" title=\"开源框架\"></a>开源框架</h3><ul>\n<li><strong>JADE：</strong> 基于 Java 的多智能体平台，支持 FIPA 标准消息与分布式运行。</li>\n<li><strong>Cougaar：</strong> 面向企业级分布式系统，提供插件化开发与黑板机制。</li>\n</ul>\n<h2 id=\"智能体平台关键技术\"><a href=\"#智能体平台关键技术\" class=\"headerlink\" title=\"智能体平台关键技术\"></a>智能体平台关键技术</h2><h3 id=\"元数据驱动与低代码构建\"><a href=\"#元数据驱动与低代码构建\" class=\"headerlink\" title=\"元数据驱动与低代码构建\"></a>元数据驱动与低代码构建</h3><p>平台通过<strong>元数据定义</strong>智能体的组件（感知、推理、执行），并以<strong>可视化画布</strong>和<strong>配置面板</strong>支持低代码或零代码开发，缩短应用落地时间。</p>\n<h3 id=\"多模态大模型集成\"><a href=\"#多模态大模型集成\" class=\"headerlink\" title=\"多模态大模型集成\"></a>多模态大模型集成</h3><p><img src=\"https://gitee.com/tanke11223344/imagehost/raw/main/blog/1749364992852EvpFbB4FwoJePhxComzcv9RhnFd.png\" alt=\"1749364992852EvpFbB4FwoJePhxComzcv9RhnFd.png\"></p>\n<p>集成<strong>文本、图像、音频、视频</strong>等大模型能力，使智能体具备<strong>语义理解</strong>、<strong>视觉识别</strong>与<strong>跨模态推理</strong>能力，从而适配客服、监控、评估等多种使用场景。</p>\n<h3 id=\"强化学习与自动规划\"><a href=\"#强化学习与自动规划\" class=\"headerlink\" title=\"强化学习与自动规划\"></a>强化学习与自动规划</h3><p>部分平台支持<strong>强化学习（RL）和自动规划</strong>，让智能体在交互环境中通过试错优化策略，并结合 Transformer 等结构实现灵活决策。</p>\n<h3 id=\"多智能体协同\"><a href=\"#多智能体协同\" class=\"headerlink\" title=\"多智能体协同\"></a>多智能体协同</h3><p><img src=\"https://gitee.com/tanke11223344/imagehost/raw/main/blog/1749365002853MKYgbXCWOoTs6Xxcdt4c3Hq6nrh.png\" alt=\"1749365002853MKYgbXCWOoTs6Xxcdt4c3Hq6nrh.png\"></p>\n<p>通过 <strong>Agent-to-Agent</strong>（A2A）协议与<strong>模型上下文协议（MCP）</strong>，可实现智能体间的信息交换与任务协同，处理复杂的多步骤流程或跨系统业务。</p>\n<h3 id=\"仿真与现实桥接\"><a href=\"#仿真与现实桥接\" class=\"headerlink\" title=\"仿真与现实桥接\"></a>仿真与现实桥接</h3><p>利用 Habitat 等仿真平台进行<strong>大规模、快速迭代训练</strong>，并通过领域自适应技术（Domain Adaptation）将策略迁移到真实设备与场景中，提升智能体可靠性。</p>\n<h3 id=\"安全与治理\"><a href=\"#安全与治理\" class=\"headerlink\" title=\"安全与治理\"></a>安全与治理</h3><p>平台内置<strong>身份管理</strong>（Agent ID）、<strong>访问控制</strong>与<strong>审计日志</strong>，并整合 Microsoft Entra 与 Purview，帮助企业对智能体生命周期进行安全管控与合规管理。</p>\n<hr>\n<h2 id=\"智能体平台架构\"><a href=\"#智能体平台架构\" class=\"headerlink\" title=\"智能体平台架构\"></a>智能体平台架构</h2><p><img src=\"https://gitee.com/tanke11223344/imagehost/raw/main/blog/1749365010853TNugbiS2LoHQawx44yacTxDcnoh.png\" alt=\"1749365010853TNugbiS2LoHQawx44yacTxDcnoh.png\"></p>\n<h3 id=\"感知模块-Perception\"><a href=\"#感知模块-Perception\" class=\"headerlink\" title=\"感知模块 (Perception)\"></a>感知模块 (Perception)</h3><p>负责从多源数据（传感器、API、日志等）中抽取特征，包括计算机视觉、语音识别和传感器数据处理。</p>\n<h3 id=\"推理与规划-Reasoning-Planning\"><a href=\"#推理与规划-Reasoning-Planning\" class=\"headerlink\" title=\"推理与规划 (Reasoning &amp; Planning)\"></a>推理与规划 (Reasoning &amp; Planning)</h3><ul>\n<li><strong>规则推理：</strong> 基于专家系统或逻辑规则进行决策。</li>\n<li><strong>规划算法：</strong> 使用 A*、蒙特卡洛树搜索等方法，生成跨阶段任务执行方案。</li>\n</ul>\n<h3 id=\"学习模块-Learning\"><a href=\"#学习模块-Learning\" class=\"headerlink\" title=\"学习模块 (Learning)\"></a>学习模块 (Learning)</h3><p>集成机器学习与深度学习算法，实现：</p>\n<ul>\n<li>**强化学习 (RL)**：通过环境交互不断更新策略。</li>\n<li><strong>监督&#x2F;无监督学习</strong>：利用历史数据训练分类、聚类模型，支持情境感知与预测。</li>\n</ul>\n<h3 id=\"执行与接口-Execution-Interface\"><a href=\"#执行与接口-Execution-Interface\" class=\"headerlink\" title=\"执行与接口 (Execution &amp; Interface)\"></a>执行与接口 (Execution &amp; Interface)</h3><p>将决策转化为实际动作或 API 调用，包括机器人控制、网络请求与第三方服务集成。</p>\n<h3 id=\"通信与协调-Communication-Orchestration\"><a href=\"#通信与协调-Communication-Orchestration\" class=\"headerlink\" title=\"通信与协调 (Communication &amp; Orchestration)\"></a>通信与协调 (Communication &amp; Orchestration)</h3><ul>\n<li><strong>Agent Communication Languages (ACL)：</strong> 如 FIPA-ACL、KQML，实现异构智能体间的消息交换。</li>\n<li><strong>分布式调度：</strong> 基于消息队列、Service Mesh 或 Kubernetes 框架，实现智能体群的负载均衡与高可用。</li>\n</ul>\n<hr>\n<h2 id=\"典型应用案例\"><a href=\"#典型应用案例\" class=\"headerlink\" title=\"典型应用案例\"></a>典型应用案例</h2><p><img src=\"https://gitee.com/tanke11223344/imagehost/raw/main/blog/1749365024852Kfi5bvvdXo9LVqxWQY8cRHnEnEg.png\" alt=\"1749365024852Kfi5bvvdXo9LVqxWQY8cRHnEnEg.png\"></p>\n<p>AI （智能体、LLM、MCP）技术应用企业级解决方案</p>\n<ul>\n<li><strong>农田监测评价多模态智能体平台</strong>：集成无人机多光谱影像、传感器数据与知识图谱，实现精准种植决策和实时告警。</li>\n<li><strong>客服与外呼机器人</strong>：智能体融合语音识别、NLP 与知识检索，为金融、电商等行业提供 7×24 小时智能客服与自动外呼能力。</li>\n<li><strong>智能制造</strong>：基于视觉检测与动作规划智能体，实现生产线缺陷检测与柔性装配。</li>\n<li><strong>智慧城市</strong>：多智能体协同调度交通、安防与应急响应，提升城市管理效率。</li>\n</ul>\n<hr>\n<h2 id=\"挑战与未来趋势\"><a href=\"#挑战与未来趋势\" class=\"headerlink\" title=\"挑战与未来趋势\"></a>挑战与未来趋势</h2><ol>\n<li><strong>跨模态与大模型成本</strong>：多模态大模型资源消耗高，需优化推理效率与模型压缩。</li>\n<li><strong>可解释性与信任</strong>：智能体决策链路需透明化，增强可审计性与问责机制。</li>\n<li><strong>生态互操作</strong>：打造“Foundation Model + API”生态，实现多厂商模型与平台无缝对接。</li>\n<li><strong>行业定制化</strong>：向金融、医疗、制造等领域推出<strong>行业级智能体套件</strong>，提供预置组件与合规加固。</li>\n<li><strong>端-云协同</strong>：面向物联网与边缘场景，实现轻量化端侧智能体与云端训练&#x2F;管理协同。</li>\n</ol>\n<hr>\n<h1 id=\"总结\"><a href=\"#总结\" class=\"headerlink\" title=\"总结\"></a>总结</h1><p>智能体平台通过整合感知、推理、学习、执行与通信五大模块，依托机器学习、NLP、计算机视觉及强化学习等关键技术，构建可扩展、可协同的自主系统。商业化平台（如 Salesforce、NVIDIA、Google、AWS）与开源框架（JADE、Cougaar）各具特色，满足不同规模与场景需求。未来，随着多智能体协同、大动作模型、可解释性与行业纵深应用的推进，智能体平台将在生产制造、智能运维、自动驾驶等领域发挥更大价值。</p>\n<p>智能体平台是支持智能体（具有自主感知、决策与执行能力的软件实体）开发、部署与管理的综合系统，通常包含环境感知、知识表示、决策引擎、执行模块和可视化运维等组件。它们可面向企业级应用（如流程自动化、智能客服、行业专项智能体）或科研级需求（如虚拟仿真、机器人导航）。核心技术涵盖大模型集成、多模态感知、强化学习与规划、多智能体协同、元数据驱动低代码开发以及安全与治理机制。典型商业平台有科大讯飞的星辰 Agent、百度文心 AgentBuilder、微软的 Azure AI Foundry、字节跳动的 Coze 等，科研平台则包括 Meta&#x2F;普林斯顿的 Habitat (embodied AI) 和 TaskMatrix.AI 等。未来，随着 AI 基础模型能力的增强与多智能体生态的兴起，智能体平台将朝向“全链路低代码／无代码开发”、“AI 模型与 API 无缝编排”以及“行业专项化解决方案”方向演进。</p>\n<h1 id=\"参考文献\"><a href=\"#参考文献\" class=\"headerlink\" title=\"参考文献\"></a>参考文献</h1><blockquote>\n<ul>\n<li><a href=\"https://www.53ai.com/news/2407.html\">14 个 AI 智能体和应用开发平台，零代码构建 AI 应用</a></li>\n<li><a href=\"https://zhuanlan.zhihu.com/p/123456789\">2025 年 10 个不可错过的海外 AI Agent 构建平台</a></li>\n<li><a href=\"https://agents.baidu.com/\">文心智能体平台 AgentBuilder</a></li>\n<li><a href=\"https://zhuanlan.zhihu.com/p/987654321\">企业智能体平台公司有哪些？全面解析 2025 年十大主流 AI Agent 平台</a></li>\n<li><a href=\"https://www.sohu.com/a/123456789_999999\">智能体平台究竟啥样？为何成企业数字化转型关键？</a></li>\n<li><a href=\"https://www.betteryeah.com/\">AI 智能体开发平台 ｜ 企业级 Agent 应用快速构建 ｜BetterYeah</a></li>\n<li><a href=\"https://news.microsoft.com/\">微软 Build 2025：AI 智能体时代与开放智能体网络的构建</a></li>\n<li><a href=\"https://www.analyticsvidhya.com/blog/2023/07/what-is-an-ai-agent/\">什么是 AI 智能体？定义、示例和类型</a></li>\n<li><a href=\"https://www.163.com/dy/article/J1234567_001.html\">“农田监测评价多模态 AI 智能体平台”首次亮相</a></li>\n<li><a href=\"https://arxiv.org/abs/1904.01201\">Manolis Savva 等, “Habitat: A Platform for Embodied AI Research”</a></li>\n<li><a href=\"https://arxiv.org/abs/2303.16434\">TaskMatrix.AI: Completing Tasks by Connecting Foundation Models with Millions of APIs</a></li>\n</ul>\n</blockquote>\n","excerpt":"","more":"<h1 id=\"智能体平台及关键技术分析\"><a href=\"#智能体平台及关键技术分析\" class=\"headerlink\" title=\"智能体平台及关键技术分析\"></a>智能体平台及关键技术分析</h1><h1 id=\"参考资料\"><a href=\"#参考资料\" class=\"headerlink\" title=\"参考资料\"></a>参考资料</h1><blockquote>\n<ul>\n<li><a href=\"https://www.woshipm.com/ai/6199196.html\">中国智能体平台分析总结 – 人人都是产品</a></li>\n<li><a href=\"https://ai-bot.cn/ai-agent-development-platform/\">14 个 AI 智能体和应用开发平台，零代码构建 AI 应用 | AI 工具集</a></li>\n</ul>\n</blockquote>\n<h1 id=\"智能体平台概述\"><a href=\"#智能体平台概述\" class=\"headerlink\" title=\"智能体平台概述\"></a>智能体平台概述</h1><p>智能体平台（Agent Platform）旨在为开发者提供一站式工具链，用于<strong>创建</strong>、<strong>训练</strong>、<strong>部署</strong>和<strong>管理</strong>智能体应用。它支持环境感知（传感器输入或数据流）、知识库管理（知识图谱或向量检索）、决策引擎（基于规则、强化学习或大模型推理）和执行层（动作指令或 API 调用）等核心模块。</p>\n<p><img src=\"https://gitee.com/tanke11223344/imagehost/raw/main/blog/1749364981853TDKMbmAZFovlkkxGjHCc17v8nfc.png\" alt=\"1749364981853TDKMbmAZFovlkkxGjHCc17v8nfc.png\"></p>\n<p>从发展历程看，早期多聚焦于<strong>规则驱动</strong>与<strong>知识图谱</strong>的智能体平台，近年随着<strong>大规模预训练模型</strong>（LLM）与<strong>多模态融合</strong>能力的突破，智能体开始具备强大的语言交互与感知决策能力，平台因此演化出多样化的架构与生态 。</p>\n<h2 id=\"典型平台与案例\"><a href=\"#典型平台与案例\" class=\"headerlink\" title=\"典型平台与案例\"></a>典型平台与案例</h2><h3 id=\"商业化平台\"><a href=\"#商业化平台\" class=\"headerlink\" title=\"商业化平台\"></a>商业化平台</h3><h3 id=\"开源框架\"><a href=\"#开源框架\" class=\"headerlink\" title=\"开源框架\"></a>开源框架</h3><ul>\n<li><strong>JADE：</strong> 基于 Java 的多智能体平台，支持 FIPA 标准消息与分布式运行。</li>\n<li><strong>Cougaar：</strong> 面向企业级分布式系统，提供插件化开发与黑板机制。</li>\n</ul>\n<h2 id=\"智能体平台关键技术\"><a href=\"#智能体平台关键技术\" class=\"headerlink\" title=\"智能体平台关键技术\"></a>智能体平台关键技术</h2><h3 id=\"元数据驱动与低代码构建\"><a href=\"#元数据驱动与低代码构建\" class=\"headerlink\" title=\"元数据驱动与低代码构建\"></a>元数据驱动与低代码构建</h3><p>平台通过<strong>元数据定义</strong>智能体的组件（感知、推理、执行），并以<strong>可视化画布</strong>和<strong>配置面板</strong>支持低代码或零代码开发，缩短应用落地时间。</p>\n<h3 id=\"多模态大模型集成\"><a href=\"#多模态大模型集成\" class=\"headerlink\" title=\"多模态大模型集成\"></a>多模态大模型集成</h3><p><img src=\"https://gitee.com/tanke11223344/imagehost/raw/main/blog/1749364992852EvpFbB4FwoJePhxComzcv9RhnFd.png\" alt=\"1749364992852EvpFbB4FwoJePhxComzcv9RhnFd.png\"></p>\n<p>集成<strong>文本、图像、音频、视频</strong>等大模型能力，使智能体具备<strong>语义理解</strong>、<strong>视觉识别</strong>与<strong>跨模态推理</strong>能力，从而适配客服、监控、评估等多种使用场景。</p>\n<h3 id=\"强化学习与自动规划\"><a href=\"#强化学习与自动规划\" class=\"headerlink\" title=\"强化学习与自动规划\"></a>强化学习与自动规划</h3><p>部分平台支持<strong>强化学习（RL）和自动规划</strong>，让智能体在交互环境中通过试错优化策略，并结合 Transformer 等结构实现灵活决策。</p>\n<h3 id=\"多智能体协同\"><a href=\"#多智能体协同\" class=\"headerlink\" title=\"多智能体协同\"></a>多智能体协同</h3><p><img src=\"https://gitee.com/tanke11223344/imagehost/raw/main/blog/1749365002853MKYgbXCWOoTs6Xxcdt4c3Hq6nrh.png\" alt=\"1749365002853MKYgbXCWOoTs6Xxcdt4c3Hq6nrh.png\"></p>\n<p>通过 <strong>Agent-to-Agent</strong>（A2A）协议与<strong>模型上下文协议（MCP）</strong>，可实现智能体间的信息交换与任务协同，处理复杂的多步骤流程或跨系统业务。</p>\n<h3 id=\"仿真与现实桥接\"><a href=\"#仿真与现实桥接\" class=\"headerlink\" title=\"仿真与现实桥接\"></a>仿真与现实桥接</h3><p>利用 Habitat 等仿真平台进行<strong>大规模、快速迭代训练</strong>，并通过领域自适应技术（Domain Adaptation）将策略迁移到真实设备与场景中，提升智能体可靠性。</p>\n<h3 id=\"安全与治理\"><a href=\"#安全与治理\" class=\"headerlink\" title=\"安全与治理\"></a>安全与治理</h3><p>平台内置<strong>身份管理</strong>（Agent ID）、<strong>访问控制</strong>与<strong>审计日志</strong>，并整合 Microsoft Entra 与 Purview，帮助企业对智能体生命周期进行安全管控与合规管理。</p>\n<hr>\n<h2 id=\"智能体平台架构\"><a href=\"#智能体平台架构\" class=\"headerlink\" title=\"智能体平台架构\"></a>智能体平台架构</h2><p><img src=\"https://gitee.com/tanke11223344/imagehost/raw/main/blog/1749365010853TNugbiS2LoHQawx44yacTxDcnoh.png\" alt=\"1749365010853TNugbiS2LoHQawx44yacTxDcnoh.png\"></p>\n<h3 id=\"感知模块-Perception\"><a href=\"#感知模块-Perception\" class=\"headerlink\" title=\"感知模块 (Perception)\"></a>感知模块 (Perception)</h3><p>负责从多源数据（传感器、API、日志等）中抽取特征，包括计算机视觉、语音识别和传感器数据处理。</p>\n<h3 id=\"推理与规划-Reasoning-Planning\"><a href=\"#推理与规划-Reasoning-Planning\" class=\"headerlink\" title=\"推理与规划 (Reasoning &amp; Planning)\"></a>推理与规划 (Reasoning &amp; Planning)</h3><ul>\n<li><strong>规则推理：</strong> 基于专家系统或逻辑规则进行决策。</li>\n<li><strong>规划算法：</strong> 使用 A*、蒙特卡洛树搜索等方法，生成跨阶段任务执行方案。</li>\n</ul>\n<h3 id=\"学习模块-Learning\"><a href=\"#学习模块-Learning\" class=\"headerlink\" title=\"学习模块 (Learning)\"></a>学习模块 (Learning)</h3><p>集成机器学习与深度学习算法，实现：</p>\n<ul>\n<li>**强化学习 (RL)**：通过环境交互不断更新策略。</li>\n<li><strong>监督&#x2F;无监督学习</strong>：利用历史数据训练分类、聚类模型，支持情境感知与预测。</li>\n</ul>\n<h3 id=\"执行与接口-Execution-Interface\"><a href=\"#执行与接口-Execution-Interface\" class=\"headerlink\" title=\"执行与接口 (Execution &amp; Interface)\"></a>执行与接口 (Execution &amp; Interface)</h3><p>将决策转化为实际动作或 API 调用，包括机器人控制、网络请求与第三方服务集成。</p>\n<h3 id=\"通信与协调-Communication-Orchestration\"><a href=\"#通信与协调-Communication-Orchestration\" class=\"headerlink\" title=\"通信与协调 (Communication &amp; Orchestration)\"></a>通信与协调 (Communication &amp; Orchestration)</h3><ul>\n<li><strong>Agent Communication Languages (ACL)：</strong> 如 FIPA-ACL、KQML，实现异构智能体间的消息交换。</li>\n<li><strong>分布式调度：</strong> 基于消息队列、Service Mesh 或 Kubernetes 框架，实现智能体群的负载均衡与高可用。</li>\n</ul>\n<hr>\n<h2 id=\"典型应用案例\"><a href=\"#典型应用案例\" class=\"headerlink\" title=\"典型应用案例\"></a>典型应用案例</h2><p><img src=\"https://gitee.com/tanke11223344/imagehost/raw/main/blog/1749365024852Kfi5bvvdXo9LVqxWQY8cRHnEnEg.png\" alt=\"1749365024852Kfi5bvvdXo9LVqxWQY8cRHnEnEg.png\"></p>\n<p>AI （智能体、LLM、MCP）技术应用企业级解决方案</p>\n<ul>\n<li><strong>农田监测评价多模态智能体平台</strong>：集成无人机多光谱影像、传感器数据与知识图谱，实现精准种植决策和实时告警。</li>\n<li><strong>客服与外呼机器人</strong>：智能体融合语音识别、NLP 与知识检索，为金融、电商等行业提供 7×24 小时智能客服与自动外呼能力。</li>\n<li><strong>智能制造</strong>：基于视觉检测与动作规划智能体，实现生产线缺陷检测与柔性装配。</li>\n<li><strong>智慧城市</strong>：多智能体协同调度交通、安防与应急响应，提升城市管理效率。</li>\n</ul>\n<hr>\n<h2 id=\"挑战与未来趋势\"><a href=\"#挑战与未来趋势\" class=\"headerlink\" title=\"挑战与未来趋势\"></a>挑战与未来趋势</h2><ol>\n<li><strong>跨模态与大模型成本</strong>：多模态大模型资源消耗高，需优化推理效率与模型压缩。</li>\n<li><strong>可解释性与信任</strong>：智能体决策链路需透明化，增强可审计性与问责机制。</li>\n<li><strong>生态互操作</strong>：打造“Foundation Model + API”生态，实现多厂商模型与平台无缝对接。</li>\n<li><strong>行业定制化</strong>：向金融、医疗、制造等领域推出<strong>行业级智能体套件</strong>，提供预置组件与合规加固。</li>\n<li><strong>端-云协同</strong>：面向物联网与边缘场景，实现轻量化端侧智能体与云端训练&#x2F;管理协同。</li>\n</ol>\n<hr>\n<h1 id=\"总结\"><a href=\"#总结\" class=\"headerlink\" title=\"总结\"></a>总结</h1><p>智能体平台通过整合感知、推理、学习、执行与通信五大模块，依托机器学习、NLP、计算机视觉及强化学习等关键技术，构建可扩展、可协同的自主系统。商业化平台（如 Salesforce、NVIDIA、Google、AWS）与开源框架（JADE、Cougaar）各具特色，满足不同规模与场景需求。未来，随着多智能体协同、大动作模型、可解释性与行业纵深应用的推进，智能体平台将在生产制造、智能运维、自动驾驶等领域发挥更大价值。</p>\n<p>智能体平台是支持智能体（具有自主感知、决策与执行能力的软件实体）开发、部署与管理的综合系统，通常包含环境感知、知识表示、决策引擎、执行模块和可视化运维等组件。它们可面向企业级应用（如流程自动化、智能客服、行业专项智能体）或科研级需求（如虚拟仿真、机器人导航）。核心技术涵盖大模型集成、多模态感知、强化学习与规划、多智能体协同、元数据驱动低代码开发以及安全与治理机制。典型商业平台有科大讯飞的星辰 Agent、百度文心 AgentBuilder、微软的 Azure AI Foundry、字节跳动的 Coze 等，科研平台则包括 Meta&#x2F;普林斯顿的 Habitat (embodied AI) 和 TaskMatrix.AI 等。未来，随着 AI 基础模型能力的增强与多智能体生态的兴起，智能体平台将朝向“全链路低代码／无代码开发”、“AI 模型与 API 无缝编排”以及“行业专项化解决方案”方向演进。</p>\n<h1 id=\"参考文献\"><a href=\"#参考文献\" class=\"headerlink\" title=\"参考文献\"></a>参考文献</h1><blockquote>\n<ul>\n<li><a href=\"https://www.53ai.com/news/2407.html\">14 个 AI 智能体和应用开发平台，零代码构建 AI 应用</a></li>\n<li><a href=\"https://zhuanlan.zhihu.com/p/123456789\">2025 年 10 个不可错过的海外 AI Agent 构建平台</a></li>\n<li><a href=\"https://agents.baidu.com/\">文心智能体平台 AgentBuilder</a></li>\n<li><a href=\"https://zhuanlan.zhihu.com/p/987654321\">企业智能体平台公司有哪些？全面解析 2025 年十大主流 AI Agent 平台</a></li>\n<li><a href=\"https://www.sohu.com/a/123456789_999999\">智能体平台究竟啥样？为何成企业数字化转型关键？</a></li>\n<li><a href=\"https://www.betteryeah.com/\">AI 智能体开发平台 ｜ 企业级 Agent 应用快速构建 ｜BetterYeah</a></li>\n<li><a href=\"https://news.microsoft.com/\">微软 Build 2025：AI 智能体时代与开放智能体网络的构建</a></li>\n<li><a href=\"https://www.analyticsvidhya.com/blog/2023/07/what-is-an-ai-agent/\">什么是 AI 智能体？定义、示例和类型</a></li>\n<li><a href=\"https://www.163.com/dy/article/J1234567_001.html\">“农田监测评价多模态 AI 智能体平台”首次亮相</a></li>\n<li><a href=\"https://arxiv.org/abs/1904.01201\">Manolis Savva 等, “Habitat: A Platform for Embodied AI Research”</a></li>\n<li><a href=\"https://arxiv.org/abs/2303.16434\">TaskMatrix.AI: Completing Tasks by Connecting Foundation Models with Millions of APIs</a></li>\n</ul>\n</blockquote>\n"},{"title":"2025-07-03-拯救我的“高烧”战友——Y7000P 2024 版清灰换硅脂记录","date":"2025-07-02T16:00:00.000Z","_content":"# 2025-07-03-拯救我的“高烧”战友——Y7000P 2024 版清灰换硅脂记录\n\n> 参考资料\n> [【详细教程】联想拯救者 Y7000p 深度清灰 ＋ 更换硅脂_哔哩哔哩_bilibili](https://www.bilibili.com/video/BV1FJ411V7Ys/)\n>\n>\n> [【清灰教程】联想拯救者 Y7000p(2018 款)拆机清灰教程 + 更换硅脂_y7000p 拆机教程图解-CSDN 博客](https://blog.csdn.net/weixin_46050242/article/details/139240278)\n>\n>\n> [联想拯救者 Y7000P 拆机清灰学习_联想 y7000p 拆机图解-CSDN 博客](https://blog.csdn.net/Mr__Wind/article/details/103442556)\n\n## 一、前言：我的战友，你“发烧”了\n\n我的这台拯救者 Y7000P 2024 版，是去年入手的全能战友，陪我度过了无数个编码和游戏的日夜。然而，就在今天（2025 年 7 月 3 日），我发现它有点“力不从心”了。\n\n最明显的感受是，玩跑深度学习项目或同时开多个任务时，风扇噪音堪比直升机起飞，时不时就来一次大卡顿。我把手放到键盘上方，那温度简直能煎鸡蛋了。很显然，积攒了一年的灰尘和原厂硅脂的干涸，已经让这套散热系统不堪重负。\n\n为了让我的战友重回性能巅峰，也为了让自己的耳朵和手指能更舒服一些，我决定：自己动手，给它做一次彻底的“清肺手术”——清灰，并更换更高级的导热硅脂！\n\n## 二、准备工作：工欲善其事，必先利其器\n\n在开始之前，充分的准备是成功的关键。\n\n![17516136196281751613619085.png](https://tk-pichost-1325224430.cos.ap-chengdu.myqcloud.com/blog/17516136196281751613619085.png)\n\n这里找的网图，[图片来源](https://blog.csdn.net/weixin_46050242/article/details/139240278)\n\n- 工具类:\n- 精密螺丝刀套装: 主要用到了 PH0 和 PH1 规格的十字口。\n- 塑料撬棒/撬片: 拆机必备，避免大力出奇迹，把外壳刮花或弄断卡扣。\n- 镊子: 用来插拔细小的风扇排线，比手指好用一百倍。\n- 气吹/压缩空气罐 & 刷子: 清理灰尘的主力军。\n- 材料类:\n\n  - 高性能导热硅脂: 我选择了口碑很好的 利民 TF7。它的导热系数高达 14W/m·K，而且不导电，对于新手来说更安全。\n  - 硅脂清洁剂: 准备了浓度 99% 的异丙醇（IPA）和无绒布以及刮子，用来完美擦除顽固的旧硅脂。\n\n![17516136376231751613636825.png](https://tk-pichost-1325224430.cos.ap-chengdu.myqcloud.com/blog/17516136376231751613636825.png)\n\n## 三、实战操作：一场精密的“外科手术”\n\n### 步骤 1：卸下 D 面，初见真容\n\n关机并断开所有电源！将笔记本翻过来，D 面朝上。拧下所有能看到的螺丝。\n\n然后，用塑料撬片从散热口或边缘处找到一个突破口，小心地沿着缝隙划动，逐一解开内部的卡扣。\n\n### 步骤 2：拆卸散热模组\n\n首先用镊子小心地拔掉两个风扇的供电线并将 wifi 天线供电线的排线和散热模组分离。\n\n![17516136607611751613660651.png](https://tk-pichost-1325224430.cos.ap-chengdu.myqcloud.com/blog/17516136607611751613660651.png)\n![17516136736261751613672855.png](https://tk-pichost-1325224430.cos.ap-chengdu.myqcloud.com/blog/17516136736261751613672855.png)\n\nY7000P 2024 版散热模组一共有两个风扇螺丝,铜色的,以及 7 个弹簧螺丝(只需要拧松就可以了,拆不下来),可以分几次、对角地拧松它们，这样可以均匀释放核心的压力。\n\n图片中风扇螺丝我使用蓝色标号了,弹簧螺丝使用的红色标号\n\n> 注意 7 个弹簧螺丝都有对应的标号,2 号弹簧螺丝是被纸片遮住的,也要拧松才可以拆开散热模组\n\n### 步骤 3：深度清洁\n\n1. 清理灰尘： 用气吹和刷子，将散热鳍片和风扇叶片里积攒的“毛毡”彻底清理干净。看这成果，是不是很夸张？\n\n![17516137956231751613795475.png](https://tk-pichost-1325224430.cos.ap-chengdu.myqcloud.com/blog/17516137956231751613795475.png)\n![img](static/GIdvbfH6Wobib2xClkXcl3JYnah.jpg)\n\n出风口的塑料条也可以拆下来用刷子刷一下\n\n1. 擦除旧硅脂： 用无绒布蘸取异丙醇，耐心、温柔地擦拭 CPU、GPU 核心以及散热铜管接触面。直到它们光亮如镜，没有任何残留。\n\n![17516137886231751613787994.png](https://tk-pichost-1325224430.cos.ap-chengdu.myqcloud.com/blog/17516137886231751613787994.png)\n![17516137956231751613795475.png](https://tk-pichost-1325224430.cos.ap-chengdu.myqcloud.com/blog/17516137956231751613795475.png)\n\n![17516138366251751613836286.png](https://tk-pichost-1325224430.cos.ap-chengdu.myqcloud.com/blog/17516138366251751613836286.png)\n\n### 步骤 4：涂抹新硅脂\n\n激动人心的时刻来了！我采用的是“X 型交叉法”，在 CPU 和 GPU 核心上分别画一个 X。对于 Y7000P 这种长方形的核心，这种方法能保证散热器压下去后，硅脂均匀覆盖整个核心。记住，量不在多，薄而均匀即可。\n\n![17516138517681751613851630.png](https://tk-pichost-1325224430.cos.ap-chengdu.myqcloud.com/blog/17516138517681751613851630.png)\n\n### 步骤 5：完美复原\n\n现在，我们倒序操作：\n\n1. 将散热模组对准孔位装回，并按照螺丝旁标注的数字从小到大的顺序（1→2→3...），对角分次拧紧。\n2. 插回两个风扇的供电线。\n3. 重新整理 wifi 天线排线！\n4. 盖上后盖，先将卡扣一一按紧，再拧回所有螺丝。大功告成！\n\n## 四、成果检验：脱胎换骨，冷静如初！\n\n紧张又期待地按下开机键，电脑顺利点亮！接下来，是见证奇迹的时刻。\n\n![17516138696231751613869285.png](https://tk-pichost-1325224430.cos.ap-chengdu.myqcloud.com/blog/17516138696231751613869285.png)\n\n结果令人惊叹！直接上对比表格：\n\n<table>\n<tr>\n<td>测试项目 (Test Item)<br/></td><td>清灰换硅脂前 (Before)<br/></td><td>清灰换硅脂后 (After)<br/></td><td>温度变化 (Delta)<br/></td></tr>\n<tr>\n<td>待机温度 (CPU/GPU)<br/></td><td>45 °C / 42 °C<br/></td><td>35 °C / 33 °C<br/></td><td>↓10°C / ↓9°C<br/></td></tr>\n</table>\n\nGPU 温度也下降了 10℃。主观感受上，风扇虽然仍在高速运转，但噪音比之前柔和了不少，键盘区域也只是温热，不再烫手。\n\n如果你有任何问题，或者有更好的经验，欢迎在评论区留言交流！\n","source":"_posts/2025-07-03-拯救我的“高烧”战友——Y7000P 2024版清灰换硅脂记录.md","raw":"---\ntitle:  2025-07-03-拯救我的“高烧”战友——Y7000P 2024 版清灰换硅脂记录\ndate: 2025-07-03\ntags: \n    问题解决\n---\n# 2025-07-03-拯救我的“高烧”战友——Y7000P 2024 版清灰换硅脂记录\n\n> 参考资料\n> [【详细教程】联想拯救者 Y7000p 深度清灰 ＋ 更换硅脂_哔哩哔哩_bilibili](https://www.bilibili.com/video/BV1FJ411V7Ys/)\n>\n>\n> [【清灰教程】联想拯救者 Y7000p(2018 款)拆机清灰教程 + 更换硅脂_y7000p 拆机教程图解-CSDN 博客](https://blog.csdn.net/weixin_46050242/article/details/139240278)\n>\n>\n> [联想拯救者 Y7000P 拆机清灰学习_联想 y7000p 拆机图解-CSDN 博客](https://blog.csdn.net/Mr__Wind/article/details/103442556)\n\n## 一、前言：我的战友，你“发烧”了\n\n我的这台拯救者 Y7000P 2024 版，是去年入手的全能战友，陪我度过了无数个编码和游戏的日夜。然而，就在今天（2025 年 7 月 3 日），我发现它有点“力不从心”了。\n\n最明显的感受是，玩跑深度学习项目或同时开多个任务时，风扇噪音堪比直升机起飞，时不时就来一次大卡顿。我把手放到键盘上方，那温度简直能煎鸡蛋了。很显然，积攒了一年的灰尘和原厂硅脂的干涸，已经让这套散热系统不堪重负。\n\n为了让我的战友重回性能巅峰，也为了让自己的耳朵和手指能更舒服一些，我决定：自己动手，给它做一次彻底的“清肺手术”——清灰，并更换更高级的导热硅脂！\n\n## 二、准备工作：工欲善其事，必先利其器\n\n在开始之前，充分的准备是成功的关键。\n\n![17516136196281751613619085.png](https://tk-pichost-1325224430.cos.ap-chengdu.myqcloud.com/blog/17516136196281751613619085.png)\n\n这里找的网图，[图片来源](https://blog.csdn.net/weixin_46050242/article/details/139240278)\n\n- 工具类:\n- 精密螺丝刀套装: 主要用到了 PH0 和 PH1 规格的十字口。\n- 塑料撬棒/撬片: 拆机必备，避免大力出奇迹，把外壳刮花或弄断卡扣。\n- 镊子: 用来插拔细小的风扇排线，比手指好用一百倍。\n- 气吹/压缩空气罐 & 刷子: 清理灰尘的主力军。\n- 材料类:\n\n  - 高性能导热硅脂: 我选择了口碑很好的 利民 TF7。它的导热系数高达 14W/m·K，而且不导电，对于新手来说更安全。\n  - 硅脂清洁剂: 准备了浓度 99% 的异丙醇（IPA）和无绒布以及刮子，用来完美擦除顽固的旧硅脂。\n\n![17516136376231751613636825.png](https://tk-pichost-1325224430.cos.ap-chengdu.myqcloud.com/blog/17516136376231751613636825.png)\n\n## 三、实战操作：一场精密的“外科手术”\n\n### 步骤 1：卸下 D 面，初见真容\n\n关机并断开所有电源！将笔记本翻过来，D 面朝上。拧下所有能看到的螺丝。\n\n然后，用塑料撬片从散热口或边缘处找到一个突破口，小心地沿着缝隙划动，逐一解开内部的卡扣。\n\n### 步骤 2：拆卸散热模组\n\n首先用镊子小心地拔掉两个风扇的供电线并将 wifi 天线供电线的排线和散热模组分离。\n\n![17516136607611751613660651.png](https://tk-pichost-1325224430.cos.ap-chengdu.myqcloud.com/blog/17516136607611751613660651.png)\n![17516136736261751613672855.png](https://tk-pichost-1325224430.cos.ap-chengdu.myqcloud.com/blog/17516136736261751613672855.png)\n\nY7000P 2024 版散热模组一共有两个风扇螺丝,铜色的,以及 7 个弹簧螺丝(只需要拧松就可以了,拆不下来),可以分几次、对角地拧松它们，这样可以均匀释放核心的压力。\n\n图片中风扇螺丝我使用蓝色标号了,弹簧螺丝使用的红色标号\n\n> 注意 7 个弹簧螺丝都有对应的标号,2 号弹簧螺丝是被纸片遮住的,也要拧松才可以拆开散热模组\n\n### 步骤 3：深度清洁\n\n1. 清理灰尘： 用气吹和刷子，将散热鳍片和风扇叶片里积攒的“毛毡”彻底清理干净。看这成果，是不是很夸张？\n\n![17516137956231751613795475.png](https://tk-pichost-1325224430.cos.ap-chengdu.myqcloud.com/blog/17516137956231751613795475.png)\n![img](static/GIdvbfH6Wobib2xClkXcl3JYnah.jpg)\n\n出风口的塑料条也可以拆下来用刷子刷一下\n\n1. 擦除旧硅脂： 用无绒布蘸取异丙醇，耐心、温柔地擦拭 CPU、GPU 核心以及散热铜管接触面。直到它们光亮如镜，没有任何残留。\n\n![17516137886231751613787994.png](https://tk-pichost-1325224430.cos.ap-chengdu.myqcloud.com/blog/17516137886231751613787994.png)\n![17516137956231751613795475.png](https://tk-pichost-1325224430.cos.ap-chengdu.myqcloud.com/blog/17516137956231751613795475.png)\n\n![17516138366251751613836286.png](https://tk-pichost-1325224430.cos.ap-chengdu.myqcloud.com/blog/17516138366251751613836286.png)\n\n### 步骤 4：涂抹新硅脂\n\n激动人心的时刻来了！我采用的是“X 型交叉法”，在 CPU 和 GPU 核心上分别画一个 X。对于 Y7000P 这种长方形的核心，这种方法能保证散热器压下去后，硅脂均匀覆盖整个核心。记住，量不在多，薄而均匀即可。\n\n![17516138517681751613851630.png](https://tk-pichost-1325224430.cos.ap-chengdu.myqcloud.com/blog/17516138517681751613851630.png)\n\n### 步骤 5：完美复原\n\n现在，我们倒序操作：\n\n1. 将散热模组对准孔位装回，并按照螺丝旁标注的数字从小到大的顺序（1→2→3...），对角分次拧紧。\n2. 插回两个风扇的供电线。\n3. 重新整理 wifi 天线排线！\n4. 盖上后盖，先将卡扣一一按紧，再拧回所有螺丝。大功告成！\n\n## 四、成果检验：脱胎换骨，冷静如初！\n\n紧张又期待地按下开机键，电脑顺利点亮！接下来，是见证奇迹的时刻。\n\n![17516138696231751613869285.png](https://tk-pichost-1325224430.cos.ap-chengdu.myqcloud.com/blog/17516138696231751613869285.png)\n\n结果令人惊叹！直接上对比表格：\n\n<table>\n<tr>\n<td>测试项目 (Test Item)<br/></td><td>清灰换硅脂前 (Before)<br/></td><td>清灰换硅脂后 (After)<br/></td><td>温度变化 (Delta)<br/></td></tr>\n<tr>\n<td>待机温度 (CPU/GPU)<br/></td><td>45 °C / 42 °C<br/></td><td>35 °C / 33 °C<br/></td><td>↓10°C / ↓9°C<br/></td></tr>\n</table>\n\nGPU 温度也下降了 10℃。主观感受上，风扇虽然仍在高速运转，但噪音比之前柔和了不少，键盘区域也只是温热，不再烫手。\n\n如果你有任何问题，或者有更好的经验，欢迎在评论区留言交流！\n","slug":"2025-07-03-拯救我的“高烧”战友——Y7000P 2024版清灰换硅脂记录","published":1,"updated":"2025-09-26T12:18:26.084Z","_id":"cmg0saj4k0039jm8n1fr9gest","comments":1,"layout":"post","photos":[],"content":"<h1 id=\"2025-07-03-拯救我的“高烧”战友——Y7000P-2024-版清灰换硅脂记录\"><a href=\"#2025-07-03-拯救我的“高烧”战友——Y7000P-2024-版清灰换硅脂记录\" class=\"headerlink\" title=\"2025-07-03-拯救我的“高烧”战友——Y7000P 2024 版清灰换硅脂记录\"></a>2025-07-03-拯救我的“高烧”战友——Y7000P 2024 版清灰换硅脂记录</h1><blockquote>\n<p>参考资料<br><a href=\"https://www.bilibili.com/video/BV1FJ411V7Ys/\">【详细教程】联想拯救者 Y7000p 深度清灰 ＋ 更换硅脂_哔哩哔哩_bilibili</a></p>\n<p><a href=\"https://blog.csdn.net/weixin_46050242/article/details/139240278\">【清灰教程】联想拯救者 Y7000p(2018 款)拆机清灰教程 + 更换硅脂_y7000p 拆机教程图解-CSDN 博客</a></p>\n<p><a href=\"https://blog.csdn.net/Mr__Wind/article/details/103442556\">联想拯救者 Y7000P 拆机清灰学习_联想 y7000p 拆机图解-CSDN 博客</a></p>\n</blockquote>\n<h2 id=\"一、前言：我的战友，你“发烧”了\"><a href=\"#一、前言：我的战友，你“发烧”了\" class=\"headerlink\" title=\"一、前言：我的战友，你“发烧”了\"></a>一、前言：我的战友，你“发烧”了</h2><p>我的这台拯救者 Y7000P 2024 版，是去年入手的全能战友，陪我度过了无数个编码和游戏的日夜。然而，就在今天（2025 年 7 月 3 日），我发现它有点“力不从心”了。</p>\n<p>最明显的感受是，玩跑深度学习项目或同时开多个任务时，风扇噪音堪比直升机起飞，时不时就来一次大卡顿。我把手放到键盘上方，那温度简直能煎鸡蛋了。很显然，积攒了一年的灰尘和原厂硅脂的干涸，已经让这套散热系统不堪重负。</p>\n<p>为了让我的战友重回性能巅峰，也为了让自己的耳朵和手指能更舒服一些，我决定：自己动手，给它做一次彻底的“清肺手术”——清灰，并更换更高级的导热硅脂！</p>\n<h2 id=\"二、准备工作：工欲善其事，必先利其器\"><a href=\"#二、准备工作：工欲善其事，必先利其器\" class=\"headerlink\" title=\"二、准备工作：工欲善其事，必先利其器\"></a>二、准备工作：工欲善其事，必先利其器</h2><p>在开始之前，充分的准备是成功的关键。</p>\n<p><img src=\"https://tk-pichost-1325224430.cos.ap-chengdu.myqcloud.com/blog/17516136196281751613619085.png\" alt=\"17516136196281751613619085.png\"></p>\n<p>这里找的网图，<a href=\"https://blog.csdn.net/weixin_46050242/article/details/139240278\">图片来源</a></p>\n<ul>\n<li><p>工具类:</p>\n</li>\n<li><p>精密螺丝刀套装: 主要用到了 PH0 和 PH1 规格的十字口。</p>\n</li>\n<li><p>塑料撬棒&#x2F;撬片: 拆机必备，避免大力出奇迹，把外壳刮花或弄断卡扣。</p>\n</li>\n<li><p>镊子: 用来插拔细小的风扇排线，比手指好用一百倍。</p>\n</li>\n<li><p>气吹&#x2F;压缩空气罐 &amp; 刷子: 清理灰尘的主力军。</p>\n</li>\n<li><p>材料类:</p>\n<ul>\n<li>高性能导热硅脂: 我选择了口碑很好的 利民 TF7。它的导热系数高达 14W&#x2F;m·K，而且不导电，对于新手来说更安全。</li>\n<li>硅脂清洁剂: 准备了浓度 99% 的异丙醇（IPA）和无绒布以及刮子，用来完美擦除顽固的旧硅脂。</li>\n</ul>\n</li>\n</ul>\n<p><img src=\"https://tk-pichost-1325224430.cos.ap-chengdu.myqcloud.com/blog/17516136376231751613636825.png\" alt=\"17516136376231751613636825.png\"></p>\n<h2 id=\"三、实战操作：一场精密的“外科手术”\"><a href=\"#三、实战操作：一场精密的“外科手术”\" class=\"headerlink\" title=\"三、实战操作：一场精密的“外科手术”\"></a>三、实战操作：一场精密的“外科手术”</h2><h3 id=\"步骤-1：卸下-D-面，初见真容\"><a href=\"#步骤-1：卸下-D-面，初见真容\" class=\"headerlink\" title=\"步骤 1：卸下 D 面，初见真容\"></a>步骤 1：卸下 D 面，初见真容</h3><p>关机并断开所有电源！将笔记本翻过来，D 面朝上。拧下所有能看到的螺丝。</p>\n<p>然后，用塑料撬片从散热口或边缘处找到一个突破口，小心地沿着缝隙划动，逐一解开内部的卡扣。</p>\n<h3 id=\"步骤-2：拆卸散热模组\"><a href=\"#步骤-2：拆卸散热模组\" class=\"headerlink\" title=\"步骤 2：拆卸散热模组\"></a>步骤 2：拆卸散热模组</h3><p>首先用镊子小心地拔掉两个风扇的供电线并将 wifi 天线供电线的排线和散热模组分离。</p>\n<p><img src=\"https://tk-pichost-1325224430.cos.ap-chengdu.myqcloud.com/blog/17516136607611751613660651.png\" alt=\"17516136607611751613660651.png\"><br><img src=\"https://tk-pichost-1325224430.cos.ap-chengdu.myqcloud.com/blog/17516136736261751613672855.png\" alt=\"17516136736261751613672855.png\"></p>\n<p>Y7000P 2024 版散热模组一共有两个风扇螺丝,铜色的,以及 7 个弹簧螺丝(只需要拧松就可以了,拆不下来),可以分几次、对角地拧松它们，这样可以均匀释放核心的压力。</p>\n<p>图片中风扇螺丝我使用蓝色标号了,弹簧螺丝使用的红色标号</p>\n<blockquote>\n<p>注意 7 个弹簧螺丝都有对应的标号,2 号弹簧螺丝是被纸片遮住的,也要拧松才可以拆开散热模组</p>\n</blockquote>\n<h3 id=\"步骤-3：深度清洁\"><a href=\"#步骤-3：深度清洁\" class=\"headerlink\" title=\"步骤 3：深度清洁\"></a>步骤 3：深度清洁</h3><ol>\n<li>清理灰尘： 用气吹和刷子，将散热鳍片和风扇叶片里积攒的“毛毡”彻底清理干净。看这成果，是不是很夸张？</li>\n</ol>\n<p><img src=\"https://tk-pichost-1325224430.cos.ap-chengdu.myqcloud.com/blog/17516137956231751613795475.png\" alt=\"17516137956231751613795475.png\"><br><img src=\"/static/GIdvbfH6Wobib2xClkXcl3JYnah.jpg\" alt=\"img\"></p>\n<p>出风口的塑料条也可以拆下来用刷子刷一下</p>\n<ol>\n<li>擦除旧硅脂： 用无绒布蘸取异丙醇，耐心、温柔地擦拭 CPU、GPU 核心以及散热铜管接触面。直到它们光亮如镜，没有任何残留。</li>\n</ol>\n<p><img src=\"https://tk-pichost-1325224430.cos.ap-chengdu.myqcloud.com/blog/17516137886231751613787994.png\" alt=\"17516137886231751613787994.png\"><br><img src=\"https://tk-pichost-1325224430.cos.ap-chengdu.myqcloud.com/blog/17516137956231751613795475.png\" alt=\"17516137956231751613795475.png\"></p>\n<p><img src=\"https://tk-pichost-1325224430.cos.ap-chengdu.myqcloud.com/blog/17516138366251751613836286.png\" alt=\"17516138366251751613836286.png\"></p>\n<h3 id=\"步骤-4：涂抹新硅脂\"><a href=\"#步骤-4：涂抹新硅脂\" class=\"headerlink\" title=\"步骤 4：涂抹新硅脂\"></a>步骤 4：涂抹新硅脂</h3><p>激动人心的时刻来了！我采用的是“X 型交叉法”，在 CPU 和 GPU 核心上分别画一个 X。对于 Y7000P 这种长方形的核心，这种方法能保证散热器压下去后，硅脂均匀覆盖整个核心。记住，量不在多，薄而均匀即可。</p>\n<p><img src=\"https://tk-pichost-1325224430.cos.ap-chengdu.myqcloud.com/blog/17516138517681751613851630.png\" alt=\"17516138517681751613851630.png\"></p>\n<h3 id=\"步骤-5：完美复原\"><a href=\"#步骤-5：完美复原\" class=\"headerlink\" title=\"步骤 5：完美复原\"></a>步骤 5：完美复原</h3><p>现在，我们倒序操作：</p>\n<ol>\n<li>将散热模组对准孔位装回，并按照螺丝旁标注的数字从小到大的顺序（1→2→3…），对角分次拧紧。</li>\n<li>插回两个风扇的供电线。</li>\n<li>重新整理 wifi 天线排线！</li>\n<li>盖上后盖，先将卡扣一一按紧，再拧回所有螺丝。大功告成！</li>\n</ol>\n<h2 id=\"四、成果检验：脱胎换骨，冷静如初！\"><a href=\"#四、成果检验：脱胎换骨，冷静如初！\" class=\"headerlink\" title=\"四、成果检验：脱胎换骨，冷静如初！\"></a>四、成果检验：脱胎换骨，冷静如初！</h2><p>紧张又期待地按下开机键，电脑顺利点亮！接下来，是见证奇迹的时刻。</p>\n<p><img src=\"https://tk-pichost-1325224430.cos.ap-chengdu.myqcloud.com/blog/17516138696231751613869285.png\" alt=\"17516138696231751613869285.png\"></p>\n<p>结果令人惊叹！直接上对比表格：</p>\n<table>\n<tr>\n<td>测试项目 (Test Item)<br/></td><td>清灰换硅脂前 (Before)<br/></td><td>清灰换硅脂后 (After)<br/></td><td>温度变化 (Delta)<br/></td></tr>\n<tr>\n<td>待机温度 (CPU/GPU)<br/></td><td>45 °C / 42 °C<br/></td><td>35 °C / 33 °C<br/></td><td>↓10°C / ↓9°C<br/></td></tr>\n</table>\n\n<p>GPU 温度也下降了 10℃。主观感受上，风扇虽然仍在高速运转，但噪音比之前柔和了不少，键盘区域也只是温热，不再烫手。</p>\n<p>如果你有任何问题，或者有更好的经验，欢迎在评论区留言交流！</p>\n","excerpt":"","more":"<h1 id=\"2025-07-03-拯救我的“高烧”战友——Y7000P-2024-版清灰换硅脂记录\"><a href=\"#2025-07-03-拯救我的“高烧”战友——Y7000P-2024-版清灰换硅脂记录\" class=\"headerlink\" title=\"2025-07-03-拯救我的“高烧”战友——Y7000P 2024 版清灰换硅脂记录\"></a>2025-07-03-拯救我的“高烧”战友——Y7000P 2024 版清灰换硅脂记录</h1><blockquote>\n<p>参考资料<br><a href=\"https://www.bilibili.com/video/BV1FJ411V7Ys/\">【详细教程】联想拯救者 Y7000p 深度清灰 ＋ 更换硅脂_哔哩哔哩_bilibili</a></p>\n<p><a href=\"https://blog.csdn.net/weixin_46050242/article/details/139240278\">【清灰教程】联想拯救者 Y7000p(2018 款)拆机清灰教程 + 更换硅脂_y7000p 拆机教程图解-CSDN 博客</a></p>\n<p><a href=\"https://blog.csdn.net/Mr__Wind/article/details/103442556\">联想拯救者 Y7000P 拆机清灰学习_联想 y7000p 拆机图解-CSDN 博客</a></p>\n</blockquote>\n<h2 id=\"一、前言：我的战友，你“发烧”了\"><a href=\"#一、前言：我的战友，你“发烧”了\" class=\"headerlink\" title=\"一、前言：我的战友，你“发烧”了\"></a>一、前言：我的战友，你“发烧”了</h2><p>我的这台拯救者 Y7000P 2024 版，是去年入手的全能战友，陪我度过了无数个编码和游戏的日夜。然而，就在今天（2025 年 7 月 3 日），我发现它有点“力不从心”了。</p>\n<p>最明显的感受是，玩跑深度学习项目或同时开多个任务时，风扇噪音堪比直升机起飞，时不时就来一次大卡顿。我把手放到键盘上方，那温度简直能煎鸡蛋了。很显然，积攒了一年的灰尘和原厂硅脂的干涸，已经让这套散热系统不堪重负。</p>\n<p>为了让我的战友重回性能巅峰，也为了让自己的耳朵和手指能更舒服一些，我决定：自己动手，给它做一次彻底的“清肺手术”——清灰，并更换更高级的导热硅脂！</p>\n<h2 id=\"二、准备工作：工欲善其事，必先利其器\"><a href=\"#二、准备工作：工欲善其事，必先利其器\" class=\"headerlink\" title=\"二、准备工作：工欲善其事，必先利其器\"></a>二、准备工作：工欲善其事，必先利其器</h2><p>在开始之前，充分的准备是成功的关键。</p>\n<p><img src=\"https://tk-pichost-1325224430.cos.ap-chengdu.myqcloud.com/blog/17516136196281751613619085.png\" alt=\"17516136196281751613619085.png\"></p>\n<p>这里找的网图，<a href=\"https://blog.csdn.net/weixin_46050242/article/details/139240278\">图片来源</a></p>\n<ul>\n<li><p>工具类:</p>\n</li>\n<li><p>精密螺丝刀套装: 主要用到了 PH0 和 PH1 规格的十字口。</p>\n</li>\n<li><p>塑料撬棒&#x2F;撬片: 拆机必备，避免大力出奇迹，把外壳刮花或弄断卡扣。</p>\n</li>\n<li><p>镊子: 用来插拔细小的风扇排线，比手指好用一百倍。</p>\n</li>\n<li><p>气吹&#x2F;压缩空气罐 &amp; 刷子: 清理灰尘的主力军。</p>\n</li>\n<li><p>材料类:</p>\n<ul>\n<li>高性能导热硅脂: 我选择了口碑很好的 利民 TF7。它的导热系数高达 14W&#x2F;m·K，而且不导电，对于新手来说更安全。</li>\n<li>硅脂清洁剂: 准备了浓度 99% 的异丙醇（IPA）和无绒布以及刮子，用来完美擦除顽固的旧硅脂。</li>\n</ul>\n</li>\n</ul>\n<p><img src=\"https://tk-pichost-1325224430.cos.ap-chengdu.myqcloud.com/blog/17516136376231751613636825.png\" alt=\"17516136376231751613636825.png\"></p>\n<h2 id=\"三、实战操作：一场精密的“外科手术”\"><a href=\"#三、实战操作：一场精密的“外科手术”\" class=\"headerlink\" title=\"三、实战操作：一场精密的“外科手术”\"></a>三、实战操作：一场精密的“外科手术”</h2><h3 id=\"步骤-1：卸下-D-面，初见真容\"><a href=\"#步骤-1：卸下-D-面，初见真容\" class=\"headerlink\" title=\"步骤 1：卸下 D 面，初见真容\"></a>步骤 1：卸下 D 面，初见真容</h3><p>关机并断开所有电源！将笔记本翻过来，D 面朝上。拧下所有能看到的螺丝。</p>\n<p>然后，用塑料撬片从散热口或边缘处找到一个突破口，小心地沿着缝隙划动，逐一解开内部的卡扣。</p>\n<h3 id=\"步骤-2：拆卸散热模组\"><a href=\"#步骤-2：拆卸散热模组\" class=\"headerlink\" title=\"步骤 2：拆卸散热模组\"></a>步骤 2：拆卸散热模组</h3><p>首先用镊子小心地拔掉两个风扇的供电线并将 wifi 天线供电线的排线和散热模组分离。</p>\n<p><img src=\"https://tk-pichost-1325224430.cos.ap-chengdu.myqcloud.com/blog/17516136607611751613660651.png\" alt=\"17516136607611751613660651.png\"><br><img src=\"https://tk-pichost-1325224430.cos.ap-chengdu.myqcloud.com/blog/17516136736261751613672855.png\" alt=\"17516136736261751613672855.png\"></p>\n<p>Y7000P 2024 版散热模组一共有两个风扇螺丝,铜色的,以及 7 个弹簧螺丝(只需要拧松就可以了,拆不下来),可以分几次、对角地拧松它们，这样可以均匀释放核心的压力。</p>\n<p>图片中风扇螺丝我使用蓝色标号了,弹簧螺丝使用的红色标号</p>\n<blockquote>\n<p>注意 7 个弹簧螺丝都有对应的标号,2 号弹簧螺丝是被纸片遮住的,也要拧松才可以拆开散热模组</p>\n</blockquote>\n<h3 id=\"步骤-3：深度清洁\"><a href=\"#步骤-3：深度清洁\" class=\"headerlink\" title=\"步骤 3：深度清洁\"></a>步骤 3：深度清洁</h3><ol>\n<li>清理灰尘： 用气吹和刷子，将散热鳍片和风扇叶片里积攒的“毛毡”彻底清理干净。看这成果，是不是很夸张？</li>\n</ol>\n<p><img src=\"https://tk-pichost-1325224430.cos.ap-chengdu.myqcloud.com/blog/17516137956231751613795475.png\" alt=\"17516137956231751613795475.png\"><br><img src=\"/static/GIdvbfH6Wobib2xClkXcl3JYnah.jpg\" alt=\"img\"></p>\n<p>出风口的塑料条也可以拆下来用刷子刷一下</p>\n<ol>\n<li>擦除旧硅脂： 用无绒布蘸取异丙醇，耐心、温柔地擦拭 CPU、GPU 核心以及散热铜管接触面。直到它们光亮如镜，没有任何残留。</li>\n</ol>\n<p><img src=\"https://tk-pichost-1325224430.cos.ap-chengdu.myqcloud.com/blog/17516137886231751613787994.png\" alt=\"17516137886231751613787994.png\"><br><img src=\"https://tk-pichost-1325224430.cos.ap-chengdu.myqcloud.com/blog/17516137956231751613795475.png\" alt=\"17516137956231751613795475.png\"></p>\n<p><img src=\"https://tk-pichost-1325224430.cos.ap-chengdu.myqcloud.com/blog/17516138366251751613836286.png\" alt=\"17516138366251751613836286.png\"></p>\n<h3 id=\"步骤-4：涂抹新硅脂\"><a href=\"#步骤-4：涂抹新硅脂\" class=\"headerlink\" title=\"步骤 4：涂抹新硅脂\"></a>步骤 4：涂抹新硅脂</h3><p>激动人心的时刻来了！我采用的是“X 型交叉法”，在 CPU 和 GPU 核心上分别画一个 X。对于 Y7000P 这种长方形的核心，这种方法能保证散热器压下去后，硅脂均匀覆盖整个核心。记住，量不在多，薄而均匀即可。</p>\n<p><img src=\"https://tk-pichost-1325224430.cos.ap-chengdu.myqcloud.com/blog/17516138517681751613851630.png\" alt=\"17516138517681751613851630.png\"></p>\n<h3 id=\"步骤-5：完美复原\"><a href=\"#步骤-5：完美复原\" class=\"headerlink\" title=\"步骤 5：完美复原\"></a>步骤 5：完美复原</h3><p>现在，我们倒序操作：</p>\n<ol>\n<li>将散热模组对准孔位装回，并按照螺丝旁标注的数字从小到大的顺序（1→2→3…），对角分次拧紧。</li>\n<li>插回两个风扇的供电线。</li>\n<li>重新整理 wifi 天线排线！</li>\n<li>盖上后盖，先将卡扣一一按紧，再拧回所有螺丝。大功告成！</li>\n</ol>\n<h2 id=\"四、成果检验：脱胎换骨，冷静如初！\"><a href=\"#四、成果检验：脱胎换骨，冷静如初！\" class=\"headerlink\" title=\"四、成果检验：脱胎换骨，冷静如初！\"></a>四、成果检验：脱胎换骨，冷静如初！</h2><p>紧张又期待地按下开机键，电脑顺利点亮！接下来，是见证奇迹的时刻。</p>\n<p><img src=\"https://tk-pichost-1325224430.cos.ap-chengdu.myqcloud.com/blog/17516138696231751613869285.png\" alt=\"17516138696231751613869285.png\"></p>\n<p>结果令人惊叹！直接上对比表格：</p>\n<table>\n<tr>\n<td>测试项目 (Test Item)<br/></td><td>清灰换硅脂前 (Before)<br/></td><td>清灰换硅脂后 (After)<br/></td><td>温度变化 (Delta)<br/></td></tr>\n<tr>\n<td>待机温度 (CPU/GPU)<br/></td><td>45 °C / 42 °C<br/></td><td>35 °C / 33 °C<br/></td><td>↓10°C / ↓9°C<br/></td></tr>\n</table>\n\n<p>GPU 温度也下降了 10℃。主观感受上，风扇虽然仍在高速运转，但噪音比之前柔和了不少，键盘区域也只是温热，不再烫手。</p>\n<p>如果你有任何问题，或者有更好的经验，欢迎在评论区留言交流！</p>\n"}],"PostAsset":[],"PostCategory":[],"PostTag":[{"post_id":"cmg0saj3h0000jm8nbfxug700","tag_id":"cmg0saj3k0002jm8n376dfv0m","_id":"cmg0saj3l0004jm8n4c1whs35"},{"post_id":"cmg0saj3j0001jm8n9h6fdbws","tag_id":"cmg0saj3l0003jm8n3zt81cp5","_id":"cmg0saj3l0005jm8na3x81ka2"},{"post_id":"cmg0saj3s0006jm8n8yfb4swh","tag_id":"cmg0saj3t0008jm8n8d866ssj","_id":"cmg0saj3v000djm8n4t3r41vz"},{"post_id":"cmg0saj3s0007jm8n2trg9ka4","tag_id":"cmg0saj3v000cjm8nc802e081","_id":"cmg0saj3x000ijm8n7p1b2539"},{"post_id":"cmg0saj3u0009jm8ndroo672p","tag_id":"cmg0saj3t0008jm8n8d866ssj","_id":"cmg0saj3y000mjm8nhw4k9gu0"},{"post_id":"cmg0saj3x000jjm8n9uu46n7r","tag_id":"cmg0saj3v000cjm8nc802e081","_id":"cmg0saj3y000ojm8n51zu2lir"},{"post_id":"cmg0saj3u000ajm8ncay9g24a","tag_id":"cmg0saj3v000cjm8nc802e081","_id":"cmg0saj3z000rjm8n1h3ebsm1"},{"post_id":"cmg0saj3y000njm8n57u1fdqd","tag_id":"cmg0saj3k0002jm8n376dfv0m","_id":"cmg0saj3z000tjm8n368ofop8"},{"post_id":"cmg0saj3v000bjm8n7j0f6rda","tag_id":"cmg0saj3v000cjm8nc802e081","_id":"cmg0saj40000wjm8n6v98hucf"},{"post_id":"cmg0saj3w000ejm8nhz3b48m1","tag_id":"cmg0saj3z000ujm8n2ykrfp92","_id":"cmg0saj420010jm8nf5c84o19"},{"post_id":"cmg0saj40000xjm8n8rxx6oup","tag_id":"cmg0saj3k0002jm8n376dfv0m","_id":"cmg0saj420012jm8nd3kt6yb5"},{"post_id":"cmg0saj40000zjm8n4fs7ddod","tag_id":"cmg0saj3t0008jm8n8d866ssj","_id":"cmg0saj420015jm8n0ewtgdan"},{"post_id":"cmg0saj3w000fjm8n1xk13pnn","tag_id":"cmg0saj3z000ujm8n2ykrfp92","_id":"cmg0saj430017jm8n1e1whm78"},{"post_id":"cmg0saj420011jm8nd3n6bjdx","tag_id":"cmg0saj3k0002jm8n376dfv0m","_id":"cmg0saj43001ajm8nh3xd3446"},{"post_id":"cmg0saj3x000hjm8n2ky48hbg","tag_id":"cmg0saj3z000ujm8n2ykrfp92","_id":"cmg0saj43001cjm8n71oxbqex"},{"post_id":"cmg0saj420016jm8nc7to1duv","tag_id":"cmg0saj3t0008jm8n8d866ssj","_id":"cmg0saj44001fjm8n8rm5gw1f"},{"post_id":"cmg0saj3y000ljm8nfu0m5rtj","tag_id":"cmg0saj3z000ujm8n2ykrfp92","_id":"cmg0saj44001hjm8n6mxc0tw9"},{"post_id":"cmg0saj3z000qjm8n7dlh75o4","tag_id":"cmg0saj3z000ujm8n2ykrfp92","_id":"cmg0saj45001kjm8n42mmgnln"},{"post_id":"cmg0saj44001gjm8n0mtug5o9","tag_id":"cmg0saj3t0008jm8n8d866ssj","_id":"cmg0saj48001mjm8n1xct5onx"},{"post_id":"cmg0saj3z000sjm8nek8nbyjl","tag_id":"cmg0saj3z000ujm8n2ykrfp92","_id":"cmg0saj48001pjm8n3va6dexl"},{"post_id":"cmg0saj48001ojm8n8qrh4t33","tag_id":"cmg0saj3k0002jm8n376dfv0m","_id":"cmg0saj49001rjm8n89oj3786"},{"post_id":"cmg0saj3z000vjm8n84wvhjg0","tag_id":"cmg0saj48001njm8ngu9gc0qs","_id":"cmg0saj49001ujm8n6og9hwnd"},{"post_id":"cmg0saj49001vjm8nbyjkcykv","tag_id":"cmg0saj49001sjm8n00ra9jet","_id":"cmg0saj4a001yjm8n33l0eiar"},{"post_id":"cmg0saj420014jm8n4lste4xu","tag_id":"cmg0saj49001sjm8n00ra9jet","_id":"cmg0saj4a0020jm8n8ez31s7y"},{"post_id":"cmg0saj4a001zjm8nberm4y8i","tag_id":"cmg0saj3t0008jm8n8d866ssj","_id":"cmg0saj4a0023jm8nfkgk6f97"},{"post_id":"cmg0saj430019jm8ndzcfhqh2","tag_id":"cmg0saj49001sjm8n00ra9jet","_id":"cmg0saj4b0025jm8n7xba3g5f"},{"post_id":"cmg0saj4a0021jm8nah3ebhz0","tag_id":"cmg0saj49001sjm8n00ra9jet","_id":"cmg0saj4d0028jm8n5dvh226n"},{"post_id":"cmg0saj43001bjm8nbr3g7rjx","tag_id":"cmg0saj48001njm8ngu9gc0qs","_id":"cmg0saj4d002ajm8ncyli4jce"},{"post_id":"cmg0saj4b0026jm8nc6xhhaon","tag_id":"cmg0saj3v000cjm8nc802e081","_id":"cmg0saj4d002djm8nh3lfhqwv"},{"post_id":"cmg0saj4d0029jm8ng5r48sfr","tag_id":"cmg0saj49001sjm8n00ra9jet","_id":"cmg0saj4e002fjm8n9wmoasfb"},{"post_id":"cmg0saj44001ejm8nfy59a396","tag_id":"cmg0saj49001sjm8n00ra9jet","_id":"cmg0saj4e002ijm8n5mir693r"},{"post_id":"cmg0saj4d002bjm8n2twrh7tq","tag_id":"cmg0saj48001njm8ngu9gc0qs","_id":"cmg0saj4e002kjm8nfuseb3ef"},{"post_id":"cmg0saj4d002ejm8nfuhi7w15","tag_id":"cmg0saj49001sjm8n00ra9jet","_id":"cmg0saj4f002njm8n7i1dd035"},{"post_id":"cmg0saj44001jjm8n3jyof06c","tag_id":"cmg0saj49001sjm8n00ra9jet","_id":"cmg0saj4f002pjm8n0tag3o51"},{"post_id":"cmg0saj4e002gjm8n8zojhrtk","tag_id":"cmg0saj49001sjm8n00ra9jet","_id":"cmg0saj4f002sjm8n7ra74471"},{"post_id":"cmg0saj4e002jjm8n2u8c20bb","tag_id":"cmg0saj49001sjm8n00ra9jet","_id":"cmg0saj4g002ujm8ncrgh7gub"},{"post_id":"cmg0saj45001ljm8n7c6v7gmg","tag_id":"cmg0saj49001sjm8n00ra9jet","_id":"cmg0saj4g002xjm8n46lcg4qp"},{"post_id":"cmg0saj4e002ljm8ndsa89eff","tag_id":"cmg0saj49001sjm8n00ra9jet","_id":"cmg0saj4g002yjm8n3viscffx"},{"post_id":"cmg0saj4f002ojm8n0a1pabro","tag_id":"cmg0saj49001sjm8n00ra9jet","_id":"cmg0saj4g0030jm8n364uftr7"},{"post_id":"cmg0saj48001qjm8n574acpl7","tag_id":"cmg0saj49001sjm8n00ra9jet","_id":"cmg0saj4h0031jm8n726rfv4e"},{"post_id":"cmg0saj4f002qjm8n1gjhcb58","tag_id":"cmg0saj3k0002jm8n376dfv0m","_id":"cmg0saj4h0032jm8n6t2khhxa"},{"post_id":"cmg0saj4g002tjm8n4yhwarji","tag_id":"cmg0saj49001sjm8n00ra9jet","_id":"cmg0saj4h0033jm8n15eoffmf"},{"post_id":"cmg0saj49001tjm8nc19l0aan","tag_id":"cmg0saj49001sjm8n00ra9jet","_id":"cmg0saj4h0034jm8n751r2rxz"},{"post_id":"cmg0saj4g002vjm8ndtvg7ye1","tag_id":"cmg0saj49001sjm8n00ra9jet","_id":"cmg0saj4h0035jm8ngz6chonj"},{"post_id":"cmg0saj49001wjm8ndm6x7og0","tag_id":"cmg0saj4g002wjm8nbhd9122w","_id":"cmg0saj4h0036jm8n93yvf7jy"},{"post_id":"cmg0saj4a0024jm8n3j5o7rye","tag_id":"cmg0saj4g002zjm8n78b089ui","_id":"cmg0saj4h0037jm8n82wsgmfu"},{"post_id":"cmg0saj4j0038jm8n7xjac0xl","tag_id":"cmg0saj49001sjm8n00ra9jet","_id":"cmg0saj4k003ajm8nbz1s3aoh"},{"post_id":"cmg0saj4k0039jm8n1fr9gest","tag_id":"cmg0saj3k0002jm8n376dfv0m","_id":"cmg0saj4k003bjm8n7miohxc6"}],"Tag":[{"name":"问题解决","_id":"cmg0saj3k0002jm8n376dfv0m"},{"name":"数学建模","_id":"cmg0saj3l0003jm8n3zt81cp5"},{"name":"程序开发","_id":"cmg0saj3t0008jm8n8d866ssj"},{"name":"深度学习","_id":"cmg0saj3v000cjm8nc802e081"},{"name":"算法练习","_id":"cmg0saj3z000ujm8n2ykrfp92"},{"name":"深度学习 论文阅读","_id":"cmg0saj48001njm8ngu9gc0qs"},{"name":"课程学习","_id":"cmg0saj49001sjm8n00ra9jet"},{"name":"算法学习","_id":"cmg0saj4g002wjm8nbhd9122w"},{"name":"深度学习 程序开发","_id":"cmg0saj4g002zjm8n78b089ui"}]}}